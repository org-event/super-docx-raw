"use strict";
const superEditor_converter = require("./SuperConverter--V0Gvst5.cjs");
const jszip = require("./jszip-C8_CqJxM.cjs");
const helpers$1 = require("./helpers-C7_u3NNJ.cjs");
const vue = require("./vue-De9wkgLl.cjs");
require("./jszip.min-BPh2MMAa.cjs");
const eventemitter3 = require("./eventemitter3-BQuRcMPI.cjs");
const uuid = require("./uuid-R7L08bOx.cjs");
const blankDocx = require("./blank-docx-DfW3Eeh2.cjs");
const Y$1 = require("yjs");
const superEditor_docxZipper = require("../super-editor/docx-zipper.cjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k2 in e) {
      if (k2 !== "default") {
        const d = Object.getOwnPropertyDescriptor(e, k2);
        Object.defineProperty(n, k2, d.get ? d : {
          enumerable: true,
          get: () => e[k2]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const Y__namespace = /* @__PURE__ */ _interopNamespaceDefault(Y$1);
function getExtensionConfigField(extension, field, context = { name: "" }) {
  const fieldValue = extension.config[field];
  if (typeof fieldValue === "function") {
    const boundValue = fieldValue.bind({ ...context });
    return boundValue;
  }
  return fieldValue;
}
function callOrGet(value, context = null, ...props) {
  if (typeof value === "function") {
    const fn2 = value;
    if (context) return fn2.bind(context)(...props);
    return fn2(...props);
  }
  return value;
}
let Node$1 = class Node2 {
  constructor(config) {
    this.type = "node";
    this.name = "node";
    this.config = {
      ...config,
      name: config.name || this.name
    };
    this.name = this.config.name;
    this.group = this.config.group;
    if (this.config.addOptions) {
      this.options = callOrGet(
        getExtensionConfigField(this, "addOptions", {
          name: this.name
        })
      ) || {};
    } else {
      this.options = {};
    }
    this.storage = callOrGet(
      getExtensionConfigField(this, "addStorage", {
        name: this.name,
        options: this.options
      })
    ) || {};
  }
  /**
   * Factory method to construct a new Node extension.
   * @param config - The node configuration.
   * @returns A new Node instance.
   */
  static create(config) {
    return new Node2(config);
  }
};
class Mark {
  constructor(config) {
    this.type = "mark";
    this.name = "mark";
    this.config = {
      ...config,
      name: config.name || this.name
    };
    this.name = this.config.name;
    this.isExternal = Boolean(this.config.isExternal);
    if (this.config.addOptions) {
      this.options = callOrGet(
        getExtensionConfigField(this, "addOptions", {
          name: this.name
        })
      ) || {};
    } else {
      this.options = {};
    }
    this.storage = callOrGet(
      getExtensionConfigField(this, "addStorage", {
        name: this.name,
        options: this.options
      })
    ) || {};
  }
  /**
   * Static method for creating Mark extension.
   * @param config Configuration for the mark.
   */
  static create(config) {
    return new Mark(config);
  }
}
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
const isMacOS = () => {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
};
const isIOS = () => {
  if (typeof navigator === "undefined") return false;
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(
    navigator.platform
  );
};
function deleteProps(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  const removeNested = (target, pathParts, index2 = 0) => {
    if (!target || typeof target !== "object") {
      return false;
    }
    const key2 = pathParts[index2];
    const isLast = index2 === pathParts.length - 1;
    if (!(key2 in target)) {
      return Object.keys(target).length === 0;
    }
    if (isLast) {
      delete target[key2];
    } else {
      const shouldDeleteChild = removeNested(target[key2], pathParts, index2 + 1);
      if (shouldDeleteChild) {
        delete target[key2];
      }
    }
    return Object.keys(target).length === 0;
  };
  const clonedObj = JSON.parse(JSON.stringify(obj));
  props.forEach((propPath) => {
    if (!propPath.includes(".")) {
      delete clonedObj[propPath];
      return;
    }
    removeNested(clonedObj, propPath.split("."));
  });
  return Object.entries(clonedObj).reduce((acc, [key2, value]) => {
    if (value == null) {
      return acc;
    }
    if (typeof value === "object" && Object.keys(value).length === 0) {
      return acc;
    }
    acc[key2] = value;
    return acc;
  }, {});
}
const CSS_DIMENSION_REGEX = /[\d-.]+(\w+)$/;
const DOM_SIZE_UNITS = ["px", "rem", "em", "in", "q", "mm", "cm", "pt", "pc", "vh", "vw", "vmin", "vmax"];
function parseSizeUnit(val = "0") {
  const length2 = val.toString() || "0";
  const value = Number.parseFloat(length2);
  const match = length2.match(CSS_DIMENSION_REGEX);
  const unit = (match?.[1] ?? "").toLowerCase();
  return [value, DOM_SIZE_UNITS.includes(unit) ? unit : null];
}
function minMax(value = 0, min2 = 0, max2 = 0) {
  return Math.min(Math.max(value, min2), max2);
}
function createDocument(converter, schema, editor, { check = false } = {}) {
  const documentData = converter.getSchema(editor);
  if (documentData) {
    const documentNode = schema.nodeFromJSON(documentData);
    if (check) {
      documentNode.check();
    }
    return documentNode;
  }
  return schema.topNodeType.createAndFill();
}
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function cleanSchemaItem(schemaItem) {
  const entries = Object.entries(schemaItem).filter(([key2, value]) => {
    if (key2 === "attrs" && isEmptyObject(value)) {
      return false;
    }
    return value !== null && value !== void 0;
  });
  return Object.fromEntries(entries);
}
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}' in schema.`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}' in schema.`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
function defaultBlockAt$1(match) {
  for (let i = 0; i < match.edgeCount; i++) {
    const { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs()) return type;
  }
  return null;
}
const isList = (name, extensions) => {
  const nodeExtensions = extensions.filter((e) => e.type === "node");
  const extension = nodeExtensions.find((i) => i.name === name);
  if (!extension) return false;
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrGet(getExtensionConfigField(extension, "group", context));
  if (typeof group !== "string") return false;
  return group.split(" ").includes("list");
};
function generateDocxListAttributes(listType) {
  const listTypesMap = {
    bulletList: 1,
    orderedList: 2
  };
  return {
    attributes: {
      parentAttributes: {
        "w14:paraId": superEditor_converter.generateDocxRandomId(),
        "w14:textId": superEditor_converter.generateDocxRandomId(),
        "w:rsidR": superEditor_converter.generateDocxRandomId(),
        "w:rsidRDefault": superEditor_converter.generateDocxRandomId(),
        "w:rsidP": superEditor_converter.generateDocxRandomId(),
        paragraphProperties: {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:pStyle",
              attributes: {
                "w:val": "ListParagraph"
              }
            },
            {
              type: "element",
              name: "w:numPr",
              elements: [
                {
                  type: "element",
                  name: "w:ilvl",
                  attributes: {
                    "w:val": "0"
                  }
                },
                {
                  type: "element",
                  name: "w:numId",
                  attributes: {
                    "w:val": listTypesMap[listType] || 0
                  }
                }
              ]
            }
          ]
        }
      }
    }
  };
}
const isTextSelection = (value) => {
  return value instanceof superEditor_converter.TextSelection;
};
function findMarkInSet(marks, type, attrs = {}) {
  return marks.find((item) => {
    return item.type === type && superEditor_converter.objectIncludes(item.attrs, attrs);
  });
}
function isMarkInSet(marks, type, attrs = {}) {
  return !!findMarkInSet(marks, type, attrs);
}
function getMarkRange($pos, type, attrs = {}) {
  if (!$pos || !type) return;
  let start2 = $pos.parent.childAfter($pos.parentOffset);
  if ($pos.parentOffset === start2.offset && start2.offset !== 0) {
    start2 = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start2.node) return;
  const mark = findMarkInSet([...start2.node.marks], type, attrs);
  if (!mark) return;
  let startIndex = start2.index;
  let startPos = $pos.start() + start2.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start2.node.nodeSize;
  findMarkInSet([...start2.node.marks], type, attrs);
  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attrs)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return { from: startPos, to: endPos };
}
function isMarkActive(state, typeOrName, attrs = {}) {
  const { empty: empty2, ranges } = state.selection;
  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;
  if (empty2) {
    return !!(state.storedMarks || state.selection.$from.marks()).filter((mark) => {
      if (!type) return true;
      return type.name === mark.type.name;
    }).find((mark) => superEditor_converter.objectIncludes(mark.attrs, attrs, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from3 = $from.pos;
    const to = $to.pos;
    state.doc.nodesBetween(from3, to, (node, pos) => {
      if (!node.isText && !node.marks.length) return;
      const relativeFrom = Math.max(from3, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      const range2 = relativeTo - relativeFrom;
      selectionRange += range2;
      markRanges.push(
        ...node.marks.map((mark) => ({
          mark,
          from: relativeFrom,
          to: relativeTo
        }))
      );
    });
  });
  if (selectionRange === 0) return false;
  const matchedRange = markRanges.filter((markRange) => {
    if (!type) return true;
    return type.name === markRange.mark.type.name;
  }).filter((markRange) => superEditor_converter.objectIncludes(markRange.mark.attrs, attrs, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type) return true;
    return markRange.mark.type !== type && markRange.mark.type.excludes(type);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range >= selectionRange;
}
function getMarksBetween(from3, to, doc2) {
  const marks = [];
  if (from3 === to) {
    doc2.resolve(from3).marks().forEach((mark) => {
      const $pos = doc2.resolve(from3 - 1);
      const range = getMarkRange($pos, mark.type);
      if (!range) {
        return;
      }
      marks.push({
        mark,
        ...range
      });
    });
  } else {
    doc2.nodesBetween(from3, to, (node, pos) => {
      if (!node || node?.nodeSize === void 0) {
        return;
      }
      marks.push(
        ...node.marks.map((mark) => ({
          from: pos,
          to: pos + node.nodeSize,
          mark
        }))
      );
    });
  }
  return marks;
}
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) return "node";
  if (schema.marks[name]) return "mark";
  return null;
}
function isNodeActive(state, typeOrName, attrs = {}) {
  const { from: from3, to, empty: empty2 } = state.selection;
  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;
  const nodeRanges = [];
  state.doc.nodesBetween(from3, to, (node, pos) => {
    if (node.isText) return;
    const relativeFrom = Math.max(from3, pos);
    const relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from3;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type) return true;
    return type.name === nodeRange.node.type.name;
  }).filter((nodeRange) => superEditor_converter.objectIncludes(nodeRange.node.attrs, attrs, { strict: false }));
  if (empty2) return !!matchedNodeRanges.length;
  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range >= selectionRange;
}
function isActive(state, name, attrs = {}) {
  if (!name) {
    return isNodeActive(state, null, attrs) || isMarkActive(state, null, attrs);
  }
  const schemaType = getSchemaTypeNameByName(name, state.schema);
  if (schemaType === "node") {
    return isNodeActive(state, name, attrs);
  }
  if (schemaType === "mark") {
    return isMarkActive(state, name, attrs);
  }
  return false;
}
function getMarksFromSelection(state) {
  const { from: from3, to, empty: empty2 } = state.selection;
  const marks = [];
  if (empty2) {
    if (state.storedMarks) {
      marks.push(...state.storedMarks);
    }
    marks.push(...state.selection.$head.marks());
  } else {
    state.doc.nodesBetween(from3, to, (node) => {
      marks.push(...node.marks);
    });
  }
  return marks;
}
const findMark = (state, markType, toArr = false) => {
  const { selection, doc: doc2 } = state;
  const { $from, $to } = selection;
  const fromMark = $from.marks().find((mark) => mark.type === markType);
  const toMark = $to.marks().find((mark) => mark.type === markType);
  let markFound;
  const marksFound = [];
  doc2.nodesBetween($from.pos, $to.pos, (node, from3) => {
    if (node.marks) {
      const actualMark = node.marks.find((mark) => mark.type === markType);
      if (actualMark) {
        markFound = {
          from: from3,
          to: from3 + node.nodeSize,
          attrs: actualMark.attrs,
          contained: !fromMark || !toMark || fromMark === toMark
        };
        marksFound.push(markFound);
      }
    }
  });
  if (toArr) {
    return marksFound;
  }
  return markFound;
};
function getActiveFormatting(editor) {
  const { state } = editor;
  const { selection } = state;
  const marks = getMarksFromSelection(state);
  const markAttrs = selection.$head.parent.attrs.marksAttrs;
  const marksToProcess = marks.filter((mark) => !["textStyle", "link"].includes(mark.type.name)).map((mark) => ({ name: mark.type.name, attrs: mark.attrs }));
  const textStyleMarks = marks.filter((mark) => mark.type.name === "textStyle");
  marksToProcess.push(...textStyleMarks.flatMap(unwrapTextMarks));
  if (markAttrs) {
    const marksFromAttrs = markAttrs.filter((mark) => !["textStyle", "link"].includes(mark.type)).map((mark) => ({ name: mark.type, attrs: mark.attrs || {} }));
    const textStyleMarksFromAttrs = markAttrs.filter((mark) => mark.type === "textStyle");
    marksToProcess.push(...marksFromAttrs);
    marksToProcess.push(...textStyleMarksFromAttrs.flatMap(unwrapTextMarks));
  }
  const linkMarkType = state.schema.marks["link"];
  const linkMark = findMark(state, linkMarkType);
  if (linkMark) {
    let { from: from3, to, attrs } = linkMark;
    if (selection.from >= from3 && selection.to <= to) {
      marksToProcess.push({ name: "link", attrs });
    }
  }
  const ignoreKeys = ["paragraphSpacing"];
  const attributes = getActiveAttributes(state);
  Object.keys(attributes).forEach((key2) => {
    if (ignoreKeys.includes(key2)) return;
    const attrs = {};
    attrs[key2] = attributes[key2];
    marksToProcess.push({ name: key2, attrs });
  });
  const textColor = marksToProcess.find((i) => i.name === "textColor");
  const textHightlight = marksToProcess.find((i) => i.name === "textHighlight");
  if (textColor) {
    marksToProcess.push({
      name: "color",
      attrs: { color: textColor.attrs?.textColor }
    });
  }
  if (textHightlight) {
    marksToProcess.push({
      name: "highlight",
      attrs: { color: textHightlight.attrs?.textHighlight }
    });
  }
  const hasPendingFormatting = !!editor.storage.formatCommands?.storedStyle;
  if (hasPendingFormatting) marksToProcess.push({ name: "copyFormat", attrs: true });
  return marksToProcess;
}
function unwrapTextMarks(textStyleMark) {
  const processedMarks = [];
  const { attrs } = textStyleMark;
  Object.keys(attrs).forEach((key2) => {
    if (!attrs[key2]) return;
    processedMarks.push({ name: key2, attrs: { [key2]: attrs[key2] } });
  });
  return processedMarks;
}
function getActiveAttributes(state) {
  try {
    const { from: from3, to, empty: empty2 } = state.selection;
    const attributes = {};
    const getAttrs2 = (node) => {
      Object.keys(node.attrs).forEach((key2) => {
        const value = node.attrs[key2];
        if (value) {
          attributes[key2] = value;
        }
      });
    };
    let start2 = from3;
    let end2 = to;
    if (empty2) state.doc.nodesBetween(start2, end2 + 1, (node) => getAttrs2(node));
    else state.doc.nodesBetween(from3, to, (node) => getAttrs2(node));
    return attributes;
  } catch {
    return {};
  }
}
function findChildren$5(node, predicate) {
  const nodesWithPos = [];
  node.descendants((child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos
      });
    }
  });
  return nodesWithPos;
}
function posToDOMRect(view, from3, to) {
  const minPos = 0;
  const maxPos = view.state.doc.content.size;
  const resolvedFrom = minMax(from3, minPos, maxPos);
  const resolvedEnd = minMax(to, minPos, maxPos);
  const start2 = view.coordsAtPos(resolvedFrom);
  const end2 = view.coordsAtPos(resolvedEnd, -1);
  const top2 = Math.min(start2.top, end2.top);
  const bottom2 = Math.max(start2.bottom, end2.bottom);
  const left2 = Math.min(start2.left, end2.left);
  const right2 = Math.max(start2.right, end2.right);
  const width = right2 - left2;
  const height = bottom2 - top2;
  const x = left2;
  const y2 = top2;
  const data = {
    top: top2,
    bottom: bottom2,
    left: left2,
    right: right2,
    width,
    height,
    x,
    y: y2
  };
  return {
    ...data,
    toJSON: () => data
  };
}
const isInTable$1 = (state) => {
  const { $head } = state.selection;
  for (let d = $head.depth; d > 0; d -= 1) {
    if ($head.node(d).type?.spec?.tableRole === "row") {
      return true;
    }
  }
  return false;
};
function processContent({ content, type, editor }) {
  if (!editor) {
    throw new Error("[processContent] Editor instance is required");
  }
  if (!editor.schema) {
    throw new Error("[processContent] Editor schema is not initialized");
  }
  if (content === null || content === void 0) {
    throw new Error("[processContent] Content is required and cannot be null or undefined");
  }
  const domDocument = editor?.options?.document ?? editor?.options?.mockDocument ?? (typeof document !== "undefined" ? document : null);
  let doc2;
  switch (type) {
    case "html":
      if (!domDocument) {
        throw new Error(
          "[processContent] HTML processing requires a DOM. Provide { document } (e.g. from JSDOM), set DOM globals, or run in a browser environment."
        );
      }
      doc2 = superEditor_converter.createDocFromHTML(content, editor, { isImport: true, document: domDocument });
      break;
    case "markdown":
      if (!domDocument) {
        throw new Error(
          "[processContent] Markdown processing requires a DOM. Provide { document } (e.g. from JSDOM), set DOM globals, or run in a browser environment."
        );
      }
      doc2 = superEditor_converter.createDocFromMarkdown(content, editor, { isImport: true, document: domDocument });
      break;
    case "text":
      if (!domDocument) {
        throw new Error(
          "[processContent] Text processing requires a DOM. Provide { document } (e.g. from JSDOM), set DOM globals, or run in a browser environment."
        );
      }
      const wrapper = domDocument.createElement("div");
      wrapper.dataset.superdocImport = "true";
      const para = domDocument.createElement("p");
      para.textContent = content;
      wrapper.appendChild(para);
      doc2 = superEditor_converter.DOMParser.fromSchema(editor.schema).parse(wrapper);
      doc2 = superEditor_converter.wrapTextsInRuns(doc2);
      break;
    case "schema":
      doc2 = editor.schema.nodeFromJSON(content);
      doc2 = superEditor_converter.wrapTextsInRuns(doc2);
      break;
    default:
      throw new Error(
        `[processContent] Unknown content type: ${type}. Expected 'html', 'markdown', 'text', or 'schema'.`
      );
  }
  return doc2;
}
const defaultBooleans = ["required", "readonly", "disabled", "checked", "multiple", "autofocus"];
function updateDOMAttributes(dom, attrs = {}, options = {}) {
  const customBooleans = options.customBooleans || [];
  const booleans = [...defaultBooleans, ...customBooleans];
  Object.entries(attrs).forEach(([key2, value]) => {
    if (booleans.includes(key2)) {
      if (!value) dom.removeAttribute(key2);
      else dom.setAttribute(key2, "");
      return;
    }
    if (value != null) {
      dom.setAttribute(key2, value);
    } else {
      dom.removeAttribute(key2);
    }
  });
}
const MAX_INLINE_NAVIGATION_ITERATIONS = 8;
const computeChangeRange = (original, suggested) => {
  const origLen = original.length;
  const suggLen = suggested.length;
  let prefix2 = 0;
  while (prefix2 < origLen && prefix2 < suggLen && original[prefix2] === suggested[prefix2]) {
    prefix2++;
  }
  if (prefix2 === origLen && prefix2 === suggLen) {
    return { prefix: prefix2, suffix: 0, hasChange: false };
  }
  let suffix2 = 0;
  while (suffix2 < origLen - prefix2 && suffix2 < suggLen - prefix2 && original[origLen - 1 - suffix2] === suggested[suggLen - 1 - suffix2]) {
    suffix2++;
  }
  return { prefix: prefix2, suffix: suffix2, hasChange: true };
};
const resolveInlineTextPosition$1 = (doc2, position, direction) => {
  const docSize = doc2.content.size;
  if (position < 0 || position > docSize) {
    return position;
  }
  const step = direction === "forward" ? 1 : -1;
  let current = position;
  let iterations = 0;
  while (iterations < MAX_INLINE_NAVIGATION_ITERATIONS) {
    iterations++;
    const resolved = doc2.resolve(current);
    const boundaryNode = direction === "forward" ? resolved.nodeAfter : resolved.nodeBefore;
    if (!boundaryNode || boundaryNode.isText) {
      break;
    }
    if (!boundaryNode.isInline || boundaryNode.isAtom || boundaryNode.content.size === 0) {
      break;
    }
    const next = current + step;
    if (next < 0 || next > docSize) {
      break;
    }
    current = next;
    const adjacent = doc2.resolve(current);
    const checkNode = direction === "forward" ? adjacent.nodeAfter : adjacent.nodeBefore;
    if (checkNode && checkNode.isText) {
      break;
    }
  }
  return current;
};
const mapCharOffsetToPosition = (doc2, from3, to, charOffset) => {
  const docSize = doc2.content.size;
  if (from3 < 0 || from3 >= docSize || from3 >= to) {
    return from3;
  }
  const resolvedFrom = resolveInlineTextPosition$1(doc2, from3, "forward");
  if (charOffset <= 0) {
    return resolvedFrom;
  }
  const totalTextLength = doc2.textBetween(resolvedFrom, to, "", "").length;
  if (totalTextLength <= 0) {
    return resolvedFrom;
  }
  const targetOffset = Math.min(charOffset, totalTextLength);
  let low = resolvedFrom;
  let high = to;
  while (low < high) {
    const mid = Math.floor((low + high) / 2);
    const textLength = doc2.textBetween(resolvedFrom, mid, "", "").length;
    if (textLength < targetOffset) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  const mappedPosition = Math.min(low, to);
  const direction = targetOffset === totalTextLength ? "backward" : "forward";
  return resolveInlineTextPosition$1(doc2, mappedPosition, direction);
};
const getFirstTextMarks = (doc2, from3, to) => {
  const docSize = doc2.content.size;
  if (from3 < 0 || to > docSize || from3 > to) {
    return null;
  }
  let firstMarks = null;
  doc2.nodesBetween(from3, to, (node) => {
    if (node.isText) {
      firstMarks = node.marks;
      return false;
    }
  });
  return firstMarks;
};
const getMarksAtPosition = (state, position) => {
  if (state.storedMarks?.length) {
    return [...state.storedMarks];
  }
  const resolved = state.doc.resolve(position);
  return [...resolved.marks()];
};
const buildTextNodes = (state, from3, to, suggestedText) => {
  if (!suggestedText) {
    return [];
  }
  const { schema } = state;
  const firstMarks = getFirstTextMarks(state.doc, from3, to);
  const marks = firstMarks ? [...firstMarks] : getMarksAtPosition(state, from3);
  return [schema.text(suggestedText, marks)];
};
const _testInternals = {
  computeChangeRange,
  resolveInlineTextPosition: resolveInlineTextPosition$1,
  mapCharOffsetToPosition,
  getFirstTextMarks,
  getMarksAtPosition,
  buildTextNodes
};
const applyPatch = ({ state, tr, from: from3, to, suggestedText }) => {
  if (!state?.doc) {
    return { tr, changed: false };
  }
  const docSize = state.doc.content.size;
  if (from3 < 0 || to > docSize || from3 > to) {
    return { tr, changed: false };
  }
  const originalText = state.doc.textBetween(from3, to, "", "");
  const { prefix: prefix2, suffix: suffix2, hasChange } = computeChangeRange(originalText, suggestedText);
  if (!hasChange) {
    return { tr, changed: false };
  }
  const changeFrom = mapCharOffsetToPosition(state.doc, from3, to, prefix2);
  const originalTextLength = originalText.length;
  const changeTo = mapCharOffsetToPosition(state.doc, from3, to, originalTextLength - suffix2);
  const replacementEnd = suggestedText.length - suffix2;
  const replacementText = suggestedText.slice(prefix2, replacementEnd);
  if (!replacementText) {
    tr.delete(changeFrom, changeTo);
    return { tr, changed: true };
  }
  const nodes = buildTextNodes(state, changeFrom, changeTo, replacementText);
  tr.replaceWith(changeFrom, changeTo, superEditor_converter.Fragment.fromArray(nodes));
  return { tr, changed: true };
};
const helpers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _testInternals,
  applyPatch,
  chainableEditorState: superEditor_converter.chainableEditorState,
  cleanSchemaItem,
  convertMarkdownToHTML: superEditor_converter.convertMarkdownToHTML,
  createDocFromHTML: superEditor_converter.createDocFromHTML,
  createDocFromMarkdown: superEditor_converter.createDocFromMarkdown,
  createDocument,
  defaultBlockAt: defaultBlockAt$1,
  findChildren: findChildren$5,
  findMark,
  findParentNode: superEditor_converter.findParentNode,
  findParentNodeClosestToPos: superEditor_converter.findParentNodeClosestToPos,
  generateDocxListAttributes,
  generateDocxRandomId: superEditor_converter.generateDocxRandomId,
  generateRandom32BitHex: superEditor_converter.generateRandom32BitHex,
  generateRandomSigned32BitIntStrId: superEditor_converter.generateRandomSigned32BitIntStrId,
  getActiveFormatting,
  getExtensionConfigField,
  getMarkRange,
  getMarkType,
  getMarksBetween,
  getMarksFromSelection,
  getNodeType,
  getSchemaTypeByName,
  getSchemaTypeNameByName,
  isActive,
  isInTable: isInTable$1,
  isList,
  isMarkActive,
  isNodeActive,
  isTextSelection,
  posToDOMRect,
  processContent,
  updateDOMAttributes
}, Symbol.toStringTag, { value: "Module" }));
const comments_module_events = {
  RESOLVED: "resolved",
  NEW: "new",
  ADD: "add",
  UPDATE: "update",
  DELETED: "deleted",
  PENDING: "pending",
  SELECTED: "selected",
  // Comments list
  COMMENTS_LIST: "comments-list",
  // Tracked changes
  CHANGE_ACCEPTED: "change-accepted",
  CHANGE_REJECTED: "change-rejected"
};
function hasV8CaptureStackTrace(error) {
  return typeof error.captureStackTrace === "function";
}
class FileObjectError extends Error {
  constructor(message, cause) {
    super(message);
    this.cause = cause;
    this.name = "FileObjectError";
    if (hasV8CaptureStackTrace(Error)) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}
class InvalidDataUriError extends FileObjectError {
  constructor(uri) {
    super(`Invalid data URI format: URI must contain exactly one comma separator`);
    this.uri = uri;
    this.name = "InvalidDataUriError";
  }
}
class FetchFailedError extends FileObjectError {
  constructor(url, cause) {
    super(`Failed to fetch file from URL: ${url}`, cause);
    this.url = url;
    this.name = "FetchFailedError";
  }
}
const getFileObject = async (fileUrl, name, type) => {
  try {
    if (fileUrl.startsWith("data:") && fileUrl.includes(";base64,")) {
      const parts = fileUrl.split(",");
      if (parts.length !== 2) {
        throw new InvalidDataUriError(fileUrl);
      }
      const binary = atob(parts[1]);
      const bytes = Uint8Array.from(binary, (c2) => c2.charCodeAt(0));
      return new File([bytes], name, { type });
    }
    const response = await fetch(fileUrl);
    if (!response.ok) {
      throw new FetchFailedError(fileUrl, new Error(`HTTP ${response.status}: ${response.statusText}`));
    }
    const blob = await response.blob();
    return new File([blob], name, { type });
  } catch (error) {
    if (error instanceof FileObjectError) {
      throw error;
    }
    throw new FileObjectError("Failed to create file object", error);
  }
};
const vClickOutside = {
  mounted(el, binding) {
    const clickOutsideHandler = (event) => {
      if (!el.contains(event.target)) {
        binding.value?.(event);
      }
    };
    document.addEventListener("click", clickOutsideHandler);
    el.__clickOutsideHandler = clickOutsideHandler;
  },
  unmounted(el) {
    if (el.__clickOutsideHandler) {
      document.removeEventListener("click", el.__clickOutsideHandler);
      delete el.__clickOutsideHandler;
    }
  }
};
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice(from3, to) {
  if (from3 === void 0) from3 = 0;
  if (to === void 0) to = this.length;
  if (from3 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from3), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) {
    return void 0;
  }
  return this.getInner(i);
};
RopeSequence.prototype.forEach = function forEach(f, from3, to) {
  if (from3 === void 0) from3 = 0;
  if (to === void 0) to = this.length;
  if (from3 <= to) {
    this.forEachInner(f, from3, to, 0);
  } else {
    this.forEachInvertedInner(f, from3, to, 0);
  }
};
RopeSequence.prototype.map = function map(f, from3, to) {
  if (from3 === void 0) from3 = 0;
  if (to === void 0) to = this.length;
  var result = [];
  this.forEach(function(elt, i) {
    return result.push(f(elt, i));
  }, from3, to);
  return result;
};
RopeSequence.from = function from(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ (function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  if (RopeSequence3) Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten2() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from3, to) {
    if (from3 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from3, to));
  };
  Leaf2.prototype.getInner = function getInner(i) {
    return this.values[i];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f, from3, to, start2) {
    for (var i = from3; i < to; i++) {
      if (f(this.values[i], start2 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from3, to, start2) {
    for (var i = from3 - 1; i >= to; i--) {
      if (f(this.values[i], start2 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors);
  return Leaf2;
})(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ (function(RopeSequence3) {
  function Append2(left2, right2) {
    RopeSequence3.call(this);
    this.left = left2;
    this.right = right2;
    this.length = left2.length + right2.length;
    this.depth = Math.max(left2.depth, right2.depth) + 1;
  }
  if (RopeSequence3) Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten2() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f, from3, to, start2) {
    var leftLen = this.left.length;
    if (from3 < leftLen && this.left.forEachInner(f, from3, Math.min(to, leftLen), start2) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f, Math.max(from3 - leftLen, 0), Math.min(this.length, to) - leftLen, start2 + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from3, to, start2) {
    var leftLen = this.left.length;
    if (from3 > leftLen && this.right.forEachInvertedInner(f, from3 - leftLen, Math.max(to, leftLen) - leftLen, start2 + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from3, leftLen), to, start2) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from3, to) {
    if (from3 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from3, to);
    }
    if (from3 >= leftLen) {
      return this.right.slice(from3 - leftLen, to - leftLen);
    }
    return this.left.slice(from3, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
})(RopeSequence);
const max_empty_items = 500;
class Branch {
  constructor(items, eventCount) {
    this.items = items;
    this.eventCount = eventCount;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(state, preserveItems) {
    if (this.eventCount == 0)
      return null;
    let end2 = this.items.length;
    for (; ; end2--) {
      let next = this.items.get(end2 - 1);
      if (next.selection) {
        --end2;
        break;
      }
    }
    let remap, mapFrom;
    if (preserveItems) {
      remap = this.remapping(end2, this.items.length);
      mapFrom = remap.maps.length;
    }
    let transform = state.tr;
    let selection, remaining;
    let addAfter = [], addBefore = [];
    this.items.forEach((item, i) => {
      if (!item.step) {
        if (!remap) {
          remap = this.remapping(end2, i + 1);
          mapFrom = remap.maps.length;
        }
        mapFrom--;
        addBefore.push(item);
        return;
      }
      if (remap) {
        addBefore.push(new Item(item.map));
        let step = item.step.map(remap.slice(mapFrom)), map3;
        if (step && transform.maybeStep(step).doc) {
          map3 = transform.mapping.maps[transform.mapping.maps.length - 1];
          addAfter.push(new Item(map3, void 0, void 0, addAfter.length + addBefore.length));
        }
        mapFrom--;
        if (map3)
          remap.appendMap(map3, mapFrom);
      } else {
        transform.maybeStep(item.step);
      }
      if (item.selection) {
        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
        remaining = new Branch(this.items.slice(0, end2).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
        return false;
      }
    }, this.items.length, 0);
    return { remaining, transform, selection };
  }
  // Create a new branch with the given transform added.
  addTransform(transform, selection, histOptions, preserveItems) {
    let newItems = [], eventCount = this.eventCount;
    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
    for (let i = 0; i < transform.steps.length; i++) {
      let step = transform.steps[i].invert(transform.docs[i]);
      let item = new Item(transform.mapping.maps[i], step, selection), merged;
      if (merged = lastItem && lastItem.merge(item)) {
        item = merged;
        if (i)
          newItems.pop();
        else
          oldItems = oldItems.slice(0, oldItems.length - 1);
      }
      newItems.push(item);
      if (selection) {
        eventCount++;
        selection = void 0;
      }
      if (!preserveItems)
        lastItem = item;
    }
    let overflow = eventCount - histOptions.depth;
    if (overflow > DEPTH_OVERFLOW) {
      oldItems = cutOffEvents(oldItems, overflow);
      eventCount -= overflow;
    }
    return new Branch(oldItems.append(newItems), eventCount);
  }
  remapping(from3, to) {
    let maps = new superEditor_converter.Mapping();
    this.items.forEach((item, i) => {
      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from3 ? maps.maps.length - item.mirrorOffset : void 0;
      maps.appendMap(item.map, mirrorPos);
    }, from3, to);
    return maps;
  }
  addMaps(array) {
    if (this.eventCount == 0)
      return this;
    return new Branch(this.items.append(array.map((map3) => new Item(map3))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(rebasedTransform, rebasedCount) {
    if (!this.eventCount)
      return this;
    let rebasedItems = [], start2 = Math.max(0, this.items.length - rebasedCount);
    let mapping = rebasedTransform.mapping;
    let newUntil = rebasedTransform.steps.length;
    let eventCount = this.eventCount;
    this.items.forEach((item) => {
      if (item.selection)
        eventCount--;
    }, start2);
    let iRebased = rebasedCount;
    this.items.forEach((item) => {
      let pos = mapping.getMirror(--iRebased);
      if (pos == null)
        return;
      newUntil = Math.min(newUntil, pos);
      let map3 = mapping.maps[pos];
      if (item.step) {
        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
        if (selection)
          eventCount++;
        rebasedItems.push(new Item(map3, step, selection));
      } else {
        rebasedItems.push(new Item(map3));
      }
    }, start2);
    let newMaps = [];
    for (let i = rebasedCount; i < newUntil; i++)
      newMaps.push(new Item(mapping.maps[i]));
    let items = this.items.slice(0, start2).append(newMaps).append(rebasedItems);
    let branch = new Branch(items, eventCount);
    if (branch.emptyItemCount() > max_empty_items)
      branch = branch.compress(this.items.length - rebasedItems.length);
    return branch;
  }
  emptyItemCount() {
    let count = 0;
    this.items.forEach((item) => {
      if (!item.step)
        count++;
    });
    return count;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(upto = this.items.length) {
    let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
    let items = [], events2 = 0;
    this.items.forEach((item, i) => {
      if (i >= upto) {
        items.push(item);
        if (item.selection)
          events2++;
      } else if (item.step) {
        let step = item.step.map(remap.slice(mapFrom)), map3 = step && step.getMap();
        mapFrom--;
        if (map3)
          remap.appendMap(map3, mapFrom);
        if (step) {
          let selection = item.selection && item.selection.map(remap.slice(mapFrom));
          if (selection)
            events2++;
          let newItem = new Item(map3.invert(), step, selection), merged, last = items.length - 1;
          if (merged = items.length && items[last].merge(newItem))
            items[last] = merged;
          else
            items.push(newItem);
        }
      } else if (item.map) {
        mapFrom--;
      }
    }, this.items.length, 0);
    return new Branch(RopeSequence.from(items.reverse()), events2);
  }
}
Branch.empty = new Branch(RopeSequence.empty, 0);
function cutOffEvents(items, n) {
  let cutPoint;
  items.forEach((item, i) => {
    if (item.selection && n-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}
class Item {
  constructor(map3, step, selection, mirrorOffset) {
    this.map = map3;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }
  merge(other) {
    if (this.step && other.step && !other.selection) {
      let step = other.step.merge(this.step);
      if (step)
        return new Item(step.getMap().invert(), step, this.selection);
    }
  }
}
class HistoryState {
  constructor(done, undone, prevRanges, prevTime, prevComposition) {
    this.done = done;
    this.undone = undone;
    this.prevRanges = prevRanges;
    this.prevTime = prevTime;
    this.prevComposition = prevComposition;
  }
}
const DEPTH_OVERFLOW = 20;
function applyTransaction(history2, state, tr, options) {
  let historyTr = tr.getMeta(historyKey), rebased;
  if (historyTr)
    return historyTr.historyState;
  if (tr.getMeta(closeHistoryKey))
    history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
  let appended = tr.getMeta("appendedTransaction");
  if (tr.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      return new HistoryState(history2.done.addTransform(tr, void 0, options, mustPreserveItems(state)), history2.undone, rangesFor(tr.mapping.maps), history2.prevTime, history2.prevComposition);
    else
      return new HistoryState(history2.done, history2.undone.addTransform(tr, void 0, options, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);
  } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    let composition = tr.getMeta("composition");
    let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history2.prevRanges));
    let prevRanges = appended ? mapRanges(history2.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);
    return new HistoryState(history2.done.addTransform(tr, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history2.prevComposition : composition);
  } else if (rebased = tr.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr, rebased), history2.undone.rebased(tr, rebased), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);
  } else {
    return new HistoryState(history2.done.addMaps(tr.mapping.maps), history2.undone.addMaps(tr.mapping.maps), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges)
    return false;
  if (!transform.docChanged)
    return true;
  let adjacent = false;
  transform.mapping.maps[0].forEach((start2, end2) => {
    for (let i = 0; i < prevRanges.length; i += 2)
      if (start2 <= prevRanges[i + 1] && end2 >= prevRanges[i])
        adjacent = true;
  });
  return adjacent;
}
function rangesFor(maps) {
  let result = [];
  for (let i = maps.length - 1; i >= 0 && result.length == 0; i--)
    maps[i].forEach((_from, _to, from3, to) => result.push(from3, to));
  return result;
}
function mapRanges(ranges, mapping) {
  if (!ranges)
    return null;
  let result = [];
  for (let i = 0; i < ranges.length; i += 2) {
    let from3 = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
    if (from3 <= to)
      result.push(from3, to);
  }
  return result;
}
function histTransaction(history2, state, redo2) {
  let preserveItems = mustPreserveItems(state);
  let histOptions = historyKey.get(state).spec.config;
  let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop)
    return null;
  let selection = pop.selection.resolve(pop.transform.doc);
  let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
  return pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist });
}
let cachedPreserveItems = false, cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  let plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (let i = 0; i < plugins.length; i++)
      if (plugins[i].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
const historyKey = new superEditor_converter.PluginKey("history");
const closeHistoryKey = new superEditor_converter.PluginKey("closeHistory");
function history(config = {}) {
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new superEditor_converter.Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
      },
      apply(tr, hist, state) {
        return applyTransaction(hist, state, tr, config);
      }
    },
    config,
    props: {
      handleDOMEvents: {
        beforeinput(view, e) {
          let inputType = e.inputType;
          let command2 = inputType == "historyUndo" ? undo$1 : inputType == "historyRedo" ? redo$1 : null;
          if (!command2 || !view.editable)
            return false;
          e.preventDefault();
          return command2(view.state, view.dispatch);
        }
      }
    }
  });
}
function buildCommand(redo2, scroll) {
  return (state, dispatch) => {
    let hist = historyKey.getState(state);
    if (!hist || (redo2 ? hist.undone : hist.done).eventCount == 0)
      return false;
    if (dispatch) {
      let tr = histTransaction(hist, state, redo2);
      if (tr)
        dispatch(scroll ? tr.scrollIntoView() : tr);
    }
    return true;
  };
}
const undo$1 = buildCommand(false, true);
const redo$1 = buildCommand(true, true);
function undoDepth(state) {
  let hist = historyKey.getState(state);
  return hist ? hist.done.eventCount : 0;
}
function redoDepth(state) {
  let hist = historyKey.getState(state);
  return hist ? hist.undone.eventCount : 0;
}
const domIndex = function(node) {
  for (var index2 = 0; ; index2++) {
    node = node.previousSibling;
    if (!node)
      return index2;
  }
};
const parentNode = function(node) {
  let parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
let reusedRange = null;
const textRange = function(node, from3, to) {
  let range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from3 || 0);
  return range;
};
const clearReusedRange = function() {
  reusedRange = null;
};
const isEquivalentPosition = function(node, off2, targetNode, targetOff) {
  return targetNode && (scanFor(node, off2, targetNode, targetOff, -1) || scanFor(node, off2, targetNode, targetOff, 1));
};
const atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node, off2, targetNode, targetOff, dir) {
  var _a;
  for (; ; ) {
    if (node == targetNode && off2 == targetOff)
      return true;
    if (off2 == (dir < 0 ? 0 : nodeSize(node))) {
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        return false;
      off2 = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      let child = node.childNodes[off2 + (dir < 0 ? -1 : 0)];
      if (child.nodeType == 1 && child.contentEditable == "false") {
        if ((_a = child.pmViewDesc) === null || _a === void 0 ? void 0 : _a.ignoreForSelection)
          off2 += dir;
        else
          return false;
      } else {
        node = child;
        off2 = dir < 0 ? nodeSize(node) : 0;
      }
    } else {
      return false;
    }
  }
}
function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function textNodeBefore$1(node, offset2) {
  for (; ; ) {
    if (node.nodeType == 3 && offset2)
      return node;
    if (node.nodeType == 1 && offset2 > 0) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset2 - 1];
      offset2 = nodeSize(node);
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset2 = domIndex(node);
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter$1(node, offset2) {
  for (; ; ) {
    if (node.nodeType == 3 && offset2 < node.nodeValue.length)
      return node;
    if (node.nodeType == 1 && offset2 < node.childNodes.length) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset2];
      offset2 = 0;
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset2 = domIndex(node) + 1;
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function isOnEdge(node, offset2, parent) {
  for (let atStart = offset2 == 0, atEnd = offset2 == nodeSize(node); atStart || atEnd; ) {
    if (node == parent)
      return true;
    let index2 = domIndex(node);
    node = node.parentNode;
    if (!node)
      return false;
    atStart = atStart && index2 == 0;
    atEnd = atEnd && index2 == nodeSize(node);
  }
}
function hasBlockDesc(dom) {
  let desc;
  for (let cur = dom; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
const selectionCollapsed = function(domSel) {
  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
};
function keyEvent(keyCode, key2) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key2;
  return event;
}
function deepActiveElement(doc2) {
  let elt = doc2.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function caretFromPoint(doc2, x, y2) {
  if (doc2.caretPositionFromPoint) {
    try {
      let pos = doc2.caretPositionFromPoint(x, y2);
      if (pos)
        return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };
    } catch (_2) {
    }
  }
  if (doc2.caretRangeFromPoint) {
    let range = doc2.caretRangeFromPoint(x, y2);
    if (range)
      return { node: range.startContainer, offset: Math.min(nodeSize(range.startContainer), range.startOffset) };
  }
}
const nav = typeof navigator != "undefined" ? navigator : null;
const doc$1 = typeof document != "undefined" ? document : null;
const agent = nav && nav.userAgent || "";
const ie_edge = /Edge\/(\d+)/.exec(agent);
const ie_upto10 = /MSIE \d/.exec(agent);
const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
const ie$1 = !!(ie_upto10 || ie_11up || ie_edge);
const ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
const gecko = !ie$1 && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
const _chrome = !ie$1 && /Chrome\/(\d+)/.exec(agent);
const chrome = !!_chrome;
const chrome_version = _chrome ? +_chrome[1] : 0;
const safari = !ie$1 && !!nav && /Apple Computer/.test(nav.vendor);
const ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
const mac$2 = ios || (nav ? /Mac/.test(nav.platform) : false);
const windows$1 = nav ? /Win/.test(nav.platform) : false;
const android = /Android \d/.test(agent);
const webkit = !!doc$1 && "webkitFontSmoothing" in doc$1.documentElement.style;
const webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function windowRect(doc2) {
  let vp = doc2.defaultView && doc2.defaultView.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: doc2.documentElement.clientWidth,
    top: 0,
    bottom: doc2.documentElement.clientHeight
  };
}
function getSide(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node) {
  let rect = node.getBoundingClientRect();
  let scaleX = rect.width / node.offsetWidth || 1;
  let scaleY = rect.height / node.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  let doc2 = view.dom.ownerDocument;
  for (let parent = startDOM || view.dom; ; ) {
    if (!parent)
      break;
    if (parent.nodeType != 1) {
      parent = parentNode(parent);
      continue;
    }
    let elt = parent;
    let atTop = elt == doc2.body;
    let bounding = atTop ? windowRect(doc2) : clientRect(elt);
    let moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, "bottom"))
      moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc2.defaultView.scrollBy(moveX, moveY);
      } else {
        let startX = elt.scrollLeft, startY = elt.scrollTop;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    let pos = atTop ? "fixed" : getComputedStyle(parent).position;
    if (/^(fixed|sticky)$/.test(pos))
      break;
    parent = pos == "absolute" ? parent.offsetParent : parentNode(parent);
  }
}
function storeScrollPos(view) {
  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  let refDOM, refTop;
  for (let x = (rect.left + rect.right) / 2, y2 = startY + 1; y2 < Math.min(innerHeight, rect.bottom); y2 += 5) {
    let dom = view.root.elementFromPoint(x, y2);
    if (!dom || dom == view.dom || !view.dom.contains(dom))
      continue;
    let localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  let stack2 = [], doc2 = dom.ownerDocument;
  for (let cur = dom; cur; cur = parentNode(cur)) {
    stack2.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom == doc2)
      break;
  }
  return stack2;
}
function resetScrollPos({ refDOM, refTop, stack: stack2 }) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack2, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack2, dTop) {
  for (let i = 0; i < stack2.length; i++) {
    let { dom, top: top2, left: left2 } = stack2[i];
    if (dom.scrollTop != top2 + dTop)
      dom.scrollTop = top2 + dTop;
    if (dom.scrollLeft != left2)
      dom.scrollLeft = left2;
  }
}
let preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node, coords) {
  let closest, dxClosest = 2e8, coordsClosest, offset2 = 0;
  let rowBot = coords.top, rowTop = coords.top;
  let firstBelow, coordsBelow;
  for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    let rects;
    if (child.nodeType == 1)
      rects = child.getClientRects();
    else if (child.nodeType == 3)
      rects = textRange(child).getClientRects();
    else
      continue;
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx)
            offset2 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
        firstBelow = child;
        coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
        offset2 = childIndex + 1;
    }
  }
  if (!closest && firstBelow) {
    closest = firstBelow;
    coordsClosest = coordsBelow;
    dxClosest = 0;
  }
  if (closest && closest.nodeType == 3)
    return findOffsetInText(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1)
    return { node, offset: offset2 };
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node, coords) {
  let len = node.nodeValue.length;
  let range = document.createRange(), result;
  for (let i = 0; i < len; i++) {
    range.setEnd(node, i + 1);
    range.setStart(node, i);
    let rect = singleRect(range, 1);
    if (rect.top == rect.bottom)
      continue;
    if (inRect(coords, rect)) {
      result = { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
      break;
    }
  }
  range.detach();
  return result || { node, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  let parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    return parent;
  return dom;
}
function posFromElement(view, elt, coords) {
  let { node, offset: offset2 } = findOffsetInNode(elt, coords), bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    let rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset2, bias);
}
function posFromCaret(view, node, offset2, coords) {
  let outsideBlock = -1;
  for (let cur = node, sawBlock = false; ; ) {
    if (cur == view.dom)
      break;
    let desc = view.docView.nearestDesc(cur, true), rect;
    if (!desc)
      return null;
    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {
      if (desc.node.isBlock && desc.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(desc.dom.nodeName)) {
        if (!sawBlock && rect.left > coords.left || rect.top > coords.top)
          outsideBlock = desc.posBefore;
        else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)
          outsideBlock = desc.posAfter;
        sawBlock = true;
      }
      if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
        let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before ? desc.posBefore : desc.posAfter;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset2, -1);
}
function elementFromPoint(element, coords, box) {
  let len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
      let child = element.childNodes[i];
      if (child.nodeType == 1) {
        let rects = child.getClientRects();
        for (let j = 0; j < rects.length; j++) {
          let rect = rects[j];
          if (inRect(coords, rect))
            return elementFromPoint(child, coords, rect);
        }
      }
      if ((i = (i + 1) % len) == startI)
        break;
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  let doc2 = view.dom.ownerDocument, node, offset2 = 0;
  let caret = caretFromPoint(doc2, coords.left, coords.top);
  if (caret)
    ({ node, offset: offset2 } = caret);
  let elt = (view.root.elementFromPoint ? view.root : doc2).elementFromPoint(coords.left, coords.top);
  let pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box))
      return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt)
      return null;
  }
  if (safari) {
    for (let p2 = elt; node && p2; p2 = parentNode(p2))
      if (p2.draggable)
        node = void 0;
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (gecko && node.nodeType == 1) {
      offset2 = Math.min(offset2, node.childNodes.length);
      if (offset2 < node.childNodes.length) {
        let next = node.childNodes[offset2], box;
        if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
          offset2++;
      }
    }
    let prev;
    if (webkit && offset2 && node.nodeType == 1 && (prev = node.childNodes[offset2 - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
      offset2--;
    if (node == view.dom && offset2 == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    else if (offset2 == 0 || node.nodeType != 1 || node.childNodes[offset2 - 1].nodeName != "BR")
      pos = posFromCaret(view, node, offset2, coords);
  }
  if (pos == null)
    pos = posFromElement(view, elt, coords);
  let desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function nonZero(rect) {
  return rect.top < rect.bottom || rect.left < rect.right;
}
function singleRect(target, bias) {
  let rects = target.getClientRects();
  if (rects.length) {
    let first2 = rects[bias < 0 ? 0 : rects.length - 1];
    if (nonZero(first2))
      return first2;
  }
  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
}
const BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  let { node, offset: offset2, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  let supportEmptyRange = webkit || gecko;
  if (node.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset2 : offset2 == node.nodeValue.length))) {
      let rect = singleRect(textRange(node, offset2, offset2), side);
      if (gecko && offset2 && /\s/.test(node.nodeValue[offset2 - 1]) && offset2 < node.nodeValue.length) {
        let rectBefore = singleRect(textRange(node, offset2 - 1, offset2 - 1), -1);
        if (rectBefore.top == rect.top) {
          let rectAfter = singleRect(textRange(node, offset2, offset2 + 1), -1);
          if (rectAfter.top != rect.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      let from3 = offset2, to = offset2, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset2) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset2 == node.nodeValue.length) {
        from3--;
        takeSide = 1;
      } else if (side < 0) {
        from3--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node, from3, to), takeSide), takeSide < 0);
    }
  }
  let $dom = view.state.doc.resolve(pos - (atom || 0));
  if (!$dom.parent.inlineContent) {
    if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
      let before = node.childNodes[offset2 - 1];
      if (before.nodeType == 1)
        return flattenH(before.getBoundingClientRect(), false);
    }
    if (atom == null && offset2 < nodeSize(node)) {
      let after = node.childNodes[offset2];
      if (after.nodeType == 1)
        return flattenH(after.getBoundingClientRect(), true);
    }
    return flattenH(node.getBoundingClientRect(), side >= 0);
  }
  if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
    let before = node.childNodes[offset2 - 1];
    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
    if (target)
      return flattenV(singleRect(target, 1), false);
  }
  if (atom == null && offset2 < nodeSize(node)) {
    let after = node.childNodes[offset2];
    while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
      after = after.nextSibling;
    let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
    if (target)
      return flattenV(singleRect(target, -1), true);
  }
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}
function flattenV(rect, left2) {
  if (rect.width == 0)
    return rect;
  let x = left2 ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top2) {
  if (rect.height == 0)
    return rect;
  let y2 = top2 ? rect.top : rect.bottom;
  return { top: y2, bottom: y2, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f) {
  let viewState = view.state, active = view.root.activeElement;
  if (viewState != state)
    view.updateState(state);
  if (active != view.dom)
    view.focus();
  try {
    return f();
  } finally {
    if (viewState != state)
      view.updateState(viewState);
    if (active != view.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical(view, state, dir) {
  let sel = state.selection;
  let $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, () => {
    let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    for (; ; ) {
      let nearest = view.docView.nearestDesc(dom, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom = nearest.contentDOM || nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    let coords = coordsAtPos(view, $pos.pos, 1);
    for (let child = dom.firstChild; child; child = child.nextSibling) {
      let boxes;
      if (child.nodeType == 1)
        boxes = child.getClientRects();
      else if (child.nodeType == 3)
        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      else
        continue;
      for (let i = 0; i < boxes.length; i++) {
        let box = boxes[i];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          return false;
      }
    }
    return true;
  });
}
const maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  let { $head } = state.selection;
  if (!$head.parent.isTextblock)
    return false;
  let offset2 = $head.parentOffset, atStart = !offset2, atEnd = offset2 == $head.parent.content.size;
  let sel = view.domSelection();
  if (!sel)
    return $head.pos == $head.start() || $head.pos == $head.end();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, () => {
    let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
    let oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
    let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
        sel.extend(oldNode, oldOff);
    } catch (_2) {
    }
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}
let cachedState = null;
let cachedDir = null;
let cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir)
    return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
const NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;
class ViewDesc {
  constructor(parent, children, dom, contentDOM) {
    this.parent = parent;
    this.children = children;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(widget) {
    return false;
  }
  matchesMark(mark) {
    return false;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return false;
  }
  matchesHack(nodeName) {
    return false;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(event) {
    return false;
  }
  // The size of the content represented by this desc.
  get size() {
    let size2 = 0;
    for (let i = 0; i < this.children.length; i++)
      size2 += this.children[i].size;
    return size2;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0;
    if (this.dom.pmViewDesc == this)
      this.dom.pmViewDesc = void 0;
    for (let i = 0; i < this.children.length; i++)
      this.children[i].destroy();
  }
  posBeforeChild(child) {
    for (let i = 0, pos = this.posAtStart; ; i++) {
      let cur = this.children[i];
      if (cur == child)
        return pos;
      pos += cur.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(dom, offset2, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
      if (bias < 0) {
        let domBefore, desc;
        if (dom == this.contentDOM) {
          domBefore = dom.childNodes[offset2 - 1];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domBefore = dom.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
          domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        let domAfter, desc;
        if (dom == this.contentDOM) {
          domAfter = dom.childNodes[offset2];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domAfter = dom.nextSibling;
        }
        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
          domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
      }
    }
    let atEnd;
    if (dom == this.dom && this.contentDOM) {
      atEnd = offset2 > domIndex(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset2 == 0)
        for (let search2 = dom; ; search2 = search2.parentNode) {
          if (search2 == this.dom) {
            atEnd = false;
            break;
          }
          if (search2.previousSibling)
            break;
        }
      if (atEnd == null && offset2 == dom.childNodes.length)
        for (let search2 = dom; ; search2 = search2.parentNode) {
          if (search2 == this.dom) {
            atEnd = true;
            break;
          }
          if (search2.nextSibling)
            break;
        }
    }
    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(dom, onlyNodes = false) {
    for (let first2 = true, cur = dom; cur; cur = cur.parentNode) {
      let desc = this.getDesc(cur), nodeDOM;
      if (desc && (!onlyNodes || desc.node)) {
        if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
          first2 = false;
        else
          return desc;
      }
    }
  }
  getDesc(dom) {
    let desc = dom.pmViewDesc;
    for (let cur = desc; cur; cur = cur.parent)
      if (cur == this)
        return desc;
  }
  posFromDOM(dom, offset2, bias) {
    for (let scan = dom; scan; scan = scan.parentNode) {
      let desc = this.getDesc(scan);
      if (desc)
        return desc.localPosFromDOM(dom, offset2, bias);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(pos) {
    for (let i = 0, offset2 = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (offset2 == pos && end2 != offset2) {
        while (!child.border && child.children.length) {
          for (let i2 = 0; i2 < child.children.length; i2++) {
            let inner = child.children[i2];
            if (inner.size) {
              child = inner;
              break;
            }
          }
        }
        return child;
      }
      if (pos < end2)
        return child.descAt(pos - offset2 - child.border);
      offset2 = end2;
    }
  }
  domFromPos(pos, side) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: pos + 1 };
    let i = 0, offset2 = 0;
    for (let curPos = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = curPos + child.size;
      if (end2 > pos || child instanceof TrailingHackViewDesc) {
        offset2 = pos - curPos;
        break;
      }
      curPos = end2;
    }
    if (offset2)
      return this.children[i].domFromPos(offset2 - this.children[i].border, side);
    for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {
    }
    if (side <= 0) {
      let prev, enter = true;
      for (; ; i--, enter = false) {
        prev = i ? this.children[i - 1] : null;
        if (!prev || prev.dom.parentNode == this.contentDOM)
          break;
      }
      if (prev && side && enter && !prev.border && !prev.domAtom)
        return prev.domFromPos(prev.size, side);
      return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
    } else {
      let next, enter = true;
      for (; ; i++, enter = false) {
        next = i < this.children.length ? this.children[i] : null;
        if (!next || next.dom.parentNode == this.contentDOM)
          break;
      }
      if (next && enter && !next.border && !next.domAtom)
        return next.domFromPos(0, side);
      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(from3, to, base2 = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: from3, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let fromOffset = -1, toOffset = -1;
    for (let offset2 = base2, i = 0; ; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (fromOffset == -1 && from3 <= end2) {
        let childBase = offset2 + child.border;
        if (from3 >= childBase && to <= end2 - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
          return child.parseRange(from3, to, childBase);
        from3 = offset2;
        for (let j = i; j > 0; j--) {
          let prev = this.children[j - 1];
          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
            fromOffset = domIndex(prev.dom) + 1;
            break;
          }
          from3 -= prev.size;
        }
        if (fromOffset == -1)
          fromOffset = 0;
      }
      if (fromOffset > -1 && (end2 > to || i == this.children.length - 1)) {
        to = end2;
        for (let j = i + 1; j < this.children.length; j++) {
          let next = this.children[j];
          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
            toOffset = domIndex(next.dom);
            break;
          }
          to += next.size;
        }
        if (toOffset == -1)
          toOffset = this.contentDOM.childNodes.length;
        break;
      }
      offset2 = end2;
    }
    return { node: this.contentDOM, from: from3, to, fromOffset, toOffset };
  }
  emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    let child = this.children[side < 0 ? 0 : this.children.length - 1];
    return child.size == 0 || child.emptyChildAt(side);
  }
  domAfterPos(pos) {
    let { node, offset: offset2 } = this.domFromPos(pos, 0);
    if (node.nodeType != 1 || offset2 == node.childNodes.length)
      throw new RangeError("No node after pos " + pos);
    return node.childNodes[offset2];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(anchor, head, view, force = false) {
    let from3 = Math.min(anchor, head), to = Math.max(anchor, head);
    for (let i = 0, offset2 = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (from3 > offset2 && to < end2)
        return child.setSelection(anchor - offset2 - child.border, head - offset2 - child.border, view, force);
      offset2 = end2;
    }
    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    let domSel = view.root.getSelection();
    let selRange = view.domSelectionRange();
    let brKludge = false;
    if ((gecko || safari) && anchor == head) {
      let { node, offset: offset2 } = anchorDOM;
      if (node.nodeType == 3) {
        brKludge = !!(offset2 && node.nodeValue[offset2 - 1] == "\n");
        if (brKludge && offset2 == node.nodeValue.length) {
          for (let scan = node, after; scan; scan = scan.parentNode) {
            if (after = scan.nextSibling) {
              if (after.nodeName == "BR")
                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
              break;
            }
            let desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock)
              break;
          }
        }
      } else {
        let prev = node.childNodes[offset2 - 1];
        brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
      }
    }
    if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {
      let after = selRange.focusNode.childNodes[selRange.focusOffset];
      if (after && after.contentEditable == "false")
        force = true;
    }
    if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))
      return;
    let domSelExtended = false;
    if ((domSel.extend || anchor == head) && !(brKludge && gecko)) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head)
          domSel.extend(headDOM.node, headDOM.offset);
        domSelExtended = true;
      } catch (_2) {
      }
    }
    if (!domSelExtended) {
      if (anchor > head) {
        let tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      let range = document.createRange();
      range.setEnd(headDOM.node, headDOM.offset);
      range.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range);
    }
  }
  ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(from3, to) {
    for (let offset2 = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (offset2 == end2 ? from3 <= end2 && to >= offset2 : from3 < end2 && to > offset2) {
        let startInside = offset2 + child.border, endInside = end2 - child.border;
        if (from3 >= startInside && to <= endInside) {
          this.dirty = from3 == offset2 || to == end2 ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from3 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
            child.dirty = NODE_DIRTY;
          else
            child.markDirty(from3 - startInside, to - startInside);
          return;
        } else {
          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
        }
      }
      offset2 = end2;
    }
    this.dirty = CONTENT_DIRTY;
  }
  markParentsDirty() {
    let level = 1;
    for (let node = this.parent; node; node = node.parent, level++) {
      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      if (node.dirty < dirty)
        node.dirty = dirty;
    }
  }
  get domAtom() {
    return false;
  }
  get ignoreForCoords() {
    return false;
  }
  get ignoreForSelection() {
    return false;
  }
  isText(text) {
    return false;
  }
}
class WidgetViewDesc extends ViewDesc {
  constructor(parent, widget, view, pos) {
    let self2, dom = widget.type.toDOM;
    if (typeof dom == "function")
      dom = dom(view, () => {
        if (!self2)
          return pos;
        if (self2.parent)
          return self2.parent.posBeforeChild(self2);
      });
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        let wrap = document.createElement("span");
        wrap.appendChild(dom);
        dom = wrap;
      }
      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }
    super(parent, [], dom, null);
    this.widget = widget;
    this.widget = widget;
    self2 = this;
  }
  matchesWidget(widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: true };
  }
  stopEvent(event) {
    let stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false;
  }
  ignoreMutation(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom);
    super.destroy();
  }
  get domAtom() {
    return true;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
}
class CompositionViewDesc extends ViewDesc {
  constructor(parent, dom, textDOM, text) {
    super(parent, [], dom, null);
    this.textDOM = textDOM;
    this.text = text;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(dom, offset2) {
    if (dom != this.textDOM)
      return this.posAtStart + (offset2 ? this.size : 0);
    return this.posAtStart + offset2;
  }
  domFromPos(pos) {
    return { node: this.textDOM, offset: pos };
  }
  ignoreMutation(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  }
}
class MarkViewDesc extends ViewDesc {
  constructor(parent, mark, dom, contentDOM, spec) {
    super(parent, [], dom, contentDOM);
    this.mark = mark;
    this.spec = spec;
  }
  static create(parent, mark, inline, view) {
    let custom = view.nodeViews[mark.type.name];
    let spec = custom && custom(mark, view, inline);
    if (!spec || !spec.dom)
      spec = superEditor_converter.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);
    return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);
  }
  parseRule() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
      return null;
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(mark) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark);
  }
  markDirty(from3, to) {
    super.markDirty(from3, to);
    if (this.dirty != NOT_DIRTY) {
      let parent = this.parent;
      while (!parent.node)
        parent = parent.parent;
      if (parent.dirty < this.dirty)
        parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY;
    }
  }
  slice(from3, to, view) {
    let copy = MarkViewDesc.create(this.parent, this.mark, true, view);
    let nodes = this.children, size2 = this.size;
    if (to < size2)
      nodes = replaceNodes(nodes, to, size2, view);
    if (from3 > 0)
      nodes = replaceNodes(nodes, 0, from3, view);
    for (let i = 0; i < nodes.length; i++)
      nodes[i].parent = copy;
    copy.children = nodes;
    return copy;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
}
class NodeViewDesc extends ViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    super(parent, [], dom, contentDOM);
    this.node = node;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    this.nodeDOM = nodeDOM;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(parent, node, outerDeco, innerDeco, view, pos) {
    let custom = view.nodeViews[node.type.name], descObj;
    let spec = custom && custom(node, view, () => {
      if (!descObj)
        return pos;
      if (descObj.parent)
        return descObj.parent.posBeforeChild(descObj);
    }, outerDeco, innerDeco);
    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node.isText) {
      if (!dom)
        dom = document.createTextNode(node.text);
      else if (dom.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else if (!dom) {
      let spec2 = superEditor_converter.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);
      ({ dom, contentDOM } = spec2);
    }
    if (!contentDOM && !node.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable"))
        dom.contentEditable = "false";
      if (node.type.spec.draggable)
        dom.draggable = true;
    }
    let nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node);
    if (spec)
      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
    else if (node.isText)
      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
    else
      return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre")
      rule.preserveWhitespace = "full";
    if (!this.contentDOM) {
      rule.getContent = () => this.node.content;
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (let i = this.children.length - 1; i >= 0; i--) {
        let child = this.children[i];
        if (this.dom.contains(child.dom.parentNode)) {
          rule.contentElement = child.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement)
        rule.getContent = () => superEditor_converter.Fragment.empty;
    }
    return rule;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(view, pos) {
    let inline = this.node.inlineContent, off2 = pos;
    let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
    let localComposition = composition && composition.pos > -1 ? composition : null;
    let compositionInChild = composition && composition.pos < 0;
    let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
    iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {
      if (widget.spec.marks)
        updater.syncToMarks(widget.spec.marks, inline, view);
      else if (widget.type.side >= 0 && !insideNode)
        updater.syncToMarks(i == this.node.childCount ? superEditor_converter.Mark.none : this.node.child(i).marks, inline, view);
      updater.placeWidget(widget, view, off2);
    }, (child, outerDeco, innerDeco, i) => {
      updater.syncToMarks(child.marks, inline, view);
      let compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;
      else if (compositionInChild && view.state.selection.from > off2 && view.state.selection.to < off2 + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;
      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off2)) ;
      else {
        updater.addNode(child, outerDeco, innerDeco, view, off2);
      }
      off2 += child.nodeSize;
    });
    updater.syncToMarks([], inline, view);
    if (this.node.isTextblock)
      updater.addTextblockHacks();
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition)
        this.protectLocalComposition(view, localComposition);
      renderDescs(this.contentDOM, this.children, view);
      if (ios)
        iosHacks(this.dom);
    }
  }
  localCompositionInfo(view, pos) {
    let { from: from3, to } = view.state.selection;
    if (!(view.state.selection instanceof superEditor_converter.TextSelection) || from3 < pos || to > pos + this.node.content.size)
      return null;
    let textNode = view.input.compositionNode;
    if (!textNode || !this.dom.contains(textNode.parentNode))
      return null;
    if (this.node.inlineContent) {
      let text = textNode.nodeValue;
      let textPos = findTextInFragment(this.node.content, text, from3 - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text };
    } else {
      return { node: textNode, pos: -1, text: "" };
    }
  }
  protectLocalComposition(view, { node, pos, text }) {
    if (this.getDesc(node))
      return;
    let topNode = node;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM)
        break;
      while (topNode.previousSibling)
        topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling)
        topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc)
        topNode.pmViewDesc = void 0;
    }
    let desc = new CompositionViewDesc(this, topNode, node, text);
    view.input.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
      return false;
    this.updateInner(node, outerDeco, innerDeco, view);
    return true;
  }
  updateInner(node, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node;
    this.innerDeco = innerDeco;
    if (this.contentDOM)
      this.updateChildren(view, this.posAtStart);
    this.dirty = NOT_DIRTY;
  }
  updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco))
      return;
    let needsWrap = this.nodeDOM.nodeType != 1;
    let oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = void 0;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  }
  // Mark this node as being the selected node.
  selectNode() {
    if (this.nodeDOM.nodeType == 1) {
      this.nodeDOM.classList.add("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.nodeDOM.draggable = true;
    }
  }
  // Remove selected node marking from this node.
  deselectNode() {
    if (this.nodeDOM.nodeType == 1) {
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.nodeDOM.removeAttribute("draggable");
    }
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function docViewDesc(doc2, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc2);
  let docView = new NodeViewDesc(void 0, doc2, outerDeco, innerDeco, dom, dom, dom, view, 0);
  if (docView.contentDOM)
    docView.updateChildren(view, 0);
  return docView;
}
class TextViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
  }
  parseRule() {
    let skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco)
      skip = skip.parentNode;
    return { skip: skip || true };
  }
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
      return false;
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node.text;
      if (view.trackWrites == this.nodeDOM)
        view.trackWrites = null;
    }
    this.node = node;
    this.dirty = NOT_DIRTY;
    return true;
  }
  inParent() {
    let parentDOM = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == parentDOM)
        return true;
    return false;
  }
  domFromPos(pos) {
    return { node: this.nodeDOM, offset: pos };
  }
  localPosFromDOM(dom, offset2, bias) {
    if (dom == this.nodeDOM)
      return this.posAtStart + Math.min(offset2, this.node.text.length);
    return super.localPosFromDOM(dom, offset2, bias);
  }
  ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  }
  slice(from3, to, view) {
    let node = this.node.cut(from3, to), dom = document.createTextNode(node.text);
    return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
  }
  markDirty(from3, to) {
    super.markDirty(from3, to);
    if (this.dom != this.nodeDOM && (from3 == 0 || to == this.nodeDOM.nodeValue.length))
      this.dirty = NODE_DIRTY;
  }
  get domAtom() {
    return false;
  }
  isText(text) {
    return this.node.text == text;
  }
}
class TrailingHackViewDesc extends ViewDesc {
  parseRule() {
    return { ignore: true };
  }
  matchesHack(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  }
  get domAtom() {
    return true;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class CustomNodeViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY)
      return false;
    if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {
      let result = this.spec.update(node, outerDeco, innerDeco);
      if (result)
        this.updateInner(node, outerDeco, innerDeco, view);
      return result;
    } else if (!this.contentDOM && !node.isLeaf) {
      return false;
    } else {
      return super.update(node, outerDeco, innerDeco, view);
    }
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(anchor, head, view, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
  stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
}
function renderDescs(parentDOM, descs, view) {
  let dom = parentDOM.firstChild, written = false;
  for (let i = 0; i < descs.length; i++) {
    let desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      let pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM)
    view.trackWrites = null;
}
const OuterDecoLevel = function(nodeName) {
  if (nodeName)
    this.nodeName = nodeName;
};
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
const noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco;
  let top2 = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top2];
  for (let i = 0; i < outerDeco.length; i++) {
    let attrs = outerDeco[i].type.attrs;
    if (!attrs)
      continue;
    if (attrs.nodeName)
      result.push(top2 = new OuterDecoLevel(attrs.nodeName));
    for (let name in attrs) {
      let val = attrs[name];
      if (val == null)
        continue;
      if (needsWrap && result.length == 1)
        result.push(top2 = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class")
        top2.class = (top2.class ? top2.class + " " : "") + val;
      else if (name == "style")
        top2.style = (top2.style ? top2.style + ";" : "") + val;
      else if (name != "nodeName")
        top2[name] = val;
    }
  }
  return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco)
    return nodeDOM;
  let curDOM = nodeDOM;
  for (let i = 0; i < curComputed.length; i++) {
    let deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      let parent;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (let name in prev)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom.removeAttribute(name);
  for (let name in cur)
    if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
      dom.setAttribute(name, cur[name]);
  if (prev.class != cur.class) {
    let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
    let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (let i = 0; i < prevList.length; i++)
      if (curList.indexOf(prevList[i]) == -1)
        dom.classList.remove(prevList[i]);
    for (let i = 0; i < curList.length; i++)
      if (prevList.indexOf(curList[i]) == -1)
        dom.classList.add(curList[i]);
    if (dom.classList.length == 0)
      dom.removeAttribute("class");
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m2;
      while (m2 = prop.exec(prev.style))
        dom.style.removeProperty(m2[1]);
    }
    if (cur.style)
      dom.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
}
function sameOuterDeco(a, b2) {
  if (a.length != b2.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!a[i].type.eq(b2[i].type))
      return false;
  return true;
}
function rm(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
class ViewTreeUpdater {
  constructor(top2, lock, view) {
    this.lock = lock;
    this.view = view;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top2;
    this.preMatch = preMatch(top2.node.content, top2);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(start2, end2) {
    if (start2 == end2)
      return;
    for (let i = start2; i < end2; i++)
      this.top.children[i].destroy();
    this.top.children.splice(start2, end2 - start2);
    this.changed = true;
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(marks, inline, view) {
    let keep2 = 0, depth = this.stack.length >> 1;
    let maxKeep = Math.min(depth, marks.length);
    while (keep2 < maxKeep && (keep2 == depth - 1 ? this.top : this.stack[keep2 + 1 << 1]).matchesMark(marks[keep2]) && marks[keep2].type.spec.spanning !== false)
      keep2++;
    while (keep2 < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks.length) {
      this.stack.push(this.top, this.index + 1);
      let found = -1;
      for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
        let next = this.top.children[i];
        if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
          found = i;
          break;
        }
      }
      if (found > -1) {
        if (found > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found);
        }
        this.top = this.top.children[this.index];
      } else {
        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(node, outerDeco, innerDeco, index2) {
    let found = -1, targetDesc;
    if (index2 >= this.preMatch.index && (targetDesc = this.preMatch.matches[index2 - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
      found = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
        let child = this.top.children[i];
        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
          found = i;
          break;
        }
      }
    }
    if (found < 0)
      return false;
    this.destroyBetween(this.index, found);
    this.index++;
    return true;
  }
  updateNodeAt(node, outerDeco, innerDeco, index2, view) {
    let child = this.top.children[index2];
    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
      child.dirty = CONTENT_DIRTY;
    if (!child.update(node, outerDeco, innerDeco, view))
      return false;
    this.destroyBetween(this.index, index2);
    this.index++;
    return true;
  }
  findIndexWithChild(domNode) {
    for (; ; ) {
      let parent = domNode.parentNode;
      if (!parent)
        return -1;
      if (parent == this.top.contentDOM) {
        let desc = domNode.pmViewDesc;
        if (desc)
          for (let i = this.index; i < this.top.children.length; i++) {
            if (this.top.children[i] == desc)
              return i;
          }
        return -1;
      }
      domNode = parent;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(node, outerDeco, innerDeco, view, index2, pos) {
    for (let i = this.index; i < this.top.children.length; i++) {
      let next = this.top.children[i];
      if (next instanceof NodeViewDesc) {
        let preMatch2 = this.preMatch.matched.get(next);
        if (preMatch2 != null && preMatch2 != index2)
          return false;
        let nextDOM = next.dom, updated;
        let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
        if (!locked && next.update(node, outerDeco, innerDeco, view)) {
          this.destroyBetween(this.index, i);
          if (next.dom != nextDOM)
            this.changed = true;
          this.index++;
          return true;
        } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
          this.destroyBetween(this.index, i);
          this.top.children[this.index] = updated;
          if (updated.contentDOM) {
            updated.dirty = CONTENT_DIRTY;
            updated.updateChildren(view, pos + 1);
            updated.dirty = NOT_DIRTY;
          }
          this.changed = true;
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
    if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))
      return null;
    let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (wrapper.contentDOM) {
      wrapper.children = next.children;
      next.children = [];
      for (let ch of wrapper.children)
        ch.parent = wrapper;
    }
    next.destroy();
    return wrapper;
  }
  // Insert the node as a newly created node desc.
  addNode(node, outerDeco, innerDeco, view, pos) {
    let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (desc.contentDOM)
      desc.updateChildren(view, pos + 1);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
  placeWidget(widget, view, pos) {
    let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      let desc = new WidgetViewDesc(this.top, widget, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let lastChild = this.top.children[this.index - 1], parent = this.top;
    while (lastChild instanceof MarkViewDesc) {
      parent = lastChild;
      lastChild = parent.children[parent.children.length - 1];
    }
    if (!lastChild || // Empty textblock
    !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
      if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
        this.addHackNode("IMG", parent);
      this.addHackNode("BR", this.top);
    }
  }
  addHackNode(nodeName, parent) {
    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      let dom = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom.className = "ProseMirror-separator";
        dom.alt = "";
      }
      if (nodeName == "BR")
        dom.className = "ProseMirror-trailingBreak";
      let hack = new TrailingHackViewDesc(this.top, [], dom, null);
      if (parent != this.top)
        parent.children.push(hack);
      else
        parent.children.splice(this.index++, 0, hack);
      this.changed = true;
    }
  }
  isLocked(node) {
    return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
  }
}
function preMatch(frag, parentDesc) {
  let curDesc = parentDesc, descI = curDesc.children.length;
  let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches = [];
  outer: while (fI > 0) {
    let desc;
    for (; ; ) {
      if (descI) {
        let next = curDesc.children[descI - 1];
        if (next instanceof MarkViewDesc) {
          curDesc = next;
          descI = next.children.length;
        } else {
          desc = next;
          descI--;
          break;
        }
      } else if (curDesc == parentDesc) {
        break outer;
      } else {
        descI = curDesc.parent.children.indexOf(curDesc);
        curDesc = curDesc.parent;
      }
    }
    let node = desc.node;
    if (!node)
      continue;
    if (node != frag.child(fI - 1))
      break;
    --fI;
    matched.set(desc, fI);
    matches.push(desc);
  }
  return { index: fI, matched, matches: matches.reverse() };
}
function compareSide(a, b2) {
  return a.type.side - b2.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  let locals = deco.locals(parent), offset2 = 0;
  if (locals.length == 0) {
    for (let i = 0; i < parent.childCount; i++) {
      let child = parent.child(i);
      onNode(child, locals, deco.forChild(offset2, child), i);
      offset2 += child.nodeSize;
    }
    return;
  }
  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0; ; ) {
    let widget, widgets;
    while (decoIndex < locals.length && locals[decoIndex].to == offset2) {
      let next = locals[decoIndex++];
      if (next.widget) {
        if (!widget)
          widget = next;
        else
          (widgets || (widgets = [widget])).push(next);
      }
    }
    if (widget) {
      if (widgets) {
        widgets.sort(compareSide);
        for (let i = 0; i < widgets.length; i++)
          onWidget(widgets[i], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    let child, index2;
    if (restNode) {
      index2 = -1;
      child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index2 = parentIndex;
      child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (let i = 0; i < active.length; i++)
      if (active[i].to <= offset2)
        active.splice(i--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset2 && locals[decoIndex].to > offset2)
      active.push(locals[decoIndex++]);
    let end2 = offset2 + child.nodeSize;
    if (child.isText) {
      let cutAt = end2;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
        cutAt = locals[decoIndex].from;
      for (let i = 0; i < active.length; i++)
        if (active[i].to < cutAt)
          cutAt = active[i].to;
      if (cutAt < end2) {
        restNode = child.cut(cutAt - offset2);
        child = child.cut(0, cutAt - offset2);
        end2 = cutAt;
        index2 = -1;
      }
    } else {
      while (decoIndex < locals.length && locals[decoIndex].to < end2)
        decoIndex++;
    }
    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
    onNode(child, outerDeco, deco.forChild(offset2, child), index2);
    offset2 = end2;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    let oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function findTextInFragment(frag, text, from3, to) {
  for (let i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
    let child = frag.child(i++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText)
      continue;
    let str = child.text;
    while (i < frag.childCount) {
      let next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText)
        break;
      str += next.text;
    }
    if (pos >= from3) {
      if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text)
        return to - text.length;
      let found = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
      if (found >= 0 && found + text.length + childStart >= from3)
        return childStart + found;
      if (from3 == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text)
        return to;
    }
  }
  return -1;
}
function replaceNodes(nodes, from3, to, view, replacement) {
  let result = [];
  for (let i = 0, off2 = 0; i < nodes.length; i++) {
    let child = nodes[i], start2 = off2, end2 = off2 += child.size;
    if (start2 >= to || end2 <= from3) {
      result.push(child);
    } else {
      if (start2 < from3)
        result.push(child.slice(0, from3 - start2, view));
      if (replacement) {
        result.push(replacement);
        replacement = void 0;
      }
      if (end2 > to)
        result.push(child.slice(to - start2, child.size, view));
    }
  }
  return result;
}
function selectionFromDOM(view, origin = null) {
  let domSel = view.domSelectionRange(), doc2 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc2.resolve(head), anchor, selection;
  if (selectionCollapsed(domSel)) {
    anchor = head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    let nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && superEditor_converter.NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      let pos = nearestDesc.posBefore;
      selection = new superEditor_converter.NodeSelection(head == pos ? $head : doc2.resolve(pos));
    }
  } else {
    if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {
      let min2 = head, max2 = head;
      for (let i = 0; i < domSel.rangeCount; i++) {
        let range = domSel.getRangeAt(i);
        min2 = Math.min(min2, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));
        max2 = Math.max(max2, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));
      }
      if (min2 < 0)
        return null;
      [anchor, head] = max2 == view.state.selection.anchor ? [max2, min2] : [min2, max2];
      $head = doc2.resolve(head);
    } else {
      anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    }
    if (anchor < 0)
      return null;
  }
  let $anchor = doc2.resolve(anchor);
  if (!selection) {
    let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof superEditor_converter.TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
const brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  let { node, offset: offset2 } = view.docView.domFromPos(pos, 0);
  let after = offset2 < node.childNodes.length ? node.childNodes[offset2] : null;
  let before = offset2 ? node.childNodes[offset2 - 1] : null;
  if (safari && after && after.contentEditable == "false")
    return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after)
      return setEditable(after);
    else if (before)
      return setEditable(before);
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc2 = view.dom.ownerDocument;
  doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelectionRange();
  let node = domSel.anchorNode, offset2 = domSel.anchorOffset;
  doc2.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset2) {
      doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection();
  if (!domSel)
    return;
  let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img)
    domSel.collapse(node.parentNode, domIndex(node) + 1);
  else
    domSel.collapse(node, 0);
  if (!img && !view.state.selection.visible && ie$1 && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof superEditor_converter.NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || superEditor_converter.TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus())
    return false;
  return hasSelection(view);
}
function hasSelection(view) {
  let sel = view.domSelectionRange();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_2) {
    return false;
  }
}
function anchorInRightPlace(view) {
  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  let domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  let { $anchor, $head } = state.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && superEditor_converter.Selection.findFrom($start, dir);
}
function apply$1(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof superEditor_converter.TextSelection) {
    if (mods.indexOf("s") > -1) {
      let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
      if (!node || node.isText || !node.isLeaf)
        return false;
      let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
      return apply$1(view, new superEditor_converter.TextSelection(sel.$anchor, $newHead));
    } else if (!sel.empty) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof superEditor_converter.NodeSelection)
        return apply$1(view, next);
      return false;
    } else if (!(mac$2 && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node || node.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (superEditor_converter.NodeSelection.isSelectable(node)) {
        return apply$1(view, new superEditor_converter.NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
      } else if (webkit) {
        return apply$1(view, new superEditor_converter.TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof superEditor_converter.NodeSelection && sel.node.isInline) {
    return apply$1(view, new superEditor_converter.TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next)
      return apply$1(view, next);
    return false;
  }
}
function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isIgnorable(dom, dir) {
  let desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}
function skipIgnoredNodesBefore(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset2 = sel.focusOffset;
  if (!node)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko && node.nodeType == 1 && offset2 < nodeLen(node) && isIgnorable(node.childNodes[offset2], -1))
    force = true;
  for (; ; ) {
    if (offset2 > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        let before = node.childNodes[offset2 - 1];
        if (isIgnorable(before, -1)) {
          moveNode = node;
          moveOffset = --offset2;
        } else if (before.nodeType == 3) {
          node = before;
          offset2 = node.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      let prev = node.previousSibling;
      while (prev && isIgnorable(prev, -1)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset2 = 0;
      } else {
        node = prev;
        offset2 = nodeLen(node);
      }
    }
  }
  if (force)
    setSelFocus(view, node, offset2);
  else if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function skipIgnoredNodesAfter(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset2 = sel.focusOffset;
  if (!node)
    return;
  let len = nodeLen(node);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset2 < len) {
      if (node.nodeType != 1)
        break;
      let after = node.childNodes[offset2];
      if (isIgnorable(after, 1)) {
        moveNode = node;
        moveOffset = ++offset2;
      } else
        break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      let next = node.nextSibling;
      while (next && isIgnorable(next, 1)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset2 = len = 0;
      } else {
        node = next;
        offset2 = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function textNodeAfter(node, offset2) {
  while (node && offset2 == node.childNodes.length && !hasBlockDesc(node)) {
    offset2 = domIndex(node) + 1;
    node = node.parentNode;
  }
  while (node && offset2 < node.childNodes.length) {
    let next = node.childNodes[offset2];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset2 = 0;
  }
}
function textNodeBefore(node, offset2) {
  while (node && !offset2 && !hasBlockDesc(node)) {
    offset2 = domIndex(node);
    node = node.parentNode;
  }
  while (node && offset2) {
    let next = node.childNodes[offset2 - 1];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset2 = node.childNodes.length;
  }
}
function setSelFocus(view, node, offset2) {
  if (node.nodeType != 3) {
    let before, after;
    if (after = textNodeAfter(node, offset2)) {
      node = after;
      offset2 = 0;
    } else if (before = textNodeBefore(node, offset2)) {
      node = before;
      offset2 = before.nodeValue.length;
    }
  }
  let sel = view.domSelection();
  if (!sel)
    return;
  if (selectionCollapsed(sel)) {
    let range = document.createRange();
    range.setEnd(node, offset2);
    range.setStart(node, offset2);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset2);
  }
  view.domObserver.setCurSelection();
  let { state } = view;
  setTimeout(() => {
    if (view.state == state)
      selectionToDOM(view);
  }, 50);
}
function findDirection(view, pos) {
  let $pos = view.state.doc.resolve(pos);
  if (!(chrome || windows$1) && $pos.parent.inlineContent) {
    let coords = view.coordsAtPos(pos);
    if (pos > $pos.start()) {
      let before = view.coordsAtPos(pos - 1);
      let mid = (before.top + before.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
        return before.left < coords.left ? "ltr" : "rtl";
    }
    if (pos < $pos.end()) {
      let after = view.coordsAtPos(pos + 1);
      let mid = (after.top + after.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
        return after.left > coords.left ? "ltr" : "rtl";
    }
  }
  let computed = getComputedStyle(view.dom).direction;
  return computed == "rtl" ? "rtl" : "ltr";
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof superEditor_converter.TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac$2 && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof superEditor_converter.NodeSelection)
      return apply$1(view, next);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof superEditor_converter.AllSelection ? superEditor_converter.Selection.near(side, dir) : superEditor_converter.Selection.findFrom(side, dir);
    return beyond ? apply$1(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof superEditor_converter.TextSelection))
    return true;
  let { $head, $anchor, empty: empty2 } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty2)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr = view.state.tr;
    if (dir < 0)
      tr.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr);
    return true;
  }
  return false;
}
function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(() => switchEditable(view, child, "false"), 20);
  }
  return false;
}
function getMods(event) {
  let result = "";
  if (event.ctrlKey)
    result += "c";
  if (event.metaKey)
    result += "m";
  if (event.altKey)
    result += "a";
  if (event.shiftKey)
    result += "s";
  return result;
}
function captureKeyDown(view, event) {
  let code = event.keyCode, mods = getMods(event);
  if (code == 8 || mac$2 && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code == 46 && !event.shiftKey || mac$2 && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37 || mac$2 && code == 66 && mods == "c") {
    let dir = code == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 39 || mac$2 && code == 70 && mods == "c") {
    let dir = code == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 38 || mac$2 && code == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code == 40 || mac$2 && code == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
  } else if (mods == (mac$2 ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice2) {
  view.someProp("transformCopied", (f) => {
    slice2 = f(slice2, view);
  });
  let context = [], { content, openStart, openEnd } = slice2;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }
  let serializer = view.someProp("clipboardSerializer") || superEditor_converter.DOMSerializer.fromSchema(view.state.schema);
  let doc2 = detachedDoc(), wrap = doc2.createElement("div");
  wrap.appendChild(serializer.serializeFragment(content, { document: doc2 }));
  let firstChild = wrap.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i = needsWrap.length - 1; i >= 0; i--) {
      let wrapper = doc2.createElement(needsWrap[i]);
      while (wrap.firstChild)
        wrapper.appendChild(wrap.firstChild);
      wrap.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text = view.someProp("clipboardTextSerializer", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
  return { dom: wrap, text, slice: slice2 };
}
function parseFromClipboard(view, text, html, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom, slice2;
  if (!html && !text)
    return null;
  let asText = !!text && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", (f) => {
      text = f(text, inCode || plainText, view);
    });
    if (inCode) {
      slice2 = new superEditor_converter.Slice(superEditor_converter.Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0);
      view.someProp("transformPasted", (f) => {
        slice2 = f(slice2, view, true);
      });
      return slice2;
    }
    let parsed = view.someProp("clipboardTextParser", (f) => f(text, $context, plainText, view));
    if (parsed) {
      slice2 = parsed;
    } else {
      let marks = $context.marks();
      let { schema } = view.state, serializer = superEditor_converter.DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach((block) => {
        let p2 = dom.appendChild(document.createElement("p"));
        if (block)
          p2.appendChild(serializer.serializeNode(schema.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f) => {
      html = f(html, view);
    });
    dom = readHTML(html);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i = +sliceData[3]; i > 0; i--) {
      let child = dom.firstChild;
      while (child && child.nodeType != 1)
        child = child.nextSibling;
      if (!child)
        break;
      dom = child;
    }
  if (!slice2) {
    let parser = view.someProp("clipboardParser") || view.someProp("domParser") || superEditor_converter.DOMParser.fromSchema(view.state.schema);
    slice2 = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice2 = superEditor_converter.Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
    if (slice2.openStart || slice2.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
      }
      for (let node = slice2.content.lastChild; openEnd < slice2.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
      }
      slice2 = closeSlice(slice2, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f) => {
    slice2 = f(slice2, view, asText);
  });
  return slice2;
}
const inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d = $context.depth; d >= 0; d--) {
    let parent = $context.node(d);
    let match = parent.contentMatchAt($context.index(d));
    let lastWrap, result = [];
    fragment.forEach((node) => {
      if (!result)
        return;
      let wrap = match.findWrapping(node.type), inLast;
      if (!wrap)
        return result = null;
      if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length)
          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        let wrapped = withWrappers(node, wrap);
        result.push(wrapped);
        match = match.matchType(wrapped.type);
        lastWrap = wrap;
      }
    });
    if (result)
      return superEditor_converter.Fragment.from(result);
  }
  return fragment;
}
function withWrappers(node, wrap, from3 = 0) {
  for (let i = wrap.length - 1; i >= from3; i--)
    node = wrap[i].create(null, superEditor_converter.Fragment.from(node));
  return node;
}
function addToSibling(wrap, lastWrap, node, sibling, depth) {
  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    let match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1]))
      return sibling.copy(sibling.content.append(superEditor_converter.Fragment.from(withWrappers(node, wrap, depth + 1))));
  }
}
function closeRight(node, depth) {
  if (depth == 0)
    return node;
  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  let fill = node.contentMatchAt(node.childCount).fillBefore(superEditor_converter.Fragment.empty, true);
  return node.copy(fragment.append(fill));
}
function closeRange(fragment, side, from3, to, depth, openEnd) {
  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (fragment.childCount > 1)
    openEnd = 0;
  if (depth < to - 1)
    inner = closeRange(inner, side, from3, to, depth + 1, openEnd);
  if (depth >= from3)
    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(superEditor_converter.Fragment.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}
function closeSlice(slice2, openStart, openEnd) {
  if (openStart < slice2.openStart)
    slice2 = new superEditor_converter.Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
  if (openEnd < slice2.openEnd)
    slice2 = new superEditor_converter.Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
  return slice2;
}
const wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
let _policy = null;
function maybeWrapTrusted(html) {
  let trustedTypes = window.trustedTypes;
  if (!trustedTypes)
    return html;
  if (!_policy)
    _policy = trustedTypes.defaultPolicy || trustedTypes.createPolicy("ProseMirrorClipboard", { createHTML: (s) => s });
  return _policy.createHTML(html);
}
function readHTML(html) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas)
    html = html.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap;
  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html = wrap.map((n) => "<" + n + ">").join("") + html + wrap.map((n) => "</" + n + ">").reverse().join("");
  elt.innerHTML = maybeWrapTrusted(html);
  if (wrap)
    for (let i = 0; i < wrap.length; i++)
      elt = elt.querySelector(wrap[i]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i = 0; i < nodes.length; i++) {
    let node = nodes[i];
    if (node.childNodes.length == 1 && node.textContent == "" && node.parentNode)
      node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
  }
}
function addContext(slice2, context) {
  if (!slice2.size)
    return slice2;
  let schema = slice2.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e) {
    return slice2;
  }
  let { content, openStart, openEnd } = slice2;
  for (let i = array.length - 2; i >= 0; i -= 2) {
    let type = schema.nodes[array[i]];
    if (!type || type.hasRequiredAttrs())
      break;
    content = superEditor_converter.Fragment.from(type.create(array[i + 1], content));
    openStart++;
    openEnd++;
  }
  return new superEditor_converter.Slice(content, openStart, openEnd);
}
const handlers = {};
const editHandlers = {};
const passiveHandlers = { touchstart: true, touchmove: true };
class InputState {
  constructor() {
    this.shiftKey = false;
    this.mouseDown = null;
    this.lastKeyCode = null;
    this.lastKeyCodeTime = 0;
    this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 };
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastIOSEnter = 0;
    this.lastIOSEnterFallbackTimeout = -1;
    this.lastFocus = 0;
    this.lastTouch = 0;
    this.lastChromeDelete = 0;
    this.composing = false;
    this.compositionNode = null;
    this.composingTimeout = -1;
    this.compositionNodes = [];
    this.compositionEndedAt = -2e8;
    this.compositionID = 1;
    this.compositionPendingChanges = 0;
    this.domChangeCount = 0;
    this.eventHandlers = /* @__PURE__ */ Object.create(null);
    this.hideSelectionGuard = null;
  }
}
function initInput(view) {
  for (let event in handlers) {
    let handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
        handler(view, event2);
    }, passiveHandlers[event] ? { passive: true } : void 0);
  }
  if (safari)
    view.dom.addEventListener("input", () => null);
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (let type in view.input.eventHandlers)
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", (currentHandlers) => {
    for (let type in currentHandlers)
      if (!view.input.eventHandlers[type])
        view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", (handlers2) => {
    let handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target; node != view.dom; node = node.parentNode)
    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}
editHandlers.keydown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event))
    return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    let now = Date.now();
    view.input.lastIOSEnter = now;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
      if (view.input.lastIOSEnter == now) {
        view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = (view, event) => {
  if (event.keyCode == 16)
    view.input.shiftKey = false;
};
editHandlers.keypress = (view, _event) => {
  let event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac$2 && event.metaKey)
    return;
  if (view.someProp("handleKeyPress", (f) => f(view, event))) {
    event.preventDefault();
    return;
  }
  let sel = view.state.selection;
  if (!(sel instanceof superEditor_converter.TextSelection) || !sel.$from.sameParent(sel.$to)) {
    let text = String.fromCharCode(event.charCode);
    let deflt = () => view.state.tr.insertText(text).scrollIntoView();
    if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text, deflt)))
      view.dispatch(deflt());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused)
    view.focus();
  if (view.state.selection.eq(selection))
    return;
  let tr = view.state.tr.setSelection(selection);
  tr.setMeta("pointer", true);
  view.dispatch(tr);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && superEditor_converter.NodeSelection.isSelectable(node)) {
    updateSelection(view, new superEditor_converter.NodeSelection($pos));
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof superEditor_converter.NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (superEditor_converter.NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, superEditor_converter.NodeSelection.create(view.state.doc, selectAt));
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
}
function handleTripleClick$1(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc2 = view.state.doc;
  if (inside == -1) {
    if (doc2.inlineContent) {
      updateSelection(view, superEditor_converter.TextSelection.create(doc2, 0, doc2.content.size));
      return true;
    }
    return false;
  }
  let $pos = doc2.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    let nodePos = $pos.before(i);
    if (node.inlineContent)
      updateSelection(view, superEditor_converter.TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node.content.size));
    else if (superEditor_converter.NodeSelection.isSelectable(node))
      updateSelection(view, superEditor_converter.NodeSelection.create(doc2, nodePos));
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
const selectNodeModifier = mac$2 ? "metaKey" : "ctrlKey";
handlers.mousedown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush(view);
  let now = Date.now(), type = "singleClick";
  if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier] && view.input.lastClick.button == event.button) {
    if (view.input.lastClick.type == "singleClick")
      type = "doubleClick";
    else if (view.input.lastClick.type == "doubleClick")
      type = "tripleClick";
  }
  view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type, button: event.button };
  let pos = view.posAtCoords(eventCoords(event));
  if (!pos)
    return;
  if (type == "singleClick") {
    if (view.input.mouseDown)
      view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick$1)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
class MouseDown {
  constructor(view, pos, event, flushed) {
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    const target = flushed ? null : event.target;
    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc && targetDesc.nodeDOM.nodeType == 1 ? targetDesc.nodeDOM : null;
    let { selection } = view.state;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof superEditor_converter.NodeSelection && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
      };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => {
          if (this.view.input.mouseDown == this)
            this.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(() => selectionToDOM(this.view));
    this.view.input.mouseDown = null;
  }
  up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    let pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords(event));
    this.updateAllowDefault(event);
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, superEditor_converter.Selection.near(this.view.state.doc.resolve(pos.pos)));
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }
  move(event) {
    this.updateAllowDefault(event);
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  }
  updateAllowDefault(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
  }
}
handlers.touchstart = (view) => {
  view.input.lastTouch = Date.now();
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.touchmove = (view) => {
  view.input.lastTouch = Date.now();
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = (view) => forceDOMFlush(view);
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
const timeoutComposition = android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
  if (!view.composing) {
    view.domObserver.flush();
    let { state } = view, $pos = state.selection.$to;
    if (state.selection instanceof superEditor_converter.TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m2) => m2.type.spec.inclusive === false) || chrome && windows$1 && selectionBeforeUneditable(view))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view, !state.selection.empty);
      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view.domSelectionRange();
        for (let node = sel.focusNode, offset2 = sel.focusOffset; node && node.nodeType == 1 && offset2 != 0; ) {
          let before = offset2 < 0 ? node.lastChild : node.childNodes[offset2 - 1];
          if (!before)
            break;
          if (before.nodeType == 3) {
            let sel2 = view.domSelection();
            if (sel2)
              sel2.collapse(before, before.nodeValue.length);
            break;
          } else {
            node = before;
            offset2 = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
function selectionBeforeUneditable(view) {
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (!focusNode || focusNode.nodeType != 1 || focusOffset >= focusNode.childNodes.length)
    return false;
  let next = focusNode.childNodes[focusOffset];
  return next.nodeType == 1 && next.contentEditable == "false";
}
editHandlers.compositionend = (view, event) => {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
    view.input.compositionNode = null;
    if (view.input.compositionPendingChanges)
      Promise.resolve().then(() => view.domObserver.flush());
    view.input.compositionID++;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function findCompositionNode(view) {
  let sel = view.domSelectionRange();
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
  if (textBefore && textAfter && textBefore != textAfter) {
    let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;
    if (textBefore == lastChanged || textAfter == lastChanged)
      return lastChanged;
    if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
      return textAfter;
    } else if (view.input.compositionNode == textAfter) {
      let descBefore = textBefore.pmViewDesc;
      if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))
        return textAfter;
    }
  }
  return textBefore || textAfter;
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, restarting = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (restarting || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view), cur = view.state.selection;
    if (sel && !sel.eq(cur))
      view.dispatch(view.state.tr.setSelection(sel));
    else if ((view.markCursor || restarting) && !cur.$from.node(cur.$from.sharedDepth(cur.to)).inlineContent)
      view.dispatch(view.state.tr.deleteSelection());
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode)
    return;
  let wrap = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap.appendChild(dom);
  wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(() => {
    if (wrap.parentNode)
      wrap.parentNode.removeChild(wrap);
    view.focus();
  }, 50);
}
const brokenClipboardAPI = ie$1 && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = (view, _event) => {
  let event = _event;
  let sel = view.state.selection, cut = event.type == "cut";
  if (sel.empty)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let slice2 = sel.content(), { dom, text } = serializeForClipboard(view, slice2);
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text);
  } else {
    captureCopy(view, dom);
  }
  if (cut)
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice2) {
  return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  setTimeout(() => {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, plain, event);
    else
      doPaste(view, target.textContent, target.innerHTML, plain, event);
  }, 50);
}
function doPaste(view, text, html, preferPlain, event) {
  let slice2 = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", (f) => f(view, event, slice2 || superEditor_converter.Slice.empty)))
    return true;
  if (!slice2)
    return false;
  let singleNode = sliceSingleNode(slice2);
  let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function getText(clipboardData) {
  let text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
  if (text)
    return text;
  let uris = clipboardData.getData("text/uri-list");
  return uris ? uris.replace(/\r?\n/g, " ") : "";
}
editHandlers.paste = (view, _event) => {
  let event = _event;
  if (view.composing && !android)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  if (data && doPaste(view, getText(data), data.getData("text/html"), plain, event))
    event.preventDefault();
  else
    capturePaste(view, event);
};
class Dragging {
  constructor(slice2, move2, node) {
    this.slice = slice2;
    this.move = move2;
    this.node = node;
  }
}
const dragCopyModifier = mac$2 ? "altKey" : "ctrlKey";
function dragMoves(view, event) {
  let moves = view.someProp("dragCopies", (test) => !test(event));
  return moves != null ? moves : !event[dragCopyModifier];
}
handlers.dragstart = (view, _event) => {
  let event = _event;
  let mouseDown = view.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  let sel = view.state.selection;
  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  let node;
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof superEditor_converter.NodeSelection ? sel.to - 1 : sel.to)) ;
  else if (mouseDown && mouseDown.mightDrag) {
    node = superEditor_converter.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
  } else if (event.target && event.target.nodeType == 1) {
    let desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      node = superEditor_converter.NodeSelection.create(view.state.doc, desc.posBefore);
  }
  let draggedSlice = (node || view.state.selection).content();
  let { dom, text, slice: slice2 } = serializeForClipboard(view, draggedSlice);
  if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)
    event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI)
    event.dataTransfer.setData("text/plain", text);
  view.dragging = new Dragging(slice2, dragMoves(view, event), node);
};
handlers.dragend = (view) => {
  let dragging = view.dragging;
  window.setTimeout(() => {
    if (view.dragging == dragging)
      view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (_2, e) => e.preventDefault();
editHandlers.drop = (view, event) => {
  try {
    handleDrop(view, event, view.dragging);
  } finally {
    view.dragging = null;
  }
};
function handleDrop(view, event, dragging) {
  if (!event.dataTransfer)
    return;
  let eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos)
    return;
  let $mouse = view.state.doc.resolve(eventPos.pos);
  let slice2 = dragging && dragging.slice;
  if (slice2) {
    view.someProp("transformPasted", (f) => {
      slice2 = f(slice2, view, false);
    });
  } else {
    slice2 = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  let move2 = !!(dragging && dragMoves(view, event));
  if (view.someProp("handleDrop", (f) => f(view, event, slice2 || superEditor_converter.Slice.empty, move2))) {
    event.preventDefault();
    return;
  }
  if (!slice2)
    return;
  event.preventDefault();
  let insertPos = slice2 ? superEditor_converter.dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  let tr = view.state.tr;
  if (move2) {
    let { node } = dragging;
    if (node)
      node.replace(tr);
    else
      tr.deleteSelection();
  }
  let pos = tr.mapping.map(insertPos);
  let isNode2 = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
  let beforeInsert = tr.doc;
  if (isNode2)
    tr.replaceRangeWith(pos, pos, slice2.content.firstChild);
  else
    tr.replaceRange(pos, pos, slice2);
  if (tr.doc.eq(beforeInsert))
    return;
  let $pos = tr.doc.resolve(pos);
  if (isNode2 && superEditor_converter.NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
    tr.setSelection(new superEditor_converter.NodeSelection($pos));
  } else {
    let end2 = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end2 = newTo);
    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end2)));
  }
  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
}
handlers.focus = (view) => {
  view.input.lastFocus = Date.now();
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(() => {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
        selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = (view, _event) => {
  let event = _event;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget))
      view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = (view, _event) => {
  let event = _event;
  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    let { domChangeCount } = view.input;
    setTimeout(() => {
      if (view.input.domChangeCount != domChangeCount)
        return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
        return;
      let { $cursor } = view.state.selection;
      if ($cursor && $cursor.pos > 0)
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (let prop in editHandlers)
  handlers[prop] = editHandlers[prop];
function compareObjs(a, b2) {
  if (a == b2)
    return true;
  for (let p2 in a)
    if (a[p2] !== b2[p2])
      return false;
  for (let p2 in b2)
    if (!(p2 in a))
      return false;
  return true;
}
class WidgetType {
  constructor(toDOM, spec) {
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  map(mapping, span, offset2, oldOffset) {
    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration(pos - offset2, pos - offset2, this);
  }
  valid() {
    return true;
  }
  eq(other) {
    return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  }
  destroy(node) {
    if (this.spec.destroy)
      this.spec.destroy(node);
  }
}
class InlineType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset2, oldOffset) {
    let from3 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
    return from3 >= to ? null : new Decoration(from3, to, this);
  }
  valid(_2, span) {
    return span.from < span.to;
  }
  eq(other) {
    return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  static is(span) {
    return span.type instanceof InlineType;
  }
  destroy() {
  }
}
class NodeType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset2, oldOffset) {
    let from3 = mapping.mapResult(span.from + oldOffset, 1);
    if (from3.deleted)
      return null;
    let to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from3.pos)
      return null;
    return new Decoration(from3.pos - offset2, to.pos - offset2, this);
  }
  valid(node, span) {
    let { index: index2, offset: offset2 } = node.content.findIndex(span.from), child;
    return offset2 == span.from && !(child = node.child(index2)).isText && offset2 + child.nodeSize == span.to;
  }
  eq(other) {
    return this == other || other instanceof NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  destroy() {
  }
}
class Decoration {
  /**
  @internal
  */
  constructor(from3, to, type) {
    this.from = from3;
    this.to = to;
    this.type = type;
  }
  /**
  @internal
  */
  copy(from3, to) {
    return new Decoration(from3, to, this.type);
  }
  /**
  @internal
  */
  eq(other, offset2 = 0) {
    return this.type.eq(other.type) && this.from + offset2 == other.from && this.to + offset2 == other.to;
  }
  /**
  @internal
  */
  map(mapping, offset2, oldOffset) {
    return this.type.map(mapping, this, offset2, oldOffset);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(pos, toDOM, spec) {
    return new Decoration(pos, pos, new WidgetType(toDOM, spec));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(from3, to, attrs, spec) {
    return new Decoration(from3, to, new InlineType(attrs, spec));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(from3, to, attrs, spec) {
    return new Decoration(from3, to, new NodeType(attrs, spec));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof InlineType;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof WidgetType;
  }
}
const none = [], noSpec = {};
class DecorationSet {
  /**
  @internal
  */
  constructor(local, children) {
    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(doc2, decorations) {
    return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(start2, end2, predicate) {
    let result = [];
    this.findInner(start2 == null ? 0 : start2, end2 == null ? 1e9 : end2, result, 0, predicate);
    return result;
  }
  findInner(start2, end2, result, offset2, predicate) {
    for (let i = 0; i < this.local.length; i++) {
      let span = this.local[i];
      if (span.from <= end2 && span.to >= start2 && (!predicate || predicate(span.spec)))
        result.push(span.copy(span.from + offset2, span.to + offset2));
    }
    for (let i = 0; i < this.children.length; i += 3) {
      if (this.children[i] < end2 && this.children[i + 1] > start2) {
        let childOff = this.children[i] + 1;
        this.children[i + 2].findInner(start2 - childOff, end2 - childOff, result, offset2 + childOff, predicate);
      }
    }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(mapping, doc2, options) {
    if (this == empty || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc2, 0, 0, options || noSpec);
  }
  /**
  @internal
  */
  mapInner(mapping, node, offset2, oldOffset, options) {
    let newLocal;
    for (let i = 0; i < this.local.length; i++) {
      let mapped = this.local[i].map(mapping, offset2, oldOffset);
      if (mapped && mapped.type.valid(node, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options.onRemove)
        options.onRemove(this.local[i].spec);
    }
    if (this.children.length)
      return mapChildren(this.children, newLocal || [], mapping, node, offset2, oldOffset, options);
    else
      return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(doc2, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty)
      return DecorationSet.create(doc2, decorations);
    return this.addInner(doc2, decorations, 0);
  }
  addInner(doc2, decorations, offset2) {
    let children, childIndex = 0;
    doc2.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset2, found;
      if (!(found = takeSpansForNode(decorations, childNode, baseOffset)))
        return;
      if (!children)
        children = this.children.slice();
      while (childIndex < children.length && children[childIndex] < childOffset)
        childIndex += 3;
      if (children[childIndex] == childOffset)
        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);
      else
        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });
    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset2);
    for (let i = 0; i < local.length; i++)
      if (!local[i].type.valid(doc2, local[i]))
        local.splice(i--, 1);
    return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(decorations) {
    if (decorations.length == 0 || this == empty)
      return this;
    return this.removeInner(decorations, 0);
  }
  removeInner(decorations, offset2) {
    let children = this.children, local = this.local;
    for (let i = 0; i < children.length; i += 3) {
      let found;
      let from3 = children[i] + offset2, to = children[i + 1] + offset2;
      for (let j = 0, span; j < decorations.length; j++)
        if (span = decorations[j]) {
          if (span.from > from3 && span.to < to) {
            decorations[j] = null;
            (found || (found = [])).push(span);
          }
        }
      if (!found)
        continue;
      if (children == this.children)
        children = this.children.slice();
      let removed = children[i + 2].removeInner(found, from3 + 1);
      if (removed != empty) {
        children[i + 2] = removed;
      } else {
        children.splice(i, 3);
        i -= 3;
      }
    }
    if (local.length) {
      for (let i = 0, span; i < decorations.length; i++)
        if (span = decorations[i]) {
          for (let j = 0; j < local.length; j++)
            if (local[j].eq(span, offset2)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(j--, 1);
            }
        }
    }
    if (children == this.children && local == this.local)
      return this;
    return local.length || children.length ? new DecorationSet(local, children) : empty;
  }
  forChild(offset2, node) {
    if (this == empty)
      return this;
    if (node.isLeaf)
      return DecorationSet.empty;
    let child, local;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] >= offset2) {
        if (this.children[i] == offset2)
          child = this.children[i + 2];
        break;
      }
    let start2 = offset2 + 1, end2 = start2 + node.content.size;
    for (let i = 0; i < this.local.length; i++) {
      let dec = this.local[i];
      if (dec.from < end2 && dec.to > start2 && dec.type instanceof InlineType) {
        let from3 = Math.max(start2, dec.from) - start2, to = Math.min(end2, dec.to) - start2;
        if (from3 < to)
          (local || (local = [])).push(dec.copy(from3, to));
      }
    }
    if (local) {
      let localSet = new DecorationSet(local.sort(byPos), none);
      return child ? new DecorationGroup([localSet, child]) : localSet;
    }
    return child || empty;
  }
  /**
  @internal
  */
  eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (let i = 0; i < this.local.length; i++)
      if (!this.local[i].eq(other.local[i]))
        return false;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))
        return false;
    return true;
  }
  /**
  @internal
  */
  locals(node) {
    return removeOverlap(this.localsInner(node));
  }
  /**
  @internal
  */
  localsInner(node) {
    if (this == empty)
      return none;
    if (node.inlineContent || !this.local.some(InlineType.is))
      return this.local;
    let result = [];
    for (let i = 0; i < this.local.length; i++) {
      if (!(this.local[i].type instanceof InlineType))
        result.push(this.local[i]);
    }
    return result;
  }
  forEachSet(f) {
    f(this);
  }
}
DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
const empty = DecorationSet.empty;
class DecorationGroup {
  constructor(members) {
    this.members = members;
  }
  map(mapping, doc2) {
    const mappedDecos = this.members.map((member) => member.map(mapping, doc2, noSpec));
    return DecorationGroup.from(mappedDecos);
  }
  forChild(offset2, child) {
    if (child.isLeaf)
      return DecorationSet.empty;
    let found = [];
    for (let i = 0; i < this.members.length; i++) {
      let result = this.members[i].forChild(offset2, child);
      if (result == empty)
        continue;
      if (result instanceof DecorationGroup)
        found = found.concat(result.members);
      else
        found.push(result);
    }
    return DecorationGroup.from(found);
  }
  eq(other) {
    if (!(other instanceof DecorationGroup) || other.members.length != this.members.length)
      return false;
    for (let i = 0; i < this.members.length; i++)
      if (!this.members[i].eq(other.members[i]))
        return false;
    return true;
  }
  locals(node) {
    let result, sorted = true;
    for (let i = 0; i < this.members.length; i++) {
      let locals = this.members[i].localsInner(node);
      if (!locals.length)
        continue;
      if (!result) {
        result = locals;
      } else {
        if (sorted) {
          result = result.slice();
          sorted = false;
        }
        for (let j = 0; j < locals.length; j++)
          result.push(locals[j]);
      }
    }
    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(members) {
    switch (members.length) {
      case 0:
        return empty;
      case 1:
        return members[0];
      default:
        return new DecorationGroup(members.every((m2) => m2 instanceof DecorationSet) ? members : members.reduce((r2, m2) => r2.concat(m2 instanceof DecorationSet ? m2 : m2.members), []));
    }
  }
  forEachSet(f) {
    for (let i = 0; i < this.members.length; i++)
      this.members[i].forEachSet(f);
  }
}
function mapChildren(oldChildren, newLocal, mapping, node, offset2, oldOffset, options) {
  let children = oldChildren.slice();
  for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
    let moved = 0;
    mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {
      let dSize = newEnd - newStart - (oldEnd - oldStart);
      for (let i2 = 0; i2 < children.length; i2 += 3) {
        let end2 = children[i2 + 1];
        if (end2 < 0 || oldStart > end2 + baseOffset - moved)
          continue;
        let start2 = children[i2] + baseOffset - moved;
        if (oldEnd >= start2) {
          children[i2 + 1] = oldStart <= start2 ? -2 : -1;
        } else if (oldStart >= baseOffset && dSize) {
          children[i2] += dSize;
          children[i2 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    baseOffset = mapping.maps[i].map(baseOffset, -1);
  }
  let mustRebuild = false;
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] < 0) {
      if (children[i + 1] == -2) {
        mustRebuild = true;
        children[i + 1] = -1;
        continue;
      }
      let from3 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from3 - offset2;
      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }
      let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset2;
      let { index: index2, offset: childOffset } = node.content.findIndex(fromLocal);
      let childNode = node.maybeChild(index2);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children[i + 2].mapInner(mapping, childNode, from3 + 1, oldChildren[i] + oldOffset + 1, options);
        if (mapped != empty) {
          children[i] = fromLocal;
          children[i + 1] = toLocal;
          children[i + 2] = mapped;
        } else {
          children[i + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset2, oldOffset, options);
    let built = buildTree(decorations, node, 0, options);
    newLocal = built.local;
    for (let i = 0; i < children.length; i += 3)
      if (children[i + 1] < 0) {
        children.splice(i, 3);
        i -= 3;
      }
    for (let i = 0, j = 0; i < built.children.length; i += 3) {
      let from3 = built.children[i];
      while (j < children.length && children[j] < from3)
        j += 3;
      children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset2) {
  if (!offset2 || !spans.length)
    return spans;
  let result = [];
  for (let i = 0; i < spans.length; i++) {
    let span = spans[i];
    result.push(new Decoration(span.from + offset2, span.to + offset2, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset2, oldOffset, options) {
  function gather(set, oldOffset2) {
    for (let i = 0; i < set.local.length; i++) {
      let mapped = set.local[i].map(mapping, offset2, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options.onRemove)
        options.onRemove(set.local[i].spec);
    }
    for (let i = 0; i < set.children.length; i += 3)
      gather(set.children[i + 2], set.children[i] + oldOffset2 + 1);
  }
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] == -1)
      gather(children[i + 2], oldChildren[i] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node, offset2) {
  if (node.isLeaf)
    return null;
  let end2 = offset2 + node.nodeSize, found = null;
  for (let i = 0, span; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset2 && span.to < end2) {
      (found || (found = [])).push(span);
      spans[i] = null;
    }
  }
  return found;
}
function withoutNulls(array) {
  let result = [];
  for (let i = 0; i < array.length; i++)
    if (array[i] != null)
      result.push(array[i]);
  return result;
}
function buildTree(spans, node, offset2, options) {
  let children = [], hasNulls = false;
  node.forEach((childNode, localStart) => {
    let found = takeSpansForNode(spans, childNode, localStart + offset2);
    if (found) {
      hasNulls = true;
      let subtree = buildTree(found, childNode, offset2 + localStart + 1, options);
      if (subtree != empty)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset2).sort(byPos);
  for (let i = 0; i < locals.length; i++)
    if (!locals[i].type.valid(node, locals[i])) {
      if (options.onRemove)
        options.onRemove(locals[i].spec);
      locals.splice(i--, 1);
    }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}
function byPos(a, b2) {
  return a.from - b2.from || a.to - b2.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i = 0; i < working.length - 1; i++) {
    let span = working[i];
    if (span.from != span.to)
      for (let j = i + 1; j < working.length; j++) {
        let next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j] = next.copy(next.from, span.to);
            insertAhead(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i] = span.copy(span.from, next.from);
            insertAhead(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0)
    i++;
  array.splice(i, 0, deco);
}
function viewDecorations(view) {
  let found = [];
  view.someProp("decorations", (f) => {
    let result = f(view.state);
    if (result && result != empty)
      found.push(result);
  });
  if (view.cursorWrapper)
    found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found);
}
const observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
const useCharData = ie$1 && ie_version <= 11;
class SelectionState {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  set(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  }
}
class DOMObserver {
  constructor(view, handleDOMChange) {
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.lastChangedTextNode = null;
    this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
      for (let i = 0; i < mutations.length; i++)
        this.queue.push(mutations[i]);
      if (ie$1 && ie_version <= 11 && mutations.some((m2) => m2.type == "childList" && m2.removedNodes.length || m2.type == "characterData" && m2.oldValue.length > m2.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData) {
      this.onCharData = (e) => {
        this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
        this.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    if (this.flushingSoon < 0)
      this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  }
  start() {
    if (this.observer) {
      this.observer.takeRecords();
      this.observer.observe(this.view.dom, observeOptions);
    }
    if (this.onCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let take = this.observer.takeRecords();
      if (take.length) {
        for (let i = 0; i < take.length; i++)
          this.queue.push(take[i]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    if (this.onCharData)
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true;
    setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }
  onSelectionChange() {
    if (!hasFocusAndSelection(this.view))
      return;
    if (this.suppressingSelectionUpdates)
      return selectionToDOM(this.view);
    if (ie$1 && ie_version <= 11 && !this.view.state.selection.empty) {
      let sel = this.view.domSelectionRange();
      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        return this.flushSoon();
    }
    this.flush();
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(sel) {
    if (!sel.focusNode)
      return true;
    let ancestors = /* @__PURE__ */ new Set(), container;
    for (let scan = sel.focusNode; scan; scan = parentNode(scan))
      ancestors.add(scan);
    for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
      if (ancestors.has(scan)) {
        container = scan;
        break;
      }
    let desc = container && this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({
      type: "selection",
      target: container.nodeType == 3 ? container.parentNode : container
    })) {
      this.setCurSelection();
      return true;
    }
  }
  pendingRecords() {
    if (this.observer)
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
    return this.queue;
  }
  flush() {
    let { view } = this;
    if (!view.docView || this.flushingSoon > -1)
      return;
    let mutations = this.pendingRecords();
    if (mutations.length)
      this.queue = [];
    let sel = view.domSelectionRange();
    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
    let from3 = -1, to = -1, typeOver = false, added = [];
    if (view.editable) {
      for (let i = 0; i < mutations.length; i++) {
        let result = this.registerMutation(mutations[i], added);
        if (result) {
          from3 = from3 < 0 ? result.from : Math.min(result.from, from3);
          to = to < 0 ? result.to : Math.max(result.to, to);
          if (result.typeOver)
            typeOver = true;
        }
      }
    }
    if (gecko && added.length) {
      let brs = added.filter((n) => n.nodeName == "BR");
      if (brs.length == 2) {
        let [a, b2] = brs;
        if (a.parentNode && a.parentNode.parentNode == b2.parentNode)
          b2.remove();
        else
          a.remove();
      } else {
        let { focusNode } = this.currentSelection;
        for (let br of brs) {
          let parent = br.parentNode;
          if (parent && parent.nodeName == "LI" && (!focusNode || blockParent(view, focusNode) != parent))
            br.remove();
        }
      }
    } else if ((chrome || safari) && added.some((n) => n.nodeName == "BR") && (view.input.lastKeyCode == 8 || view.input.lastKeyCode == 46)) {
      for (let node of added)
        if (node.nodeName == "BR" && node.parentNode) {
          let after = node.nextSibling;
          if (after && after.nodeType == 1 && after.contentEditable == "false")
            node.parentNode.removeChild(node);
        }
    }
    let readSel = null;
    if (from3 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(superEditor_converter.Selection.near(view.state.doc.resolve(0), 1))) {
      view.input.lastFocus = 0;
      selectionToDOM(view);
      this.currentSelection.set(sel);
      view.scrollToSelection();
    } else if (from3 > -1 || newSel) {
      if (from3 > -1) {
        view.docView.markDirty(from3, to);
        checkCSS(view);
      }
      this.handleDOMChange(from3, to, typeOver, added);
      if (view.docView && view.docView.dirty)
        view.updateState(view.state);
      else if (!this.currentSelection.eq(sel))
        selectionToDOM(view);
      this.currentSelection.set(sel);
    }
  }
  registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1)
      return null;
    let desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
      return null;
    if (!desc || desc.ignoreMutation(mut))
      return null;
    if (mut.type == "childList") {
      for (let i = 0; i < mut.addedNodes.length; i++) {
        let node = mut.addedNodes[i];
        added.push(node);
        if (node.nodeType == 3)
          this.lastChangedTextNode = node;
      }
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
        return { from: desc.posBefore, to: desc.posAfter };
      let prev = mut.previousSibling, next = mut.nextSibling;
      if (ie$1 && ie_version <= 11 && mut.addedNodes.length) {
        for (let i = 0; i < mut.addedNodes.length; i++) {
          let { previousSibling, nextSibling } = mut.addedNodes[i];
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
            prev = previousSibling;
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
            next = nextSibling;
        }
      }
      let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
      let from3 = desc.localPosFromDOM(mut.target, fromOffset, -1);
      let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
      let to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from: from3, to };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      this.lastChangedTextNode = mut.target;
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  }
}
let cssChecked = /* @__PURE__ */ new WeakMap();
let cssCheckWarned = false;
function checkCSS(view) {
  if (cssChecked.has(view))
    return;
  cssChecked.set(view, null);
  if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned)
      return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
function rangeToSelectionRange(view, range) {
  let anchorNode = range.startContainer, anchorOffset = range.startOffset;
  let focusNode = range.endContainer, focusOffset = range.endOffset;
  let currentAnchor = view.domAtPos(view.state.selection.anchor);
  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariShadowSelectionRange(view, selection) {
  if (selection.getComposedRanges) {
    let range = selection.getComposedRanges(view.root)[0];
    if (range)
      return rangeToSelectionRange(view, range);
  }
  let found;
  function read2(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found = event.getTargetRanges()[0];
  }
  view.dom.addEventListener("beforeinput", read2, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read2, true);
  return found ? rangeToSelectionRange(view, found) : null;
}
function blockParent(view, node) {
  for (let p2 = node.parentNode; p2 && p2 != view.dom; p2 = p2.parentNode) {
    let desc = view.docView.nearestDesc(p2, true);
    if (desc && desc.node.isBlock)
      return p2;
  }
  return null;
}
function parseBetween(view, from_, to_) {
  let { node: parent, fromOffset, toOffset, from: from3, to } = view.docView.parseRange(from_, to_);
  let domSel = view.domSelectionRange();
  let find2;
  let anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find2 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel))
      find2.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome && view.input.lastKeyCode === 8) {
    for (let off2 = toOffset; off2 > fromOffset; off2--) {
      let node = parent.childNodes[off2 - 1], desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) {
        toOffset = off2;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  let startDoc = view.state.doc;
  let parser = view.someProp("domParser") || superEditor_converter.DOMParser.fromSchema(view.state.schema);
  let $from = startDoc.resolve(from3);
  let sel = null, doc2 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find2,
    ruleFromNode,
    context: $from
  });
  if (find2 && find2[0].pos != null) {
    let anchor2 = find2[0].pos, head = find2[1] && find2[1].pos;
    if (head == null)
      head = anchor2;
    sel = { anchor: anchor2 + from3, head: head + from3 };
  }
  return { doc: doc2, sel, from: from3, to };
}
function ruleFromNode(dom) {
  let desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      let skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
const isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function readDOMChange(view, from3, to, typeOver, addedNodes) {
  let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
  view.input.compositionPendingChanges = 0;
  if (from3 < 0) {
    let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
        return;
      let tr = view.state.tr.setSelection(newSel);
      if (origin == "pointer")
        tr.setMeta("pointer", true);
      else if (origin == "key")
        tr.scrollIntoView();
      if (compositionID)
        tr.setMeta("composition", compositionID);
      view.dispatch(tr);
    }
    return;
  }
  let $before = view.state.doc.resolve(from3);
  let shared = $before.sharedDepth(to);
  from3 = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  let sel = view.state.selection;
  let parse = parseBetween(view, from3, to);
  let doc2 = view.state.doc, compare = doc2.slice(parse.from, parse.to);
  let preferredPos, preferredSide;
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
  if (change)
    view.input.domChangeCount++;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof superEditor_converter.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse.sel) {
        let sel2 = resolveSelection(view, view.state.doc, parse.sel);
        if (sel2 && !sel2.eq(view.state.selection)) {
          let tr = view.state.tr.setSelection(sel2);
          if (compositionID)
            tr.setMeta("composition", compositionID);
          view.dispatch(tr);
        }
      }
      return;
    }
  }
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof superEditor_converter.TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (ie$1 && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " ") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  let $from = parse.doc.resolveNoCache(change.start - parse.from);
  let $to = parse.doc.resolveNoCache(change.endB - parse.from);
  let $fromA = doc2.resolve(change.start);
  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse.doc.content.size && (!$from.sameParent($to) || !$from.parent.inlineContent) && $from.pos < $to.pos && !/\S/.test(parse.doc.textBetween($from.pos, $to.pos, "", ""))) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeBackspace(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
    if (android && chrome)
      view.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome && change.endB == change.start)
    view.input.lastChromeDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse.doc.resolveNoCache(change.endB - parse.from);
    setTimeout(() => {
      view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  let chFrom = change.start, chTo = change.endA;
  let mkTr = (base2) => {
    let tr = base2 || view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
    if (parse.sel) {
      let sel2 = resolveSelection(view, tr.doc, parse.sel);
      if (sel2 && !(chrome && view.composing && sel2.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr.mapping.map(chTo) - 1) || ie$1 && sel2.empty && sel2.head == chFrom))
        tr.setSelection(sel2);
    }
    if (compositionID)
      tr.setMeta("composition", compositionID);
    return tr.scrollIntoView();
  };
  let markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie$1 && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM(view), 20);
      }
      let tr = mkTr(view.state.tr.delete(chFrom, chTo));
      let marks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
      if (marks)
        tr.ensureMarks(marks);
      view.dispatch(tr);
    } else if (
      // Adding or removing a mark
      change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
    ) {
      let tr = mkTr(view.state.tr);
      if (markChange.type == "add")
        tr.addMark(chFrom, chTo, markChange.mark);
      else
        tr.removeMark(chFrom, chTo, markChange.mark);
      view.dispatch(tr);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      let deflt = () => mkTr(view.state.tr.insertText(text, chFrom, chTo));
      if (!view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text, deflt)))
        view.dispatch(deflt());
    } else {
      view.dispatch(mkTr());
    }
  } else {
    view.dispatch(mkTr());
  }
}
function resolveSelection(view, doc2, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size)
    return null;
  return selectionBetween(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  let added = curMarks, removed = prevMarks, type, mark, update;
  for (let i = 0; i < prevMarks.length; i++)
    added = prevMarks[i].removeFromSet(added);
  for (let i = 0; i < curMarks.length; i++)
    removed = curMarks[i].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update = (node) => node.mark(mark.addToSet(node.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update = (node) => node.mark(mark.removeFromSet(node.marks));
  } else {
    return null;
  }
  let updated = [];
  for (let i = 0; i < prev.childCount; i++)
    updated.push(update(prev.child(i)));
  if (superEditor_converter.Fragment.from(updated).eq(cur))
    return { mark, type };
}
function looksLikeBackspace(old, start2, end2, $newStart, $newEnd) {
  if (
    // The content must have shrunk
    end2 - start2 <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
    skipClosingAndOpening($newStart, true, false) < $newEnd.pos
  )
    return false;
  let $start = old.resolve(start2);
  if (!$newStart.parent.isTextblock) {
    let after = $start.nodeAfter;
    return after != null && end2 == start2 + after.nodeSize;
  }
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  let $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end2 || skipClosingAndOpening($next, true, false) < end2)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end2 = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end2++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end2++;
    }
  }
  return end2;
}
function findDiff(a, b2, pos, preferredPos, preferredSide) {
  let start2 = a.findDiffStart(b2, pos);
  if (start2 == null)
    return null;
  let { a: endA, b: endB } = a.findDiffEnd(b2, pos + a.size, pos + b2.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start2 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start2;
  }
  if (endA < start2 && a.size < b2.size) {
    let move2 = preferredPos <= start2 && preferredPos >= endA ? start2 - preferredPos : 0;
    start2 -= move2;
    if (start2 && start2 < b2.size && isSurrogatePair(b2.textBetween(start2 - 1, start2 + 1)))
      start2 += move2 ? 1 : -1;
    endB = start2 + (endB - endA);
    endA = start2;
  } else if (endB < start2) {
    let move2 = preferredPos <= start2 && preferredPos >= endB ? start2 - preferredPos : 0;
    start2 -= move2;
    if (start2 && start2 < a.size && isSurrogatePair(a.textBetween(start2 - 1, start2 + 1)))
      start2 += move2 ? 1 : -1;
    endA = start2 + (endA - endB);
    endB = start2;
  }
  return { start: start2, endA, endB };
}
function isSurrogatePair(str) {
  if (str.length != 2)
    return false;
  let a = str.charCodeAt(0), b2 = str.charCodeAt(1);
  return a >= 56320 && a <= 57343 && b2 >= 55296 && b2 <= 56319;
}
class EditorView {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(place, props) {
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = void 0;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.requiresGeckoHackNode = false;
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild)
        place.appendChild(this.dom);
      else if (typeof place == "function")
        place(this.dom);
      else if (place.mount)
        this.mounted = true;
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, (from3, to, typeOver, added) => readDOMChange(this, from3, to, typeOver, added));
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let prev = this._props;
      this._props = {};
      for (let name in prev)
        this._props[name] = prev[name];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(props) {
    if (props.handleDOMEvents != this._props.handleDOMEvents)
      ensureListeners(this);
    let prevProps = this._props;
    this._props = props;
    if (props.plugins) {
      props.plugins.forEach(checkStateComponent);
      this.directPlugins = props.plugins;
    }
    this.updateStateInner(props.state, prevProps);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(props) {
    let updated = {};
    for (let name in this._props)
      updated[name] = this._props[name];
    updated.state = this.state;
    for (let name in props)
      updated[name] = props[name];
    this.update(updated);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(state) {
    this.updateStateInner(state, this._props);
  }
  updateStateInner(state, prevProps) {
    var _a;
    let prev = this.state, redraw = false, updateSel = false;
    if (state.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state;
    let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
      let nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
    }
    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
      ensureListeners(this);
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
    let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
    if (updateDoc || !state.selection.eq(prev.selection))
      updateSel = true;
    let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (updateSel) {
      this.domObserver.stop();
      let forceSelUpdate = updateDoc && (ie$1 || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
      if (updateDoc) {
        let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
        if (this.composing)
          this.input.compositionNode = findCompositionNode(this);
        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco(outerDeco);
          this.docView.destroy();
          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && !this.trackWrites)
          forceSelUpdate = true;
      }
      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
        selectionToDOM(this, forceSelUpdate);
      } else {
        syncNodeSelection(this, state.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev);
    if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc))
      this.updateDraggedNode(this.dragging, prev);
    if (scroll == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll == "to selection") {
      this.scrollToSelection();
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  }
  /**
  @internal
  */
  scrollToSelection() {
    let startDOM = this.domSelectionRange().focusNode;
    if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;
    else if (this.someProp("handleScrollToSelection", (f) => f(this))) ;
    else if (this.state.selection instanceof superEditor_converter.NodeSelection) {
      let target = this.docView.domAfterPos(this.state.selection.from);
      if (target.nodeType == 1)
        scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
    }
  }
  destroyPluginViews() {
    let view;
    while (view = this.pluginViews.pop())
      if (view.destroy)
        view.destroy();
  }
  updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (let i = 0; i < this.directPlugins.length; i++) {
        let plugin2 = this.directPlugins[i];
        if (plugin2.spec.view)
          this.pluginViews.push(plugin2.spec.view(this));
      }
      for (let i = 0; i < this.state.plugins.length; i++) {
        let plugin2 = this.state.plugins[i];
        if (plugin2.spec.view)
          this.pluginViews.push(plugin2.spec.view(this));
      }
    } else {
      for (let i = 0; i < this.pluginViews.length; i++) {
        let pluginView = this.pluginViews[i];
        if (pluginView.update)
          pluginView.update(this, prevState);
      }
    }
  }
  updateDraggedNode(dragging, prev) {
    let sel = dragging.node, found = -1;
    if (this.state.doc.nodeAt(sel.from) == sel.node) {
      found = sel.from;
    } else {
      let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
      let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
      if (moved == sel.node)
        found = movedPos;
    }
    this.dragging = new Dragging(dragging.slice, dragging.move, found < 0 ? void 0 : superEditor_converter.NodeSelection.create(this.state.doc, found));
  }
  someProp(propName, f) {
    let prop = this._props && this._props[propName], value;
    if (prop != null && (value = f ? f(prop) : prop))
      return value;
    for (let i = 0; i < this.directPlugins.length; i++) {
      let prop2 = this.directPlugins[i].props[propName];
      if (prop2 != null && (value = f ? f(prop2) : prop2))
        return value;
    }
    let plugins = this.state.plugins;
    if (plugins)
      for (let i = 0; i < plugins.length; i++) {
        let prop2 = plugins[i].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2))
          return value;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (ie$1) {
      let node = this.root.activeElement;
      if (node == this.dom)
        return true;
      if (!node || !this.dom.contains(node))
        return false;
      while (node && this.dom != node && this.dom.contains(node)) {
        if (node.contentEditable == "false")
          return false;
        node = node.parentElement;
      }
      return true;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop();
    if (this.editable)
      focusPreventScroll(this.dom);
    selectionToDOM(this);
    this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let cached = this._root;
    if (cached == null)
      for (let search2 = this.dom.parentNode; search2; search2 = search2.parentNode) {
        if (search2.nodeType == 9 || search2.nodeType == 11 && search2.host) {
          if (!search2.getSelection)
            Object.getPrototypeOf(search2).getSelection = () => search2.ownerDocument.getSelection();
          return this._root = search2;
        }
      }
    return cached || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(coords) {
    return posAtCoords(this, coords);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(pos, side = 1) {
    return coordsAtPos(this, pos, side);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(pos, side = 0) {
    return this.docView.domFromPos(pos, side);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(pos) {
    let desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimesfor example when interpreting an event
  targetyou don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(node, offset2, bias = -1) {
    let pos = this.docView.posFromDOM(node, offset2, bias);
    if (pos == null)
      throw new RangeError("DOM position not inside the editor");
    return pos;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(dir, state) {
    return endOfTextblock(this, state || this.state, dir);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(html, event) {
    return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(text, event) {
    return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(slice2) {
    return serializeForClipboard(this, slice2);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    if (!this.docView)
      return;
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
    clearReusedRange();
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(event) {
    return dispatchEvent(this, event);
  }
  /**
  @internal
  */
  domSelectionRange() {
    let sel = this.domSelection();
    if (!sel)
      return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
    return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
EditorView.prototype.dispatch = function(tr) {
  let dispatchTransaction = this._props.dispatchTransaction;
  if (dispatchTransaction)
    dispatchTransaction.call(this, tr);
  else
    this.updateState(this.state.apply(tr));
};
function computeDocDeco(view) {
  let attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", (value) => {
    if (typeof value == "function")
      value = value(view.state);
    if (value)
      for (let attr in value) {
        if (attr == "class")
          attrs.class += " " + value[attr];
        else if (attr == "style")
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
        else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
          attrs[attr] = String(value[attr]);
      }
  });
  if (!attrs.translate)
    attrs.translate = "no";
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    let dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", (value) => value(view.state) === false);
}
function selectionContextChanged(sel1, sel2) {
  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  let result = /* @__PURE__ */ Object.create(null);
  function add(obj) {
    for (let prop in obj)
      if (!Object.prototype.hasOwnProperty.call(result, prop))
        result[prop] = obj[prop];
  }
  view.someProp("nodeViews", add);
  view.someProp("markViews", add);
  return result;
}
function changedNodeViews(a, b2) {
  let nA = 0, nB = 0;
  for (let prop in a) {
    if (a[prop] != b2[prop])
      return true;
    nA++;
  }
  for (let _2 in b2)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin2) {
  if (plugin2.spec.state || plugin2.spec.filterTransaction || plugin2.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
const floor = Math.floor;
const abs = Math.abs;
const min$1 = (a, b2) => a < b2 ? a : b2;
const max$1 = (a, b2) => a > b2 ? a : b2;
const pow = Math.pow;
const isNegativeZero = (n) => n !== 0 ? n < 0 : 1 / n < 0;
const BIT7 = 64;
const BIT8 = 128;
const BIT30 = 1 << 29;
const BITS6 = 63;
const BITS7 = 127;
const BITS31 = 2147483647;
const MAX_SAFE_INTEGER$2 = Number.MAX_SAFE_INTEGER;
const isInteger = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor(num) === num);
const create$2 = () => /* @__PURE__ */ new Set();
const from2 = Array.from;
const isArray$1 = Array.isArray;
const fromCharCode = String.fromCharCode;
const toLowerCase = (s) => s.toLowerCase();
const trimLeftRegex = /^\s*/g;
const trimLeft = (s) => s.replace(trimLeftRegex, "");
const fromCamelCaseRegex = /([A-Z])/g;
const fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, (match) => `${separator}${toLowerCase(match)}`));
const _encodeUtf8Polyfill = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    buf[i] = /** @type {number} */
    encodedString.codePointAt(i);
  }
  return buf;
};
const utf8TextEncoder = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
const _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);
const encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
exports.utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (exports.utf8TextDecoder && exports.utf8TextDecoder.decode(new Uint8Array()).length === 1) {
  exports.utf8TextDecoder = null;
}
class Encoder {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
}
const createEncoder = () => new Encoder();
const encode = (f) => {
  const encoder = createEncoder();
  f(encoder);
  return toUint8Array(encoder);
};
const length$1 = (encoder) => {
  let len = encoder.cpos;
  for (let i = 0; i < encoder.bufs.length; i++) {
    len += encoder.bufs[i].length;
  }
  return len;
};
const toUint8Array = (encoder) => {
  const uint8arr = new Uint8Array(length$1(encoder));
  let curPos = 0;
  for (let i = 0; i < encoder.bufs.length; i++) {
    const d = encoder.bufs[i];
    uint8arr.set(d, curPos);
    curPos += d.length;
  }
  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
  return uint8arr;
};
const verifyLen = (encoder, len) => {
  const bufferLen = encoder.cbuf.length;
  if (bufferLen - encoder.cpos < len) {
    encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos));
    encoder.cbuf = new Uint8Array(max$1(bufferLen, len) * 2);
    encoder.cpos = 0;
  }
};
const write$1 = (encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
};
const writeVarUint = (encoder, num) => {
  while (num > BITS7) {
    write$1(encoder, BIT8 | BITS7 & num);
    num = floor(num / 128);
  }
  write$1(encoder, BITS7 & num);
};
const writeVarInt = (encoder, num) => {
  const isNegative = isNegativeZero(num);
  if (isNegative) {
    num = -num;
  }
  write$1(encoder, (num > BITS6 ? BIT8 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);
  num = floor(num / 64);
  while (num > 0) {
    write$1(encoder, (num > BITS7 ? BIT8 : 0) | BITS7 & num);
    num = floor(num / 128);
  }
};
const _strBuffer = new Uint8Array(3e4);
const _maxStrBSize = _strBuffer.length / 3;
const _writeVarStringNative = (encoder, str) => {
  if (str.length < _maxStrBSize) {
    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
    writeVarUint(encoder, written);
    for (let i = 0; i < written; i++) {
      write$1(encoder, _strBuffer[i]);
    }
  } else {
    writeVarUint8Array(encoder, encodeUtf8(str));
  }
};
const _writeVarStringPolyfill = (encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint(encoder, len);
  for (let i = 0; i < len; i++) {
    write$1(
      encoder,
      /** @type {number} */
      encodedString.codePointAt(i)
    );
  }
};
const writeVarString = utf8TextEncoder && /** @type {any} */
utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
const writeUint8Array = (encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min$1(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max$1(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
};
const writeVarUint8Array = (encoder, uint8Array) => {
  writeVarUint(encoder, uint8Array.byteLength);
  writeUint8Array(encoder, uint8Array);
};
const writeOnDataView = (encoder, len) => {
  verifyLen(encoder, len);
  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
  encoder.cpos += len;
  return dview;
};
const writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);
const writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);
const writeBigInt64 = (encoder, num) => (
  /** @type {any} */
  writeOnDataView(encoder, 8).setBigInt64(0, num, false)
);
const floatTestBed = new DataView(new ArrayBuffer(4));
const isFloat32 = (num) => {
  floatTestBed.setFloat32(0, num);
  return floatTestBed.getFloat32(0) === num;
};
const writeAny = (encoder, data) => {
  switch (typeof data) {
    case "string":
      write$1(encoder, 119);
      writeVarString(encoder, data);
      break;
    case "number":
      if (isInteger(data) && abs(data) <= BITS31) {
        write$1(encoder, 125);
        writeVarInt(encoder, data);
      } else if (isFloat32(data)) {
        write$1(encoder, 124);
        writeFloat32(encoder, data);
      } else {
        write$1(encoder, 123);
        writeFloat64(encoder, data);
      }
      break;
    case "bigint":
      write$1(encoder, 122);
      writeBigInt64(encoder, data);
      break;
    case "object":
      if (data === null) {
        write$1(encoder, 126);
      } else if (isArray$1(data)) {
        write$1(encoder, 117);
        writeVarUint(encoder, data.length);
        for (let i = 0; i < data.length; i++) {
          writeAny(encoder, data[i]);
        }
      } else if (data instanceof Uint8Array) {
        write$1(encoder, 116);
        writeVarUint8Array(encoder, data);
      } else {
        write$1(encoder, 118);
        const keys2 = Object.keys(data);
        writeVarUint(encoder, keys2.length);
        for (let i = 0; i < keys2.length; i++) {
          const key2 = keys2[i];
          writeVarString(encoder, key2);
          writeAny(encoder, data[key2]);
        }
      }
      break;
    case "boolean":
      write$1(encoder, data ? 120 : 121);
      break;
    default:
      write$1(encoder, 127);
  }
};
const create$1 = (s) => new Error(s);
const methodUnimplemented = () => {
  throw create$1("Method unimplemented");
};
const unexpectedCase = () => {
  throw create$1("Unexpected case");
};
const create = () => /* @__PURE__ */ new Map();
const setIfUndefined = (map3, key2, createT) => {
  let set = map3.get(key2);
  if (set === void 0) {
    map3.set(key2, set = createT());
  }
  return set;
};
const keys$1 = Object.keys;
const map$1 = (obj, f) => {
  const results = [];
  for (const key2 in obj) {
    results.push(f(obj[key2], key2));
  }
  return results;
};
const length = (obj) => keys$1(obj).length;
const every = (obj, f) => {
  for (const key2 in obj) {
    if (!f(obj[key2], key2)) {
      return false;
    }
  }
  return true;
};
const hasProperty = (obj, key2) => Object.prototype.hasOwnProperty.call(obj, key2);
const EqualityTraitSymbol = Symbol("Equality");
const equalityDeep = (a, b2) => {
  if (a === b2) {
    return true;
  }
  if (a == null || b2 == null || a.constructor !== b2.constructor) {
    return false;
  }
  if (a[EqualityTraitSymbol] != null) {
    return a[EqualityTraitSymbol](b2);
  }
  switch (a.constructor) {
    case ArrayBuffer:
      a = new Uint8Array(a);
      b2 = new Uint8Array(b2);
    // eslint-disable-next-line no-fallthrough
    case Uint8Array: {
      if (a.byteLength !== b2.byteLength) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b2[i]) {
          return false;
        }
      }
      break;
    }
    case Set: {
      if (a.size !== b2.size) {
        return false;
      }
      for (const value of a) {
        if (!b2.has(value)) {
          return false;
        }
      }
      break;
    }
    case Map: {
      if (a.size !== b2.size) {
        return false;
      }
      for (const key2 of a.keys()) {
        if (!b2.has(key2) || !equalityDeep(a.get(key2), b2.get(key2))) {
          return false;
        }
      }
      break;
    }
    case Object:
      if (length(a) !== length(b2)) {
        return false;
      }
      for (const key2 in a) {
        if (!hasProperty(a, key2) || !equalityDeep(a[key2], b2[key2])) {
          return false;
        }
      }
      break;
    case Array:
      if (a.length !== b2.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (!equalityDeep(a[i], b2[i])) {
          return false;
        }
      }
      break;
    default:
      return false;
  }
  return true;
};
const isOneOf = (value, options) => options.includes(value);
const createMutex = () => {
  let token = true;
  return (f, g2) => {
    if (token) {
      token = false;
      try {
        f();
      } finally {
        token = true;
      }
    } else if (g2 !== void 0) {
      g2();
    }
  };
};
const highSurrogateRegex = /[\uD800-\uDBFF]/;
const lowSurrogateRegex = /[\uDC00-\uDFFF]/;
const simpleDiffString = (a, b2) => {
  let left2 = 0;
  let right2 = 0;
  while (left2 < a.length && left2 < b2.length && a[left2] === b2[left2]) {
    left2++;
  }
  if (left2 > 0 && highSurrogateRegex.test(a[left2 - 1])) left2--;
  while (right2 + left2 < a.length && right2 + left2 < b2.length && a[a.length - right2 - 1] === b2[b2.length - right2 - 1]) {
    right2++;
  }
  if (right2 > 0 && lowSurrogateRegex.test(a[a.length - right2])) right2--;
  return {
    index: left2,
    remove: a.length - left2 - right2,
    insert: b2.slice(left2, b2.length - right2)
  };
};
const simpleDiff = simpleDiffString;
const ySyncPluginKey = new superEditor_converter.PluginKey("y-sync");
const yUndoPluginKey = new superEditor_converter.PluginKey("y-undo");
const yCursorPluginKey = new superEditor_converter.PluginKey("yjs-cursor");
const rand = Math.random;
const oneOf = (arr) => arr[floor(rand() * arr.length)];
const undefinedToNull = (v) => v === void 0 ? null : v;
class VarStoragePolyfill {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(key2, newValue) {
    this.map.set(key2, newValue);
  }
  /**
   * @param {string} key
   */
  getItem(key2) {
    return this.map.get(key2);
  }
}
let _localStorage = new VarStoragePolyfill();
let usePolyfill = true;
try {
  if (typeof localStorage !== "undefined" && localStorage) {
    _localStorage = localStorage;
    usePolyfill = false;
  }
} catch (e) {
}
const varStorage = _localStorage;
const onChange = (eventHandler) => usePolyfill || addEventListener(
  "storage",
  /** @type {any} */
  eventHandler
);
const offChange = (eventHandler) => usePolyfill || removeEventListener(
  "storage",
  /** @type {any} */
  eventHandler
);
const isNode = typeof vue.process$1 !== "undefined" && vue.process$1.release && /node|io\.js/.test(vue.process$1.release.name) && Object.prototype.toString.call(typeof vue.process$1 !== "undefined" ? vue.process$1 : 0) === "[object process]";
const isBrowser$4 = typeof window !== "undefined" && typeof document !== "undefined" && !isNode;
let params;
const computeParams = () => {
  if (params === void 0) {
    if (isNode) {
      params = create();
      const pargs = vue.process$1.argv;
      let currParamName = null;
      for (let i = 0; i < pargs.length; i++) {
        const parg = pargs[i];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params.set(currParamName, parg);
            currParamName = null;
          }
        }
      }
      if (currParamName !== null) {
        params.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params = create();
      (location.search || "?").slice(1).split("&").forEach((kv) => {
        if (kv.length !== 0) {
          const [key2, value] = kv.split("=");
          params.set(`--${fromCamelCase(key2, "-")}`, value);
          params.set(`-${fromCamelCase(key2, "-")}`, value);
        }
      });
    } else {
      params = create();
    }
  }
  return params;
};
const hasParam = (name) => computeParams().has(name);
const getVariable = (name) => isNode ? undefinedToNull(vue.process$1.env[name.toUpperCase().replaceAll("-", "_")]) : undefinedToNull(varStorage.getItem(name));
const hasConf = (name) => hasParam("--" + name) || getVariable(name) !== null;
hasConf("production");
const forceColor = isNode && isOneOf(vue.process$1.env.FORCE_COLOR, ["true", "1", "2"]);
forceColor || !hasParam("--no-colors") && // @todo deprecate --no-colors
!hasConf("no-color") && (!isNode || vue.process$1.stdout.isTTY) && (!isNode || hasParam("--color") || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));
const doc = (
  /** @type {Document} */
  typeof document !== "undefined" ? document : {}
);
typeof DOMParser !== "undefined" ? new DOMParser() : null;
const createTimeoutClass = (clearFunction) => class TT {
  /**
   * @param {number} timeoutId
   */
  constructor(timeoutId) {
    this._ = timeoutId;
  }
  destroy() {
    clearFunction(this._);
  }
};
const Timeout = createTimeoutClass(clearTimeout);
const timeout = (timeout2, callback) => new Timeout(setTimeout(callback, timeout2));
const rotr = (w, shift2) => w >>> shift2 | w << 32 - shift2;
const sum0to256 = (x) => rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
const sum1to256 = (x) => rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
const sigma0to256 = (x) => rotr(x, 7) ^ rotr(x, 18) ^ x >>> 3;
const sigma1to256 = (x) => rotr(x, 17) ^ rotr(x, 19) ^ x >>> 10;
const K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const HINIT = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
class Hasher {
  constructor() {
    const buf = new ArrayBuffer(64 + 64 * 4);
    this._H = new Uint32Array(buf, 0, 8);
    this._H.set(HINIT);
    this._W = new Uint32Array(buf, 64, 64);
  }
  _updateHash() {
    const H2 = this._H;
    const W2 = this._W;
    for (let t = 16; t < 64; t++) {
      W2[t] = sigma1to256(W2[t - 2]) + W2[t - 7] + sigma0to256(W2[t - 15]) + W2[t - 16];
    }
    let a = H2[0];
    let b2 = H2[1];
    let c2 = H2[2];
    let d = H2[3];
    let e = H2[4];
    let f = H2[5];
    let g2 = H2[6];
    let h2 = H2[7];
    for (let tt = 0, T1, T2; tt < 64; tt++) {
      T1 = h2 + sum1to256(e) + (e & f ^ ~e & g2) + K[tt] + W2[tt] >>> 0;
      T2 = sum0to256(a) + (a & b2 ^ a & c2 ^ b2 & c2) >>> 0;
      h2 = g2;
      g2 = f;
      f = e;
      e = d + T1 >>> 0;
      d = c2;
      c2 = b2;
      b2 = a;
      a = T1 + T2 >>> 0;
    }
    H2[0] += a;
    H2[1] += b2;
    H2[2] += c2;
    H2[3] += d;
    H2[4] += e;
    H2[5] += f;
    H2[6] += g2;
    H2[7] += h2;
  }
  /**
   * Returns a 32-byte hash.
   *
   * @param {Uint8Array} data
   */
  digest(data) {
    let i = 0;
    for (; i + 56 <= data.length; ) {
      let j2 = 0;
      for (; j2 < 16 && i + 3 < data.length; j2++) {
        this._W[j2] = data[i++] << 24 | data[i++] << 16 | data[i++] << 8 | data[i++];
      }
      if (i % 64 !== 0) {
        this._W.fill(0, j2, 16);
        while (i < data.length) {
          this._W[j2] |= data[i] << (3 - i % 4) * 8;
          i++;
        }
        this._W[j2] |= BIT8 << (3 - i % 4) * 8;
      }
      this._updateHash();
    }
    const isPaddedWith1 = i % 64 !== 0;
    this._W.fill(0, 0, 16);
    let j = 0;
    for (; i < data.length; j++) {
      for (let ci = 3; ci >= 0 && i < data.length; ci--) {
        this._W[j] |= data[i++] << ci * 8;
      }
    }
    if (!isPaddedWith1) {
      this._W[j - (i % 4 === 0 ? 0 : 1)] |= BIT8 << (3 - i % 4) * 8;
    }
    this._W[14] = data.byteLength / BIT30;
    this._W[15] = data.byteLength * 8;
    this._updateHash();
    const dv = new Uint8Array(32);
    for (let i2 = 0; i2 < this._H.length; i2++) {
      for (let ci = 0; ci < 4; ci++) {
        dv[i2 * 4 + ci] = this._H[i2] >>> (3 - ci) * 8;
      }
    }
    return dv;
  }
}
const digest = (data) => new Hasher().digest(data);
const createUint8ArrayFromLen = (len) => new Uint8Array(len);
const createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length2) => new Uint8Array(buffer, byteOffset, length2);
const createUint8ArrayFromArrayBuffer = (buffer) => new Uint8Array(buffer);
const toBase64Browser = (bytes) => {
  let s = "";
  for (let i = 0; i < bytes.byteLength; i++) {
    s += fromCharCode(bytes[i]);
  }
  return btoa(s);
};
const toBase64Node = (bytes) => jszip.Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString("base64");
const fromBase64Browser = (s) => {
  const a = atob(s);
  const bytes = createUint8ArrayFromLen(a.length);
  for (let i = 0; i < a.length; i++) {
    bytes[i] = a.charCodeAt(i);
  }
  return bytes;
};
const fromBase64Node = (s) => {
  const buf = jszip.Buffer.from(s, "base64");
  return createUint8ArrayViewFromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength);
};
const toBase64 = isBrowser$4 ? toBase64Browser : toBase64Node;
const fromBase64 = isBrowser$4 ? fromBase64Browser : fromBase64Node;
const encodeAny = (data) => encode((encoder) => writeAny(encoder, data));
const _convolute = (digest2) => {
  const N = 6;
  for (let i = N; i < digest2.length; i++) {
    digest2[i % N] = digest2[i % N] ^ digest2[i];
  }
  return digest2.slice(0, N);
};
const hashOfJSON = (json) => toBase64(_convolute(digest(encodeAny(json))));
const createEmptyMeta = () => ({
  mapping: /* @__PURE__ */ new Map(),
  isOMark: /* @__PURE__ */ new Map()
});
const isVisible = (item, snapshot) => snapshot === void 0 ? !item.deleted : snapshot.sv.has(item.id.client) && /** @type {number} */
snapshot.sv.get(item.id.client) > item.id.clock && !Y__namespace.isDeleted(snapshot.ds, item.id);
const defaultColors = [{ light: "#ecd44433", dark: "#ecd444" }];
const getUserColor = (colorMapping, colors2, user) => {
  if (!colorMapping.has(user)) {
    if (colorMapping.size < colors2.length) {
      const usedColors = create$2();
      colorMapping.forEach((color) => usedColors.add(color));
      colors2 = colors2.filter((color) => !usedColors.has(color));
    }
    colorMapping.set(user, oneOf(colors2));
  }
  return (
    /** @type {ColorDef} */
    colorMapping.get(user)
  );
};
const ySyncPlugin = (yXmlFragment, {
  colors: colors2 = defaultColors,
  colorMapping = /* @__PURE__ */ new Map(),
  permanentUserData = null,
  onFirstRender = () => {
  },
  mapping
} = {}) => {
  let initialContentChanged = false;
  const binding = new ProsemirrorBinding(yXmlFragment, mapping);
  const plugin2 = new superEditor_converter.Plugin({
    props: {
      editable: (state) => {
        const syncState = ySyncPluginKey.getState(state);
        return syncState.snapshot == null && syncState.prevSnapshot == null;
      }
    },
    key: ySyncPluginKey,
    state: {
      /**
       * @returns {any}
       */
      init: (_initargs, _state) => {
        return {
          type: yXmlFragment,
          doc: yXmlFragment.doc,
          binding,
          snapshot: null,
          prevSnapshot: null,
          isChangeOrigin: false,
          isUndoRedoOperation: false,
          addToHistory: true,
          colors: colors2,
          colorMapping,
          permanentUserData
        };
      },
      apply: (tr, pluginState) => {
        const change = tr.getMeta(ySyncPluginKey);
        if (change !== void 0) {
          pluginState = Object.assign({}, pluginState);
          for (const key2 in change) {
            pluginState[key2] = change[key2];
          }
        }
        pluginState.addToHistory = tr.getMeta("addToHistory") !== false;
        pluginState.isChangeOrigin = change !== void 0 && !!change.isChangeOrigin;
        pluginState.isUndoRedoOperation = change !== void 0 && !!change.isChangeOrigin && !!change.isUndoRedoOperation;
        if (binding.prosemirrorView !== null) {
          if (change !== void 0 && (change.snapshot != null || change.prevSnapshot != null)) {
            timeout(0, () => {
              if (binding.prosemirrorView == null) {
                return;
              }
              if (change.restore == null) {
                binding._renderSnapshot(
                  change.snapshot,
                  change.prevSnapshot,
                  pluginState
                );
              } else {
                binding._renderSnapshot(
                  change.snapshot,
                  change.snapshot,
                  pluginState
                );
                delete pluginState.restore;
                delete pluginState.snapshot;
                delete pluginState.prevSnapshot;
                binding.mux(() => {
                  binding._prosemirrorChanged(
                    binding.prosemirrorView.state.doc
                  );
                });
              }
            });
          }
        }
        return pluginState;
      }
    },
    view: (view) => {
      binding.initView(view);
      if (mapping == null) {
        binding._forceRerender();
      }
      onFirstRender();
      return {
        update: () => {
          const pluginState = plugin2.getState(view.state);
          if (pluginState.snapshot == null && pluginState.prevSnapshot == null) {
            if (
              // If the content doesn't change initially, we don't render anything to Yjs
              // If the content was cleared by a user action, we want to catch the change and
              // represent it in Yjs
              initialContentChanged || view.state.doc.content.findDiffStart(
                view.state.doc.type.createAndFill().content
              ) !== null
            ) {
              initialContentChanged = true;
              if (pluginState.addToHistory === false && !pluginState.isChangeOrigin) {
                const yUndoPluginState = yUndoPluginKey.getState(view.state);
                const um = yUndoPluginState && yUndoPluginState.undoManager;
                if (um) {
                  um.stopCapturing();
                }
              }
              binding.mux(() => {
                pluginState.doc.transact((tr) => {
                  tr.meta.set("addToHistory", pluginState.addToHistory);
                  binding._prosemirrorChanged(view.state.doc);
                }, ySyncPluginKey);
              });
            }
          }
        },
        destroy: () => {
          binding.destroy();
        }
      };
    }
  });
  return plugin2;
};
const restoreRelativeSelection = (tr, relSel, binding) => {
  if (relSel !== null && relSel.anchor !== null && relSel.head !== null) {
    if (relSel.type === "all") {
      tr.setSelection(new superEditor_converter.AllSelection(tr.doc));
    } else if (relSel.type === "node") {
      const anchor = relativePositionToAbsolutePosition(
        binding.doc,
        binding.type,
        relSel.anchor,
        binding.mapping
      );
      tr.setSelection(superEditor_converter.NodeSelection.create(tr.doc, anchor));
    } else {
      const anchor = relativePositionToAbsolutePosition(
        binding.doc,
        binding.type,
        relSel.anchor,
        binding.mapping
      );
      const head = relativePositionToAbsolutePosition(
        binding.doc,
        binding.type,
        relSel.head,
        binding.mapping
      );
      if (anchor !== null && head !== null) {
        const sel = superEditor_converter.TextSelection.between(tr.doc.resolve(anchor), tr.doc.resolve(head));
        tr.setSelection(sel);
      }
    }
  }
};
const getRelativeSelection = (pmbinding, state) => ({
  type: (
    /** @type {any} */
    state.selection.jsonID
  ),
  anchor: absolutePositionToRelativePosition(
    state.selection.anchor,
    pmbinding.type,
    pmbinding.mapping
  ),
  head: absolutePositionToRelativePosition(
    state.selection.head,
    pmbinding.type,
    pmbinding.mapping
  )
});
class ProsemirrorBinding {
  /**
   * @param {Y.XmlFragment} yXmlFragment The bind source
   * @param {ProsemirrorMapping} mapping
   */
  constructor(yXmlFragment, mapping = /* @__PURE__ */ new Map()) {
    this.type = yXmlFragment;
    this.prosemirrorView = null;
    this.mux = createMutex();
    this.mapping = mapping;
    this.isOMark = /* @__PURE__ */ new Map();
    this._observeFunction = this._typeChanged.bind(this);
    this.doc = yXmlFragment.doc;
    this.beforeTransactionSelection = null;
    this.beforeAllTransactions = () => {
      if (this.beforeTransactionSelection === null && this.prosemirrorView != null) {
        this.beforeTransactionSelection = getRelativeSelection(
          this,
          this.prosemirrorView.state
        );
      }
    };
    this.afterAllTransactions = () => {
      this.beforeTransactionSelection = null;
    };
    this._domSelectionInView = null;
  }
  /**
   * Create a transaction for changing the prosemirror state.
   *
   * @returns
   */
  get _tr() {
    return this.prosemirrorView.state.tr.setMeta("addToHistory", false);
  }
  _isLocalCursorInView() {
    if (!this.prosemirrorView.hasFocus()) return false;
    if (isBrowser$4 && this._domSelectionInView === null) {
      timeout(0, () => {
        this._domSelectionInView = null;
      });
      this._domSelectionInView = this._isDomSelectionInView();
    }
    return this._domSelectionInView;
  }
  _isDomSelectionInView() {
    const selection = this.prosemirrorView._root.getSelection();
    if (selection == null || selection.anchorNode == null) return false;
    const range = this.prosemirrorView._root.createRange();
    range.setStart(selection.anchorNode, selection.anchorOffset);
    range.setEnd(selection.focusNode, selection.focusOffset);
    const rects = range.getClientRects();
    if (rects.length === 0) {
      if (range.startContainer && range.collapsed) {
        range.selectNodeContents(range.startContainer);
      }
    }
    const bounding = range.getBoundingClientRect();
    const documentElement = doc.documentElement;
    return bounding.bottom >= 0 && bounding.right >= 0 && bounding.left <= (window.innerWidth || documentElement.clientWidth || 0) && bounding.top <= (window.innerHeight || documentElement.clientHeight || 0);
  }
  /**
   * @param {Y.Snapshot} snapshot
   * @param {Y.Snapshot} prevSnapshot
   */
  renderSnapshot(snapshot, prevSnapshot) {
    if (!prevSnapshot) {
      prevSnapshot = Y__namespace.createSnapshot(Y__namespace.createDeleteSet(), /* @__PURE__ */ new Map());
    }
    this.prosemirrorView.dispatch(
      this._tr.setMeta(ySyncPluginKey, { snapshot, prevSnapshot })
    );
  }
  unrenderSnapshot() {
    this.mapping.clear();
    this.mux(() => {
      const fragmentContent = this.type.toArray().map(
        (t) => createNodeFromYElement(
          /** @type {Y.XmlElement} */
          t,
          this.prosemirrorView.state.schema,
          this
        )
      ).filter((n) => n !== null);
      const tr = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new superEditor_converter.Slice(superEditor_converter.Fragment.from(fragmentContent), 0, 0)
      );
      tr.setMeta(ySyncPluginKey, { snapshot: null, prevSnapshot: null });
      this.prosemirrorView.dispatch(tr);
    });
  }
  _forceRerender() {
    this.mapping.clear();
    this.mux(() => {
      const sel = this.beforeTransactionSelection !== null ? null : this.prosemirrorView.state.selection;
      const fragmentContent = this.type.toArray().map(
        (t) => createNodeFromYElement(
          /** @type {Y.XmlElement} */
          t,
          this.prosemirrorView.state.schema,
          this
        )
      ).filter((n) => n !== null);
      const tr = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new superEditor_converter.Slice(superEditor_converter.Fragment.from(fragmentContent), 0, 0)
      );
      if (sel) {
        const clampedAnchor = min$1(max$1(sel.anchor, 0), tr.doc.content.size);
        const clampedHead = min$1(max$1(sel.head, 0), tr.doc.content.size);
        tr.setSelection(superEditor_converter.TextSelection.create(tr.doc, clampedAnchor, clampedHead));
      }
      this.prosemirrorView.dispatch(
        tr.setMeta(ySyncPluginKey, { isChangeOrigin: true, binding: this })
      );
    });
  }
  /**
   * @param {Y.Snapshot|Uint8Array} snapshot
   * @param {Y.Snapshot|Uint8Array} prevSnapshot
   * @param {Object} pluginState
   */
  _renderSnapshot(snapshot, prevSnapshot, pluginState) {
    let historyDoc = this.doc;
    let historyType = this.type;
    if (!snapshot) {
      snapshot = Y__namespace.snapshot(this.doc);
    }
    if (snapshot instanceof Uint8Array || prevSnapshot instanceof Uint8Array) {
      if (!(snapshot instanceof Uint8Array) || !(prevSnapshot instanceof Uint8Array)) {
        unexpectedCase();
      }
      historyDoc = new Y__namespace.Doc({ gc: false });
      Y__namespace.applyUpdateV2(historyDoc, prevSnapshot);
      prevSnapshot = Y__namespace.snapshot(historyDoc);
      Y__namespace.applyUpdateV2(historyDoc, snapshot);
      snapshot = Y__namespace.snapshot(historyDoc);
      if (historyType._item === null) {
        const rootKey = Array.from(this.doc.share.keys()).find(
          (key2) => this.doc.share.get(key2) === this.type
        );
        historyType = historyDoc.getXmlFragment(rootKey);
      } else {
        const historyStructs = historyDoc.store.clients.get(historyType._item.id.client) ?? [];
        const itemIndex = Y__namespace.findIndexSS(
          historyStructs,
          historyType._item.id.clock
        );
        const item = (
          /** @type {Y.Item} */
          historyStructs[itemIndex]
        );
        const content = (
          /** @type {Y.ContentType} */
          item.content
        );
        historyType = /** @type {Y.XmlFragment} */
        content.type;
      }
    }
    this.mapping.clear();
    this.mux(() => {
      historyDoc.transact((transaction) => {
        const pud = pluginState.permanentUserData;
        if (pud) {
          pud.dss.forEach((ds) => {
            Y__namespace.iterateDeletedStructs(transaction, ds, (_item) => {
            });
          });
        }
        const computeYChange = (type, id) => {
          const user = type === "added" ? pud.getUserByClientId(id.client) : pud.getUserByDeletedId(id);
          return {
            user,
            type,
            color: getUserColor(
              pluginState.colorMapping,
              pluginState.colors,
              user
            )
          };
        };
        const fragmentContent = Y__namespace.typeListToArraySnapshot(
          historyType,
          new Y__namespace.Snapshot(prevSnapshot.ds, snapshot.sv)
        ).map((t) => {
          if (!t._item.deleted || isVisible(t._item, snapshot) || isVisible(t._item, prevSnapshot)) {
            return createNodeFromYElement(
              t,
              this.prosemirrorView.state.schema,
              { mapping: /* @__PURE__ */ new Map(), isOMark: /* @__PURE__ */ new Map() },
              snapshot,
              prevSnapshot,
              computeYChange
            );
          } else {
            return null;
          }
        }).filter((n) => n !== null);
        const tr = this._tr.replace(
          0,
          this.prosemirrorView.state.doc.content.size,
          new superEditor_converter.Slice(superEditor_converter.Fragment.from(fragmentContent), 0, 0)
        );
        this.prosemirrorView.dispatch(
          tr.setMeta(ySyncPluginKey, { isChangeOrigin: true })
        );
      }, ySyncPluginKey);
    });
  }
  /**
   * @param {Array<Y.YEvent<any>>} events
   * @param {Y.Transaction} transaction
   */
  _typeChanged(events2, transaction) {
    if (this.prosemirrorView == null) return;
    const syncState = ySyncPluginKey.getState(this.prosemirrorView.state);
    if (events2.length === 0 || syncState.snapshot != null || syncState.prevSnapshot != null) {
      this.renderSnapshot(syncState.snapshot, syncState.prevSnapshot);
      return;
    }
    this.mux(() => {
      const delType = (_2, type) => this.mapping.delete(type);
      Y__namespace.iterateDeletedStructs(
        transaction,
        transaction.deleteSet,
        (struct) => {
          if (struct.constructor === Y__namespace.Item) {
            const type = (
              /** @type {Y.ContentType} */
              /** @type {Y.Item} */
              struct.content.type
            );
            type && this.mapping.delete(type);
          }
        }
      );
      transaction.changed.forEach(delType);
      transaction.changedParentTypes.forEach(delType);
      const fragmentContent = this.type.toArray().map(
        (t) => createNodeIfNotExists(
          /** @type {Y.XmlElement | Y.XmlHook} */
          t,
          this.prosemirrorView.state.schema,
          this
        )
      ).filter((n) => n !== null);
      let tr = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new superEditor_converter.Slice(superEditor_converter.Fragment.from(fragmentContent), 0, 0)
      );
      restoreRelativeSelection(tr, this.beforeTransactionSelection, this);
      tr = tr.setMeta(ySyncPluginKey, { isChangeOrigin: true, isUndoRedoOperation: transaction.origin instanceof Y__namespace.UndoManager });
      if (this.beforeTransactionSelection !== null && this._isLocalCursorInView()) {
        tr.scrollIntoView();
      }
      this.prosemirrorView.dispatch(tr);
    });
  }
  /**
   * @param {import('prosemirror-model').Node} doc
   */
  _prosemirrorChanged(doc2) {
    this.doc.transact(() => {
      updateYFragment(this.doc, this.type, doc2, this);
      this.beforeTransactionSelection = getRelativeSelection(
        this,
        this.prosemirrorView.state
      );
    }, ySyncPluginKey);
  }
  /**
   * View is ready to listen to changes. Register observers.
   * @param {any} prosemirrorView
   */
  initView(prosemirrorView) {
    if (this.prosemirrorView != null) this.destroy();
    this.prosemirrorView = prosemirrorView;
    this.doc.on("beforeAllTransactions", this.beforeAllTransactions);
    this.doc.on("afterAllTransactions", this.afterAllTransactions);
    this.type.observeDeep(this._observeFunction);
  }
  destroy() {
    if (this.prosemirrorView == null) return;
    this.prosemirrorView = null;
    this.type.unobserveDeep(this._observeFunction);
    this.doc.off("beforeAllTransactions", this.beforeAllTransactions);
    this.doc.off("afterAllTransactions", this.afterAllTransactions);
  }
}
const createNodeIfNotExists = (el, schema, meta, snapshot, prevSnapshot, computeYChange) => {
  const node = (
    /** @type {PModel.Node} */
    meta.mapping.get(el)
  );
  if (node === void 0) {
    if (el instanceof Y__namespace.XmlElement) {
      return createNodeFromYElement(
        el,
        schema,
        meta,
        snapshot,
        prevSnapshot,
        computeYChange
      );
    } else {
      throw methodUnimplemented();
    }
  }
  return node;
};
const createNodeFromYElement = (el, schema, meta, snapshot, prevSnapshot, computeYChange) => {
  const children = [];
  const createChildren = (type) => {
    if (type instanceof Y__namespace.XmlElement) {
      const n = createNodeIfNotExists(
        type,
        schema,
        meta,
        snapshot,
        prevSnapshot,
        computeYChange
      );
      if (n !== null) {
        children.push(n);
      }
    } else {
      const nextytext = (
        /** @type {Y.ContentType} */
        type._item.right?.content?.type
      );
      if (nextytext instanceof Y__namespace.Text && !nextytext._item.deleted && nextytext._item.id.client === nextytext.doc.clientID) {
        type.applyDelta([
          { retain: type.length },
          ...nextytext.toDelta()
        ]);
        nextytext.doc.transact((tr) => {
          nextytext._item.delete(tr);
        });
      }
      const ns = createTextNodesFromYText(
        type,
        schema,
        meta,
        snapshot,
        prevSnapshot,
        computeYChange
      );
      if (ns !== null) {
        ns.forEach((textchild) => {
          if (textchild !== null) {
            children.push(textchild);
          }
        });
      }
    }
  };
  if (snapshot === void 0 || prevSnapshot === void 0) {
    el.toArray().forEach(createChildren);
  } else {
    Y__namespace.typeListToArraySnapshot(el, new Y__namespace.Snapshot(prevSnapshot.ds, snapshot.sv)).forEach(createChildren);
  }
  try {
    const attrs = el.getAttributes(snapshot);
    if (snapshot !== void 0) {
      if (!isVisible(
        /** @type {Y.Item} */
        el._item,
        snapshot
      )) {
        attrs.ychange = computeYChange ? computeYChange(
          "removed",
          /** @type {Y.Item} */
          el._item.id
        ) : { type: "removed" };
      } else if (!isVisible(
        /** @type {Y.Item} */
        el._item,
        prevSnapshot
      )) {
        attrs.ychange = computeYChange ? computeYChange(
          "added",
          /** @type {Y.Item} */
          el._item.id
        ) : { type: "added" };
      }
    }
    const node = schema.node(el.nodeName, attrs, children);
    meta.mapping.set(el, node);
    return node;
  } catch (e) {
    el.doc.transact((transaction) => {
      el._item.delete(transaction);
    }, ySyncPluginKey);
    meta.mapping.delete(el);
    return null;
  }
};
const createTextNodesFromYText = (text, schema, _meta, snapshot, prevSnapshot, computeYChange) => {
  const nodes = [];
  const deltas = text.toDelta(snapshot, prevSnapshot, computeYChange);
  try {
    for (let i = 0; i < deltas.length; i++) {
      const delta = deltas[i];
      nodes.push(schema.text(delta.insert, attributesToMarks(delta.attributes, schema)));
    }
  } catch (e) {
    text.doc.transact((transaction) => {
      text._item.delete(transaction);
    }, ySyncPluginKey);
    return null;
  }
  return nodes;
};
const createTypeFromTextNodes = (nodes, meta) => {
  const type = new Y__namespace.XmlText();
  const delta = nodes.map((node) => ({
    // @ts-ignore
    insert: node.text,
    attributes: marksToAttributes(node.marks, meta)
  }));
  type.applyDelta(delta);
  meta.mapping.set(type, nodes);
  return type;
};
const createTypeFromElementNode = (node, meta) => {
  const type = new Y__namespace.XmlElement(node.type.name);
  for (const key2 in node.attrs) {
    const val = node.attrs[key2];
    if (val !== null && key2 !== "ychange") {
      type.setAttribute(key2, val);
    }
  }
  type.insert(
    0,
    normalizePNodeContent(node).map(
      (n) => createTypeFromTextOrElementNode(n, meta)
    )
  );
  meta.mapping.set(type, node);
  return type;
};
const createTypeFromTextOrElementNode = (node, meta) => node instanceof Array ? createTypeFromTextNodes(node, meta) : createTypeFromElementNode(node, meta);
const isObject$2 = (val) => typeof val === "object" && val !== null;
const equalAttrs = (pattrs, yattrs) => {
  const keys2 = Object.keys(pattrs).filter((key2) => pattrs[key2] !== null);
  let eq2 = keys2.length === (yattrs == null ? 0 : Object.keys(yattrs).filter((key2) => yattrs[key2] !== null).length);
  for (let i = 0; i < keys2.length && eq2; i++) {
    const key2 = keys2[i];
    const l = pattrs[key2];
    const r2 = yattrs[key2];
    eq2 = key2 === "ychange" || l === r2 || isObject$2(l) && isObject$2(r2) && equalAttrs(l, r2);
  }
  return eq2;
};
const normalizePNodeContent = (pnode) => {
  const c2 = pnode.content.content;
  const res = [];
  for (let i = 0; i < c2.length; i++) {
    const n = c2[i];
    if (n.isText) {
      const textNodes = [];
      for (let tnode = c2[i]; i < c2.length && tnode.isText; tnode = c2[++i]) {
        textNodes.push(tnode);
      }
      i--;
      res.push(textNodes);
    } else {
      res.push(n);
    }
  }
  return res;
};
const equalYTextPText = (ytext, ptexts) => {
  const delta = ytext.toDelta();
  return delta.length === ptexts.length && delta.every(
    /** @type {(d:any,i:number) => boolean} */
    (d, i) => d.insert === /** @type {any} */
    ptexts[i].text && keys$1(d.attributes || {}).length === ptexts[i].marks.length && every(d.attributes, (attr, yattrname) => {
      const markname = yattr2markname(yattrname);
      const pmarks = ptexts[i].marks;
      return equalAttrs(attr, pmarks.find(
        /** @param {any} mark */
        (mark) => mark.type.name === markname
      )?.attrs);
    })
  );
};
const equalYTypePNode = (ytype, pnode) => {
  if (ytype instanceof Y__namespace.XmlElement && !(pnode instanceof Array) && matchNodeName(ytype, pnode)) {
    const normalizedContent = normalizePNodeContent(pnode);
    return ytype._length === normalizedContent.length && equalAttrs(ytype.getAttributes(), pnode.attrs) && ytype.toArray().every(
      (ychild, i) => equalYTypePNode(ychild, normalizedContent[i])
    );
  }
  return ytype instanceof Y__namespace.XmlText && pnode instanceof Array && equalYTextPText(ytype, pnode);
};
const mappedIdentity = (mapped, pcontent) => mapped === pcontent || mapped instanceof Array && pcontent instanceof Array && mapped.length === pcontent.length && mapped.every(
  (a, i) => pcontent[i] === a
);
const computeChildEqualityFactor = (ytype, pnode, meta) => {
  const yChildren = ytype.toArray();
  const pChildren = normalizePNodeContent(pnode);
  const pChildCnt = pChildren.length;
  const yChildCnt = yChildren.length;
  const minCnt = min$1(yChildCnt, pChildCnt);
  let left2 = 0;
  let right2 = 0;
  let foundMappedChild = false;
  for (; left2 < minCnt; left2++) {
    const leftY = yChildren[left2];
    const leftP = pChildren[left2];
    if (mappedIdentity(meta.mapping.get(leftY), leftP)) {
      foundMappedChild = true;
    } else if (!equalYTypePNode(leftY, leftP)) {
      break;
    }
  }
  for (; left2 + right2 < minCnt; right2++) {
    const rightY = yChildren[yChildCnt - right2 - 1];
    const rightP = pChildren[pChildCnt - right2 - 1];
    if (mappedIdentity(meta.mapping.get(rightY), rightP)) {
      foundMappedChild = true;
    } else if (!equalYTypePNode(rightY, rightP)) {
      break;
    }
  }
  return {
    equalityFactor: left2 + right2,
    foundMappedChild
  };
};
const ytextTrans = (ytext) => {
  let str = "";
  let n = ytext._start;
  const nAttrs = {};
  while (n !== null) {
    if (!n.deleted) {
      if (n.countable && n.content instanceof Y__namespace.ContentString) {
        str += n.content.str;
      } else if (n.content instanceof Y__namespace.ContentFormat) {
        nAttrs[n.content.key] = null;
      }
    }
    n = n.right;
  }
  return {
    str,
    nAttrs
  };
};
const updateYText = (ytext, ptexts, meta) => {
  meta.mapping.set(ytext, ptexts);
  const { nAttrs, str } = ytextTrans(ytext);
  const content = ptexts.map((p2) => ({
    insert: (
      /** @type {any} */
      p2.text
    ),
    attributes: Object.assign({}, nAttrs, marksToAttributes(p2.marks, meta))
  }));
  const { insert, remove, index: index2 } = simpleDiff(
    str,
    content.map((c2) => c2.insert).join("")
  );
  ytext.delete(index2, remove);
  ytext.insert(index2, insert);
  ytext.applyDelta(
    content.map((c2) => ({ retain: c2.insert.length, attributes: c2.attributes }))
  );
};
const hashedMarkNameRegex = /(.*)(--[a-zA-Z0-9+/=]{8})$/;
const yattr2markname = (attrName) => hashedMarkNameRegex.exec(attrName)?.[1] ?? attrName;
const attributesToMarks = (attrs, schema) => {
  const marks = [];
  for (const markName in attrs) {
    marks.push(schema.mark(yattr2markname(markName), attrs[markName]));
  }
  return marks;
};
const marksToAttributes = (marks, meta) => {
  const pattrs = {};
  marks.forEach((mark) => {
    if (mark.type.name !== "ychange") {
      const isOverlapping = setIfUndefined(meta.isOMark, mark.type, () => !mark.type.excludes(mark.type));
      pattrs[isOverlapping ? `${mark.type.name}--${hashOfJSON(mark.toJSON())}` : mark.type.name] = mark.attrs;
    }
  });
  return pattrs;
};
const updateYFragment = (y2, yDomFragment, pNode, meta) => {
  if (yDomFragment instanceof Y__namespace.XmlElement && yDomFragment.nodeName !== pNode.type.name) {
    throw new Error("node name mismatch!");
  }
  meta.mapping.set(yDomFragment, pNode);
  if (yDomFragment instanceof Y__namespace.XmlElement) {
    const yDomAttrs = yDomFragment.getAttributes();
    const pAttrs = pNode.attrs;
    for (const key2 in pAttrs) {
      if (pAttrs[key2] !== null) {
        if (yDomAttrs[key2] !== pAttrs[key2] && key2 !== "ychange") {
          yDomFragment.setAttribute(key2, pAttrs[key2]);
        }
      } else {
        yDomFragment.removeAttribute(key2);
      }
    }
    for (const key2 in yDomAttrs) {
      if (pAttrs[key2] === void 0) {
        yDomFragment.removeAttribute(key2);
      }
    }
  }
  const pChildren = normalizePNodeContent(pNode);
  const pChildCnt = pChildren.length;
  const yChildren = yDomFragment.toArray();
  const yChildCnt = yChildren.length;
  const minCnt = min$1(pChildCnt, yChildCnt);
  let left2 = 0;
  let right2 = 0;
  for (; left2 < minCnt; left2++) {
    const leftY = yChildren[left2];
    const leftP = pChildren[left2];
    if (!mappedIdentity(meta.mapping.get(leftY), leftP)) {
      if (equalYTypePNode(leftY, leftP)) {
        meta.mapping.set(leftY, leftP);
      } else {
        break;
      }
    }
  }
  for (; right2 + left2 < minCnt; right2++) {
    const rightY = yChildren[yChildCnt - right2 - 1];
    const rightP = pChildren[pChildCnt - right2 - 1];
    if (!mappedIdentity(meta.mapping.get(rightY), rightP)) {
      if (equalYTypePNode(rightY, rightP)) {
        meta.mapping.set(rightY, rightP);
      } else {
        break;
      }
    }
  }
  y2.transact(() => {
    while (yChildCnt - left2 - right2 > 0 && pChildCnt - left2 - right2 > 0) {
      const leftY = yChildren[left2];
      const leftP = pChildren[left2];
      const rightY = yChildren[yChildCnt - right2 - 1];
      const rightP = pChildren[pChildCnt - right2 - 1];
      if (leftY instanceof Y__namespace.XmlText && leftP instanceof Array) {
        if (!equalYTextPText(leftY, leftP)) {
          updateYText(leftY, leftP, meta);
        }
        left2 += 1;
      } else {
        let updateLeft = leftY instanceof Y__namespace.XmlElement && matchNodeName(leftY, leftP);
        let updateRight = rightY instanceof Y__namespace.XmlElement && matchNodeName(rightY, rightP);
        if (updateLeft && updateRight) {
          const equalityLeft = computeChildEqualityFactor(
            /** @type {Y.XmlElement} */
            leftY,
            /** @type {PModel.Node} */
            leftP,
            meta
          );
          const equalityRight = computeChildEqualityFactor(
            /** @type {Y.XmlElement} */
            rightY,
            /** @type {PModel.Node} */
            rightP,
            meta
          );
          if (equalityLeft.foundMappedChild && !equalityRight.foundMappedChild) {
            updateRight = false;
          } else if (!equalityLeft.foundMappedChild && equalityRight.foundMappedChild) {
            updateLeft = false;
          } else if (equalityLeft.equalityFactor < equalityRight.equalityFactor) {
            updateLeft = false;
          } else {
            updateRight = false;
          }
        }
        if (updateLeft) {
          updateYFragment(
            y2,
            /** @type {Y.XmlFragment} */
            leftY,
            /** @type {PModel.Node} */
            leftP,
            meta
          );
          left2 += 1;
        } else if (updateRight) {
          updateYFragment(
            y2,
            /** @type {Y.XmlFragment} */
            rightY,
            /** @type {PModel.Node} */
            rightP,
            meta
          );
          right2 += 1;
        } else {
          meta.mapping.delete(yDomFragment.get(left2));
          yDomFragment.delete(left2, 1);
          yDomFragment.insert(left2, [
            createTypeFromTextOrElementNode(leftP, meta)
          ]);
          left2 += 1;
        }
      }
    }
    const yDelLen = yChildCnt - left2 - right2;
    if (yChildCnt === 1 && pChildCnt === 0 && yChildren[0] instanceof Y__namespace.XmlText) {
      meta.mapping.delete(yChildren[0]);
      yChildren[0].delete(0, yChildren[0].length);
    } else if (yDelLen > 0) {
      yDomFragment.slice(left2, left2 + yDelLen).forEach((type) => meta.mapping.delete(type));
      yDomFragment.delete(left2, yDelLen);
    }
    if (left2 + right2 < pChildCnt) {
      const ins = [];
      for (let i = left2; i < pChildCnt - right2; i++) {
        ins.push(createTypeFromTextOrElementNode(pChildren[i], meta));
      }
      yDomFragment.insert(left2, ins);
    }
  }, ySyncPluginKey);
};
const matchNodeName = (yElement, pNode) => !(pNode instanceof Array) && yElement.nodeName === pNode.type.name;
let viewsToUpdate = null;
const updateMetas = () => {
  const ups = (
    /** @type {Map<EditorView, Map<any, any>>} */
    viewsToUpdate
  );
  viewsToUpdate = null;
  ups.forEach((metas, view) => {
    const tr = view.state.tr;
    const syncState = ySyncPluginKey.getState(view.state);
    if (syncState && syncState.binding && !syncState.binding.isDestroyed) {
      metas.forEach((val, key2) => {
        tr.setMeta(key2, val);
      });
      view.dispatch(tr);
    }
  });
};
const setMeta$1 = (view, key2, value) => {
  if (!viewsToUpdate) {
    viewsToUpdate = /* @__PURE__ */ new Map();
    timeout(0, updateMetas);
  }
  setIfUndefined(viewsToUpdate, view, create).set(key2, value);
};
const absolutePositionToRelativePosition = (pos, type, mapping) => {
  if (pos === 0) {
    return Y__namespace.createRelativePositionFromTypeIndex(type, 0, type.length === 0 ? -1 : 0);
  }
  let n = type._first === null ? null : (
    /** @type {Y.ContentType} */
    type._first.content.type
  );
  while (n !== null && type !== n) {
    if (n instanceof Y__namespace.XmlText) {
      if (n._length >= pos) {
        return Y__namespace.createRelativePositionFromTypeIndex(n, pos, type.length === 0 ? -1 : 0);
      } else {
        pos -= n._length;
      }
      if (n._item !== null && n._item.next !== null) {
        n = /** @type {Y.ContentType} */
        n._item.next.content.type;
      } else {
        do {
          n = n._item === null ? null : n._item.parent;
          pos--;
        } while (n !== type && n !== null && n._item !== null && n._item.next === null);
        if (n !== null && n !== type) {
          n = n._item === null ? null : (
            /** @type {Y.ContentType} */
            /** @type Y.Item */
            n._item.next.content.type
          );
        }
      }
    } else {
      const pNodeSize = (
        /** @type {any} */
        (mapping.get(n) || { nodeSize: 0 }).nodeSize
      );
      if (n._first !== null && pos < pNodeSize) {
        n = /** @type {Y.ContentType} */
        n._first.content.type;
        pos--;
      } else {
        if (pos === 1 && n._length === 0 && pNodeSize > 1) {
          return new Y__namespace.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? Y__namespace.findRootTypeKey(n) : null, null);
        }
        pos -= pNodeSize;
        if (n._item !== null && n._item.next !== null) {
          n = /** @type {Y.ContentType} */
          n._item.next.content.type;
        } else {
          if (pos === 0) {
            n = n._item === null ? n : n._item.parent;
            return new Y__namespace.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? Y__namespace.findRootTypeKey(n) : null, null);
          }
          do {
            n = /** @type {Y.Item} */
            n._item.parent;
            pos--;
          } while (n !== type && /** @type {Y.Item} */
          n._item.next === null);
          if (n !== type) {
            n = /** @type {Y.ContentType} */
            /** @type {Y.Item} */
            /** @type {Y.Item} */
            n._item.next.content.type;
          }
        }
      }
    }
    if (n === null) {
      throw unexpectedCase();
    }
    if (pos === 0 && n.constructor !== Y__namespace.XmlText && n !== type) {
      return createRelativePosition(n._item.parent, n._item);
    }
  }
  return Y__namespace.createRelativePositionFromTypeIndex(type, type._length, type.length === 0 ? -1 : 0);
};
const createRelativePosition = (type, item) => {
  let typeid = null;
  let tname = null;
  if (type._item === null) {
    tname = Y__namespace.findRootTypeKey(type);
  } else {
    typeid = Y__namespace.createID(type._item.id.client, type._item.id.clock);
  }
  return new Y__namespace.RelativePosition(typeid, tname, item.id);
};
const relativePositionToAbsolutePosition = (y2, documentType, relPos, mapping) => {
  const decodedPos = Y__namespace.createAbsolutePositionFromRelativePosition(relPos, y2);
  if (decodedPos === null || decodedPos.type !== documentType && !Y__namespace.isParentOf(documentType, decodedPos.type._item)) {
    return null;
  }
  let type = decodedPos.type;
  let pos = 0;
  if (type.constructor === Y__namespace.XmlText) {
    pos = decodedPos.index;
  } else if (type._item === null || !type._item.deleted) {
    let n = type._first;
    let i = 0;
    while (i < type._length && i < decodedPos.index && n !== null) {
      if (!n.deleted) {
        const t = (
          /** @type {Y.ContentType} */
          n.content.type
        );
        i++;
        if (t instanceof Y__namespace.XmlText) {
          pos += t._length;
        } else {
          pos += /** @type {any} */
          mapping.get(t).nodeSize;
        }
      }
      n = /** @type {Y.Item} */
      n.right;
    }
    pos += 1;
  }
  while (type !== documentType && type._item !== null) {
    const parent = type._item.parent;
    if (parent._item === null || !parent._item.deleted) {
      pos += 1;
      let n = (
        /** @type {Y.AbstractType} */
        parent._first
      );
      while (n !== null) {
        const contentType = (
          /** @type {Y.ContentType} */
          n.content.type
        );
        if (contentType === type) {
          break;
        }
        if (!n.deleted) {
          if (contentType instanceof Y__namespace.XmlText) {
            pos += contentType._length;
          } else {
            pos += /** @type {any} */
            mapping.get(contentType).nodeSize;
          }
        }
        n = n.right;
      }
    }
    type = /** @type {Y.AbstractType} */
    parent;
  }
  return pos - 1;
};
const yXmlFragmentToProseMirrorFragment = (yXmlFragment, schema) => {
  const fragmentContent = yXmlFragment.toArray().map(
    (t) => createNodeFromYElement(
      /** @type {Y.XmlElement} */
      t,
      schema,
      createEmptyMeta()
    )
  ).filter((n) => n !== null);
  return superEditor_converter.Fragment.fromArray(fragmentContent);
};
const yXmlFragmentToProseMirrorRootNode = (yXmlFragment, schema) => schema.topNodeType.create(null, yXmlFragmentToProseMirrorFragment(yXmlFragment, schema));
function prosemirrorToYDoc(doc2, xmlFragment = "prosemirror") {
  const ydoc = new Y__namespace.Doc();
  const type = (
    /** @type {Y.XmlFragment} */
    ydoc.get(xmlFragment, Y__namespace.XmlFragment)
  );
  if (!type.doc) {
    return ydoc;
  }
  prosemirrorToYXmlFragment(doc2, type);
  return type.doc;
}
function prosemirrorToYXmlFragment(doc2, xmlFragment) {
  const type = xmlFragment || new Y__namespace.XmlFragment();
  const ydoc = type.doc ? type.doc : { transact: (transaction) => transaction(void 0) };
  updateYFragment(ydoc, type, doc2, { mapping: /* @__PURE__ */ new Map(), isOMark: /* @__PURE__ */ new Map() });
  return type;
}
const defaultAwarenessStateFilter = (currentClientId, userClientId, _user) => currentClientId !== userClientId;
const defaultCursorBuilder = (user) => {
  const cursor = document.createElement("span");
  cursor.classList.add("ProseMirror-yjs-cursor");
  cursor.setAttribute("style", `border-color: ${user.color}`);
  const userDiv = document.createElement("div");
  userDiv.setAttribute("style", `background-color: ${user.color}`);
  userDiv.insertBefore(document.createTextNode(user.name), null);
  const nonbreakingSpace1 = document.createTextNode("");
  const nonbreakingSpace2 = document.createTextNode("");
  cursor.insertBefore(nonbreakingSpace1, null);
  cursor.insertBefore(userDiv, null);
  cursor.insertBefore(nonbreakingSpace2, null);
  return cursor;
};
const defaultSelectionBuilder = (user) => {
  return {
    style: `background-color: ${user.color}70`,
    class: "ProseMirror-yjs-selection"
  };
};
const rxValidColor = /^#[0-9a-fA-F]{6}$/;
const createDecorations = (state, awareness, awarenessFilter, createCursor, createSelection) => {
  const ystate = ySyncPluginKey.getState(state);
  const y2 = ystate.doc;
  const decorations = [];
  if (ystate.snapshot != null || ystate.prevSnapshot != null || ystate.binding.mapping.size === 0) {
    return DecorationSet.create(state.doc, []);
  }
  awareness.getStates().forEach((aw, clientId) => {
    if (!awarenessFilter(y2.clientID, clientId, aw)) {
      return;
    }
    if (aw.cursor != null) {
      const user = aw.user || {};
      if (user.color == null) {
        user.color = "#ffa500";
      } else if (!rxValidColor.test(user.color)) {
        console.warn("A user uses an unsupported color format", user);
      }
      if (user.name == null) {
        user.name = `User: ${clientId}`;
      }
      let anchor = relativePositionToAbsolutePosition(
        y2,
        ystate.type,
        Y__namespace.createRelativePositionFromJSON(aw.cursor.anchor),
        ystate.binding.mapping
      );
      let head = relativePositionToAbsolutePosition(
        y2,
        ystate.type,
        Y__namespace.createRelativePositionFromJSON(aw.cursor.head),
        ystate.binding.mapping
      );
      if (anchor !== null && head !== null) {
        const maxsize = max$1(state.doc.content.size - 1, 0);
        anchor = min$1(anchor, maxsize);
        head = min$1(head, maxsize);
        decorations.push(
          Decoration.widget(head, () => createCursor(user, clientId), {
            key: clientId + "",
            side: 10
          })
        );
        const from3 = min$1(anchor, head);
        const to = max$1(anchor, head);
        decorations.push(
          Decoration.inline(from3, to, createSelection(user, clientId), {
            inclusiveEnd: true,
            inclusiveStart: false
          })
        );
      }
    }
  });
  return DecorationSet.create(state.doc, decorations);
};
const yCursorPlugin = (awareness, {
  awarenessStateFilter = defaultAwarenessStateFilter,
  cursorBuilder = defaultCursorBuilder,
  selectionBuilder = defaultSelectionBuilder,
  getSelection: getSelection2 = (state) => state.selection
} = {}, cursorStateField = "cursor") => new superEditor_converter.Plugin({
  key: yCursorPluginKey,
  state: {
    init(_2, state) {
      return createDecorations(
        state,
        awareness,
        awarenessStateFilter,
        cursorBuilder,
        selectionBuilder
      );
    },
    apply(tr, prevState, _oldState, newState) {
      const ystate = ySyncPluginKey.getState(newState);
      const yCursorState = tr.getMeta(yCursorPluginKey);
      if (ystate && ystate.isChangeOrigin || yCursorState && yCursorState.awarenessUpdated) {
        return createDecorations(
          newState,
          awareness,
          awarenessStateFilter,
          cursorBuilder,
          selectionBuilder
        );
      }
      return prevState.map(tr.mapping, tr.doc);
    }
  },
  props: {
    decorations: (state) => {
      return yCursorPluginKey.getState(state);
    }
  },
  view: (view) => {
    const awarenessListener = () => {
      if (view.docView) {
        setMeta$1(view, yCursorPluginKey, { awarenessUpdated: true });
      }
    };
    const updateCursorInfo = () => {
      const ystate = ySyncPluginKey.getState(view.state);
      const current = awareness.getLocalState() || {};
      if (view.hasFocus()) {
        const selection = getSelection2(view.state);
        const anchor = absolutePositionToRelativePosition(
          selection.anchor,
          ystate.type,
          ystate.binding.mapping
        );
        const head = absolutePositionToRelativePosition(
          selection.head,
          ystate.type,
          ystate.binding.mapping
        );
        if (current.cursor == null || !Y__namespace.compareRelativePositions(
          Y__namespace.createRelativePositionFromJSON(current.cursor.anchor),
          anchor
        ) || !Y__namespace.compareRelativePositions(
          Y__namespace.createRelativePositionFromJSON(current.cursor.head),
          head
        )) {
          awareness.setLocalStateField(cursorStateField, {
            anchor,
            head
          });
        }
      } else if (current.cursor != null && relativePositionToAbsolutePosition(
        ystate.doc,
        ystate.type,
        Y__namespace.createRelativePositionFromJSON(current.cursor.anchor),
        ystate.binding.mapping
      ) !== null) {
        awareness.setLocalStateField(cursorStateField, null);
      }
    };
    awareness.on("change", awarenessListener);
    view.dom.addEventListener("focusin", updateCursorInfo);
    view.dom.addEventListener("focusout", updateCursorInfo);
    return {
      update: updateCursorInfo,
      destroy: () => {
        view.dom.removeEventListener("focusin", updateCursorInfo);
        view.dom.removeEventListener("focusout", updateCursorInfo);
        awareness.off("change", awarenessListener);
        awareness.setLocalStateField(cursorStateField, null);
      }
    };
  }
});
const undo = (state) => yUndoPluginKey.getState(state)?.undoManager?.undo() != null;
const redo = (state) => yUndoPluginKey.getState(state)?.undoManager?.redo() != null;
const defaultProtectedNodes = /* @__PURE__ */ new Set(["paragraph"]);
const defaultDeleteFilter = (item, protectedNodes) => !(item instanceof Y$1.Item) || !(item.content instanceof Y$1.ContentType) || !(item.content.type instanceof Y$1.Text || item.content.type instanceof Y$1.XmlElement && protectedNodes.has(item.content.type.nodeName)) || item.content.type._length === 0;
const yUndoPlugin = ({ protectedNodes = defaultProtectedNodes, trackedOrigins = [], undoManager = null } = {}) => new superEditor_converter.Plugin({
  key: yUndoPluginKey,
  state: {
    init: (initargs, state) => {
      const ystate = ySyncPluginKey.getState(state);
      const _undoManager = undoManager || new Y$1.UndoManager(ystate.type, {
        trackedOrigins: new Set([ySyncPluginKey].concat(trackedOrigins)),
        deleteFilter: (item) => defaultDeleteFilter(item, protectedNodes),
        captureTransaction: (tr) => tr.meta.get("addToHistory") !== false
      });
      return {
        undoManager: _undoManager,
        prevSel: null,
        hasUndoOps: _undoManager.undoStack.length > 0,
        hasRedoOps: _undoManager.redoStack.length > 0
      };
    },
    apply: (tr, val, oldState, state) => {
      const binding = ySyncPluginKey.getState(state).binding;
      const undoManager2 = val.undoManager;
      const hasUndoOps = undoManager2.undoStack.length > 0;
      const hasRedoOps = undoManager2.redoStack.length > 0;
      if (binding) {
        return {
          undoManager: undoManager2,
          prevSel: getRelativeSelection(binding, oldState),
          hasUndoOps,
          hasRedoOps
        };
      } else {
        if (hasUndoOps !== val.hasUndoOps || hasRedoOps !== val.hasRedoOps) {
          return Object.assign({}, val, {
            hasUndoOps: undoManager2.undoStack.length > 0,
            hasRedoOps: undoManager2.redoStack.length > 0
          });
        } else {
          return val;
        }
      }
    }
  },
  view: (view) => {
    const ystate = ySyncPluginKey.getState(view.state);
    const undoManager2 = yUndoPluginKey.getState(view.state).undoManager;
    undoManager2.on("stack-item-added", ({ stackItem }) => {
      const binding = ystate.binding;
      if (binding) {
        stackItem.meta.set(binding, yUndoPluginKey.getState(view.state).prevSel);
      }
    });
    undoManager2.on("stack-item-popped", ({ stackItem }) => {
      const binding = ystate.binding;
      if (binding) {
        binding.beforeTransactionSelection = stackItem.meta.get(binding) || binding.beforeTransactionSelection;
      }
    });
    return {
      destroy: () => {
        undoManager2.destroy();
      }
    };
  }
});
class Extension {
  constructor(config) {
    this.type = "extension";
    this.name = "extension";
    this.config = {
      ...config,
      name: config.name || this.name
    };
    this.name = this.config.name;
    if (this.config.addOptions) {
      this.options = callOrGet(
        getExtensionConfigField(this, "addOptions", {
          name: this.name
        })
      ) || {};
    } else {
      this.options = {};
    }
    this.storage = callOrGet(
      getExtensionConfigField(this, "addStorage", {
        name: this.name,
        options: this.options
      })
    ) || {};
  }
  /**
   * Static method for creating an extension.
   * @param config Configuration for the extension.
   */
  static create(config) {
    return new Extension(config);
  }
}
const History = Extension.create({
  name: "history",
  addOptions() {
    return {
      depth: 100,
      newGroupDelay: 500
    };
  },
  addPmPlugins() {
    if (this.editor.options.collaborationProvider && this.editor.options.ydoc) {
      const undoPlugin = createUndoPlugin();
      return [undoPlugin];
    }
    const historyPlugin = history(this.options);
    return [historyPlugin];
  },
  //prettier-ignore
  addCommands() {
    return {
      /**
       * Undo the last action
       * @category Command
       * @example
       * editor.commands.undo()
       * @note Groups changes within the newGroupDelay window
       */
      undo: () => ({ state, dispatch, tr }) => {
        if (this.editor.options.collaborationProvider && this.editor.options.ydoc) {
          tr.setMeta("preventDispatch", true);
          return undo(state);
        }
        tr.setMeta("inputType", "historyUndo");
        return undo$1(state, dispatch);
      },
      /**
       * Redo the last undone action
       * @category Command
       * @example
       * editor.commands.redo()
       * @note Only available after an undo action
       */
      redo: () => ({ state, dispatch, tr }) => {
        if (this.editor.options.collaborationProvider && this.editor.options.ydoc) {
          tr.setMeta("preventDispatch", true);
          return redo(state);
        }
        tr.setMeta("inputType", "historyRedo");
        return redo$1(state, dispatch);
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Mod-Shift-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo()
    };
  }
});
const createUndoPlugin = () => {
  const yUndoPluginInstance = yUndoPlugin();
  return yUndoPluginInstance;
};
class Attribute {
  /**
   * Get a list of all attributes defined in the extensions.
   * @param extensions List of all extensions.
   * @returns Extension attributes.
   */
  static getAttributesFromExtensions(extensions) {
    const extensionAttributes = [];
    const defaultAttribute = {
      default: null,
      rendered: true,
      renderDOM: null,
      parseDOM: null,
      keepOnSplit: true
    };
    const globalAttributes = this.#getGlobalAttributes(extensions, defaultAttribute);
    const nodeAndMarksAttributes = this.#getNodeAndMarksAttributes(extensions, defaultAttribute);
    extensionAttributes.push(...globalAttributes, ...nodeAndMarksAttributes);
    return extensionAttributes;
  }
  /**
   * Get a list of global attributes defined in the extensions.
   * @param extensions List of all extensions.
   * @param defaultAttribute Default attribute.
   * @returns Global extension attributes.
   */
  static #getGlobalAttributes(extensions, defaultAttribute) {
    const extensionAttributes = [];
    const collectAttribute = (globalAttr) => {
      for (const type of globalAttr.types) {
        const entries = Object.entries(globalAttr.attributes);
        for (const [name, attribute] of entries) {
          extensionAttributes.push({
            type,
            name,
            attribute: {
              ...defaultAttribute,
              ...attribute
            }
          });
        }
      }
    };
    for (const extension of extensions) {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addGlobalAttributes = getExtensionConfigField(
        extension,
        "addGlobalAttributes",
        context
      );
      if (!addGlobalAttributes) continue;
      const globalAttributes = addGlobalAttributes();
      for (const globalAttr of globalAttributes) {
        collectAttribute(globalAttr);
      }
    }
    return extensionAttributes;
  }
  /**
   * Get a list of attributes defined in the Node and Mark extensions.
   * @param extensions List of all extensions.
   * @param defaultAttribute Default attribute.
   * @returns Node and Mark extension attributes.
   */
  static #getNodeAndMarksAttributes(extensions, defaultAttribute) {
    const extensionAttributes = [];
    const nodeAndMarkExtensions = extensions.filter((e) => {
      return e.type === "node" || e.type === "mark";
    });
    for (const extension of nodeAndMarkExtensions) {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage
      };
      const addAttributes = getExtensionConfigField(
        extension,
        "addAttributes",
        context
      );
      if (!addAttributes) continue;
      const attributes = addAttributes();
      for (const [name, attribute] of Object.entries(attributes)) {
        const merged = {
          ...defaultAttribute,
          ...attribute
        };
        if (typeof merged.default === "function") {
          merged.default = merged.default();
        }
        extensionAttributes.push({
          type: extension.name,
          name,
          attribute: merged
        });
      }
    }
    return extensionAttributes;
  }
  /**
   * Inserts extension attributes into parseRule attributes.
   * @param parseRule PM ParseRule.
   * @param extensionAttrs List of attributes to insert.
   */
  static insertExtensionAttrsToParseRule(parseRule, extensionAttrs) {
    if ("style" in parseRule) {
      return parseRule;
    }
    return {
      ...parseRule,
      getAttrs: (node) => {
        const oldAttrs = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
        if (oldAttrs === false) return false;
        const parseFromString = (value) => {
          if (typeof value !== "string") return value;
          if (value.match(/^[+-]?(\d*\.)?\d+$/)) return Number(value);
          if (value === "true") return true;
          if (value === "false") return false;
          return value;
        };
        let newAttrs = {};
        for (const item of extensionAttrs) {
          const value = item.attribute.parseDOM ? item.attribute.parseDOM(node) : parseFromString(node.getAttribute(item.name));
          if (value === null || value === void 0) continue;
          newAttrs = {
            ...newAttrs,
            [item.name]: value
          };
        }
        return { ...oldAttrs, ...newAttrs };
      }
    };
  }
  /**
   * Get attributes to render.
   * @param nodeOrMark Node or Mark.
   * @param extensionAttrs Extension attributes.
   */
  static getAttributesToRender(nodeOrMark, extensionAttrs) {
    const attributes = extensionAttrs.filter((item) => item.attribute.rendered).map((item) => {
      if (!item.attribute.renderDOM) {
        return { [item.name]: nodeOrMark.attrs[item.name] };
      }
      return item.attribute.renderDOM(nodeOrMark.attrs) || {};
    });
    let mergedAttrs = {};
    for (const attribute of attributes) {
      mergedAttrs = this.mergeAttributes(mergedAttrs, attribute);
    }
    return mergedAttrs;
  }
  /**
   * Merges attributes.
   * @param objects Objects with attributes.
   * @returns Object with merged attributes.
   */
  static mergeAttributes(...objects) {
    const items = objects.filter((item) => !!item);
    let attrs = {};
    for (const item of items) {
      const mergedAttributes = { ...attrs };
      for (const [key2, value] of Object.entries(item)) {
        const exists2 = mergedAttributes[key2];
        if (!exists2) {
          mergedAttributes[key2] = value;
          continue;
        }
        if (key2 === "class") {
          const valueStr = typeof value === "string" ? value : String(value);
          const existingStr = typeof mergedAttributes[key2] === "string" ? mergedAttributes[key2] : String(mergedAttributes[key2] || "");
          const valueClasses = valueStr ? valueStr.split(" ") : [];
          const existingClasses = existingStr ? existingStr.split(" ") : [];
          const insertClasses = valueClasses.filter((value2) => !existingClasses.includes(value2));
          mergedAttributes[key2] = [...existingClasses, ...insertClasses].join(" ");
        } else if (key2 === "style") {
          mergedAttributes[key2] = [mergedAttributes[key2], value].join("; ");
        } else {
          mergedAttributes[key2] = value;
        }
      }
      attrs = mergedAttributes;
    }
    return attrs;
  }
  /**
   * Get extension attributes that should be splitted by keepOnSplit flag.
   * @param extensionAttrs Array of attributes.
   * @param typeName The type of the extension.
   * @param attributes The extension attributes.
   * @returns The splitted attributes.
   */
  static getSplittedAttributes(extensionAttrs, typeName, attributes) {
    const entries = Object.entries(attributes).filter(([name]) => {
      const extensionAttr = extensionAttrs.find((item) => {
        return item.type === typeName && item.name === name;
      });
      if (!extensionAttr) return false;
      return extensionAttr.attribute.keepOnSplit;
    });
    return Object.fromEntries(entries);
  }
  /**
   * Get mark attrs on the current editor state.
   * @param state The current editor state.
   * @param typeOrName The mark type or name.
   * @returns The mark attrs.
   */
  static getMarkAttributes(state, typeOrName) {
    const type = getMarkType(typeOrName, state.schema);
    const marks = getMarksFromSelection(state);
    const mark = marks.find((markItem) => markItem.type.name === type.name);
    if (!mark) return {};
    return { ...mark.attrs };
  }
  /**
   * Get node attrs on the current editor state.
   * @param state The current editor state.
   * @param typeOrName The node type or name.
   * @returns The node attrs.
   */
  static getNodeAttributes(state, typeOrName) {
    const type = getNodeType(typeOrName, state.schema);
    const { from: from3, to } = state.selection;
    const nodes = [];
    state.doc.nodesBetween(from3, to, (node2) => {
      nodes.push(node2);
    });
    const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
    if (!node) return {};
    return { ...node.attrs };
  }
  /**
   * Get node or mark attrs on the current editor state.
   * @param state The current editor state.
   * @param typeOrName The node/mark type or name.
   * @returns The attrs of the node/mark or an empty object.
   */
  static getAttributes(state, typeOrName) {
    const schemaType = getSchemaTypeNameByName(
      typeof typeOrName === "string" ? typeOrName : typeOrName.name,
      state.schema
    );
    if (schemaType === "node") {
      return this.getNodeAttributes(state, typeOrName);
    }
    if (schemaType === "mark") {
      return this.getMarkAttributes(state, typeOrName);
    }
    return {};
  }
}
class Schema {
  /**
   * Creates PM schema by resolved extensions.
   * @param extensions List of extensions.
   * @param editor Editor instance.
   * @returns PM schema
   */
  static createSchemaByExtensions(extensions, editor) {
    const nodeExtensions = extensions.filter((e) => e.type === "node");
    const markExtensions = extensions.filter((e) => e.type === "mark");
    const topNode = nodeExtensions.find((e) => getExtensionConfigField(e, "topNode"))?.name;
    const attributes = Attribute.getAttributesFromExtensions(extensions);
    const nodes = Schema.#createNodesSchema(nodeExtensions, attributes, editor);
    const marks = Schema.#createMarksSchema(markExtensions, attributes, editor);
    return new superEditor_converter.Schema({ topNode, nodes, marks });
  }
  /**
   * Creates nodes schema by Node extensions.
   * @param nodeExtensions Node extensions.
   * @param attributes List of all extension attributes.
   * @param editor Editor instance.
   * @returns Nodes schema.
   */
  static #createNodesSchema(nodeExtensions, attributes, editor) {
    const nodeEntries = nodeExtensions.map((extension) => {
      const extensionAttributes = attributes.filter((a) => a.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor
      };
      const attrs = Object.fromEntries(
        extensionAttributes.map((attr) => {
          return [attr.name, { default: attr?.attribute?.default }];
        })
      );
      const additionalNodeFields = nodeExtensions.reduce((fields, e) => {
        const extendNodeSchema = getExtensionConfigField(e, "extendNodeSchema", context);
        return {
          ...fields,
          ...extendNodeSchema ? extendNodeSchema(extension) : {}
        };
      }, {});
      const schema = cleanSchemaItem({
        content: callOrGet(getExtensionConfigField(extension, "content", context)),
        group: callOrGet(getExtensionConfigField(extension, "group", context)),
        marks: callOrGet(getExtensionConfigField(extension, "marks", context)),
        inline: callOrGet(getExtensionConfigField(extension, "inline", context)),
        atom: callOrGet(getExtensionConfigField(extension, "atom", context)),
        selectable: callOrGet(getExtensionConfigField(extension, "selectable", context)),
        draggable: callOrGet(getExtensionConfigField(extension, "draggable", context)),
        code: callOrGet(getExtensionConfigField(extension, "code", context)),
        defining: callOrGet(getExtensionConfigField(extension, "defining", context)),
        isolating: callOrGet(getExtensionConfigField(extension, "isolating", context)),
        summary: getExtensionConfigField(extension, "summary", context),
        attrs,
        ...additionalNodeFields
      });
      if (typeof extension.validChildren === "function" || Array.isArray(extension.validChildren)) {
        Object.defineProperty(schema, "validChildren", {
          enumerable: false,
          configurable: false,
          get: () => extension.validChildren
        });
      }
      const parseDOM = callOrGet(getExtensionConfigField(extension, "parseDOM", context));
      if (parseDOM) {
        schema.parseDOM = parseDOM.map((parseRule) => {
          return Attribute.insertExtensionAttrsToParseRule(parseRule, extensionAttributes);
        });
      }
      const renderDOM = getExtensionConfigField(extension, "renderDOM", context);
      if (renderDOM) {
        schema.toDOM = (node) => renderDOM({
          node,
          htmlAttributes: Attribute.getAttributesToRender(node, extensionAttributes)
        });
      }
      const renderText = getExtensionConfigField(extension, "renderText", context);
      if (renderText) {
        schema.toText = renderText;
      }
      return [extension.name, schema];
    });
    return Object.fromEntries(nodeEntries);
  }
  /**
   * Creates marks schema by Marks extensions.
   * @param markExtensions Marks extensions.
   * @param attributes List of all extension attributes.
   * @param editor Editor instance.
   * @returns Marks schema.
   */
  static #createMarksSchema(markExtensions, attributes, editor) {
    const markEntries = markExtensions.map((extension) => {
      const extensionAttributes = attributes.filter((a) => a.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor
      };
      const attrs = Object.fromEntries(
        extensionAttributes.map((attr) => {
          return [attr.name, { default: attr?.attribute?.default }];
        })
      );
      const schema = cleanSchemaItem({
        group: callOrGet(getExtensionConfigField(extension, "group", context)),
        inclusive: callOrGet(getExtensionConfigField(extension, "inclusive", context)),
        excludes: callOrGet(getExtensionConfigField(extension, "excludes", context)),
        spanning: callOrGet(getExtensionConfigField(extension, "spanning", context)),
        code: callOrGet(getExtensionConfigField(extension, "code", context)),
        attrs
      });
      const parseDOM = callOrGet(getExtensionConfigField(extension, "parseDOM", context));
      if (parseDOM) {
        schema.parseDOM = parseDOM.map((parseRule) => {
          return Attribute.insertExtensionAttrsToParseRule(parseRule, extensionAttributes);
        });
      }
      const renderDOM = getExtensionConfigField(extension, "renderDOM", context);
      if (renderDOM) {
        schema.toDOM = (mark) => renderDOM({
          mark,
          htmlAttributes: Attribute.getAttributesToRender(mark, extensionAttributes)
        });
      }
      return [extension.name, schema];
    });
    return Object.fromEntries(markEntries);
  }
}
const positionTrackerKey = new superEditor_converter.PluginKey("positionTracker");
function createPositionTrackerPlugin() {
  return new superEditor_converter.Plugin({
    key: positionTrackerKey,
    state: {
      init() {
        return {
          decorations: DecorationSet.empty,
          generation: 0
        };
      },
      apply(tr, state) {
        let { decorations, generation } = state;
        const meta = tr.getMeta(positionTrackerKey);
        if (meta?.action === "add") {
          decorations = decorations.add(tr.doc, meta.decorations);
        } else if (meta?.action === "remove") {
          const toRemove = decorations.find().filter((decoration) => meta.ids.includes(decoration.spec.id));
          decorations = decorations.remove(toRemove);
        } else if (meta?.action === "removeByType") {
          const toRemove = decorations.find().filter((decoration) => decoration.spec.type === meta.type);
          decorations = decorations.remove(toRemove);
        }
        if (tr.docChanged) {
          decorations = decorations.map(tr.mapping, tr.doc);
          generation += 1;
        }
        return { decorations, generation };
      }
    },
    props: {
      decorations() {
        return DecorationSet.empty;
      }
    }
  });
}
class PositionTracker {
  #editor;
  constructor(editor) {
    this.#editor = editor;
  }
  #getState() {
    if (!this.#editor?.state) return null;
    return positionTrackerKey.getState(this.#editor.state) ?? null;
  }
  track(from3, to, spec) {
    const id = uuid.v4();
    if (!this.#editor?.state) return id;
    const fullSpec = { kind: "range", ...spec, id };
    const deco = Decoration.inline(from3, to, {}, fullSpec);
    const tr = this.#editor.state.tr.setMeta(positionTrackerKey, {
      action: "add",
      decorations: [deco]
    }).setMeta("addToHistory", false);
    this.#editor.dispatch(tr);
    return id;
  }
  trackMany(ranges) {
    if (!this.#editor?.state) {
      return ranges.map(() => uuid.v4());
    }
    const ids = [];
    const decorations = [];
    for (const { from: from3, to, spec } of ranges) {
      const id = uuid.v4();
      ids.push(id);
      const fullSpec = { kind: "range", ...spec, id };
      decorations.push(Decoration.inline(from3, to, {}, fullSpec));
    }
    const tr = this.#editor.state.tr.setMeta(positionTrackerKey, {
      action: "add",
      decorations
    }).setMeta("addToHistory", false);
    this.#editor.dispatch(tr);
    return ids;
  }
  untrack(id) {
    if (!this.#editor?.state) return;
    const tr = this.#editor.state.tr.setMeta(positionTrackerKey, {
      action: "remove",
      ids: [id]
    }).setMeta("addToHistory", false);
    this.#editor.dispatch(tr);
  }
  untrackMany(ids) {
    if (!this.#editor?.state || ids.length === 0) return;
    const tr = this.#editor.state.tr.setMeta(positionTrackerKey, {
      action: "remove",
      ids
    }).setMeta("addToHistory", false);
    this.#editor.dispatch(tr);
  }
  untrackByType(type) {
    if (!this.#editor?.state) return;
    const tr = this.#editor.state.tr.setMeta(positionTrackerKey, {
      action: "removeByType",
      type
    }).setMeta("addToHistory", false);
    this.#editor.dispatch(tr);
  }
  resolve(id) {
    const state = this.#getState();
    if (!state) return null;
    const found = state.decorations.find().find((decoration) => decoration.spec.id === id);
    if (!found) return null;
    const spec = found.spec;
    return {
      id: spec.id,
      from: found.from,
      to: found.to,
      spec
    };
  }
  resolveMany(ids) {
    const result = /* @__PURE__ */ new Map();
    for (const id of ids) {
      result.set(id, null);
    }
    const state = this.#getState();
    if (!state || ids.length === 0) return result;
    const idSet = new Set(ids);
    for (const decoration of state.decorations.find()) {
      const spec = decoration.spec;
      if (idSet.has(spec.id)) {
        result.set(spec.id, {
          id: spec.id,
          from: decoration.from,
          to: decoration.to,
          spec
        });
      }
    }
    return result;
  }
  findByType(type) {
    const state = this.#getState();
    if (!state) return [];
    return state.decorations.find().filter((decoration) => decoration.spec.type === type).map((decoration) => {
      const spec = decoration.spec;
      return {
        id: spec.id,
        from: decoration.from,
        to: decoration.to,
        spec
      };
    });
  }
  get generation() {
    return this.#getState()?.generation ?? 0;
  }
}
class OxmlNode extends Node$1 {
  constructor(config) {
    super(config);
    this.oXmlName = config.oXmlName;
  }
  /**
   * Factory method to construct a new OxmlNode instance.
   * @param config - The OXML node configuration.
   * @returns A new OxmlNode instance.
   */
  static create(config) {
    return new OxmlNode(config);
  }
}
class EditorError extends Error {
  constructor(message) {
    super(message);
    this.name = "EditorError";
  }
}
class InvalidStateError extends EditorError {
  constructor(message) {
    super(message);
    this.name = "InvalidStateError";
  }
}
class NoSourcePathError extends EditorError {
  constructor(message) {
    super(message);
    this.name = "NoSourcePathError";
  }
}
class FileSystemNotAvailableError extends EditorError {
  constructor(message) {
    super(message);
    this.name = "FileSystemNotAvailableError";
  }
}
class DocumentLoadError extends EditorError {
  constructor(message, cause) {
    super(message);
    this.name = "DocumentLoadError";
    this.cause = cause;
  }
}
const first = (commands2) => (props) => {
  const items = typeof commands2 === "function" ? commands2(props) : commands2;
  for (let i = 0; i < items.length; i += 1) {
    if (items[i](props)) return true;
  }
  return false;
};
const command = (fn2) => (props) => fn2(props);
const insertTabChar = () => ({ tr }) => {
  tr.insertText("	", tr.selection.from, tr.selection.to);
  return true;
};
const splitRunToParagraph = () => (props) => {
  const { state, view, tr, editor } = props;
  const { $from, empty: empty2 } = state.selection;
  if (!empty2) return false;
  if ($from.parent.type.name !== "run") return false;
  let dispatchTransaction = null;
  if (view?.dispatch) {
    dispatchTransaction = view.dispatch.bind(view);
  } else if (editor?.dispatch) {
    dispatchTransaction = editor.dispatch.bind(editor);
  }
  if (!dispatchTransaction) return false;
  const handled = splitBlockPatch(
    state,
    (transaction) => {
      dispatchTransaction(transaction);
    },
    editor
  );
  if (handled) {
    tr.setMeta("preventDispatch", true);
  }
  return handled;
};
function splitBlockPatch(state, dispatch, editor) {
  let { $from } = state.selection;
  if (state.selection instanceof superEditor_converter.NodeSelection && state.selection.node.isBlock) {
    if (!$from.parentOffset || !superEditor_converter.canSplit(state.doc, $from.pos)) return false;
    if (dispatch) dispatch(state.tr.split($from.pos).scrollIntoView());
    return true;
  }
  if (!$from.depth) return false;
  let types = [];
  let splitDepth, deflt, paragraphAttrs = null, atEnd = false, atStart = false;
  for (let d = $from.depth; ; d--) {
    let node = $from.node(d);
    if (node.isBlock) {
      atEnd = $from.end(d) == $from.pos + ($from.depth - d);
      atStart = $from.start(d) == $from.pos - ($from.depth - d);
      deflt = defaultBlockAt$1($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));
      paragraphAttrs = { ...node.attrs };
      types.unshift({ type: deflt || node.type, attrs: paragraphAttrs });
      splitDepth = d;
      break;
    } else {
      if (d == 1) return false;
      types.unshift(null);
    }
  }
  let tr = state.tr;
  if (state.selection instanceof superEditor_converter.TextSelection || state.selection instanceof superEditor_converter.AllSelection) tr.deleteSelection();
  let splitPos = tr.mapping.map($from.pos);
  let can = superEditor_converter.canSplit(tr.doc, splitPos, types.length, types);
  if (!can) {
    types[0] = deflt ? { type: deflt, attrs: paragraphAttrs } : null;
    can = superEditor_converter.canSplit(tr.doc, splitPos, types.length, types);
  }
  if (!can) return false;
  tr.split(splitPos, types.length, types);
  if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {
    let first2 = tr.mapping.map($from.before(splitDepth)), $first = tr.doc.resolve(first2);
    if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))
      tr.setNodeMarkup(tr.mapping.map($from.before(splitDepth)), deflt);
  }
  applyStyleMarks(state, tr, editor, paragraphAttrs);
  if (dispatch) dispatch(tr.scrollIntoView());
  return true;
}
function applyStyleMarks(state, tr, editor, paragraphAttrs) {
  const styleId = paragraphAttrs?.paragraphProperties?.styleId;
  if (!editor?.converter && !styleId) {
    return;
  }
  try {
    const params2 = { docx: editor?.converter?.convertedXml ?? {}, numbering: editor?.converter?.numbering ?? {} };
    const resolvedPpr = styleId ? { styleId } : {};
    const runProperties = styleId ? superEditor_converter.resolveRunProperties(params2, {}, resolvedPpr, false, false) : {};
    const markDefsFromStyle = styleId ? (
      /** @type {Array<{type: string, attrs: Record<string, unknown>}>} */
      superEditor_converter.encodeMarksFromRPr(runProperties, editor?.converter?.convertedXml ?? {})
    ) : [];
    const selectionMarks = state.selection?.$from?.marks ? state.selection.$from.marks() : [];
    const selectionMarkDefs = selectionMarks.map((mark) => ({ type: mark.type.name, attrs: mark.attrs }));
    const markDefsToApply = selectionMarks.length ? selectionMarkDefs : markDefsFromStyle;
    const marksToApply = markDefsToApply.map((def) => {
      const markType = state.schema.marks[def.type];
      return markType ? markType.create(def.attrs) : null;
    }).filter(Boolean);
    if (marksToApply.length > 0) {
      tr.ensureMarks(marksToApply);
      tr.setMeta("sdStyleMarks", markDefsToApply);
    }
  } catch {
  }
}
const splitRunAtCursor = () => (props) => {
  let { state, dispatch, tr } = props;
  const sel = state.selection;
  if (!sel.empty) return false;
  const $pos = sel.$from;
  const runType = state.schema.nodes.run;
  if ($pos.parent.type !== runType) return false;
  const run = $pos.parent;
  const offset2 = $pos.parentOffset;
  const runStart = $pos.before();
  const runEnd = runStart + run.nodeSize;
  const leftFrag = run.content.cut(0, offset2);
  const rightFrag = run.content.cut(offset2);
  const leftRun = runType.create(run.attrs, leftFrag, run.marks);
  const rightRun = runType.create(run.attrs, rightFrag, run.marks);
  const gapPos = runStart + leftRun.nodeSize;
  tr.replaceWith(runStart, runEnd, [leftRun, rightRun]).setSelection(superEditor_converter.TextSelection.create(tr.doc, gapPos));
  if (dispatch) {
    dispatch(tr);
  }
  return true;
};
const insertTabCharacter = ({ tr, state, dispatch }) => {
  const { from: from3 } = tr.selection;
  const tabText = state.schema.text("	");
  tr = tr.replaceSelectionWith(tabText);
  tr = tr.setSelection(superEditor_converter.TextSelection.create(tr.doc, from3 + 1));
  if (dispatch) dispatch(tr);
  return true;
};
const insertTabNode = () => ({ tr, state, dispatch }) => {
  let newPos = tr.selection.from;
  const tabNode = state.schema?.nodes?.tab?.create();
  if (!tabNode) return insertTabCharacter({ tr, state, dispatch });
  const { from: from3 } = tr.selection;
  const $pos = tr.doc.resolve(from3);
  if ($pos.parent.type === state.schema.nodes.run) {
    if (from3 === $pos.end()) {
      newPos = $pos.end() + 1;
    } else if (from3 === $pos.start()) {
      newPos = $pos.start() - 1;
    } else {
      splitRunAtCursor()({ tr, state });
      newPos = tr.selection.from;
    }
  }
  tr.insert(newPos, tabNode);
  tr = tr.setSelection(superEditor_converter.TextSelection.create(tr.doc, newPos + tabNode.nodeSize));
  if (dispatch) dispatch(tr);
  return true;
};
const setMeta = (key2, value) => ({ tr }) => {
  tr.setMeta(key2, value);
  return true;
};
const ensureMarks = (state, splittableMarks) => {
  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    const filtered = marks.filter((m2) => splittableMarks?.includes(m2.type.name));
    state.tr.ensureMarks(filtered);
  }
};
const splitBlock$1 = ({ keepMarks = true, attrsToRemoveOverride = [] } = {}) => (props) => {
  const { tr, state, dispatch, editor } = props;
  const { selection, doc: doc2 } = tr;
  const { $from, $to } = selection;
  const extensionAttrs = editor.extensionService.attributes;
  let newAttrs = Attribute.getSplittedAttributes(extensionAttrs, $from.node().type.name, $from.node().attrs);
  if (attrsToRemoveOverride.length > 0) {
    newAttrs = deleteAttributes(newAttrs, attrsToRemoveOverride);
  }
  if (selection instanceof superEditor_converter.NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !superEditor_converter.canSplit(doc2, $from.pos)) return false;
    if (dispatch) {
      if (keepMarks) ensureMarks(state, editor.extensionService.splittableMarks);
      tr.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) return false;
  if (dispatch) {
    const atEnd = $to.parentOffset === $to.parent.content.size;
    if (selection instanceof superEditor_converter.TextSelection) tr.deleteSelection();
    const deflt = $from.depth === 0 ? null : defaultBlockAt$1($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    let types = atEnd && deflt ? [{ type: deflt, attrs: newAttrs }] : void 0;
    let can = superEditor_converter.canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
    if (!types && !can && superEditor_converter.canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
      can = true;
      types = deflt ? [{ type: deflt, attrs: newAttrs }] : void 0;
    }
    if (can) {
      tr.split(tr.mapping.map($from.pos), 1, types);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr.mapping.map($from.before());
        const $first = tr.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) ensureMarks(state, editor.extensionService.splittableMarks);
    tr.scrollIntoView();
  }
  return true;
};
function deleteAttributes(attrs, attrsToRemove) {
  const newAttrs = { ...attrs };
  attrsToRemove.forEach((attrName) => {
    const parts = attrName.split(".");
    if (parts.length === 1) {
      delete newAttrs[attrName];
    } else {
      let current = newAttrs;
      for (let i = 0; i < parts.length - 1; i++) {
        if (current[parts[i]] == null) return;
        current = current[parts[i]];
      }
      delete current[parts[parts.length - 1]];
    }
  });
  return newAttrs;
}
const deleteSelection$1 = (state, dispatch) => {
  if (state.selection.empty)
    return false;
  if (dispatch)
    dispatch(state.tr.deleteSelection().scrollIntoView());
  return true;
};
function atBlockStart(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
    return null;
  return $cursor;
}
const joinBackward$1 = (state, dispatch, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  if (!$cut) {
    let range = $cursor.blockRange(), target = range && superEditor_converter.liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  let before = $cut.nodeBefore;
  if (deleteBarrier(state, $cut, dispatch, -1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || superEditor_converter.NodeSelection.isSelectable(before))) {
    for (let depth = $cursor.depth; ; depth--) {
      let delStep = superEditor_converter.replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), superEditor_converter.Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch) {
          let tr = state.tr.step(delStep);
          tr.setSelection(textblockAt(before, "end") ? superEditor_converter.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : superEditor_converter.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
      if (depth == 1 || $cursor.node(depth - 1).childCount > 1)
        break;
    }
  }
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }
  return false;
};
function textblockAt(node, side, only = false) {
  for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only && scan.childCount != 1)
      return false;
  }
  return false;
}
const selectNodeBackward$1 = (state, dispatch, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
      return false;
    $cut = findCutBefore($head);
  }
  let node = $cut && $cut.nodeBefore;
  if (!node || !superEditor_converter.NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(superEditor_converter.NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true;
};
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      if ($pos.index(i) > 0)
        return $pos.doc.resolve($pos.before(i + 1));
      if ($pos.node(i).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
    return null;
  return $cursor;
}
const joinForward$1 = (state, dispatch, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  if (!$cut)
    return false;
  let after = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch, 1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || superEditor_converter.NodeSelection.isSelectable(after))) {
    let delStep = superEditor_converter.replaceStep(state.doc, $cursor.before(), $cursor.after(), superEditor_converter.Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        let tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(after, "start") ? superEditor_converter.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : superEditor_converter.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
  }
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }
  return false;
};
const selectNodeForward$1 = (state, dispatch, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
      return false;
    $cut = findCutAfter($head);
  }
  let node = $cut && $cut.nodeAfter;
  if (!node || !superEditor_converter.NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(superEditor_converter.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true;
};
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      let parent = $pos.node(i);
      if ($pos.index(i) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(i + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
const joinUp$1 = (state, dispatch) => {
  let sel = state.selection, nodeSel = sel instanceof superEditor_converter.NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !superEditor_converter.canJoin(state.doc, sel.from))
      return false;
    point = sel.from;
  } else {
    point = superEditor_converter.joinPoint(state.doc, sel.from, -1);
    if (point == null)
      return false;
  }
  if (dispatch) {
    let tr = state.tr.join(point);
    if (nodeSel)
      tr.setSelection(superEditor_converter.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
const joinDown$1 = (state, dispatch) => {
  let sel = state.selection, point;
  if (sel instanceof superEditor_converter.NodeSelection) {
    if (sel.node.isTextblock || !superEditor_converter.canJoin(state.doc, sel.to))
      return false;
    point = sel.to;
  } else {
    point = superEditor_converter.joinPoint(state.doc, sel.to, 1);
    if (point == null)
      return false;
  }
  if (dispatch)
    dispatch(state.tr.join(point).scrollIntoView());
  return true;
};
const newlineInCode$1 = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  if (dispatch)
    dispatch(state.tr.insertText("\n").scrollIntoView());
  return true;
};
function defaultBlockAt(match) {
  for (let i = 0; i < match.edgeCount; i++) {
    let { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs())
      return type;
  }
  return null;
}
const exitCode$1 = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type))
    return false;
  if (dispatch) {
    let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr.setSelection(superEditor_converter.Selection.near(tr.doc.resolve(pos), 1));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
const createParagraphNear$1 = (state, dispatch) => {
  let sel = state.selection, { $from, $to } = sel;
  if (sel instanceof superEditor_converter.AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
    return false;
  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock)
    return false;
  if (dispatch) {
    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    let tr = state.tr.insert(side, type.createAndFill());
    tr.setSelection(superEditor_converter.TextSelection.create(tr.doc, side + 1));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
const liftEmptyBlock$1 = (state, dispatch) => {
  let { $cursor } = state.selection;
  if (!$cursor || $cursor.parent.content.size)
    return false;
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    let before = $cursor.before();
    if (superEditor_converter.canSplit(state.doc, before)) {
      if (dispatch)
        dispatch(state.tr.split(before).scrollIntoView());
      return true;
    }
  }
  let range = $cursor.blockRange(), target = range && superEditor_converter.liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
function splitBlockAs(splitNode) {
  return (state, dispatch) => {
    let { $from, $to } = state.selection;
    if (state.selection instanceof superEditor_converter.NodeSelection && state.selection.node.isBlock) {
      if (!$from.parentOffset || !superEditor_converter.canSplit(state.doc, $from.pos))
        return false;
      if (dispatch)
        dispatch(state.tr.split($from.pos).scrollIntoView());
      return true;
    }
    if (!$from.depth)
      return false;
    let types = [];
    let splitDepth, deflt, atEnd = false, atStart = false;
    for (let d = $from.depth; ; d--) {
      let node = $from.node(d);
      if (node.isBlock) {
        atEnd = $from.end(d) == $from.pos + ($from.depth - d);
        atStart = $from.start(d) == $from.pos - ($from.depth - d);
        deflt = defaultBlockAt($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));
        types.unshift(atEnd && deflt ? { type: deflt } : null);
        splitDepth = d;
        break;
      } else {
        if (d == 1)
          return false;
        types.unshift(null);
      }
    }
    let tr = state.tr;
    if (state.selection instanceof superEditor_converter.TextSelection || state.selection instanceof superEditor_converter.AllSelection)
      tr.deleteSelection();
    let splitPos = tr.mapping.map($from.pos);
    let can = superEditor_converter.canSplit(tr.doc, splitPos, types.length, types);
    if (!can) {
      types[0] = deflt ? { type: deflt } : null;
      can = superEditor_converter.canSplit(tr.doc, splitPos, types.length, types);
    }
    if (!can)
      return false;
    tr.split(splitPos, types.length, types);
    if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {
      let first2 = tr.mapping.map($from.before(splitDepth)), $first = tr.doc.resolve(first2);
      if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))
        tr.setNodeMarkup(tr.mapping.map($from.before(splitDepth)), deflt);
    }
    if (dispatch)
      dispatch(tr.scrollIntoView());
    return true;
  };
}
const splitBlock = splitBlockAs();
const selectAll$1 = (state, dispatch) => {
  if (dispatch)
    dispatch(state.tr.setSelection(new superEditor_converter.AllSelection(state.doc)));
  return true;
};
function joinMaybeClear(state, $pos, dispatch) {
  let before = $pos.nodeBefore, after = $pos.nodeAfter, index2 = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type))
    return false;
  if (!before.content.size && $pos.parent.canReplace(index2 - 1, index2)) {
    if (dispatch)
      dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index2, index2 + 1) || !(after.isTextblock || superEditor_converter.canJoin(state.doc, $pos.pos)))
    return false;
  if (dispatch)
    dispatch(state.tr.join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state, $cut, dispatch, dir) {
  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
  let isolated = before.type.spec.isolating || after.type.spec.isolating;
  if (!isolated && joinMaybeClear(state, $cut, dispatch))
    return true;
  let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      let end2 = $cut.pos + after.nodeSize, wrap = superEditor_converter.Fragment.empty;
      for (let i = conn.length - 1; i >= 0; i--)
        wrap = superEditor_converter.Fragment.from(conn[i].create(null, wrap));
      wrap = superEditor_converter.Fragment.from(before.copy(wrap));
      let tr = state.tr.step(new superEditor_converter.ReplaceAroundStep($cut.pos - 1, end2, $cut.pos, end2, new superEditor_converter.Slice(wrap, 1, 0), conn.length, true));
      let $joinAt = tr.doc.resolve(end2 + 2 * conn.length);
      if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && superEditor_converter.canJoin(tr.doc, $joinAt.pos))
        tr.join($joinAt.pos);
      dispatch(tr.scrollIntoView());
    }
    return true;
  }
  let selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : superEditor_converter.Selection.findFrom($cut, 1);
  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && superEditor_converter.liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    let at = before, wrap = [];
    for (; ; ) {
      wrap.push(at);
      if (at.isTextblock)
        break;
      at = at.lastChild;
    }
    let afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        let end2 = superEditor_converter.Fragment.empty;
        for (let i = wrap.length - 1; i >= 0; i--)
          end2 = superEditor_converter.Fragment.from(wrap[i].copy(end2));
        let tr = state.tr.step(new superEditor_converter.ReplaceAroundStep($cut.pos - wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new superEditor_converter.Slice(end2, wrap.length, 0), 0, true));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch) {
    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    let depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(superEditor_converter.TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
const selectTextblockStart$1 = selectTextblockSide(-1);
const selectTextblockEnd$1 = selectTextblockSide(1);
function setBlockType(nodeType, attrs = null) {
  return function(state, dispatch) {
    let applicable = false;
    for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {
      let { $from: { pos: from3 }, $to: { pos: to } } = state.selection.ranges[i];
      state.doc.nodesBetween(from3, to, (node, pos) => {
        if (applicable)
          return false;
        if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
          return;
        if (node.type == nodeType) {
          applicable = true;
        } else {
          let $pos = state.doc.resolve(pos), index2 = $pos.index();
          applicable = $pos.parent.canReplaceWith(index2, index2 + 1, nodeType);
        }
      });
    }
    if (!applicable)
      return false;
    if (dispatch) {
      let tr = state.tr;
      for (let i = 0; i < state.selection.ranges.length; i++) {
        let { $from: { pos: from3 }, $to: { pos: to } } = state.selection.ranges[i];
        tr.setBlockType(from3, to, nodeType, attrs);
      }
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
}
function chainCommands(...commands2) {
  return function(state, dispatch, view) {
    for (let i = 0; i < commands2.length; i++)
      if (commands2[i](state, dispatch, view))
        return true;
    return false;
  };
}
chainCommands(deleteSelection$1, joinBackward$1, selectNodeBackward$1);
chainCommands(deleteSelection$1, joinForward$1, selectNodeForward$1);
({
  "Enter": chainCommands(newlineInCode$1, createParagraphNear$1, liftEmptyBlock$1, splitBlock)
});
typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
const liftEmptyBlock = () => ({ state, dispatch }) => liftEmptyBlock$1(state, dispatch);
const createParagraphNear = () => ({ state, dispatch }) => {
  return createParagraphNear$1(state, dispatch);
};
const newlineInCode = () => ({ state, dispatch }) => newlineInCode$1(state, dispatch);
const exitCode = () => ({ state, dispatch }) => {
  return exitCode$1(state, dispatch);
};
function canSetMark(editor, state, tr, newMarkType) {
  let { selection } = tr;
  if (editor.options.isHeaderOrFooter) {
    selection = editor.options.lastSelection;
  }
  let cursor = null;
  if (isTextSelection(selection)) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = state.storedMarks ?? cursor.marks();
    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
  }
  return selection.ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
      if (someNodeSupportsMark) return false;
      if (node.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
const setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch, editor }) => {
  let { selection } = tr;
  if (editor.options.isHeaderOrFooter) {
    selection = editor.options.lastSelection;
  }
  const { empty: empty2, ranges } = selection;
  const type = getMarkType(typeOrName, state.schema);
  if (dispatch) {
    if (empty2) {
      const oldAttributes = Attribute.getMarkAttributes(state, type);
      tr.addStoredMark(
        type.create({
          ...oldAttributes,
          ...attributes
        })
      );
    } else {
      ranges.forEach((range) => {
        const from3 = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from3, to, (node, pos) => {
          const trimmedFrom = Math.max(pos, from3);
          const trimmedTo = Math.min(pos + node.nodeSize, to);
          const someHasMark = node.marks.find((mark) => mark.type === type);
          if (someHasMark) {
            node.marks.forEach((mark) => {
              if (type === mark.type) {
                tr.addMark(
                  trimmedFrom,
                  trimmedTo,
                  type.create({
                    ...mark.attrs,
                    ...attributes
                  })
                );
              }
            });
          } else {
            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return canSetMark(editor, state, tr, type);
};
const unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch, editor }) => {
  const { extendEmptyMarkRange = false } = options;
  let { selection } = tr;
  if (editor.options.isHeaderOrFooter) {
    selection = editor.options.lastSelection;
  }
  const type = getMarkType(typeOrName, state.schema);
  const { $from, empty: empty2, ranges } = selection;
  if (!dispatch) return true;
  if (empty2 && extendEmptyMarkRange) {
    let { from: from3, to } = selection;
    const attrs = $from.marks().find((mark) => mark.type === type)?.attrs;
    const range = getMarkRange($from, type, attrs);
    if (range) {
      from3 = range.from;
      to = range.to;
    }
    tr.removeMark(from3, to, type);
  } else {
    ranges.forEach((range) => {
      tr.removeMark(range.$from.pos, range.$to.pos, type);
    });
  }
  tr.removeStoredMark(type);
  return true;
};
const unsetAllMarks = () => ({ tr, dispatch, editor }) => {
  let { selection } = tr;
  if (editor.options.isHeaderOrFooter) {
    selection = editor.options.lastSelection;
  }
  const { empty: empty2, ranges } = selection;
  if (dispatch) {
    if (!empty2) {
      ranges.forEach((range) => {
        tr.removeMark(range.$from.pos, range.$to.pos);
      });
    }
    tr.setStoredMarks([]);
  }
  return true;
};
const toggleMark = (typeOrName, attrs = {}, options = {}) => ({ state, commands: commands2 }) => {
  const { extendEmptyMarkRange = false } = options;
  const type = getMarkType(typeOrName, state.schema);
  const isActive2 = isMarkActive(state, type, attrs);
  if (isActive2) return commands2.unsetMark(type, { extendEmptyMarkRange });
  return commands2.setMark(type, attrs);
};
const toggleMarkCascade = (markName, options = {}) => ({ state, chain, editor }) => {
  const {
    negationAttrs = { value: "0" },
    isNegation = (attrs) => attrs?.value === "0",
    styleDetector = defaultStyleDetector,
    extendEmptyMarkRange = true
  } = options;
  const selectionMarks = getMarksFromSelection(state) || [];
  const inlineMarks = selectionMarks.filter((m2) => m2.type?.name === markName);
  const hasNegation = inlineMarks.some((m2) => isNegation(m2.attrs || {}));
  const hasInline = inlineMarks.some((m2) => !isNegation(m2.attrs || {}));
  const styleOn = styleDetector({ state, selectionMarks, markName, editor });
  const cmdChain = chain();
  if (hasNegation) return cmdChain.unsetMark(markName, { extendEmptyMarkRange }).run();
  if (hasInline && styleOn) {
    return cmdChain.unsetMark(markName, { extendEmptyMarkRange }).setMark(markName, negationAttrs, { extendEmptyMarkRange }).run();
  }
  if (hasInline) return cmdChain.unsetMark(markName, { extendEmptyMarkRange }).run();
  if (styleOn) return cmdChain.setMark(markName, negationAttrs, { extendEmptyMarkRange }).run();
  return cmdChain.setMark(markName, {}, { extendEmptyMarkRange }).run();
};
function defaultStyleDetector({ state, selectionMarks, markName, editor }) {
  try {
    const styleId = getEffectiveStyleId(state, selectionMarks);
    if (!styleId || !editor?.converter?.linkedStyles) return false;
    const styles = editor.converter.linkedStyles;
    const seen = /* @__PURE__ */ new Set();
    let current = styleId;
    const key2 = mapMarkToStyleKey(markName);
    while (current && !seen.has(current)) {
      seen.add(current);
      const style2 = styles.find((s) => s.id === current);
      const def = style2?.definition?.styles || {};
      if (key2 in def) {
        const raw = def[key2];
        if (raw === void 0) return true;
        const val = raw?.value ?? raw;
        return isStyleTokenEnabled(val);
      }
      current = style2?.definition?.attrs?.basedOn || null;
    }
    return false;
  } catch {
    return false;
  }
}
function getEffectiveStyleId(state, selectionMarks) {
  const sidFromMarks = getStyleIdFromMarks(selectionMarks);
  if (sidFromMarks) return sidFromMarks;
  const $from = state.selection.$from;
  const before = $from.nodeBefore;
  const after = $from.nodeAfter;
  if (before && before.marks) {
    const sid = getStyleIdFromMarks(before.marks);
    if (sid) return sid;
  }
  if (after && after.marks) {
    const sid = getStyleIdFromMarks(after.marks);
    if (sid) return sid;
  }
  const ts = selectionMarks.find((m2) => m2.type?.name === "textStyle" && m2.attrs?.styleId);
  if (ts) return ts.attrs.styleId;
  const pos = state.selection.$from.pos;
  const $pos = state.doc.resolve(pos);
  for (let d = $pos.depth; d >= 0; d--) {
    const n = $pos.node(d);
    if (n?.type?.name === "paragraph") return n.attrs?.styleId || null;
  }
  return null;
}
function getStyleIdFromMarks(marks) {
  if (!Array.isArray(marks)) return null;
  const textStyleMark = marks.find((m2) => m2.type?.name === "textStyle" && m2.attrs?.styleId);
  if (textStyleMark) return textStyleMark.attrs.styleId;
  return null;
}
function mapMarkToStyleKey(markName) {
  if (markName === "textStyle" || markName === "color") return "color";
  return markName;
}
function isStyleTokenEnabled(val) {
  if (val === false || val === 0) return false;
  if (typeof val === "string") {
    const normalized = val.trim().toLowerCase();
    if (!normalized) return false;
    if (["0", "false", "none", "inherit", "transparent"].includes(normalized)) return false;
    return true;
  }
  return !!val;
}
const clearNodes = () => ({ state, tr, dispatch }) => {
  const { selection } = tr;
  const { ranges } = selection;
  if (!dispatch) return true;
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
      if (node.type.isText) return;
      const { doc: doc2, mapping } = tr;
      const $mappedFrom = doc2.resolve(mapping.map(pos));
      const $mappedTo = doc2.resolve(mapping.map(pos + node.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) return;
      const targetLiftDepth = superEditor_converter.liftTarget(nodeRange);
      if (node.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
const setNode = (typeOrName, attrs = {}) => ({ state, dispatch, chain }) => {
  const type = getNodeType(typeOrName, state.schema);
  if (!type.isTextblock) return false;
  return chain().command(({ commands: commands2 }) => {
    const canSetBlock = setBlockType(type, attrs)(state);
    if (canSetBlock) return true;
    return commands2.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType(type, attrs)(updatedState, dispatch);
  }).run();
};
const toggleNode = (typeOrName, toggleTypeOrName, attrs = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const toggleType = getNodeType(toggleTypeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attrs);
  if (isActive2) return commands2.setNode(toggleType);
  return commands2.setNode(type, attrs);
};
const selectAll = () => ({ state, dispatch }) => selectAll$1(state, dispatch);
const deleteSelection = () => ({ state, tr, dispatch }) => {
  const { from: from3, to, empty: empty2 } = state.selection;
  if (typeof document !== "undefined" && document.getSelection) {
    const currentDomSelection = document.getSelection();
    if (currentDomSelection?.baseNode?.data?.length === 1) {
      return false;
    }
  }
  if (empty2) {
    return deleteSelection$1(state, dispatch);
  }
  let hasListContent = false;
  state.doc.nodesBetween(from3, to, (node) => {
    if (node.type.name === "orderedList" || node.type.name === "bulletList" || node.type.name === "listItem") {
      hasListContent = true;
      return false;
    }
  });
  if (hasListContent) {
    const transaction = tr || state.tr;
    transaction.deleteRange(from3, to);
    if (dispatch) {
      dispatch(transaction);
    }
    return true;
  }
  return deleteSelection$1(state, dispatch);
};
const updateAttributes = (typeOrName, attrs = {}) => ({ tr, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (!schemaType) return false;
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr.selection.ranges.forEach((range) => {
      const from3 = range.$from.pos;
      const to = range.$to.pos;
      state.doc.nodesBetween(from3, to, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          const resolvedAttrs = mergeAttributes(node.attrs, attrs);
          tr.setNodeMarkup(pos, void 0, resolvedAttrs);
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              const trimmedFrom = Math.max(pos, from3);
              const trimmedTo = Math.min(pos + node.nodeSize, to);
              const resolvedAttrs = mergeAttributes(mark.attrs, attrs);
              tr.addMark(trimmedFrom, trimmedTo, markType.create(resolvedAttrs));
            }
          });
        }
      });
    });
    dispatch(tr);
  }
  return true;
};
const isPlainObject$4 = (value) => Boolean(value) && typeof value === "object" && !Array.isArray(value);
const assignNestedValue = (target, path, value) => {
  if (!path.includes(".")) {
    target[path] = value;
    return;
  }
  const parts = path.split(".");
  let current = target;
  for (let i = 0; i < parts.length; i += 1) {
    const part = parts[i];
    const isLast = i === parts.length - 1;
    if (isLast) {
      current[part] = value;
    } else {
      if (!isPlainObject$4(current[part])) {
        current[part] = {};
      }
      current = current[part];
    }
  }
};
const mergeAttributes = (existingAttrs = {}, newAttrs = {}) => {
  const expandedAttrs = JSON.parse(JSON.stringify(existingAttrs));
  Object.entries(newAttrs).forEach(([key2, value]) => {
    assignNestedValue(expandedAttrs, key2, value);
  });
  return expandedAttrs;
};
const resetAttributes = (typeOrName, attrs) => ({ tr, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (!schemaType) return false;
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr.selection.ranges.forEach((range) => {
      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attrs));
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attrs)));
            }
          });
        }
      });
    });
    dispatch(tr);
  }
  return true;
};
const joinUp = () => ({ state, dispatch }) => joinUp$1(state, dispatch);
const joinDown = () => ({ state, dispatch }) => joinDown$1(state, dispatch);
const joinBackward = () => ({ state, dispatch }) => {
  const { selection, doc: doc2 } = state;
  const { $from } = selection;
  if (!$from.parent.isTextblock || $from.parentOffset > 0) {
    return joinBackward$1(state, dispatch);
  }
  const beforePos = $from.before();
  const nodeBefore = doc2.resolve(beforePos).nodeBefore;
  const nodeAfter = doc2.resolve(beforePos).nodeAfter;
  const isList2 = (node) => node?.type.name === "orderedList" || node?.type.name === "bulletList";
  if (isList2(nodeBefore) || isList2(nodeAfter)) {
    return false;
  }
  return joinBackward$1(state, dispatch);
};
const joinForward = () => ({ state, dispatch }) => {
  const { selection, doc: doc2 } = state;
  const { $from } = selection;
  if (!$from.parent.isTextblock || $from.parentOffset > 0) {
    return joinForward$1(state, dispatch);
  }
  const beforePos = $from.before();
  const nodeBefore = doc2.resolve(beforePos).nodeBefore;
  const nodeAfter = doc2.resolve(beforePos).nodeAfter;
  const isList2 = (node) => node?.type.name === "orderedList" || node?.type.name === "bulletList";
  if (isList2(nodeBefore) || isList2(nodeAfter)) {
    return false;
  }
  return joinForward$1(state, dispatch);
};
const selectNodeBackward = () => ({ state, dispatch }) => {
  return selectNodeBackward$1(state, dispatch);
};
const selectNodeForward = () => ({ state, dispatch }) => selectNodeForward$1(state, dispatch);
const selectTextblockStart = () => ({ state, dispatch }) => selectTextblockStart$1(state, dispatch);
const selectTextblockEnd = () => ({ state, dispatch }) => selectTextblockEnd$1(state, dispatch);
const insertContent = (value, options = {}) => ({ tr, commands: commands2, editor }) => {
  if (options.contentType) {
    const validTypes = ["html", "markdown", "text", "schema"];
    if (!validTypes.includes(options.contentType)) {
      console.error(`[insertContent] Invalid contentType: "${options.contentType}". Use: ${validTypes.join(", ")}`);
      return false;
    }
    try {
      const processedDoc = processContent({
        content: value,
        type: options.contentType,
        editor
      });
      const jsonContent = processedDoc.toJSON();
      const ok = commands2.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, jsonContent, options);
      if (ok && (options.contentType === "html" || options.contentType === "markdown")) {
        Promise.resolve().then(() => editor.migrateListsToV2?.());
      }
      return ok;
    } catch (error) {
      console.error(`[insertContent] Failed to process ${options.contentType}:`, error);
      return false;
    }
  }
  return commands2.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);
};
const removeWhitespaces = (node) => {
  const children = node.childNodes;
  for (let i = children.length - 1; i >= 0; i -= 1) {
    const child = children[i];
    if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
      node.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces(child);
    }
  }
  return node;
};
function elementFromString(value, editor) {
  const wrappedValue = `<body>${value}</body>`;
  const html = superEditor_converter.htmlHandler(wrappedValue, editor);
  if (html === null) {
    return null;
  }
  return removeWhitespaces(html);
}
function createNodeFromContent(content, editor, options) {
  const schema = editor.schema;
  options = {
    slice: true,
    parseOptions: {},
    ...options
  };
  const isJSONContent = typeof content === "object" && content !== null;
  const isTextContent = typeof content === "string";
  if (isJSONContent) {
    try {
      const isArrayContent = Array.isArray(content) && content.length > 0;
      if (isArrayContent) {
        return superEditor_converter.Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
      }
      const node = schema.nodeFromJSON(content);
      if (options.errorOnInvalidContent) {
        node.check();
      }
      return node;
    } catch (error) {
      if (options.errorOnInvalidContent) {
        throw new Error("[super-editor error]: Invalid JSON content", { cause: error });
      }
      console.warn("[super-editor warn]: Invalid content.", "Passed value:", content, "Error:", error);
      return createNodeFromContent("", editor, options);
    }
  }
  if (isTextContent) {
    const element = elementFromString(content, editor);
    if (element === null) {
      console.warn(
        "[super-editor] Cannot parse HTML content without a DOM. HTML insertion requires a browser environment or JSDOM. Skipping insertion."
      );
      return null;
    }
    if (options.errorOnInvalidContent) {
      let hasInvalidContent = false;
      let invalidContent = "";
      const contentCheckSchema = new superEditor_converter.Schema({
        topNode: schema.spec.topNode,
        marks: schema.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: schema.spec.nodes.append({
          __supereditor__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: () => [
              {
                tag: "*",
                getAttrs: (e) => {
                  hasInvalidContent = true;
                  invalidContent = typeof e === "string" ? e : e.outerHTML;
                  return null;
                }
              }
            ]
          }
        })
      });
      if (options.slice) {
        superEditor_converter.DOMParser.fromSchema(contentCheckSchema).parseSlice(element, options.parseOptions);
      } else {
        superEditor_converter.DOMParser.fromSchema(contentCheckSchema).parse(element, options.parseOptions);
      }
      if (options.errorOnInvalidContent && hasInvalidContent) {
        throw new Error("[super-editor error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${invalidContent}`)
        });
      }
    }
    const parser = superEditor_converter.DOMParser.fromSchema(schema);
    if (options.slice) {
      return parser.parseSlice(element, options.parseOptions).content;
    }
    return parser.parse(element, options.parseOptions);
  }
  return createNodeFromContent("", editor, options);
}
function selectionToInsertionEnd(tr, startLen, bias) {
  const last = tr.steps.length - 1;
  if (last < startLen) {
    return;
  }
  const step = tr.steps[last];
  if (!(step instanceof superEditor_converter.ReplaceStep || step instanceof superEditor_converter.ReplaceAroundStep)) {
    return;
  }
  const map3 = tr.mapping.maps[last];
  let end2 = 0;
  map3.forEach((_from, _to, _newFrom, newTo) => {
    if (end2 === 0) {
      end2 = newTo;
    }
  });
  tr.setSelection(superEditor_converter.Selection.near(tr.doc.resolve(end2), bias));
}
const isFragment = (nodeOrFragment) => {
  return !("type" in nodeOrFragment);
};
const looksLikeHTML = (str) => /^\s*<[a-zA-Z][^>]*>.*<\/[a-zA-Z][^>]*>\s*$/s.test(str) || // Complete tag pair
/^\s*<[a-zA-Z][^>]*\/>\s*$/.test(str) || // Self-closing tag
/^\s*<(br|hr|img|input|meta|link|area|base|col|embed|param|source|track|wbr)\b[^>]*>\s*$/i.test(str);
const insertContentAt = (position, value, options) => ({ tr, dispatch, editor }) => {
  if (!dispatch) return true;
  options = {
    parseOptions: {},
    updateSelection: true,
    applyInputRules: false,
    applyPasteRules: false,
    // optional escape hatch to force literal text insertion
    asText: false,
    ...options
  };
  let { from: from3, to } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
  const isBareString = typeof value === "string";
  const isArrayOfText = Array.isArray(value) && value.every((v) => typeof v === "string" || v && typeof v.text === "string");
  const isTextObject = !!value && typeof value === "object" && !Array.isArray(value) && typeof value.text === "string";
  const usePlainTextPath = options.asText || isArrayOfText || isTextObject || isBareString && !looksLikeHTML(value);
  if (usePlainTextPath) {
    let textContent2;
    if (isArrayOfText) {
      textContent2 = value.map((v) => typeof v === "string" ? v : v && v.text || "").join("");
    } else if (isTextObject) {
      textContent2 = value.text;
    } else {
      textContent2 = typeof value === "string" ? value : "";
    }
    tr.insertText(textContent2, from3, to);
    if (options.updateSelection) {
      selectionToInsertionEnd(tr, tr.steps.length - 1, -1);
    }
    if (options.applyInputRules) {
      tr.setMeta("applyInputRules", { from: from3, text: textContent2 });
    }
    if (options.applyPasteRules) {
      tr.setMeta("applyPasteRules", { from: from3, text: textContent2 });
    }
    return true;
  }
  let content;
  try {
    content = createNodeFromContent(value, editor, {
      parseOptions: {
        preserveWhitespace: "full",
        ...options.parseOptions
      },
      errorOnInvalidContent: options.errorOnInvalidContent ?? editor.options.enableContentCheck
    });
  } catch (e) {
    editor.emit("contentError", {
      editor,
      error: e,
      disableCollaboration: () => {
        console.error("[super-editor error]: Unable to disable collaboration at this point in time");
      }
    });
    return false;
  }
  if (content === null) {
    return false;
  }
  let isOnlyTextContent = true;
  let isOnlyBlockContent = true;
  const nodes = isFragment(content) ? content : [content];
  nodes.forEach((node) => {
    node.check();
    isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
    isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
  });
  if (from3 === to && isOnlyBlockContent) {
    const { parent } = tr.doc.resolve(from3);
    const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
    if (isEmptyTextBlock) {
      from3 -= 1;
      to += 1;
    }
  }
  let newContent;
  if (isOnlyTextContent) {
    newContent = typeof value === "string" ? value : "";
    tr.insertText(newContent, from3, to);
  } else {
    newContent = content;
    tr.replaceWith(from3, to, newContent);
  }
  if (options.updateSelection) {
    selectionToInsertionEnd(tr, tr.steps.length - 1, -1);
  }
  if (options.applyInputRules) {
    tr.setMeta("applyInputRules", { from: from3, text: newContent });
  }
  if (options.applyPasteRules) {
    tr.setMeta("applyPasteRules", { from: from3, text: newContent });
  }
  return true;
};
const undoInputRule = () => ({ state, dispatch }) => {
  const plugins = state.plugins;
  for (let i = 0; i < plugins.length; i += 1) {
    const plugin2 = plugins[i];
    let undoable;
    if (plugin2.spec.isInputRules && (undoable = plugin2.getState(state))) {
      if (dispatch) {
        const tr = state.tr;
        const toUndo = undoable.transform;
        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }
        if (undoable.text) {
          const marks = tr.doc.resolve(undoable.from).marks();
          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
const setBodyHeaderFooter = ({ headerInches, footerInches } = {}) => ({ editor }) => {
  if (!editor) {
    console.warn("[setBodyHeaderFooter] No editor instance provided");
    return false;
  }
  const hasHeader = typeof headerInches === "number";
  const hasFooter = typeof footerInches === "number";
  if (!hasHeader && !hasFooter) {
    console.warn("[setBodyHeaderFooter] No margin values provided");
    return false;
  }
  if (hasHeader && headerInches < 0) {
    console.warn("[setBodyHeaderFooter] headerInches must be >= 0, got:", headerInches);
    return false;
  }
  if (hasFooter && footerInches < 0) {
    console.warn("[setBodyHeaderFooter] footerInches must be >= 0, got:", footerInches);
    return false;
  }
  if (!editor.updatePageStyle) {
    console.warn("[setBodyHeaderFooter] editor.updatePageStyle is not available");
    return false;
  }
  const styles = editor.getPageStyles?.() || {};
  const current = styles.pageMargins || {};
  const next = { ...current };
  if (hasHeader) next.header = headerInches;
  if (hasFooter) next.footer = footerInches;
  editor.updatePageStyle({ pageMargins: next });
  return true;
};
function getSectPrMargins(sectPr) {
  if (!sectPr || sectPr.name !== "w:sectPr") return {};
  const pgMar = sectPr.elements?.find((el) => el?.name === "w:pgMar");
  if (!pgMar?.attributes) return {};
  const a = pgMar.attributes;
  const result = {};
  if (a["w:top"] != null) result.top = helpers$1.twipsToInches(a["w:top"]);
  if (a["w:right"] != null) result.right = helpers$1.twipsToInches(a["w:right"]);
  if (a["w:bottom"] != null) result.bottom = helpers$1.twipsToInches(a["w:bottom"]);
  if (a["w:left"] != null) result.left = helpers$1.twipsToInches(a["w:left"]);
  if (a["w:header"] != null) result.header = helpers$1.twipsToInches(a["w:header"]);
  if (a["w:footer"] != null) result.footer = helpers$1.twipsToInches(a["w:footer"]);
  if (a["w:gutter"] != null) result.gutter = helpers$1.twipsToInches(a["w:gutter"]);
  return result;
}
function ensurePgMar(sectPr) {
  if (!sectPr || sectPr.name !== "w:sectPr") throw new Error("ensurePgMar: invalid sectPr node");
  if (!Array.isArray(sectPr.elements)) sectPr.elements = [];
  let pgMar = sectPr.elements.find((el) => el?.name === "w:pgMar");
  if (!pgMar) {
    pgMar = { type: "element", name: "w:pgMar", attributes: {} };
    sectPr.elements.push(pgMar);
  } else if (!pgMar.attributes) {
    pgMar.attributes = {};
  }
  return pgMar;
}
function updateSectPrMargins(sectPr, updates = {}) {
  if (!sectPr || sectPr.name !== "w:sectPr") throw new Error("updateSectPrMargins: invalid sectPr node");
  const pgMar = ensurePgMar(sectPr);
  const a = pgMar.attributes;
  if (updates.topInches != null) a["w:top"] = String(helpers$1.inchesToTwips(updates.topInches));
  if (updates.rightInches != null) a["w:right"] = String(helpers$1.inchesToTwips(updates.rightInches));
  if (updates.bottomInches != null) a["w:bottom"] = String(helpers$1.inchesToTwips(updates.bottomInches));
  if (updates.leftInches != null) a["w:left"] = String(helpers$1.inchesToTwips(updates.leftInches));
  if (updates.headerInches != null) a["w:header"] = String(helpers$1.inchesToTwips(updates.headerInches));
  if (updates.footerInches != null) a["w:footer"] = String(helpers$1.inchesToTwips(updates.footerInches));
  if (updates.gutterInches != null) a["w:gutter"] = String(helpers$1.inchesToTwips(updates.gutterInches));
  return sectPr;
}
function updateSectionMargins(target, updates = {}) {
  if (!target || !target.type) throw new Error("updateSectionMargins: missing or invalid target");
  if (target.type === "body") {
    const { converter } = target;
    if (!converter) throw new Error("updateSectionMargins: body target missing converter");
    if (!converter.pageStyles) converter.pageStyles = {};
    if (!converter.pageStyles.pageMargins) converter.pageStyles.pageMargins = {};
    const m2 = converter.pageStyles.pageMargins;
    if (updates.topInches != null) m2.top = updates.topInches;
    if (updates.rightInches != null) m2.right = updates.rightInches;
    if (updates.bottomInches != null) m2.bottom = updates.bottomInches;
    if (updates.leftInches != null) m2.left = updates.leftInches;
    if (updates.headerInches != null) m2.header = updates.headerInches;
    if (updates.footerInches != null) m2.footer = updates.footerInches;
    if (updates.gutterInches != null) m2.gutter = updates.gutterInches;
    return { kind: "body", pageMargins: { ...m2 } };
  }
  if (target.type === "sectPr") {
    const { sectPr } = target;
    if (!sectPr || sectPr.name !== "w:sectPr")
      throw new Error("updateSectionMargins: sectPr target missing/invalid sectPr");
    updateSectPrMargins(sectPr, updates);
    return { kind: "sectPr", sectPr };
  }
  throw new Error(`updateSectionMargins: unsupported target type: ${target.type}`);
}
function findNearestParagraphWithSectPr(doc2, pos) {
  let target = null;
  doc2.descendants((node, nodePos) => {
    if (nodePos > pos) return false;
    if (node.type?.name === "paragraph" && node.attrs?.paragraphProperties?.sectPr) {
      target = { node, pos: nodePos };
    }
    return true;
  });
  return target;
}
const setSectionHeaderFooterAtSelection = ({ headerInches, footerInches } = {}) => ({ tr, state, editor }) => {
  if (!state || !editor) {
    console.warn("[setSectionHeaderFooterAtSelection] Missing state or editor");
    return false;
  }
  const hasHeader = typeof headerInches === "number";
  const hasFooter = typeof footerInches === "number";
  if (!hasHeader && !hasFooter) {
    console.warn("[setSectionHeaderFooterAtSelection] No margin values provided");
    return false;
  }
  if (hasHeader && headerInches < 0) {
    console.warn("[setSectionHeaderFooterAtSelection] headerInches must be >= 0, got:", headerInches);
    return false;
  }
  if (hasFooter && footerInches < 0) {
    console.warn("[setSectionHeaderFooterAtSelection] footerInches must be >= 0, got:", footerInches);
    return false;
  }
  const { from: from3 } = state.selection;
  const found = findNearestParagraphWithSectPr(state.doc, from3);
  if (!found) {
    console.warn("[setSectionHeaderFooterAtSelection] No section break found at or before selection");
    return false;
  }
  const { node, pos } = found;
  const paraProps = node.attrs?.paragraphProperties || null;
  const existingSectPr = paraProps?.sectPr || null;
  if (!existingSectPr) {
    console.warn("[setSectionHeaderFooterAtSelection] Paragraph found but has no sectPr");
    return false;
  }
  const sectPr = JSON.parse(JSON.stringify(existingSectPr));
  const updates = {};
  if (hasHeader) updates.headerInches = headerInches;
  if (hasFooter) updates.footerInches = footerInches;
  try {
    updateSectionMargins({ type: "sectPr", sectPr }, updates);
  } catch (err) {
    console.error("[setSectionHeaderFooterAtSelection] Failed to update sectPr:", err);
    return false;
  }
  const newParagraphProperties = { ...paraProps || {}, sectPr };
  const resolvedMargins = getSectPrMargins(sectPr);
  const normalizedMargins = {
    header: resolvedMargins.header ?? null,
    footer: resolvedMargins.footer ?? null
  };
  const nextAttrs = {
    ...node.attrs,
    paragraphProperties: newParagraphProperties,
    sectionMargins: normalizedMargins
  };
  tr.setNodeMarkup(pos, void 0, nextAttrs, node.marks);
  return true;
};
function findGoverningSectPrParagraph(doc2, selectionPos) {
  const candidates = [];
  doc2.descendants((node, nodePos) => {
    if (node.type?.name === "paragraph" && node.attrs?.paragraphProperties?.sectPr) {
      candidates.push({ node, pos: nodePos });
    }
  });
  if (!candidates.length) return null;
  const inside = candidates.find((c2) => selectionPos >= c2.pos && selectionPos < c2.pos + c2.node.nodeSize);
  if (inside) return inside;
  const atOrAfter = candidates.find((c2) => c2.pos >= selectionPos);
  return atOrAfter ?? candidates[candidates.length - 1];
}
const setSectionPageMarginsAtSelection = ({ topInches, rightInches, bottomInches, leftInches } = {}) => ({ tr, state, editor }) => {
  if (!state || !editor) {
    console.warn("[setSectionPageMarginsAtSelection] Missing state or editor");
    return false;
  }
  const hasTop = typeof topInches === "number";
  const hasRight = typeof rightInches === "number";
  const hasBottom = typeof bottomInches === "number";
  const hasLeft = typeof leftInches === "number";
  if (!hasTop && !hasRight && !hasBottom && !hasLeft) {
    console.warn("[setSectionPageMarginsAtSelection] No margin values provided");
    return false;
  }
  if (hasTop && topInches < 0 || hasRight && rightInches < 0 || hasBottom && bottomInches < 0 || hasLeft && leftInches < 0) {
    console.warn("[setSectionPageMarginsAtSelection] Margin values must be >= 0");
    return false;
  }
  const updates = {};
  if (hasTop) updates.topInches = topInches;
  if (hasRight) updates.rightInches = rightInches;
  if (hasBottom) updates.bottomInches = bottomInches;
  if (hasLeft) updates.leftInches = leftInches;
  const { from: from3 } = state.selection;
  const governing = findGoverningSectPrParagraph(state.doc, from3);
  if (governing) {
    const { node, pos } = governing;
    const paraProps = node.attrs?.paragraphProperties || null;
    const existingSectPr = paraProps?.sectPr || null;
    if (!existingSectPr) {
      console.warn("[setSectionPageMarginsAtSelection] Paragraph found but has no sectPr");
      return false;
    }
    const sectPr2 = JSON.parse(JSON.stringify(existingSectPr));
    try {
      updateSectionMargins({ type: "sectPr", sectPr: sectPr2 }, updates);
    } catch (err) {
      console.error("[setSectionPageMarginsAtSelection] Failed to update sectPr:", err);
      return false;
    }
    const resolved = getSectPrMargins(sectPr2);
    const normalizedSectionMargins = {
      top: resolved.top ?? null,
      right: resolved.right ?? null,
      bottom: resolved.bottom ?? null,
      left: resolved.left ?? null,
      header: resolved.header ?? null,
      footer: resolved.footer ?? null
    };
    const newParagraphProperties = { ...paraProps || {}, sectPr: sectPr2 };
    const nextAttrs = {
      ...node.attrs,
      paragraphProperties: newParagraphProperties,
      sectionMargins: normalizedSectionMargins
    };
    tr.setNodeMarkup(pos, void 0, nextAttrs, node.marks);
    tr.setMeta("forceUpdatePagination", true);
    return true;
  }
  const docAttrs = state.doc.attrs ?? {};
  const converter = editor.converter ?? null;
  const baseBodySectPr = docAttrs.bodySectPr || converter?.bodySectPr || null;
  const sectPr = baseBodySectPr != null ? JSON.parse(JSON.stringify(baseBodySectPr)) : { type: "element", name: "w:sectPr", elements: [] };
  try {
    updateSectionMargins({ type: "sectPr", sectPr }, updates);
  } catch (err) {
    console.error("[setSectionPageMarginsAtSelection] Failed to update sectPr:", err);
    return false;
  }
  if (converter) {
    converter.bodySectPr = sectPr;
    if (!converter.pageStyles) converter.pageStyles = {};
    if (!converter.pageStyles.pageMargins) converter.pageStyles.pageMargins = {};
    const pageMargins = converter.pageStyles.pageMargins;
    const resolved = getSectPrMargins(sectPr);
    if (resolved.top != null) pageMargins.top = resolved.top;
    if (resolved.right != null) pageMargins.right = resolved.right;
    if (resolved.bottom != null) pageMargins.bottom = resolved.bottom;
    if (resolved.left != null) pageMargins.left = resolved.left;
    if (resolved.header != null) pageMargins.header = resolved.header;
    if (resolved.footer != null) pageMargins.footer = resolved.footer;
  }
  const nextDocAttrs = { ...docAttrs, bodySectPr: sectPr };
  tr.setNodeMarkup(0, void 0, nextDocAttrs);
  tr.setMeta("forceUpdatePagination", true);
  return true;
};
const insertSectionBreakAtSelection = ({ headerInches, footerInches } = {}) => ({ tr, state, editor }) => {
  if (!state || !editor) {
    console.warn("[insertSectionBreakAtSelection] Missing state or editor");
    return false;
  }
  if (typeof headerInches === "number" && headerInches < 0) {
    console.warn("[insertSectionBreakAtSelection] headerInches must be >= 0, got:", headerInches);
    return false;
  }
  if (typeof footerInches === "number" && footerInches < 0) {
    console.warn("[insertSectionBreakAtSelection] footerInches must be >= 0, got:", footerInches);
    return false;
  }
  const { $from } = state.selection;
  let paraPos = 0;
  let paragraph = null;
  for (let d = $from.depth; d >= 0; d -= 1) {
    const node = $from.node(d);
    if (node?.type?.name === "paragraph") {
      paraPos = $from.before(d);
      paragraph = node;
      break;
    }
  }
  if (!paragraph || paraPos <= 0) {
    console.warn("[insertSectionBreakAtSelection] No paragraph found at selection");
    return false;
  }
  const paraProps = paragraph.attrs?.paragraphProperties || null;
  const existingSectPr = paraProps?.sectPr || null;
  const sectPr = existingSectPr ? JSON.parse(JSON.stringify(existingSectPr)) : { type: "element", name: "w:sectPr", elements: [] };
  const updates = {};
  if (headerInches != null) updates.headerInches = headerInches;
  if (footerInches != null) updates.footerInches = footerInches;
  if (Object.keys(updates).length) {
    updateSectionMargins({ type: "sectPr", sectPr }, updates);
  }
  const margins = getSectPrMargins(sectPr) || {};
  const sectionMargins = {
    header: margins.header ?? null,
    footer: margins.footer ?? null
  };
  const newParagraphProperties = { ...paraProps || {}, sectPr };
  const nextAttrs = {
    ...paragraph.attrs,
    paragraphProperties: newParagraphProperties,
    pageBreakSource: "sectPr",
    sectionMargins
  };
  tr.setNodeMarkup(paraPos, void 0, nextAttrs, paragraph.marks);
  return true;
};
const defaultIncrementPoints = 36;
const increaseTextIndent = () => modifyIndentation((node) => calculateNewIndentation(node, 1));
const decreaseTextIndent = () => modifyIndentation((node) => calculateNewIndentation(node, -1));
const setTextIndentation = (points) => modifyIndentation(() => helpers$1.ptToTwips(points));
const unsetTextIndentation = () => modifyIndentation(() => null);
function calculateNewIndentation(node, delta) {
  let { indent } = superEditor_converter.getResolvedParagraphProperties(node);
  let { left: left2 } = indent || {};
  const increment = helpers$1.ptToTwips(delta * defaultIncrementPoints);
  if (!left2) {
    left2 = increment;
  } else {
    left2 += increment;
  }
  if (left2 <= 0) {
    left2 = null;
  }
  return left2;
}
function modifyIndentation(calcFunc) {
  return ({ state, dispatch }) => {
    const tr = state.tr;
    const { from: from3, to } = state.selection;
    const results = [];
    state.doc.nodesBetween(from3, to, (node, pos) => {
      if (node.type.name === "paragraph") {
        let left2 = calcFunc(node);
        if (Number.isNaN(left2)) {
          results.push(false);
          return false;
        }
        const newAttrs = {
          ...node.attrs,
          paragraphProperties: {
            ...node.attrs.paragraphProperties || {},
            indent: {
              ...node.attrs.paragraphProperties?.indent || {},
              left: left2
            }
          }
        };
        if (left2 == null) {
          delete newAttrs.paragraphProperties.indent.left;
          if (Object.keys(newAttrs.paragraphProperties.indent).length === 0) {
            delete newAttrs.paragraphProperties.indent;
          }
        }
        tr.setNodeMarkup(pos, void 0, newAttrs);
        results.push(true);
        return false;
      }
      return true;
    });
    const success = results.every((result) => result);
    if (dispatch && success) {
      dispatch(tr);
    }
    return success;
  };
}
const setLineHeight = (lineHeight2) => ({ commands: commands2 }) => {
  if (!lineHeight2) return false;
  return commands2.updateAttributes("paragraph", {
    "paragraphProperties.spacing.line": helpers$1.linesToTwips(lineHeight2),
    "paragraphProperties.spacing.lineRule": "auto"
  });
};
const unsetLineHeight = () => ({ commands: commands2 }) => {
  return commands2.resetAttributes(
    "paragraph",
    "paragraphProperties.spacing.line",
    "paragraphProperties.spacing.lineRule"
  );
};
const backspaceEmptyRunParagraph = () => ({ state, dispatch }) => {
  const { $from } = state.selection;
  if (!state.selection.empty) return false;
  const paraType = state.schema.nodes.paragraph;
  const runType = state.schema.nodes.run;
  const para = $from.parent;
  if (para.type !== paraType || para.childCount !== 1 || para.firstChild.type !== runType || para.firstChild.content.size)
    return false;
  if (state.doc.childCount === 1 && $from.depth === 1) return false;
  if (dispatch) {
    const paraPos = $from.before();
    let tr = state.tr.deleteRange(paraPos, paraPos + para.nodeSize).scrollIntoView();
    const targetPos = Math.max(1, Math.min(paraPos - 1, tr.doc.content.size));
    tr = tr.setSelection(superEditor_converter.TextSelection.create(tr.doc, targetPos));
    dispatch(tr);
  }
  return true;
};
const backspaceSkipEmptyRun = () => ({ state, dispatch }) => {
  const sel = state.selection;
  if (!sel.empty) return false;
  const runType = state.schema.nodes.run;
  const $pos = sel.$from;
  const emptyRun = (n) => n && n.type === runType && n.content.size === 0;
  if ($pos.parent.type !== runType || $pos.pos !== $pos.end() || !emptyRun(state.doc.nodeAt($pos.pos + 1))) {
    return false;
  }
  const leftTextSel = superEditor_converter.Selection.findFrom($pos, -1, true);
  if (!leftTextSel) return false;
  const pos = leftTextSel.$from.pos;
  if (dispatch) {
    dispatch(state.tr.delete(pos - 1, pos).scrollIntoView());
  }
  return true;
};
const backspaceNextToRun = () => ({ state, tr, dispatch }) => {
  const sel = state.selection;
  if (!sel.empty) return false;
  const runType = state.schema.nodes.run;
  const $pos = sel.$from;
  if ($pos.nodeBefore?.type !== runType && $pos.pos !== $pos.start()) return false;
  if ($pos.nodeBefore) {
    if ($pos.nodeBefore.content.size === 0) return false;
    tr.delete($pos.pos - 2, $pos.pos - 1).setSelection(superEditor_converter.Selection.near(tr.doc.resolve($pos.pos - 2)));
    if (dispatch) {
      dispatch(tr.scrollIntoView());
    }
  } else {
    const prevNode = state.doc.resolve($pos.start() - 1).nodeBefore;
    if (prevNode?.type !== runType || prevNode.content.size === 0) return false;
    tr.delete($pos.pos - 3, $pos.pos - 2).setSelection(superEditor_converter.Selection.near(tr.doc.resolve($pos.pos - 3)));
    if (dispatch) {
      dispatch(tr.scrollIntoView());
    }
  }
  return true;
};
const deleteSkipEmptyRun = () => ({ state, dispatch }) => {
  const sel = state.selection;
  if (!sel.empty) return false;
  const runType = state.schema.nodes.run;
  const $pos = sel.$from;
  const emptyRun = (n) => n && n.type === runType && n.content.size === 0;
  if ($pos.parent.type === runType && emptyRun(state.doc.nodeAt($pos.end() + 1))) {
    if ($pos.pos === $pos.end()) {
      return deleteFromEndOfRun(state, dispatch, $pos);
    } else if ($pos.pos === $pos.end() - 1) {
      return deleteFromLastCharacter(state, dispatch, $pos);
    }
    return false;
  }
  return false;
};
function deleteFromEndOfRun(state, dispatch, $pos) {
  const rightRun = state.doc.nodeAt($pos.pos + 1);
  const $afterRightRunPos = state.doc.resolve($pos.pos + 2 + rightRun.nodeSize);
  const rightTextSel = superEditor_converter.Selection.findFrom($afterRightRunPos, 1, true);
  if (!rightTextSel) return false;
  const pos = rightTextSel.$from.pos;
  if (dispatch) {
    dispatch(state.tr.delete(pos, pos + 1).scrollIntoView());
  }
  return true;
}
function deleteFromLastCharacter(state, dispatch, $pos) {
  if (dispatch) {
    dispatch(state.tr.delete($pos.pos, $pos.pos + 1).scrollIntoView());
  }
  return true;
}
const deleteNextToRun = () => ({ state, tr, dispatch }) => {
  const sel = state.selection;
  if (!sel.empty) return false;
  const runType = state.schema.nodes.run;
  const $pos = sel.$from;
  if ($pos.nodeAfter?.type !== runType && $pos.pos !== $pos.end()) return false;
  if ($pos.nodeAfter) {
    if ($pos.nodeAfter.content.size === 0) return false;
    tr.delete($pos.pos + 1, $pos.pos + 2).setSelection(superEditor_converter.Selection.near(tr.doc.resolve($pos.pos + 1)));
    if (dispatch) {
      dispatch(tr.scrollIntoView());
    }
  } else {
    const nextNode = state.doc.resolve($pos.end() + 1).nodeAfter;
    if (nextNode?.type !== runType || nextNode.content.size === 0) return false;
    tr.delete($pos.pos + 2, $pos.pos + 3).setSelection(superEditor_converter.Selection.near(tr.doc.resolve($pos.pos + 2)));
    if (dispatch) {
      dispatch(tr.scrollIntoView());
    }
  }
  return true;
};
function skipTab(dir) {
  return ({ state, dispatch }) => {
    const tab = state.schema.nodes.tab;
    const run = state.schema.nodes.run;
    const sel = state.selection;
    if (!tab || !sel.empty) return false;
    const $pos = sel.$from;
    if ($pos.parent.type !== run) return false;
    if (dir > 0 && $pos.pos < $pos.end()) return false;
    if (dir < 0 && $pos.pos > $pos.start()) return false;
    const step = dir > 0 ? 1 : -1;
    let $nextPos = state.doc.resolve($pos.pos + step);
    const nextNode = dir > 0 ? $nextPos.nodeAfter : $nextPos.nodeBefore;
    if (!nextNode || nextNode.type !== tab) return false;
    const nextPos = dir > 0 ? Math.min($nextPos.pos + nextNode.nodeSize + 1, state.doc.nodeSize) : Math.max(0, $nextPos.pos - nextNode.nodeSize - 1);
    if (dispatch) {
      dispatch(state.tr.setSelection(superEditor_converter.TextSelection.create(state.doc, nextPos)));
    }
    return true;
  };
}
const decreaseListIndent = () => ({ editor, tr, dispatch }) => {
  const handled = superEditor_converter.changeListLevel(-1, editor, tr);
  if (handled && dispatch) {
    dispatch(tr);
  }
  return handled;
};
const removeNumberingProperties = ({ checkType = "startParagraph" } = {}) => (props) => {
  const { tr, state, editor, dispatch } = props;
  const { node: paragraph, pos } = superEditor_converter.findParentNode(superEditor_converter.isList)(state.selection) || {};
  if (!paragraph) return false;
  if (checkType === "empty" && !isVisuallyEmptyParagraph(paragraph)) return false;
  if (checkType === "startParagraph") {
    const { $from, empty: empty2 } = state.selection;
    if ((!empty2 || $from.parentOffset !== 0) && !isVisuallyEmptyParagraph(paragraph)) return false;
  }
  const ilvl = superEditor_converter.getResolvedParagraphProperties(paragraph).numberingProperties.ilvl;
  if (ilvl > 0) {
    const outdented = decreaseListIndent()(props);
    if (outdented) {
      tr.scrollIntoView();
    }
    return outdented;
  } else {
    superEditor_converter.updateNumberingProperties(null, paragraph, pos, editor, tr);
  }
  if (dispatch) dispatch(tr);
  return true;
};
function isVisuallyEmptyParagraph(node) {
  if (!node || node.type.name !== "paragraph") return false;
  let hasHardBreak = false;
  node.descendants((n) => {
    if (n.type && n.type.name === "hardBreak") {
      hasHardBreak = true;
      return false;
    }
    return true;
  });
  if (hasHardBreak) return false;
  const text = (node.textContent || "").replace(/\u200b/g, "").trim();
  if (text.length > 0) return false;
  let hasInlineLeaf = false;
  node.descendants((n) => {
    if (n.isInline && n.isLeaf && n.type?.name !== "hardBreak" && n.type?.name !== "run") {
      hasInlineLeaf = true;
      return false;
    }
    return true;
  });
  if (hasInlineLeaf) return false;
  return true;
}
const toggleList = (listType) => ({ editor, state, tr, dispatch }) => {
  let predicate;
  if (listType === "orderedList") {
    predicate = (n) => {
      const paraProps = superEditor_converter.getResolvedParagraphProperties(n);
      return paraProps.numberingProperties && n.attrs.listRendering && n.attrs.listRendering.numberingType !== "bullet";
    };
  } else if (listType === "bulletList") {
    predicate = (n) => {
      const paraProps = superEditor_converter.getResolvedParagraphProperties(n);
      return paraProps.numberingProperties && n.attrs.listRendering && n.attrs.listRendering.numberingType === "bullet";
    };
  } else {
    return false;
  }
  const { selection } = state;
  const { from: from3, to } = selection;
  let firstListNode = null;
  let hasNonListParagraphs = false;
  let allParagraphsInSelection = [];
  state.doc.nodesBetween(from3, to, (node, pos) => {
    if (node.type.name === "paragraph") {
      allParagraphsInSelection.push({ node, pos });
      return false;
    }
    return true;
  });
  let paragraphsInSelection = allParagraphsInSelection.length === 1 ? allParagraphsInSelection : allParagraphsInSelection.filter(({ node }) => !isVisuallyEmptyParagraph(node));
  for (const { node } of paragraphsInSelection) {
    if (!firstListNode && predicate(node)) {
      firstListNode = node;
    } else if (!predicate(node)) {
      hasNonListParagraphs = true;
    }
  }
  if (!firstListNode && from3 > 0) {
    const $from = state.doc.resolve(from3);
    const parentIndex = $from.index(-1);
    if (parentIndex > 0) {
      const beforeNode = $from.node(-1).child(parentIndex - 1);
      if (beforeNode && beforeNode.type.name === "paragraph" && predicate(beforeNode)) {
        firstListNode = beforeNode;
      }
    }
  }
  let mode = null;
  let sharedNumberingProperties = null;
  if (firstListNode) {
    if (!hasNonListParagraphs) {
      mode = "remove";
    } else {
      mode = "reuse";
      const paraProps = superEditor_converter.getResolvedParagraphProperties(firstListNode);
      const baseNumbering = paraProps.numberingProperties || {};
      sharedNumberingProperties = {
        ...baseNumbering,
        ilvl: baseNumbering.ilvl ?? 0
      };
    }
  } else {
    mode = "create";
    const numId = superEditor_converter.ListHelpers.getNewListId(editor);
    superEditor_converter.ListHelpers.generateNewListDefinition({ numId: Number(numId), listType, editor });
    sharedNumberingProperties = {
      numId: Number(numId),
      ilvl: 0
    };
  }
  for (const { node, pos } of paragraphsInSelection) {
    if (mode === "remove") {
      superEditor_converter.updateNumberingProperties(null, node, pos, editor, tr);
      continue;
    }
    if (mode === "reuse" && predicate(node)) {
      continue;
    }
    superEditor_converter.updateNumberingProperties(sharedNumberingProperties, node, pos, editor, tr);
  }
  if (paragraphsInSelection.length > 0) {
    const firstPara = paragraphsInSelection[0];
    const lastPara = paragraphsInSelection[paragraphsInSelection.length - 1];
    const mappedFirstPos = tr.mapping.map(firstPara.pos);
    const mappedLastPos = tr.mapping.map(lastPara.pos);
    const $firstPos = tr.doc.resolve(mappedFirstPos);
    const $lastPos = tr.doc.resolve(mappedLastPos);
    const firstNode = $firstPos.nodeAfter;
    const lastNode = $lastPos.nodeAfter;
    if (firstNode && lastNode) {
      let selFrom = mappedFirstPos + 1;
      let selTo = mappedLastPos + lastNode.nodeSize - 1;
      if (firstNode.firstChild && firstNode.firstChild.type.name === "run") {
        selFrom = mappedFirstPos + 2;
      }
      if (lastNode.lastChild && lastNode.lastChild.type.name === "run") {
        selTo = mappedLastPos + lastNode.nodeSize - 2;
      }
      if (selFrom >= 0 && selTo <= tr.doc.content.size && selFrom <= selTo) {
        try {
          tr.setSelection(superEditor_converter.TextSelection.create(tr.doc, selFrom, selTo));
        } catch {
        }
      }
    }
  }
  if (dispatch) dispatch(tr);
  return true;
};
const increaseListIndent = () => ({ editor, tr, dispatch }) => {
  const handled = superEditor_converter.changeListLevel(1, editor, tr);
  if (handled && dispatch) {
    dispatch(tr);
  }
  return handled;
};
const restoreSelection = () => ({ editor, state, tr }) => {
  if (editor.options.lastSelection) {
    tr.setSelection(
      superEditor_converter.TextSelection.create(state.doc, editor.options.lastSelection.from, editor.options.lastSelection.to)
    );
    return true;
  }
  return false;
};
const clamp = (value, min2, max2) => Math.max(min2, Math.min(value, max2));
const setTextSelection = ({ from: from3, to }) => ({ state, dispatch, editor }) => {
  if (typeof from3 !== "number" && typeof to !== "number") {
    return false;
  }
  const doc2 = state.doc;
  const docSize = doc2.content.size;
  const nextFrom = clamp(typeof from3 === "number" ? from3 : state.selection.from, 0, docSize);
  const nextToBase = typeof to === "number" ? to : nextFrom;
  const nextTo = clamp(nextToBase, 0, docSize);
  const [head, anchor] = nextFrom <= nextTo ? [nextFrom, nextTo] : [nextTo, nextFrom];
  const selection = superEditor_converter.TextSelection.create(doc2, head, anchor);
  if (dispatch) {
    const transaction = state.tr.setSelection(selection);
    dispatch(transaction);
  }
  if (editor?.view?.dom && typeof editor.view.dom.focus === "function") {
    editor.view.dom.focus({ preventScroll: true });
  } else if (editor?.view && typeof editor.view.focus === "function") {
    editor.view.focus();
  }
  return true;
};
const getSelectionMarks = () => ({ state, tr }) => {
  tr.setMeta("preventDispatch", true);
  const marks = getMarksFromSelection(state) ?? [];
  const uniqueByType = /* @__PURE__ */ new Map();
  for (const mark of marks) {
    const typeName = typeof mark?.type === "string" ? mark.type : mark?.type?.name;
    if (!typeName) continue;
    const existing = uniqueByType.get(typeName);
    if (!existing) {
      uniqueByType.set(typeName, mark);
      continue;
    }
    const existingAttrs = existing?.attrs ?? {};
    const nextAttrs = mark?.attrs ?? {};
    const existingHasValues = Object.values(existingAttrs).some((value) => value != null);
    const nextHasValues = Object.values(nextAttrs).some((value) => value != null);
    if (!existingHasValues && nextHasValues) {
      uniqueByType.set(typeName, mark);
    }
  }
  return Array.from(uniqueByType.values());
};
const commands$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  backspaceEmptyRunParagraph,
  backspaceNextToRun,
  backspaceSkipEmptyRun,
  changeListLevel: superEditor_converter.changeListLevel,
  clearNodes,
  command,
  createParagraphNear,
  decreaseListIndent,
  decreaseTextIndent,
  defaultStyleDetector,
  deleteNextToRun,
  deleteSelection,
  deleteSkipEmptyRun,
  exitCode,
  first,
  getEffectiveStyleId,
  getSelectionMarks,
  getStyleIdFromMarks,
  increaseListIndent,
  increaseTextIndent,
  insertContent,
  insertContentAt,
  insertSectionBreakAtSelection,
  insertTabChar,
  insertTabCharacter,
  insertTabNode,
  isStyleTokenEnabled,
  isVisuallyEmptyParagraph,
  joinBackward,
  joinDown,
  joinForward,
  joinUp,
  liftEmptyBlock,
  mapMarkToStyleKey,
  newlineInCode,
  removeNumberingProperties,
  resetAttributes,
  restoreSelection,
  selectAll,
  selectNodeBackward,
  selectNodeForward,
  selectTextblockEnd,
  selectTextblockStart,
  setBodyHeaderFooter,
  setLineHeight,
  setMark,
  setMeta,
  setNode,
  setSectionHeaderFooterAtSelection,
  setSectionPageMarginsAtSelection,
  setTextIndentation,
  setTextSelection,
  skipTab,
  splitBlock: splitBlock$1,
  toggleList,
  toggleMark,
  toggleMarkCascade,
  toggleNode,
  undoInputRule,
  unsetAllMarks,
  unsetLineHeight,
  unsetMark,
  unsetTextIndentation,
  updateAttributes,
  updateNumberingProperties: superEditor_converter.updateNumberingProperties
}, Symbol.toStringTag, { value: "Module" }));
const Commands = Extension.create({
  name: "commands",
  addCommands() {
    return { ...commands$1 };
  }
});
const handleEnter = (editor) => {
  return editor.commands.first(({ commands: commands2 }) => [
    () => commands2.splitRunToParagraph(),
    () => commands2.newlineInCode(),
    () => commands2.createParagraphNear(),
    () => commands2.liftEmptyBlock(),
    () => commands2.splitBlock()
  ]);
};
const handleBackspace = (editor) => {
  return editor.commands.first(({ commands: commands2, tr }) => [
    () => commands2.undoInputRule(),
    () => {
      tr.setMeta("inputType", "deleteContentBackward");
      return false;
    },
    () => commands2.backspaceEmptyRunParagraph(),
    () => commands2.backspaceSkipEmptyRun(),
    () => commands2.backspaceNextToRun(),
    () => commands2.deleteSelection(),
    () => commands2.removeNumberingProperties(),
    () => commands2.joinBackward(),
    () => commands2.selectNodeBackward()
  ]);
};
const handleDelete = (editor) => {
  return editor.commands.first(({ commands: commands2 }) => [
    () => commands2.deleteSkipEmptyRun(),
    () => commands2.deleteNextToRun(),
    () => commands2.deleteSelection(),
    () => commands2.joinForward(),
    () => commands2.selectNodeForward()
  ]);
};
const Keymap = Extension.create({
  name: "keymap",
  addShortcuts() {
    const baseKeymap = {
      Enter: () => handleEnter(this.editor),
      "Shift-Enter": () => this.editor.commands.insertLineBreak(),
      "Mod-Enter": () => this.editor.commands.insertPageBreak(),
      Backspace: () => handleBackspace(this.editor),
      "Mod-Backspace": () => handleBackspace(this.editor),
      "Shift-Backspace": () => handleBackspace(this.editor),
      Delete: () => handleDelete(this.editor),
      "Mod-Delete": () => handleDelete(this.editor),
      "Mod-a": () => this.editor.commands.selectAll(),
      Tab: () => this.editor.commands.insertTabNode(),
      ArrowLeft: () => this.editor.commands.skipTab(-1),
      ArrowRight: () => this.editor.commands.skipTab(1)
    };
    const pcBaseKeymap = {
      ...baseKeymap
    };
    const macBaseKeymap = {
      ...baseKeymap,
      "Ctrl-h": () => handleBackspace(this.editor),
      "Alt-Backspace": () => handleBackspace(this.editor),
      "Ctrl-d": () => handleDelete(this.editor),
      "Ctrl-Alt-Backspace": () => handleDelete(this.editor),
      "Alt-Delete": () => handleDelete(this.editor),
      "Alt-d": () => handleDelete(this.editor),
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd(),
      "Ctrl-t": () => this.editor.commands.insertTabChar()
    };
    if (isMacOS() || isIOS()) {
      return macBaseKeymap;
    }
    return pcBaseKeymap;
  }
});
const Editable = Extension.create({
  name: "editable",
  addPmPlugins() {
    const editor = this.editor;
    const editablePlugin = new superEditor_converter.Plugin({
      key: new superEditor_converter.PluginKey("editable"),
      props: {
        editable: () => editor.options.editable,
        handleDOMEvents: {
          beforeinput: (_view, event) => {
            if (!editor.options.editable) {
              event.preventDefault();
              return true;
            }
            return false;
          },
          mousedown: (_view, event) => {
            if (!editor.options.editable) {
              event.preventDefault();
              return true;
            }
            return false;
          },
          focus: (view, event) => {
            if (!editor.options.editable) {
              event.preventDefault();
              view.dom.blur();
              return true;
            }
            return false;
          }
        },
        handleClick: () => !editor.options.editable,
        handleDoubleClick: () => !editor.options.editable,
        handleTripleClick: () => !editor.options.editable,
        handleKeyDown: () => !editor.options.editable,
        handlePaste: () => !editor.options.editable,
        handleDrop: () => !editor.options.editable
      }
    });
    return [editablePlugin];
  }
});
const EditorFocus = Extension.create({
  name: "editorFocus",
  addPmPlugins() {
    const editor = this.editor;
    const editorFocusPlugin = new superEditor_converter.Plugin({
      key: new superEditor_converter.PluginKey("editorFocus"),
      props: {
        handleDOMEvents: {
          focus: (view, event) => {
            editor.isFocused = true;
            const tr = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
            view.dispatch(tr);
            return false;
          },
          blur: (view, event) => {
            editor.isFocused = false;
            const tr = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
            view.dispatch(tr);
            return false;
          }
        }
      }
    });
    return [editorFocusPlugin];
  }
});
const PositionTrackerExtension = Extension.create({
  name: "positionTracker",
  addStorage() {
    return {
      tracker: null
    };
  },
  addPmPlugins() {
    return [createPositionTrackerPlugin()];
  },
  onCreate() {
    const existing = this.editor?.positionTracker ?? this.storage.tracker;
    if (existing) {
      this.storage.tracker = existing;
      this.editor.positionTracker = existing;
      return;
    }
    const tracker = new PositionTracker(this.editor);
    this.storage.tracker = tracker;
    this.editor.positionTracker = tracker;
  },
  onDestroy() {
    if (this.editor?.positionTracker === this.storage.tracker) {
      this.editor.positionTracker = null;
    }
    this.storage.tracker = null;
  }
});
class EventEmitter {
  #events = /* @__PURE__ */ new Map();
  /**
   * Subscribe to the event.
   * @param name Event name.
   * @param fn Callback.
   * @returns {void}
   */
  on(name, fn2) {
    const callbacks2 = this.#events.get(name);
    if (callbacks2) callbacks2.push(fn2);
    else this.#events.set(name, [fn2]);
  }
  /**
   * Emit event.
   * @param name Event name.
   * @param args Arguments to pass to each listener.
   * @returns {void}
   */
  emit(name, ...args) {
    const callbacks2 = this.#events.get(name);
    if (!callbacks2) return;
    for (const fn2 of callbacks2) {
      fn2.apply(this, args);
    }
  }
  /**
   * Remove a specific callback from event
   * or all event subscriptions.
   * @param name Event name.
   * @param fn Callback.
   * @returns {void}
   */
  off(name, fn2) {
    const callbacks2 = this.#events.get(name);
    if (!callbacks2) return;
    if (fn2) {
      this.#events.set(name, callbacks2.filter((cb) => cb !== fn2));
    } else {
      this.#events.delete(name);
    }
  }
  /**
   * Subscribe to an event that will be called only once.
   * @param name Event name.
   * @param fn Callback.
   * @returns {void}
   */
  once(name, fn2) {
    const wrapper = (...args) => {
      this.off(name, wrapper);
      fn2.apply(this, args);
    };
    this.on(name, wrapper);
  }
  /**
   * Remove all registered events and subscriptions.
   */
  removeAllListeners() {
    this.#events = /* @__PURE__ */ new Map();
  }
}
var base$1 = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac$1 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var i = 0; i < 10; i++) base$1[48 + i] = base$1[96 + i] = String(i);
for (var i = 1; i <= 24; i++) base$1[i + 111] = "F" + i;
for (var i = 65; i <= 90; i++) {
  base$1[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
for (var code in base$1) if (!shift.hasOwnProperty(code)) shift[code] = base$1[code];
function keyName(event) {
  var ignoreKey = mac$1 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base$1)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name;
}
const mac = typeof navigator != "undefined" && /Mac|iP(hone|[oa]d)/.test(navigator.platform);
const windows = typeof navigator != "undefined" && /Win/.test(navigator.platform);
function normalizeKeyName(name) {
  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta;
  for (let i = 0; i < parts.length - 1; i++) {
    let mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function normalize(map3) {
  let copy = /* @__PURE__ */ Object.create(null);
  for (let prop in map3)
    copy[normalizeKeyName(prop)] = map3[prop];
  return copy;
}
function modifiers(name, event, shift2 = true) {
  if (event.altKey)
    name = "Alt-" + name;
  if (event.ctrlKey)
    name = "Ctrl-" + name;
  if (event.metaKey)
    name = "Meta-" + name;
  if (shift2 && event.shiftKey)
    name = "Shift-" + name;
  return name;
}
function keymap(bindings) {
  return new superEditor_converter.Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  let map3 = normalize(bindings);
  return function(view, event) {
    let name = keyName(event), baseName, direct = map3[modifiers(name, event)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (name.length == 1 && name != " ") {
      if (event.shiftKey) {
        let noShift = map3[modifiers(name, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view))
          return true;
      }
      if ((event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(windows && event.ctrlKey && event.altKey) && (baseName = base$1[event.keyCode]) && baseName != name) {
        let fromCode = map3[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view))
          return true;
      }
    }
    return false;
  };
}
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
class ExtensionService {
  editor;
  schema;
  extensions;
  externalExtensions = [];
  splittableMarks = [];
  constructor(extensions, userExtensions, editor) {
    this.editor = editor;
    this.externalExtensions = userExtensions || [];
    this.externalExtensions = this.externalExtensions.map((extension) => {
      return {
        ...extension,
        isExternal: true
      };
    });
    this.extensions = ExtensionService.getResolvedExtensions([...extensions, ...this.externalExtensions]);
    this.schema = Schema.createSchemaByExtensions(this.extensions, editor);
    this.#setupExtensions();
  }
  /**
   * Static method for creating ExtensionService.
   * @param args Arguments for the constructor.
   */
  static create(...args) {
    return new ExtensionService(...args);
  }
  /**
   * Get an array of resolved extensions (e.g. sorted by priority).
   * @param extensions Array of extensions.
   * @returns Array of resolved extensions.
   */
  static getResolvedExtensions(extensions) {
    const resolvedExtensions = ExtensionService.sortByPriority(extensions);
    return resolvedExtensions;
  }
  /**
   * Sort extensions by priority.
   * @param extensions Array of extensions.
   * @returns Array of sorted extensions by priority.
   */
  static sortByPriority(extensions) {
    const defaultValue = 100;
    return extensions.sort((a, b2) => {
      const priorityA = getExtensionConfigField(a, "priority") || defaultValue;
      const priorityB = getExtensionConfigField(b2, "priority") || defaultValue;
      if (priorityA > priorityB) return -1;
      if (priorityA < priorityB) return 1;
      return 0;
    });
  }
  /**
   * Get all attributes defined in the extensions.
   * @returns Array of attributes.
   */
  get attributes() {
    return Attribute.getAttributesFromExtensions(this.extensions);
  }
  /**
   * Get all commands defined in the extensions.
   * @returns Object with commands (key - command name, value - function).
   */
  get commands() {
    let commandsObject = {};
    for (const extension of this.extensions) {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addCommands = getExtensionConfigField(extension, "addCommands", context);
      if (addCommands) {
        commandsObject = {
          ...commandsObject,
          ...addCommands()
        };
      }
    }
    return commandsObject;
  }
  /**
   * Get all helper methods defined in the extensions.
   * Each extension can define its own helper methods.
   * Example: editor.helpers.linkedStyles.getStyles()
   * @returns {Object} Object with helper methods for extensions.
   */
  get helpers() {
    const helpersObject = {};
    for (const extension of this.extensions) {
      const name = extension.name;
      if (!name) continue;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addHelpers = getExtensionConfigField(extension, "addHelpers", context);
      if (addHelpers) {
        helpersObject[name] = addHelpers();
      }
    }
    return helpersObject;
  }
  /**
   * Get all PM plugins defined in the extensions.
   * And also keyboard shortcuts.
   * @returns Array of PM plugins.
   */
  get plugins() {
    const editor = this.editor;
    const extensions = ExtensionService.sortByPriority([...this.extensions].reverse());
    const inputRules = [];
    const allPlugins = extensions.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const plugins = [];
      const addShortcuts = getExtensionConfigField(extension, "addShortcuts", context);
      let bindingsObject = {};
      if (addShortcuts) {
        const entries = Object.entries(addShortcuts()).map(([shortcut, method]) => {
          return [shortcut, (...args) => method({ editor, keymapArgs: args })];
        });
        bindingsObject = { ...Object.fromEntries(entries) };
      }
      plugins.push(keymap(bindingsObject));
      const addInputRules = getExtensionConfigField(extension, "addInputRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
        inputRules.push(...addInputRules());
      }
      const addPmPlugins = getExtensionConfigField(extension, "addPmPlugins", context);
      if (addPmPlugins) {
        const pmPlugins = addPmPlugins();
        plugins.push(...pmPlugins);
      }
      return plugins;
    }).flat();
    return [
      superEditor_converter.inputRulesPlugin({
        editor,
        rules: inputRules
      }),
      ...allPlugins
    ];
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views.
   */
  get nodeViews() {
    const { editor } = this;
    const nodeExtensions = this.extensions.filter((e) => e.type === "node");
    const entries = nodeExtensions.filter((extension) => !!getExtensionConfigField(extension, "addNodeView")).map((extension) => {
      const extensionAttrs = this.attributes.filter((a) => a.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getNodeType(extension.name, this.schema)
      };
      const addNodeView = getExtensionConfigField(extension, "addNodeView", context);
      if (!addNodeView) return null;
      const nodeViewFunction = addNodeView();
      if (!nodeViewFunction) return null;
      const nodeview = (node, _view, getPos, decorations) => {
        const htmlAttributes = Attribute.getAttributesToRender(node, extensionAttrs);
        return nodeViewFunction({
          editor,
          node,
          getPos,
          decorations,
          htmlAttributes,
          extension,
          extensionAttrs
        });
      };
      return [extension.name, nodeview];
    }).filter(Boolean);
    return Object.fromEntries(entries);
  }
  /**
   * Install all extensions.
   * Create extension storage in the editor, attach editor events.
   */
  #setupExtensions() {
    for (const extension of this.extensions) {
      this.editor.extensionStorage[extension.name] = extension.storage;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      if (extension.type === "mark") {
        const keepOnSplit = callOrGet(getExtensionConfigField(extension, "keepOnSplit", context)) ?? true;
        if (keepOnSplit) {
          this.splittableMarks.push(extension.name);
        }
      }
      this.#attachEditorEvents(extension);
    }
  }
  /**
   * Attach editor events to extension
   * if callbacks are defined in the extension config.
   * @param extension Extension.
   */
  #attachEditorEvents(extension) {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor: this.editor,
      type: getSchemaTypeByName(extension.name, this.schema)
    };
    const onBeforeCreate = getExtensionConfigField(extension, "onBeforeCreate", context);
    const onCreate2 = getExtensionConfigField(extension, "onCreate", context);
    const onUpdate = getExtensionConfigField(extension, "onUpdate", context);
    const onSelectionUpdate = getExtensionConfigField(extension, "onSelectionUpdate", context);
    const onTransaction = getExtensionConfigField(extension, "onTransaction", context);
    const onFocus = getExtensionConfigField(extension, "onFocus", context);
    const onBlur = getExtensionConfigField(extension, "onBlur", context);
    const onDestroy2 = getExtensionConfigField(extension, "onDestroy", context);
    if (onBeforeCreate) this.editor.on("beforeCreate", onBeforeCreate);
    if (onCreate2) this.editor.on("create", onCreate2);
    if (onUpdate) this.editor.on("update", onUpdate);
    if (onSelectionUpdate) this.editor.on("selectionUpdate", onSelectionUpdate);
    if (onTransaction) this.editor.on("transaction", onTransaction);
    if (onFocus) this.editor.on("focus", onFocus);
    if (onBlur) this.editor.on("blur", onBlur);
    if (onDestroy2) this.editor.on("destroy", onDestroy2);
  }
}
const findTrackedMarkBetween = ({
  tr,
  from: from3,
  to,
  markName,
  attrs = {},
  offset: offset2 = 1
  // To get non-inclusive marks.
}) => {
  const { doc: doc2 } = tr;
  const startPos = Math.max(from3 - offset2, 0);
  const endPos = Math.min(to + offset2, doc2.content.size);
  let markFound = null;
  const tryMatch = (node, pos) => {
    if (!node || node?.nodeSize === void 0) {
      return;
    }
    const mark = node.marks?.find(
      (mark2) => mark2.type.name === markName && Object.keys(attrs).every((attr) => mark2.attrs[attr] === attrs[attr])
    );
    if (mark && !markFound) {
      markFound = {
        from: pos,
        to: pos + node.nodeSize,
        mark
      };
      return false;
    }
  };
  doc2.nodesBetween(startPos, endPos, (node, pos) => {
    return tryMatch(node, pos);
  });
  const inspectAroundPosition = (pos) => {
    if (pos < 0 || pos > doc2.content.size) {
      return;
    }
    const resolved = doc2.resolve(pos);
    const before = resolved.nodeBefore;
    if (before?.type?.name === "run") {
      const beforeStart = Math.max(pos - before.nodeSize, 0);
      const node = before.content?.content?.[0];
      if (node?.type?.name === "text") {
        tryMatch(node, beforeStart);
      }
    }
    const after = resolved.nodeAfter;
    if (after?.type?.name === "run") {
      const node = after.content?.content?.[0];
      if (node?.type?.name === "text") {
        tryMatch(node, pos);
      }
    }
  };
  if (!markFound) {
    inspectAroundPosition(startPos);
    inspectAroundPosition(endPos);
  }
  return markFound;
};
const markInsertion = ({ tr, from: from3, to, user, date, id: providedId }) => {
  tr.removeMark(from3, to, tr.doc.type.schema.marks[superEditor_converter.TrackDeleteMarkName]);
  tr.removeMark(from3, to, tr.doc.type.schema.marks[superEditor_converter.TrackInsertMarkName]);
  let trackedMark = findTrackedMarkBetween({
    tr,
    from: from3,
    to,
    markName: superEditor_converter.TrackInsertMarkName,
    attrs: { authorEmail: user.email }
  });
  let id;
  if (providedId) {
    id = providedId;
  } else if (trackedMark) {
    id = trackedMark.mark.attrs.id;
  } else {
    id = uuid.v4();
  }
  const insertionMark = tr.doc.type.schema.marks[superEditor_converter.TrackInsertMarkName].create({
    id,
    author: user.name,
    authorEmail: user.email,
    authorImage: user.image,
    date
  });
  tr.addMark(from3, to, insertionMark);
  tr.doc.nodesBetween(from3, to, (node, pos) => {
    if (pos < from3 || ["bulletList", "orderedList"].includes(node.type.name)) {
      return true;
    } else if (node.isInline || ["tableRow", "tableCell"].includes(node.type.name)) {
      return false;
    }
    if (node.attrs.track) ;
    if (node.type.name === "table") {
      return false;
    }
  });
  return insertionMark;
};
const markDeletion = ({ tr, from: from3, to, user, date, id: providedId }) => {
  const normalizeEmail2 = (value) => typeof value === "string" ? value.trim().toLowerCase() : "";
  const userEmail = normalizeEmail2(user?.email);
  const isOwnInsertion = (mark) => {
    const authorEmail = normalizeEmail2(mark?.attrs?.authorEmail);
    if (!authorEmail || !userEmail) return true;
    return authorEmail === userEmail;
  };
  let trackedMark = findTrackedMarkBetween({
    tr,
    from: from3,
    to,
    markName: superEditor_converter.TrackDeleteMarkName,
    attrs: { authorEmail: user.email }
  });
  let id;
  if (providedId) {
    id = providedId;
  } else if (trackedMark) {
    id = trackedMark.mark.attrs.id;
  } else {
    id = uuid.v4();
  }
  const deletionMark = tr.doc.type.schema.marks[superEditor_converter.TrackDeleteMarkName].create({
    id,
    author: user.name,
    authorEmail: user.email,
    authorImage: user.image,
    date
  });
  const deletionMap = new superEditor_converter.Mapping();
  let nodes = [];
  tr.doc.nodesBetween(from3, to, (node, pos) => {
    if (node.type.name.includes("table")) {
      return;
    }
    const insertMark = node.marks.find((mark) => mark.type.name === superEditor_converter.TrackInsertMarkName);
    if (node.isInline && insertMark && isOwnInsertion(insertMark)) {
      const removeStep = new superEditor_converter.ReplaceStep(
        deletionMap.map(Math.max(from3, pos)),
        deletionMap.map(Math.min(to, pos + node.nodeSize)),
        superEditor_converter.Slice.empty
      );
      if (!tr.maybeStep(removeStep).failed) {
        deletionMap.appendMap(removeStep.getMap());
      }
    } else if (node.isInline && !node.marks.find((mark) => mark.type.name === superEditor_converter.TrackDeleteMarkName)) {
      nodes.push(node);
      tr.addMark(
        deletionMap.map(Math.max(from3, pos)),
        deletionMap.map(Math.min(to, pos + node.nodeSize)),
        deletionMark
      );
    } else if (node.attrs.track && !node.attrs.track.find((trackAttr) => trackAttr.type === superEditor_converter.TrackDeleteMarkName) && !["bulletList", "orderedList"].includes(node.type.name)) ;
  });
  return { deletionMark, deletionMap, nodes };
};
const findMarkPosition = (doc2, pos, markName) => {
  const $pos = doc2.resolve(pos);
  const parent = $pos.parent;
  const start2 = parent.childAfter($pos.parentOffset);
  if (!start2.node) {
    return null;
  }
  const actualMark = start2.node.marks.find((mark) => mark.type.name === markName);
  if (!actualMark) {
    return null;
  }
  let startIndex = $pos.index();
  let startPos = $pos.start() + start2.offset;
  while (startIndex > 0 && actualMark.isInSet(parent.child(startIndex - 1).marks)) {
    startPos -= parent.child(--startIndex).nodeSize;
  }
  let endIndex = $pos.index() + 1;
  let endPos = $pos.start() + start2.offset + start2.node.nodeSize;
  while (endIndex < parent.childCount && actualMark.isInSet(parent.child(endIndex).marks)) {
    endPos += parent.child(endIndex++).nodeSize;
  }
  return {
    from: startPos,
    to: endPos,
    attrs: actualMark.attrs
  };
};
const flatten$3 = (node, descend = true) => {
  if (!node) {
    throw new Error('Invalid "node" parameter');
  }
  const result = [];
  node.descendants((child, pos) => {
    result.push({ node: child, pos });
    if (!descend) {
      return false;
    }
  });
  return result;
};
const findChildren$4 = (node, predicate, descend) => {
  if (!node) {
    throw new Error('Invalid "node" parameter');
  } else if (!predicate) {
    throw new Error('Invalid "predicate" parameter');
  }
  return flatten$3(node, descend).filter((child) => predicate(child.node));
};
const findInlineNodes = (node, descend) => {
  return findChildren$4(node, (child) => child.isInline, descend);
};
const documentHelpers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  findChildren: findChildren$4,
  findInlineNodes,
  findMarkPosition,
  flatten: flatten$3
}, Symbol.toStringTag, { value: "Module" }));
const getTrackChanges = (state, id = null) => {
  const trackedChanges = [];
  const allInlineNodes = findInlineNodes(state.doc);
  if (!allInlineNodes.length) {
    return trackedChanges;
  }
  allInlineNodes.forEach(({ node, pos }) => {
    const { marks } = node;
    const trackedMarks = [superEditor_converter.TrackInsertMarkName, superEditor_converter.TrackDeleteMarkName, superEditor_converter.TrackFormatMarkName];
    if (marks.length > 0) {
      marks.forEach((mark) => {
        if (trackedMarks.includes(mark.type.name)) {
          trackedChanges.push({
            mark,
            from: pos,
            to: pos + node.nodeSize
          });
        }
      });
    }
  });
  if (id) {
    return trackedChanges.filter(({ mark }) => mark.attrs.id === id);
  }
  return trackedChanges;
};
const TrackChangesBasePluginKey = new superEditor_converter.PluginKey("TrackChangesBase");
const TrackChangesBasePlugin = () => {
  return new superEditor_converter.Plugin({
    key: TrackChangesBasePluginKey,
    state: {
      init(_2, state) {
        const decorations = getTrackChangesDecorations(state, false, false);
        return {
          isTrackChangesActive: false,
          onlyOriginalShown: false,
          onlyModifiedShown: false,
          decorations
        };
      },
      apply(tr, oldState, prevEditorState, newEditorState) {
        const meta = tr.getMeta(TrackChangesBasePluginKey);
        if (meta && meta.type === "TRACK_CHANGES_ENABLE") {
          return {
            ...oldState,
            isTrackChangesActive: meta.value === true,
            decorations: getTrackChangesDecorations(
              newEditorState,
              oldState.onlyOriginalShown,
              oldState.onlyModifiedShown
            )
          };
        }
        if (meta && meta.type === "SHOW_ONLY_ORIGINAL") {
          return {
            ...oldState,
            onlyOriginalShown: meta.value === true,
            onlyModifiedShown: false,
            decorations: getTrackChangesDecorations(newEditorState, meta.value === true, false)
          };
        }
        if (meta && meta.type === "SHOW_ONLY_MODIFIED") {
          return {
            ...oldState,
            onlyOriginalShown: false,
            onlyModifiedShown: meta.value === true,
            decorations: getTrackChangesDecorations(newEditorState, false, meta.value === true)
          };
        }
        if (!tr.docChanged) {
          return oldState;
        }
        if (!meta) {
          let mightAffectTrackChanges = false;
          tr.steps.forEach((step) => {
            if (step.slice || step.from !== step.to) {
              mightAffectTrackChanges = true;
            }
          });
          if (mightAffectTrackChanges) {
            return {
              ...oldState,
              decorations: getTrackChangesDecorations(
                newEditorState,
                oldState.onlyOriginalShown,
                oldState.onlyModifiedShown
              )
            };
          }
          return {
            ...oldState,
            decorations: oldState.decorations.map(tr.mapping, tr.doc)
          };
        }
        return {
          ...oldState,
          decorations: getTrackChangesDecorations(
            newEditorState,
            oldState.onlyOriginalShown,
            oldState.onlyModifiedShown
          )
        };
      }
    },
    props: {
      decorations(state) {
        return this.getState(state)?.decorations;
      }
    }
  });
};
const getTrackChangesDecorations = (state, onlyOriginalShown, onlyModifiedShown) => {
  if (!state.doc || !state.doc.nodeSize || onlyModifiedShown && onlyOriginalShown) {
    return DecorationSet.empty;
  }
  const decorations = [];
  const trackedChanges = getTrackChanges(state);
  if (!trackedChanges.length) {
    return DecorationSet.empty;
  }
  trackedChanges.forEach(({ mark, from: from3, to }) => {
    if (mark.type.name === superEditor_converter.TrackInsertMarkName) {
      if (onlyOriginalShown) {
        const decoration = Decoration.inline(from3, to, {
          class: "track-insert-dec hidden"
        });
        decorations.push(decoration);
      } else if (onlyModifiedShown) {
        const decoration = Decoration.inline(from3, to, {
          class: "track-insert-dec normal"
        });
        decorations.push(decoration);
      } else {
        const decoration = Decoration.inline(from3, to, {
          class: "track-insert-dec highlighted"
        });
        decorations.push(decoration);
      }
    }
    if (mark.type.name === superEditor_converter.TrackDeleteMarkName) {
      if (onlyOriginalShown) {
        const decoration = Decoration.inline(from3, to, {
          class: "track-delete-dec normal"
        });
        decorations.push(decoration);
      } else if (onlyModifiedShown) {
        const decoration = Decoration.inline(from3, to, {
          class: "track-delete-dec hidden"
        });
        decorations.push(decoration);
      } else {
        const decorationInline = Decoration.inline(from3, to, {
          class: "track-delete-dec highlighted"
          // 'hidden'
        });
        decorations.push(decorationInline);
        const decorationWidget = Decoration.widget(
          from3,
          () => {
            const span = document.createElement("span");
            span.classList.add("track-delete-widget");
            return span;
          },
          {
            ignoreSelection: true,
            key: "stable-key"
          }
        );
        decorations.push(decorationWidget);
      }
    }
    if (mark.type.name === superEditor_converter.TrackFormatMarkName) {
      if (onlyOriginalShown) {
        const decoration = Decoration.inline(from3, to, {
          class: "track-format-dec before"
        });
        decorations.push(decoration);
      } else if (onlyModifiedShown) {
        const decoration = Decoration.inline(from3, to, {
          class: "track-format-dec normal"
        });
        decorations.push(decoration);
      } else {
        const decoration = Decoration.inline(from3, to, {
          class: "track-format-dec highlighted"
        });
        decorations.push(decoration);
      }
    }
  });
  return DecorationSet.create(state.doc, decorations);
};
const CommentMarkName = "commentMark";
const resolveCommentMeta = ({ converter, importedId }) => {
  const comments = converter?.comments || [];
  const matchingImportedComment = comments.find((c2) => c2.importedId == importedId);
  const resolvedCommentId = matchingImportedComment?.commentId ?? (importedId ? String(importedId) : uuid.v4());
  const internal = matchingImportedComment?.internal ?? matchingImportedComment?.isInternal ?? false;
  const parentCommentId = matchingImportedComment?.parentCommentId;
  const trackedChangeParentId = matchingImportedComment?.trackedChangeParentId;
  const trackedChangeIds = converter?.trackedChangeIdMap ? new Set(Array.from(converter.trackedChangeIdMap.values()).map((id) => String(id))) : null;
  const tcParentId = trackedChangeParentId || parentCommentId;
  const isTrackedChangeParent = tcParentId && trackedChangeIds ? trackedChangeIds.has(String(tcParentId)) : false;
  return {
    resolvedCommentId,
    importedId,
    internal,
    matchingImportedComment,
    trackedChange: matchingImportedComment?.trackedChange === true || isTrackedChangeParent
  };
};
const ensureFallbackComment = ({ converter, matchingImportedComment, commentId, importedId }) => {
  if (matchingImportedComment || !converter) return;
  converter.comments = converter.comments || [];
  const alreadyExists = converter.comments.some((comment) => comment.commentId === commentId);
  if (alreadyExists) return;
  converter.comments.push({
    commentId,
    importedId,
    textJson: null,
    creatorName: null,
    creatorEmail: null,
    createdTime: null,
    isDone: false
  });
};
const TRACK_CHANGE_MARKS$1 = [superEditor_converter.TrackInsertMarkName, superEditor_converter.TrackDeleteMarkName, superEditor_converter.TrackFormatMarkName];
const removeCommentsById = ({ commentId, state, tr, dispatch }) => {
  const positions = getCommentPositionsById(commentId, state.doc);
  positions.forEach(({ from: from3, to }) => {
    tr.removeMark(from3, to, state.schema.marks[CommentMarkName]);
  });
  dispatch(tr);
};
const getCommentPositionsById = (commentId, doc2) => {
  const positions = [];
  doc2.descendants((node, pos) => {
    const { marks } = node;
    const commentMark = marks.find((mark) => mark.type.name === CommentMarkName);
    if (commentMark) {
      const { attrs } = commentMark;
      const { commentId: currentCommentId } = attrs;
      if (commentId === currentCommentId) {
        positions.push({ from: pos, to: pos + node.nodeSize });
      }
    }
  });
  return positions;
};
const getCommentMarkSegmentsById = (commentId, doc2) => {
  const segments = [];
  doc2.descendants((node, pos) => {
    if (!node.isInline) return;
    const commentMark = node.marks?.find(
      (mark) => mark.type.name === CommentMarkName && mark.attrs?.commentId === commentId
    );
    if (!commentMark) return;
    segments.push({
      from: pos,
      to: pos + node.nodeSize,
      attrs: commentMark.attrs || {}
    });
  });
  return segments;
};
const getCommentMarkRangesById = (commentId, doc2) => {
  const segments = getCommentMarkSegmentsById(commentId, doc2);
  if (!segments.length) return { segments, ranges: [] };
  const ranges = [];
  let active = null;
  segments.forEach((seg) => {
    if (!active) {
      active = {
        from: seg.from,
        to: seg.to,
        internal: !!seg.attrs?.internal
      };
      return;
    }
    if (seg.from <= active.to) {
      active.to = Math.max(active.to, seg.to);
      return;
    }
    ranges.push(active);
    active = {
      from: seg.from,
      to: seg.to,
      internal: !!seg.attrs?.internal
    };
  });
  if (active) ranges.push(active);
  return { segments, ranges };
};
const resolveCommentById = ({ commentId, state, tr, dispatch }) => {
  const { schema } = state;
  const markType = schema.marks?.[CommentMarkName];
  if (!markType) return false;
  const { segments, ranges } = getCommentMarkRangesById(commentId, state.doc);
  if (!segments.length) return false;
  segments.forEach(({ from: from3, to, attrs }) => {
    tr.removeMark(from3, to, markType.create(attrs));
  });
  const startType = schema.nodes?.commentRangeStart;
  const endType = schema.nodes?.commentRangeEnd;
  if (startType && endType) {
    ranges.slice().sort((a, b2) => b2.from - a.from).forEach(({ from: from3, to, internal }) => {
      tr.insert(to, endType.create({ "w:id": commentId }));
      tr.insert(from3, startType.create({ "w:id": commentId, internal }));
    });
  }
  dispatch(tr);
  return true;
};
const prepareCommentsForExport = (doc2, tr, schema, comments = []) => {
  const commentMap = /* @__PURE__ */ new Map();
  comments.forEach((c2) => {
    commentMap.set(c2.commentId, c2);
  });
  const trackedChangeSpanById = /* @__PURE__ */ new Map();
  const trackedChangeMarksById = /* @__PURE__ */ new Map();
  doc2.descendants((node, pos) => {
    const trackedChangeMark = node.marks?.find((mark) => TRACK_CHANGE_MARKS$1.includes(mark.type.name));
    if (!trackedChangeMark) return;
    const trackedChangeId = trackedChangeMark.attrs?.id;
    if (!trackedChangeId) return;
    const existing = trackedChangeSpanById.get(trackedChangeId);
    const startPos = pos;
    const endPos = pos + node.nodeSize;
    if (!existing) {
      trackedChangeSpanById.set(trackedChangeId, { startPos, endPos });
    } else {
      existing.startPos = Math.min(existing.startPos, startPos);
      existing.endPos = Math.max(existing.endPos, endPos);
    }
    const marksEntry = trackedChangeMarksById.get(trackedChangeId) || {};
    if (trackedChangeMark.type?.name === superEditor_converter.TrackInsertMarkName && !marksEntry.insertMark) {
      marksEntry.insertMark = trackedChangeMark;
    }
    if (trackedChangeMark.type?.name === superEditor_converter.TrackDeleteMarkName && !marksEntry.deleteMark) {
      marksEntry.deleteMark = trackedChangeMark;
    }
    trackedChangeMarksById.set(trackedChangeId, marksEntry);
  });
  const getThreadingParentId = (comment) => {
    if (!comment) return void 0;
    const usesRangeThreading = comment.threadingStyleOverride === "range-based" || comment.threadingMethod === "range-based" || comment.originalXmlStructure?.hasCommentsExtended === false;
    if (usesRangeThreading && comment.threadingParentCommentId) {
      return comment.threadingParentCommentId;
    }
    return comment.parentCommentId;
  };
  const commentRanges = /* @__PURE__ */ new Map();
  const commentTrackedChangeId = /* @__PURE__ */ new Map();
  doc2.descendants((node, pos) => {
    const commentMarks = node.marks?.filter((mark) => mark.type.name === CommentMarkName) || [];
    if (!commentMarks.length) return;
    const nodeEnd = pos + node.nodeSize;
    const trackedChangeMark = node.marks?.find((mark) => TRACK_CHANGE_MARKS$1.includes(mark.type.name));
    const trackedChangeId = trackedChangeMark?.attrs?.id;
    commentMarks.forEach((commentMark) => {
      const { attrs = {} } = commentMark;
      const { commentId } = attrs;
      if (commentId === "pending") return;
      if (!commentRanges.has(commentId)) {
        commentRanges.set(commentId, {
          start: pos,
          end: nodeEnd,
          attrs
        });
      } else {
        const existing = commentRanges.get(commentId);
        existing.start = Math.min(existing.start, pos);
        existing.end = Math.max(existing.end, nodeEnd);
      }
      if (trackedChangeId && !commentTrackedChangeId.has(commentId)) {
        commentTrackedChangeId.set(commentId, trackedChangeId);
      }
    });
  });
  const startNodes = [];
  const endNodes = [];
  const seen = /* @__PURE__ */ new Set();
  const trackedChangeCommentMeta = /* @__PURE__ */ new Map();
  commentRanges.forEach(({ start: start2, end: end2, attrs }, commentId) => {
    if (seen.has(commentId)) return;
    seen.add(commentId);
    const comment = commentMap.get(commentId);
    const parentCommentId = getThreadingParentId(comment);
    const trackedChangeId = commentTrackedChangeId.get(commentId);
    const trackedSpan = trackedChangeId ? trackedChangeSpanById.get(trackedChangeId) : null;
    if (trackedSpan) {
      trackedChangeCommentMeta.set(commentId, {
        comment,
        parentCommentId,
        trackedChangeId,
        actualStart: start2,
        actualEnd: end2
      });
      return;
    }
    const commentStartNodeAttrs = getPreparedComment(attrs);
    const startNode = schema.nodes.commentRangeStart.create(commentStartNodeAttrs);
    startNodes.push({
      pos: start2,
      node: startNode,
      commentId,
      parentCommentId
    });
    const endNode = schema.nodes.commentRangeEnd.create(commentStartNodeAttrs);
    endNodes.push({
      pos: end2,
      node: endNode,
      commentId,
      parentCommentId
    });
    const childComments = comments.filter((c2) => getThreadingParentId(c2) === commentId).sort((a, b2) => a.createdTime - b2.createdTime);
    childComments.forEach((c2) => {
      if (seen.has(c2.commentId)) return;
      seen.add(c2.commentId);
      const childRange = commentRanges.get(c2.commentId);
      const childStart = childRange?.start ?? start2;
      const childEnd = childRange?.end ?? end2;
      const childMark = getPreparedComment({
        commentId: c2.commentId,
        internal: c2.isInternal
      });
      const childStartNode = schema.nodes.commentRangeStart.create(childMark);
      startNodes.push({
        pos: childStart,
        node: childStartNode,
        commentId: c2.commentId,
        parentCommentId: getThreadingParentId(c2)
      });
      const childEndNode = schema.nodes.commentRangeEnd.create(childMark);
      endNodes.push({
        pos: childEnd,
        node: childEndNode,
        commentId: c2.commentId,
        parentCommentId: getThreadingParentId(c2)
      });
    });
  });
  if (trackedChangeSpanById.size > 0) {
    trackedChangeCommentMeta.forEach(({ comment, parentCommentId, trackedChangeId, actualStart, actualEnd }) => {
      if (!comment || !trackedChangeSpanById.has(trackedChangeId)) return;
      const span = trackedChangeSpanById.get(trackedChangeId);
      if (!span) return;
      const childMark = getPreparedComment({
        commentId: comment.commentId,
        internal: comment.isInternal
      });
      const trackedMarks = trackedChangeMarksById.get(trackedChangeId) || {};
      const startMarks = trackedMarks.insertMark ? [trackedMarks.insertMark] : trackedMarks.deleteMark ? [trackedMarks.deleteMark] : void 0;
      const endMarks = trackedMarks.deleteMark ? [trackedMarks.deleteMark] : trackedMarks.insertMark ? [trackedMarks.insertMark] : void 0;
      const startPos = actualStart ?? span.startPos;
      const endPos = actualEnd ?? span.endPos;
      const childStartNode = schema.nodes.commentRangeStart.create(childMark, null, startMarks);
      startNodes.push({
        pos: startPos,
        node: childStartNode,
        commentId: comment.commentId,
        parentCommentId
      });
      const childEndNode = schema.nodes.commentRangeEnd.create(childMark, null, endMarks);
      endNodes.push({
        pos: endPos,
        node: childEndNode,
        commentId: comment.commentId,
        parentCommentId
      });
      const childComments = comments.filter((c2) => getThreadingParentId(c2) === comment.commentId).sort((a, b2) => a.createdTime - b2.createdTime);
      childComments.forEach((c2) => {
        if (seen.has(c2.commentId)) return;
        seen.add(c2.commentId);
        const childRange = commentRanges.get(c2.commentId);
        const childStart = childRange?.start ?? actualStart ?? span.startPos;
        const childEnd = childRange?.end ?? actualEnd ?? span.endPos;
        const childStartMarks = childRange ? void 0 : startMarks;
        const childEndMarks = childRange ? void 0 : endMarks;
        const childMarkAttrs = getPreparedComment({
          commentId: c2.commentId,
          internal: c2.isInternal
        });
        const childStartNode2 = schema.nodes.commentRangeStart.create(childMarkAttrs, null, childStartMarks);
        startNodes.push({
          pos: childStart,
          node: childStartNode2,
          commentId: c2.commentId,
          parentCommentId: getThreadingParentId(c2)
        });
        const childEndNode2 = schema.nodes.commentRangeEnd.create(childMarkAttrs, null, childEndMarks);
        endNodes.push({
          pos: childEnd,
          node: childEndNode2,
          commentId: c2.commentId,
          parentCommentId: getThreadingParentId(c2)
        });
      });
    });
    comments.filter((comment) => {
      const tcParentId = comment.trackedChangeParentId || comment.parentCommentId;
      return trackedChangeSpanById.has(tcParentId) && !comment.trackedChange;
    }).sort((a, b2) => a.createdTime - b2.createdTime).forEach((comment) => {
      if (seen.has(comment.commentId)) return;
      seen.add(comment.commentId);
      const tcParentId = comment.trackedChangeParentId || comment.parentCommentId;
      const span = trackedChangeSpanById.get(tcParentId);
      if (!span) return;
      const childMark = getPreparedComment({
        commentId: comment.commentId,
        internal: comment.isInternal
      });
      const parentCommentId = getThreadingParentId(comment);
      const trackedMarks = trackedChangeMarksById.get(tcParentId) || {};
      const startMarks = trackedMarks.insertMark ? [trackedMarks.insertMark] : trackedMarks.deleteMark ? [trackedMarks.deleteMark] : void 0;
      const endMarks = trackedMarks.deleteMark ? [trackedMarks.deleteMark] : trackedMarks.insertMark ? [trackedMarks.insertMark] : void 0;
      const childStartNode = schema.nodes.commentRangeStart.create(childMark, null, startMarks);
      startNodes.push({
        pos: span.startPos,
        node: childStartNode,
        commentId: comment.commentId,
        parentCommentId
      });
      const childEndNode = schema.nodes.commentRangeEnd.create(childMark, null, endMarks);
      endNodes.push({
        pos: span.endPos,
        node: childEndNode,
        commentId: comment.commentId,
        parentCommentId
      });
    });
  }
  startNodes.sort((a, b2) => {
    if (a.pos !== b2.pos) return a.pos - b2.pos;
    const aIsParentOfB = a.commentId === b2.parentCommentId;
    const bIsParentOfA = b2.commentId === a.parentCommentId;
    if (aIsParentOfB) return -1;
    if (bIsParentOfA) return 1;
    if (a.parentCommentId && a.parentCommentId === b2.parentCommentId) {
      const aComment = commentMap.get(a.commentId);
      const bComment = commentMap.get(b2.commentId);
      return (aComment?.createdTime || 0) - (bComment?.createdTime || 0);
    }
    return 0;
  });
  endNodes.sort((a, b2) => {
    if (a.pos !== b2.pos) return a.pos - b2.pos;
    const aIsParentOfB = a.commentId === b2.parentCommentId;
    const bIsParentOfA = b2.commentId === a.parentCommentId;
    if (aIsParentOfB) return -1;
    if (bIsParentOfA) return 1;
    if (a.parentCommentId && a.parentCommentId === b2.parentCommentId) {
      const aComment = commentMap.get(a.commentId);
      const bComment = commentMap.get(b2.commentId);
      return (aComment?.createdTime || 0) - (bComment?.createdTime || 0);
    }
    return 0;
  });
  startNodes.forEach((n) => {
    const { pos, node } = n;
    const mappedPos = tr.mapping.map(pos);
    tr.insert(mappedPos, node);
  });
  endNodes.forEach((n) => {
    const { pos, node } = n;
    const mappedPos = tr.mapping.map(pos);
    tr.insert(mappedPos, node);
  });
  return tr;
};
const getPreparedComment = (attrs) => {
  const { commentId, internal } = attrs;
  return {
    "w:id": commentId,
    internal
  };
};
const prepareCommentsForImport = (doc2, tr, schema, converter) => {
  const toMark = [];
  const toDelete = [];
  const toUpdate = [];
  doc2.descendants((node, pos) => {
    const { type } = node;
    const commentNodes = ["commentRangeStart", "commentRangeEnd", "commentReference"];
    if (!commentNodes.includes(type.name)) return;
    const { resolvedCommentId, importedId, internal, matchingImportedComment, trackedChange } = resolveCommentMeta({
      converter,
      importedId: node.attrs["w:id"]
    });
    const isDone = !!matchingImportedComment?.isDone;
    if (type.name === "commentRangeStart") {
      if (!matchingImportedComment || !matchingImportedComment.isDone) {
        toMark.push({
          commentId: resolvedCommentId,
          importedId,
          internal,
          trackedChange,
          start: pos
        });
      }
      ensureFallbackComment({
        converter,
        matchingImportedComment,
        commentId: resolvedCommentId,
        importedId
      });
      if (isDone) {
        toUpdate.push({
          pos,
          attrs: {
            ...node.attrs,
            "w:id": resolvedCommentId,
            internal
          }
        });
      } else {
        toDelete.push({ start: pos, end: pos + 1 });
      }
    } else if (type.name === "commentRangeEnd") {
      if (isDone) {
        toUpdate.push({
          pos,
          attrs: {
            ...node.attrs,
            "w:id": resolvedCommentId
          }
        });
        return;
      }
      const itemToMark = toMark.find((p2) => p2.importedId === importedId);
      if (!itemToMark) return;
      const { start: start2 } = itemToMark;
      const markAttrs = {
        commentId: itemToMark.commentId,
        importedId,
        internal: itemToMark.internal,
        trackedChange: itemToMark.trackedChange
      };
      tr.addMark(start2, pos + 1, schema.marks[CommentMarkName].create(markAttrs));
      toDelete.push({ start: pos, end: pos + 1 });
    } else if (type.name === "commentReference") {
      toDelete.push({ start: pos, end: pos + 1 });
    }
  });
  if (typeof tr.setNodeMarkup === "function") {
    toUpdate.sort((a, b2) => b2.pos - a.pos).forEach(({ pos, attrs }) => {
      tr.setNodeMarkup(pos, void 0, attrs);
    });
  }
  toDelete.sort((a, b2) => b2.start - a.start).forEach(({ start: start2, end: end2 }) => {
    tr.delete(start2, end2);
  });
};
const translateFormatChangesToEnglish = (attrs = {}) => {
  const { before = [], after = [] } = attrs;
  const beforeTypes = new Set(before.map((mark) => mark.type));
  const afterTypes = new Set(after.map((mark) => mark.type));
  const added = [...afterTypes].filter((type) => !beforeTypes.has(type));
  const removed = [...beforeTypes].filter((type) => !afterTypes.has(type));
  const messages = [];
  const nonTextStyleAdded = added.filter((type) => !["textStyle", "commentMark"].includes(type));
  if (nonTextStyleAdded.length) {
    messages.push(`Added formatting: ${nonTextStyleAdded.join(", ")}`);
  }
  const nonTextStyleRemoved = removed.filter((type) => !["textStyle", "commentMark"].includes(type));
  if (nonTextStyleRemoved.length) {
    messages.push(`Removed formatting: ${nonTextStyleRemoved.join(", ")}`);
  }
  const beforeTextStyle = before.find((mark) => mark.type === "textStyle")?.attrs || {};
  const afterTextStyle = after.find((mark) => mark.type === "textStyle")?.attrs || {};
  const textStyleChanges = [];
  const formatAttrName = (attr) => attr.replace(/([a-z])([A-Z])/g, "$1 $2").toLowerCase();
  Object.keys({ ...beforeTextStyle, ...afterTextStyle }).forEach((attr) => {
    const beforeValue = beforeTextStyle[attr];
    const afterValue = afterTextStyle[attr];
    if (beforeValue !== afterValue) {
      if (afterValue === null) {
        return;
      } else if (attr === "color") {
        textStyleChanges.push(`Changed color`);
      } else {
        const label = formatAttrName(attr);
        if (beforeValue === void 0 || beforeValue === null) {
          textStyleChanges.push(`Set ${label} to ${afterValue}`);
        } else {
          textStyleChanges.push(`Changed ${label} from ${beforeValue} to ${afterValue}`);
        }
      }
    }
  });
  if (textStyleChanges.length) {
    messages.push(`Modified text style: ${textStyleChanges.join(", ")}`);
  }
  return messages.length ? messages.join(". ") : "No formatting changes.";
};
const DEFAULT_ACTIVE_ALPHA = 68 / 255;
const DEFAULT_INACTIVE_ALPHA = 34 / 255;
const clampOpacity = (value) => {
  if (!Number.isFinite(value)) return null;
  return Math.max(0, Math.min(1, value));
};
const applyAlphaToHex = (color, opacity) => {
  if (typeof color !== "string") return color;
  const match = color.match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
  if (!match) return color;
  const hex2 = match[1].length === 3 ? match[1].split("").map((c2) => c2 + c2).join("") : match[1];
  const alpha = Math.round(opacity * 255).toString(16).padStart(2, "0");
  return `#${hex2}${alpha}`;
};
const getHighlightColor = ({ activeThreadId, threadId, isInternal, editor }) => {
  if (!editor.options.isInternal && isInternal) return "transparent";
  const pluginState = CommentsPluginKey.getState(editor.state);
  const highlightColors = editor.options.comments?.highlightColors || {};
  const highlightOpacity = editor.options.comments?.highlightOpacity || {};
  const isActive2 = activeThreadId === threadId;
  const baseColor = isInternal ? highlightColors.internal ?? pluginState.internalColor : highlightColors.external ?? pluginState.externalColor;
  const activeOverride = isInternal ? highlightColors.activeInternal : highlightColors.activeExternal;
  if (isActive2 && activeOverride) return activeOverride;
  const resolvedOpacity = clampOpacity(isActive2 ? highlightOpacity.active : highlightOpacity.inactive);
  const opacity = resolvedOpacity ?? (isActive2 ? DEFAULT_ACTIVE_ALPHA : DEFAULT_INACTIVE_ALPHA);
  return applyAlphaToHex(baseColor, opacity);
};
const normalizeCommentEventPayload = ({ conversation, editorOptions, fallbackCommentId, fallbackInternal }) => {
  const { user, documentId } = editorOptions || {};
  const normalized = {
    ...conversation,
    commentId: conversation?.commentId ?? fallbackCommentId,
    isInternal: conversation?.isInternal ?? fallbackInternal
  };
  if (!normalized.commentText && normalized.text) {
    normalized.commentText = normalized.text;
    delete normalized.text;
  }
  if ("skipEmit" in normalized) delete normalized.skipEmit;
  if (!normalized.creatorName && user?.name) {
    normalized.creatorName = user.name;
  }
  if (!normalized.creatorEmail && user?.email) {
    normalized.creatorEmail = user.email;
  }
  if (!normalized.creatorImage && user?.image) {
    normalized.creatorImage = user.image;
  }
  if (!normalized.createdTime) {
    normalized.createdTime = Date.now();
  }
  if (!normalized.fileId && documentId) {
    normalized.fileId = documentId;
  }
  if (!normalized.documentId && documentId) {
    normalized.documentId = documentId;
  }
  return normalized;
};
const updatePosition = ({ allCommentPositions, threadId, pos, currentBounds, node }) => {
  let bounds = {};
  if (currentBounds instanceof DOMRect) {
    bounds = {
      top: currentBounds.top,
      bottom: currentBounds.bottom,
      left: currentBounds.left,
      right: currentBounds.right
    };
  } else {
    bounds = { ...currentBounds };
  }
  if (!allCommentPositions[threadId]) {
    allCommentPositions[threadId] = {
      threadId,
      start: pos,
      end: pos + node.nodeSize,
      bounds
    };
  } else {
    const existing = allCommentPositions[threadId];
    existing.start = Math.min(existing.start, pos);
    existing.end = Math.max(existing.end, pos + node.nodeSize);
    existing.bounds.top = Math.min(existing.bounds.top, currentBounds.top);
    existing.bounds.bottom = Math.max(existing.bounds.bottom, currentBounds.bottom);
  }
};
const TRACK_CHANGE_MARKS = [superEditor_converter.TrackInsertMarkName, superEditor_converter.TrackDeleteMarkName, superEditor_converter.TrackFormatMarkName];
const CommentsPluginKey = new superEditor_converter.PluginKey("comments");
const CommentsPlugin = Extension.create({
  name: "comments",
  addCommands() {
    return {
      /**
       * Add a comment to the current selection
       * @category Command
       * @param {string|Object} contentOrOptions - Comment content as a string, or an options object
       * @param {string} [contentOrOptions.content] - The comment content (text or HTML)
       * @param {string} [contentOrOptions.author] - Author name (defaults to user from editor config)
       * @param {string} [contentOrOptions.authorEmail] - Author email (defaults to user from editor config)
       * @param {string} [contentOrOptions.authorImage] - Author image URL (defaults to user from editor config)
       * @param {boolean} [contentOrOptions.isInternal=false] - Whether the comment is internal/private
       * @returns {boolean} True if the comment was added successfully, false otherwise
       * @example
       * // Simple usage with just content
       * editor.commands.addComment('This needs review')
       *
       * // With options
       * editor.commands.addComment({
       *   content: 'Please clarify this section',
       *   author: 'Jane Doe',
       *   isInternal: true
       * })
       *
       * // To get the comment ID, listen to the commentsUpdate event
       * editor.on('commentsUpdate', (event) => {
       *   if (event.type === 'add') {
       *     console.log('New comment ID:', event.activeCommentId)
       *   }
       * })
       */
      addComment: (contentOrOptions) => ({ tr, dispatch, editor }) => {
        const { selection } = tr;
        const { $from, $to } = selection;
        if ($from.pos === $to.pos) {
          console.warn("addComment requires a text selection. Please select text before adding a comment.");
          return false;
        }
        let content, author, authorEmail, authorImage, isInternal;
        if (typeof contentOrOptions === "string") {
          content = contentOrOptions;
        } else if (contentOrOptions && typeof contentOrOptions === "object") {
          content = contentOrOptions.content;
          author = contentOrOptions.author;
          authorEmail = contentOrOptions.authorEmail;
          authorImage = contentOrOptions.authorImage;
          isInternal = contentOrOptions.isInternal;
        }
        const commentId = uuid.v4();
        const resolvedInternal = isInternal ?? false;
        const configUser = editor.options?.user || {};
        tr.setMeta(CommentsPluginKey, { event: "add" });
        tr.addMark(
          $from.pos,
          $to.pos,
          editor.schema.marks[CommentMarkName].create({
            commentId,
            internal: resolvedInternal
          })
        );
        if (dispatch) dispatch(tr);
        const commentPayload = normalizeCommentEventPayload({
          conversation: {
            commentId,
            isInternal: resolvedInternal,
            commentText: content,
            creatorName: author ?? configUser.name,
            creatorEmail: authorEmail ?? configUser.email,
            creatorImage: authorImage ?? configUser.image,
            createdTime: Date.now()
          },
          editorOptions: editor.options,
          fallbackCommentId: commentId,
          fallbackInternal: resolvedInternal
        });
        editor.emit("commentsUpdate", {
          type: comments_module_events.ADD,
          comment: commentPayload,
          activeCommentId: commentId
        });
        return true;
      },
      /**
       * Add a reply to an existing comment or tracked change
       * @category Command
       * @param {Object} options - Reply options
       * @param {string} options.parentId - The ID of the parent comment or tracked change
       * @param {string} [options.content] - The reply content (text or HTML)
       * @param {string} [options.author] - Author name (defaults to user from editor config)
       * @param {string} [options.authorEmail] - Author email (defaults to user from editor config)
       * @param {string} [options.authorImage] - Author image URL (defaults to user from editor config)
       * @returns {boolean} True if the reply was added successfully, false otherwise
       * @example
       * editor.commands.addCommentReply({
       *   parentId: 'comment-123',
       *   content: 'I agree with this suggestion'
       * })
       */
      addCommentReply: (options = {}) => ({ editor }) => {
        const { parentId, content, author, authorEmail, authorImage } = options;
        if (!parentId) {
          console.warn("addCommentReply requires a parentId");
          return false;
        }
        const commentId = uuid.v4();
        const configUser = editor.options?.user || {};
        const commentPayload = normalizeCommentEventPayload({
          conversation: {
            commentId,
            parentCommentId: parentId,
            commentText: content,
            creatorName: author ?? configUser.name,
            creatorEmail: authorEmail ?? configUser.email,
            creatorImage: authorImage ?? configUser.image,
            createdTime: Date.now()
          },
          editorOptions: editor.options,
          fallbackCommentId: commentId,
          fallbackInternal: false
        });
        editor.emit("commentsUpdate", {
          type: comments_module_events.ADD,
          comment: commentPayload,
          activeCommentId: commentId
        });
        return true;
      },
      /**
       * @private
       * Internal command to insert a comment mark at the current selection.
       * Use `addComment` for the public API.
       */
      insertComment: (conversation = {}) => ({ tr, dispatch }) => {
        const { selection } = tr;
        const { $from, $to } = selection;
        const skipEmit = conversation?.skipEmit;
        const resolvedCommentId = conversation?.commentId ?? uuid.v4();
        const resolvedInternal = conversation?.isInternal ?? false;
        tr.setMeta(CommentsPluginKey, { event: "add" });
        tr.addMark(
          $from.pos,
          $to.pos,
          this.editor.schema.marks[CommentMarkName].create({
            commentId: resolvedCommentId,
            internal: resolvedInternal
          })
        );
        if (dispatch) dispatch(tr);
        const shouldEmit = !skipEmit && resolvedCommentId !== "pending";
        if (shouldEmit) {
          const commentPayload = normalizeCommentEventPayload({
            conversation,
            editorOptions: this.editor.options,
            fallbackCommentId: resolvedCommentId,
            fallbackInternal: resolvedInternal
          });
          const activeCommentId = commentPayload.commentId || commentPayload.importedId || null;
          const event = {
            type: comments_module_events.ADD,
            comment: commentPayload,
            ...activeCommentId && { activeCommentId }
          };
          this.editor.emit("commentsUpdate", event);
        }
        return true;
      },
      removeComment: ({ commentId, importedId }) => ({ tr, dispatch, state }) => {
        tr.setMeta(CommentsPluginKey, { event: "deleted" });
        removeCommentsById({ commentId, state, tr, dispatch });
      },
      setActiveComment: ({ commentId }) => ({ tr }) => {
        tr.setMeta(CommentsPluginKey, { type: "setActiveComment", activeThreadId: commentId, forceUpdate: true });
        return true;
      },
      setCommentInternal: ({ commentId, isInternal }) => ({ tr, dispatch, state }) => {
        const { doc: doc2 } = state;
        let foundStartNode;
        let foundPos;
        tr.setMeta(CommentsPluginKey, { event: "update" });
        doc2.descendants((node, pos) => {
          if (foundStartNode) return;
          const { marks = [] } = node;
          const commentMark = marks.find((mark) => mark.type.name === CommentMarkName);
          if (commentMark) {
            const { attrs } = commentMark;
            const wid = attrs.commentId;
            if (wid === commentId) {
              foundStartNode = node;
              foundPos = pos;
            }
          }
        });
        if (!foundStartNode) return false;
        tr.addMark(
          foundPos,
          foundPos + foundStartNode.nodeSize,
          this.editor.schema.marks[CommentMarkName].create({
            commentId,
            internal: isInternal
          })
        );
        tr.setMeta(CommentsPluginKey, { type: "setCommentInternal" });
        dispatch(tr);
        return true;
      },
      resolveComment: ({ commentId }) => ({ tr, dispatch, state }) => {
        tr.setMeta(CommentsPluginKey, { event: "update" });
        return resolveCommentById({ commentId, state, tr, dispatch });
      },
      setCursorById: (id) => ({ state, editor }) => {
        const { from: from3 } = findRangeById(state.doc, id) || {};
        if (from3 != null) {
          state.tr.setSelection(superEditor_converter.TextSelection.create(state.doc, from3));
          editor.view.focus();
          return true;
        }
        return false;
      }
    };
  },
  addPmPlugins() {
    const editor = this.editor;
    let shouldUpdate = true;
    if (editor.options.isHeadless) return [];
    const commentsPlugin = new superEditor_converter.Plugin({
      key: CommentsPluginKey,
      state: {
        init() {
          const highlightColors = editor.options.comments?.highlightColors || {};
          return {
            activeThreadId: null,
            externalColor: highlightColors.external ?? "#B1124B",
            internalColor: highlightColors.internal ?? "#078383",
            decorations: DecorationSet.empty,
            allCommentPositions: {},
            allCommentIds: [],
            changedActiveThread: false,
            trackedChanges: {}
          };
        },
        apply(tr, pluginState, _2, newEditorState) {
          const meta = tr.getMeta(CommentsPluginKey);
          const { type } = meta || {};
          if (type === "force" || type === "forceTrackChanges") shouldUpdate = true;
          if (type === "setActiveComment") {
            shouldUpdate = true;
            const previousActiveThreadId = pluginState.activeThreadId;
            const newActiveThreadId = meta.activeThreadId;
            if (previousActiveThreadId !== newActiveThreadId) {
              const update = {
                type: comments_module_events.SELECTED,
                activeCommentId: newActiveThreadId ? newActiveThreadId : null
              };
              setTimeout(() => editor.emit("commentsUpdate", update), 0);
            }
            pluginState.activeThreadId = newActiveThreadId;
            return {
              ...pluginState,
              activeThreadId: newActiveThreadId,
              changedActiveThread: true
            };
          }
          if (meta && meta.decorations) {
            return {
              ...pluginState,
              decorations: meta.decorations,
              allCommentPositions: meta.allCommentPositions
            };
          }
          const trackedChangeMeta = tr.getMeta(TrackChangesBasePluginKey);
          const currentTrackedChanges = pluginState.trackedChanges;
          if (trackedChangeMeta) {
            pluginState.trackedChanges = handleTrackedChangeTransaction(
              trackedChangeMeta,
              currentTrackedChanges,
              newEditorState,
              editor
            );
          }
          const trChangedActiveComment = meta?.type === "setActiveComment";
          if (!tr.docChanged && tr.selectionSet || trChangedActiveComment) {
            const { selection } = tr;
            let currentActiveThread = getActiveCommentId(newEditorState.doc, selection);
            if (trChangedActiveComment) currentActiveThread = meta.activeThreadId;
            const previousSelectionId = pluginState.activeThreadId;
            if (previousSelectionId !== currentActiveThread) {
              pluginState.activeThreadId = currentActiveThread;
              const update = {
                type: comments_module_events.SELECTED,
                activeCommentId: currentActiveThread ? currentActiveThread : null
              };
              shouldUpdate = true;
              editor.emit("commentsUpdate", update);
              const { tr: newTr } = editor.view.state;
              const { dispatch } = editor.view;
              newTr.setMeta(CommentsPluginKey, { type: "force" });
              dispatch(newTr);
            }
          }
          return pluginState;
        }
      },
      props: {
        decorations(state) {
          return this.getState(state).decorations;
        }
      },
      view() {
        let prevDoc = null;
        let prevActiveThreadId = null;
        let prevAllCommentPositions = {};
        let hasEverEmitted = false;
        return {
          update(view) {
            const { state } = view;
            const { doc: doc2, tr } = state;
            const pluginState = CommentsPluginKey.getState(state);
            const currentActiveThreadId = pluginState.activeThreadId;
            const meta = tr.getMeta(CommentsPluginKey);
            if (meta?.type === "setActiveComment" || meta?.forceUpdate) {
              shouldUpdate = true;
            }
            const docChanged = !prevDoc || !prevDoc.eq(doc2);
            if (docChanged) shouldUpdate = true;
            const activeThreadChanged = prevActiveThreadId !== currentActiveThreadId;
            if (activeThreadChanged) {
              shouldUpdate = true;
              prevActiveThreadId = currentActiveThreadId;
            }
            const isInitialLoad = prevDoc === null;
            const onlyActiveThreadChanged = !isInitialLoad && !docChanged && activeThreadChanged;
            if (!shouldUpdate) return;
            prevDoc = doc2;
            shouldUpdate = false;
            const decorations = [];
            const allCommentPositions = {};
            doc2.descendants((node, pos) => {
              const { marks = [] } = node;
              const commentMarks = marks.filter((mark) => mark.type.name === CommentMarkName);
              let hasActive = false;
              commentMarks.forEach((commentMark) => {
                const { attrs } = commentMark;
                const threadId = attrs.commentId || attrs.importedId;
                if (!onlyActiveThreadChanged) {
                  let currentBounds;
                  try {
                    currentBounds = view.coordsAtPos(pos);
                  } catch {
                    currentBounds = null;
                  }
                  if (currentBounds) {
                    updatePosition({
                      allCommentPositions,
                      threadId,
                      pos,
                      currentBounds,
                      node
                    });
                  }
                }
                const isInternal = attrs.internal;
                if (!hasActive) hasActive = currentActiveThreadId === threadId;
                let color = getHighlightColor({
                  activeThreadId: currentActiveThreadId,
                  threadId,
                  isInternal,
                  editor
                });
                const deco = Decoration.inline(pos, pos + node.nodeSize, {
                  style: `background-color: ${color};`,
                  "data-thread-id": threadId,
                  class: "sd-editor-comment-highlight"
                });
                if (hasActive && currentActiveThreadId !== threadId) return;
                decorations.push(deco);
              });
              const trackedChangeMark = findTrackedMark({
                doc: doc2,
                from: pos,
                to: pos + node.nodeSize
              });
              if (trackedChangeMark) {
                if (!onlyActiveThreadChanged) {
                  let currentBounds;
                  try {
                    currentBounds = view.coordsAtPos(pos);
                  } catch {
                    currentBounds = null;
                  }
                  const { id } = trackedChangeMark.mark.attrs;
                  if (currentBounds) {
                    updatePosition({
                      allCommentPositions,
                      threadId: id,
                      pos,
                      currentBounds,
                      node
                    });
                  }
                }
                const isActiveTrackedChange = currentActiveThreadId === trackedChangeMark.mark.attrs.id;
                if (isActiveTrackedChange) {
                  const trackedChangeDeco = Decoration.inline(pos, pos + node.nodeSize, {
                    style: `border-width: 2px;`,
                    "data-thread-id": trackedChangeMark.mark.attrs.id,
                    class: "sd-editor-tracked-change-highlight"
                  });
                  decorations.push(trackedChangeDeco);
                }
              }
            });
            const decorationSet = DecorationSet.create(doc2, decorations);
            const oldDecorations = pluginState.decorations;
            const same = oldDecorations.eq(decorationSet);
            if (!same) {
              const tr2 = state.tr.setMeta(CommentsPluginKey, {
                decorations: decorationSet,
                allCommentPositions,
                forceUpdate: true
              });
              view.dispatch(tr2);
            }
            if (!onlyActiveThreadChanged) {
              const positionsChanged = hasPositionsChanged(prevAllCommentPositions, allCommentPositions);
              const hasComments2 = Object.keys(allCommentPositions).length > 0;
              const shouldEmitPositions = positionsChanged || !hasEverEmitted && hasComments2;
              if (shouldEmitPositions) {
                prevAllCommentPositions = allCommentPositions;
                hasEverEmitted = true;
                editor.emit("comment-positions", { allCommentPositions });
              }
            }
          }
        };
      }
    });
    return [commentsPlugin];
  }
});
const hasPositionsChanged = (prevPositions, currPositions) => {
  const prevKeys = Object.keys(prevPositions);
  const currKeys = Object.keys(currPositions);
  if (prevKeys.length !== currKeys.length) return true;
  for (const key2 of currKeys) {
    const prev = prevPositions[key2];
    const curr = currPositions[key2];
    if (!prev || !prev.bounds || !curr.bounds) {
      return true;
    }
    if (prev.bounds.top !== curr.bounds.top || prev.bounds.left !== curr.bounds.left) {
      return true;
    }
  }
  return false;
};
const getActiveCommentId = (doc2, selection) => {
  if (!selection) return;
  const { $from, $to } = selection;
  if ($from.pos !== $to.pos) return;
  const nodeAtPos = doc2.nodeAt($from.pos);
  if (!nodeAtPos) return;
  const trackedChangeMark = findTrackedMark({
    doc: doc2,
    from: $from.pos,
    to: $to.pos
  });
  const commentRanges = /* @__PURE__ */ new Map();
  doc2.descendants((node, pos) => {
    const { marks = [] } = node;
    const commentMarks = marks.filter((mark) => mark.type.name === CommentMarkName);
    commentMarks.forEach((mark) => {
      const commentId = mark.attrs.commentId || mark.attrs.importedId;
      if (!commentId) return;
      const existing = commentRanges.get(commentId);
      const end2 = pos + node.nodeSize;
      if (!existing) {
        commentRanges.set(commentId, { start: pos, end: end2 });
      } else {
        commentRanges.set(commentId, {
          start: Math.min(existing.start, pos),
          end: Math.max(existing.end, end2)
        });
      }
    });
  });
  const containingComments = [];
  commentRanges.forEach((range, commentId) => {
    if ($from.pos >= range.start && $from.pos < range.end) {
      containingComments.push({
        commentId,
        start: range.start,
        end: range.end,
        size: range.end - range.start
      });
    }
  });
  if (containingComments.length === 0) {
    if (trackedChangeMark) {
      return trackedChangeMark.mark.attrs.id;
    }
    return null;
  }
  containingComments.sort((a, b2) => a.size - b2.size);
  return containingComments[0].commentId;
};
const findTrackedMark = ({
  doc: doc2,
  from: from3,
  to,
  offset: offset2 = 1
  // To get non-inclusive marks.
}) => {
  const startPos = Math.max(from3 - offset2, 0);
  const endPos = Math.min(to + offset2, doc2.content.size);
  let markFound;
  doc2.nodesBetween(startPos, endPos, (node, pos) => {
    if (!node || node?.nodeSize === void 0) {
      return;
    }
    const mark = node.marks.find((mark2) => TRACK_CHANGE_MARKS.includes(mark2.type.name));
    if (mark && !markFound) {
      markFound = {
        from: pos,
        to: pos + node.nodeSize,
        mark
      };
    }
  });
  return markFound;
};
const handleTrackedChangeTransaction = (trackedChangeMeta, trackedChanges, newEditorState, editor) => {
  const { insertedMark, deletionMark, formatMark, deletionNodes } = trackedChangeMeta;
  if (!insertedMark && !deletionMark && !formatMark) {
    return;
  }
  const newTrackedChanges = { ...trackedChanges };
  let id = insertedMark?.attrs?.id || deletionMark?.attrs?.id || formatMark?.attrs?.id;
  if (!id) {
    return trackedChanges;
  }
  let isNewChange = false;
  if (!newTrackedChanges[id]) {
    newTrackedChanges[id] = {};
    isNewChange = true;
  }
  if (insertedMark) newTrackedChanges[id].insertion = id;
  if (deletionMark) newTrackedChanges[id].deletion = deletionMark.attrs?.id;
  if (formatMark) newTrackedChanges[id].format = formatMark.attrs?.id;
  const { step } = trackedChangeMeta;
  let nodes = step?.slice?.content?.content || [];
  if (!nodes.length) {
    newEditorState.doc.descendants((node) => {
      const hasFormatMark = node.marks.find((mark) => mark.type.name === superEditor_converter.TrackFormatMarkName);
      if (hasFormatMark) {
        nodes = [node];
        return false;
      }
    });
  }
  const emitParams = createOrUpdateTrackedChangeComment({
    documentId: editor.options.documentId,
    event: isNewChange ? "add" : "update",
    marks: {
      insertedMark,
      deletionMark,
      formatMark
    },
    deletionNodes,
    nodes,
    newEditorState
  });
  if (emitParams) editor.emit("commentsUpdate", emitParams);
  return newTrackedChanges;
};
const getTrackedChangeText = ({ nodes, mark, trackedChangeType, isDeletionInsertion, marks }) => {
  let trackedChangeText = "";
  let deletionText = "";
  if (trackedChangeType === superEditor_converter.TrackDeleteMarkName || isDeletionInsertion) {
    deletionText = nodes.reduce((acc, node) => {
      const hasDeleteMark = node.marks.find((nodeMark) => nodeMark.type.name === superEditor_converter.TrackDeleteMarkName);
      if (!hasDeleteMark) return acc;
      const nodeText = node?.text || node?.textContent || "";
      acc += nodeText;
      return acc;
    }, "");
  }
  if (trackedChangeType === superEditor_converter.TrackInsertMarkName || isDeletionInsertion) {
    trackedChangeText = nodes.reduce((acc, node) => {
      const hasInsertMark = node.marks.find((nodeMark) => nodeMark.type.name === superEditor_converter.TrackInsertMarkName);
      if (!hasInsertMark) return acc;
      const nodeText = node?.text || node?.textContent || "";
      acc += nodeText;
      return acc;
    }, "");
  }
  if (trackedChangeType === superEditor_converter.TrackFormatMarkName) {
    trackedChangeText = translateFormatChangesToEnglish(mark.attrs);
  }
  return {
    deletionText,
    trackedChangeText
  };
};
const createOrUpdateTrackedChangeComment = ({ event, marks, deletionNodes, nodes, newEditorState, documentId }) => {
  const trackedMark = marks.insertedMark || marks.deletionMark || marks.formatMark;
  const { type, attrs } = trackedMark;
  const { name: trackedChangeType } = type;
  const { author, authorEmail, authorImage, date, importedAuthor } = attrs;
  const id = attrs.id;
  const node = nodes[0];
  const trackedChangesWithId = getTrackChanges(newEditorState, id);
  let isDeletionInsertion = !!(marks.insertedMark && marks.deletionMark);
  if (!isDeletionInsertion) {
    const hasInsertMark = trackedChangesWithId.some(({ mark }) => mark.type.name === superEditor_converter.TrackInsertMarkName);
    const hasDeleteMark = trackedChangesWithId.some(({ mark }) => mark.type.name === superEditor_converter.TrackDeleteMarkName);
    isDeletionInsertion = hasInsertMark && hasDeleteMark;
  }
  let nodesWithMark = [];
  trackedChangesWithId.forEach(({ from: from3, to, mark }) => {
    newEditorState.doc.nodesBetween(from3, to, (node2, pos) => {
      if (node2.isText) {
        const hasMatchingMark = node2.marks?.some((m2) => TRACK_CHANGE_MARKS.includes(m2.type.name) && m2.attrs.id === id);
        if (hasMatchingMark) {
          const alreadyAdded = nodesWithMark.some((n) => n === node2);
          if (!alreadyAdded) {
            nodesWithMark.push(node2);
          }
        }
      }
    });
  });
  let nodesToUse;
  if (isDeletionInsertion) {
    const allNodes = [...nodesWithMark, ...nodes, ...deletionNodes || []];
    nodesToUse = Array.from(new Set(allNodes));
  } else {
    nodesToUse = nodesWithMark.length ? nodesWithMark : node ? [node] : [];
  }
  if (!nodesToUse.length) {
    return;
  }
  const { deletionText, trackedChangeText } = getTrackedChangeText({
    nodes: nodesToUse,
    mark: trackedMark,
    marks,
    trackedChangeType,
    isDeletionInsertion
  });
  if (!deletionText && !trackedChangeText) {
    return;
  }
  const params2 = {
    event: comments_module_events.ADD,
    type: "trackedChange",
    documentId,
    changeId: id,
    trackedChangeType: isDeletionInsertion ? "both" : trackedChangeType,
    trackedChangeText,
    deletedText: marks.deletionMark ? deletionText : null,
    author,
    authorEmail,
    ...authorImage && { authorImage },
    date,
    ...importedAuthor && {
      importedAuthor: {
        name: importedAuthor
      }
    }
  };
  if (event === "add") params2.event = comments_module_events.ADD;
  else if (event === "update") params2.event = comments_module_events.UPDATE;
  return params2;
};
function findRangeById(doc2, id) {
  let from3 = null, to = null;
  doc2.descendants((node, pos) => {
    const trackedMark = node.marks.find((m2) => TRACK_CHANGE_MARKS.includes(m2.type.name) && m2.attrs.id === id);
    if (trackedMark) {
      if (from3 === null || pos < from3) from3 = pos;
      if (to === null || pos + node.nodeSize > to) to = pos + node.nodeSize;
    }
    const commentMark = node.marks.find(
      (m2) => m2.type.name === CommentMarkName && (m2.attrs.commentId === id || m2.attrs.importedId === id)
    );
    if (commentMark) {
      if (from3 === null || pos < from3) from3 = pos;
      if (to === null || pos + node.nodeSize > to) to = pos + node.nodeSize;
    }
    if (node.type.name === "commentRangeStart" && node.attrs["w:id"] === id) {
      from3 = pos;
    }
    if (node.type.name === "commentRangeEnd" && node.attrs["w:id"] === id) {
      to = pos;
    }
  });
  return from3 !== null && to !== null ? { from: from3, to } : null;
}
const replaceStep = ({ state, tr, step, newTr, map: map3, user, date, originalStep, originalStepIndex }) => {
  const trTemp = state.apply(newTr).tr;
  let positionTo = step.to;
  let positionAdjusted = false;
  const isSingleStep = tr.steps.length === 1;
  if (isSingleStep) {
    const probePos = Math.max(step.from, step.to - 1);
    const deletionSpan = findMarkPosition(trTemp.doc, probePos, superEditor_converter.TrackDeleteMarkName);
    if (deletionSpan && deletionSpan.to > positionTo) {
      positionTo = deletionSpan.to;
      positionAdjusted = true;
    }
  }
  const tryInsert = (slice2) => {
    const insertionStep = new superEditor_converter.ReplaceStep(positionTo, positionTo, slice2, false);
    if (trTemp.maybeStep(insertionStep).failed) return null;
    return {
      insertedFrom: insertionStep.from,
      insertedTo: insertionStep.getMap().map(insertionStep.to, 1)
    };
  };
  const insertion = tryInsert(step.slice) || tryInsert(superEditor_converter.Slice.maxOpen(step.slice.content, true));
  if (!insertion) {
    if (!newTr.maybeStep(step).failed) {
      map3.appendMap(step.getMap());
    }
    return;
  }
  const meta = {};
  const insertedMark = markInsertion({
    tr: trTemp,
    from: insertion.insertedFrom,
    to: insertion.insertedTo,
    user,
    date
  });
  const trackedInsertedSlice = trTemp.doc.slice(insertion.insertedFrom, insertion.insertedTo);
  const condensedStep = new superEditor_converter.ReplaceStep(positionTo, positionTo, trackedInsertedSlice, false);
  if (newTr.maybeStep(condensedStep).failed) {
    if (!newTr.maybeStep(step).failed) {
      map3.appendMap(step.getMap());
    }
    return;
  }
  const invertStep = originalStep.invert(tr.docs[originalStepIndex]).map(map3);
  map3.appendMap(invertStep.getMap());
  const mirrorIndex = map3.maps.length - 1;
  map3.appendMap(condensedStep.getMap(), mirrorIndex);
  if (insertion.insertedFrom !== insertion.insertedTo) {
    meta.insertedMark = insertedMark;
    meta.step = condensedStep;
    if (positionAdjusted) {
      const insertionLength = insertion.insertedTo - insertion.insertedFrom;
      meta.insertedTo = positionTo + insertionLength;
    }
  }
  if (!newTr.selection.eq(trTemp.selection)) {
    newTr.setSelection(trTemp.selection);
  }
  if (step.from !== step.to) {
    const {
      deletionMark,
      deletionMap,
      nodes: deletionNodes
    } = markDeletion({
      tr: newTr,
      from: step.from,
      to: step.to,
      user,
      date,
      id: meta.insertedMark?.attrs?.id
    });
    meta.deletionNodes = deletionNodes;
    meta.deletionMark = deletionMark;
    if (meta.insertedTo !== void 0) {
      meta.insertedTo = deletionMap.map(meta.insertedTo, 1);
    }
    map3.appendMapping(deletionMap);
  }
  newTr.setMeta(TrackChangesBasePluginKey, meta);
  newTr.setMeta(CommentsPluginKey, { type: "force" });
};
const addMarkStep = ({ state, step, newTr, doc: doc2, user, date }) => {
  const meta = {};
  doc2.nodesBetween(step.from, step.to, (node, pos) => {
    if (!node.isInline) {
      return;
    }
    if (node.marks.find((mark) => mark.type.name === superEditor_converter.TrackDeleteMarkName)) {
      return false;
    }
    const existingChangeMark = node.marks.find(
      (mark) => [superEditor_converter.TrackDeleteMarkName, superEditor_converter.TrackFormatMarkName].includes(mark.type.name)
    );
    const wid = existingChangeMark ? existingChangeMark.attrs.id : uuid.v4();
    newTr.addMark(Math.max(step.from, pos), Math.min(step.to, pos + node.nodeSize), step.mark);
    const allowedMarks = ["bold", "italic", "strike", "underline", "textStyle"];
    if (allowedMarks.includes(step.mark.type.name) && !node.marks.find((mark) => mark.type === step.mark.type)) {
      const formatChangeMark = node.marks.find((mark) => mark.type.name === superEditor_converter.TrackFormatMarkName);
      let after = [];
      let before = [];
      if (formatChangeMark) {
        let foundBefore = formatChangeMark.attrs.before.find((mark) => {
          if (mark.type === "textStyle") {
            return mark.type === step.mark.type.name && superEditor_converter.objectIncludes(mark.attrs, step.mark.attrs);
          }
          return mark.type === step.mark.type.name;
        });
        if (foundBefore) {
          before = [...formatChangeMark.attrs.before.filter((mark) => mark.type !== step.mark.type.name)];
          after = [...formatChangeMark.attrs.after];
        } else {
          before = [...formatChangeMark.attrs.before];
          after = [
            ...formatChangeMark.attrs.after,
            {
              type: step.mark.type.name,
              attrs: { ...step.mark.attrs }
            }
          ];
        }
      } else {
        before = node.marks.map((mark) => ({
          type: mark.type.name,
          attrs: { ...mark.attrs }
        }));
        after = [
          {
            type: step.mark.type.name,
            attrs: { ...step.mark.attrs }
          }
        ];
      }
      if (after.length || before.length) {
        const newFormatMark = state.schema.marks[superEditor_converter.TrackFormatMarkName].create({
          id: wid,
          author: user.name,
          authorEmail: user.email,
          authorImage: user.image,
          date,
          before,
          after
        });
        newTr.addMark(
          step.from,
          // Math.max(step.from, pos)
          step.to,
          // Math.min(step.to, pos + node.nodeSize),
          newFormatMark
        );
        meta.formatMark = newFormatMark;
        meta.step = step;
        newTr.setMeta(TrackChangesBasePluginKey, meta);
        newTr.setMeta(CommentsPluginKey, { type: "force" });
      } else if (formatChangeMark) {
        newTr.removeMark(Math.max(step.from, pos), Math.min(step.to, pos + node.nodeSize), formatChangeMark);
      }
    }
  });
};
const removeMarkStep = ({ state, step, newTr, doc: doc2, user, date }) => {
  const meta = {};
  doc2.nodesBetween(step.from, step.to, (node, pos) => {
    if (!node.isInline) {
      return true;
    }
    if (node.marks.find((mark) => mark.type.name === superEditor_converter.TrackDeleteMarkName)) {
      return false;
    }
    newTr.removeMark(Math.max(step.from, pos), Math.min(step.to, pos + node.nodeSize), step.mark);
    const allowedMarks = ["bold", "italic", "strike", "underline", "textStyle"];
    if (allowedMarks.includes(step.mark.type.name) && node.marks.find((mark) => mark.type === step.mark.type)) {
      const formatChangeMark = node.marks.find((mark) => mark.type.name === superEditor_converter.TrackFormatMarkName);
      let after = [];
      let before = [];
      if (formatChangeMark) {
        let foundAfter = formatChangeMark.attrs.after.find((mark) => mark.type === step.mark.type.name);
        if (foundAfter) {
          after = [...formatChangeMark.attrs.after.filter((mark) => mark.type !== step.mark.type.name)];
          before = [...formatChangeMark.attrs.before];
        } else {
          after = [...formatChangeMark.attrs.after];
          before = [
            ...formatChangeMark.attrs.before,
            {
              type: step.mark.type.name,
              attrs: { ...step.mark.attrs }
            }
          ];
        }
      } else {
        after = [];
        before = [
          {
            type: step.mark.type.name,
            attrs: { ...step.mark.attrs }
          }
        ];
      }
      if (after.length || before.length) {
        const newFormatMark = state.schema.marks[superEditor_converter.TrackFormatMarkName].create({
          id: uuid.v4(),
          author: user.name,
          authorEmail: user.email,
          authorImage: user.image,
          date,
          before,
          after
        });
        newTr.addMark(Math.max(step.from, pos), Math.min(step.to, pos + node.nodeSize), newFormatMark);
        meta.formatMark = newFormatMark;
        meta.step = step;
        newTr.setMeta(TrackChangesBasePluginKey, meta);
        newTr.setMeta(CommentsPluginKey, { type: "force" });
      } else if (formatChangeMark) {
        newTr.removeMark(Math.max(step.from, pos), Math.min(step.to, pos + node.nodeSize), formatChangeMark);
      }
    }
  });
};
const trackedTransaction = ({ tr, state, user }) => {
  const onlyInputTypeMeta = ["inputType", "uiEvent", "paste", "pointer"];
  const notAllowedMeta = ["historyUndo", "historyRedo", "acceptReject"];
  const isProgrammaticInput = tr.getMeta("inputType") === "programmatic";
  const ySyncMeta = tr.getMeta(ySyncPluginKey);
  const allowedMeta = /* @__PURE__ */ new Set([...onlyInputTypeMeta, ySyncPluginKey.key]);
  const hasDisallowedMeta = tr.meta && Object.keys(tr.meta).some((meta) => !allowedMeta.has(meta));
  if (ySyncMeta?.isChangeOrigin || // Skip Yjs-origin transactions (remote/rehydration).
  !tr.steps.length || hasDisallowedMeta && !isProgrammaticInput || notAllowedMeta.includes(tr.getMeta("inputType")) || tr.getMeta(CommentsPluginKey)) {
    return tr;
  }
  const newTr = state.tr;
  const map3 = new superEditor_converter.Mapping();
  const fixedTimeTo10Mins = Math.floor(Date.now() / 6e5) * 6e5;
  const date = new Date(fixedTimeTo10Mins).toISOString();
  tr.steps.forEach((originalStep, originalStepIndex) => {
    const step = originalStep.map(map3);
    const { doc: doc2 } = newTr;
    if (!step) {
      return;
    }
    if (step instanceof superEditor_converter.ReplaceStep) {
      replaceStep({
        state,
        tr,
        step,
        newTr,
        map: map3,
        user,
        date,
        originalStep,
        originalStepIndex
      });
    } else if (step instanceof superEditor_converter.AddMarkStep) {
      addMarkStep({
        state,
        step,
        newTr,
        doc: doc2,
        user,
        date
      });
    } else if (step instanceof superEditor_converter.RemoveMarkStep) {
      removeMarkStep({
        state,
        step,
        newTr,
        doc: doc2,
        user,
        date
      });
    } else {
      newTr.step(step);
    }
  });
  if (tr.getMeta("inputType")) {
    newTr.setMeta("inputType", tr.getMeta("inputType"));
  }
  if (tr.getMeta("uiEvent")) {
    newTr.setMeta("uiEvent", tr.getMeta("uiEvent"));
  }
  if (tr.getMeta("addToHistory") !== void 0) {
    newTr.setMeta("addToHistory", tr.getMeta("addToHistory"));
  }
  const trackMeta = newTr.getMeta(TrackChangesBasePluginKey);
  if (tr.selectionSet) {
    const deletionMarkSchema = state.schema.marks[superEditor_converter.TrackDeleteMarkName];
    const deletionMark = findMark(state, deletionMarkSchema, false);
    if (tr.selection instanceof superEditor_converter.TextSelection && (tr.selection.from < state.selection.from || tr.getMeta("inputType") === "deleteContentBackward")) {
      const caretPos = map3.map(tr.selection.from, -1);
      newTr.setSelection(new superEditor_converter.TextSelection(newTr.doc.resolve(caretPos)));
    } else if (trackMeta?.insertedTo !== void 0) {
      newTr.setSelection(new superEditor_converter.TextSelection(newTr.doc.resolve(trackMeta.insertedTo)));
    } else if (tr.selection.from > state.selection.from && deletionMark) {
      const caretPos = map3.map(deletionMark.to + 1, 1);
      newTr.setSelection(new superEditor_converter.TextSelection(newTr.doc.resolve(caretPos)));
    } else {
      newTr.setSelection(tr.selection.map(newTr.doc, map3));
    }
  } else if (state.selection.from - tr.selection.from > 1 && tr.selection.$head.depth > 1) {
    const caretPos = map3.map(tr.selection.from - 2, -1);
    newTr.setSelection(new superEditor_converter.TextSelection(newTr.doc.resolve(caretPos)));
  } else ;
  if (tr.storedMarksSet) {
    newTr.setStoredMarks(tr.storedMarks);
  }
  if (tr.scrolledIntoView) {
    newTr.scrollIntoView();
  }
  return newTr;
};
const migration_after_0_4_14 = (editor) => {
  const { state } = editor;
  const dispatch = typeof editor.view?.dispatch === "function" ? editor.view.dispatch.bind(editor.view) : editor.dispatch.bind(editor);
  const { tr } = state;
  if (!dispatch) return;
  state.doc.descendants((node, pos) => {
    if (node.type.name === "paragraph") {
      const { attrs } = node;
      const { spacing } = attrs;
      if (!spacing) return;
      const newSpacing = {
        line: helpers$1.twipsToLines(helpers$1.pixelsToTwips(spacing.line)),
        lineSpaceBefore: helpers$1.twipsToLines(helpers$1.pixelsToTwips(spacing.lineSpaceBefore)),
        lineSpaceAfter: helpers$1.twipsToLines(helpers$1.pixelsToTwips(spacing.lineSpaceAfter))
      };
      tr.setNodeMarkup(pos, void 0, {
        ...attrs,
        spacing: {
          ...spacing,
          ...newSpacing
        }
      });
    }
  });
  dispatch(tr);
  return true;
};
const DOCUMENT_MIGRATIONS = {
  initial: migration_after_0_4_14
};
const getNecessaryMigrations = (version2) => {
  if (version2 === "initial" || version2 === "0.4.14") return Object.values(DOCUMENT_MIGRATIONS);
};
const getFieldAttrs = (field, value, input) => {
  const { type } = field.attrs;
  const annotatorHandlers = {
    html: annotateHtml,
    text: annotateText,
    checkbox: annotateCheckbox,
    image: annotateImage,
    link: annotateLink,
    yesno: annotateYesNo,
    date: annotateDate
  };
  const handler = annotatorHandlers[type];
  if (!handler) return {};
  return handler(value, input);
};
const annotateHtml = (value) => ({ rawHtml: value });
const annotateText = (value) => ({ displayLabel: value });
const annotateImage = (value) => ({ imageSrc: value });
const annotateCheckbox = (value) => ({ displayLabel: value });
const annotateDate = (value, input) => {
  const formatted = getFormattedDate(value, input.input_format);
  return { displayLabel: formatted };
};
const annotateLink = (value) => {
  if (!value.startsWith("http")) value = `http://${value}`;
  return { linkUrl: value };
};
const annotateYesNo = (value) => {
  const yesNoValues = {
    YES: "Yes",
    NO: "No"
  };
  const parsedValue = yesNoValues[value[0].toUpperCase()];
  return { displayLabel: parsedValue };
};
const processTables = ({ state, tr, annotationValues }) => {
  const { doc: doc2 } = state;
  const tables = [];
  doc2.descendants((node, pos) => {
    if (node.type.name === "table") tables.push({ node, pos });
  });
  tables.reverse().forEach(({ pos }) => {
    const currentTableNode = tr.doc.nodeAt(pos);
    if (!currentTableNode || currentTableNode.type.name !== "table") return;
    try {
      generateTableIfNecessary({ tableNode: { node: currentTableNode, pos }, annotationValues, tr, state });
    } catch (error) {
      console.error("Error generating table at pos", pos, ":", error);
    }
  });
  return tr;
};
const generateTableIfNecessary = ({ tableNode, annotationValues, tr, state }) => {
  const {
    tableRow: RowType,
    tableCell: CellType,
    fieldAnnotation: FieldType,
    paragraph: ParaType
  } = state.schema.nodes;
  const rows = [];
  tableNode.node.descendants((node, pos) => {
    if (node.type === RowType) {
      rows.push({ node, pos });
    }
  });
  let rowNodeToGenerate = null;
  for (const row of rows) {
    let hasArrayAnnotation = false;
    row.node.descendants((node) => {
      if (node.type === FieldType) {
        const annotationValue = getAnnotationValue(node.attrs.fieldId, annotationValues);
        if (Array.isArray(annotationValue) && node.attrs.generatorIndex === null) {
          hasArrayAnnotation = true;
        }
      }
    });
    if (hasArrayAnnotation) {
      rowNodeToGenerate = row;
      break;
    }
  }
  if (!rowNodeToGenerate) return;
  const { node: rowNode, pos: rowStartPos } = rowNodeToGenerate;
  const absoluteRowStart = tableNode.pos + 1 + rowStartPos;
  let rowsToGenerate = 0;
  rowNode.descendants((childNode) => {
    if (childNode.type === FieldType) {
      const annotationValue = getAnnotationValue(childNode.attrs.fieldId, annotationValues);
      if (Array.isArray(annotationValue)) {
        rowsToGenerate = Math.max(rowsToGenerate, annotationValue.length);
      }
    }
  });
  if (rowsToGenerate <= 1) return;
  const validateAttributes = (attrs) => {
    const cleaned = {};
    for (const [key2, value] of Object.entries(attrs)) {
      if (value !== void 0 && value !== null) {
        if (key2 === "displayLabel") {
          cleaned[key2] = String(value);
        } else if (key2 === "rawHtml" || key2 === "linkUrl" || key2 === "imageSrc") {
          cleaned[key2] = String(value);
        } else if (typeof value === "string" && value.length > 0) {
          cleaned[key2] = value;
        } else if (typeof value !== "string") {
          cleaned[key2] = value;
        }
      }
    }
    return cleaned;
  };
  const rebuildCell = (cellNode, rowIndex) => {
    try {
      const updatedBlocks = cellNode.content.content.map((blockNode) => {
        if (blockNode.type !== ParaType) return blockNode;
        const updatedInlines = blockNode.content.content.map((inlineNode) => {
          if (inlineNode.type !== FieldType) return inlineNode;
          let matchedAnnotationValues = getAnnotationValue(inlineNode.attrs.fieldId, annotationValues);
          if (!Array.isArray(matchedAnnotationValues)) {
            matchedAnnotationValues = [matchedAnnotationValues];
          }
          const value = matchedAnnotationValues[rowIndex];
          let extraAttrs = {};
          try {
            const rawExtraAttrs = getFieldAttrs(inlineNode, value, null);
            extraAttrs = validateAttributes(rawExtraAttrs || {});
          } catch (error) {
            console.error("Error getting field attrs:", error);
            extraAttrs = {};
          }
          const baseAttrs = validateAttributes(inlineNode.attrs || {});
          const newAttrs = {
            ...baseAttrs,
            ...extraAttrs,
            generatorIndex: rowIndex
          };
          try {
            return FieldType.create(newAttrs, inlineNode.content || superEditor_converter.Fragment.empty, inlineNode.marks || []);
          } catch (error) {
            console.error("Error creating field node:", error);
            try {
              const fallbackAttrs = {
                ...baseAttrs,
                generatorIndex: rowIndex,
                displayLabel: String(value || "")
              };
              return FieldType.create(
                validateAttributes(fallbackAttrs),
                inlineNode.content || superEditor_converter.Fragment.empty,
                inlineNode.marks || []
              );
            } catch (fallbackError) {
              console.error("Fallback also failed:", fallbackError);
              return inlineNode;
            }
          }
        });
        try {
          return ParaType.create(
            validateAttributes(blockNode.attrs || {}),
            superEditor_converter.Fragment.from(updatedInlines),
            blockNode.marks || []
          );
        } catch (error) {
          console.error("Error creating paragraph node:", error);
          return blockNode;
        }
      });
      return CellType.create(
        validateAttributes(cellNode.attrs || {}),
        superEditor_converter.Fragment.from(updatedBlocks),
        cellNode.marks || []
      );
    } catch (error) {
      console.error(`Failed to rebuild cell for row ${rowIndex}:`, error);
      throw error;
    }
  };
  try {
    const newRows = [];
    for (let rowIndex = 0; rowIndex < rowsToGenerate; rowIndex++) {
      const newCells = rowNode.content.content.map((cellNode) => rebuildCell(cellNode, rowIndex));
      const newRow = RowType.create(
        validateAttributes(rowNode.attrs || {}),
        superEditor_converter.Fragment.from(newCells),
        rowNode.marks || []
      );
      newRows.push(newRow);
    }
    const mappedRowStart = tr.mapping.map(absoluteRowStart);
    const rowEnd = mappedRowStart + rowNode.nodeSize;
    tr.replaceWith(mappedRowStart, rowEnd, superEditor_converter.Fragment.from(newRows));
    tr.setMeta("tableGeneration", true);
  } catch (error) {
    console.error("Error during row generation:", error);
    throw error;
  }
};
const getAnnotationValue = (id, annotationValues) => {
  return annotationValues.find((value) => value.input_id === id)?.input_value || null;
};
const getAllHeaderFooterEditors = () => [];
const annotateHeadersAndFooters = () => {
};
const annotateDocument = ({
  annotationValues = [],
  hiddenFieldIds = [],
  removeEmptyFields = false,
  schema,
  tr
}) => {
  const annotations = [];
  const FieldType = schema.nodes.fieldAnnotation;
  tr.doc.descendants((node, pos) => {
    if (node.type === FieldType) {
      annotations.push({ node, pos, size: node.nodeSize });
    }
  });
  const toDelete = /* @__PURE__ */ new Set();
  if (hiddenFieldIds.length) {
    for (const { node, pos } of annotations) {
      if (hiddenFieldIds.includes(node.attrs.fieldId)) {
        toDelete.add(pos);
      }
    }
  }
  for (const { node, pos } of annotations) {
    const { type, fieldType, fieldId } = node.attrs;
    if (toDelete.has(pos)) continue;
    let newValue = null;
    const input = annotationValues.find((i) => i.input_id === fieldId);
    if (!input) {
      const checkboxInputs = annotationValues.filter((i) => i.input_field_type === "CHECKBOXINPUT");
      inputsLoop: for (const cb of checkboxInputs) {
        for (const opt of cb.input_options) {
          if (opt.itemid === fieldId) {
            newValue = cb.input_link_value[opt.itemid] || " ";
            break inputsLoop;
          }
        }
      }
    }
    newValue = newValue || input?.input_value || null;
    if (Array.isArray(newValue) && node.attrs.generatorIndex != null) {
      continue;
    }
    if (type === "checkbox" || fieldType === "CHECKBOXINPUT") {
      const isEmptyOrSquare = !newValue || typeof newValue === "string" && newValue.codePointAt(0) === 9744;
      if (isEmptyOrSquare) newValue = " ";
    }
    if (!newValue) {
      toDelete.add(pos);
    } else {
      const attrs = getFieldAttrs(node, newValue, input);
      tr = tr.setNodeMarkup(pos, void 0, {
        ...node.attrs,
        ...attrs
      });
    }
  }
  if (removeEmptyFields) {
    Array.from(toDelete).sort((a, b2) => b2 - a).forEach((pos) => {
      const ann = annotations.find((a) => a.pos === pos);
      if (!ann) return;
      tr = tr.delete(pos, pos + ann.node.nodeSize);
    });
  }
  return tr;
};
const getFormattedDate = (input = null, format = "") => {
  const date = input ? new Date(input) : /* @__PURE__ */ new Date();
  if (isNaN(date.getTime())) {
    return input;
  }
  if (format) return dateFormat(date, format);
  return date.toLocaleDateString("en-US", {
    month: "short",
    // e.g. May
    day: "2-digit",
    // e.g. 05
    year: "numeric"
    // e.g. 2025
  });
};
const AnnotatorHelpers = {
  getFieldAttrs,
  processTables,
  annotateDocument,
  annotateHeadersAndFooters,
  getAllHeaderFooterEditors
};
const updateYdocDocxData = async (editor, ydoc) => {
  try {
    ydoc = ydoc || editor?.options?.ydoc;
    if (!ydoc) return;
    if (!editor || editor.isDestroyed) return;
    const metaMap = ydoc.getMap("meta");
    const docxValue = metaMap.get("docx");
    let docx = [];
    if (Array.isArray(docxValue)) {
      docx = [...docxValue];
    } else if (docxValue && typeof docxValue.toArray === "function") {
      docx = docxValue.toArray();
    } else if (docxValue && typeof docxValue[Symbol.iterator] === "function") {
      docx = Array.from(docxValue);
    }
    if (!docx.length && Array.isArray(editor.options.content)) {
      docx = [...editor.options.content];
    }
    const newXml = await editor.exportDocx({ getUpdatedDocs: true });
    if (!newXml || typeof newXml !== "object") return;
    let hasChanges = false;
    Object.keys(newXml).forEach((key2) => {
      const fileIndex = docx.findIndex((item) => item.name === key2);
      const existingContent = fileIndex > -1 ? docx[fileIndex].content : null;
      if (existingContent === newXml[key2]) {
        return;
      }
      hasChanges = true;
      if (fileIndex > -1) {
        docx.splice(fileIndex, 1);
      }
      docx.push({
        name: key2,
        content: newXml[key2]
      });
    });
    if (hasChanges || !docxValue) {
      ydoc.transact(
        () => {
          metaMap.set("docx", docx);
        },
        { event: "docx-update", user: editor.options.user }
      );
    }
  } catch (error) {
    console.warn("[collaboration] Failed to update Ydoc docx data", error);
  }
};
let isApplyingRemoteChanges = false;
const isApplyingRemoteHeaderFooterChanges = () => isApplyingRemoteChanges;
const pushHeaderFooterToYjs = (editor, type, sectionId, content) => {
  if (isApplyingRemoteChanges) return;
  const ydoc = editor?.options?.ydoc;
  if (!ydoc) return;
  const headerFooterMap = ydoc.getMap("headerFooterJson");
  const key2 = `${type}:${sectionId}`;
  const existing = headerFooterMap.get(key2)?.content;
  if (existing && JSON.stringify(existing) === JSON.stringify(content)) {
    return;
  }
  ydoc.transact(() => headerFooterMap.set(key2, { type, sectionId, content }), {
    event: "header-footer-update",
    user: editor.options.user
  });
};
const applyRemoteHeaderFooterChanges = (editor, key2, data) => {
  if (!editor || editor.isDestroyed || !editor.converter) return;
  const { type, sectionId, content } = data;
  if (!type || !sectionId || !content) return;
  isApplyingRemoteChanges = true;
  try {
    const storage = editor.converter[`${type}s`];
    if (storage) storage[sectionId] = content;
    editor.converter.headerFooterModified = true;
    const editors = editor.converter[`${type}Editors`];
    editors?.forEach((item) => {
      if (item.id === sectionId && item.editor) {
        item.editor.replaceContent(content);
      }
    });
    editor.emit("remoteHeaderFooterChanged", { type, sectionId, content });
  } finally {
    setTimeout(() => {
      isApplyingRemoteChanges = false;
    }, 0);
  }
};
new superEditor_converter.PluginKey("collaboration");
const Collaboration = Extension.create({
  name: "collaboration",
  priority: 1e3,
  addOptions() {
    return {
      ydoc: null,
      field: "supereditor",
      fragment: null,
      isReady: false
    };
  },
  addPmPlugins() {
    if (!this.editor.options.ydoc) return [];
    this.options.ydoc = this.editor.options.ydoc;
    initSyncListener(this.options.ydoc, this.editor, this);
    initDocumentListener({ ydoc: this.options.ydoc, editor: this.editor });
    const [syncPlugin, fragment] = createSyncPlugin(this.options.ydoc, this.editor);
    this.options.fragment = fragment;
    const metaMap = this.options.ydoc.getMap("media");
    metaMap.observe((event) => {
      event.changes.keys.forEach((_2, key2) => {
        if (!(key2 in this.editor.storage.image.media)) {
          const fileData = metaMap.get(key2);
          this.editor.storage.image.media[key2] = fileData;
        }
      });
    });
    const headerFooterMap = this.options.ydoc.getMap("headerFooterJson");
    headerFooterMap.observe((event) => {
      if (event.transaction.local) return;
      event.changes.keys.forEach((change, key2) => {
        if (change.action === "add" || change.action === "update") {
          const data = headerFooterMap.get(key2);
          if (data) {
            applyRemoteHeaderFooterChanges(this.editor, key2, data);
          }
        }
      });
    });
    return [syncPlugin];
  },
  addCommands() {
    return {
      addImageToCollaboration: ({ mediaPath, fileData }) => () => {
        if (!this.options.ydoc || !mediaPath || !fileData) return false;
        const mediaMap = this.options.ydoc.getMap("media");
        mediaMap.set(mediaPath, fileData);
        return true;
      }
    };
  }
});
const createSyncPlugin = (ydoc, editor) => {
  const fragment = ydoc.getXmlFragment("supereditor");
  const onFirstRender = () => {
    if (!editor.options.isNewFile) return;
    initializeMetaMap(ydoc, editor);
  };
  return [ySyncPlugin(fragment, { onFirstRender }), fragment];
};
const initializeMetaMap = (ydoc, editor) => {
  const metaMap = ydoc.getMap("meta");
  metaMap.set("docx", editor.options.content);
  metaMap.set("fonts", editor.options.fonts);
  const mediaMap = ydoc.getMap("media");
  Object.entries(editor.options.mediaFiles).forEach(([key2, value]) => {
    mediaMap.set(key2, value);
  });
};
const checkDocxChanged = (transaction) => {
  if (!transaction.changed) return false;
  for (const [, value] of transaction.changed.entries()) {
    if (value instanceof Set && value.has("docx")) {
      return true;
    }
  }
  return false;
};
const initDocumentListener = ({ ydoc, editor }) => {
  const debouncedUpdate = debounce$2((editor2) => {
    updateYdocDocxData(editor2);
  }, 1e3);
  ydoc.on("afterTransaction", (transaction) => {
    const { local } = transaction;
    const hasChangedDocx = checkDocxChanged(transaction);
    if (!hasChangedDocx && transaction.changed?.size && local) {
      debouncedUpdate(editor);
    }
  });
};
const debounce$2 = (fn2, wait) => {
  let timeout2 = null;
  return (...args) => {
    clearTimeout(timeout2);
    timeout2 = setTimeout(() => fn2.apply(void 0, args), wait);
  };
};
const initSyncListener = (ydoc, editor, extension) => {
  const provider = editor.options.collaborationProvider;
  if (!provider) return;
  const emit = () => {
    extension.options.isReady = true;
    provider.off("synced", emit);
    editor.emit("collaborationReady", { editor, ydoc });
  };
  if (provider.synced) {
    setTimeout(() => {
      emit();
    }, 250);
    return;
  }
  provider.on("synced", emit);
};
const generateCollaborationData = async (editor) => {
  const ydoc = prosemirrorToYDoc(editor.state.doc, "supereditor");
  initializeMetaMap(ydoc, editor);
  await updateYdocDocxData(editor, ydoc);
  return Y$1.encodeStateAsUpdate(ydoc);
};
const isHighContrastMode = vue.ref(false);
function useHighContrastMode() {
  const setHighContrastMode = (value) => {
    isHighContrastMode.value = value;
  };
  return {
    isHighContrastMode,
    setHighContrastMode
  };
}
const setImageNodeSelection = (view, pos) => {
  const { doc: doc2 } = view.state;
  const node = doc2.nodeAt(pos);
  if (node && node.type.name === "image") {
    const tr = view.state.tr.setSelection(superEditor_converter.NodeSelection.create(doc2, pos));
    view.dispatch(tr);
    return true;
  }
  return false;
};
function canRenderFont(fontName, uiDisplayFallbackFont = "sans-serif") {
  const _canRenderFont = (fontName2, uiDisplayFallbackFont2) => {
    const canvas2 = document.createElement("canvas");
    const ctx2 = canvas2.getContext("2d");
    ctx2.textBaseline = "top";
    const text = "abcdefghijklmnopqrstuvwxyz0123456789";
    ctx2.font = `72px ${uiDisplayFallbackFont2}`;
    const initialTextMeasurement = ctx2.measureText(text);
    const fallbackWidth = initialTextMeasurement.width;
    const fallbackHeight = initialTextMeasurement.actualBoundingBoxDescent;
    ctx2.font = `72px "${fontName2}", ${uiDisplayFallbackFont2}`;
    const customTextMeasurement = ctx2.measureText(text);
    const customFontWidth = customTextMeasurement.width;
    const customFontHeight = customTextMeasurement.actualBoundingBoxDescent;
    const isAvailable = customFontWidth !== fallbackWidth || customFontHeight !== fallbackHeight;
    return isAvailable;
  };
  if (_canRenderFont(fontName, uiDisplayFallbackFont)) {
    return true;
  }
  const oppositeUiDisplayFallbackFont = uiDisplayFallbackFont === "sans-serif" ? "serif" : "sans-serif";
  return _canRenderFont(fontName, oppositeUiDisplayFallbackFont);
}
const { findChildren: findChildren$3 } = helpers;
function getAllFieldAnnotations(state) {
  let fieldAnnotations = findChildren$3(state.doc, (node) => node.type.name === "fieldAnnotation");
  return fieldAnnotations;
}
function getAllFieldAnnotationsWithRect(view, state) {
  let fieldAnnotations = getAllFieldAnnotations(state).map(({ node, pos }) => {
    let rect = posToDOMRect(view, pos, pos + node.nodeSize);
    return {
      node,
      pos,
      rect
    };
  });
  return fieldAnnotations;
}
function findFieldAnnotations(predicate, state) {
  let allFieldAnnotations = getAllFieldAnnotations(state);
  let fieldAnnotations = [];
  allFieldAnnotations.forEach((annotation) => {
    if (predicate(annotation.node)) {
      fieldAnnotations.push(annotation);
    }
  });
  return fieldAnnotations;
}
const { findChildren: findChildren$2 } = helpers;
function findFieldAnnotationsByFieldId(fieldIdOrArray, state) {
  let fieldAnnotations = findChildren$2(state.doc, (node) => {
    let isFieldAnnotation = node.type.name === "fieldAnnotation";
    if (Array.isArray(fieldIdOrArray)) {
      return isFieldAnnotation && fieldIdOrArray.includes(node.attrs.fieldId);
    } else {
      return isFieldAnnotation && node.attrs.fieldId === fieldIdOrArray;
    }
  });
  return fieldAnnotations;
}
function findFirstFieldAnnotationByFieldId(fieldId, state) {
  let fieldAnnotation = findNode(state.doc, (node) => {
    return node.type.name === "fieldAnnotation" && node.attrs.fieldId === fieldId;
  });
  return fieldAnnotation;
}
function findNode(node, predicate) {
  let found = null;
  node.descendants((node2, pos) => {
    if (predicate(node2)) found = { node: node2, pos };
    if (found) return false;
  });
  return found;
}
function findFieldAnnotationsBetween(from3, to, doc2) {
  let fieldAnnotations = [];
  doc2.nodesBetween(from3, to, (node, pos) => {
    if (!node || node?.nodeSize === void 0) {
      return;
    }
    if (node.type.name === "fieldAnnotation") {
      fieldAnnotations.push({
        node,
        pos
      });
    }
  });
  return fieldAnnotations;
}
function findRemovedFieldAnnotations(tr) {
  let removedNodes = [];
  if (!tr.steps.length || tr.meta && !Object.keys(tr.meta).every((meta) => ["inputType", "uiEvent", "paste"].includes(meta)) || ["historyUndo", "historyRedo"].includes(tr.getMeta("inputType")) || ["drop"].includes(tr.getMeta("uiEvent")) || tr.getMeta("fieldAnnotationUpdate") === true || tr.getMeta("tableGeneration") === true) {
    return removedNodes;
  }
  const hasDeletion = transactionDeletedAnything(tr);
  if (!hasDeletion) return removedNodes;
  tr.steps.forEach((step, stepIndex) => {
    if (step instanceof superEditor_converter.ReplaceStep && step.from !== step.to) {
      let mapping = tr.mapping.maps[stepIndex];
      let originalDoc = tr.before;
      originalDoc.nodesBetween(step.from, step.to, (node, pos) => {
        if (node.type.name === "fieldAnnotation") {
          let mappedPos = mapping.mapResult(pos);
          if (mappedPos.deleted) {
            removedNodes.push({ node, pos });
          }
        }
      });
    }
  });
  return removedNodes;
}
function transactionDeletedAnything(tr) {
  return tr.steps.some((step) => {
    if (step instanceof superEditor_converter.ReplaceStep || step instanceof ReplaceAroundStep) {
      return step.from !== step.to;
    }
    return false;
  });
}
function trackFieldAnnotationsDeletion(editor, tr) {
  let removedAnnotations = [];
  try {
    removedAnnotations = findRemovedFieldAnnotations(tr);
  } catch {
  }
  if (removedAnnotations.length > 0) {
    setTimeout(() => {
      editor.emit("fieldAnnotationDeleted", {
        editor,
        removedNodes: removedAnnotations
      });
    }, 0);
  }
}
const getHeaderFooterAnnotations = (editor) => {
  const editors = getAllHeaderFooterEditors();
  const allAnnotations = [];
  editors.forEach(({ editor: editor2 }) => {
    const annotations = getAllFieldAnnotations(editor2.state);
    allAnnotations.push(...annotations);
  });
  return allAnnotations;
};
const { findChildren: findChildren$1 } = helpers;
function findHeaderFooterAnnotationsByFieldId(fieldIdOrArray, editor, activeSectionEditor) {
  const sectionEditors = getAllHeaderFooterEditors();
  const annotations = [];
  sectionEditors.forEach(({ editor: sectionEditor }) => {
    const state = activeSectionEditor.options.documentId === sectionEditor.options.documentId ? activeSectionEditor.state : sectionEditor.state;
    const fieldAnnotations = findChildren$1(state.doc, (node) => {
      let isFieldAnnotation = node.type.name === "fieldAnnotation";
      if (Array.isArray(fieldIdOrArray)) {
        return isFieldAnnotation && fieldIdOrArray.includes(node.attrs.fieldId);
      } else {
        return isFieldAnnotation && node.attrs.fieldId === fieldIdOrArray;
      }
    });
    annotations.push(...fieldAnnotations);
  });
  return annotations;
}
const index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  findFieldAnnotations,
  findFieldAnnotationsBetween,
  findFieldAnnotationsByFieldId,
  findFirstFieldAnnotationByFieldId,
  findHeaderFooterAnnotationsByFieldId,
  findRemovedFieldAnnotations,
  getAllFieldAnnotations,
  getAllFieldAnnotationsWithRect,
  getHeaderFooterAnnotations,
  trackFieldAnnotationsDeletion
}, Symbol.toStringTag, { value: "Module" }));
const migrateListsToV2IfNecessary = (editor) => {
  const replacements = [];
  const numbering = editor.converter.numbering;
  if (!numbering) return replacements;
  const { state } = editor;
  const { doc: doc2 } = state;
  const dispatch = typeof editor.view?.dispatch === "function" ? editor.view.dispatch.bind(editor.view) : editor.dispatch.bind(editor);
  const LIST_TYPES = ["orderedList", "bulletList"];
  let lastListEndPos = 0;
  doc2.descendants((node, pos) => {
    if (!LIST_TYPES.includes(node.type.name)) return;
    if (pos < lastListEndPos) return;
    const extracted = flattenListCompletely(node, editor, 0);
    if (extracted.length > 0) {
      replacements.push({
        from: pos,
        to: pos + node.nodeSize,
        listNode: node,
        replacement: extracted
      });
    }
    lastListEndPos = pos + node.nodeSize;
  });
  let tr = state.tr;
  if (replacements.length > 0) {
    for (let i = replacements.length - 1; i >= 0; i--) {
      const { from: from3, to, replacement, listNode } = replacements[i];
      const nodesToInsert = [];
      for (const item of replacement) {
        if (item.node.type.name === "listItem") {
          const singleItemList = listNode.type.create(listNode.attrs, [item.node]);
          nodesToInsert.push(singleItemList);
        } else {
          nodesToInsert.push(item.node);
        }
      }
      tr = tr.replaceWith(from3, to, nodesToInsert);
    }
  }
  tr.setMeta("listsv2migration", replacements);
  editor.options.migrated = true;
  dispatch(tr);
  return replacements;
};
function flattenListCompletely(listNode, editor, baseLevel = 0, sharedNumId = null) {
  const result = [];
  const listTypes = ["orderedList", "bulletList"];
  const currentListType = listNode.type.name;
  const needsMigration = shouldMigrateList(listNode);
  const hasValidDefinition = checkValidDefinition(listNode, editor);
  if (!needsMigration) {
    if (!hasValidDefinition) {
      return generateMissingListDefinition(listNode, editor);
    } else {
      return result;
    }
  }
  let numId = parseInt(listNode.attrs?.listId);
  if (!numId || Number.isNaN(numId)) numId = superEditor_converter.ListHelpers.getNewListId(editor);
  const listHasDef = superEditor_converter.ListHelpers.getListDefinitionDetails({ numId, level: baseLevel, editor });
  if (!listHasDef || !sharedNumId && !numId) {
    numId = superEditor_converter.ListHelpers.getNewListId(editor);
    superEditor_converter.ListHelpers.generateNewListDefinition({
      numId,
      listType: currentListType,
      editor
    });
  }
  if (!sharedNumId) sharedNumId = numId;
  for (const listItem of listNode.content.content) {
    if (!listItem.content.content?.length) {
      result.push({ node: listItem, baseLevel });
    } else if (listItem.content.content.length === 1) {
      const contentNode = listItem.content.content[0];
      if (listTypes.includes(contentNode.type.name)) {
        const flattened = flattenListCompletely(contentNode, editor, baseLevel + 1, sharedNumId);
        result.push(...flattened);
      } else {
        const newList = superEditor_converter.ListHelpers.createSchemaOrderedListNode({
          level: baseLevel,
          numId: sharedNumId,
          listType: listNode.type.name,
          editor,
          contentNode: contentNode.toJSON(),
          listLevel: listItem.attrs.listLevel || [1]
        });
        result.push({ node: newList, baseLevel });
      }
    } else {
      const firstItem = listItem.content.content[0];
      if (listTypes.includes(firstItem.type.name)) {
        const flattened = flattenListCompletely(firstItem, editor, baseLevel + 1, sharedNumId);
        result.push(...flattened);
      } else {
        if (firstItem.type.name === "paragraph" || firstItem.isTextblock) {
          const newList = superEditor_converter.ListHelpers.createSchemaOrderedListNode({
            level: baseLevel,
            numId: sharedNumId,
            listType: listNode.type.name,
            editor,
            contentNode: firstItem.toJSON(),
            listLevel: listItem.attrs.listLevel || [1]
          });
          result.push({ node: newList, baseLevel });
        } else {
          result.push({ node: firstItem });
        }
      }
      for (let contentItem of listItem.content.content.slice(1)) {
        if (listTypes.includes(contentItem.type.name)) {
          const flattened = flattenListCompletely(contentItem, editor, baseLevel + 1, sharedNumId);
          result.push(...flattened);
        } else {
          result.push({ node: contentItem });
        }
      }
    }
  }
  return result;
}
const shouldMigrateList = (listItem) => {
  const content = listItem.content;
  if (content?.content?.length > 1) {
    return true;
  }
  const firstChild = content.firstChild;
  if (firstChild && firstChild.type.name === "listItem") {
    const { attrs } = firstChild;
    const { level, listNumberingType } = attrs || {};
    if (typeof level === "undefined" || !listNumberingType) {
      return true;
    }
    const childContent = firstChild?.content?.content;
    const nestedLists = childContent.filter((child) => ["bulletList", "orderedList"].includes(child.type.name));
    return nestedLists.length > 0;
  }
  return false;
};
const checkValidDefinition = (listNode, editor) => {
  const listType = listNode.type.name;
  const listItem = listNode.content.firstChild;
  const { attrs } = listItem;
  const { numId, level } = attrs || {};
  const listDef = superEditor_converter.ListHelpers.getListDefinitionDetails({ numId, level, listType, editor });
  const { abstract } = listDef || {};
  if (abstract) return true;
  return false;
};
const generateMissingListDefinition = (listNode, editor) => {
  const listType = listNode.type.name;
  const listItem = listNode.content.firstChild;
  const { attrs } = listItem;
  const { numId } = attrs || {};
  return superEditor_converter.ListHelpers.generateNewListDefinition({
    numId,
    listType,
    editor
  });
};
const migrateParagraphFieldsListsV2 = async (annotationValues = [], editor) => {
  const annotations = getAllFieldAnnotations(editor.state);
  const newValues = [];
  if (!annotations.length) {
    return annotationValues;
  }
  for (const annotation of annotations) {
    const type = annotation.node?.attrs?.type;
    const matchedAnnotation = annotationValues.find((v) => v.input_id === annotation.node.attrs.fieldId);
    if (!!matchedAnnotation && (!type || type !== "html")) {
      newValues.push(matchedAnnotation);
      continue;
    }
    const value = matchedAnnotation?.input_value;
    if (!value) continue;
    await new Promise((resolve, reject) => {
      const element = document.createElement("div");
      editor.createChildEditor({
        element,
        html: value,
        onCreate: ({ editor: localEditor }) => {
          const { migrated } = localEditor.options;
          if (migrated) {
            const newHTML = localEditor.getHTML();
            matchedAnnotation.input_value = newHTML;
            newValues.push(matchedAnnotation);
          }
          resolve();
        },
        onError: (error) => {
          reject(error);
        }
      });
    });
  }
  return newValues;
};
const createLinkedChildEditor = (currentEditor, options = {}) => {
  if (currentEditor.options.isChildEditor) {
    return null;
  }
  const editor = new Editor({
    ...currentEditor.options,
    pagination: false,
    suppressDefaultDocxStyles: true,
    ydoc: null,
    collaborationProvider: null,
    fileSource: null,
    initialState: null,
    documentId: null,
    isCommentsEnabled: false,
    isNewFile: false,
    fragment: false,
    onCreate: () => null,
    onListDefinitionsChange: linkListDefinitionsChange,
    // Options overrides
    ...options,
    isChildEditor: true,
    parentEditor: currentEditor
  });
  return editor;
};
const linkListDefinitionsChange = (options) => {
  const { editor, numbering } = options;
  const { parentEditor = {} } = editor.options;
  const { converter: parentConverter } = parentEditor;
  if (!parentConverter) return;
  parentConverter.numbering = numbering;
  const { tr } = parentEditor.state;
  tr.setMeta("updatedListItemNodeViews", true);
  parentEditor.dispatch(tr);
};
function createLogger(debug, additionalPrefixes = []) {
  const basePrefix = "[SuperValidator]";
  const style2 = "color: teal; font-weight: bold;";
  const allPrefixes = [basePrefix, ...additionalPrefixes.map((p2) => `[${p2}]`)];
  const format = allPrefixes.map(() => "%c%s").join(" ");
  const styledPrefixes = allPrefixes.map((p2) => [style2, p2]).flat();
  return {
    debug: (...args) => {
      if (!debug) return;
      console.debug(format, ...styledPrefixes, ...args);
    },
    withPrefix: (prefix2) => createLogger(debug, [...additionalPrefixes, prefix2])
  };
}
function ensureValidImageRID(images, editor, tr, logger) {
  let modified = false;
  const results = [];
  images.forEach(({ node, pos }) => {
    const { rId, src } = node.attrs;
    if (!rId && src) {
      let newId = editor.converter.docxHelpers.findRelationshipIdFromTarget(src, editor);
      if (newId) logger.debug("Reusing existing rId for image:", newId, "at pos:", pos);
      if (!newId) {
        newId = editor.converter.docxHelpers.insertNewRelationship(src, "image", editor);
        logger.debug("Creating new rId for image at pos:", pos, "with src:", src);
      }
      tr.setNodeMarkup(pos, void 0, {
        ...node.attrs,
        rId: newId
      });
      results.push(`Added missing rId to image at pos ${pos}`);
      modified = true;
    }
  });
  return { modified, results };
}
function createImageNodeValidator({ editor, logger }) {
  const validator = (tr, analysis) => {
    const images = analysis.image || [];
    const ruleResults = [ensureValidImageRID(images, editor, tr, logger)];
    const modified = ruleResults.some((r2) => r2.modified);
    const results = ruleResults.flatMap((r2) => r2.results);
    return { modified, results };
  };
  validator.requiredElements = {
    nodes: ["image"]
  };
  return validator;
}
function ensureValidLinkRID(links, editor, tr, logger) {
  let modified = false;
  const results = [];
  links.forEach(({ mark, from: from3, to }) => {
    const { rId, href, anchor } = mark.attrs;
    if (!rId && href && !anchor) {
      let newId = editor.converter.docxHelpers.findRelationshipIdFromTarget(href, editor);
      if (newId) logger.debug("Reusing existing rId for link:", newId, "from pos:", from3, "to pos:", to);
      if (!newId) {
        newId = editor.converter.docxHelpers.insertNewRelationship(href, "hyperlink", editor);
        logger.debug("Creating new rId for link from pos:", from3, "to pos:", to, "with href:", href);
      }
      if (newId) {
        const linkMarkType = editor.schema.marks.link;
        const newMark = linkMarkType.create({
          ...mark.attrs,
          rId: newId
        });
        tr.removeMark(from3, to, linkMarkType);
        tr.addMark(from3, to, newMark);
        results.push(`Added missing rId to link from pos ${from3} to ${to}`);
        modified = true;
      }
    }
  });
  return { modified, results };
}
function createLinkMarkValidator({ editor, logger }) {
  const validator = (tr, analysis) => {
    const links = analysis.link || [];
    const ruleResults = [ensureValidLinkRID(links, editor, tr, logger)];
    const modified = ruleResults.some((r2) => r2.modified);
    const results = ruleResults.flatMap((r2) => r2.results);
    return { modified, results };
  };
  validator.requiredElements = {
    marks: ["link"]
  };
  return validator;
}
const StateValidators = {
  imageNodeValidator: createImageNodeValidator,
  linkMarkValidator: createLinkMarkValidator
};
function createNumberingValidator({ editor, logger }) {
  return () => {
    const results = [];
    let modified = false;
    const convertedXml = editor?.converter?.convertedXml;
    const path = "word/numbering.xml";
    const numbering = convertedXml?.[path];
    if (!numbering || !numbering.elements?.length || !numbering.elements[0].elements?.length) {
      results.push(`${path} is not a valid xml`);
      return { results, modified };
    }
    const removed = [];
    let elements = numbering.elements[0];
    pruneInvalidNumNodes(elements, removed);
    if (removed.length) {
      modified = true;
      results.push(`Removed invalid <w:num> by numId:` + removed.join(", "));
      logger?.debug?.(`Removed invalid <w:num> by numId: ${removed.join(", ")}`);
    } else {
      results.push("No <w:num> entries with null/invalid numId found.");
    }
    return { results, modified };
  };
}
function pruneInvalidNumNodes(node, removed) {
  if (!node || !Array.isArray(node.elements)) return;
  const next = [];
  for (const el of node.elements) {
    if (el?.type === "element") {
      if (el.name === "w:num") {
        const attrs = el.attributes || {};
        const raw = attrs["w:numId"];
        const v = raw == null ? null : String(raw).trim();
        const isInvalid = v == null || v === "" || /^null$/i.test(v) || !/^\d+$/.test(v);
        if (isInvalid) {
          removed.push(v ?? "missing node");
          continue;
        }
      }
      if (Array.isArray(el.elements) && el.elements.length) {
        pruneInvalidNumNodes(el, removed);
      }
    }
    next.push(el);
  }
  node.elements = next;
}
function createRelationshipsValidator({ editor, logger }) {
  return () => {
    const results = [];
    let modified = false;
    const convertedXml = editor?.converter?.convertedXml;
    if (!convertedXml || typeof convertedXml !== "object") {
      return { results, modified };
    }
    const { relsKey, wasNormalized } = findAndNormalizeRelationshipsFile(convertedXml, results);
    if (!relsKey) {
      return { results, modified };
    }
    if (wasNormalized) modified = true;
    const { root: root2, wasFixed } = validateRelationshipsRoot(convertedXml[relsKey], relsKey, results);
    if (!root2) {
      return { results, modified };
    }
    if (wasFixed) modified = true;
    const wasCleaned = cleanupRootChildren(root2);
    if (wasCleaned) modified = true;
    const { filteredIds, binMediaTargets, wasProcessed } = processRelationships(root2, convertedXml, results);
    if (wasProcessed) modified = true;
    const wasDocumentFixed = fixMissingDocumentRefs(convertedXml, filteredIds, results, logger);
    if (wasDocumentFixed) modified = true;
    const contentTypesKey = "[Content_Types].xml";
    const contentTypesXml = convertedXml[contentTypesKey];
    if (binMediaTargets.size > 0 || contentTypesXml) {
      const wasContentTypesUpdated = updateContentTypes(convertedXml, binMediaTargets, results);
      if (wasContentTypesUpdated) modified = true;
    } else {
      results.push("[Content_Types].xml not found or not parseable. Skipped content types patch.");
    }
    return { results, modified };
  };
}
function findAndNormalizeRelationshipsFile(convertedXml, results) {
  const candidateKeys = [
    "word/_rels/document.xml.rels",
    "word/document.xml.rels",
    "_rels/document.xml.rels",
    "document.xml.rels"
  ];
  const relsKey = candidateKeys.find((k2) => convertedXml?.[k2]?.elements);
  if (!relsKey) return { relsKey: null, wasNormalized: false };
  const canonicalKey = "word/_rels/document.xml.rels";
  if (relsKey !== canonicalKey) {
    convertedXml[canonicalKey] = convertedXml[relsKey];
    delete convertedXml[relsKey];
    results.push(`Normalized relationships location to ${canonicalKey} (was ${relsKey})`);
    return { relsKey: canonicalKey, wasNormalized: true };
  }
  return { relsKey, wasNormalized: false };
}
function validateRelationshipsRoot(relsTree, relsKey, results) {
  const root2 = relsTree?.elements?.[0];
  if (!root2 || root2.type !== "element") {
    results.push(`${relsKey} is not a valid xml`);
    return { root: null, wasFixed: false };
  }
  const RELS_NS = "http://schemas.openxmlformats.org/package/2006/relationships";
  let wasFixed = false;
  if (root2.name !== "Relationships") {
    root2.name = "Relationships";
    results.push(`Fixed relationships root element name to "Relationships"`);
    wasFixed = true;
  }
  root2.attributes = root2.attributes || {};
  if (root2.attributes.xmlns !== RELS_NS) {
    root2.attributes.xmlns = RELS_NS;
    results.push(`Set relationships xmlns to ${RELS_NS}`);
    wasFixed = true;
  }
  return { root: root2, wasFixed };
}
function cleanupRootChildren(root2) {
  const validChildren = root2.elements?.filter((child) => child?.type === "element" && child.name === "Relationship") || [];
  if (root2.elements?.length !== validChildren.length) {
    root2.elements = validChildren;
    return true;
  }
  return false;
}
function processRelationships(root2, convertedXml, results) {
  const binMediaTargets = /* @__PURE__ */ new Set();
  const filteredIds = /* @__PURE__ */ new Set();
  let wasProcessed = false;
  const ridNum = (id) => {
    const m2 = /^rId(\d+)$/.exec(String(id || ""));
    return m2 ? parseInt(m2[1], 10) : null;
  };
  const isType2 = (type, tail) => typeof type === "string" && new RegExp(`/relationships/${tail}$`, "i").test(type);
  const isHyperlinkType = (type) => isType2(type, "hyperlink");
  const isImageType = (type) => isType2(type, "image");
  const looksExternal = (target) => /^https?:\/\//i.test(target || "") || /^mailto:/i.test(target || "");
  const usedIds = /* @__PURE__ */ new Set();
  let maxRid = 0;
  for (const el of root2.elements) {
    el.attributes = el.attributes || {};
    const id = el.attributes.Id;
    const n = ridNum(id);
    if (Number.isInteger(n)) maxRid = Math.max(maxRid, n);
    if (typeof id === "string" && id) {
      usedIds.add(id);
    }
  }
  let ridCounter = maxRid;
  const allocateId = (preferred) => {
    let newId;
    do {
      ridCounter += 1;
      newId = `rId${ridCounter}`;
    } while (usedIds.has(newId));
    usedIds.add(newId);
    return newId;
  };
  const seenIds = /* @__PURE__ */ new Set();
  const filtered = [];
  function extractStringAttr(attrs, key2) {
    return typeof attrs[key2] === "string" ? attrs[key2].trim() : "";
  }
  for (const rel of root2.elements) {
    rel.attributes = rel.attributes || {};
    const attrs = rel.attributes;
    let id = extractStringAttr(attrs, "Id");
    const type = extractStringAttr(attrs, "Type");
    let target = extractStringAttr(attrs, "Target");
    let targetMode = extractStringAttr(attrs, "TargetMode");
    if (!target) {
      results.push(`Removed relationship "${id}" without Target`);
      wasProcessed = true;
      continue;
    }
    if (isHyperlinkType(type) && looksExternal(target) && targetMode.toLowerCase() !== "external") {
      attrs.TargetMode = "External";
      targetMode = "External";
      results.push(`Set TargetMode="External" for hyperlink ${id}`);
      wasProcessed = true;
    }
    if (isImageType(type)) {
      const relPath = helpers$1.resolveOpcTargetPath(target, "word");
      if (relPath && /^media\/.+\.bin$/i.test(target) && relPath in convertedXml) {
        binMediaTargets.add(`/${relPath}`);
      }
    }
    if (targetMode.toLowerCase() !== "external" && !looksExternal(target)) {
      const likelyPath = helpers$1.resolveOpcTargetPath(target, "word");
      if (!(likelyPath in convertedXml)) {
        if (!isImageType(type)) {
          results.push(`Removed relationship ${id} with missing target: ${target}`);
          wasProcessed = true;
          continue;
        } else {
          results.push(`Warning: image relationship ${id} target not found: ${target}.`);
        }
      }
    }
    if (!id) {
      const newId = allocateId();
      attrs.Id = newId;
      results.push(`Assigned missing Id "${newId}"`);
      wasProcessed = true;
      id = newId;
    }
    if (seenIds.has(id)) {
      results.push(`Removed duplicate relationship with ID "${id}"`);
      wasProcessed = true;
      continue;
    }
    seenIds.add(id);
    filtered.push(rel);
  }
  if (root2.elements.length !== filtered.length) {
    root2.elements = filtered;
    wasProcessed = true;
  } else {
    const contentChanged = root2.elements.some((el, i) => el !== filtered[i]);
    if (contentChanged) {
      root2.elements = filtered;
      wasProcessed = true;
    }
  }
  for (const rel of root2.elements) {
    const id = rel.attributes?.Id;
    if (typeof id === "string" && id) {
      filteredIds.add(id);
    }
  }
  return { filteredIds, binMediaTargets, wasProcessed };
}
function fixMissingDocumentRefs(convertedXml, filteredIds, results, logger) {
  const documentPath = "word/document.xml";
  const document2 = convertedXml[documentPath];
  if (document2?.elements?.length) {
    const documentRoot = document2.elements[0];
    if (documentRoot?.type === "element") {
      const missingRefs = [];
      processDocumentForMissingRefs(documentRoot, filteredIds, missingRefs);
      if (missingRefs.length) {
        results.push(`Fixed ${missingRefs.length} missing relationship references`);
        logger?.debug?.(`Fixed ${missingRefs.length} missing relationship references in document`);
        return true;
      }
    }
  }
  return false;
}
function updateContentTypes(convertedXml, binMediaTargets, results) {
  const contentTypesKey = "[Content_Types].xml";
  const contentTypesXml = convertedXml[contentTypesKey];
  if (typeof contentTypesXml === "string") {
    return updateContentTypesString(contentTypesXml, binMediaTargets, results, convertedXml, contentTypesKey);
  } else if (contentTypesXml?.elements?.length) {
    return updateContentTypesElements(contentTypesXml, binMediaTargets, results);
  } else {
    return false;
  }
}
function updateContentTypesString(contentTypesXml, binMediaTargets, results, convertedXml, contentTypesKey) {
  const CONTENT_TYPES_NS = '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">';
  const ensureDefault = (xmlString, ext, contentType) => {
    const defRe = new RegExp(`<Default\\s+Extension="${ext}"\\b`, "i");
    if (defRe.test(xmlString)) return xmlString;
    return xmlString.replace(
      CONTENT_TYPES_NS,
      `${CONTENT_TYPES_NS}<Default Extension="${ext}" ContentType="${contentType}"/>`
    );
  };
  const ensureOverride = (xmlString, partName, contentType) => {
    const esc = partName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    const ovRe = new RegExp(`<Override\\s+PartName="${esc}"\\b`, "i");
    if (ovRe.test(xmlString)) return xmlString;
    return xmlString.replace(
      CONTENT_TYPES_NS,
      `${CONTENT_TYPES_NS}<Override PartName="${partName}" ContentType="${contentType}" />`
    );
  };
  let updated = contentTypesXml;
  updated = ensureDefault(updated, "rels", "application/vnd.openxmlformats-package.relationships+xml");
  updated = ensureDefault(updated, "xml", "application/xml");
  for (const partName of binMediaTargets) {
    updated = ensureOverride(updated, partName, "image/png");
    results.push(`Added Content Types Override for "${partName}" as image/png`);
  }
  if (updated !== contentTypesXml) {
    convertedXml[contentTypesKey] = updated;
    return true;
  }
  return false;
}
function updateContentTypesElements(contentTypesXml, binMediaTargets, results) {
  const typesRoot = contentTypesXml.elements.find((el) => el.name === "Types") || contentTypesXml.elements[0];
  typesRoot.elements = typesRoot.elements || [];
  const hasDefault = (ext) => typesRoot.elements.some((el) => el.name === "Default" && el.attributes?.Extension === ext);
  const addDefault = (ext, ct) => {
    typesRoot.elements.unshift({
      type: "element",
      name: "Default",
      attributes: { Extension: ext, ContentType: ct }
    });
  };
  const hasOverride = (part) => typesRoot.elements.some((el) => el.name === "Override" && el.attributes?.PartName === part);
  const addOverride = (part, ct) => {
    typesRoot.elements.unshift({
      type: "element",
      name: "Override",
      attributes: { PartName: part, ContentType: ct }
    });
  };
  let wasUpdated = false;
  if (!hasDefault("rels")) {
    addDefault("rels", "application/vnd.openxmlformats-package.relationships+xml");
    wasUpdated = true;
  }
  if (!hasDefault("xml")) {
    addDefault("xml", "application/xml");
    wasUpdated = true;
  }
  for (const partName of binMediaTargets) {
    if (!hasOverride(partName)) {
      addOverride(partName, "image/png");
      results.push(`Added Content Types Override for "${partName}" as image/png`);
      wasUpdated = true;
    }
  }
  return wasUpdated;
}
function processDocumentForMissingRefs(node, usedIds, fixed) {
  if (!node?.elements?.length) return;
  for (const element of node.elements) {
    if (element?.type !== "element") continue;
    const rIdValue = element.attributes?.["r:id"];
    if (typeof rIdValue === "string" && !usedIds.has(rIdValue)) {
      delete element.attributes["r:id"];
      fixed.push(`Removed invalid r:id="${rIdValue}"`);
    }
    processDocumentForMissingRefs(element, usedIds, fixed);
  }
}
const XmlValidators = {
  numberingValidator: createNumberingValidator,
  relationshipsValidator: createRelationshipsValidator
};
class SuperValidator {
  /** @type {Editor} */
  #editor;
  /** @type {any} */
  #stateValidators;
  /** @type {any} */
  #xmlValidators;
  /** @type {Set<string>} */
  #requiredNodeTypes;
  /** @type {Set<string>} */
  #requiredMarkTypes;
  /**
   * Create a SuperValidator instance.
   * @param {SuperValidatorOptions} options - Options for the validator.
   */
  constructor(options) {
    this.#editor = options.editor;
    this.dryRun = options.dryRun || false;
    this.debug = options.debug || false;
    this.logger = createLogger(this.debug);
    const { stateValidators, xmlValidators, nodeTypes, markTypes } = this.#initializeValidators();
    this.#stateValidators = stateValidators;
    this.#xmlValidators = xmlValidators;
    this.#requiredNodeTypes = nodeTypes;
    this.#requiredMarkTypes = markTypes;
  }
  /**
   * Initialize all validators and collect their element requirements
   * @returns {{ stateValidators: Record<string, ValidatorFunction>, xmlValidators: Record<string, ValidatorFunction>, nodeTypes: Set<string>, markTypes: Set<string> }}
   */
  #initializeValidators() {
    const requiredNodes = /* @__PURE__ */ new Set();
    const requiredMarks = /* @__PURE__ */ new Set();
    const initializeValidatorSet = (validatorFactories) => {
      return Object.fromEntries(
        Object.entries(validatorFactories).map(([key2, factory]) => {
          const validatorLogger = this.logger.withPrefix(key2);
          const validator = factory({ editor: this.#editor, logger: validatorLogger });
          this.#collectValidatorRequirements(validator, requiredNodes, requiredMarks);
          return [key2, validator];
        })
      );
    };
    const stateValidators = initializeValidatorSet(StateValidators);
    const xmlValidators = initializeValidatorSet(XmlValidators);
    return {
      stateValidators,
      xmlValidators,
      nodeTypes: requiredNodes,
      markTypes: requiredMarks
    };
  }
  /**
   * Extract and collect requirements from a validator
   * @param {ValidatorFunction} validator
   * @param {Set<string>} requiredNodes
   * @param {Set<string>} requiredMarks
   */
  #collectValidatorRequirements(validator, requiredNodes, requiredMarks) {
    if (!validator.requiredElements) return;
    if (typeof validator.requiredElements === "object") {
      if (validator.requiredElements.nodes) {
        validator.requiredElements.nodes.forEach((nodeType) => {
          requiredNodes.add(nodeType);
        });
      }
      if (validator.requiredElements.marks) {
        validator.requiredElements.marks.forEach((markType) => {
          requiredMarks.add(markType);
        });
      }
    }
  }
  /**
   * Analyze the document to collect all required elements
   * @returns {DocumentAnalysis}
   */
  #analyzeDocument() {
    const { doc: doc2 } = this.#editor.state;
    const analysis = {};
    this.#requiredNodeTypes.forEach((type) => analysis[type] = []);
    this.#requiredMarkTypes.forEach((type) => analysis[type] = []);
    const collectElements = (node, pos) => {
      if (this.#requiredNodeTypes.has(node.type.name)) {
        analysis[node.type.name].push({ node, pos });
      }
      if (node.isText && node.marks) {
        node.marks.forEach(
          /** @param {Mark} mark */
          (mark) => {
            if (this.#requiredMarkTypes.has(mark.type.name)) {
              analysis[mark.type.name].push({
                mark,
                node,
                pos,
                from: pos,
                to: pos + node.nodeSize
              });
            }
          }
        );
      }
    };
    doc2.descendants(collectElements);
    return analysis;
  }
  /**
   * Validate the active document in the editor. Triggered automatically on editor initialization.
   * @returns {{ modified: boolean, results: Array<{ key: string, results: string[] }> }}
   */
  validateActiveDocument() {
    const state = this.#editor.state;
    if (!state) return { modified: false, results: [] };
    const { tr } = state;
    const documentAnalysis = this.#analyzeDocument();
    this.logger.debug("Document analysis:", documentAnalysis);
    let hasModifiedDocument = false;
    const validationResults = [];
    Object.entries(this.#stateValidators).forEach(([key2, validator]) => {
      this.logger.debug(` Validating with ${key2}...`);
      const { results, modified } = validator(tr, documentAnalysis);
      validationResults.push({ key: key2, results });
      hasModifiedDocument = hasModifiedDocument || modified;
    });
    if (!this.dryRun) {
      this.#dispatchWithFallback(tr);
    } else {
      this.logger.debug("DRY RUN: No changes applied to the document.");
    }
    this.logger.debug("Results:", validationResults);
    return { modified: hasModifiedDocument, results: validationResults };
  }
  /**
   * Validate the exported document in the editor. Triggered automatically on editor export.
   * @returns {{ modified: boolean, results: Array<{ key: string, results: string[] }> }}
   */
  validateDocumentExport() {
    const state = this.#editor.state;
    if (!state) return { modified: false, results: [] };
    const { tr } = state;
    let hasModifiedDocument = false;
    const validationResults = [];
    Object.entries(this.#xmlValidators).forEach(([key2, validator]) => {
      this.logger.debug(` Validating export with ${key2}...`);
      const { results, modified } = validator();
      validationResults.push({ key: key2, results });
      hasModifiedDocument = hasModifiedDocument || modified;
    });
    if (!this.dryRun && hasModifiedDocument) {
      this.#dispatchWithFallback(tr);
    } else {
      this.logger.debug("DRY RUN: No export changes applied to the document.");
    }
    this.logger.debug("Export validation results:", validationResults);
    return { modified: hasModifiedDocument, results: validationResults };
  }
  /**
   * Dispatch a transaction using the editor's public API if available, or fall back to the view.
   * @param {import('prosemirror-state').Transaction} tr
   */
  #dispatchWithFallback(tr) {
    if (typeof this.#editor?.dispatch === "function") {
      this.#editor.dispatch(tr);
      return;
    }
    this.#editor?.view?.dispatch?.(tr);
  }
}
const isHeadless = (editor) => {
  return editor?.options?.isHeadless ?? false;
};
const shouldSkipNodeView = (editor) => {
  return isHeadless(editor);
};
let domAvailabilityCache = null;
const canUseDOM = () => {
  if (domAvailabilityCache !== null) {
    return domAvailabilityCache;
  }
  try {
    const hasDOM = typeof globalThis !== "undefined" && typeof globalThis.window !== "undefined" && typeof globalThis.document !== "undefined" && typeof globalThis.document.createElement === "function";
    domAvailabilityCache = hasDOM;
    return hasDOM;
  } catch {
    domAvailabilityCache = false;
    return false;
  }
};
const summaryVersion = "1.9.0-next.5";
const nodeKeys = ["group", "content", "marks", "inline", "atom", "defining", "code", "tableRole", "summary"];
const markKeys = ["group", "inclusive", "excludes", "spanning", "code"];
function mapAttributes(attrs) {
  if (!attrs) return {};
  return Object.fromEntries(
    Object.entries(attrs).map(([name, attrSpec]) => {
      const defaultValue = attrSpec?.default;
      return [
        name,
        {
          default: defaultValue ?? null,
          required: defaultValue === void 0
        }
      ];
    })
  );
}
function pickSpecFields(spec, keys2) {
  return Object.fromEntries(keys2.map((key2) => [key2, spec[key2]]).filter(([, value]) => value !== void 0));
}
function buildSchemaSummary(schema, schemaVersion) {
  if (!schema || typeof schema !== "object") {
    throw new Error("Invalid schema: schema must be a valid ProseMirror Schema object.");
  }
  const resolvedSchemaVersion = schemaVersion || "current";
  const nodes = [];
  schema.spec.nodes.forEach((name, spec) => {
    nodes.push({
      name,
      attrs: mapAttributes(spec.attrs),
      ...pickSpecFields(spec, nodeKeys)
    });
  });
  const marks = [];
  schema.spec.marks.forEach((name, spec) => {
    marks.push({
      name,
      attrs: mapAttributes(spec.attrs),
      ...pickSpecFields(spec, markKeys)
    });
  });
  return {
    version: summaryVersion,
    schemaVersion: resolvedSchemaVersion,
    topNode: schema.topNodeType?.name,
    nodes,
    marks
  };
}
const transformListsInCopiedContent = (html) => {
  const container = document.createElement("div");
  container.innerHTML = html;
  const result = [];
  const stack2 = [];
  const flushStackUntil = (level) => {
    while (stack2.length && stack2[stack2.length - 1].level >= level) {
      const top2 = stack2.pop();
      if (stack2.length) {
        stack2[stack2.length - 1].el.appendChild(top2.el);
      } else {
        result.push(top2.el.outerHTML);
      }
    }
  };
  Array.from(container.childNodes).forEach((node) => {
    if (node.nodeType !== Node.ELEMENT_NODE) {
      result.push(node.outerHTML || node.textContent);
      return;
    }
    if (node.tagName.toLowerCase() === "ol" || node.tagName.toLowerCase() === "ul") {
      const child = getFirstElementChild(node);
      const level = getLevel(child);
      const numFmt = child.getAttribute("data-num-fmt");
      const lvlText = child.getAttribute("data-lvl-text");
      const tag = node.tagName.toLowerCase();
      const li = child.cloneNode(true);
      li.setAttribute("aria-level", level + 1);
      li.style.setProperty("list-style-type", getListStyleType(numFmt, lvlText));
      if (!stack2.length || stack2[stack2.length - 1].level < level) {
        const newList = document.createElement(tag);
        stack2.push({ tag, level, el: newList });
      } else if (stack2[stack2.length - 1].level > level) {
        flushStackUntil(level + 1);
      } else if (stack2[stack2.length - 1].tag !== tag) {
        flushStackUntil(level);
        const newList = document.createElement(tag);
        stack2.push({ tag, level, el: newList });
      }
      stack2[stack2.length - 1].el.appendChild(li);
    } else {
      flushStackUntil(0);
      result.push(node.outerHTML);
    }
  });
  flushStackUntil(0);
  return result.join("");
};
const getListStyleType = (numFmt, lvlText) => {
  const bulletFmtMap = /* @__PURE__ */ new Map([
    ["", "disc"],
    ["", "circle"],
    ["", "square"]
  ]);
  if (numFmt === "bullet") return bulletFmtMap.get(lvlText) || "disc";
  const fmtMap = /* @__PURE__ */ new Map([
    ["decimal", "decimal"],
    ["lowerLetter", "lower-alpha"],
    ["upperLetter", "upper-alpha"],
    ["lowerRoman", "lower-roman"],
    ["upperRoman", "upper-roman"]
  ]);
  return lvlText.startsWith("0") ? "decimal-leading-zero" : fmtMap.get(numFmt);
};
function getFirstElementChild(node) {
  return Array.from(node.childNodes).find((n) => n.nodeType === Node.ELEMENT_NODE) || null;
}
const getLevel = (node) => {
  const lvl = node.getAttribute("data-level");
  return lvl ? parseInt(lvl, 10) : 0;
};
const STYLE_ISOLATION_CLASS = "sd-editor-scoped";
const applyStyleIsolationClass = (target) => {
  if (!target || !target.classList) return;
  target.classList.add(STYLE_ISOLATION_CLASS);
};
const DEFAULT_FALLBACK_MARGIN_INCHES = 1;
const MIN_MOBILE_SIDE_MARGIN_PX = 10;
const RESIZE_DEBOUNCE_MS = 150;
const DEFAULT_LINE_HEIGHT = 1.2;
class ProseMirrorRenderer {
  constructor() {
    this.view = null;
    this.eventListenerCleanups = [];
    this.resizeTimeoutId = null;
  }
  /**
   * Attach the renderer to a DOM element and create a ProseMirror view.
   *
   * Destroys any existing view before creating a new one to prevent memory leaks.
   *
   * @param params - Configuration including element, state, and callbacks
   * @param params.element - DOM element to mount into (or null for headless)
   * @param params.state - Initial ProseMirror editor state
   * @param params.editorProps - Additional ProseMirror view properties
   * @param params.dispatchTransaction - Transaction dispatch callback
   * @param params.handleClick - Optional click handler
   * @returns The created ProseMirror EditorView instance
   */
  attach({
    element,
    state,
    editorProps = {},
    dispatchTransaction,
    handleClick: handleClick2
  }) {
    this.view?.destroy();
    const validatedEditorProps = editorProps && typeof editorProps === "object" ? editorProps : {};
    this.view = new EditorView(element, {
      ...validatedEditorProps,
      dispatchTransaction,
      state,
      handleClick: handleClick2
    });
    return this.view;
  }
  /**
   * Destroy the renderer and clean up all resources.
   *
   * Destroys the ProseMirror view, removes all event listeners, and sets view to null.
   * Should be called when the editor is unmounted or destroyed.
   */
  destroy() {
    if (this.resizeTimeoutId !== null) {
      clearTimeout(this.resizeTimeoutId);
      this.resizeTimeoutId = null;
    }
    for (const cleanup of this.eventListenerCleanups) {
      cleanup();
    }
    this.eventListenerCleanups = [];
    this.view?.destroy();
    this.view = null;
  }
  /**
   * Initialize the container element for the editor.
   *
   * Handles element selection via selector, applies style isolation class,
   * and configures headless mode if DOM is unavailable.
   *
   * In headless mode or when DOM is unavailable:
   * - Sets isHeadless to true
   * - Sets element to null
   *
   * In browser mode:
   * - Resolves element from selector (# or . prefix, or getElementById)
   * - Creates a new div if no element provided
   * - Applies style isolation class
   *
   * @param options - Partial editor options containing element/selector configuration
   */
  initContainerElement(options) {
    if (!canUseDOM()) {
      options.isHeadless = true;
      options.element = null;
      return;
    }
    if (!options.element && options.selector) {
      const { selector } = options;
      let foundElement = null;
      if (selector.startsWith("#") || selector.startsWith(".")) {
        const queriedElement = document.querySelector(selector);
        foundElement = queriedElement instanceof HTMLElement ? queriedElement : null;
      } else {
        foundElement = document.getElementById(selector);
      }
      options.element = foundElement;
      const textModes = ["text", "html"];
      if (textModes.includes(options.mode) && options.element) {
        options.element.classList.add("sd-super-editor-html");
      }
    }
    if (options.isHeadless) {
      options.element = null;
      return;
    }
    options.element = options.element || document.createElement("div");
    applyStyleIsolationClass(options.element);
  }
  /**
   * Initialize and inject document fonts into the DOM.
   *
   * Extracts font data from the converter, generates @font-face CSS rules,
   * and appends them to the document head for use throughout the application.
   *
   * Updates editor.fontsImported with the list of imported font families.
   *
   * Wraps DOM manipulation in try-catch to handle cases where document.head
   * is inaccessible or DOM operations fail (e.g., in restricted iframe contexts).
   *
   * @param editor - The editor instance containing font data via converter
   */
  initFonts(editor) {
    const results = editor.converter.getFontFaceImportString();
    if (results?.styleString?.length) {
      try {
        const style2 = document.createElement("style");
        style2.textContent = results.styleString;
        document.head.appendChild(style2);
        editor.fontsImported = results.fontsImported;
      } catch (error) {
        console.warn("Failed to inject fonts into DOM:", error);
      }
    }
  }
  /**
   * Update styles on the editor container and ProseMirror element.
   *
   * Applies:
   * - Page dimensions (width, height) from converter pageStyles
   * - Page margins (left, right, top for presentation mode)
   * - Accessibility attributes (role, aria-multiline, aria-label)
   * - Typography (font family, font size from document defaults)
   * - Mobile-specific styles (transform-origin, touch-action)
   * - Line height and padding for proper text layout
   *
   * @param editor - The editor instance
   * @param element - The container element to style
   * @param proseMirror - The ProseMirror content element (.ProseMirror)
   */
  updateEditorStyles(editor, element, proseMirror) {
    if (!proseMirror || !element) {
      return;
    }
    this.#applyBaseStyles(editor, element, proseMirror);
    if (editor.isWebLayout()) {
      this.#applyWebLayoutStyles(element, proseMirror);
    } else {
      this.#applyPrintLayoutStyles(editor, element, proseMirror);
    }
  }
  /**
   * Apply base styles common to both web and print layouts.
   * Includes accessibility attributes, colors, typography, and mobile styles.
   */
  #applyBaseStyles(editor, element, proseMirror) {
    proseMirror.setAttribute("role", "document");
    proseMirror.setAttribute("aria-multiline", "true");
    proseMirror.setAttribute("aria-label", "Main content area, start typing to enter text.");
    proseMirror.setAttribute("aria-description", "");
    proseMirror.classList.remove("view-mode");
    element.style.boxSizing = "border-box";
    element.style.isolation = "isolate";
    proseMirror.style.outline = "none";
    proseMirror.style.border = "none";
    element.style.backgroundColor = "#fff";
    proseMirror.style.backgroundColor = "#fff";
    const { typeface, fontSizePt, fontFamilyCss } = editor.converter.getDocumentDefaultStyles() ?? {};
    const resolvedFontFamily = fontFamilyCss || typeface;
    if (resolvedFontFamily) {
      element.style.fontFamily = resolvedFontFamily;
    }
    if (fontSizePt) {
      element.style.fontSize = `${fontSizePt}pt`;
    }
    proseMirror.style.lineHeight = String(DEFAULT_LINE_HEIGHT);
    element.style.transformOrigin = "top left";
    element.style.touchAction = "auto";
    const elementStyleWithVendor = element.style;
    if ("webkitOverflowScrolling" in element.style || typeof elementStyleWithVendor === "object") {
      elementStyleWithVendor.webkitOverflowScrolling = "touch";
    }
  }
  /**
   * Apply styles for web layout mode (OOXML ST_View 'web').
   * Content reflows to fit container width - CSS handles dimensions and text reflow.
   * This method resets inline styles that print mode may have set.
   */
  #applyWebLayoutStyles(element, proseMirror) {
    element.style.width = "";
    element.style.minWidth = "";
    element.style.minHeight = "";
    element.style.paddingLeft = "";
    element.style.paddingRight = "";
    proseMirror.style.paddingTop = "0";
    proseMirror.style.paddingBottom = "0";
  }
  /**
   * Apply styles for print layout mode (OOXML ST_View 'print').
   * Fixed page dimensions with document margins for print fidelity.
   */
  #applyPrintLayoutStyles(editor, element, proseMirror) {
    const { pageSize, pageMargins } = editor.converter.pageStyles ?? {};
    if (pageSize?.width != null) {
      element.style.width = `${pageSize.width}in`;
      element.style.minWidth = `${pageSize.width}in`;
      if (pageSize?.height != null) {
        element.style.minHeight = `${pageSize.height}in`;
      }
    }
    if (pageMargins) {
      element.style.paddingLeft = `${pageMargins.left}in`;
      element.style.paddingRight = `${pageMargins.right}in`;
    }
    if (editor.presentationEditor && pageMargins?.top != null) {
      proseMirror.style.paddingTop = `${pageMargins.top}in`;
    } else if (editor.presentationEditor) {
      proseMirror.style.paddingTop = `${DEFAULT_FALLBACK_MARGIN_INCHES}in`;
    } else {
      proseMirror.style.paddingTop = "0";
    }
    proseMirror.style.paddingBottom = "0";
  }
  /**
   * Initialize default styles for the editor container and ProseMirror element.
   *
   * Skipped in headless mode or when suppressDefaultDocxStyles is enabled.
   * Calls updateEditorStyles and initMobileStyles to apply all default styling.
   *
   * @param editor - The editor instance
   * @param element - The container element (defaults to editor.element)
   */
  initDefaultStyles(editor, element = editor.element) {
    if (editor.options.isHeadless || editor.options.suppressDefaultDocxStyles) return;
    if (!element) {
      return;
    }
    const proseMirrorElement = element.querySelector(".ProseMirror");
    const proseMirror = proseMirrorElement instanceof HTMLElement ? proseMirrorElement : null;
    if (!proseMirror) {
      return;
    }
    this.updateEditorStyles(editor, element, proseMirror);
    this.initMobileStyles(editor, element);
  }
  /**
   * Initialize responsive styles for mobile devices.
   *
   * Sets up viewport-based scaling to fit the editor within mobile screen widths.
   * Listens for orientation changes and window resize events to update scaling dynamically.
   *
   * Note: Scaling is skipped in responsive layout mode since content reflows naturally.
   *
   * Scaling calculation:
   * - Maintains minimum side margins (MIN_MOBILE_SIDE_MARGIN_PX)
   * - Scales editor down if viewport is narrower than content
   * - Scales to 1.0 (100%) if viewport is wide enough
   *
   * Event listeners are tracked for proper cleanup in destroy().
   *
   * @param editor - The editor instance
   * @param element - The container element to apply mobile scaling to
   */
  initMobileStyles(editor, element) {
    if (!element) {
      return;
    }
    if (editor.isWebLayout()) {
      return;
    }
    const initialWidth = element.offsetWidth;
    const updateScale = () => {
      const elementWidth = initialWidth;
      const availableWidth = document.documentElement.clientWidth - MIN_MOBILE_SIDE_MARGIN_PX;
      editor.options.scale = Math.min(1, availableWidth / elementWidth);
      const superEditorElement = element.closest(".super-editor");
      const superEditorContainer = element.closest(".super-editor-container");
      if (!(superEditorElement instanceof HTMLElement) || !(superEditorContainer instanceof HTMLElement)) {
        return;
      }
      if (editor.options.scale < 1) {
        superEditorElement.style.maxWidth = `${elementWidth * editor.options.scale}px`;
        superEditorContainer.style.minWidth = "0px";
        element.style.transform = `scale(${editor.options.scale})`;
      } else {
        superEditorElement.style.maxWidth = "";
        superEditorContainer.style.minWidth = "";
        element.style.transform = "none";
      }
    };
    updateScale();
    const handleResize = () => {
      if (this.resizeTimeoutId !== null) {
        clearTimeout(this.resizeTimeoutId);
      }
      this.resizeTimeoutId = setTimeout(() => {
        updateScale();
        this.resizeTimeoutId = null;
      }, RESIZE_DEBOUNCE_MS);
    };
    if ("orientation" in screen && "addEventListener" in screen.orientation) {
      screen.orientation.addEventListener("change", handleResize);
      this.eventListenerCleanups.push(() => {
        screen.orientation.removeEventListener("change", handleResize);
      });
    } else {
      const mediaQueryList = typeof window.matchMedia === "function" ? window.matchMedia("(orientation: portrait)") : null;
      if (mediaQueryList?.addEventListener) {
        mediaQueryList.addEventListener("change", handleResize);
        this.eventListenerCleanups.push(() => {
          mediaQueryList.removeEventListener("change", handleResize);
        });
      }
    }
    window.addEventListener("resize", handleResize);
    this.eventListenerCleanups.push(() => {
      window.removeEventListener("resize", handleResize);
    });
  }
  /**
   * Register a copy event handler for transforming copied content.
   *
   * Intercepts the native copy event to apply custom transformations to the clipboard data.
   * Specifically transforms lists to ensure proper HTML structure when pasting into other applications.
   *
   * The handler:
   * - Serializes the current selection to HTML
   * - Applies list transformation via transformListsInCopiedContent
   * - Sets the transformed HTML on the clipboard
   *
   * Wraps clipboard operations in try-catch to handle permission errors or API failures.
   * The listener is tracked for cleanup in destroy().
   *
   * @param _editor - The editor instance (unused, kept for interface compatibility)
   */
  registerCopyHandler(_editor) {
    const dom = this.view?.dom;
    if (!dom || !canUseDOM()) {
      return;
    }
    const copyHandler = (event) => {
      try {
        const clipboardData = event.clipboardData;
        if (!clipboardData) return;
        event.preventDefault();
        if (!this.view) return;
        const { from: from3, to } = this.view.state.selection;
        const slice2 = this.view.state.doc.slice(from3, to);
        const fragment = slice2.content;
        const div2 = document.createElement("div");
        const serializer = superEditor_converter.DOMSerializer.fromSchema(this.view.state.schema);
        div2.appendChild(serializer.serializeFragment(fragment));
        const html = transformListsInCopiedContent(div2.innerHTML);
        clipboardData.setData("text/html", html);
      } catch (error) {
        console.warn("Failed to transform copied content:", error);
      }
    };
    dom.addEventListener("copy", copyHandler);
    this.eventListenerCleanups.push(() => {
      dom.removeEventListener("copy", copyHandler);
    });
  }
  /**
   * Initialize developer tools integration.
   *
   * Exposes editor and converter instances to window.superdocdev in development mode or when isDebug is enabled.
   * Skipped for header/footer editors to avoid cluttering the global scope.
   *
   * Available in:
   * - Development builds (process.env.NODE_ENV === 'development')
   * - Production builds with editor.options.isDebug = true
   *
   * Wraps in try-catch to handle cases where window is frozen or property assignment fails.
   *
   * @param editor - The editor instance to expose to developer tools
   */
  initDevTools(editor) {
    if (editor.options.isHeaderOrFooter) return;
    if (vue.process$1.env.NODE_ENV === "development" || editor.options.isDebug) {
      try {
        window.superdocdev = {
          converter: editor.converter,
          editor
        };
      } catch (error) {
        console.warn("Failed to initialize developer tools:", error);
      }
    }
  }
}
const BLANK_DOCX_BASE64 = `UEsDBBQAAAAIAAAAIQAykW9XXgEAAKUFAAATABwAW0NvbnRlbnRfVHlwZXNdLnhtbFVUCQADMNDOEjDQzhJ1eAsAAQT1AQAABBQAAAC1lMtqwzAQRfeF/oPRNthKuiilxMmij2UbaPoBijRORPVCmrz+vuM4NaWkMeSxMcgz994zQsxwvLEmW0FM2ruSDYo+y8BJr7Sbl+xz+po/sCyhcEoY76BkW0hsPLq9GU63AVJGapdKtkAMj5wnuQArUuEDOKpUPlqBdIxzHoT8EnPgd/3+PZfeITjMsfZgo+EzVGJpMHvZ0O+GJIJJLHtqGuuskokQjJYCqc5XTv1JyfcJBSl3PWmhQ+pRA+MHE+rK/wF73TtdTdQKsomI+CYsdfG1j4orL5eWlMVxmwOcvqq0hFZfu4XoJaREd25N0Vas0K7XxeGWdgaRlJcHaa07IRJuDaTLEzS+3fGASIJrAOydOxHWMPu4GsUv806QinKnYmbg8hitdScE0hqA5js4m2NncyySOifRh0RrJZ4w9s/eqNU5DRwgoj7+6tpEsj57PqhXkgJ1IJvvluzoG1BLAwQKAAAAAACTZE1bAAAAAAAAAAAAAAAACQAcAGRvY1Byb3BzL1VUCQADhhztaIcc7Wh1eAsAAQT1AQAABBQAAABQSwMEFAAAAAgAAAAhACEYr1llAQAAxQIAABAAHABkb2NQcm9wcy9hcHAueG1sVVQJAAMw0M4SMNDOEnV4CwABBPUBAAAEFAAAAJ1STU/DMAy9I/Efqt63dBwmNHlBaAhx4GPSCpyjxG0j0iRKson9e5wVSoEbOdnP9st7TuDqvTfFAUPUzq7LxbwqC7TSKW3bdflc384uyyImYZUwzuK6PGIsr/j5GWyD8xiSxlgQhY3rskvJrxiLssNexDmVLVUaF3qRKA0tc02jJd44ue/RJnZRVUuG7wmtQjXzI2E5MK4O6b+kysmsL77UR098HGrsvREJ+WOeNHPlUg9sRKF2SZha98grgscEtqLFyBfAhgBeXVAx9wwBbDoRhEy0vwxOMrj23mgpEu2VP2gZXHRNKp5OYos8DWzaAmRgh3IfdDpmqmkK99ri6YIhIFVBtEH47gROMthJYXBD1nkjTERg3wBsXO+FJTo2RsT3Fp997W7yFj5HfoITi686dTsvJP4yO8FhRygqUj8KGAG4o8cIJrPTrG1RffX8LeT1vQy/ki+W84rOaV9fGLkevwv/AFBLAwQUAAAACAAAACEACvOn+GYBAADtAgAAEQAcAGRvY1Byb3BzL2NvcmUueG1sVVQJAAMw0M4SMNDOEnV4CwABBPUBAAAEFAAAAJ2SXU+DMBSG7038D6T3UGBqDAGWTLMrZ0yc0XhX27Otjn6k7cb27y0wmMRdeXc+nvP29G3z6UFUwR6M5UoWKIliFICkinG5LtDbch7eo8A6IhmplIQCHcGiaXl9lVOdUWXgxSgNxnGwgVeSNqO6QBvndIaxpRsQxEaekL65UkYQ51OzxprQLVkDTuP4DgtwhBFHcCMY6kERnSQZHST1zlStAKMYKhAgncVJlOAz68AIe3Gg7fwiBXdHDRfRvjnQB8sHsK7rqJ60qN8/wR+Lp9f2qiGXjVcUUJkzmjnuKihzfA59ZHdf30BdVx4SH1MDxClTPnO6DWZgJKlapq83jm/hWCvDrJ8eZR5jYKnh2vl37LRHBU9XxLqFf9gVBzY7jo/5224mDOx58y/KtCWGND+Z3K0GLPDmZJ2Vfed98vC4nKMyjdObMEnD5G6Zpll8m8XxZ7PdaP4sKE4L/FuxF+gMGn/Q8gdQSwMECgAAAAAAk2RNWwAAAAAAAAAAAAAAAAYAHABfcmVscy9VVAkAA4Yc7WiHHO1odXgLAAEE9QEAAAQUAAAAUEsDBBQAAAAIAAAAIQAekRq36QAAAE4CAAALABwAX3JlbHMvLnJlbHNVVAkAAzDQzhIw0M4SdXgLAAEE9QEAAAQUAAAArZLBasMwDEDvg/2D0b1R2sEYo04vY9DbGNkHCFtJTBPb2GrX/v082NgCXelhR8vS05PQenOcRnXglF3wGpZVDYq9Cdb5XsNb+7x4AJWFvKUxeNZw4gyb5vZm/cojSSnKg4tZFYrPGgaR+IiYzcAT5SpE9uWnC2kiKc/UYySzo55xVdf3mH4zoJkx1dZqSFt7B6o9Rb6GHbrOGX4KZj+xlzMtkI/C3rJdxFTqk7gyjWop9SwabDAvJZyRYqwKGvC80ep6o7+nxYmFLAmhCYkv+3xmXBJa/ueK5hk/Nu8hWbRf4W8bnF1B8wFQSwMECgAAAAAAk2RNWwAAAAAAAAAAAAAAAAUAHAB3b3JkL1VUCQADhhztaIcc7Wh1eAsAAQT1AQAABBQAAABQSwMEFAAAAAgAoWRNW+xw0GIQAgAAtAcAABIAHAB3b3JkL2ZvbnRUYWJsZS54bWxVVAkAA54c7WieHO1odXgLAAEE9QEAAAQUAAAAvZPBbqMwEIbvlfoOlu8NhpA0RSFV222kvexh1T6AY0ywFtvI44Tk7dcYiBSyuy3tqiCEGf75mPnHLO8PskR7bkBoleJwQjDiiulMqG2KX1/WNwuMwFKV0VIrnuIjB3y/ur5a1kmulQXk8hUkkqW4sLZKggBYwSWFia64ci9zbSS17tFsA0nNr111w7SsqBUbUQp7DCJC5vj6CrmjZZn3oHSeC8a/abaTXFkPCQwvHVYrKEQFZ8j6Pcham6wymnEA170sW6ikQp2zwviCJgUzGnRuJ663rjbPc4yQ+JUsB5TZOEr0Z8qc8cM40KIDBS7zAiaycbD5CSayIexjZQ0p2W4UJ5r2FTW3Jn0IhMxmxThmP8GgyaWWFhSKCywf1+/sxDxKNwgkWfJ9q7Shm9KR3CZDbosgD0btZJobaieO+j6Qdwiv2mK6nxLViaLSUV6E5IB+8Br91JKqXtZJK6o08NCp97RMMWkanZMpmZHYXZFbxTg4T2EFNcDtKYUMBTmVojz2743/6kBSCcuKXrGnRjQdD0Ugtk6ygw1J8TMhJHper3EbCVP85CK3i9ljF4maSvxx10WmpwhpIsxz/GPYcpjnnDT915dB6+Bf/HzSOyO4aRx908tb59+d97TxMv60l1Jn3PzbzFwcePYRJ+PpVzv54MZevunho9uPsfewPT/rIdQC4P/sx4evdrFfwuo3UEsDBBQAAAAIAAAAIQCWFrgr1QIAAIgLAAARABwAd29yZC9kb2N1bWVudC54bWxVVAkAAzDQzhIw0M4SdXgLAAEE9QEAAAQUAAAApZZbb9sgFMffJ+07WH5v8S1OYjWttGab+jCpWrcPQIDEqAYsILd9+h3s+LJ5qxz3CXPg/PjDORxz93AShXdg2nAlV354G/gek0RRLncr/+ePLzcL3zMWS4oLJdnKPzPjP9x//HB3zKgie8Gk9QAhTXYsycrPrS0zhAzJmcDmVnCilVFbe0uUQGq75YSho9IURUEYVF+lVoQZA+s9YnnAxr/gyGkcjWp8BGcHTBDJsbbs1DHCqyEztESLISiaAIIdRuEQFV+NSpFTNQAlk0CgakCaTSP9Y3PpNFI0JM2nkeIhaTGNNEgnMUxwVTIJg1ulBbbQ1TsksH7dlzcALrHlG15wewZmkDYYzOXrBEXg1RJETK8mzJFQlBUxbShq5e+1zC7+N62/k57V/pem9WDFuGVhuSViJ1sY2/jqMWdXu68vhaU6NaRZAeeopMl52VYHMZUGg3kDObx1AAdR+G1lC0detf+VtnUdhg44Rv4ldqKolb9NDIMR0XSI1mOMhD/XbJQIyOBu4UlH0zvccGTxaQDRAJASNvJn0TAWFwYi3e12HD7yWjWctOVw2uNME9MD0P1ViChudLjGufdYhlqaX4drYoScL7Y4xybvE9l1G5y1uLPonXe5e9+l+qrVvuxo/H20p668HuV1GwzSvyNYmveJeclxCVVXkOxpJ5XGmwIUwVXz4LZ4VQS8Ol1d49U3wGti7VUJ5Lmq5d/DO22j6Nm1JQwkWYk1foI0T8JlmqTz0K+s8Jezzhoks+VivpyBNYM3If0OJkiveD3/1JqetTPGYZA8fm6Na7bF+8IOpz/3JiMnwzBin/VYfiV89/ILBqFihVGUBG4iJHQ4W8A3qid8w45oFRTWMKmnaL7LbdfdKGuV6PoF2/ZGc4Ypg3XnUdXdKmV73d3eVt3LckQVBqymxITVcyozvIe/aheSrOCSPXNLQGWcVqOo2Xf1WUcEdU/o+99QSwMEFAAAAAgAAAAhAMrnZYorBAAAvgwAABEAHAB3b3JkL3NldHRpbmdzLnhtbFVUCQADMNDOEjDQzhJ1eAsAAQT1AQAABBQAAAC1V22PmzgQ/n7S/QfE58uG1ySLmq3yervV5lqVre6zAZNYa2Nkm03T0/33GwwO9BZVSav9hJln5pnxeGYM795/ZdR6wUISXsxt98axLVykPCPFfm5/edqOZrYlFSoyRHmB5/YJS/v93e+/vTtGEisFatICikJGLJ3bB6XKaDyW6QEzJG94iQsAcy4YUvAq9mOGxHNVjlLOSqRIQihRp7HnOBO7peFzuxJF1FKMGEkFlzxXtUnE85ykuH0YC3GJ38ZkzdOK4UJpj2OBKcTAC3kgpTRs7GfZADwYkpcfbeKFUaN3dJ0LtnvkIjtbXBJebVAKnmIp4YAYNQGSonMcvCI6+74B3+0WNRWYu45e9SMPryPwXhFMUvz1Oo5ZyzEGyz4Pya7jmZx5SNbj+blgegRZdRWF55s46kdt3uOSmcoO19GZMxrXtkihA5KHPiO+boPhme7EunxLekkFNtAjSQQSp375sTR62BdcoIRCOFCGFlSSpaOzmqOsH1ZTHZbJg6WTa9/B1PnGObOOUYlFCq0HI8tz7HENQMHzPFZIAVEkS0ypnmEpxQj8HqO9QAymj5FomwznqKLqCSWx4iUovSDY3tRQpgckUKqwiEuUAtuKF0pwavQy/hdXK5hkAhqttdBzrVvFzYwEiwIx2PB3c2/HM1xHVgly+cnYxrsb9l3+3xGHmS5Ihp/qRMfqRPEWgo/JN7wosg+VVAQY9fT7hQh+FAAuas8foTSeTiXeYqQqSNMbOdMnsaWk3BEhuHgoMqiNN3NG8hwLcECg1nZQPkTwo87zPUYZXKVv5LeS+G9Qhs70n6Asn5dcKc7uT+UBcv1rJ6nrfdwvX/ggyKRZfOZcnVVhbPnr6bKJtEYvQXzXCVabQWTibN1hm0XgO/4gsnLXbjCMhLPlaggJboOJuxhCJqG3CcIhZLH0Zv5sCFku3Wk4iKxW/srfDiIbZz28n83Km04HY9vees7tpj2d9kxYVH9qfBJmVTe2xRqLFWKJIMja1R8j41ojEc9LUhg8wTClcR+Jq8SAo1EDSIYo3UKJGcBp5BmR5Rrnek13SOw73lZDDEphyn44c9VTG4s/Ba/KBj0KVDYNa1TcIGgtSaEeCTNyWSWxsSrgXulBVZF9fBE6T116jpGCBtCD7xHpRtK6uBh9idtGoyKumwTvUFk2vZbs3blNyf6g3Lo9FLxl8M2qX5K912KexrwG0y8orXcG2u2ik3lG1tPzjczvZIGRBZ0sNLKwk02MbFLLDjBdBVx1z9D2ZlnLc04pP+LsvsNficwlmBI48fjEku5uu2kwSiTMoRKuQcWFwf7QmBtEGU8f6vs6aOT+YhGuF860gUN9fSo9qiC1n3G+RBJnLWZMw8b0n8nEmbjuajYKZpvb0WYaBKOZu7wdTafO1PW3rufPnH/bPjA/Hnf/AVBLAwQUAAAACAAAACEA24Vsw30EAACXHQAAEgAcAHdvcmQvbnVtYmVyaW5nLnhtbFVUCQADMNDOEjDQzhJ1eAsAAQT1AQAABBQAAADNmc1u4zYQx+8F+g6CgB4Tifq2sM4iySZFFttF0U3RMy3RlhB+CBRlx9d9mT5CH2tfoaRkyXLkxJIctz4pJjk/zQxnyL+dDx+fCdaWiOcpo1MdXJq6hmjE4pQupvqfj/cXga7lAtIYYkbRVF+jXP949fNPH1YhLcgMcblQkwyah6ssmuqJEFloGHmUIALzS5JGnOVsLi4jRgw2n6cRMlaMx4ZlArP8K+MsQnkuObeQLmGub3DRcz9azOFKGiugY0QJ5AI9bxlgMMQ1JkbQBVkjQDJCC3RR9mCUZyivOiBnFEh61SG540h7gvPGkawuyR9HsrukYBypU06kW+AsQ1ROzhknUMiPfGEQyJ+K7EKCMyjSWYpTsZZM06sxMKVPIzySVg2B2PFggm8QFiNsxzWFTfWC03Bjf9HYK9fDyn7zaCwQ7vda+bqJgZ4FzkVty/vkrjL/xKKCICrKrBkcYZlHRvMkzZrTgYylycmkhizfSsCSYL052UDPVnvtaPtUbcMW2Mf9zd4RXHn+NhGYPXZTIRqLPi7svrP2hMgK3r54VGpayQU9D58aYHUAXoR6XhY1I9gwjGjb3YqT9myrmuM1nDRuccY50wLExSCEZdd+qIcyb7HyWMTJMFy9R4ayhQImME/aRDQsQLfBrUkr39niuKb6lbMi29LS42gP2+N1RYcFaHovdzDLj3PmWwIzeeqSKHxYUMbhDEuPZKtpslu0cge0qlzVQ6s6QKv3WisLSFOnln4lhRqc5YLDSHwtiLbz6UFWuxR8khlyJFUeV4OVprueC8RvOIJPaomi0Fy9LVxCeQUAD1jejenrhpohBRbpF7RE+HGdoXpNsp7xNP5NzWE1V60VJMP1Chfc3Tp3ZlDN4KWaSOWjcioUGZb3remYE9M0QelD6WPjRGUnZeg9aQZnBcZINMRHeQfVUz++/9OMf47qUYzmm+XZ71w9UqrCVMNT3bdKTxJIF6Ugtj1TrTWaxXzzuGdU5Cq5eZTKOvy2JjOGS9NrmbedgZRKcIzmUGZmAyspRunYy0yATibsckTeZ/JSXCK14ujMsKF5AY4zLjG3rOAp4tpXtGpl58VolHcXDsua1cma+/5Z+/H976F5s4A3Lm9/ydXqO1neytru2LAE2Xsa7AQJGtxwVhD83x3nnGXHyTycdce5Z9pxjj3yCH/vjvPOtONcc+RR/n4d559lx7n+yLP6P+q44Ew7znNGHuHHd5yxo24PSl8wRvq6gW8C++b6OOl7d+c5wL91+kjf+57bGKMoJRDv3cdfwOU7a9+echVMRhYlZivEvyAh92J/RNbgiA6p1p5aEtwcE9IfjEC6PyJ7X0Q8XSQDBCUIeoTUVX/3I0N6s+acwTt0SP71VGynKzp3cEiHhFtPOXWyovOGF11HU/Uquq4AOknR+YN36JAC6ilaTld0wfCQDmiXnoriZEU3GV50HVnxStF1NQAt737auvPVD2dhXJQ/q5WDMlTHn3jWy5/LHpprv34X3cO09jGdwHWB7wDwOhO0mUbrH6pX/wJQSwMEFAAAAAgAAAAhAL5+dmJWAQAA0AMAABQAHAB3b3JkL3dlYlNldHRpbmdzLnhtbFVUCQADMNDOEjDQzhJ1eAsAAQT1AQAABBQAAACd01FvwiAQAOD3JfsPhHelumlMYzVZFpe9LEu2/QAKV0sGXAO46n79aLWuiy92T0DLfbnjYLneG02+wHmFNqOTcUIJWIFS2W1GP943owUlPnAruUYLGT2Ap+vV7c2yTmvI3yCEuNOTqFifGpHRMoQqZcyLEgz3Y6zAxp8FOsNDXLotM9x97qqRQFPxoHKlVTiwaZLM6Ylx1yhYFErAI4qdARvaeOZARxGtL1XlO62+RqvRycqhAO9jPUYfPcOVPTOT+wvIKOHQYxHGsZhTRi0VwydJOzP6F5gNA6YXwFzAfpixOBksRvYdJYc587OjZM/5XzI9QO4GEdO7Lo9maMJ7lpdBlsO4rkesieWBl9yXfRGGFTg7cwfTnLcR6fPWouO5jlK8QSReAtLC5NiFZiDHxpKuBNKeC13FJ4ZVUEZ9wwbdg8Pag2PNZ6411q8vT3HB/rzD1Q9QSwMEFAAAAAgAAAAhAD+v4WZfDwAADaYAAA8AHAB3b3JkL3N0eWxlcy54bWxVVAkAAzDQzhIw0M4SdXgLAAEE9QEAAAQUAAAA3Z1tc9s2Esff38x9B45e9V6ksp5lT92O7STnzCWpWzvX1xAJWaj5oCOpOO6nPwB8EKUlKC64UdRMZlqL4v4I4L+7xIIU+dMvXwLf+czjREThZW/w41nP4aEbeSJ8vOx9enj7at5zkpSFHvOjkF/2XnjS++Xnf/7jp+eLJH3xeeJIQJhcBO5lb5Wm64t+P3FXPGDJj9Gah/LLZRQHLJUf48d+wOKnzfqVGwVrloqF8EX60h+enU17OSZuQ4mWS+Hy15G7CXiYavt+zH1JjMJkJdZJQXtuQ3uOYm8dRy5PEtnpwM94ARNhiRmMASgQbhwl0TL9UXYmb5FGSfPBmf4r8LeACQ4wBICpy7/gGPOc0ZeWVY7wcJxpyRFehWPXmArA26AQw1HRDvU/ZV5hJV7qrXC4QqO+smUpW7FkVSVyXAcnJe4lUOMduBfvHsMoZgtfkqQHOdIJHA12MhXU/5xMWKfogqPHpfezjC4vcl/zJdv4aaI+xndx/jH/pP/3NgrTxHm+YIkrxGXvKhZMDvHzBWdJepUI9iBbLg8fCNmS26swEerLlfqjsrObXPYeRCBD+SN/dn6PAhY6P1xH3otzc/+vXl8d6InHodzzM/Mve8NsU/JXuWFcbLlJ9rf5LHwstvHw1af7ausqmxbCk01i8av7K204GF/44pGlm1g2S33ShCwRxd6N7Db/km5k++XO/Xw8+vujtC4/ZXvtDalMGDJ93GdZTH7Ll+8j94l796n84rJ31ss2fnp3F4solpnqsnd+nm+854G4FZ7Hw8qO4Up4/I8VDz8l3Ntu/+2tzjb5BjfahPLv0WyqZfYT780Xl69V7pLfhkzp9VEZaG02Yntwbf6/AjbIB7jOfsWZSuDOYB9xjkYMlUVS6W09c7PX9wH6QKNjHWh8rANNjnWg6bEONDvWgebHOtD51z6QCD2Z3wf1hwHUQxxDNKI5hmBDcwyxhOYYQgXNMUQCmmNwdDTH4MdojsFNEZw0ck1eWHH2kcHbm7mHzxF23MOnBDvu4TOAHfdwwrfjHs7vdtzD6dyOezh723EPJ2s8N5tqOe9kmIVp5yhbRlEaRil31PS0M42FkqWrWhqeOunxmKSTBJgss+Un4s40l+nPhz1k0u18nqqCzomWzlI8quKkc8N5+Jn70Zo7zPMkjxAYc1k+GUbExqdjvuQxD11O6dh0UF+E3Ak3wYLAN9fskYzFQ494+AoiSVIoHZpt0pUKEkHg1AFz44hgzsLI8sN7kXQfKwVxrje+z4lYH2lcTLO61wYa07000JjulYHGdC8MKppRDVFOIxqpnEY0YDmNaNwy/6Qat5xGNG45jWjcclr3cXsQqc/3Zx2D9mt3N36UUCS8e/EY6vXTzqR8zdS5YzF7jNl65ahl54MzLfRx9JLzA8U5rSRRzeu1i6hVZxFuug/oDo0quEoeUXiVPKIAK3ndQ+yDnCarCdotTT1zv1mktUHbviq4Z/4mm9B2jzaWdvewbQC8FXFCFgb1WAIP/qims7dEU71tK7s3bMvqHlb7WYm0eTmSoJV+5D7RpOHblzWPZVn21Jn0NvL96Jl7dMT7NI4yX6uG/HDYOuTfBOsVS0QCEO1P9cUdDM4Htu7coTufiZBGtzevAiZ8h24Gcfvw4b3zEK1VmakGhgZ4HaVpFJAx85XAH/7gi3/RNPBKFsHhC1Fvr4iWhzTsRhCcZDJS5BGR5DRThILkHKp5/+Evi4jFHg3tLubZTUMpJyLes2DtU8WWzIvPMv8QzIY0778sFmpdiCqoHkhglWXDZLP4k7vdU93HyCFZGfp1k+r1Rz3V7X61dwfXfZqwg+s+RdBqytOD8l+Czu7gund2B0fV2RufJYkwXkK15lF1t+BR97d78ZfzIj+KlxufbgALINkIFkCyIYz8TRAmlD3WPMIOax51fwldRvMIluQ079+x8MjE0DAqJTSMSgYNo9JAw0gF6H6HTgXW/TadCqz7vToZjGgKUIFR+Rnp6Z/oKk8FRuVnGkblZxpG5WcaRuVno9cOXy7lJJjuFFNBUvlcBUl3oglTHqyjmMUvRMg3Pn9kBAukGe0ujpbq1yRRmN3ETTGd3SxSysl2hqMS+Q++IGuaYlG2i2BFlPl+FBGtrW1PONpy9961Q2b65xydm3DnM5evIt/jsaFPjfXy/Zq5Ai6dtr9Y8l48rlLnflWu9lcx07ODlkXBvmN2+IB1Yz4dNl5m8sQmKBoKf0wxHbU3HgLj8WHj7Uxix3LS0hIec3rYcjtL3rGctbSEx5y3tBwBy6Z4eM3ip1pHmDX5T1njGZxv1nhhvjCuPWyTI5WWdS44a/KinVBxrlxXXS2A6rSLGbN9u+Ax22OiyEzBhJOZ0jquzIimAPudfxZJ7Rr1gevf5d0TIO+PW2fO3zZRCi5TD9v/qOudnDiFCXdqOaP2F652sox5HFunGzOidd4xI1onIDOiVSYymqNSkpnSOjeZEa2TlBmBzlbwjIDLVtAel62gvU22ghSbbNVhFmBGtJ4OmBHoQIUIdKB2mCmYEahABeZWgQop6ECFCHSgQgQ6UOEEDBeo0B4XqNDeJlAhxSZQIQUdqBCBDlSIQAcqRKADFSLQgWo5tzeaWwUqpKADFSLQgQoR6EAddwxUaI8LVGhvE6iQYhOokIIOVIhABypEoAMVItCBChHoQIUIVKACc6tAhRR0oEIEOlAhAh2ok46BCu1xgQrtbQIVUmwCFVLQgQoR6ECFCHSgQgQ6UCECHagQgQpUYG4VqJCCDlSIQAcqRKADddoxUKE9LlChvU2gQopNoEIKOlAhAh2oEIEOVIhABypEoAMVIlCBCsytAhVS0IEKEehAhYgm/8wvUZpusx/gVz2Nd+wjfueTNer36k+5d9ZQ26OKVplZ7X+LcB1FT07tDw9Ho/YQsfBFpJeoDZfVq9wZ+sLnrzfNv/Bp8RiPtl3Jfwuhr5kC+LitJVhTGTe5fNUSFHnjJk+vWoJZ57gp+1YtwWlw3JR0dVwWN6XI0xEwbkozFeOBwbwpW1fM4RA35eiKIRzhpsxcMYQD3JSPK4YTRyXnfetJy3GalveXAkKTO1YIMzOhyS2hVsa1/daimQlt1TMT2spoJqD0NGLwwppRaIXNKDupYZhhpbYPVDMBKzUkWEkNMPZSQ5S11BBlJzVMjFipIQErtX1yNhOspAYYe6khylpqiLKTGp7KsFJDAlZqSMBK3fGEbMTYSw1R1lJDlJ3UcHKHlRoSsFJDAlZqSLCSGmDspYYoa6khyk5qUCWjpYYErNSQgJUaEqykBhh7qSHKWmqIapJar6LYV0sVc9wkrGKIOyFXDHHJuWJoUS1VrC2rpQrBslqCWtlVS1XR7Kqlqnp21VJVRrtqCehpVy3VCmtXLdUqbFctmaXGVUt1UtsHql21VCc1rloySo2rlhqlxlVLjVLjqiWz1LhqqU5qXLVUJ7V9crarloxS46qlRqlx1VKj1LhqySw1rlqqkxpXLdVJjauW6qTueEK2q5YapcZVS41S46ols9S4aqlOaly1VCc1rlqqkxpXLRmlxlVLjVLjqqVGqXHVkllqXLVUJzWuWqqTGlct1UmNq5aMUuOqpUapcdVSo9S4aumDNBEEj4C6D1icOnTPi7tlySpl3R9O+CmMeRL5n7nn0Hb1PaqX/eed118ptn6dn9w/lWOmnoBe+bmSlz0BNgfqHd955WuqlLFqiZO/5yvfrBucX67NjqgNDxyqhOfXigcAv325lT7Cgsle/RrWHTxUD0as2a4cotheHOZmxeLs262rFvuc7/fl+SJO1Avcsq/Pzoaj0evZdbbXOns12xPn64/y+P3ig9SHJ/pTkv2AVpov1DPF5AiMpvq3V2yZ8viyN8+jNsqe2vT+s18eKZcuP0btW+CKV76xPyuvfNt/H5z68k2+TX2vXwlXa+kmaWXztfBE1jhXRXnZrrfj2VT7ht5ZZ4DLHtPxv92sbkpR9xm8zQjbF8gVF5urL5AbF30tXu1m4zxDo/MMKZ1n2MJ5tmGZ7bcTlF/ZvQYt3WvwfbrXaAjdK9vW0b1GRvcaUbrX6Dtxr2Gzex1yomO4ynAOXSXb1tFVxkZXGVO6yvjEXWVe9ZSx0VNGX8dTRPbfm4TEbzp6xMToERNKj5h8Hx4xPs3c0dEHpkYfmFL6wPTEfcAs++ToiWByrv7tO4F609LWBR6EeoPv1ZTAA2ZGD5hResDsb+sB0yME/pE1nxs1n1NqPj8pzaGys6PH9nCm/rXR+TXFnO/cqPM5pc7nJ67z/AgRTK+sKweVufkD1Q3rX/mLkcon++jXIu1rbnh7kkGvQTu9zO1O1SpsQ5v1Km3jwl3+sHaTQ7X2qHThZ1LLP96FyqGe83fYZy31vrBeseMN9/0PLNs7Wpt39fkyzb4dnM1rvl9kr4Qw2sf62oER0N9tTL/shHm8s5dE5j9qMa6T6keGweHOHiXWcaRb+rC7SeTQ6OXe/fbtrIHut/K2WG51tnlmL3HVxoEpXQ0OpCpz8vle1qO6LHciJR02SjokknSIO/t8/wp3WXFEKjxqVHhEpPDoayn8d1/0Q6o1blRrTKTW+NTUOvbCG1KVSaMqEyJVJqemysnpMG3UYUqkw/TUdDjqahRSklmjJDMiSWanJslpiTBvFGFOJML81EQ46koOUpLzRknOiSQ5PzVJvslyWvZgi/2xzrZSrKNpUtMi2iAv2FBrZNtF7r0L4656fcWXdMP8/En6jctjxyyBtk3W3XpV9PuJx+XgbifLZXqcwunzhDgRbiWqdYOu4VbxJbP6p1m2Hl+z+iAtX6K9L1D5BUWoFrDGaB1YRGu4CbI/hA/vhyq/BDE9mB64Je+bTECAVwwm36Lm3RHL5BZdQ3fXvczecOJzxq8sWX3MZq8B2Fcm20oRrZrUFKpDmztrD92ANige3venW3BUEcvj2khtmGSOz9S/NhpS18PbgasVp2vMVBQ2a3IwYI46cvUOrC6fbN+rsT9We6/dOOTRcChGYwv3FPpSl7pQpZ6R12LO19Jdyk7nD44rn2a3323wuDuco9R4BOqEetg7jnifVT4W9Ylu920oFAmverimvDeyKSjW117lAqneL5GelL9X+y91j5yTZUeuJ61OPuyW6+PlpdSvfKT+tmeHfhgxKjJ7NcbmU90afWU3+0SS/L/peijwo0bX7Xo62AmSAx57cnHfmCO3z9Y0DeB2j65Zsrjmh8qSi+yo+WglMqn4N2xNM3ZgSjmpH9Hir+Tn/wNQSwMECgAAAAAAk2RNWwAAAAAAAAAAAAAAAAsAHAB3b3JkL3RoZW1lL1VUCQADhhztaIcc7Wh1eAsAAQT1AQAABBQAAABQSwMEFAAAAAgAAAAhAGeA/LSbBgAAzSAAABUAHAB3b3JkL3RoZW1lL3RoZW1lMS54bWxVVAkAAzDQzhIw0M4SdXgLAAEE9QEAAAQUAAAA7VlPb9s2FL8P2HcgdHf1x5IsBXUL/23XJm3RpB16ZGRaYkyJAkknMYoCQ3vaZcCAbthlwG47DMMKrMCKXfZhCrTYug8xSnZs0abatE23AksMxCL5e48/vvf4+ExdvHycEnCIGMc0axv2BcsAKIvoCGdx27izN2wEBuACZiNIaIbaxgxx4/KlTz+5CLdEglIEpHzGt2DbSITIt0yTR7Ib8gs0R5kcG1OWQiGbLDZHDB5JvSkxHcvyzRTizAAZTKXam+MxjhDYK1Qal06UD4j8lwledESE7UbljFWJEjua2MUXn/EeYeAQkrYh5xnRoz10LAxAIBdyoG1Y5Z9hXrpoLoWIqJGtyA3Lv4XcQmA0cUo5Fu8vBa2BE7j2Ur8z17+JGwTFZ6mvBMAokiu1N7C251uBs8BWQPNHje6wZTdVfEV/c1N/6HcdV8E3V3h3c43DcND3FLy7wnsb+I7ldMOmgvdWeH8D7w46LWeg4EtQQnA22UT7rSDwF+glZEzJVS089H2r1V/AVyizEl1z+UzUxVoKDygbSkDpXChwBsQsR2MYSVwnF5SDPuY5gTMD5DCjXHZbjm3LwHMtZ/kpLQ63EKxIz7sivtFV8AE8YjgXbeOa1GpUIC+ePXv+8Onzh789f/To+cNfwDaOE6GRuwqzuCr36sev//7+C/DXrz+8evyNHs+r+Jc/f/ny9z9ep14otL598vLpkxffffXnT4818A6D+1X4Hk4RBzfQEbhNU7lAzQRon72dxF4CcVWik8UcZrCQ0aAHIlHQN2aQQA2ui1Q73mUyXeiAV6YHCuHdhE0F1gCvJ6kC3KGUdCnTrul6MVfVCtMs1k/OplXcbQgPdXP31rw8mOYy7rFOZS9BCs1bRLocxihDAhRjdIKQRuwexopdd3DEKKdjAe5h0IVYa5I9vC/0QldxKv0y0xGU/lZss3MXdCnRqe+jQxUp9wYkOpWIKGa8AqcCplrGMCVV5DYUiY7k7oxFisG5kJ6OEaFgMEKc62RusplC9zqUeUvr9h0yS1UkE3iiQ25DSqvIPp30EpjmWs44S6rYz/hEhigEt6jQkqDqDina0g8wq3X3XYzE2+3tOzIN6QOkGJky3ZZAVN2PMzKGSKe8w1IlxXYY1kZHdxorob2NEIFHcIQQuPOZDk9zqid9LZFZ5SrS2eYaVGO1aGeIy1qpKG40jsVcCdldFNMaPjuztcQzg1kKWZ3mGxM1ZAb7TG5GXbySaKKkUsyKTasncZOn8FRabyVQCauizfXxOmPZ2+4xKXPwDjLorWVkYj+1bfYgQfqA2YMYbOvSrRSZ6kWK7VSKTbVyY3XTrtxgrhU9Kc7eUAH9N5XPB6t5zr7aqUso6zVOHW69sulRNsIff2HTh9PsFpJnyXldc17X/B/rmrr9fF7NnFcz59XMv1bNrAoYs3rZU2pJa29+xpiQXTEjaJuXpQ+Xe380lJ1loxRaXjTliXxcTKfgYgbLZ8Co+ByLZDeBuZzGLmeI+UJ1zEFOuSyfjFrdZfE1TXfoaHGPZ5/cbUoBKFb9lrfsl6WamPf6rdVF6FJ92Yp5lYBXKj09icpkKommhkSreToStnVWLEINi8B+HQuz4hV5OAFYXIt77pyRDDcZ0qPCT3P5E++euafrjKku29EsL3TPzNMKiUq4qSQqYZjIw2O9+4x9HYZ6VztaGq3gQ/ja3MwNJFNb4EjuuaYn1UQwbxtj+bNJPqa51MeLTAVJnLWNSCwM/S6ZJWdc9CFP5rByaL7+FAvEAMGpjPWqG0i24mY7LevjJRdaH5/lzHUno/EYRaKmZ9WUY3Ml2tH3BBcNOpWkd5PREdgnU3YbSkN5Lbsw4AhzsbTmCLNKcK+suJauFltReQO02qKQ5AlcnCjVZD6Hl89LOpV1lEzXV2XqTLgfD8/i1H2z0FrSrDlAWrVZ7MMd8hVWTT0rT5vrwsB6/Snx/gdChVqgp9bUU6s7O86wIKhM59fYzan15nueButRa1bqyrK18XKb7h/IyO/LanVKBJ9fkB3L8rt38lpyngnK3pPscizAlOG2cd/yOm7P8XoNK/AGDbfpWo3A6zQbHc9r2gPPtvpd54E0ikhS25vPPZQ/9sls8e6+7N94f5+elNoXIpqatKyDzVK4fH9vO/Xv7wGWlrnvO8OwGXb9RtjsDBtuvxs0wp7fbfT9Xqs/7Pe8IBw+MMBhCXY7zZ7rD4KGb/d6Dde3CvpB2Gi5jtNxW51g4HYeLGwtV37yfWLektelfwBQSwMECgAAAAAAk2RNWwAAAAAAAAAAAAAAAAsAHAB3b3JkL19yZWxzL1VUCQADhhztaIcc7Wh1eAsAAQT1AQAABBQAAABQSwMEFAAAAAgAAAAhALO+ix3+AAAAtgMAABwAHAB3b3JkL19yZWxzL2RvY3VtZW50LnhtbC5yZWxzVVQJAAMw0M4SiBztaHV4CwABBPUBAAAEFAAAAK2TzWrDMBCE74W+g9h7LTttQwmRcymBXFv3AWR7/UP1Y6RNWr99RUoShwbTg44zYme+hdV6860VO6DzvTUCsiQFhqaydW9aAR/F9uEFmCdpaqmsQQEjetjk93frN1SSwpDv+sGzkGK8gI5oWHHuqw619Ikd0ISXxjotKUjX8kFWn7JFvkjTJXfTDMivMtmuFuB29SOwYhzwP9m2afoKX22112joRgX3SBQ28yFTuhZJwMlJQhbw2wiLqAg0KpwCHPVcfRaz3ux1iS5sfCE4W3MQy5gQFGbxAnCUv2Y2x/Ack6GxhgpZqgnH2ZqDeIoJ8YXl+5+TnJgnEH712/IfUEsBAh4DFAAAAAgAAAAhADKRb1deAQAApQUAABMAGAAAAAAAAQAAAKSBAAAAAFtDb250ZW50X1R5cGVzXS54bWxVVAUAAzDQzhJ1eAsAAQT1AQAABBQAAABQSwECHgMKAAAAAACTZE1bAAAAAAAAAAAAAAAACQAYAAAAAAAAABAA7UGrAQAAZG9jUHJvcHMvVVQFAAOGHO1odXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgAAAAhACEYr1llAQAAxQIAABAAGAAAAAAAAQAAAKSB7gEAAGRvY1Byb3BzL2FwcC54bWxVVAUAAzDQzhJ1eAsAAQT1AQAABBQAAABQSwECHgMUAAAACAAAACEACvOn+GYBAADtAgAAEQAYAAAAAAABAAAApIGdAwAAZG9jUHJvcHMvY29yZS54bWxVVAUAAzDQzhJ1eAsAAQT1AQAABBQAAABQSwECHgMKAAAAAACTZE1bAAAAAAAAAAAAAAAABgAYAAAAAAAAABAA7UFOBQAAX3JlbHMvVVQFAAOGHO1odXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgAAAAhAB6RGrfpAAAATgIAAAsAGAAAAAAAAQAAAKSBjgUAAF9yZWxzLy5yZWxzVVQFAAMw0M4SdXgLAAEE9QEAAAQUAAAAUEsBAh4DCgAAAAAAk2RNWwAAAAAAAAAAAAAAAAUAGAAAAAAAAAAQAO1BvAYAAHdvcmQvVVQFAAOGHO1odXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgAoWRNW+xw0GIQAgAAtAcAABIAGAAAAAAAAQAAAKSB+wYAAHdvcmQvZm9udFRhYmxlLnhtbFVUBQADnhztaHV4CwABBPUBAAAEFAAAAFBLAQIeAxQAAAAIAAAAIQCWFrgr1QIAAIgLAAARABgAAAAAAAEAAACkgVcJAAB3b3JkL2RvY3VtZW50LnhtbFVUBQADMNDOEnV4CwABBPUBAAAEFAAAAFBLAQIeAxQAAAAIAAAAIQDK52WKKwQAAL4MAAARABgAAAAAAAEAAACkgXcMAAB3b3JkL3NldHRpbmdzLnhtbFVUBQADMNDOEnV4CwABBPUBAAAEFAAAAFBLAQIeAxQAAAAIAAAAIQDbhWzDfQQAAJcdAAASABgAAAAAAAEAAACkge0QAAB3b3JkL251bWJlcmluZy54bWxVVAUAAzDQzhJ1eAsAAQT1AQAABBQAAABQSwECHgMUAAAACAAAACEAvn52YlYBAADQAwAAFAAYAAAAAAABAAAApIG2FQAAd29yZC93ZWJTZXR0aW5ncy54bWxVVAUAAzDQzhJ1eAsAAQT1AQAABBQAAABQSwECHgMUAAAACAAAACEAP6/hZl8PAAANpgAADwAYAAAAAAABAAAApIFaFwAAd29yZC9zdHlsZXMueG1sVVQFAAMw0M4SdXgLAAEE9QEAAAQUAAAAUEsBAh4DCgAAAAAAk2RNWwAAAAAAAAAAAAAAAAsAGAAAAAAAAAAQAO1BAicAAHdvcmQvdGhlbWUvVVQFAAOGHO1odXgLAAEE9QEAAAQUAAAAUEsBAh4DFAAAAAgAAAAhAGeA/LSbBgAAzSAAABUAGAAAAAAAAQAAAKSBRycAAHdvcmQvdGhlbWUvdGhlbWUxLnhtbFVUBQADMNDOEnV4CwABBPUBAAAEFAAAAFBLAQIeAwoAAAAAAJNkTVsAAAAAAAAAAAAAAAALABgAAAAAAAAAEADtQTEuAAB3b3JkL19yZWxzL1VUBQADhhztaHV4CwABBPUBAAAEFAAAAFBLAQIeAxQAAAAIAAAAIQCzvosd/gAAALYDAAAcABgAAAAAAAEAAACkgXYuAAB3b3JkL19yZWxzL2RvY3VtZW50LnhtbC5yZWxzVVQFAAMw0M4SdXgLAAEE9QEAAAQUAAAAUEsFBgAAAAARABEAqQUAAMovAAAAAA==`;
const BLANK_DOCX_DATA_URI = `data:application/vnd.openxmlformats-officedocument.wordprocessingml.document;base64,${BLANK_DOCX_BASE64}`;
const PIXELS_PER_INCH$1 = 96;
const MAX_HEIGHT_BUFFER_PX = 50;
const MAX_WIDTH_BUFFER_PX = 20;
class Editor extends EventEmitter {
  /**
   * Create a new Editor instance.
   *
   * **Legacy mode (backward compatible):**
   * When `content` or `fileSource` is provided, the editor initializes synchronously
   * with the document loaded immediately. This preserves existing behavior where
   * `editor.view` is available right after construction.
   *
   * **New mode (document lifecycle API):**
   * When no `content` or `fileSource` is provided, only core services (extensions,
   * commands, schema) are initialized. Call `editor.open()` to load a document.
   *
   * @param options - Editor configuration options
   *
   * @example
   * ```typescript
   * // Legacy mode (still works)
   * const editor = new Editor({ content: docx, element: el });
   * console.log(editor.view.state.doc); // Works immediately
   *
   * // New mode
   * const editor = new Editor({ element: el });
   * await editor.open('/path/to/doc.docx');
   * ```
   */
  constructor(options) {
    super();
    this.extensionStorage = {};
    this.#renderer = null;
    this.#isDestroyed = false;
    this.#editorLifecycleState = "initialized";
    this.#sourcePath = null;
    this.presentationEditor = null;
    this.isFocused = false;
    this.fontsImported = [];
    this.options = {
      element: null,
      selector: null,
      isHeadless: false,
      document: null,
      mockDocument: null,
      mockWindow: null,
      content: "",
      // XML content
      user: null,
      users: [],
      media: {},
      mediaFiles: {},
      fonts: {},
      documentMode: "editing",
      mode: "docx",
      role: "editor",
      colors: [],
      converter: null,
      fileSource: null,
      initialState: null,
      documentId: null,
      extensions: [],
      editable: true,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: true,
      isCommentsEnabled: false,
      isNewFile: false,
      scale: 1,
      viewOptions: { layout: "print" },
      annotations: false,
      isInternal: false,
      externalExtensions: [],
      isChildEditor: false,
      numbering: {},
      isHeaderOrFooter: false,
      lastSelection: null,
      suppressDefaultDocxStyles: false,
      jsonOverride: null,
      loadFromSchema: false,
      fragment: null,
      skipViewCreation: false,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error }) => {
        throw error;
      },
      onTrackedChangesUpdate: () => null,
      onCommentsUpdate: () => null,
      onCommentsLoaded: () => null,
      onCommentClicked: () => null,
      onCommentLocationsUpdate: () => null,
      onDocumentLocked: () => null,
      onFirstRender: () => null,
      onCollaborationReady: () => null,
      onException: () => null,
      onListDefinitionsChange: () => null,
      onFontsResolved: null,
      // async (file) => url;
      handleImageUpload: null,
      // Docx xml updated by User
      customUpdatedFiles: {},
      isHeaderFooterChanged: false,
      isCustomXmlChanged: false,
      ydoc: null,
      collaborationProvider: null,
      collaborationIsReady: false,
      shouldLoadComments: false,
      replacedFile: false,
      focusTarget: null,
      permissionResolver: null,
      // header/footer editors may have parent(main) editor set
      parentEditor: null
    };
    const resolvedOptions = { ...options };
    const domAvailable = canUseDOM();
    const isHeadlessRequested = Boolean(resolvedOptions.isHeadless);
    const mountRequested = Boolean(resolvedOptions.element || resolvedOptions.selector);
    const domDocumentForImport = resolvedOptions.document ?? resolvedOptions.mockDocument ?? (domAvailable ? document : null);
    const requiresDomForImport = Boolean(resolvedOptions.html || resolvedOptions.markdown) || (resolvedOptions.mode === "text" || resolvedOptions.mode === "html") && typeof resolvedOptions.content === "string";
    if (!domDocumentForImport && requiresDomForImport) {
      throw new Error(
        "[super-editor] HTML/Markdown import requires a DOM. Provide { document } (e.g. from JSDOM), set DOM globals, or run in a browser environment."
      );
    }
    if (!domAvailable && mountRequested && !isHeadlessRequested) {
      throw new Error(
        "[super-editor] Cannot mount an editor without a DOM. Provide DOM globals (e.g. via JSDOM) or pass { isHeadless: true }."
      );
    }
    if (!domAvailable && !isHeadlessRequested) {
      resolvedOptions.isHeadless = true;
    }
    if (resolvedOptions.isHeadless) {
      resolvedOptions.element = null;
      resolvedOptions.selector = null;
    }
    this.#checkHeadless(resolvedOptions);
    this.setOptions(resolvedOptions);
    this.#renderer = resolvedOptions.renderer ?? (domAvailable ? new ProseMirrorRenderer() : null);
    const { setHighContrastMode } = useHighContrastMode();
    this.setHighContrastMode = setHighContrastMode;
    const useNewApiMode = resolvedOptions.deferDocumentLoad === true;
    if (useNewApiMode) {
      this.#initCore();
      this.#editorLifecycleState = "initialized";
    } else {
      const modes = {
        docx: () => this.#init(),
        text: () => this.#initRichText(),
        html: () => this.#initRichText(),
        default: () => {
          console.log("Not implemented.");
        }
      };
      const initMode = modes[this.options.mode] ?? modes.default;
      initMode();
      this.#editorLifecycleState = "ready";
    }
  }
  /**
   * Command service for handling editor commands
   */
  #commandService;
  #renderer;
  #isDestroyed;
  #editorLifecycleState;
  #sourcePath;
  /**
   * Getter which indicates if any changes happen in Editor
   */
  get docChanged() {
    return this.options.isHeaderFooterChanged || this.options.isCustomXmlChanged || !this.options.initialState.doc.eq(this.state.doc);
  }
  /**
   * Initialize the container element for the editor
   */
  #initContainerElement(options) {
    this.#renderer?.initContainerElement?.(options);
  }
  #shouldMountRenderer() {
    return canUseDOM() && !this.options.isHeadless;
  }
  #getDomDocument() {
    return this.options.document ?? this.options.mockDocument ?? (canUseDOM() ? document : null);
  }
  #emitCreateAsync() {
    setTimeout(() => {
      if (this.isDestroyed) return;
      this.emit("create", { editor: this });
    }, 0);
  }
  /**
   * Assert that the editor is in one of the allowed states.
   * Throws InvalidStateError if not.
   */
  #assertState(...allowed) {
    if (!allowed.includes(this.#editorLifecycleState)) {
      throw new InvalidStateError(
        `Invalid operation: editor is in '${this.#editorLifecycleState}' state, expected one of: ${allowed.join(", ")}`
      );
    }
  }
  /**
   * Wraps an async operation with state transitions for safe lifecycle management.
   *
   * This method ensures atomic state transitions during async operations:
   * 1. Sets state to `during` before executing the operation
   * 2. On success: sets state to `success` and returns the operation result
   * 3. On error: sets state to `failure` and re-throws the error
   *
   * This prevents race conditions and ensures the editor is always in a valid state,
   * even when operations fail.
   *
   * @template T - The return type of the operation
   * @param during - State to set while the operation is running
   * @param success - State to set if the operation succeeds
   * @param failure - State to set if the operation fails
   * @param operation - Async operation to execute
   * @returns Promise resolving to the operation's return value
   * @throws Re-throws any error from the operation after setting failure state
   *
   * @example
   * ```typescript
   * // Used internally for save operations:
   * await this.#withState('saving', 'ready', 'ready', async () => {
   *   const data = await this.exportDocument();
   *   await this.#writeToPath(path, data);
   * });
   * ```
   */
  async #withState(during, success, failure, operation) {
    this.#editorLifecycleState = during;
    try {
      const result = await operation();
      this.#editorLifecycleState = success;
      return result;
    } catch (error) {
      this.#editorLifecycleState = failure;
      throw error;
    }
  }
  /**
   * Initialize core editor services for new lifecycle API mode.
   *
   * When `deferDocumentLoad: true` is set, this method initializes only the
   * document-independent components:
   * - Extension service (loads and configures all extensions)
   * - Command service (registers all editor commands)
   * - ProseMirror schema (derived from extensions, reusable across documents)
   *
   * These services are created once during construction and reused when opening
   * different documents via the `open()` method. This enables efficient document
   * switching without recreating the entire editor infrastructure.
   *
   * Called exclusively from the constructor when `deferDocumentLoad` is true.
   *
   * @remarks
   * This is part of the new lifecycle API that separates editor initialization
   * from document loading. The schema and extensions remain constant while
   * documents can be opened, closed, and reopened.
   *
   * @see #loadDocument - Loads document-specific state after core initialization
   */
  #initCore() {
    if (!this.options.extensions?.length) {
      this.options.extensions = this.options.mode === "docx" ? getStarterExtensions() : getRichTextExtensions();
    }
    this.#createExtensionService();
    this.#createCommandService();
    this.#createSchema();
    this.#registerEventListeners();
  }
  /**
   * Register all event listeners from options.
   *
   * Called once during core initialization. These listeners persist across
   * document open/close cycles since the callbacks are set at construction time.
   */
  #registerEventListeners() {
    this.on("create", this.options.onCreate);
    this.on("update", this.options.onUpdate);
    this.on("selectionUpdate", this.options.onSelectionUpdate);
    this.on("transaction", this.options.onTransaction);
    this.on("focus", this.#onFocus.bind(this));
    this.on("blur", this.options.onBlur);
    this.on("destroy", this.options.onDestroy);
    this.on("trackedChangesUpdate", this.options.onTrackedChangesUpdate);
    this.on("commentsLoaded", this.options.onCommentsLoaded);
    this.on("commentClick", this.options.onCommentClicked);
    this.on("commentsUpdate", this.options.onCommentsUpdate);
    this.on("locked", this.options.onDocumentLocked);
    this.on("collaborationReady", this.#onCollaborationReady.bind(this));
    this.on("comment-positions", this.options.onCommentLocationsUpdate);
    this.on("list-definitions-change", this.options.onListDefinitionsChange);
    this.on("fonts-resolved", this.options.onFontsResolved);
    this.on("exception", this.options.onException);
  }
  /**
   * Load a document into the editor from various source types.
   *
   * This method handles the complete document loading pipeline:
   * 1. **Source resolution**: Determines source type (path/File/Blob/Buffer/blank)
   * 2. **Content loading**:
   *    - String path: Reads file from disk (Node.js) or fetches URL (browser)
   *    - File/Blob: Extracts docx archive data
   *    - Buffer: Processes binary data (Node.js)
   *    - undefined/null: Creates blank document
   * 3. **Document initialization**: Creates converter, media, fonts, initial state
   * 4. **View mounting**: Attaches ProseMirror view (unless headless)
   * 5. **Event wiring**: Connects all lifecycle event handlers
   *
   * Called by `open()` after state validation, wrapped in `#withState()` for
   * atomic state transitions.
   *
   * @param source - Document source:
   *   - `string`: File path (Node.js reads from disk, browser fetches as URL)
   *   - `File | Blob`: Browser file object or blob
   *   - `Buffer`: Node.js buffer containing docx data
   *   - `undefined | null`: Creates a blank document
   * @param options - Document-level options (mode, comments, styles, etc.)
   * @returns Promise that resolves when document is fully loaded and ready
   * @throws {DocumentLoadError} If any step of document loading fails. The error
   *   wraps the underlying cause for debugging.
   *
   * @remarks
   * - Sets `#sourcePath` for path-based sources (enables `save()`)
   * - Sets `#sourcePath = null` for Blob/Buffer sources (requires `saveTo()`)
   * - In browser, string paths are treated as URLs to fetch
   * - In Node.js, string paths are read from the filesystem
   *
   * @see open - Public API that calls this method
   * @see #unloadDocument - Cleanup counterpart that reverses this process
   */
  async #loadDocument(source, options) {
    try {
      const resolvedMode = options?.mode ?? this.options.mode ?? "docx";
      const resolvedOptions = {
        ...this.options,
        mode: resolvedMode,
        isCommentsEnabled: options?.isCommentsEnabled ?? this.options.isCommentsEnabled,
        suppressDefaultDocxStyles: options?.suppressDefaultDocxStyles ?? this.options.suppressDefaultDocxStyles,
        documentMode: options?.documentMode ?? this.options.documentMode ?? "editing",
        html: options?.html,
        markdown: options?.markdown,
        jsonOverride: options?.json ?? null
      };
      if (typeof source === "string") {
        if (typeof vue.process$1 !== "undefined" && vue.process$1.versions?.node) {
          const fs = require("fs");
          const buffer = fs.readFileSync(source);
          const [docx, _media, mediaFiles, fonts] = await Editor.loadXmlData(buffer, true);
          resolvedOptions.content = docx;
          resolvedOptions.mediaFiles = mediaFiles;
          resolvedOptions.fonts = fonts;
          resolvedOptions.fileSource = buffer;
          this.#sourcePath = source;
        } else {
          const response = await fetch(source);
          if (!response.ok) {
            console.debug("[SuperDoc] Fetch failed:", response.status, response.statusText);
            throw new Error(`Fetch failed: ${response.status} ${response.statusText}`);
          }
          const blob = await response.blob();
          const [docx, _media, mediaFiles, fonts] = await Editor.loadXmlData(blob);
          resolvedOptions.content = docx;
          resolvedOptions.mediaFiles = mediaFiles;
          resolvedOptions.fonts = fonts;
          resolvedOptions.fileSource = blob;
          this.#sourcePath = source.split("/").pop() || null;
        }
      } else if (source != null && typeof source === "object") {
        const isNodeBuffer = typeof jszip.Buffer !== "undefined" && (jszip.Buffer.isBuffer(source) || source instanceof jszip.Buffer);
        const isBlob = typeof Blob !== "undefined" && source instanceof Blob;
        const isArrayBuffer = source instanceof ArrayBuffer;
        const hasArrayBuffer = typeof source === "object" && "buffer" in source && source.buffer instanceof ArrayBuffer;
        if (isNodeBuffer || isBlob || isArrayBuffer || hasArrayBuffer) {
          const [docx, _media, mediaFiles, fonts] = await Editor.loadXmlData(
            source,
            isNodeBuffer
          );
          resolvedOptions.content = docx;
          resolvedOptions.mediaFiles = mediaFiles;
          resolvedOptions.fonts = fonts;
          resolvedOptions.fileSource = source;
          this.#sourcePath = null;
        } else {
          const [docx, _media, mediaFiles, fonts] = await Editor.loadXmlData(source, false);
          resolvedOptions.content = docx;
          resolvedOptions.mediaFiles = mediaFiles;
          resolvedOptions.fonts = fonts;
          resolvedOptions.fileSource = source;
          this.#sourcePath = null;
        }
      } else {
        const shouldLoadBlankDocx = resolvedMode === "docx" && !options?.content && !options?.html && !options?.markdown && !options?.json;
        if (shouldLoadBlankDocx) {
          const arrayBuffer = await helpers$1.getArrayBufferFromUrl(BLANK_DOCX_DATA_URI);
          const isNodeRuntime = typeof vue.process$1 !== "undefined" && !!vue.process$1.versions?.node;
          const canUseBuffer = isNodeRuntime && typeof jszip.Buffer !== "undefined";
          const uint8Array = new Uint8Array(arrayBuffer);
          let fileSource;
          if (canUseBuffer) {
            fileSource = jszip.Buffer.from(uint8Array);
          } else if (typeof Blob !== "undefined") {
            fileSource = new Blob([uint8Array]);
          } else {
            throw new Error("Blob is not available to create blank DOCX");
          }
          const [docx, _media, mediaFiles, fonts] = await Editor.loadXmlData(fileSource, canUseBuffer);
          resolvedOptions.content = docx;
          resolvedOptions.mediaFiles = mediaFiles;
          resolvedOptions.fonts = fonts;
          resolvedOptions.fileSource = fileSource;
          resolvedOptions.isNewFile = true;
          this.#sourcePath = null;
        } else {
          resolvedOptions.content = options?.content ?? [];
          resolvedOptions.mediaFiles = options?.mediaFiles ?? {};
          resolvedOptions.fonts = options?.fonts ?? {};
          resolvedOptions.fileSource = null;
          resolvedOptions.isNewFile = !options?.content;
          this.#sourcePath = null;
        }
      }
      this.setOptions(resolvedOptions);
      this.#createConverter();
      this.#initMedia();
      const shouldMountRenderer = this.#shouldMountRenderer();
      if (shouldMountRenderer) {
        this.#initContainerElement(this.options);
        this.#initFonts();
      }
      this.#createInitialState({ includePlugins: !shouldMountRenderer });
      if (!shouldMountRenderer) {
        const tr = this.state.tr.setMeta("forcePluginPass", true).setMeta("addToHistory", false);
        this.#dispatchTransaction(tr);
      }
      if (shouldMountRenderer) {
        this.mount(this.options.element);
        this.#configureStateWithExtensionPlugins();
      }
      if (!shouldMountRenderer) {
        this.#emitCreateAsync();
      }
      if (shouldMountRenderer) {
        this.initDefaultStyles();
        this.#checkFonts();
      }
      const shouldMigrateListsOnInit = Boolean(
        this.options.markdown || this.options.html || this.options.loadFromSchema || this.options.jsonOverride || this.options.mode === "html" || this.options.mode === "text"
      );
      if (shouldMigrateListsOnInit) {
        this.migrateListsToV2();
      }
      this.setDocumentMode(this.options.documentMode, "init");
      this.initializeCollaborationData();
      if (!this.options.ydoc && !this.options.isChildEditor) {
        this.#initComments();
      }
      if (shouldMountRenderer) {
        this.#initDevTools();
        this.#registerCopyHandler();
      }
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      console.debug("[SuperDoc] Document load error:", err.message);
      throw new DocumentLoadError(`Failed to load document: ${err.message}`, err);
    }
  }
  /**
   * Unload the current document and clean up all document-specific resources.
   *
   * This method performs a complete cleanup of document state while preserving
   * the core editor services (schema, extensions, commands) for reuse:
   *
   * **Resources cleaned up:**
   * - ProseMirror view (unmounted from DOM)
   * - Header/footer editors (destroyed)
   * - Document converter instance
   * - Media references and image storage
   * - Source path reference
   * - Document-specific options (content, fileSource, initialState)
   * - ProseMirror editor state
   *
   * **Resources preserved:**
   * - ProseMirror schema
   * - Extension service and registered extensions
   * - Command service and registered commands
   * - Event listeners (registered once during core init, reused across documents)
   *
   * After cleanup, the editor transitions to 'closed' state and can be reopened
   * with a new document via `open()`.
   *
   * Called by `close()` after emitting the `documentClose` event.
   *
   * @remarks
   * This is a critical part of the document lifecycle API that enables efficient
   * document switching. By preserving schema and extensions, we avoid expensive
   * reinitialization when opening multiple documents sequentially.
   *
   * @see close - Public API that calls this method
   * @see #loadDocument - Counterpart method that loads document resources
   */
  #unloadDocument() {
    this.unmount();
    this.destroyHeaderFooterEditors();
    this.converter = void 0;
    if (this.storage.image) {
      this.storage.image.media = {};
    }
    this.#sourcePath = null;
    this.options.initialState = null;
    this.options.content = "";
    this.options.fileSource = null;
    this._state = void 0;
  }
  /**
   * Initialize the editor with the given options
   */
  #init() {
    this.#createExtensionService();
    this.#createCommandService();
    this.#createSchema();
    this.#createConverter();
    this.#initMedia();
    this.on("beforeCreate", this.options.onBeforeCreate);
    this.emit("beforeCreate", { editor: this });
    this.on("contentError", this.options.onContentError);
    const shouldMountRenderer = this.#shouldMountRenderer();
    this.#createInitialState({ includePlugins: !shouldMountRenderer });
    if (!shouldMountRenderer) {
      const tr = this.state.tr.setMeta("forcePluginPass", true).setMeta("addToHistory", false);
      this.#dispatchTransaction(tr);
    }
    if (shouldMountRenderer) {
      this.#initContainerElement(this.options);
      this.#initFonts();
      this.mount(this.options.element);
      this.#configureStateWithExtensionPlugins();
    }
    this.on("create", this.options.onCreate);
    this.on("update", this.options.onUpdate);
    this.on("selectionUpdate", this.options.onSelectionUpdate);
    this.on("transaction", this.options.onTransaction);
    this.on("focus", this.#onFocus.bind(this));
    this.on("blur", this.options.onBlur);
    this.on("destroy", this.options.onDestroy);
    this.on("trackedChangesUpdate", this.options.onTrackedChangesUpdate);
    this.on("commentsLoaded", this.options.onCommentsLoaded);
    this.on("commentClick", this.options.onCommentClicked);
    this.on("commentsUpdate", this.options.onCommentsUpdate);
    this.on("locked", this.options.onDocumentLocked);
    this.on("collaborationReady", this.#onCollaborationReady.bind(this));
    this.on("comment-positions", this.options.onCommentLocationsUpdate);
    this.on("list-definitions-change", this.options.onListDefinitionsChange);
    this.on("fonts-resolved", this.options.onFontsResolved);
    this.on("exception", this.options.onException);
    if (!shouldMountRenderer) {
      this.#emitCreateAsync();
    }
    this.initializeCollaborationData();
    if (shouldMountRenderer) {
      this.initDefaultStyles();
      this.#checkFonts();
    }
    const shouldMigrateListsOnInit = Boolean(
      this.options.markdown || this.options.html || this.options.loadFromSchema || this.options.jsonOverride || this.options.mode === "html" || this.options.mode === "text"
    );
    if (shouldMigrateListsOnInit) {
      this.migrateListsToV2();
    }
    this.setDocumentMode(this.options.documentMode, "init");
    if (!this.options.ydoc && !this.options.isChildEditor) {
      this.#initComments();
    }
    if (shouldMountRenderer) {
      this.#initDevTools();
      this.#registerCopyHandler();
    }
  }
  /**
   * Initialize the editor in rich text mode
   */
  #initRichText() {
    if (!this.options.extensions || !this.options.extensions.length) {
      this.options.extensions = getRichTextExtensions();
    }
    this.#createExtensionService();
    this.#createCommandService();
    this.#createSchema();
    this.on("beforeCreate", this.options.onBeforeCreate);
    this.emit("beforeCreate", { editor: this });
    this.on("contentError", this.options.onContentError);
    const shouldMountRenderer = this.#shouldMountRenderer();
    this.#createInitialState({ includePlugins: !shouldMountRenderer });
    if (shouldMountRenderer) {
      this.#initContainerElement(this.options);
      this.mount(this.options.element);
      this.#configureStateWithExtensionPlugins();
    }
    this.on("create", this.options.onCreate);
    this.on("update", this.options.onUpdate);
    this.on("selectionUpdate", this.options.onSelectionUpdate);
    this.on("transaction", this.options.onTransaction);
    this.on("focus", this.#onFocus.bind(this));
    this.on("blur", this.options.onBlur);
    this.on("destroy", this.options.onDestroy);
    this.on("commentsLoaded", this.options.onCommentsLoaded);
    this.on("commentClick", this.options.onCommentClicked);
    this.on("locked", this.options.onDocumentLocked);
    this.on("list-definitions-change", this.options.onListDefinitionsChange);
    if (!shouldMountRenderer) {
      this.#emitCreateAsync();
    }
  }
  mount(el) {
    this.#createView(el);
    setTimeout(() => {
      if (this.isDestroyed) return;
      this.emit("create", { editor: this });
    }, 0);
  }
  unmount() {
    if (this.#renderer) {
      this.#renderer.destroy();
    } else if (this.view) {
      this.view.destroy();
    }
    this.view = void 0;
  }
  /**
   * Handle focus event
   */
  #onFocus({ editor, event }) {
    this.toolbar?.setActiveEditor?.(editor);
    this.options.onFocus?.({ editor, event });
  }
  /**
   * Set the toolbar for this editor
   */
  setToolbar(toolbar) {
    this.toolbar = toolbar;
  }
  /**
   * Check if the editor should run in headless mode
   */
  #checkHeadless(options) {
    if (!options.isHeadless) return;
    if (typeof navigator === "undefined") {
      vue.global.navigator = {
        platform: "node",
        userAgent: "Node.js"
      };
    }
    if (options.mockDocument) {
      console.warn(
        "[super-editor] `mockDocument` is deprecated and will be removed in a future version. Use `document` instead (e.g., `new Editor({ document: jsdomDocument })`). See https://docs.superdoc.dev/guide/headless for migration guidance."
      );
      vue.global.document = options.mockDocument;
    }
    if (options.mockWindow) {
      console.warn(
        "[super-editor] `mockWindow` is deprecated and will be removed in a future version. Prefer passing `document` only. Global window assignment is no longer required for headless mode."
      );
      vue.global.window = options.mockWindow;
    }
  }
  /**
   * Check if web layout mode is enabled (OOXML ST_View 'web')
   */
  isWebLayout() {
    return this.options.viewOptions?.layout === "web";
  }
  /**
   * Focus the editor.
   */
  focus() {
    this.view?.focus();
  }
  /**
   * Get the editor state
   */
  get state() {
    return this._state;
  }
  /**
   * Get the current editor lifecycle state.
   *
   * @returns The current lifecycle state ('initialized', 'documentLoading', 'ready', 'saving', 'closed', 'destroyed')
   */
  get lifecycleState() {
    return this.#editorLifecycleState;
  }
  /**
   * Get the source path of the currently opened document.
   *
   * Returns the file path if the document was opened from a path (Node.js),
   * or null if opened from a Blob/Buffer or created as a blank document.
   *
   * In browsers, this is only a suggested filename, not an actual filesystem path.
   */
  get sourcePath() {
    return this.#sourcePath;
  }
  /**
   * Replace the editor state entirely.
   *
   * Use this method when you need to set a completely new EditorState
   * (e.g., in tests or when loading a new document). For incremental
   * changes, prefer using transactions via `editor.dispatch()` or commands.
   *
   * **Important:** This method bypasses the transaction system entirely.
   * No transaction events will be emitted, no history entries will be created,
   * and plugins will not receive transaction metadata. Use `editor.dispatch()`
   * with transactions for changes that should be undoable or tracked.
   *
   * @param newState - The new EditorState to set
   *
   * @example
   * ```typescript
   * const newState = EditorState.create({
   *   schema: editor.schema,
   *   doc: newDoc,
   *   plugins: editor.state.plugins,
   * });
   * editor.setState(newState);
   * ```
   */
  setState(newState) {
    this._state = newState;
    if (this.view && !this.view.isDestroyed) {
      this.view.updateState(newState);
    }
  }
  /**
   * Get the editor storage.
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * Get object of registered commands.
   */
  get commands() {
    return this.#commandService?.commands;
  }
  /**
   * Get extension helpers.
   */
  get helpers() {
    return this.extensionService.helpers;
  }
  /**
   * Check if the editor is editable.
   */
  get isEditable() {
    return Boolean(this.options.editable && this.view && this.view.editable);
  }
  /**
   * Check if editor is destroyed.
   */
  get isDestroyed() {
    return Boolean(this.#isDestroyed || this.view?.isDestroyed);
  }
  /**
   * Get the editor element
   */
  get element() {
    return this.options.element;
  }
  /**
   * Get possible users of the editor.
   */
  get users() {
    return this.options.users;
  }
  /**
   * Create a chain of commands to call multiple commands at once.
   */
  chain() {
    return this.#commandService.chain();
  }
  /**
   * Check if a command or a chain of commands can be executed. Without executing it.
   */
  can() {
    return this.#commandService.can();
  }
  /**
   * Set the document mode
   * @param documentMode - The document mode ('editing', 'viewing', 'suggesting')
   * @param _caller - Calling context (unused)
   */
  setDocumentMode(documentMode, _caller) {
    if (this.options.isHeaderOrFooter || this.options.isChildEditor) return;
    let cleanedMode = documentMode?.toLowerCase() || "editing";
    if (!this.extensionService || !this.state) return;
    const pm = this.view?.dom || this.options.element?.querySelector?.(".ProseMirror");
    if (this.options.role === "viewer") cleanedMode = "viewing";
    if (this.options.role === "suggester" && cleanedMode === "editing") cleanedMode = "suggesting";
    if (cleanedMode === "viewing") {
      this.commands.toggleTrackChangesShowOriginal?.();
      this.setEditable(false, false);
      this.setOptions({ documentMode: "viewing" });
      if (pm) pm.classList.add("view-mode");
    } else if (cleanedMode === "suggesting") {
      this.commands.disableTrackChangesShowOriginal?.();
      this.commands.enableTrackChanges?.();
      this.setOptions({ documentMode: "suggesting" });
      this.setEditable(true, false);
      if (pm) pm.classList.remove("view-mode");
    } else if (cleanedMode === "editing") {
      this.commands.disableTrackChangesShowOriginal?.();
      this.commands.disableTrackChanges?.();
      this.setEditable(true, false);
      this.setOptions({ documentMode: "editing" });
      if (pm) pm.classList.remove("view-mode");
    }
  }
  /**
   * Blur the editor.
   */
  blur() {
    this.view?.dom?.blur();
  }
  /**
   * Check if editor has focus
   */
  hasFocus() {
    if (this.view) {
      return this.view.hasFocus();
    }
    return false;
  }
  /**
   * Get viewport coordinates for a document position. Falls back to the PresentationEditor
   * when running without a ProseMirror view (layout mode).
   */
  coordsAtPos(pos) {
    if (this.view) {
      return this.view.coordsAtPos(pos);
    }
    const layoutRects = this.presentationEditor?.getRangeRects?.(pos, pos);
    if (Array.isArray(layoutRects) && layoutRects.length > 0) {
      const rect = layoutRects[0];
      return {
        top: rect.top,
        bottom: rect.bottom,
        left: rect.left,
        right: rect.right,
        width: rect.width,
        height: rect.height
      };
    }
    return null;
  }
  /**
   * Get the DOM element for a document position.
   * In presentation mode, returns the painted element.
   */
  getElementAtPos(pos, options = {}) {
    if (this.presentationEditor) {
      return this.presentationEditor.getElementAtPos(pos, options);
    }
    if (!this.view) return null;
    if (!Number.isFinite(pos)) return null;
    const maxPos = this.view.state.doc.content.size;
    const clampedPos = Math.max(0, Math.min(pos, maxPos));
    try {
      const { node } = this.view.domAtPos(clampedPos);
      if (node && node.nodeType === 1) {
        return node;
      }
      if (node && node.nodeType === 3) {
        return node.parentElement;
      }
      return node?.parentElement ?? null;
    } catch {
      return null;
    }
  }
  /**
   * Get position from client-space coordinates.
   * In layout/presentation mode, uses PresentationEditor hit testing for accurate coordinate mapping.
   * Falls back to ProseMirror view for standard editing mode.
   */
  posAtCoords(coords) {
    if (typeof this.presentationEditor?.hitTest === "function") {
      const coordsObj = coords;
      const clientX = coordsObj?.clientX ?? coordsObj?.left ?? coordsObj?.x ?? null;
      const clientY = coordsObj?.clientY ?? coordsObj?.top ?? coordsObj?.y ?? null;
      if (Number.isFinite(clientX) && Number.isFinite(clientY)) {
        const hit = this.presentationEditor.hitTest(clientX, clientY);
        if (hit) {
          return {
            pos: hit.pos,
            inside: hit.pos
          };
        }
      }
    }
    if (this.view) {
      return this.view.posAtCoords(coords);
    }
    return null;
  }
  #registerCopyHandler() {
    this.#renderer?.registerCopyHandler?.(this);
  }
  /**
   * Export the yjs binary from the current state.
   */
  async generateCollaborationUpdate() {
    return await generateCollaborationData(this);
  }
  /**
   * Initialize data for collaborative editing
   * If we are replacing data and have a valid provider, listen for synced event
   * so that we can initialize the data
   */
  initializeCollaborationData() {
    if (!this.options.isNewFile || !this.options.collaborationProvider) return;
    const provider = this.options.collaborationProvider;
    const postSyncInit = () => {
      provider.off?.("synced", postSyncInit);
      this.#insertNewFileData();
    };
    if (provider.synced) this.#insertNewFileData();
    else provider.on?.("synced", postSyncInit);
  }
  /**
   * Replace content of editor that was created with loadFromSchema option
   * Used to replace content of other header/footer when one of it was edited
   *
   * @param content - new editor content json (retrieved from editor.getUpdatedJson)
   */
  replaceContent(content) {
    this.setOptions({
      content
    });
    this.#createConverter();
    this.initDefaultStyles();
    this.#createConverter();
    this.#initMedia();
    const doc2 = this.#generatePmData();
    const tr = this.state.tr.replaceWith(0, this.state.doc.content.size, doc2);
    tr.setMeta("replaceContent", true);
    this.#dispatchTransaction(tr);
  }
  /**
   * Replace the current document with new data. Necessary for initializing a new collaboration file,
   * since we need to insert the data only after the provider has synced.
   */
  #insertNewFileData() {
    if (!this.options.isNewFile) return;
    this.options.isNewFile = false;
    const doc2 = this.#generatePmData();
    const tr = this.state.tr.replaceWith(0, this.state.doc.content.size, doc2).setMeta("addToHistory", false);
    this.#dispatchTransaction(tr);
    setTimeout(() => {
      this.#initComments();
    }, 50);
  }
  /**
   * Set editor options and update state.
   */
  setOptions(options = {}) {
    this.options = {
      ...this.options,
      ...options
    };
    if ((this.options.isNewFile || !this.options.ydoc) && this.options.isCommentsEnabled) {
      this.options.shouldLoadComments = true;
    }
    if (!this.view || !this.state || this.isDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  /**
   * Set whether the editor is editable.
   *
   * When setting to non-editable, this method:
   * - Forces ProseMirror to re-evaluate the editable prop from the Editable plugin
   * - Blurs the editor to remove the cursor
   *
   * @param editable - Whether the editor should accept user input (default: true)
   * @param emitUpdate - Whether to emit an update event after changing editability (default: true)
   */
  setEditable(editable = true, emitUpdate = true) {
    this.setOptions({ editable });
    if (this.view) {
      this.view.setProps({});
      if (!editable && this.view.dom) {
        this.view.dom.blur();
      }
    }
    if (emitUpdate) {
      this.emit("update", { editor: this, transaction: this.state.tr });
    }
  }
  /**
   * Register PM plugin.
   * @param plugin PM plugin.
   * @param handlePlugins Optional function for handling plugin merge.
   */
  registerPlugin(plugin2, handlePlugins) {
    if (this.isDestroyed) return;
    if (!this.state?.plugins) return;
    const plugins = typeof handlePlugins === "function" ? handlePlugins(plugin2, [...this.state.plugins]) : [...this.state.plugins, plugin2];
    this._state = this.state.reconfigure({ plugins });
    this.view?.updateState(this._state);
  }
  /**
   * Safely resolve the plugin key string for a plugin instance.
   */
  #getPluginKeyName(plugin2) {
    const pluginKey = plugin2.key;
    return typeof pluginKey?.key === "string" ? pluginKey.key : "";
  }
  /**
   * Unregister a PM plugin
   */
  unregisterPlugin(nameOrPluginKey) {
    if (this.isDestroyed) return;
    const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey?.key ?? "";
    this._state = this.state.reconfigure({
      plugins: this.state.plugins.filter((plugin2) => !this.#getPluginKeyName(plugin2).startsWith(name))
    });
    this.view?.updateState(this._state);
  }
  /**
   * Creates extension service.
   */
  #createExtensionService() {
    const allowedExtensions = ["extension", "node", "mark"];
    const coreExtensions = [Editable, Commands, EditorFocus, Keymap, PositionTrackerExtension];
    const externalExtensions = this.options.externalExtensions || [];
    const allExtensions = [...coreExtensions, ...this.options.extensions].filter((extension) => {
      const extensionType = typeof extension?.type === "string" ? extension.type : void 0;
      return extensionType ? allowedExtensions.includes(extensionType) : false;
    });
    this.extensionService = ExtensionService.create(allExtensions, externalExtensions, this);
  }
  /**
   * Creates a command service.
   */
  #createCommandService() {
    this.#commandService = superEditor_converter.CommandService.create({
      editor: this
    });
  }
  /**
   * Create the document converter as this.converter.
   */
  #createConverter() {
    if (this.options.converter) {
      this.converter = this.options.converter;
    } else {
      this.converter = new superEditor_converter.SuperConverter({
        docx: this.options.content,
        media: this.options.mediaFiles,
        fonts: this.options.fonts,
        debug: true,
        fileSource: this.options.fileSource,
        documentId: this.options.documentId,
        mockWindow: this.options.mockWindow ?? null,
        mockDocument: this.options.mockDocument ?? null
      });
    }
  }
  /**
   * Initialize media.
   */
  #initMedia() {
    if (this.options.isChildEditor) return;
    if (!this.options.ydoc) {
      this.storage.image.media = this.options.mediaFiles;
      return;
    }
    const mediaMap = this.options.ydoc.getMap("media");
    if (this.options.isNewFile) {
      Object.entries(this.options.mediaFiles).forEach(([key2, value]) => {
        mediaMap.set(key2, value);
      });
      this.storage.image.media = this.options.mediaFiles;
    } else {
      this.storage.image.media = Object.fromEntries(mediaMap.entries());
    }
  }
  /**
   * Initialize fonts
   */
  #initFonts() {
    this.#renderer?.initFonts?.(this);
  }
  /**
   * Determines the fonts used in the document and the unsupported ones and triggers the `onFontsResolved` callback.
   */
  async #checkFonts() {
    if (!this.options.onFontsResolved || typeof this.options.onFontsResolved !== "function") {
      return;
    }
    if (this.options.isHeadless) {
      return;
    }
    try {
      const fontsUsedInDocument = this.converter.getDocumentFonts();
      const unsupportedFonts = this.#determineUnsupportedFonts(fontsUsedInDocument);
      const payload = {
        documentFonts: fontsUsedInDocument,
        unsupportedFonts
      };
      this.emit("fonts-resolved", payload);
    } catch {
      console.warn("[SuperDoc] Could not determine document fonts and unsupported fonts");
    }
  }
  /**
   * Determines which fonts used in the document are not supported
   * by attempting to render them on a canvas.
   * Fonts are considered unsupported if they cannot be rendered
   * and are not already imported in the document via @font-face.
   *
   * @param fonts - Array of font family names used in the document.
   * @returns Array of unsupported font family names.
   */
  #determineUnsupportedFonts(fonts) {
    const unsupportedFonts = fonts.filter((font) => {
      const canRender = canRenderFont(font);
      const isFontImported = this.fontsImported.includes(font);
      return !canRender && !isFontImported;
    });
    return unsupportedFonts;
  }
  /**
   * Load the data from DOCX to be used in the schema.
   * Expects a DOCX file.
   * @param fileSource - The DOCX file to load (File/Blob in browser, Buffer in Node.js)
   * @param isNode - Whether the method is being called in a Node.js environment
   * @returns A promise that resolves to an array containing:
   *   - [0] xmlFiles - Array of XML files extracted from the DOCX
   *   - [1] mediaFiles - Object containing media files with URLs (browser only)
   *   - [2] mediaFiles - Object containing media files with base64 data
   *   - [3] fonts - Object containing font files from the DOCX
   */
  static async loadXmlData(fileSource, isNode2 = false) {
    if (!fileSource) return;
    const zipper = new superEditor_docxZipper();
    const xmlFiles = await zipper.getDocxData(fileSource, isNode2);
    const mediaFiles = zipper.media;
    return [xmlFiles, mediaFiles, zipper.mediaFiles, zipper.fonts];
  }
  /**
   * Get the document version
   */
  static getDocumentVersion(doc2) {
    return superEditor_converter.SuperConverter.getStoredSuperdocVersion(doc2);
  }
  /**
   * Set the document version
   */
  static setDocumentVersion(doc2, version2) {
    const result = superEditor_converter.SuperConverter.setStoredSuperdocVersion(doc2, version2);
    if (typeof result === "string") {
      return result;
    }
    return version2;
  }
  /**
   * Get the document GUID
   */
  static getDocumentGuid(doc2) {
    return superEditor_converter.SuperConverter.extractDocumentGuid(doc2);
  }
  /**
   * @deprecated use setDocumentVersion instead
   */
  static updateDocumentVersion(doc2, version2) {
    console.warn("updateDocumentVersion is deprecated, use setDocumentVersion instead");
    return Editor.setDocumentVersion(doc2, version2);
  }
  /**
   * Generates a schema summary for the current runtime schema.
   */
  async getSchemaSummaryJSON() {
    if (!this.schema) {
      throw new Error("Schema is not initialized.");
    }
    const schemaVersion = this.converter?.getSuperdocVersion?.() || "current";
    const suppressedNames = new Set(
      (this.extensionService?.extensions || []).filter((ext) => {
        const config = ext?.config;
        const suppressFlag = config?.excludeFromSummaryJSON;
        return Boolean(suppressFlag);
      }).map((ext) => ext.name)
    );
    const summary = buildSchemaSummary(this.schema, schemaVersion);
    if (!suppressedNames.size) {
      return summary;
    }
    return {
      ...summary,
      nodes: summary.nodes.filter((node) => !suppressedNames.has(node.name)),
      marks: summary.marks.filter((mark) => !suppressedNames.has(mark.name))
    };
  }
  /**
   * Validates a ProseMirror JSON document against the current schema.
   */
  validateJSON(doc2) {
    if (!this.schema) {
      throw new Error("Schema is not initialized.");
    }
    try {
      if (Array.isArray(doc2)) return doc2.map((d) => this.schema.nodeFromJSON(d));
      return this.schema.nodeFromJSON(doc2);
    } catch (error) {
      const detail = error instanceof Error ? error.message : String(error);
      const validationError = new Error(`Invalid document for current schema: ${detail}`);
      if (error instanceof Error) {
        validationError.cause = error;
      }
      throw validationError;
    }
  }
  /**
   * Creates document PM schema.
   */
  #createSchema() {
    this.schema = this.extensionService.schema;
  }
  /**
   * Generate ProseMirror data from file
   */
  #generatePmData() {
    let doc2;
    try {
      const { mode, content, fragment, loadFromSchema } = this.options;
      const domDocument = this.#getDomDocument();
      const hasJsonContent = (value) => typeof value === "object" && value !== null && !Array.isArray(value);
      if (mode === "docx") {
        if (loadFromSchema && hasJsonContent(content)) {
          doc2 = this.schema.nodeFromJSON(content);
          doc2 = this.#prepareDocumentForImport(doc2);
        } else {
          doc2 = createDocument(this.converter, this.schema, this);
          doc2 = this.#prepareDocumentForImport(doc2);
          if (this.options.markdown) {
            doc2 = superEditor_converter.createDocFromMarkdown(this.options.markdown, this, { isImport: true, document: domDocument });
          } else if (this.options.html)
            doc2 = superEditor_converter.createDocFromHTML(this.options.html, this, { isImport: true, document: domDocument });
          else if (this.options.jsonOverride) doc2 = this.schema.nodeFromJSON(this.options.jsonOverride);
          if (fragment) doc2 = yXmlFragmentToProseMirrorRootNode(fragment, this.schema);
        }
      } else if (mode === "text" || mode === "html") {
        if (loadFromSchema && hasJsonContent(content)) doc2 = this.schema.nodeFromJSON(content);
        else if (typeof content === "string") doc2 = superEditor_converter.createDocFromHTML(content, this, { document: domDocument });
        else doc2 = this.schema.topNodeType.createAndFill();
      }
    } catch (err) {
      console.error(err);
      const error = err instanceof Error ? err : new Error(String(err));
      this.emit("contentError", { editor: this, error });
    }
    return doc2;
  }
  /**
   * Create the PM editor view
   */
  #createInitialState({ includePlugins = false } = {}) {
    if (this._state) return;
    const doc2 = this.#generatePmData();
    const config = { schema: this.schema };
    if (!this.options.ydoc) config.doc = doc2;
    let initialState = superEditor_converter.EditorState.create(config);
    if (includePlugins) {
      initialState = initialState.reconfigure({
        plugins: [...this.extensionService.plugins]
      });
    }
    this.options.initialState = initialState;
    this._state = initialState;
  }
  #configureStateWithExtensionPlugins() {
    const configuredState = this.state.reconfigure({
      plugins: [...this.extensionService.plugins]
    });
    this._state = configuredState;
    this.view?.updateState(configuredState);
  }
  /**
   * Create the PM editor view
   */
  #createView(element) {
    if (!this._state) {
      this.#createInitialState();
    }
    if (!this.#renderer) {
      if (!canUseDOM()) {
        throw new Error("[super-editor] Cannot create an editor view without a renderer.");
      }
      this.#renderer = new ProseMirrorRenderer();
    }
    this.view = this.#renderer.attach({
      element,
      editorProps: this.options.editorProps,
      dispatchTransaction: this.#dispatchTransaction.bind(this),
      state: this.state,
      handleClick: this.#handleNodeSelection.bind(this)
    });
    this.createNodeViews();
  }
  /**
   * Creates all node views.
   */
  createNodeViews() {
    if (this.options.skipViewCreation || typeof this.view?.setProps !== "function") {
      return;
    }
    this.view.setProps({
      nodeViews: this.extensionService.nodeViews
    });
  }
  /**
   * Get the maximum content size based on page dimensions and margins
   * @returns Size object with width and height in pixels, or empty object if no page size
   * @note In web layout mode, returns empty object to skip content constraints.
   *       CSS max-width: 100% handles responsive display while preserving full resolution.
   */
  getMaxContentSize() {
    if (!this.converter) return {};
    if (this.isWebLayout()) {
      return {};
    }
    const { pageSize = {}, pageMargins = {} } = this.converter.pageStyles ?? {};
    const { width, height } = pageSize;
    if (!width || !height) return {};
    const getMarginPx = (side) => {
      return (pageMargins?.[side] ?? 0) * PIXELS_PER_INCH$1;
    };
    const topPx = getMarginPx("top");
    const bottomPx = getMarginPx("bottom");
    const leftPx = getMarginPx("left");
    const rightPx = getMarginPx("right");
    const maxHeight = height * PIXELS_PER_INCH$1 - topPx - bottomPx - MAX_HEIGHT_BUFFER_PX;
    const maxWidth = width * PIXELS_PER_INCH$1 - leftPx - rightPx - MAX_WIDTH_BUFFER_PX;
    return {
      width: maxWidth,
      height: maxHeight
    };
  }
  /**
   * Attach styles and attributes to the editor element
   */
  updateEditorStyles(element, proseMirror) {
    this.#renderer?.updateEditorStyles?.(this, element, proseMirror);
  }
  /**
   * Initialize default styles for the editor container and ProseMirror.
   * Get page size and margins from the converter.
   * Set document default font and font size.
   *
   * @param element - The DOM element to apply styles to
   */
  initDefaultStyles(element = this.element) {
    if (this.options.isHeadless || this.options.suppressDefaultDocxStyles) return;
    this.#renderer?.initDefaultStyles?.(this, element);
  }
  /**
   * Initializes responsive styles for mobile devices.
   * Sets up scaling based on viewport width and handles orientation changes.
   */
  initMobileStyles(element) {
    this.#renderer?.initMobileStyles?.(this, element);
  }
  /**
   * Handler called when collaboration is ready.
   * Initializes comments if not a new file.
   */
  #onCollaborationReady({ editor, ydoc }) {
    if (this.options.collaborationIsReady) return;
    console.debug(" [super-editor] Collaboration ready");
    this.#validateDocumentInit();
    if (this.options.ydoc) {
      this.migrateListsToV2();
    }
    this.options.onCollaborationReady({ editor, ydoc });
    this.options.collaborationIsReady = true;
    this.options.initialState = this.state;
    const { tr } = this.state;
    tr.setMeta("collaborationReady", true);
    this.#dispatchTransaction(tr);
    if (!this.options.isNewFile) {
      this.#initComments();
      updateYdocDocxData(this, this.options.ydoc);
    }
  }
  /**
   * Initialize comments plugin
   */
  #initComments() {
    if (!this.options.isCommentsEnabled) return;
    if (!this.options.shouldLoadComments) return;
    const replacedFile = this.options.replacedFile;
    this.emit("commentsLoaded", {
      editor: this,
      replacedFile,
      comments: this.converter.comments || []
    });
    this.options.replacedFile = false;
    if (this.options.isHeadless) {
      return;
    }
    setTimeout(() => {
      const st = this.state;
      if (!st) return;
      const tr = st.tr.setMeta(CommentsPluginKey, { type: "force" });
      this.#dispatchTransaction(tr);
    }, 50);
  }
  /**
   * Dispatch a transaction to update the editor state
   */
  #dispatchTransaction(transaction) {
    if (this.isDestroyed) return;
    const start2 = Date.now();
    const prevState = this.state;
    let nextState;
    let transactionToApply = transaction;
    try {
      const trackChangesState = TrackChangesBasePluginKey.getState(prevState);
      const isTrackChangesActive = trackChangesState?.isTrackChangesActive ?? false;
      const skipTrackChanges = transactionToApply.getMeta("skipTrackChanges") === true;
      transactionToApply = isTrackChangesActive && !skipTrackChanges ? trackedTransaction({
        tr: transactionToApply,
        state: prevState,
        user: this.options.user
      }) : transactionToApply;
      const { state: appliedState } = prevState.applyTransaction(transactionToApply);
      nextState = appliedState;
    } catch (error) {
      nextState = prevState.apply(transactionToApply);
      console.log(error);
    }
    const selectionHasChanged = !prevState.selection.eq(nextState.selection);
    this._state = nextState;
    if (this.view) {
      this.view.updateState(nextState);
    }
    const end2 = Date.now();
    this.emit("transaction", {
      editor: this,
      transaction: transactionToApply,
      duration: end2 - start2
    });
    if (selectionHasChanged) {
      this.emit("selectionUpdate", {
        editor: this,
        transaction: transactionToApply
      });
    }
    const focus = transactionToApply.getMeta("focus");
    if (focus) {
      this.emit("focus", {
        editor: this,
        event: focus.event,
        transaction: transactionToApply
      });
    }
    const blur = transactionToApply.getMeta("blur");
    if (blur) {
      this.emit("blur", {
        editor: this,
        event: blur.event,
        transaction: transactionToApply
      });
    }
    if (!transactionToApply.docChanged) {
      return;
    }
    if (transaction.docChanged && this.converter) {
      if (!this.converter.documentGuid) {
        this.converter.promoteToGuid();
        console.debug("Document modified - assigned GUID:", this.converter.documentGuid);
      }
      this.converter.documentModified = true;
    }
    this.emit("update", {
      editor: this,
      transaction: transactionToApply
    });
  }
  /**
   * Public dispatch method for transaction dispatching.
   *
   * Allows external callers (e.g., SuperDoc stores, headless workflows) to dispatch
   * transactions without accessing editor.view directly. This method works in both
   * mounted and headless modes.
   *
   * In headless mode, this is the primary way to apply state changes since there is
   * no ProseMirror view to dispatch through.
   *
   * @param tr - The ProseMirror transaction to dispatch
   *
   * @example
   * ```typescript
   * // Headless mode: insert text without a view
   * const editor = new Editor({ isHeadless: true, content: docx });
   * editor.dispatch(editor.state.tr.insertText('Hello'));
   * ```
   */
  dispatch(tr) {
    this.#dispatchTransaction(tr);
  }
  /**
   * Get document identifier (async - may generate hash)
   */
  async getDocumentIdentifier() {
    return await this.converter?.getDocumentIdentifier() || null;
  }
  /**
   * Get permanent document GUID (sync - only for modified documents)
   */
  getDocumentGuid() {
    return this.converter?.documentGuid || null;
  }
  /**
   * Check if document has been modified
   */
  isDocumentModified() {
    return this.converter?.documentModified || false;
  }
  /**
   * @deprecated use getDocumentGuid instead
   */
  getDocumentId() {
    console.warn("getDocumentId is deprecated, use getDocumentGuid instead");
    return this.getDocumentGuid();
  }
  /**
   * Get attrs of the currently selected node or mark.
   * @example
   * editor.getAttributes('textStyle').color
   */
  getAttributes(nameOrType) {
    return Attribute.getAttributes(this.state, nameOrType);
  }
  /**
   * Returns if the currently selected node or mark is active.
   * @param nameOrAttributes - The name of the node/mark or an attributes object
   * @param attributesOrUndefined - Optional attributes to check when first parameter is a name
   * @example
   * editor.isActive('bold')
   * editor.isActive('textStyle', { color: 'purple' })
   * editor.isActive({ textAlign: 'center' })
   */
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return isActive(this.state, name, attributes);
  }
  /**
   * Get the editor content as JSON
   */
  getJSON() {
    const json = this.state.doc.toJSON();
    try {
      const jsonObj = json;
      const attrs = jsonObj.attrs;
      const converter = this.converter;
      if (converter && converter.bodySectPr) {
        jsonObj.attrs = attrs || {};
        jsonObj.attrs.bodySectPr = converter.bodySectPr;
      }
    } catch {
    }
    return json;
  }
  /**
   * Get document metadata including GUID, modification status, and version
   */
  getMetadata() {
    return {
      documentGuid: this.converter?.documentGuid || null,
      isModified: this.isDocumentModified(),
      version: this.converter?.getSuperdocVersion() || null
    };
  }
  /**
   * Get the editor content as HTML
   */
  getHTML({ unflattenLists = false } = {}) {
    const domDocument = this.#getDomDocument();
    if (!domDocument) {
      throw new Error(
        "[super-editor] getHTML() requires a DOM. Provide { document } (e.g. from JSDOM), set DOM globals, or run in a browser environment."
      );
    }
    const container = domDocument.createElement("div");
    const fragment = superEditor_converter.DOMSerializer.fromSchema(this.schema).serializeFragment(this.state.doc.content, {
      document: domDocument
    });
    container.appendChild(fragment);
    let html = container.innerHTML;
    if (unflattenLists) {
      html = superEditor_converter.unflattenListsInHtml(html, domDocument);
    }
    return html;
  }
  /**
   * Get the editor content as Markdown
   */
  async getMarkdown() {
    const domDocument = this.#getDomDocument();
    if (!domDocument) {
      throw new Error(
        "[super-editor] getMarkdown() requires a DOM. Provide { document } (e.g. from JSDOM), set DOM globals, or run in a browser environment."
      );
    }
    const globals = globalThis;
    const shouldInjectGlobals = globals.document === void 0;
    const savedGlobals = shouldInjectGlobals ? {
      document: globals.document,
      window: globals.window,
      navigatorDescriptor: Object.getOwnPropertyDescriptor(globalThis, "navigator")
    } : null;
    if (shouldInjectGlobals) {
      globals.document = domDocument;
      if (!globals.window && domDocument.defaultView) {
        globals.window = domDocument.defaultView;
      }
      if (!globals.navigator && domDocument.defaultView?.navigator) {
        globals.navigator = domDocument.defaultView.navigator;
      }
    }
    try {
      const [
        { unified },
        { default: rehypeParse },
        { default: rehypeRemark },
        { default: remarkStringify },
        { default: remarkGfm }
      ] = await Promise.all([
        Promise.resolve().then(() => require("./index-QeDY1kuN.cjs")),
        Promise.resolve().then(() => require("./index-CJxN5_-j.cjs")),
        Promise.resolve().then(() => require("./index-DK7nnXcL.cjs")),
        Promise.resolve().then(() => require("./index-Ct8-d-Yb.cjs")),
        Promise.resolve().then(() => require("./index-vmxZ5i4H.cjs"))
      ]);
      const html = this.getHTML();
      const file = unified().use(rehypeParse, { fragment: true }).use(rehypeRemark).use(remarkGfm).use(remarkStringify, {
        bullet: "-",
        fences: true
      }).processSync(html);
      return String(file);
    } finally {
      if (savedGlobals) {
        if (savedGlobals.document === void 0) {
          delete globals.document;
        } else {
          globals.document = savedGlobals.document;
        }
        if (savedGlobals.window === void 0) {
          delete globals.window;
        } else {
          globals.window = savedGlobals.window;
        }
        if (savedGlobals.navigatorDescriptor) {
          Object.defineProperty(globalThis, "navigator", savedGlobals.navigatorDescriptor);
        } else {
          delete globals.navigator;
        }
      }
    }
  }
  /**
   * Get the document version from the converter
   */
  getDocumentVersion() {
    return this.converter?.getSuperdocVersion() || null;
  }
  /**
   * Create a child editor linked to this editor.
   * This is useful for creating header/footer editors that are linked to the main editor.
   * Or paragraph fields that rely on the same underlying document and list defintions
   */
  createChildEditor(options) {
    return createLinkedChildEditor(this, options);
  }
  /**
   * Get page styles
   */
  getPageStyles() {
    return this.converter?.pageStyles || {};
  }
  /**
   * Update page styles
   */
  updatePageStyle({ pageMargins }) {
    if (!this.converter) return;
    let hasMadeUpdate = false;
    if (pageMargins) {
      this.converter.pageStyles.pageMargins = pageMargins;
      this.initDefaultStyles();
      hasMadeUpdate = true;
    }
    if (hasMadeUpdate && this.view && !isHeadless()) {
      const newTr = this.view.state.tr;
      newTr.setMeta("forceUpdatePagination", true);
      this.#dispatchTransaction(newTr);
      this.emit("pageStyleUpdate", {
        pageMargins,
        pageStyles: this.converter.pageStyles
      });
    }
  }
  /**
   * Handles image node selection for header/footer editor
   */
  #handleNodeSelection(view, pos) {
    this.setOptions({
      lastSelection: null
    });
    if (this.options.isHeaderOrFooter) {
      return setImageNodeSelection(view, pos);
    }
  }
  /**
   * Perform any post conversion pre prosemirror import processing.
   * Comments are processed here.
   * @param doc The prosemirror document
   * @returns The updated prosemirror document
   */
  #prepareDocumentForImport(doc2) {
    const newState = superEditor_converter.EditorState.create({
      schema: this.schema,
      doc: doc2
    });
    const { tr, doc: newDoc } = newState;
    prepareCommentsForImport(newDoc, tr, this.schema, this.converter);
    const updatedState = newState.apply(tr);
    return updatedState.doc;
  }
  migrateListsToV2() {
    if (this.options.isHeaderOrFooter) return [];
    const replacements = migrateListsToV2IfNecessary(this);
    return replacements;
  }
  /**
   * Prepare the document for export. Any necessary pre-export processing to the state
   * can happen here.
   * @returns The updated document in JSON
   */
  #prepareDocumentForExport(comments = []) {
    const newState = superEditor_converter.EditorState.create({
      schema: this.schema,
      doc: this.state.doc,
      plugins: this.state.plugins
    });
    const { tr, doc: doc2 } = newState;
    prepareCommentsForExport(doc2, tr, this.schema, comments);
    const updatedState = newState.apply(tr);
    return updatedState.doc.toJSON();
  }
  getUpdatedJson() {
    return this.#prepareDocumentForExport();
  }
  /**
   * Export the editor document to DOCX.
   */
  async exportDocx({
    isFinalDoc = false,
    commentsType = "external",
    exportJsonOnly = false,
    exportXmlOnly = false,
    comments,
    getUpdatedDocs = false,
    fieldsHighlightColor = null
  } = {}) {
    try {
      const effectiveComments = comments ?? this.converter.comments ?? [];
      const preparedComments = effectiveComments.map((comment) => ({
        ...comment,
        commentJSON: comment.commentJSON ?? comment.textJson
      }));
      const json = this.#prepareDocumentForExport(preparedComments);
      const documentXml = await this.converter.exportToDocx(
        json,
        this.schema,
        this.storage.image.media,
        isFinalDoc,
        commentsType,
        preparedComments,
        this,
        exportJsonOnly,
        fieldsHighlightColor
      );
      this.#validateDocumentExport();
      if (exportXmlOnly || exportJsonOnly) return documentXml;
      const customXml = this.converter.schemaToXml(this.converter.convertedXml["docProps/custom.xml"].elements[0]);
      const styles = this.converter.schemaToXml(this.converter.convertedXml["word/styles.xml"].elements[0]);
      const hasCustomSettings = !!this.converter.convertedXml["word/settings.xml"]?.elements?.length;
      const customSettings = hasCustomSettings ? this.converter.schemaToXml(this.converter.convertedXml["word/settings.xml"]?.elements?.[0]) : null;
      const rels = this.converter.schemaToXml(this.converter.convertedXml["word/_rels/document.xml.rels"].elements[0]);
      const footnotesData = this.converter.convertedXml["word/footnotes.xml"];
      const footnotesXml = footnotesData?.elements?.[0] ? this.converter.schemaToXml(footnotesData.elements[0]) : null;
      const footnotesRelsData = this.converter.convertedXml["word/_rels/footnotes.xml.rels"];
      const footnotesRelsXml = footnotesRelsData?.elements?.[0] ? this.converter.schemaToXml(footnotesRelsData.elements[0]) : null;
      const media = this.converter.addedMedia;
      const updatedHeadersFooters = {};
      Object.entries(this.converter.convertedXml).forEach(([name, json2]) => {
        if (name.includes("header") || name.includes("footer")) {
          const jsonObj = json2;
          const resultXml = this.converter.schemaToXml(jsonObj.elements?.[0]);
          updatedHeadersFooters[name] = String(resultXml.replace(/\[\[sdspace\]\]/g, ""));
        }
      });
      const numberingData = this.converter.convertedXml["word/numbering.xml"];
      const numbering = this.converter.schemaToXml(numberingData.elements[0]);
      const updatedDocs = {
        ...this.options.customUpdatedFiles,
        "word/document.xml": String(documentXml),
        "docProps/custom.xml": String(customXml),
        "word/_rels/document.xml.rels": String(rels),
        "word/numbering.xml": String(numbering),
        // Replace & with &amp; in styles.xml as DOCX viewers can't handle it
        "word/styles.xml": String(styles).replace(/&/gi, "&amp;"),
        ...updatedHeadersFooters
      };
      if (hasCustomSettings) {
        updatedDocs["word/settings.xml"] = String(customSettings);
      }
      if (footnotesXml) {
        updatedDocs["word/footnotes.xml"] = String(footnotesXml);
      }
      if (footnotesRelsXml) {
        updatedDocs["word/_rels/footnotes.xml.rels"] = String(footnotesRelsXml);
      }
      if (preparedComments.length) {
        const commentsXml = this.converter.schemaToXml(this.converter.convertedXml["word/comments.xml"].elements[0]);
        updatedDocs["word/comments.xml"] = String(commentsXml);
        const commentsExtended = this.converter.convertedXml["word/commentsExtended.xml"];
        if (commentsExtended?.elements?.[0]) {
          const commentsExtendedXml = this.converter.schemaToXml(commentsExtended.elements[0]);
          updatedDocs["word/commentsExtended.xml"] = String(commentsExtendedXml);
        }
        const commentsExtensible = this.converter.convertedXml["word/commentsExtensible.xml"];
        if (commentsExtensible?.elements?.[0]) {
          const commentsExtensibleXml = this.converter.schemaToXml(commentsExtensible.elements[0]);
          updatedDocs["word/commentsExtensible.xml"] = String(commentsExtensibleXml);
        }
        const commentsIds = this.converter.convertedXml["word/commentsIds.xml"];
        if (commentsIds?.elements?.[0]) {
          const commentsIdsXml = this.converter.schemaToXml(commentsIds.elements[0]);
          updatedDocs["word/commentsIds.xml"] = String(commentsIdsXml);
        }
      }
      const zipper = new superEditor_docxZipper();
      if (getUpdatedDocs) {
        updatedDocs["[Content_Types].xml"] = await zipper.updateContentTypes(
          {
            files: this.options.content
          },
          media,
          true,
          updatedDocs
        );
        return updatedDocs;
      }
      const result = await zipper.updateZip({
        docx: this.options.content,
        updatedDocs,
        originalDocxFile: this.options.fileSource,
        media,
        fonts: this.options.fonts,
        isHeadless: this.options.isHeadless
      });
      return result;
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      this.emit("exception", { error: err, editor: this });
      console.error(err);
    }
  }
  /**
   * Destroy collaboration provider and ydoc
   */
  #endCollaboration() {
    if (!this.options.ydoc) return;
    try {
      console.debug(" [super-editor] Ending collaboration");
      this.options.collaborationProvider?.disconnect?.();
      this.options.ydoc.destroy();
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      this.emit("exception", { error: err, editor: this });
      console.error(err);
    }
  }
  // ============================================================================
  // Document Lifecycle API
  // ============================================================================
  /**
   * Open a document in the editor.
   *
   * @param source - Document source:
   *   - `string` - File path (Node.js reads from disk, browser fetches URL)
   *   - `File | Blob` - Browser file object
   *   - `Buffer` - Node.js buffer
   *   - `undefined` - Creates a blank document
   * @param options - Document options (mode, comments, etc.)
   * @returns Promise that resolves when document is loaded
   *
   * @throws {InvalidStateError} If editor is not in 'initialized' or 'closed' state
   * @throws {DocumentLoadError} If document loading fails
   *
   * @example
   * ```typescript
   * const editor = new Editor({ element: myDiv });
   *
   * // Open from file path (Node.js)
   * await editor.open('/path/to/document.docx');
   *
   * // Open from File object (browser)
   * await editor.open(fileInput.files[0]);
   *
   * // Open blank document
   * await editor.open();
   *
   * // Open with options
   * await editor.open('/path/to/doc.docx', { isCommentsEnabled: true });
   * ```
   */
  async open(source, options) {
    this.#assertState("initialized", "closed");
    await this.#withState("documentLoading", "ready", "closed", async () => {
      await this.#loadDocument(source, options);
    });
    this.emit("documentOpen", { editor: this, sourcePath: this.#sourcePath });
  }
  /**
   * Static factory method for one-liner document opening.
   * Creates an Editor instance and opens the document in one call.
   *
   * Smart defaults enable minimal configuration:
   * - No element/selector  headless mode
   * - No extensions  uses getStarterExtensions() for docx, getRichTextExtensions() for text/html
   * - No mode  defaults to 'docx'
   *
   * @param source - Document source (path, File, Blob, Buffer, or undefined for blank)
   * @param config - Combined editor and document options (all optional)
   * @returns Promise resolving to the ready Editor instance
   *
   * @example
   * ```typescript
   * // Minimal headless usage - just works!
   * const editor = await Editor.open('/path/to/doc.docx');
   *
   * // With options
   * const editor = await Editor.open('/path/to/doc.docx', {
   *   isCommentsEnabled: true,
   * });
   *
   * // With UI element (automatically not headless)
   * const editor = await Editor.open('/path/to/doc.docx', {
   *   element: document.getElementById('editor'),
   * });
   *
   * // Blank document
   * const editor = await Editor.open();
   * ```
   */
  static async open(source, config) {
    const hasElement = config?.element != null || config?.selector != null;
    const resolvedConfig = {
      mode: "docx",
      isHeadless: !hasElement,
      ...config
    };
    const {
      // OpenOptions (document-level)
      html,
      markdown,
      isCommentsEnabled,
      suppressDefaultDocxStyles,
      documentMode,
      content,
      mediaFiles,
      fonts,
      // Everything else is EditorOptions
      ...editorConfig
    } = resolvedConfig;
    const openOptions = {
      mode: resolvedConfig.mode,
      html,
      markdown,
      isCommentsEnabled,
      suppressDefaultDocxStyles,
      documentMode,
      content,
      mediaFiles,
      fonts
    };
    const editor = new Editor({ ...editorConfig, deferDocumentLoad: true });
    await editor.open(source, openOptions);
    return editor;
  }
  /**
   * Close the current document.
   *
   * This unloads the document but keeps the editor instance alive.
   * The editor can be reused by calling `open()` again.
   *
   * This method is idempotent - calling it when already closed is a no-op.
   *
   * @example
   * ```typescript
   * await editor.open('/doc1.docx');
   * // ... work with document ...
   * editor.close();
   *
   * await editor.open('/doc2.docx');  // Reuse the same editor
   * ```
   */
  close() {
    if (this.#editorLifecycleState === "closed" || this.#editorLifecycleState === "initialized") {
      return;
    }
    if (this.#editorLifecycleState === "destroyed") {
      return;
    }
    this.#assertState("ready");
    this.emit("documentClose", { editor: this });
    this.#unloadDocument();
    this.#editorLifecycleState = "closed";
  }
  /**
   * Save the document to the original source path.
   *
   * Only works if the document was opened from a file path.
   * If opened from Blob/Buffer or created blank, use `saveTo()` or `exportDocument()`.
   *
   * @param options - Save options (comments, final doc, etc.)
   * @throws {InvalidStateError} If editor is not in 'ready' state
   * @throws {NoSourcePathError} If no source path is available
   * @throws {FileSystemNotAvailableError} If file system access is not available
   *
   * @example
   * ```typescript
   * const editor = await Editor.open('/path/to/doc.docx');
   * // ... make changes ...
   * await editor.save();  // Saves back to /path/to/doc.docx
   * ```
   */
  async save(options) {
    this.#assertState("ready");
    if (!this.#sourcePath) {
      throw new NoSourcePathError("No source path. Use saveTo(path) or exportDocument() instead.");
    }
    await this.#withState("saving", "ready", "ready", async () => {
      const data = await this.exportDocument(options);
      await this.#writeToPath(this.#sourcePath, data);
    });
  }
  /**
   * Save the document to a specific path.
   *
   * Updates the source path to the new location after saving.
   *
   * @param path - File path to save to
   * @param options - Save options
   * @throws {InvalidStateError} If editor is not in 'ready' state
   * @throws {FileSystemNotAvailableError} If file system access is not available
   *
   * @example
   * ```typescript
   * const editor = await Editor.open(blobData);  // No source path
   * await editor.saveTo('/path/to/new-doc.docx');
   * await editor.save();  // Now saves to /path/to/new-doc.docx
   * ```
   */
  async saveTo(path, options) {
    this.#assertState("ready");
    await this.#withState("saving", "ready", "ready", async () => {
      const data = await this.exportDocument(options);
      await this.#writeToPath(path, data);
      this.#sourcePath = path;
    });
  }
  /**
   * Export the document as a Blob or Buffer.
   *
   * This is a convenience wrapper around `exportDocx()` that returns
   * the document data without writing to a file.
   *
   * @param options - Export options
   * @returns Promise resolving to Blob (browser) or Buffer (Node.js)
   * @throws {InvalidStateError} If editor is not in 'ready' state
   *
   * @example
   * ```typescript
   * const blob = await editor.exportDocument();
   *
   * // Create download link in browser
   * const url = URL.createObjectURL(blob);
   * const a = document.createElement('a');
   * a.href = url;
   * a.download = 'document.docx';
   * a.click();
   * ```
   */
  async exportDocument(options) {
    this.#assertState("ready", "saving");
    const result = await this.exportDocx({
      isFinalDoc: options?.isFinalDoc,
      commentsType: options?.commentsType,
      comments: options?.comments,
      fieldsHighlightColor: options?.fieldsHighlightColor
    });
    return result;
  }
  /**
   * Writes document data to a file path.
   *
   * **Browser behavior:**
   * In browsers, the `path` parameter is only used as a suggested filename.
   * The File System Access API shows a save dialog and the user chooses the actual location.
   *
   * **Node.js behavior:**
   * The path is an actual filesystem path, written directly.
   */
  async #writeToPath(path, data) {
    const isNode2 = typeof globalThis !== "undefined" && typeof globalThis.process !== "undefined" && globalThis.process.versions?.node != null;
    const hasNodeBuffer = typeof jszip.Buffer !== "undefined" && typeof jszip.Buffer.isBuffer === "function";
    if (isNode2 || hasNodeBuffer) {
      try {
        const fs = require("fs");
        const buffer = jszip.Buffer.isBuffer(data) ? data : jszip.Buffer.from(await data.arrayBuffer());
        fs.writeFileSync(path, buffer);
        return;
      } catch {
      }
    }
    if (typeof window !== "undefined" && "showSaveFilePicker" in window) {
      const handle = await window.showSaveFilePicker({
        suggestedName: path.split("/").pop() || "document.docx",
        types: [
          {
            description: "Word Document",
            accept: { "application/vnd.openxmlformats-officedocument.wordprocessingml.document": [".docx"] }
          }
        ]
      });
      const writable = await handle.createWritable();
      await writable.write(data);
      await writable.close();
      return;
    }
    throw new FileSystemNotAvailableError(
      "File System Access API not available. Use exportDocument() to get the document data and handle the download manually."
    );
  }
  /**
   * Destroy the editor and clean up resources
   */
  destroy() {
    if (this.#editorLifecycleState === "ready") {
      this.close();
    }
    if (this.#editorLifecycleState === "destroyed") {
      return;
    }
    this.#isDestroyed = true;
    this.emit("destroy");
    this.unmount();
    this.destroyHeaderFooterEditors();
    this.#endCollaboration();
    this.removeAllListeners();
    this.extensionService = void 0;
    this.schema = void 0;
    this.#commandService = void 0;
    this.#editorLifecycleState = "destroyed";
  }
  destroyHeaderFooterEditors() {
    try {
      const headerEditors = this.converter?.headerEditors ?? [];
      const footerEditors = this.converter?.footerEditors ?? [];
      if (!headerEditors.length && !footerEditors.length) return;
      const editors = [...headerEditors, ...footerEditors].filter(Boolean);
      for (const editorData of editors) {
        editorData?.editor?.destroy?.();
      }
      if (headerEditors.length) headerEditors.length = 0;
      if (footerEditors.length) footerEditors.length = 0;
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      this.emit("exception", { error: err, editor: this });
      console.error(err);
    }
  }
  /**
   * Check if migrations are needed for the data
   */
  static checkIfMigrationsNeeded() {
    const dataVersion = version ?? "initial";
    const migrations = getNecessaryMigrations(dataVersion) || [];
    console.debug("[checkVersionMigrations] Migrations needed:", dataVersion, migrations.length);
    return migrations.length > 0;
  }
  /**
   * Process collaboration migrations
   */
  processCollaborationMigrations() {
    console.debug("[checkVersionMigrations] Current editor version", "1.9.0-next.5");
    if (!this.options.ydoc) return;
    const metaMap = this.options.ydoc.getMap("meta");
    let docVersion = metaMap.get("version");
    if (!docVersion) docVersion = "initial";
    console.debug("[checkVersionMigrations] Document version", docVersion);
    const migrations = getNecessaryMigrations(docVersion) || [];
    const plugins = this.state.plugins;
    const syncPlugin = plugins.find((plugin2) => this.#getPluginKeyName(plugin2).startsWith("y-sync"));
    if (!syncPlugin) return this.options.ydoc;
    let hasRunMigrations = false;
    for (const migration of migrations) {
      console.debug(" Running migration", migration.name);
      const result = migration(this);
      if (!result) throw new Error("Migration failed at " + migration.name);
      else hasRunMigrations = true;
    }
    if (!hasRunMigrations) return;
    const pluginState = syncPlugin?.getState(this.state);
    return pluginState.doc;
  }
  /**
   * Replace the current file
   */
  async replaceFile(newFile) {
    this.setOptions({ annotations: true });
    const [docx, media, mediaFiles, fonts] = await Editor.loadXmlData(newFile);
    this.setOptions({
      fileSource: newFile,
      content: docx,
      media,
      mediaFiles,
      fonts,
      isNewFile: true
    });
    this.options.shouldLoadComments = true;
    this.options.replacedFile = true;
    this.#createConverter();
    this.#initMedia();
    this.initDefaultStyles();
    if (this.options.ydoc && this.options.collaborationProvider) {
      updateYdocDocxData(this, this.options.ydoc);
      this.initializeCollaborationData();
    } else {
      this.#insertNewFileData();
    }
    if (!this.options.ydoc) {
      this.#initComments();
    }
  }
  /**
   * Get internal docx file content
   * @param name - File name
   * @param type - type of result (json, string)
   */
  getInternalXmlFile(name, type = "json") {
    if (!this.converter.convertedXml[name]) {
      console.warn("Cannot find file in docx");
      return null;
    }
    if (type === "json") {
      return this.converter.convertedXml[name].elements[0] || null;
    }
    return this.converter.schemaToXml(this.converter.convertedXml[name].elements[0]);
  }
  /**
   * Update internal docx file content
   * @param name - File name
   * @param updatedContent - new file content
   */
  updateInternalXmlFile(name, updatedContent) {
    if (typeof updatedContent === "string") {
      this.options.customUpdatedFiles[name] = String(updatedContent);
    } else {
      const internalFileXml = this.converter.schemaToXml(updatedContent);
      this.options.customUpdatedFiles[name] = String(internalFileXml);
    }
    this.options.isCustomXmlChanged = true;
  }
  /**
   * Get all nodes of a specific type
   */
  getNodesOfType(type) {
    const { findChildren: findChildren2 } = helpers;
    return findChildren2(this.state.doc, (node) => node.type.name === type);
  }
  /**
   * Replace a node with HTML content
   */
  replaceNodeWithHTML(targetNode, html) {
    const { tr } = this.state;
    if (!targetNode || !html) return;
    const start2 = targetNode.pos;
    const end2 = start2 + targetNode.node.nodeSize;
    const htmlNode = superEditor_converter.createDocFromHTML(html, this);
    tr.replaceWith(start2, end2, htmlNode);
    this.dispatch(tr);
  }
  /**
   * A command to prepare the editor to receive annotations. This will
   * pre-process the document as needed prior to running in the annotator.
   *
   * Currently this is only used for table generation but additional pre-processing can be done here.
   */
  prepareForAnnotations(annotationValues = []) {
    const { tr } = this.state;
    const newTr = AnnotatorHelpers.processTables({ state: this.state, tr, annotationValues });
    this.dispatch(newTr);
  }
  /**
   * Migrate paragraph fields to lists V2 structure if necessary.
   * @param annotationValues - List of field values to migrate.
   * @returns Returns a promise that resolves to the migrated values
   */
  async migrateParagraphFields(annotationValues = []) {
    if (!Array.isArray(annotationValues) || !annotationValues.length) return annotationValues;
    const result = await migrateParagraphFieldsListsV2(annotationValues, this);
    return result;
  }
  /**
   * Annotate the document with the given annotation values.
   */
  annotate(annotationValues = [], hiddenIds = [], removeEmptyFields = false) {
    const { state, schema } = this;
    let tr = state.tr;
    tr = AnnotatorHelpers.processTables({ state: this.state, tr, annotationValues });
    tr = AnnotatorHelpers.annotateDocument({
      tr,
      schema,
      annotationValues,
      hiddenFieldIds: hiddenIds,
      removeEmptyFields,
      editor: this
    });
    if (tr.docChanged) {
      const finalTr = tr.scrollIntoView();
      this.dispatch(finalTr);
    }
  }
  /**
   * Preview annotations in the editor. It stores a copy of the original state.
   * This can be reverted via closePreview()
   */
  previewAnnotations(annotationValues = [], hiddenIds = []) {
    this.originalState = this.state;
    this.annotate(annotationValues, hiddenIds);
  }
  /**
   * If there is a preview active, this will revert the editor to the original state.
   */
  closePreview() {
    if (!this.originalState) return;
    if (this.view) {
      this.view.updateState(this.originalState);
    } else {
      this._state = this.originalState;
    }
  }
  /**
   * Run the SuperValidator's active document validation to check and fix potential known issues.
   */
  #validateDocumentInit() {
    if (this.options.isHeaderOrFooter || this.options.isChildEditor) return;
    const validator = new SuperValidator({ editor: this, dryRun: false, debug: false });
    validator.validateActiveDocument();
  }
  /**
   * Run the SuperValidator's on document upon export to check and fix potential known issues.
   */
  #validateDocumentExport() {
    if (this.options.isHeaderOrFooter || this.options.isChildEditor) return;
    const validator = new SuperValidator({ editor: this, dryRun: false, debug: false });
    validator.validateDocumentExport();
  }
  #initDevTools() {
    this.#renderer?.initDevTools?.(this);
  }
}
let readFromCache;
let addToCache;
if (typeof WeakMap != "undefined") {
  let cache2 = /* @__PURE__ */ new WeakMap();
  readFromCache = (key2) => cache2.get(key2);
  addToCache = (key2, value) => {
    cache2.set(key2, value);
    return value;
  };
} else {
  const cache2 = [];
  const cacheSize = 10;
  let cachePos = 0;
  readFromCache = (key2) => {
    for (let i = 0; i < cache2.length; i += 2) if (cache2[i] == key2) return cache2[i + 1];
  };
  addToCache = (key2, value) => {
    if (cachePos == cacheSize) cachePos = 0;
    cache2[cachePos++] = key2;
    return cache2[cachePos++] = value;
  };
}
var TableMap = class {
  constructor(width, height, map3, problems) {
    this.width = width;
    this.height = height;
    this.map = map3;
    this.problems = problems;
  }
  findCell(pos) {
    for (let i = 0; i < this.map.length; i++) {
      const curPos = this.map[i];
      if (curPos != pos) continue;
      const left2 = i % this.width;
      const top2 = i / this.width | 0;
      let right2 = left2 + 1;
      let bottom2 = top2 + 1;
      for (let j = 1; right2 < this.width && this.map[i + j] == curPos; j++) right2++;
      for (let j = 1; bottom2 < this.height && this.map[i + this.width * j] == curPos; j++) bottom2++;
      return {
        left: left2,
        top: top2,
        right: right2,
        bottom: bottom2
      };
    }
    throw new RangeError(`No cell with offset ${pos} found`);
  }
  colCount(pos) {
    for (let i = 0; i < this.map.length; i++) if (this.map[i] == pos) return i % this.width;
    throw new RangeError(`No cell with offset ${pos} found`);
  }
  nextCell(pos, axis, dir) {
    const { left: left2, right: right2, top: top2, bottom: bottom2 } = this.findCell(pos);
    if (axis == "horiz") {
      if (dir < 0 ? left2 == 0 : right2 == this.width) return null;
      return this.map[top2 * this.width + (dir < 0 ? left2 - 1 : right2)];
    } else {
      if (dir < 0 ? top2 == 0 : bottom2 == this.height) return null;
      return this.map[left2 + this.width * (dir < 0 ? top2 - 1 : bottom2)];
    }
  }
  rectBetween(a, b2) {
    const { left: leftA, right: rightA, top: topA, bottom: bottomA } = this.findCell(a);
    const { left: leftB, right: rightB, top: topB, bottom: bottomB } = this.findCell(b2);
    return {
      left: Math.min(leftA, leftB),
      top: Math.min(topA, topB),
      right: Math.max(rightA, rightB),
      bottom: Math.max(bottomA, bottomB)
    };
  }
  cellsInRect(rect) {
    const result = [];
    const seen = {};
    for (let row = rect.top; row < rect.bottom; row++) for (let col = rect.left; col < rect.right; col++) {
      const index2 = row * this.width + col;
      const pos = this.map[index2];
      if (seen[pos]) continue;
      seen[pos] = true;
      if (col == rect.left && col && this.map[index2 - 1] == pos || row == rect.top && row && this.map[index2 - this.width] == pos) continue;
      result.push(pos);
    }
    return result;
  }
  positionAt(row, col, table) {
    for (let i = 0, rowStart = 0; ; i++) {
      const rowEnd = rowStart + table.child(i).nodeSize;
      if (i == row) {
        let index2 = col + row * this.width;
        const rowEndIndex = (row + 1) * this.width;
        while (index2 < rowEndIndex && this.map[index2] < rowStart) index2++;
        return index2 == rowEndIndex ? rowEnd - 1 : this.map[index2];
      }
      rowStart = rowEnd;
    }
  }
  static get(table) {
    return readFromCache(table) || addToCache(table, computeMap(table));
  }
};
function computeMap(table) {
  if (table.type.spec.tableRole != "table") throw new RangeError("Not a table node: " + table.type.name);
  const width = findWidth(table), height = table.childCount;
  const map3 = [];
  let mapPos = 0;
  let problems = null;
  const colWidths = [];
  for (let i = 0, e = width * height; i < e; i++) map3[i] = 0;
  for (let row = 0, pos = 0; row < height; row++) {
    const rowNode = table.child(row);
    pos++;
    for (let i = 0; ; i++) {
      while (mapPos < map3.length && map3[mapPos] != 0) mapPos++;
      if (i == rowNode.childCount) break;
      const cellNode = rowNode.child(i);
      const { colspan, rowspan, colwidth } = cellNode.attrs;
      for (let h2 = 0; h2 < rowspan; h2++) {
        if (h2 + row >= height) {
          (problems || (problems = [])).push({
            type: "overlong_rowspan",
            pos,
            n: rowspan - h2
          });
          break;
        }
        const start2 = mapPos + h2 * width;
        for (let w = 0; w < colspan; w++) {
          if (map3[start2 + w] == 0) map3[start2 + w] = pos;
          else (problems || (problems = [])).push({
            type: "collision",
            row,
            pos,
            n: colspan - w
          });
          const colW = colwidth && colwidth[w];
          if (colW) {
            const widthIndex = (start2 + w) % width * 2, prev = colWidths[widthIndex];
            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {
              colWidths[widthIndex] = colW;
              colWidths[widthIndex + 1] = 1;
            } else if (prev == colW) colWidths[widthIndex + 1]++;
          }
        }
      }
      mapPos += colspan;
      pos += cellNode.nodeSize;
    }
    const expectedPos = (row + 1) * width;
    let missing = 0;
    while (mapPos < expectedPos) if (map3[mapPos++] == 0) missing++;
    if (missing) (problems || (problems = [])).push({
      type: "missing",
      row,
      n: missing
    });
    pos++;
  }
  if (width === 0 || height === 0) (problems || (problems = [])).push({ type: "zero_sized" });
  const tableMap = new TableMap(width, height, map3, problems);
  let badWidths = false;
  for (let i = 0; !badWidths && i < colWidths.length; i += 2) if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true;
  if (badWidths) findBadColWidths(tableMap, colWidths, table);
  return tableMap;
}
function findWidth(table) {
  let width = -1;
  let hasRowSpan = false;
  for (let row = 0; row < table.childCount; row++) {
    const rowNode = table.child(row);
    let rowWidth = 0;
    if (hasRowSpan) for (let j = 0; j < row; j++) {
      const prevRow = table.child(j);
      for (let i = 0; i < prevRow.childCount; i++) {
        const cell = prevRow.child(i);
        if (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan;
      }
    }
    for (let i = 0; i < rowNode.childCount; i++) {
      const cell = rowNode.child(i);
      rowWidth += cell.attrs.colspan;
      if (cell.attrs.rowspan > 1) hasRowSpan = true;
    }
    if (width == -1) width = rowWidth;
    else if (width != rowWidth) width = Math.max(width, rowWidth);
  }
  return width;
}
function findBadColWidths(map3, colWidths, table) {
  if (!map3.problems) map3.problems = [];
  const seen = {};
  for (let i = 0; i < map3.map.length; i++) {
    const pos = map3.map[i];
    if (seen[pos]) continue;
    seen[pos] = true;
    const node = table.nodeAt(pos);
    if (!node) throw new RangeError(`No cell with offset ${pos} found`);
    let updated = null;
    const attrs = node.attrs;
    for (let j = 0; j < attrs.colspan; j++) {
      const colWidth = colWidths[(i + j) % map3.width * 2];
      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth)) (updated || (updated = freshColWidth(attrs)))[j] = colWidth;
    }
    if (updated) map3.problems.unshift({
      type: "colwidth mismatch",
      pos,
      colwidth: updated
    });
  }
}
function freshColWidth(attrs) {
  if (attrs.colwidth) return attrs.colwidth.slice();
  const result = [];
  for (let i = 0; i < attrs.colspan; i++) result.push(0);
  return result;
}
function tableNodeTypes(schema) {
  let result = schema.cached.tableNodeTypes;
  if (!result) {
    result = schema.cached.tableNodeTypes = {};
    for (const name in schema.nodes) {
      const type = schema.nodes[name], role = type.spec.tableRole;
      if (role) result[role] = type;
    }
  }
  return result;
}
const tableEditingKey = new superEditor_converter.PluginKey("selectingCells");
function cellAround$1($pos) {
  for (let d = $pos.depth - 1; d > 0; d--) if ($pos.node(d).type.spec.tableRole == "row") return $pos.node(0).resolve($pos.before(d + 1));
  return null;
}
function cellWrapping$1($pos) {
  for (let d = $pos.depth; d > 0; d--) {
    const role = $pos.node(d).type.spec.tableRole;
    if (role === "cell" || role === "header_cell") return $pos.node(d);
  }
  return null;
}
function isInTable(state) {
  const $head = state.selection.$head;
  for (let d = $head.depth; d > 0; d--) if ($head.node(d).type.spec.tableRole == "row") return true;
  return false;
}
function selectionCell(state) {
  const sel = state.selection;
  if ("$anchorCell" in sel && sel.$anchorCell) return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;
  else if ("node" in sel && sel.node && sel.node.type.spec.tableRole == "cell") return sel.$anchor;
  const $cell = cellAround$1(sel.$head) || cellNear(sel.$head);
  if ($cell) return $cell;
  throw new RangeError(`No cell found around position ${sel.head}`);
}
function cellNear($pos) {
  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {
    const role = after.type.spec.tableRole;
    if (role == "cell" || role == "header_cell") return $pos.doc.resolve(pos);
  }
  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {
    const role = before.type.spec.tableRole;
    if (role == "cell" || role == "header_cell") return $pos.doc.resolve(pos - before.nodeSize);
  }
}
function pointsAtCell($pos) {
  return $pos.parent.type.spec.tableRole == "row" && !!$pos.nodeAfter;
}
function moveCellForward($pos) {
  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);
}
function inSameTable($cellA, $cellB) {
  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);
}
function nextCell($pos, axis, dir) {
  const table = $pos.node(-1);
  const map3 = TableMap.get(table);
  const tableStart = $pos.start(-1);
  const moved = map3.nextCell($pos.pos - tableStart, axis, dir);
  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);
}
function removeColSpan(attrs, pos, n = 1) {
  const result = {
    ...attrs,
    colspan: attrs.colspan - n
  };
  if (result.colwidth) {
    result.colwidth = result.colwidth.slice();
    result.colwidth.splice(pos, n);
    if (!result.colwidth.some((w) => w > 0)) result.colwidth = null;
  }
  return result;
}
function addColSpan(attrs, pos, n = 1) {
  const result = {
    ...attrs,
    colspan: attrs.colspan + n
  };
  if (result.colwidth) {
    result.colwidth = result.colwidth.slice();
    for (let i = 0; i < n; i++) result.colwidth.splice(pos, 0, 0);
  }
  return result;
}
function columnIsHeader(map3, table, col) {
  const headerCell = tableNodeTypes(table.type.schema).header_cell;
  for (let row = 0; row < map3.height; row++) if (table.nodeAt(map3.map[col + row * map3.width]).type != headerCell) return false;
  return true;
}
var CellSelection = class CellSelection2 extends superEditor_converter.Selection {
  constructor($anchorCell, $headCell = $anchorCell) {
    const table = $anchorCell.node(-1);
    const map3 = TableMap.get(table);
    const tableStart = $anchorCell.start(-1);
    const rect = map3.rectBetween($anchorCell.pos - tableStart, $headCell.pos - tableStart);
    const doc2 = $anchorCell.node(0);
    const cells = map3.cellsInRect(rect).filter((p2) => p2 != $headCell.pos - tableStart);
    cells.unshift($headCell.pos - tableStart);
    const ranges = cells.map((pos) => {
      const cell = table.nodeAt(pos);
      if (!cell) throw new RangeError(`No cell with offset ${pos} found`);
      const from3 = tableStart + pos + 1;
      return new superEditor_converter.SelectionRange(doc2.resolve(from3), doc2.resolve(from3 + cell.content.size));
    });
    super(ranges[0].$from, ranges[0].$to, ranges);
    this.$anchorCell = $anchorCell;
    this.$headCell = $headCell;
  }
  map(doc2, mapping) {
    const $anchorCell = doc2.resolve(mapping.map(this.$anchorCell.pos));
    const $headCell = doc2.resolve(mapping.map(this.$headCell.pos));
    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {
      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);
      if (tableChanged && this.isRowSelection()) return CellSelection2.rowSelection($anchorCell, $headCell);
      else if (tableChanged && this.isColSelection()) return CellSelection2.colSelection($anchorCell, $headCell);
      else return new CellSelection2($anchorCell, $headCell);
    }
    return superEditor_converter.TextSelection.between($anchorCell, $headCell);
  }
  content() {
    const table = this.$anchorCell.node(-1);
    const map3 = TableMap.get(table);
    const tableStart = this.$anchorCell.start(-1);
    const rect = map3.rectBetween(this.$anchorCell.pos - tableStart, this.$headCell.pos - tableStart);
    const seen = {};
    const rows = [];
    for (let row = rect.top; row < rect.bottom; row++) {
      const rowContent = [];
      for (let index2 = row * map3.width + rect.left, col = rect.left; col < rect.right; col++, index2++) {
        const pos = map3.map[index2];
        if (seen[pos]) continue;
        seen[pos] = true;
        const cellRect = map3.findCell(pos);
        let cell = table.nodeAt(pos);
        if (!cell) throw new RangeError(`No cell with offset ${pos} found`);
        const extraLeft = rect.left - cellRect.left;
        const extraRight = cellRect.right - rect.right;
        if (extraLeft > 0 || extraRight > 0) {
          let attrs = cell.attrs;
          if (extraLeft > 0) attrs = removeColSpan(attrs, 0, extraLeft);
          if (extraRight > 0) attrs = removeColSpan(attrs, attrs.colspan - extraRight, extraRight);
          if (cellRect.left < rect.left) {
            cell = cell.type.createAndFill(attrs);
            if (!cell) throw new RangeError(`Could not create cell with attrs ${JSON.stringify(attrs)}`);
          } else cell = cell.type.create(attrs, cell.content);
        }
        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {
          const attrs = {
            ...cell.attrs,
            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)
          };
          if (cellRect.top < rect.top) cell = cell.type.createAndFill(attrs);
          else cell = cell.type.create(attrs, cell.content);
        }
        rowContent.push(cell);
      }
      rows.push(table.child(row).copy(superEditor_converter.Fragment.from(rowContent)));
    }
    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;
    return new superEditor_converter.Slice(superEditor_converter.Fragment.from(fragment), 1, 1);
  }
  replace(tr, content = superEditor_converter.Slice.empty) {
    const mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      const { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      tr.replace(mapping.map($from.pos), mapping.map($to.pos), i ? superEditor_converter.Slice.empty : content);
    }
    const sel = superEditor_converter.Selection.findFrom(tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)), -1);
    if (sel) tr.setSelection(sel);
  }
  replaceWith(tr, node) {
    this.replace(tr, new superEditor_converter.Slice(superEditor_converter.Fragment.from(node), 0, 0));
  }
  forEachCell(f) {
    const table = this.$anchorCell.node(-1);
    const map3 = TableMap.get(table);
    const tableStart = this.$anchorCell.start(-1);
    const cells = map3.cellsInRect(map3.rectBetween(this.$anchorCell.pos - tableStart, this.$headCell.pos - tableStart));
    for (let i = 0; i < cells.length; i++) f(table.nodeAt(cells[i]), tableStart + cells[i]);
  }
  isColSelection() {
    const anchorTop = this.$anchorCell.index(-1);
    const headTop = this.$headCell.index(-1);
    if (Math.min(anchorTop, headTop) > 0) return false;
    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;
    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;
  }
  static colSelection($anchorCell, $headCell = $anchorCell) {
    const table = $anchorCell.node(-1);
    const map3 = TableMap.get(table);
    const tableStart = $anchorCell.start(-1);
    const anchorRect = map3.findCell($anchorCell.pos - tableStart);
    const headRect = map3.findCell($headCell.pos - tableStart);
    const doc2 = $anchorCell.node(0);
    if (anchorRect.top <= headRect.top) {
      if (anchorRect.top > 0) $anchorCell = doc2.resolve(tableStart + map3.map[anchorRect.left]);
      if (headRect.bottom < map3.height) $headCell = doc2.resolve(tableStart + map3.map[map3.width * (map3.height - 1) + headRect.right - 1]);
    } else {
      if (headRect.top > 0) $headCell = doc2.resolve(tableStart + map3.map[headRect.left]);
      if (anchorRect.bottom < map3.height) $anchorCell = doc2.resolve(tableStart + map3.map[map3.width * (map3.height - 1) + anchorRect.right - 1]);
    }
    return new CellSelection2($anchorCell, $headCell);
  }
  isRowSelection() {
    const table = this.$anchorCell.node(-1);
    const map3 = TableMap.get(table);
    const tableStart = this.$anchorCell.start(-1);
    const anchorLeft = map3.colCount(this.$anchorCell.pos - tableStart);
    const headLeft = map3.colCount(this.$headCell.pos - tableStart);
    if (Math.min(anchorLeft, headLeft) > 0) return false;
    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;
    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(anchorRight, headRight) == map3.width;
  }
  eq(other) {
    return other instanceof CellSelection2 && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;
  }
  static rowSelection($anchorCell, $headCell = $anchorCell) {
    const table = $anchorCell.node(-1);
    const map3 = TableMap.get(table);
    const tableStart = $anchorCell.start(-1);
    const anchorRect = map3.findCell($anchorCell.pos - tableStart);
    const headRect = map3.findCell($headCell.pos - tableStart);
    const doc2 = $anchorCell.node(0);
    if (anchorRect.left <= headRect.left) {
      if (anchorRect.left > 0) $anchorCell = doc2.resolve(tableStart + map3.map[anchorRect.top * map3.width]);
      if (headRect.right < map3.width) $headCell = doc2.resolve(tableStart + map3.map[map3.width * (headRect.top + 1) - 1]);
    } else {
      if (headRect.left > 0) $headCell = doc2.resolve(tableStart + map3.map[headRect.top * map3.width]);
      if (anchorRect.right < map3.width) $anchorCell = doc2.resolve(tableStart + map3.map[map3.width * (anchorRect.top + 1) - 1]);
    }
    return new CellSelection2($anchorCell, $headCell);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(doc2, json) {
    return new CellSelection2(doc2.resolve(json.anchor), doc2.resolve(json.head));
  }
  static create(doc2, anchorCell, headCell = anchorCell) {
    return new CellSelection2(doc2.resolve(anchorCell), doc2.resolve(headCell));
  }
  getBookmark() {
    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);
  }
};
CellSelection.prototype.visible = false;
superEditor_converter.Selection.jsonID("cell", CellSelection);
var CellBookmark = class CellBookmark2 {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new CellBookmark2(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc2) {
    const $anchorCell = doc2.resolve(this.anchor), $headCell = doc2.resolve(this.head);
    if ($anchorCell.parent.type.spec.tableRole == "row" && $headCell.parent.type.spec.tableRole == "row" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell)) return new CellSelection($anchorCell, $headCell);
    else return superEditor_converter.Selection.near($headCell, 1);
  }
};
function drawCellSelection(state) {
  if (!(state.selection instanceof CellSelection)) return null;
  const cells = [];
  state.selection.forEachCell((node, pos) => {
    cells.push(Decoration.node(pos, pos + node.nodeSize, { class: "selectedCell" }));
  });
  return DecorationSet.create(state.doc, cells);
}
function isCellBoundarySelection({ $from, $to }) {
  if ($from.pos == $to.pos || $from.pos < $to.pos - 6) return false;
  let afterFrom = $from.pos;
  let beforeTo = $to.pos;
  let depth = $from.depth;
  for (; depth >= 0; depth--, afterFrom++) if ($from.after(depth + 1) < $from.end(depth)) break;
  for (let d = $to.depth; d >= 0; d--, beforeTo--) if ($to.before(d + 1) > $to.start(d)) break;
  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);
}
function isTextSelectionAcrossCells({ $from, $to }) {
  let fromCellBoundaryNode;
  let toCellBoundaryNode;
  for (let i = $from.depth; i > 0; i--) {
    const node = $from.node(i);
    if (node.type.spec.tableRole === "cell" || node.type.spec.tableRole === "header_cell") {
      fromCellBoundaryNode = node;
      break;
    }
  }
  for (let i = $to.depth; i > 0; i--) {
    const node = $to.node(i);
    if (node.type.spec.tableRole === "cell" || node.type.spec.tableRole === "header_cell") {
      toCellBoundaryNode = node;
      break;
    }
  }
  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;
}
function normalizeSelection(state, tr, allowTableNodeSelection) {
  const sel = (tr || state).selection;
  const doc2 = (tr || state).doc;
  let normalize2;
  let role;
  if (sel instanceof superEditor_converter.NodeSelection && (role = sel.node.type.spec.tableRole)) {
    if (role == "cell" || role == "header_cell") normalize2 = CellSelection.create(doc2, sel.from);
    else if (role == "row") {
      const $cell = doc2.resolve(sel.from + 1);
      normalize2 = CellSelection.rowSelection($cell, $cell);
    } else if (!allowTableNodeSelection) {
      const map3 = TableMap.get(sel.node);
      const start2 = sel.from + 1;
      const lastCell = start2 + map3.map[map3.width * map3.height - 1];
      normalize2 = CellSelection.create(doc2, start2 + 1, lastCell);
    }
  } else if (sel instanceof superEditor_converter.TextSelection && isCellBoundarySelection(sel)) normalize2 = superEditor_converter.TextSelection.create(doc2, sel.from);
  else if (sel instanceof superEditor_converter.TextSelection && isTextSelectionAcrossCells(sel)) normalize2 = superEditor_converter.TextSelection.create(doc2, sel.$from.start(), sel.$from.end());
  if (normalize2) (tr || (tr = state.tr)).setSelection(normalize2);
  return tr;
}
const fixTablesKey = new superEditor_converter.PluginKey("fix-tables");
function changedDescendants(old, cur, offset2, f) {
  const oldSize = old.childCount, curSize = cur.childCount;
  outer: for (let i = 0, j = 0; i < curSize; i++) {
    const child = cur.child(i);
    for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) if (old.child(scan) == child) {
      j = scan + 1;
      offset2 += child.nodeSize;
      continue outer;
    }
    f(child, offset2);
    if (j < oldSize && old.child(j).sameMarkup(child)) changedDescendants(old.child(j), child, offset2 + 1, f);
    else child.nodesBetween(0, child.content.size, f, offset2 + 1);
    offset2 += child.nodeSize;
  }
}
function fixTables(state, oldState) {
  let tr;
  const check = (node, pos) => {
    if (node.type.spec.tableRole == "table") tr = fixTable(state, node, pos, tr);
  };
  if (!oldState) state.doc.descendants(check);
  else if (oldState.doc != state.doc) changedDescendants(oldState.doc, state.doc, 0, check);
  return tr;
}
function fixTable(state, table, tablePos, tr) {
  const map3 = TableMap.get(table);
  if (!map3.problems) return tr;
  if (!tr) tr = state.tr;
  const mustAdd = [];
  for (let i = 0; i < map3.height; i++) mustAdd.push(0);
  for (let i = 0; i < map3.problems.length; i++) {
    const prob = map3.problems[i];
    if (prob.type == "collision") {
      const cell = table.nodeAt(prob.pos);
      if (!cell) continue;
      const attrs = cell.attrs;
      for (let j = 0; j < attrs.rowspan; j++) mustAdd[prob.row + j] += prob.n;
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, removeColSpan(attrs, attrs.colspan - prob.n, prob.n));
    } else if (prob.type == "missing") mustAdd[prob.row] += prob.n;
    else if (prob.type == "overlong_rowspan") {
      const cell = table.nodeAt(prob.pos);
      if (!cell) continue;
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {
        ...cell.attrs,
        rowspan: cell.attrs.rowspan - prob.n
      });
    } else if (prob.type == "colwidth mismatch") {
      const cell = table.nodeAt(prob.pos);
      if (!cell) continue;
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {
        ...cell.attrs,
        colwidth: prob.colwidth
      });
    } else if (prob.type == "zero_sized") {
      const pos = tr.mapping.map(tablePos);
      tr.delete(pos, pos + table.nodeSize);
    }
  }
  let first2, last;
  for (let i = 0; i < mustAdd.length; i++) if (mustAdd[i]) {
    if (first2 == null) first2 = i;
    last = i;
  }
  for (let i = 0, pos = tablePos + 1; i < map3.height; i++) {
    const row = table.child(i);
    const end2 = pos + row.nodeSize;
    const add = mustAdd[i];
    if (add > 0) {
      let role = "cell";
      if (row.firstChild) role = row.firstChild.type.spec.tableRole;
      const nodes = [];
      for (let j = 0; j < add; j++) {
        const node = tableNodeTypes(state.schema)[role].createAndFill();
        if (node) nodes.push(node);
      }
      const side = (i == 0 || first2 == i - 1) && last == i ? pos + 1 : end2 - 1;
      tr.insert(tr.mapping.map(side), nodes);
    }
    pos = end2;
  }
  return tr.setMeta(fixTablesKey, { fixTables: true });
}
function selectedRect(state) {
  const sel = state.selection;
  const $pos = selectionCell(state);
  const table = $pos.node(-1);
  const tableStart = $pos.start(-1);
  const map3 = TableMap.get(table);
  return {
    ...sel instanceof CellSelection ? map3.rectBetween(sel.$anchorCell.pos - tableStart, sel.$headCell.pos - tableStart) : map3.findCell($pos.pos - tableStart),
    tableStart,
    map: map3,
    table
  };
}
function addColumn(tr, { map: map3, tableStart, table }, col) {
  let refColumn = col > 0 ? -1 : 0;
  if (columnIsHeader(map3, table, col + refColumn)) refColumn = col == 0 || col == map3.width ? null : 0;
  for (let row = 0; row < map3.height; row++) {
    const index2 = row * map3.width + col;
    if (col > 0 && col < map3.width && map3.map[index2 - 1] == map3.map[index2]) {
      const pos = map3.map[index2];
      const cell = table.nodeAt(pos);
      tr.setNodeMarkup(tr.mapping.map(tableStart + pos), null, addColSpan(cell.attrs, col - map3.colCount(pos)));
      row += cell.attrs.rowspan - 1;
    } else {
      const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map3.map[index2 + refColumn]).type;
      const pos = map3.positionAt(row, col, table);
      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());
    }
  }
  return tr;
}
function addColumnBefore(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    dispatch(addColumn(state.tr, rect, rect.left));
  }
  return true;
}
function addColumnAfter(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    dispatch(addColumn(state.tr, rect, rect.right));
  }
  return true;
}
function removeColumn(tr, { map: map3, table, tableStart }, col) {
  const mapStart = tr.mapping.maps.length;
  for (let row = 0; row < map3.height; ) {
    const index2 = row * map3.width + col;
    const pos = map3.map[index2];
    const cell = table.nodeAt(pos);
    const attrs = cell.attrs;
    if (col > 0 && map3.map[index2 - 1] == pos || col < map3.width - 1 && map3.map[index2 + 1] == pos) tr.setNodeMarkup(tr.mapping.slice(mapStart).map(tableStart + pos), null, removeColSpan(attrs, col - map3.colCount(pos)));
    else {
      const start2 = tr.mapping.slice(mapStart).map(tableStart + pos);
      tr.delete(start2, start2 + cell.nodeSize);
    }
    row += attrs.rowspan;
  }
}
function deleteColumn(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    const tr = state.tr;
    if (rect.left == 0 && rect.right == rect.map.width) return false;
    for (let i = rect.right - 1; ; i--) {
      removeColumn(tr, rect, i);
      if (i == rect.left) break;
      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;
      if (!table) throw new RangeError("No table found");
      rect.table = table;
      rect.map = TableMap.get(table);
    }
    dispatch(tr);
  }
  return true;
}
function removeRow(tr, { map: map3, table, tableStart }, row) {
  let rowPos = 0;
  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;
  const nextRow = rowPos + table.child(row).nodeSize;
  const mapFrom = tr.mapping.maps.length;
  tr.delete(rowPos + tableStart, nextRow + tableStart);
  const seen = /* @__PURE__ */ new Set();
  for (let col = 0, index2 = row * map3.width; col < map3.width; col++, index2++) {
    const pos = map3.map[index2];
    if (seen.has(pos)) continue;
    seen.add(pos);
    if (row > 0 && pos == map3.map[index2 - map3.width]) {
      const attrs = table.nodeAt(pos).attrs;
      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {
        ...attrs,
        rowspan: attrs.rowspan - 1
      });
      col += attrs.colspan - 1;
    } else if (row < map3.height && pos == map3.map[index2 + map3.width]) {
      const cell = table.nodeAt(pos);
      const attrs = cell.attrs;
      const copy = cell.type.create({
        ...attrs,
        rowspan: cell.attrs.rowspan - 1
      }, cell.content);
      const newPos = map3.positionAt(row + 1, col, table);
      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);
      col += attrs.colspan - 1;
    }
  }
}
function deleteRow(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state), tr = state.tr;
    if (rect.top == 0 && rect.bottom == rect.map.height) return false;
    for (let i = rect.bottom - 1; ; i--) {
      removeRow(tr, rect, i);
      if (i == rect.top) break;
      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;
      if (!table) throw new RangeError("No table found");
      rect.table = table;
      rect.map = TableMap.get(rect.table);
    }
    dispatch(tr);
  }
  return true;
}
function isEmpty(cell) {
  const c2 = cell.content;
  return c2.childCount == 1 && c2.child(0).isTextblock && c2.child(0).childCount == 0;
}
function cellsOverlapRectangle({ width, height, map: map3 }, rect) {
  let indexTop = rect.top * width + rect.left, indexLeft = indexTop;
  let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);
  for (let i = rect.top; i < rect.bottom; i++) {
    if (rect.left > 0 && map3[indexLeft] == map3[indexLeft - 1] || rect.right < width && map3[indexRight] == map3[indexRight + 1]) return true;
    indexLeft += width;
    indexRight += width;
  }
  for (let i = rect.left; i < rect.right; i++) {
    if (rect.top > 0 && map3[indexTop] == map3[indexTop - width] || rect.bottom < height && map3[indexBottom] == map3[indexBottom + width]) return true;
    indexTop++;
    indexBottom++;
  }
  return false;
}
function mergeCells(state, dispatch) {
  const sel = state.selection;
  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos) return false;
  const rect = selectedRect(state), { map: map3 } = rect;
  if (cellsOverlapRectangle(map3, rect)) return false;
  if (dispatch) {
    const tr = state.tr;
    const seen = {};
    let content = superEditor_converter.Fragment.empty;
    let mergedPos;
    let mergedCell;
    for (let row = rect.top; row < rect.bottom; row++) for (let col = rect.left; col < rect.right; col++) {
      const cellPos = map3.map[row * map3.width + col];
      const cell = rect.table.nodeAt(cellPos);
      if (seen[cellPos] || !cell) continue;
      seen[cellPos] = true;
      if (mergedPos == null) {
        mergedPos = cellPos;
        mergedCell = cell;
      } else {
        if (!isEmpty(cell)) content = content.append(cell.content);
        const mapped = tr.mapping.map(cellPos + rect.tableStart);
        tr.delete(mapped, mapped + cell.nodeSize);
      }
    }
    if (mergedPos == null || mergedCell == null) return true;
    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {
      ...addColSpan(mergedCell.attrs, mergedCell.attrs.colspan, rect.right - rect.left - mergedCell.attrs.colspan),
      rowspan: rect.bottom - rect.top
    });
    if (content.size > 0) {
      const end2 = mergedPos + 1 + mergedCell.content.size;
      const start2 = isEmpty(mergedCell) ? mergedPos + 1 : end2;
      tr.replaceWith(start2 + rect.tableStart, end2 + rect.tableStart, content);
    }
    tr.setSelection(new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart)));
    dispatch(tr);
  }
  return true;
}
function splitCell(state, dispatch) {
  const nodeTypes = tableNodeTypes(state.schema);
  return splitCellWithType(({ node }) => {
    return nodeTypes[node.type.spec.tableRole];
  })(state, dispatch);
}
function splitCellWithType(getCellType2) {
  return (state, dispatch) => {
    const sel = state.selection;
    let cellNode;
    let cellPos;
    if (!(sel instanceof CellSelection)) {
      var _cellAround;
      cellNode = cellWrapping$1(sel.$from);
      if (!cellNode) return false;
      cellPos = (_cellAround = cellAround$1(sel.$from)) === null || _cellAround === void 0 ? void 0 : _cellAround.pos;
    } else {
      if (sel.$anchorCell.pos != sel.$headCell.pos) return false;
      cellNode = sel.$anchorCell.nodeAfter;
      cellPos = sel.$anchorCell.pos;
    }
    if (cellNode == null || cellPos == null) return false;
    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) return false;
    if (dispatch) {
      let baseAttrs = cellNode.attrs;
      const attrs = [];
      const colwidth = baseAttrs.colwidth;
      if (baseAttrs.rowspan > 1) baseAttrs = {
        ...baseAttrs,
        rowspan: 1
      };
      if (baseAttrs.colspan > 1) baseAttrs = {
        ...baseAttrs,
        colspan: 1
      };
      const rect = selectedRect(state), tr = state.tr;
      for (let i = 0; i < rect.right - rect.left; i++) attrs.push(colwidth ? {
        ...baseAttrs,
        colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null
      } : baseAttrs);
      let lastCell;
      for (let row = rect.top; row < rect.bottom; row++) {
        let pos = rect.map.positionAt(row, rect.left, rect.table);
        if (row == rect.top) pos += cellNode.nodeSize;
        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {
          if (col == rect.left && row == rect.top) continue;
          tr.insert(lastCell = tr.mapping.map(pos + rect.tableStart, 1), getCellType2({
            node: cellNode,
            row,
            col
          }).createAndFill(attrs[i]));
        }
      }
      tr.setNodeMarkup(cellPos, getCellType2({
        node: cellNode,
        row: rect.top,
        col: rect.left
      }), attrs[0]);
      if (sel instanceof CellSelection) tr.setSelection(new CellSelection(tr.doc.resolve(sel.$anchorCell.pos), lastCell ? tr.doc.resolve(lastCell) : void 0));
      dispatch(tr);
    }
    return true;
  };
}
function setCellAttr(name, value) {
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    const $cell = selectionCell(state);
    if ($cell.nodeAfter.attrs[name] === value) return false;
    if (dispatch) {
      const tr = state.tr;
      if (state.selection instanceof CellSelection) state.selection.forEachCell((node, pos) => {
        if (node.attrs[name] !== value) tr.setNodeMarkup(pos, null, {
          ...node.attrs,
          [name]: value
        });
      });
      else tr.setNodeMarkup($cell.pos, null, {
        ...$cell.nodeAfter.attrs,
        [name]: value
      });
      dispatch(tr);
    }
    return true;
  };
}
function deprecated_toggleHeader(type) {
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    if (dispatch) {
      const types = tableNodeTypes(state.schema);
      const rect = selectedRect(state), tr = state.tr;
      const cells = rect.map.cellsInRect(type == "column" ? {
        left: rect.left,
        top: 0,
        right: rect.right,
        bottom: rect.map.height
      } : type == "row" ? {
        left: 0,
        top: rect.top,
        right: rect.map.width,
        bottom: rect.bottom
      } : rect);
      const nodes = cells.map((pos) => rect.table.nodeAt(pos));
      for (let i = 0; i < cells.length; i++) if (nodes[i].type == types.header_cell) tr.setNodeMarkup(rect.tableStart + cells[i], types.cell, nodes[i].attrs);
      if (tr.steps.length === 0) for (let i = 0; i < cells.length; i++) tr.setNodeMarkup(rect.tableStart + cells[i], types.header_cell, nodes[i].attrs);
      dispatch(tr);
    }
    return true;
  };
}
function isHeaderEnabledByType(type, rect, types) {
  const cellPositions = rect.map.cellsInRect({
    left: 0,
    top: 0,
    right: type == "row" ? rect.map.width : 1,
    bottom: type == "column" ? rect.map.height : 1
  });
  for (let i = 0; i < cellPositions.length; i++) {
    const cell = rect.table.nodeAt(cellPositions[i]);
    if (cell && cell.type !== types.header_cell) return false;
  }
  return true;
}
function toggleHeader(type, options) {
  options = options || { useDeprecatedLogic: false };
  if (options.useDeprecatedLogic) return deprecated_toggleHeader(type);
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    if (dispatch) {
      const types = tableNodeTypes(state.schema);
      const rect = selectedRect(state), tr = state.tr;
      const isHeaderRowEnabled = isHeaderEnabledByType("row", rect, types);
      const isHeaderColumnEnabled = isHeaderEnabledByType("column", rect, types);
      const selectionStartsAt = (type === "column" ? isHeaderRowEnabled : type === "row" ? isHeaderColumnEnabled : false) ? 1 : 0;
      const cellsRect = type == "column" ? {
        left: 0,
        top: selectionStartsAt,
        right: 1,
        bottom: rect.map.height
      } : type == "row" ? {
        left: selectionStartsAt,
        top: 0,
        right: rect.map.width,
        bottom: 1
      } : rect;
      const newType = type == "column" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == "row" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;
      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {
        const cellPos = relativeCellPos + rect.tableStart;
        const cell = tr.doc.nodeAt(cellPos);
        if (cell) tr.setNodeMarkup(cellPos, newType, cell.attrs);
      });
      dispatch(tr);
    }
    return true;
  };
}
toggleHeader("row", { useDeprecatedLogic: true });
toggleHeader("column", { useDeprecatedLogic: true });
const toggleHeaderCell = toggleHeader("cell", { useDeprecatedLogic: true });
function findNextCell($cell, dir) {
  if (dir < 0) {
    const before = $cell.nodeBefore;
    if (before) return $cell.pos - before.nodeSize;
    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {
      const rowNode = $cell.node(-1).child(row);
      const lastChild = rowNode.lastChild;
      if (lastChild) return rowEnd - 1 - lastChild.nodeSize;
      rowEnd -= rowNode.nodeSize;
    }
  } else {
    if ($cell.index() < $cell.parent.childCount - 1) return $cell.pos + $cell.nodeAfter.nodeSize;
    const table = $cell.node(-1);
    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {
      const rowNode = table.child(row);
      if (rowNode.childCount) return rowStart + 1;
      rowStart += rowNode.nodeSize;
    }
  }
  return null;
}
function goToNextCell(direction) {
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    const cell = findNextCell(selectionCell(state), direction);
    if (cell == null) return false;
    if (dispatch) {
      const $cell = state.doc.resolve(cell);
      dispatch(state.tr.setSelection(superEditor_converter.TextSelection.between($cell, moveCellForward($cell))).scrollIntoView());
    }
    return true;
  };
}
function deleteTable(state, dispatch) {
  const $pos = state.selection.$anchor;
  for (let d = $pos.depth; d > 0; d--) if ($pos.node(d).type.spec.tableRole == "table") {
    if (dispatch) dispatch(state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView());
    return true;
  }
  return false;
}
function deleteCellSelection(state, dispatch) {
  const sel = state.selection;
  if (!(sel instanceof CellSelection)) return false;
  if (dispatch) {
    const tr = state.tr;
    const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;
    sel.forEachCell((cell, pos) => {
      if (!cell.content.eq(baseContent)) tr.replace(tr.mapping.map(pos + 1), tr.mapping.map(pos + cell.nodeSize - 1), new superEditor_converter.Slice(baseContent, 0, 0));
    });
    if (tr.docChanged) dispatch(tr);
  }
  return true;
}
function pastedCells(slice2) {
  if (slice2.size === 0) return null;
  let { content, openStart, openEnd } = slice2;
  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == "table")) {
    openStart--;
    openEnd--;
    content = content.child(0).content;
  }
  const first2 = content.child(0);
  const role = first2.type.spec.tableRole;
  const schema = first2.type.schema, rows = [];
  if (role == "row") for (let i = 0; i < content.childCount; i++) {
    let cells = content.child(i).content;
    const left2 = i ? 0 : Math.max(0, openStart - 1);
    const right2 = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);
    if (left2 || right2) cells = fitSlice(tableNodeTypes(schema).row, new superEditor_converter.Slice(cells, left2, right2)).content;
    rows.push(cells);
  }
  else if (role == "cell" || role == "header_cell") rows.push(openStart || openEnd ? fitSlice(tableNodeTypes(schema).row, new superEditor_converter.Slice(content, openStart, openEnd)).content : content);
  else return null;
  return ensureRectangular(schema, rows);
}
function ensureRectangular(schema, rows) {
  const widths = [];
  for (let i = 0; i < rows.length; i++) {
    const row = rows[i];
    for (let j = row.childCount - 1; j >= 0; j--) {
      const { rowspan, colspan } = row.child(j).attrs;
      for (let r2 = i; r2 < i + rowspan; r2++) widths[r2] = (widths[r2] || 0) + colspan;
    }
  }
  let width = 0;
  for (let r2 = 0; r2 < widths.length; r2++) width = Math.max(width, widths[r2]);
  for (let r2 = 0; r2 < widths.length; r2++) {
    if (r2 >= rows.length) rows.push(superEditor_converter.Fragment.empty);
    if (widths[r2] < width) {
      const empty2 = tableNodeTypes(schema).cell.createAndFill();
      const cells = [];
      for (let i = widths[r2]; i < width; i++) cells.push(empty2);
      rows[r2] = rows[r2].append(superEditor_converter.Fragment.from(cells));
    }
  }
  return {
    height: rows.length,
    width,
    rows
  };
}
function fitSlice(nodeType, slice2) {
  const node = nodeType.createAndFill();
  return new superEditor_converter.Transform(node).replace(0, node.content.size, slice2).doc;
}
function clipCells({ width, height, rows }, newWidth, newHeight) {
  if (width != newWidth) {
    const added = [];
    const newRows = [];
    for (let row = 0; row < rows.length; row++) {
      const frag = rows[row], cells = [];
      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {
        let cell = frag.child(i % frag.childCount);
        if (col + cell.attrs.colspan > newWidth) cell = cell.type.createChecked(removeColSpan(cell.attrs, cell.attrs.colspan, col + cell.attrs.colspan - newWidth), cell.content);
        cells.push(cell);
        col += cell.attrs.colspan;
        for (let j = 1; j < cell.attrs.rowspan; j++) added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;
      }
      newRows.push(superEditor_converter.Fragment.from(cells));
    }
    rows = newRows;
    width = newWidth;
  }
  if (height != newHeight) {
    const newRows = [];
    for (let row = 0, i = 0; row < newHeight; row++, i++) {
      const cells = [], source = rows[i % height];
      for (let j = 0; j < source.childCount; j++) {
        let cell = source.child(j);
        if (row + cell.attrs.rowspan > newHeight) cell = cell.type.create({
          ...cell.attrs,
          rowspan: Math.max(1, newHeight - cell.attrs.rowspan)
        }, cell.content);
        cells.push(cell);
      }
      newRows.push(superEditor_converter.Fragment.from(cells));
    }
    rows = newRows;
    height = newHeight;
  }
  return {
    width,
    height,
    rows
  };
}
function growTable(tr, map3, table, start2, width, height, mapFrom) {
  const schema = tr.doc.type.schema;
  const types = tableNodeTypes(schema);
  let empty2;
  let emptyHead;
  if (width > map3.width) for (let row = 0, rowEnd = 0; row < map3.height; row++) {
    const rowNode = table.child(row);
    rowEnd += rowNode.nodeSize;
    const cells = [];
    let add;
    if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell) add = empty2 || (empty2 = types.cell.createAndFill());
    else add = emptyHead || (emptyHead = types.header_cell.createAndFill());
    for (let i = map3.width; i < width; i++) cells.push(add);
    tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start2), cells);
  }
  if (height > map3.height) {
    const cells = [];
    for (let i = 0, start$1 = (map3.height - 1) * map3.width; i < Math.max(map3.width, width); i++) {
      const header = i >= map3.width ? false : table.nodeAt(map3.map[start$1 + i]).type == types.header_cell;
      cells.push(header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty2 || (empty2 = types.cell.createAndFill()));
    }
    const emptyRow = types.row.create(null, superEditor_converter.Fragment.from(cells)), rows = [];
    for (let i = map3.height; i < height; i++) rows.push(emptyRow);
    tr.insert(tr.mapping.slice(mapFrom).map(start2 + table.nodeSize - 2), rows);
  }
  return !!(empty2 || emptyHead);
}
function isolateHorizontal(tr, map3, table, start2, left2, right2, top2, mapFrom) {
  if (top2 == 0 || top2 == map3.height) return false;
  let found = false;
  for (let col = left2; col < right2; col++) {
    const index2 = top2 * map3.width + col, pos = map3.map[index2];
    if (map3.map[index2 - map3.width] == pos) {
      found = true;
      const cell = table.nodeAt(pos);
      const { top: cellTop, left: cellLeft } = map3.findCell(pos);
      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start2), null, {
        ...cell.attrs,
        rowspan: top2 - cellTop
      });
      tr.insert(tr.mapping.slice(mapFrom).map(map3.positionAt(top2, cellLeft, table)), cell.type.createAndFill({
        ...cell.attrs,
        rowspan: cellTop + cell.attrs.rowspan - top2
      }));
      col += cell.attrs.colspan - 1;
    }
  }
  return found;
}
function isolateVertical(tr, map3, table, start2, top2, bottom2, left2, mapFrom) {
  if (left2 == 0 || left2 == map3.width) return false;
  let found = false;
  for (let row = top2; row < bottom2; row++) {
    const index2 = row * map3.width + left2, pos = map3.map[index2];
    if (map3.map[index2 - 1] == pos) {
      found = true;
      const cell = table.nodeAt(pos);
      const cellLeft = map3.colCount(pos);
      const updatePos = tr.mapping.slice(mapFrom).map(pos + start2);
      tr.setNodeMarkup(updatePos, null, removeColSpan(cell.attrs, left2 - cellLeft, cell.attrs.colspan - (left2 - cellLeft)));
      tr.insert(updatePos + cell.nodeSize, cell.type.createAndFill(removeColSpan(cell.attrs, 0, left2 - cellLeft)));
      row += cell.attrs.rowspan - 1;
    }
  }
  return found;
}
function insertCells(state, dispatch, tableStart, rect, cells) {
  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;
  if (!table) throw new Error("No table found");
  let map3 = TableMap.get(table);
  const { top: top2, left: left2 } = rect;
  const right2 = left2 + cells.width, bottom2 = top2 + cells.height;
  const tr = state.tr;
  let mapFrom = 0;
  function recomp() {
    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;
    if (!table) throw new Error("No table found");
    map3 = TableMap.get(table);
    mapFrom = tr.mapping.maps.length;
  }
  if (growTable(tr, map3, table, tableStart, right2, bottom2, mapFrom)) recomp();
  if (isolateHorizontal(tr, map3, table, tableStart, left2, right2, top2, mapFrom)) recomp();
  if (isolateHorizontal(tr, map3, table, tableStart, left2, right2, bottom2, mapFrom)) recomp();
  if (isolateVertical(tr, map3, table, tableStart, top2, bottom2, left2, mapFrom)) recomp();
  if (isolateVertical(tr, map3, table, tableStart, top2, bottom2, right2, mapFrom)) recomp();
  for (let row = top2; row < bottom2; row++) {
    const from3 = map3.positionAt(row, left2, table), to = map3.positionAt(row, right2, table);
    tr.replace(tr.mapping.slice(mapFrom).map(from3 + tableStart), tr.mapping.slice(mapFrom).map(to + tableStart), new superEditor_converter.Slice(cells.rows[row - top2], 0, 0));
  }
  recomp();
  tr.setSelection(new CellSelection(tr.doc.resolve(tableStart + map3.positionAt(top2, left2, table)), tr.doc.resolve(tableStart + map3.positionAt(bottom2 - 1, right2 - 1, table))));
  dispatch(tr);
}
const handleKeyDown$1 = keydownHandler({
  ArrowLeft: arrow$3("horiz", -1),
  ArrowRight: arrow$3("horiz", 1),
  ArrowUp: arrow$3("vert", -1),
  ArrowDown: arrow$3("vert", 1),
  "Shift-ArrowLeft": shiftArrow("horiz", -1),
  "Shift-ArrowRight": shiftArrow("horiz", 1),
  "Shift-ArrowUp": shiftArrow("vert", -1),
  "Shift-ArrowDown": shiftArrow("vert", 1),
  Backspace: deleteCellSelection,
  "Mod-Backspace": deleteCellSelection,
  Delete: deleteCellSelection,
  "Mod-Delete": deleteCellSelection
});
function maybeSetSelection(state, dispatch, selection) {
  if (selection.eq(state.selection)) return false;
  if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());
  return true;
}
function arrow$3(axis, dir) {
  return (state, dispatch, view) => {
    if (!view) return false;
    const sel = state.selection;
    if (sel instanceof CellSelection) return maybeSetSelection(state, dispatch, superEditor_converter.Selection.near(sel.$headCell, dir));
    if (axis != "horiz" && !sel.empty) return false;
    const end2 = atEndOfCell(view, axis, dir);
    if (end2 == null) return false;
    if (axis == "horiz") return maybeSetSelection(state, dispatch, superEditor_converter.Selection.near(state.doc.resolve(sel.head + dir), dir));
    else {
      const $cell = state.doc.resolve(end2);
      const $next = nextCell($cell, axis, dir);
      let newSel;
      if ($next) newSel = superEditor_converter.Selection.near($next, 1);
      else if (dir < 0) newSel = superEditor_converter.Selection.near(state.doc.resolve($cell.before(-1)), -1);
      else newSel = superEditor_converter.Selection.near(state.doc.resolve($cell.after(-1)), 1);
      return maybeSetSelection(state, dispatch, newSel);
    }
  };
}
function shiftArrow(axis, dir) {
  return (state, dispatch, view) => {
    if (!view) return false;
    const sel = state.selection;
    let cellSel;
    if (sel instanceof CellSelection) cellSel = sel;
    else {
      const end2 = atEndOfCell(view, axis, dir);
      if (end2 == null) return false;
      cellSel = new CellSelection(state.doc.resolve(end2));
    }
    const $head = nextCell(cellSel.$headCell, axis, dir);
    if (!$head) return false;
    return maybeSetSelection(state, dispatch, new CellSelection(cellSel.$anchorCell, $head));
  };
}
function handleTripleClick(view, pos) {
  const doc2 = view.state.doc, $cell = cellAround$1(doc2.resolve(pos));
  if (!$cell) return false;
  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));
  return true;
}
function handlePaste(view, _2, slice2) {
  if (!isInTable(view.state)) return false;
  let cells = pastedCells(slice2);
  const sel = view.state.selection;
  if (sel instanceof CellSelection) {
    if (!cells) cells = {
      width: 1,
      height: 1,
      rows: [superEditor_converter.Fragment.from(fitSlice(tableNodeTypes(view.state.schema).cell, slice2))]
    };
    const table = sel.$anchorCell.node(-1);
    const start2 = sel.$anchorCell.start(-1);
    const rect = TableMap.get(table).rectBetween(sel.$anchorCell.pos - start2, sel.$headCell.pos - start2);
    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);
    insertCells(view.state, view.dispatch, start2, rect, cells);
    return true;
  } else if (cells) {
    const $cell = selectionCell(view.state);
    const start2 = $cell.start(-1);
    insertCells(view.state, view.dispatch, start2, TableMap.get($cell.node(-1)).findCell($cell.pos - start2), cells);
    return true;
  } else return false;
}
function handleMouseDown(view, startEvent) {
  var _cellUnderMouse;
  if (startEvent.ctrlKey || startEvent.metaKey) return;
  const startDOMCell = domInCell(view, startEvent.target);
  let $anchor;
  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {
    setCellSelection(view.state.selection.$anchorCell, startEvent);
    startEvent.preventDefault();
  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround$1(view.state.selection.$anchor)) != null && ((_cellUnderMouse = cellUnderMouse(view, startEvent)) === null || _cellUnderMouse === void 0 ? void 0 : _cellUnderMouse.pos) != $anchor.pos) {
    setCellSelection($anchor, startEvent);
    startEvent.preventDefault();
  } else if (!startDOMCell) return;
  function setCellSelection($anchor$1, event) {
    let $head = cellUnderMouse(view, event);
    const starting = tableEditingKey.getState(view.state) == null;
    if (!$head || !inSameTable($anchor$1, $head)) if (starting) $head = $anchor$1;
    else return;
    const selection = new CellSelection($anchor$1, $head);
    if (starting || !view.state.selection.eq(selection)) {
      const tr = view.state.tr.setSelection(selection);
      if (starting) tr.setMeta(tableEditingKey, $anchor$1.pos);
      view.dispatch(tr);
    }
  }
  function stop() {
    view.root.removeEventListener("mouseup", stop);
    view.root.removeEventListener("dragstart", stop);
    view.root.removeEventListener("mousemove", move2);
    if (tableEditingKey.getState(view.state) != null) view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));
  }
  function move2(_event) {
    const event = _event;
    const anchor = tableEditingKey.getState(view.state);
    let $anchor$1;
    if (anchor != null) $anchor$1 = view.state.doc.resolve(anchor);
    else if (domInCell(view, event.target) != startDOMCell) {
      $anchor$1 = cellUnderMouse(view, startEvent);
      if (!$anchor$1) return stop();
    }
    if ($anchor$1) setCellSelection($anchor$1, event);
  }
  view.root.addEventListener("mouseup", stop);
  view.root.addEventListener("dragstart", stop);
  view.root.addEventListener("mousemove", move2);
}
function atEndOfCell(view, axis, dir) {
  if (!(view.state.selection instanceof superEditor_converter.TextSelection)) return null;
  const { $head } = view.state.selection;
  for (let d = $head.depth - 1; d >= 0; d--) {
    const parent = $head.node(d);
    if ((dir < 0 ? $head.index(d) : $head.indexAfter(d)) != (dir < 0 ? 0 : parent.childCount)) return null;
    if (parent.type.spec.tableRole == "cell" || parent.type.spec.tableRole == "header_cell") {
      const cellPos = $head.before(d);
      const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
      return view.endOfTextblock(dirStr) ? cellPos : null;
    }
  }
  return null;
}
function domInCell(view, dom) {
  for (; dom && dom != view.dom; dom = dom.parentNode) if (dom.nodeName == "TD" || dom.nodeName == "TH") return dom;
  return null;
}
function cellUnderMouse(view, event) {
  const mousePos = view.posAtCoords({
    left: event.clientX,
    top: event.clientY
  });
  if (!mousePos) return null;
  const pos = mousePos.inside >= 0 ? mousePos.inside : mousePos.pos;
  return cellAround$1(view.state.doc.resolve(pos));
}
var TableView = class {
  constructor(node, defaultCellMinWidth) {
    this.node = node;
    this.defaultCellMinWidth = defaultCellMinWidth;
    this.dom = document.createElement("div");
    this.dom.className = "tableWrapper";
    this.table = this.dom.appendChild(document.createElement("table"));
    this.table.style.setProperty("--default-cell-min-width", `${defaultCellMinWidth}px`);
    this.colgroup = this.table.appendChild(document.createElement("colgroup"));
    updateColumnsOnResize(node, this.colgroup, this.table, defaultCellMinWidth);
    this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(node) {
    if (node.type != this.node.type) return false;
    this.node = node;
    updateColumnsOnResize(node, this.colgroup, this.table, this.defaultCellMinWidth);
    return true;
  }
  ignoreMutation(record) {
    return record.type == "attributes" && (record.target == this.table || this.colgroup.contains(record.target));
  }
};
function updateColumnsOnResize(node, colgroup, table, defaultCellMinWidth, overrideCol, overrideValue) {
  let totalWidth = 0;
  let fixedWidth = true;
  let nextDOM = colgroup.firstChild;
  const row = node.firstChild;
  if (!row) return;
  for (let i = 0, col = 0; i < row.childCount; i++) {
    const { colspan, colwidth } = row.child(i).attrs;
    for (let j = 0; j < colspan; j++, col++) {
      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];
      const cssWidth = hasWidth ? hasWidth + "px" : "";
      totalWidth += hasWidth || defaultCellMinWidth;
      if (!hasWidth) fixedWidth = false;
      if (!nextDOM) {
        const col$1 = document.createElement("col");
        col$1.style.width = cssWidth;
        colgroup.appendChild(col$1);
      } else {
        if (nextDOM.style.width != cssWidth) nextDOM.style.width = cssWidth;
        nextDOM = nextDOM.nextSibling;
      }
    }
  }
  while (nextDOM) {
    var _nextDOM$parentNode;
    const after = nextDOM.nextSibling;
    (_nextDOM$parentNode = nextDOM.parentNode) === null || _nextDOM$parentNode === void 0 || _nextDOM$parentNode.removeChild(nextDOM);
    nextDOM = after;
  }
  if (fixedWidth) {
    table.style.width = totalWidth + "px";
    table.style.minWidth = "";
  } else {
    table.style.width = "";
    table.style.minWidth = totalWidth + "px";
  }
}
const columnResizingPluginKey = new superEditor_converter.PluginKey("tableColumnResizing");
function columnResizing({ handleWidth = 5, cellMinWidth = 25, defaultCellMinWidth = 100, View = TableView, lastColumnResizable = true } = {}) {
  const plugin2 = new superEditor_converter.Plugin({
    key: columnResizingPluginKey,
    state: {
      init(_2, state) {
        var _plugin$spec;
        const nodeViews = (_plugin$spec = plugin2.spec) === null || _plugin$spec === void 0 || (_plugin$spec = _plugin$spec.props) === null || _plugin$spec === void 0 ? void 0 : _plugin$spec.nodeViews;
        const tableName = tableNodeTypes(state.schema).table.name;
        if (View && nodeViews) nodeViews[tableName] = (node, view) => {
          return new View(node, defaultCellMinWidth, view);
        };
        return new ResizeState(-1, false);
      },
      apply(tr, prev) {
        return prev.apply(tr);
      }
    },
    props: {
      attributes: (state) => {
        const pluginState = columnResizingPluginKey.getState(state);
        return pluginState && pluginState.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (view, event) => {
          handleMouseMove(view, event, handleWidth, lastColumnResizable);
        },
        mouseleave: (view) => {
          handleMouseLeave(view);
        },
        mousedown: (view, event) => {
          handleMouseDown$1(view, event, cellMinWidth, defaultCellMinWidth);
        }
      },
      decorations: (state) => {
        const pluginState = columnResizingPluginKey.getState(state);
        if (pluginState && pluginState.activeHandle > -1) return handleDecorations(state, pluginState.activeHandle);
      },
      nodeViews: {}
    }
  });
  return plugin2;
}
var ResizeState = class ResizeState2 {
  constructor(activeHandle, dragging) {
    this.activeHandle = activeHandle;
    this.dragging = dragging;
  }
  apply(tr) {
    const state = this;
    const action = tr.getMeta(columnResizingPluginKey);
    if (action && action.setHandle != null) return new ResizeState2(action.setHandle, false);
    if (action && action.setDragging !== void 0) return new ResizeState2(state.activeHandle, action.setDragging);
    if (state.activeHandle > -1 && tr.docChanged) {
      let handle = tr.mapping.map(state.activeHandle, -1);
      if (!pointsAtCell(tr.doc.resolve(handle))) handle = -1;
      return new ResizeState2(handle, state.dragging);
    }
    return state;
  }
};
function handleMouseMove(view, event, handleWidth, lastColumnResizable) {
  if (!view.editable) return;
  const pluginState = columnResizingPluginKey.getState(view.state);
  if (!pluginState) return;
  if (!pluginState.dragging) {
    const target = domCellAround(event.target);
    let cell = -1;
    if (target) {
      const { left: left2, right: right2 } = target.getBoundingClientRect();
      if (event.clientX - left2 <= handleWidth) cell = edgeCell(view, event, "left", handleWidth);
      else if (right2 - event.clientX <= handleWidth) cell = edgeCell(view, event, "right", handleWidth);
    }
    if (cell != pluginState.activeHandle) {
      if (!lastColumnResizable && cell !== -1) {
        const $cell = view.state.doc.resolve(cell);
        const table = $cell.node(-1);
        const map3 = TableMap.get(table);
        const tableStart = $cell.start(-1);
        if (map3.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1 == map3.width - 1) return;
      }
      updateHandle(view, cell);
    }
  }
}
function handleMouseLeave(view) {
  if (!view.editable) return;
  const pluginState = columnResizingPluginKey.getState(view.state);
  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging) updateHandle(view, -1);
}
function handleMouseDown$1(view, event, cellMinWidth, defaultCellMinWidth) {
  var _view$dom$ownerDocume;
  if (!view.editable) return false;
  const win = (_view$dom$ownerDocume = view.dom.ownerDocument.defaultView) !== null && _view$dom$ownerDocume !== void 0 ? _view$dom$ownerDocume : window;
  const pluginState = columnResizingPluginKey.getState(view.state);
  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging) return false;
  const cell = view.state.doc.nodeAt(pluginState.activeHandle);
  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);
  view.dispatch(view.state.tr.setMeta(columnResizingPluginKey, { setDragging: {
    startX: event.clientX,
    startWidth: width
  } }));
  function finish(event$1) {
    win.removeEventListener("mouseup", finish);
    win.removeEventListener("mousemove", move2);
    const pluginState$1 = columnResizingPluginKey.getState(view.state);
    if (pluginState$1 === null || pluginState$1 === void 0 ? void 0 : pluginState$1.dragging) {
      updateColumnWidth(view, pluginState$1.activeHandle, draggedWidth(pluginState$1.dragging, event$1, cellMinWidth));
      view.dispatch(view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null }));
    }
  }
  function move2(event$1) {
    if (!event$1.which) return finish(event$1);
    const pluginState$1 = columnResizingPluginKey.getState(view.state);
    if (!pluginState$1) return;
    if (pluginState$1.dragging) {
      const dragged = draggedWidth(pluginState$1.dragging, event$1, cellMinWidth);
      displayColumnWidth(view, pluginState$1.activeHandle, dragged, defaultCellMinWidth);
    }
  }
  displayColumnWidth(view, pluginState.activeHandle, width, defaultCellMinWidth);
  win.addEventListener("mouseup", finish);
  win.addEventListener("mousemove", move2);
  event.preventDefault();
  return true;
}
function currentColWidth(view, cellPos, { colspan, colwidth }) {
  const width = colwidth && colwidth[colwidth.length - 1];
  if (width) return width;
  const dom = view.domAtPos(cellPos);
  let domWidth = dom.node.childNodes[dom.offset].offsetWidth, parts = colspan;
  if (colwidth) {
    for (let i = 0; i < colspan; i++) if (colwidth[i]) {
      domWidth -= colwidth[i];
      parts--;
    }
  }
  return domWidth / parts;
}
function domCellAround(target) {
  while (target && target.nodeName != "TD" && target.nodeName != "TH") target = target.classList && target.classList.contains("ProseMirror") ? null : target.parentNode;
  return target;
}
function edgeCell(view, event, side, handleWidth) {
  const offset2 = side == "right" ? -handleWidth : handleWidth;
  const found = view.posAtCoords({
    left: event.clientX + offset2,
    top: event.clientY
  });
  if (!found) return -1;
  const { pos } = found;
  const $cell = cellAround$1(view.state.doc.resolve(pos));
  if (!$cell) return -1;
  if (side == "right") return $cell.pos;
  const map3 = TableMap.get($cell.node(-1)), start2 = $cell.start(-1);
  const index2 = map3.map.indexOf($cell.pos - start2);
  return index2 % map3.width == 0 ? -1 : start2 + map3.map[index2 - 1];
}
function draggedWidth(dragging, event, resizeMinWidth) {
  const offset2 = event.clientX - dragging.startX;
  return Math.max(resizeMinWidth, dragging.startWidth + offset2);
}
function updateHandle(view, value) {
  view.dispatch(view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value }));
}
function updateColumnWidth(view, cell, width) {
  const $cell = view.state.doc.resolve(cell);
  const table = $cell.node(-1), map3 = TableMap.get(table), start2 = $cell.start(-1);
  const col = map3.colCount($cell.pos - start2) + $cell.nodeAfter.attrs.colspan - 1;
  const tr = view.state.tr;
  for (let row = 0; row < map3.height; row++) {
    const mapIndex = row * map3.width + col;
    if (row && map3.map[mapIndex] == map3.map[mapIndex - map3.width]) continue;
    const pos = map3.map[mapIndex];
    const attrs = table.nodeAt(pos).attrs;
    const index2 = attrs.colspan == 1 ? 0 : col - map3.colCount(pos);
    if (attrs.colwidth && attrs.colwidth[index2] == width) continue;
    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);
    colwidth[index2] = width;
    tr.setNodeMarkup(start2 + pos, null, {
      ...attrs,
      colwidth
    });
  }
  if (tr.docChanged) view.dispatch(tr);
}
function displayColumnWidth(view, cell, width, defaultCellMinWidth) {
  const $cell = view.state.doc.resolve(cell);
  const table = $cell.node(-1), start2 = $cell.start(-1);
  const col = TableMap.get(table).colCount($cell.pos - start2) + $cell.nodeAfter.attrs.colspan - 1;
  let dom = view.domAtPos($cell.start(-1)).node;
  while (dom && dom.nodeName != "TABLE") dom = dom.parentNode;
  if (!dom) return;
  updateColumnsOnResize(table, dom.firstChild, dom, defaultCellMinWidth, col, width);
}
function zeroes(n) {
  return Array(n).fill(0);
}
function handleDecorations(state, cell) {
  const decorations = [];
  const $cell = state.doc.resolve(cell);
  const table = $cell.node(-1);
  if (!table) return DecorationSet.empty;
  const map3 = TableMap.get(table);
  const start2 = $cell.start(-1);
  const col = map3.colCount($cell.pos - start2) + $cell.nodeAfter.attrs.colspan - 1;
  for (let row = 0; row < map3.height; row++) {
    const index2 = col + row * map3.width;
    if ((col == map3.width - 1 || map3.map[index2] != map3.map[index2 + 1]) && (row == 0 || map3.map[index2] != map3.map[index2 - map3.width])) {
      var _columnResizingPlugin;
      const cellPos = map3.map[index2];
      const pos = start2 + cellPos + table.nodeAt(cellPos).nodeSize - 1;
      const dom = document.createElement("div");
      dom.className = "column-resize-handle";
      if ((_columnResizingPlugin = columnResizingPluginKey.getState(state)) === null || _columnResizingPlugin === void 0 ? void 0 : _columnResizingPlugin.dragging) decorations.push(Decoration.node(start2 + cellPos, start2 + cellPos + table.nodeAt(cellPos).nodeSize, { class: "column-resize-dragging" }));
      decorations.push(Decoration.widget(pos, dom));
    }
  }
  return DecorationSet.create(state.doc, decorations);
}
function tableEditing({ allowTableNodeSelection = false } = {}) {
  return new superEditor_converter.Plugin({
    key: tableEditingKey,
    state: {
      init() {
        return null;
      },
      apply(tr, cur) {
        const set = tr.getMeta(tableEditingKey);
        if (set != null) return set == -1 ? null : set;
        if (cur == null || !tr.docChanged) return cur;
        const { deleted, pos } = tr.mapping.mapResult(cur);
        return deleted ? null : pos;
      }
    },
    props: {
      decorations: drawCellSelection,
      handleDOMEvents: { mousedown: handleMouseDown },
      createSelectionBetween(view) {
        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;
      },
      handleTripleClick,
      handleKeyDown: handleKeyDown$1,
      handlePaste
    },
    appendTransaction(_2, oldState, state) {
      return normalizeSelection(state, fixTables(state, oldState), allowTableNodeSelection);
    }
  });
}
class EpochPositionMapper {
  #currentEpoch = 0;
  #mapsByFromEpoch = /* @__PURE__ */ new Map();
  #maxEpochsToKeep;
  /**
   * Creates a new EpochPositionMapper.
   *
   * @param options - Configuration options
   * @param options.maxEpochsToKeep - Maximum number of epoch transitions to retain, defaults to 100
   *
   * @remarks
   * The maxEpochsToKeep value is clamped to a minimum of 1 and floored to an integer.
   * This creates a sliding window of history - epochs older than (currentEpoch - maxEpochsToKeep)
   * are automatically pruned.
   *
   * A value of 100 epochs is usually sufficient since:
   * - Layouts typically complete within a few frames
   * - Once a layout completes, even older epochs are pruned aggressively
   * - Mapping from very old epochs is usually a sign of a stale layout
   */
  constructor(options) {
    const maxEpochsToKeep = options?.maxEpochsToKeep ?? 100;
    this.#maxEpochsToKeep = Math.max(1, Math.floor(maxEpochsToKeep));
  }
  /**
   * Gets the current document epoch.
   *
   * @returns The current epoch number
   *
   * @remarks
   * The epoch starts at 0 and increments by 1 for each document-changing transaction.
   * No-op transactions (tr.docChanged === false) do not increment the epoch.
   */
  getCurrentEpoch() {
    return this.#currentEpoch;
  }
  /**
   * Records a transaction's StepMaps and advances the epoch if the document changed.
   *
   * @param tr - The ProseMirror transaction to record
   *
   * @remarks
   * If the transaction did not change the document (tr.docChanged === false), this method
   * returns early without recording anything or incrementing the epoch.
   *
   * For document-changing transactions:
   * 1. Extracts the array of StepMaps from tr.mapping.maps
   * 2. Associates these maps with the current epoch (the "from" epoch)
   * 3. Increments the current epoch (the "to" epoch for this transition)
   * 4. Prunes old epochs that exceed the retention window
   *
   * StepMaps capture how positions are transformed by each step in the transaction,
   * including deletions, insertions, and replacements.
   */
  recordTransaction(tr) {
    if (!tr.docChanged) {
      return;
    }
    const fromEpoch = this.#currentEpoch;
    const maps = Array.isArray(tr.mapping?.maps) ? tr.mapping.maps : [];
    this.#mapsByFromEpoch.set(fromEpoch, maps);
    this.#currentEpoch = fromEpoch + 1;
    this.#pruneByCurrentEpoch();
  }
  /**
   * Notifies the mapper that a layout has completed, enabling aggressive pruning of old StepMaps.
   *
   * @param layoutEpoch - The document epoch that was just painted to the DOM
   *
   * @remarks
   * Once a layout is painted, we should never see DOM interactions (clicks, selections) from
   * older epochs, because the DOM represents the layoutEpoch state. Therefore, we can safely
   * discard StepMaps for epochs strictly older than layoutEpoch.
   *
   * This is more aggressive than the sliding window pruning and helps keep memory usage low
   * even if maxEpochsToKeep is large.
   *
   * Pruning steps:
   * 1. Deletes all StepMaps with fromEpoch < layoutEpoch
   * 2. Runs the standard sliding window pruning (based on currentEpoch - maxEpochsToKeep)
   *
   * Safe to call multiple times with the same or increasing layoutEpoch values.
   */
  onLayoutComplete(layoutEpoch) {
    for (const epoch of this.#mapsByFromEpoch.keys()) {
      if (epoch < layoutEpoch) {
        this.#mapsByFromEpoch.delete(epoch);
      }
    }
    this.#pruneByCurrentEpoch();
  }
  /**
   * Maps a position from a layout epoch to the current document epoch (simple result).
   *
   * @param pos - The position in the layout epoch's coordinate space
   * @param fromEpoch - The epoch when the layout was created
   * @param assoc - Association direction for ambiguous positions (-1 for left, 1 for right), defaults to 1
   * @returns The mapped position in current document coordinates, or null if mapping failed
   *
   * @remarks
   * This is a convenience wrapper around mapPosFromLayoutToCurrentDetailed() that returns
   * only the position (or null) without failure reason details.
   *
   * Use this when you only care whether mapping succeeded or failed, not why it failed.
   * For detailed failure diagnostics, use mapPosFromLayoutToCurrentDetailed().
   *
   * See mapPosFromLayoutToCurrentDetailed() for full documentation of the mapping algorithm.
   */
  mapPosFromLayoutToCurrent(pos, fromEpoch, assoc = 1) {
    const result = this.mapPosFromLayoutToCurrentDetailed(pos, fromEpoch, assoc);
    return result.ok ? result.pos : null;
  }
  /**
   * Maps a position from a layout epoch to the current document epoch with detailed failure information.
   *
   * @param pos - The position in the layout epoch's coordinate space
   * @param fromEpoch - The epoch when the layout was created
   * @param assoc - Association direction for ambiguous positions (-1 for left, 1 for right), defaults to 1
   * @returns A detailed result indicating success with the mapped position, or failure with a reason
   *
   * @remarks
   * This method applies a sequence of ProseMirror StepMaps to transform a position from a past
   * epoch to the current document state. The algorithm:
   *
   * 1. Validates inputs (pos and fromEpoch must be valid finite non-negative numbers)
   * 2. Handles the trivial case (fromEpoch === currentEpoch returns pos unchanged)
   * 3. Checks if fromEpoch is within the retention window
   * 4. Iterates through epochs from fromEpoch to currentEpoch:
   *    - Retrieves the StepMaps for each epoch transition
   *    - Applies each StepMap to transform the position
   *    - Detects if the position was deleted
   * 5. Returns the final mapped position or a failure reason
   *
   * The assoc parameter controls behavior at position boundaries:
   * - assoc = 1 (right): At insertion points, associates with content to the right
   * - assoc = -1 (left): At insertion points, associates with content to the left
   *
   * Failure reasons:
   * - `invalid_pos`: pos is not a valid finite non-negative number
   * - `invalid_epoch`: fromEpoch is invalid, negative, or greater than currentEpoch
   * - `epoch_too_old`: fromEpoch is older than the retention window
   * - `missing_stepmap`: A required StepMap is missing (indicates a bug)
   * - `deleted`: The position was deleted by a transaction
   *
   * Use this method when you need to diagnose why mapping failed (e.g., for logging or
   * fallback behavior). For simple success/failure, use mapPosFromLayoutToCurrent().
   */
  mapPosFromLayoutToCurrentDetailed(pos, fromEpoch, assoc = 1) {
    const toEpoch = this.#currentEpoch;
    if (!Number.isFinite(pos) || pos < 0) {
      return { ok: false, reason: "invalid_pos", fromEpoch, toEpoch };
    }
    if (!Number.isFinite(fromEpoch) || fromEpoch < 0) {
      return { ok: false, reason: "invalid_epoch", fromEpoch, toEpoch };
    }
    if (fromEpoch > toEpoch) {
      return { ok: false, reason: "invalid_epoch", fromEpoch, toEpoch };
    }
    if (fromEpoch === toEpoch) {
      return { ok: true, pos, fromEpoch, toEpoch };
    }
    const minKeptFromEpoch = Math.max(0, toEpoch - this.#maxEpochsToKeep);
    if (fromEpoch < minKeptFromEpoch) {
      return { ok: false, reason: "epoch_too_old", fromEpoch, toEpoch };
    }
    let mapped = pos;
    for (let epoch = fromEpoch; epoch < toEpoch; epoch += 1) {
      const maps = this.#mapsByFromEpoch.get(epoch);
      if (!maps) {
        return { ok: false, reason: "missing_stepmap", fromEpoch, toEpoch };
      }
      for (const map3 of maps) {
        const r2 = map3.mapResult(mapped, assoc);
        if (r2.deleted) {
          return { ok: false, reason: "deleted", fromEpoch, toEpoch };
        }
        mapped = r2.pos;
      }
    }
    return { ok: true, pos: mapped, fromEpoch, toEpoch };
  }
  #pruneByCurrentEpoch() {
    const minKeptFromEpoch = Math.max(0, this.#currentEpoch - this.#maxEpochsToKeep);
    for (const epoch of this.#mapsByFromEpoch.keys()) {
      if (epoch < minKeptFromEpoch) {
        this.#mapsByFromEpoch.delete(epoch);
      }
    }
  }
}
function computeTabStops$1(context) {
  const { explicitStops, defaultTabInterval, paragraphIndent } = context;
  const leftIndent = paragraphIndent.left ?? 0;
  const hanging = paragraphIndent.hanging ?? 0;
  const effectiveMinIndent = Math.max(0, leftIndent - hanging);
  const clearPositions = explicitStops.filter((stop) => stop.val === "clear").map((stop) => stop.pos);
  const filteredExplicitStops = explicitStops.filter((stop) => stop.val !== "clear").filter((stop) => stop.pos >= effectiveMinIndent);
  const maxExplicit = filteredExplicitStops.reduce((max2, stop) => Math.max(max2, stop.pos), 0);
  const hasExplicit = filteredExplicitStops.length > 0;
  const stops = [...filteredExplicitStops];
  const defaultStart = hasExplicit ? Math.max(maxExplicit, leftIndent) : 0;
  let pos = defaultStart;
  const targetLimit = Math.max(defaultStart, leftIndent) + 14400;
  while (pos < targetLimit) {
    pos += defaultTabInterval;
    const hasExplicitStop = filteredExplicitStops.some((s) => Math.abs(s.pos - pos) < 20);
    const hasClearStop = clearPositions.some((clearPos) => Math.abs(clearPos - pos) < 20);
    const isValidDefault = pos >= leftIndent;
    if (!hasExplicitStop && !hasClearStop && isValidDefault) {
      stops.push({
        val: "start",
        pos,
        leader: "none"
      });
    }
  }
  return stops.sort((a, b2) => a.pos - b2.pos);
}
function layoutWithTabs(runs, stops, lineWidth, options = {}) {
  const result = [];
  let currentX = 0;
  let currentStopIndex = 0;
  let pendingDecimalStop;
  let pendingCenterStop;
  let pendingEndStop;
  const decimalSeparator = options.decimalSeparator ?? ".";
  for (const entry of runs) {
    const { run, width, isTab } = entry;
    if (isTab) {
      while (currentStopIndex < stops.length && stops[currentStopIndex].pos <= currentX) {
        currentStopIndex++;
      }
      if (currentStopIndex < stops.length) {
        const stop = stops[currentStopIndex];
        result.push({
          run,
          x: currentX,
          width: 0,
          tabStop: stop
        });
        currentX = stop.pos;
        pendingDecimalStop = stop.val === "decimal" ? stop : void 0;
        pendingCenterStop = stop.val === "center" ? stop : void 0;
        pendingEndStop = stop.val === "end" ? stop : void 0;
        currentStopIndex++;
      } else {
        result.push({
          run,
          x: currentX,
          width
        });
        currentX += width;
        pendingDecimalStop = void 0;
        pendingCenterStop = void 0;
        pendingEndStop = void 0;
      }
    } else {
      if (pendingDecimalStop) {
        currentX = computeDecimalAlignedX(entry, pendingDecimalStop, options, decimalSeparator);
        pendingDecimalStop = void 0;
      } else if (pendingCenterStop) {
        currentX = computeCenterAlignedX(entry, pendingCenterStop);
        pendingCenterStop = void 0;
      } else if (pendingEndStop) {
        currentX = computeEndAlignedX(entry, pendingEndStop);
        pendingEndStop = void 0;
      }
      result.push({
        run,
        x: currentX,
        width
      });
      currentX += width;
    }
  }
  return result;
}
function computeDecimalAlignedX(entry, stop, options, separator) {
  const text = entry.text ?? "";
  const decimalIndex = text.indexOf(separator);
  if (decimalIndex <= 0) {
    return stop.pos;
  }
  const beforeText = text.slice(0, decimalIndex);
  let beforeWidth;
  if (options.measureTextWidth) {
    beforeWidth = options.measureTextWidth(entry.run, beforeText);
  } else if (text.length > 0) {
    beforeWidth = entry.width * decimalIndex / text.length;
  } else {
    beforeWidth = 0;
  }
  const targetX = stop.pos - beforeWidth;
  return targetX < 0 ? 0 : targetX;
}
function computeCenterAlignedX(entry, stop) {
  const width = entry.width;
  const targetX = stop.pos - width / 2;
  return targetX < 0 ? 0 : targetX;
}
function computeEndAlignedX(entry, stop) {
  const width = entry.width;
  const targetX = stop.pos - width;
  return targetX < 0 ? 0 : targetX;
}
function calculateTabWidth(params2) {
  const {
    currentX,
    tabStops,
    paragraphWidth,
    defaultTabDistance: defaultTabDistance2,
    defaultLineLength: defaultLineLength2,
    followingText = "",
    measureText: measureText2,
    decimalSeparator = "."
  } = params2;
  const nextStop = tabStops.find((stop) => stop.val !== "clear" && stop.pos > currentX);
  const fallbackWidth = () => {
    let tabWidth = defaultTabDistance2 - currentX % defaultLineLength2 % defaultTabDistance2;
    if (tabWidth <= 0) tabWidth = defaultTabDistance2;
    return {
      width: tabWidth,
      alignment: "default",
      tabStopPosUsed: "default"
    };
  };
  if (!nextStop) {
    return fallbackWidth();
  }
  let width = Math.min(nextStop.pos, paragraphWidth) - currentX;
  const alignment2 = nextStop.val;
  if (alignment2 === "bar") {
    return {
      width: 0,
      leader: nextStop.leader,
      alignment: alignment2,
      tabStopPosUsed: nextStop.pos
    };
  }
  if (alignment2 === "center" || alignment2 === "end") {
    const textWidth = measureText2 ? measureText2(followingText) : 0;
    if (alignment2 === "center") {
      width -= textWidth / 2;
    } else {
      width -= textWidth;
    }
  } else if (alignment2 === "decimal") {
    const decimalIndex = followingText.indexOf(decimalSeparator);
    if (decimalIndex >= 0) {
      const before = followingText.slice(0, decimalIndex);
      const beforeWidth = measureText2 ? measureText2(before) : 0;
      width -= beforeWidth;
    }
  }
  if (width < 1) {
    return fallbackWidth();
  }
  return {
    width,
    leader: nextStop.leader,
    alignment: alignment2,
    tabStopPosUsed: nextStop.pos
  };
}
const OOXML_PCT_DIVISOR = 5e3;
function resolveColumnWidths(columns, availableWidth) {
  const columnCount = columns.length;
  const width = availableWidth / columnCount;
  return columns.map(() => width);
}
function measureRowHeights(cells, _columnWidths) {
  return cells.map(() => 20);
}
const SPACE_CHARS$1 = /* @__PURE__ */ new Set([" ", ""]);
function shouldApplyJustify(params2) {
  const { alignment: alignment2, hasExplicitPositioning, isLastLineOfParagraph, paragraphEndsWithLineBreak, skipJustifyOverride } = params2;
  if (alignment2 !== "justify" && alignment2 !== "both") {
    return false;
  }
  if (skipJustifyOverride === true) {
    return false;
  }
  if (hasExplicitPositioning) {
    return false;
  }
  if (isLastLineOfParagraph && !paragraphEndsWithLineBreak) {
    return false;
  }
  return true;
}
function calculateJustifySpacing(params2) {
  const { lineWidth, availableWidth, spaceCount, shouldJustify } = params2;
  if (!shouldJustify) {
    return 0;
  }
  if (spaceCount <= 0) {
    return 0;
  }
  const slack = availableWidth - lineWidth;
  return slack / spaceCount;
}
const isAtomicRunKind = (kind) => kind === "image" || kind === "lineBreak" || kind === "break" || kind === "tab" || kind === "fieldAnnotation";
const isImageLikeRun = (run) => {
  if (!run || typeof run !== "object") return false;
  const candidate = run.src;
  return typeof candidate === "string";
};
const coerceRunText = (run) => {
  if (!run || typeof run !== "object") return "";
  const candidate = run.text;
  return typeof candidate === "string" ? candidate : "";
};
const coercePmStart = (run) => {
  if (!run || typeof run !== "object") return void 0;
  const candidate = run.pmStart;
  return typeof candidate === "number" ? candidate : void 0;
};
const coercePmEnd = (run) => {
  if (!run || typeof run !== "object") return void 0;
  const candidate = run.pmEnd;
  return typeof candidate === "number" ? candidate : void 0;
};
function computeLinePmRange$1(block, line) {
  if (block.kind !== "paragraph") return {};
  let pmStart;
  let pmEnd;
  for (let runIndex = line.fromRun; runIndex <= line.toRun; runIndex += 1) {
    const run = block.runs[runIndex];
    if (!run) continue;
    const runPmStart = coercePmStart(run);
    if (runPmStart == null) continue;
    if (isAtomicRunKind(run.kind) || isImageLikeRun(run)) {
      const runPmEnd = coercePmEnd(run) ?? runPmStart + 1;
      if (pmStart == null) {
        pmStart = runPmStart;
      }
      pmEnd = runPmEnd;
      continue;
    }
    const text = coerceRunText(run);
    const runLength = text.length;
    const isFirstRun = runIndex === line.fromRun;
    const isLastRun = runIndex === line.toRun;
    const startOffset = isFirstRun ? line.fromChar : 0;
    const endOffset = isLastRun ? line.toChar : runLength;
    const sliceStart = runPmStart + startOffset;
    const sliceEnd = runPmStart + endOffset;
    if (pmStart == null) {
      pmStart = sliceStart;
    }
    pmEnd = sliceEnd;
  }
  return { pmStart, pmEnd };
}
function computeFragmentPmRange$1(block, lines, fromLine, toLine) {
  let pmStart;
  let pmEnd;
  for (let index2 = fromLine; index2 < toLine; index2 += 1) {
    const range = computeLinePmRange$1(block, lines[index2]);
    if (range.pmStart != null && pmStart == null) {
      pmStart = range.pmStart;
    }
    if (range.pmEnd != null) {
      pmEnd = range.pmEnd;
    }
  }
  return { pmStart, pmEnd };
}
function resolveSpacingIndent(style2, numbering) {
  const spacing = {
    before: style2.spacing?.before ?? 0,
    after: style2.spacing?.after ?? 0,
    line: style2.spacing?.line ?? 12,
    // Default line spacing
    lineRule: style2.spacing?.lineRule ?? "auto"
  };
  let indent = {
    left: style2.indent?.left ?? 0,
    right: style2.indent?.right ?? 0,
    firstLine: style2.indent?.firstLine ?? 0,
    hanging: style2.indent?.hanging ?? 0
  };
  if (numbering?.indent) {
    indent = {
      ...indent,
      left: numbering.indent.left ?? indent.left,
      hanging: numbering.indent.hanging ?? indent.hanging
    };
  }
  return { spacing, indent };
}
function formatListLabel(level, indices) {
  const { format, text: template, start: start2 } = level;
  if (format === "bullet" || format === "custom") {
    return {
      text: template,
      width: estimateTextWidth(template)
    };
  }
  let result = template;
  for (let i = 0; i < indices.length; i++) {
    const placeholder = `%${i + 1}`;
    if (result.includes(placeholder)) {
      const formattedNum = formatNumber(indices[i] + start2 - 1, format);
      result = result.replace(placeholder, formattedNum);
    }
  }
  return {
    text: result,
    width: estimateTextWidth(result)
  };
}
function computeListIndent(level) {
  const { indent } = level;
  return {
    labelWidth: Math.abs(indent.hanging),
    hangingIndent: indent.hanging,
    firstLineIndent: indent.left - Math.abs(indent.hanging)
  };
}
function formatNumber(num, format) {
  switch (format) {
    case "decimal":
      return num.toString();
    case "lowerLetter":
      return toLetter(num, false);
    case "upperLetter":
      return toLetter(num, true);
    case "lowerRoman":
      return toRoman(num).toLowerCase();
    case "upperRoman":
      return toRoman(num);
    default:
      return num.toString();
  }
}
function toLetter(num, uppercase) {
  let result = "";
  let n = num;
  while (n > 0) {
    const remainder = (n - 1) % 26;
    const char = String.fromCharCode((uppercase ? 65 : 97) + remainder);
    result = char + result;
    n = Math.floor((n - 1) / 26);
  }
  return result || (uppercase ? "A" : "a");
}
function toRoman(num) {
  const lookup = [
    [1e3, "M"],
    [900, "CM"],
    [500, "D"],
    [400, "CD"],
    [100, "C"],
    [90, "XC"],
    [50, "L"],
    [40, "XL"],
    [10, "X"],
    [9, "IX"],
    [5, "V"],
    [4, "IV"],
    [1, "I"]
  ];
  let result = "";
  let remaining = num;
  for (const [value, numeral] of lookup) {
    while (remaining >= value) {
      result += numeral;
      remaining -= value;
    }
  }
  return result;
}
function estimateTextWidth(text) {
  return text.length * 7;
}
function scaleWrapPolygon(ooxml, imageRect) {
  if (!ooxml || ooxml.length === 0) {
    return [];
  }
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const [x, y2] of ooxml) {
    minX = Math.min(minX, x);
    minY = Math.min(minY, y2);
    maxX = Math.max(maxX, x);
    maxY = Math.max(maxY, y2);
  }
  const ooxmlWidth = maxX - minX;
  const ooxmlHeight = maxY - minY;
  if (ooxmlWidth === 0 || ooxmlHeight === 0) {
    return [];
  }
  const scaleX = imageRect.width / ooxmlWidth;
  const scaleY = imageRect.height / ooxmlHeight;
  return ooxml.map(([x, y2]) => [imageRect.x + (x - minX) * scaleX, imageRect.y + (y2 - minY) * scaleY]);
}
function computeWrapExclusion(image, lineY, lineHeight2) {
  const { rect, wrap } = image;
  const top2 = rect.y - (wrap.distTop ?? 0);
  const bottom2 = rect.y + rect.height + (wrap.distBottom ?? 0);
  const left2 = rect.x - (wrap.distLeft ?? 0);
  const right2 = rect.x + rect.width + (wrap.distRight ?? 0);
  const lineBottom = lineY + lineHeight2;
  if (lineBottom <= top2 || lineY >= bottom2) {
    return null;
  }
  switch (wrap.type) {
    case "None":
      return null;
    case "TopAndBottom":
      return null;
    case "Square":
      return { left: left2, right: right2 };
    case "Tight":
    case "Through": {
      if (!wrap.polygon || wrap.polygon.length === 0) {
        return { left: left2, right: right2 };
      }
      const polygon = wrap.polygon;
      const midY = lineY + lineHeight2 / 2;
      let polyLeft = Infinity;
      let polyRight = -Infinity;
      for (let i = 0; i < polygon.length; i++) {
        const [x1, y1] = polygon[i];
        const [x2, y2] = polygon[(i + 1) % polygon.length];
        const edgeMinY = Math.min(y1, y2);
        const edgeMaxY = Math.max(y1, y2);
        if (midY >= edgeMinY && midY <= edgeMaxY) {
          const t = (midY - y1) / (y2 - y1);
          const x = x1 + t * (x2 - x1);
          polyLeft = Math.min(polyLeft, x);
          polyRight = Math.max(polyRight, x);
        }
      }
      if (polyLeft === Infinity || polyRight === -Infinity) {
        return null;
      }
      return {
        left: polyLeft - (wrap.distLeft ?? 0),
        right: polyRight + (wrap.distRight ?? 0)
      };
    }
    default:
      return null;
  }
}
const Engines = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  OOXML_PCT_DIVISOR,
  calculateTabWidth,
  computeListIndent,
  computeTabStops: computeTabStops$1,
  computeWrapExclusion,
  formatListLabel,
  layoutWithTabs,
  measureRowHeights,
  resolveColumnWidths,
  resolveSpacingIndent,
  scaleWrapPolygon
}, Symbol.toStringTag, { value: "Module" }));
var _ = {
  accentBorderCallout1: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "#000000", stroke: "#000000" },
      { d: "M -8.333 0 Z L -8.333 100", fill: "none", stroke: "#000000" },
      { d: "M -8.333 18.75 L -38.333 112.5", fill: "none", stroke: "#000000" }
    ]
  },
  accentBorderCallout2: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "#000000", stroke: "#000000" },
      { d: "M -8.333 0 Z L -8.333 100", fill: "none", stroke: "#000000" },
      { d: "M -8.333 18.75 L -16.667 18.75 L -46.667 112.5", fill: "none", stroke: "#000000" }
    ]
  },
  accentBorderCallout3: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "#000000", stroke: "#000000" },
      { d: "M -8.333 0 Z L -8.333 100", fill: "none", stroke: "#000000" },
      { d: "M -8.333 18.75 L -16.667 18.75 L -16.667 100 L -8.333 112.963", fill: "none", stroke: "#000000" }
    ]
  },
  accentCallout1: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "#000000", stroke: "none" },
      { d: "M -8.333 0 Z L -8.333 100", fill: "none", stroke: "#000000" },
      { d: "M -8.333 18.75 L -38.333 112.5", fill: "none", stroke: "#000000" }
    ]
  },
  accentCallout2: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "#000000", stroke: "none" },
      { d: "M -8.333 0 Z L -8.333 100", fill: "none", stroke: "#000000" },
      { d: "M -8.333 18.75 L -16.667 18.75 L -46.667 112.5", fill: "none", stroke: "#000000" }
    ]
  },
  accentCallout3: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "#000000", stroke: "none" },
      { d: "M -8.333 0 Z L -8.333 100", fill: "none", stroke: "#000000" },
      { d: "M -8.333 18.75 L -16.667 18.75 L -16.667 100 L -8.333 112.963", fill: "none", stroke: "#000000" }
    ]
  },
  actionButtonBackPrevious: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 L 100 0 L 100 100 L 0 100 Z M 12.5 50 L 87.5 12.5 L 87.5 87.5 Z",
        fill: "#000000",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      { d: "M 12.5 50 L 87.5 12.5 L 87.5 87.5 Z", fill: "color-mix(in srgb, currentColor 60%, black)", stroke: "none" },
      { d: "M 12.5 50 L 87.5 12.5 L 87.5 87.5 Z", fill: "none", stroke: "#000000" },
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "none", stroke: "#000000" }
    ]
  },
  actionButtonBeginning: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 L 100 0 L 100 100 L 0 100 Z M 31.25 50 L 87.5 12.5 L 87.5 87.5 Z M 21.875 12.5 L 12.5 12.5 L 12.5 87.5 L 21.875 87.5 Z",
        fill: "#000000",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 31.25 50 L 87.5 12.5 L 87.5 87.5 Z M 21.875 12.5 L 12.5 12.5 L 12.5 87.5 L 21.875 87.5 Z",
        fill: "color-mix(in srgb, currentColor 60%, black)",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 31.25 50 L 87.5 12.5 L 87.5 87.5 Z M 21.875 12.5 L 21.875 87.5 L 12.5 87.5 L 12.5 12.5 Z",
        fill: "none",
        stroke: "#000000"
      },
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "none", stroke: "#000000" }
    ]
  },
  actionButtonBlank: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  actionButtonDocument: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 L 100 0 L 100 100 L 0 100 Z M 21.875 12.5 L 59.375 12.5 L 78.125 31.25 L 78.125 87.5 L 21.875 87.5 Z",
        fill: "#000000",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 21.875 12.5 L 59.375 12.5 L 59.375 31.25 L 78.125 31.25 L 78.125 87.5 L 21.875 87.5 Z",
        fill: "color-mix(in srgb, currentColor 80%, black)",
        stroke: "none"
      },
      {
        d: "M 59.375 12.5 L 59.375 31.25 L 78.125 31.25 Z",
        fill: "color-mix(in srgb, currentColor 60%, black)",
        stroke: "none"
      },
      {
        d: "M 21.875 12.5 L 59.375 12.5 L 78.125 31.25 L 78.125 87.5 L 21.875 87.5 Z M 78.125 31.25 L 59.375 31.25 L 59.375 12.5",
        fill: "none",
        stroke: "#000000"
      },
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "none", stroke: "#000000" }
    ]
  },
  actionButtonEnd: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 L 100 0 L 100 100 L 0 100 Z M 68.75 50 L 12.5 12.5 L 12.5 87.5 Z M 78.125 12.5 L 87.5 12.5 L 87.5 87.5 L 78.125 87.5 Z",
        fill: "#000000",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 68.75 50 L 12.5 12.5 L 12.5 87.5 Z M 78.125 12.5 L 87.5 12.5 L 87.5 87.5 L 78.125 87.5 Z",
        fill: "color-mix(in srgb, currentColor 60%, black)",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 68.75 50 L 12.5 87.5 L 12.5 12.5 Z M 78.125 12.5 L 87.5 12.5 L 87.5 87.5 L 78.125 87.5 Z",
        fill: "none",
        stroke: "#000000"
      },
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "none", stroke: "#000000" }
    ]
  },
  actionButtonForwardNext: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 L 100 0 L 100 100 L 0 100 Z M 87.5 50 L 12.5 12.5 L 12.5 87.5 Z",
        fill: "#000000",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      { d: "M 87.5 50 L 12.5 12.5 L 12.5 87.5 Z", fill: "color-mix(in srgb, currentColor 60%, black)", stroke: "none" },
      { d: "M 87.5 50 L 12.5 87.5 L 12.5 12.5 Z", fill: "none", stroke: "#000000" },
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "none", stroke: "#000000" }
    ]
  },
  actionButtonHelp: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 L 100 0 L 100 100 L 0 100 Z M 28.571428571428573 33.92857142857143 A 21.428571428571427 21.428571428571427 0 0 1 71.42857142857143 33.92857142857142 A 10.714285714285714 16.071428571428573 0 0 1 60.714285714285715 50 A 5.357142857142857 8.035714285714286 0 0 0 55.35714285714286 58.035714285714285 L 55.357142857142854 68.75 L 44.642857142857146 68.75 L 44.642857142857146 58.035714285714285 A 10.714285714285714 16.071428571428573 0 0 1 55.35714285714286 41.96428571428571 A 5.357142857142857 8.035714285714286 0 0 0 60.714285714285715 33.92857142857142 A 10.714285714285714 10.714285714285714 0 0 0 39.285714285714285 33.92857142857142 Z M 50 71.42857142857143 A 8.035714285714286 8.035714285714286 0 0 1 50 87.50000000000001 A 8.035714285714286 8.035714285714286 0 0 1 50 71.42857142857143 Z",
        fill: "#000000",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 28.571428571428573 33.92857142857143 A 21.428571428571427 21.428571428571427 0 0 1 71.42857142857143 33.92857142857142 A 10.714285714285714 16.071428571428573 0 0 1 60.714285714285715 50 A 5.357142857142857 8.035714285714286 0 0 0 55.35714285714286 58.035714285714285 L 55.357142857142854 68.75 L 44.642857142857146 68.75 L 44.642857142857146 58.035714285714285 A 10.714285714285714 16.071428571428573 0 0 1 55.35714285714286 41.96428571428571 A 5.357142857142857 8.035714285714286 0 0 0 60.714285714285715 33.92857142857142 A 10.714285714285714 10.714285714285714 0 0 0 39.285714285714285 33.92857142857142 Z M 50 71.42857142857143 A 8.035714285714286 8.035714285714286 0 0 1 50 87.50000000000001 A 8.035714285714286 8.035714285714286 0 0 1 50 71.42857142857143 Z",
        fill: "color-mix(in srgb, currentColor 60%, black)",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 28.571428571428573 33.92857142857143 A 21.428571428571427 21.428571428571427 0 0 1 71.42857142857143 33.92857142857142 A 10.714285714285714 16.071428571428573 0 0 1 60.714285714285715 50 A 5.357142857142857 8.035714285714286 0 0 0 55.35714285714286 58.035714285714285 L 55.357142857142854 68.75 L 44.642857142857146 68.75 L 44.642857142857146 58.035714285714285 A 10.714285714285714 16.071428571428573 0 0 1 55.35714285714286 41.96428571428571 A 5.357142857142857 8.035714285714286 0 0 0 60.714285714285715 33.92857142857142 A 10.714285714285714 10.714285714285714 0 0 0 39.285714285714285 33.92857142857142 Z M 50 71.42857142857143 A 8.035714285714286 8.035714285714286 0 0 1 50 87.50000000000001 A 8.035714285714286 8.035714285714286 0 0 1 50 71.42857142857143 Z",
        fill: "none",
        stroke: "#000000"
      },
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "none", stroke: "#000000" }
    ]
  },
  actionButtonHome: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 L 100 0 L 100 100 L 0 100 Z M 50 12.5 L 12.5 50 L 21.875 50 L 21.875 87.5 L 78.125 87.5 L 78.125 50 L 87.5 50 L 73.4375 35.9375 L 73.4375 17.1875 L 64.0625 17.1875 L 64.0625 26.5625 Z",
        fill: "#000000",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 73.4375 35.9375 L 73.4375 17.1875 L 64.0625 17.1875 L 64.0625 26.5625 Z M 21.875 50 L 21.875 87.5 L 45.3125 87.5 L 45.3125 68.75 L 54.6875 68.75 L 54.6875 87.5 L 78.125 87.5 L 78.125 50 Z",
        fill: "color-mix(in srgb, currentColor 80%, black)",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 50 12.5 L 12.5 50 L 87.5 50 Z M 45.3125 68.75 L 54.6875 68.75 L 54.6875 87.5 L 45.3125 87.5 Z",
        fill: "color-mix(in srgb, currentColor 60%, black)",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 50 12.5 L 64.0625 26.5625 L 64.0625 17.1875 L 73.4375 17.1875 L 73.4375 35.9375 L 87.5 50 L 78.125 50 L 78.125 87.5 L 21.875 87.5 L 21.875 50 L 12.5 50 Z M 64.0625 26.5625 L 73.4375 35.9375 M 78.125 50 L 21.875 50 M 45.3125 87.5 L 45.3125 68.75 L 54.6875 68.75 L 54.6875 87.5",
        fill: "none",
        stroke: "#000000"
      },
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "none", stroke: "#000000" }
    ]
  },
  actionButtonInformation: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 L 100 0 L 100 100 L 0 100 Z M 50 12.5 A 37.5 37.5 0 0 1 50.00000000000002 87.5 A 37.5 37.5 0 0 1 49.99999999999999 12.5 Z",
        fill: "#000000",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 50 12.5 A 37.5 37.5 0 0 1 50.00000000000002 87.5 A 37.5 37.5 0 0 1 49.99999999999999 12.5 Z M 50 14.84375 A 7.03125 7.03125 0 0 1 50 28.90625 A 7.03125 7.03125 0 0 1 50 14.84375 M 35.9375 35.9375 L 35.9375 40.625 L 42.96875 40.625 L 42.96875 73.4375 L 35.9375 73.4375 L 35.9375 78.125 L 64.0625 78.125 L 64.0625 73.4375 L 57.03125 73.4375 L 57.03125 35.9375 Z",
        fill: "color-mix(in srgb, currentColor 60%, black)",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 50 14.84375 A 7.03125 7.03125 0 0 1 50 28.90625 A 7.03125 7.03125 0 0 1 50 14.84375 M 35.9375 35.9375 L 57.03125 35.9375 L 57.03125 73.4375 L 64.0625 73.4375 L 64.0625 78.125 L 35.9375 78.125 L 35.9375 73.4375 L 42.96875 73.4375 L 42.96875 40.625 L 35.9375 40.625 Z",
        fill: "color-mix(in srgb, currentColor 60%, white)",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 50 12.5 A 37.5 37.5 0 0 1 50.00000000000002 87.5 A 37.5 37.5 0 0 1 49.99999999999999 12.5 Z M 50 14.84375 A 7.03125 7.03125 0 0 1 50 28.90625 A 7.03125 7.03125 0 0 1 50 14.84375 M 35.9375 35.9375 L 57.03125 35.9375 L 57.03125 73.4375 L 64.0625 73.4375 L 64.0625 78.125 L 35.9375 78.125 L 35.9375 73.4375 L 42.96875 73.4375 L 42.96875 40.625 L 35.9375 40.625 Z",
        fill: "none",
        stroke: "#000000"
      },
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "none", stroke: "#000000" }
    ]
  },
  actionButtonMovie: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 L 100 0 L 100 100 L 0 100 Z M 12.5 30.833333333333332 L 12.5 45.677083333333336 L 17.552083333333332 45.677083333333336 L 19.114583333333332 43.982638888888886 L 20.572916666666664 43.982638888888886 L 20.572916666666664 66.63888888888889 L 71.5625 66.63888888888889 L 71.5625 58.826388888888886 L 79.63541666666667 58.826388888888886 L 84.01041666666667 63.125 L 87.5 63.125 L 87.5 35.52083333333333 L 84.01041666666667 35.52083333333333 L 80.98958333333333 38.513888888888886 L 71.5625 38.513888888888886 L 71.5625 35.52083333333333 L 68.59375 32.39583333333333 L 19.114583333333332 32.39583333333333 L 17.552083333333332 30.833333333333332 Z",
        fill: "#000000",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 12.5 30.833333333333332 L 12.5 45.677083333333336 L 17.552083333333332 45.677083333333336 L 19.114583333333332 43.982638888888886 L 20.572916666666664 43.982638888888886 L 20.572916666666664 66.63888888888889 L 71.5625 66.63888888888889 L 71.5625 58.826388888888886 L 79.63541666666667 58.826388888888886 L 84.01041666666667 63.125 L 87.5 63.125 L 87.5 35.52083333333333 L 84.01041666666667 35.52083333333333 L 80.98958333333333 38.513888888888886 L 71.5625 38.513888888888886 L 71.5625 35.52083333333333 L 68.59375 32.39583333333333 L 19.114583333333332 32.39583333333333 L 17.552083333333332 30.833333333333332 Z",
        fill: "color-mix(in srgb, currentColor 60%, black)",
        stroke: "none"
      },
      {
        d: "M 12.5 30.833333333333332 L 17.552083333333332 30.833333333333332 L 19.114583333333332 32.39583333333333 L 68.59375 32.39583333333333 L 71.5625 35.52083333333333 L 71.5625 38.513888888888886 L 80.98958333333333 38.513888888888886 L 84.01041666666667 35.52083333333333 L 87.5 35.52083333333333 L 87.5 63.125 L 84.01041666666667 63.125 L 79.63541666666667 58.826388888888886 L 71.5625 58.826388888888886 L 71.5625 66.63888888888889 L 20.572916666666664 66.63888888888889 L 20.572916666666664 43.982638888888886 L 19.114583333333332 43.982638888888886 L 17.552083333333332 45.677083333333336 L 12.5 45.677083333333336 Z",
        fill: "none",
        stroke: "#000000"
      },
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "none", stroke: "#000000" }
    ]
  },
  actionButtonReturn: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 L 100 0 L 100 100 L 0 100 Z M 87.5 31.25 L 68.75 12.5 L 50 31.25 L 59.375 31.25 L 59.375 59.375 A 9.375 9.375 0 0 1 50 68.75 L 40.625 68.75 A 9.375 9.375 0 0 1 31.25 59.375 L 31.25 31.25 L 12.5 31.25 L 12.5 59.375 A 28.125 28.125 0 0 0 40.625 87.5 L 50 87.5 A 28.125 28.125 0 0 0 78.125 59.375 L 78.125 31.25 Z",
        fill: "#000000",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 87.5 31.25 L 68.75 12.5 L 50 31.25 L 59.375 31.25 L 59.375 59.375 A 9.375 9.375 0 0 1 50 68.75 L 40.625 68.75 A 9.375 9.375 0 0 1 31.25 59.375 L 31.25 31.25 L 12.5 31.25 L 12.5 59.375 A 28.125 28.125 0 0 0 40.625 87.5 L 50 87.5 A 28.125 28.125 0 0 0 78.125 59.375 L 78.125 31.25 Z",
        fill: "color-mix(in srgb, currentColor 60%, black)",
        stroke: "none"
      },
      {
        d: "M 87.5 31.25 L 78.125 31.25 L 78.125 59.375 A 28.125 28.125 0 0 1 50 87.5 L 40.625 87.5 A 28.125 28.125 0 0 1 12.5 59.375 L 12.5 31.25 L 31.25 31.25 L 31.25 59.375 A 9.375 9.375 0 0 0 40.625 68.75 L 50 68.75 A 9.375 9.375 0 0 0 59.375 59.375 L 59.375 31.25 L 50 31.25 L 68.75 12.5 Z",
        fill: "none",
        stroke: "#000000"
      },
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "none", stroke: "#000000" }
    ]
  },
  actionButtonSound: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 L 100 0 L 100 100 L 0 100 Z M 12.5 35.9375 L 12.5 64.0625 L 35.9375 64.0625 L 59.375 87.5 L 59.375 12.5 L 35.9375 35.9375 Z",
        fill: "#000000",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 12.5 35.9375 L 12.5 64.0625 L 35.9375 64.0625 L 59.375 87.5 L 59.375 12.5 L 35.9375 35.9375 Z",
        fill: "color-mix(in srgb, currentColor 60%, black)",
        stroke: "none"
      },
      {
        d: "M 12.5 35.9375 L 35.9375 35.9375 L 59.375 12.5 L 59.375 87.5 L 35.9375 64.0625 L 12.5 64.0625 Z M 68.75 35.9375 L 87.5 21.875 M 68.75 50 L 87.5 50 M 68.75 64.0625 L 87.5 78.125",
        fill: "none",
        stroke: "#000000"
      },
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "none", stroke: "#000000" }
    ]
  },
  arc: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 49.99999999999999 0 A 50 50 0 0 1 100 49.999999999999986", fill: "none", stroke: "#000000" }]
  },
  bentArrow: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 100 L 0 56.25 A 43.75 43.75 0 0 1 43.74999999999999 12.499999999999993 L 75 12.5 L 75 0 L 100 25 L 75 50 L 75 37.5 L 43.75 37.5 A 18.75 18.75 0 0 0 25 56.25 L 25 100 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  bentConnector2: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 0 L 100 0 L 100 100", fill: "none", stroke: "#000000" }]
  },
  bentConnector3: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 0 L 50 0 L 50 100 L 100 100", fill: "none", stroke: "#000000" }]
  },
  bentConnector4: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 0 L 50 0 L 50 50 L 100 50 L 100 100", fill: "none", stroke: "#000000" }]
  },
  bentConnector5: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 0 L 50 0 L 50 50 L 50 50 L 50 100 L 100 100", fill: "none", stroke: "#000000" }]
  },
  bentUpArrow: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 75 L 62.5 75 L 62.5 25 L 50 25 L 75 0 L 100 25 L 87.5 25 L 87.5 100 L 0 100 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  bevel: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 12.5 12.5 L 87.5 12.5 L 87.5 87.5 L 12.5 87.5 Z", fill: "#000000", stroke: "none" },
      {
        d: "M 0 0 L 100 0 L 87.5 12.5 L 12.5 12.5 Z",
        fill: "color-mix(in srgb, currentColor 80%, white)",
        stroke: "none"
      },
      {
        d: "M 0 100 L 12.5 87.5 L 87.5 87.5 L 100 100 Z",
        fill: "color-mix(in srgb, currentColor 80%, black)",
        stroke: "none"
      },
      {
        d: "M 0 0 L 12.5 12.5 L 12.5 87.5 L 0 100 Z",
        fill: "color-mix(in srgb, currentColor 60%, white)",
        stroke: "none"
      },
      {
        d: "M 100 0 L 100 100 L 87.5 87.5 L 87.5 12.5 Z",
        fill: "color-mix(in srgb, currentColor 60%, black)",
        stroke: "none"
      },
      {
        d: "M 0 0 L 100 0 L 100 100 L 0 100 Z M 12.5 12.5 L 87.5 12.5 L 87.5 87.5 L 12.5 87.5 Z M 0 0 L 12.5 12.5 M 0 100 L 12.5 87.5 M 100 0 L 87.5 12.5 M 100 100 L 87.5 87.5",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  blockArc: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50.00000000000001 A 50 50 0 0 1 100 49.999999999999986 L 75 50 A 25 25 0 0 0 25 50 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  borderCallout1: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "#000000", stroke: "#000000" },
      { d: "M -8.333 18.75 L -38.333 112.5", fill: "none", stroke: "#000000" }
    ]
  },
  borderCallout2: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "#000000", stroke: "#000000" },
      { d: "M -8.333 18.75 L -16.667 18.75 L -46.667 112.5", fill: "none", stroke: "#000000" }
    ]
  },
  borderCallout3: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "#000000", stroke: "#000000" },
      { d: "M -8.333 18.75 L -16.667 18.75 L -16.667 100 L -8.333 112.963", fill: "none", stroke: "#000000" }
    ]
  },
  bracePair: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 16.666 100 A 8.333 8.333 0 0 1 8.333 91.667 L 8.333 58.333 A 8.333 8.333 0 0 0 5.102490888647448e-16 50 A 8.333 8.333 0 0 0 8.333 41.667 L 8.333 8.333 A 8.333 8.333 0 0 1 16.666 -1.7763568394002505e-15 L 83.334 0 A 8.333 8.333 0 0 1 91.667 8.332999999999998 L 91.667 41.667 A 8.333 8.333 0 0 0 100 50 A 8.333 8.333 0 0 0 91.667 58.333 L 91.667 91.667 A 8.333 8.333 0 0 1 83.334 100 Z",
        fill: "#000000",
        stroke: "none"
      },
      {
        d: "M 16.666 100 A 8.333 8.333 0 0 1 8.333 91.667 L 8.333 58.333 A 8.333 8.333 0 0 0 5.102490888647448e-16 50 A 8.333 8.333 0 0 0 8.333 41.667 L 8.333 8.333 A 8.333 8.333 0 0 1 16.666 -1.7763568394002505e-15 M 83.334 0 A 8.333 8.333 0 0 1 91.667 8.332999999999998 L 91.667 41.667 A 8.333 8.333 0 0 0 100 50 A 8.333 8.333 0 0 0 91.667 58.333 L 91.667 91.667 A 8.333 8.333 0 0 1 83.334 100",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  bracketPair: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 16.667 A 16.667 16.667 0 0 1 16.666999999999998 -3.552713678800501e-15 L 83.333 0 A 16.667 16.667 0 0 1 100 16.666999999999998 L 100 83.333 A 16.667 16.667 0 0 1 83.333 100 L 16.667 100 A 16.667 16.667 0 0 1 0 83.333 Z",
        fill: "#000000",
        stroke: "none"
      },
      {
        d: "M 16.667 100 A 16.667 16.667 0 0 1 0 83.333 L 0 16.667 A 16.667 16.667 0 0 1 16.666999999999998 -3.552713678800501e-15 M 83.333 0 A 16.667 16.667 0 0 1 100 16.666999999999998 L 100 83.333 A 16.667 16.667 0 0 1 83.333 100",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  callout1: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "#000000", stroke: "none" },
      { d: "M -8.333 18.75 L -38.333 112.5", fill: "none", stroke: "#000000" }
    ]
  },
  callout2: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "#000000", stroke: "none" },
      { d: "M -8.333 18.75 L -16.667 18.75 L -46.667 112.5", fill: "none", stroke: "#000000" }
    ]
  },
  callout3: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "#000000", stroke: "none" },
      { d: "M -8.333 18.75 L -16.667 18.75 L -16.667 100 L -8.333 112.963", fill: "none", stroke: "#000000" }
    ]
  },
  can: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 12.5 A 50 12.5 0 0 0 100 12.499999999999998 L 100 87.5 A 50 12.5 0 0 1 0 87.5 Z",
        fill: "#000000",
        stroke: "none"
      },
      {
        d: "M 0 12.5 A 50 12.5 0 0 1 100 12.499999999999995 A 50 12.5 0 0 1 0 12.499999999999996 Z",
        fill: "color-mix(in srgb, currentColor 60%, white)",
        stroke: "none"
      },
      {
        d: "M 100 12.5 A 50 12.5 0 0 1 0 12.500000000000002 A 50 12.5 0 0 1 100 12.499999999999996 L 100 87.5 A 50 12.5 0 0 1 0 87.5 L 0 12.5",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  chartPlus: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 50 0 L 50 100 M 0 50 L 100 50", fill: "none", stroke: "#000000" },
      { d: "M 0 0 L 0 100 L 100 100 L 100 0 Z", fill: "#000000", stroke: "none" }
    ]
  },
  chartStar: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 0 0 L 100 100 M 0 100 L 100 0 M 50 0 L 50 100", fill: "none", stroke: "#000000" },
      { d: "M 0 0 L 0 100 L 100 100 L 100 0 Z", fill: "#000000", stroke: "none" }
    ]
  },
  chartX: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 0 0 L 100 100 M 0 100 L 100 0", fill: "none", stroke: "#000000" },
      { d: "M 0 0 L 0 100 L 100 100 L 100 0 Z", fill: "#000000", stroke: "none" }
    ]
  },
  chevron: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 0 L 50 0 L 100 50 L 50 100 L 0 100 L 50 50 Z", fill: "#000000", stroke: "#000000" }]
  },
  chord: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 85.35533905932738 85.35533905932738 A 50 50 0 0 1 3.806023374435661 69.1341716182545 A 50 50 0 0 1 49.99999999999999 7.105427357601002e-15 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  circularArrow: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 6.25 50.00000000000001 A 43.75 43.75 0 0 1 92.00503607239835 37.76727975646819 L 97.94870282721459 37.767278803641936 L 87.5 49.99999999999999 L 72.94870282721459 37.767278803641936 L 78.75626944045719 37.767278803641936 A 31.25 31.25 0 0 0 18.74999910786014 49.999997902787435 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  cloud: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 9.027777777777777 33.263888888888886 A 15.631944444444443 21.273148148148145 0 0 1 30.57998957216487 9.85246862529543 A 12.344907407407407 16.82175925925926 0 0 1 47.80891412463702 6.079559020422696 A 10.104166666666666 13.761574074074073 0 0 1 63.17482489729218 3.8997359934452227 A 11.243055555555555 15.266203703703702 0 0 1 81.4699864255032 11.79662680033136 A 12.344907407407407 16.83564814814815 0 0 1 89.70950362413667 36.805045586854234 A 15.68287037037037 21.34259259259259 0 0 1 80.50683519493268 73.45235178627696 A 13.391203703703702 18.21064814814815 0 0 1 61.5295304537904 89.80375312777574 A 15.629629629629628 21.33101851851852 0 0 1 35.53836349121606 96.03429219674027 A 17.87037037037037 24.40509259259259 0 0 1 14.265888824303735 88.73812262075411 A 10.092592592592592 13.699074074074073 0 0 1 7.154178969814962 64.32542955825295 A 10.05787037037037 13.761574074074073 0 0 1 10.355981204179617 37.95132232917963 Z",
        fill: "#000000",
        stroke: "#000000"
      },
      {
        d: "M 10.863425925925926 60.594907407407405 A 10.05787037037037 13.761574074074073 0 0 1 6.3341973784947445 59.507019673542544 M 16.037037037037035 80.78472222222221 A 10.092592592592592 13.699074074074073 0 0 1 14.058709360103522 81.29044790335425 M 38.14351851851852 90.4861111111111 A 15.629629629629628 21.33101851851852 0 0 1 35.927529327520006 86.22025847613271 M 66.72916666666666 80.44212962962962 A 15.629629629629628 21.33101851851852 0 0 1 65.64350914942649 86.19106007926317 M 79.00231481481481 53.13425925925926 A 13.391203703703702 18.21064814814815 0 0 1 87.87692721942935 70.4768770248552 M 96.75462962962962 35.541666666666664 A 12.344907407407407 16.83564814814815 0 0 1 92.62714666279902 41.3312984002895 M 88.71296296296296 12.560185185185185 A 11.243055555555555 15.266203703703702 0 0 1 89.03277422425806 16.48423239319878 M 67.31018518518518 9.148148148148147 A 11.243055555555555 15.266203703703702 0 0 1 69.59160776727714 5.445361345350392 M 51.25231481481481 10.925925925925926 A 10.104166666666666 13.761574074074073 0 0 1 52.582357388029564 7.102165159074247 M 32.407407407407405 12.018518518518517 A 15.631944444444443 21.273148148148145 0 0 1 35.32846815343311 14.263252515392796 M 9.55324074074074 36.54861111111111 A 15.631944444444443 21.273148148148145 0 0 1 8.640529037810998 32.332858776375595",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  cloudCallout: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 9.027777777777777 33.263888888888886 A 15.631944444444443 21.273148148148145 0 0 1 30.57998957216487 9.85246862529543 A 12.344907407407407 16.82175925925926 0 0 1 47.80891412463702 6.079559020422696 A 10.104166666666666 13.761574074074073 0 0 1 63.17482489729218 3.8997359934452227 A 11.243055555555555 15.266203703703702 0 0 1 81.4699864255032 11.79662680033136 A 12.344907407407407 16.83564814814815 0 0 1 89.70950362413667 36.805045586854234 A 15.68287037037037 21.34259259259259 0 0 1 80.50683519493268 73.45235178627696 A 13.391203703703702 18.21064814814815 0 0 1 61.5295304537904 89.80375312777574 A 15.629629629629628 21.33101851851852 0 0 1 35.53836349121606 96.03429219674027 A 17.87037037037037 24.40509259259259 0 0 1 14.265888824303735 88.73812262075411 A 10.092592592592592 13.699074074074073 0 0 1 7.154178969814962 64.32542955825295 A 10.05787037037037 13.761574074074073 0 0 1 10.355981204179617 37.95132232917963 Z",
        fill: "#000000",
        stroke: "#000000"
      },
      {
        d: "M 31.94477777777778 112.5 A 2.7777777777777777 2.7777777777777777 0 0 1 26.389222222222223 112.5 A 2.7777777777777777 2.7777777777777777 0 0 1 31.94477777777778 112.5 Z",
        fill: "#000000",
        stroke: "#000000"
      },
      {
        d: "M 35.81090347544299 109.23490399880167 A 5.555555555555555 5.555555555555555 0 0 1 24.699792364331877 109.23490399880167 A 5.555555555555555 5.555555555555555 0 0 1 35.81090347544299 109.23490399880167 Z",
        fill: "#000000",
        stroke: "#000000"
      },
      {
        d: "M 41.43382479714197 100.69933679796284 A 8.333333333333334 8.333333333333334 0 0 1 24.767158130475302 100.69933679796284 A 8.333333333333334 8.333333333333334 0 0 1 41.43382479714197 100.69933679796284 Z",
        fill: "#000000",
        stroke: "#000000"
      },
      {
        d: "M 10.863425925925926 60.594907407407405 A 10.05787037037037 13.761574074074073 0 0 1 6.3341973784947445 59.507019673542544 M 16.037037037037035 80.78472222222221 A 10.092592592592592 13.699074074074073 0 0 1 14.058709360103522 81.29044790335425 M 38.14351851851852 90.4861111111111 A 15.629629629629628 21.33101851851852 0 0 1 35.927529327520006 86.22025847613271 M 66.72916666666666 80.44212962962962 A 15.629629629629628 21.33101851851852 0 0 1 65.64350914942649 86.19106007926317 M 79.00231481481481 53.13425925925926 A 13.391203703703702 18.21064814814815 0 0 1 87.87692721942935 70.4768770248552 M 96.75462962962962 35.541666666666664 A 12.344907407407407 16.83564814814815 0 0 1 92.62714666279902 41.3312984002895 M 88.71296296296296 12.560185185185185 A 11.243055555555555 15.266203703703702 0 0 1 89.03277422425806 16.48423239319878 M 67.31018518518518 9.148148148148147 A 11.243055555555555 15.266203703703702 0 0 1 69.59160776727714 5.445361345350392 M 51.25231481481481 10.925925925925926 A 10.104166666666666 13.761574074074073 0 0 1 52.582357388029564 7.102165159074247 M 32.407407407407405 12.018518518518517 A 15.631944444444443 21.273148148148145 0 0 1 35.32846815343311 14.263252515392796 M 9.55324074074074 36.54861111111111 A 15.631944444444443 21.273148148148145 0 0 1 8.640529037810998 32.332858776375595",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  corner: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 0 L 50 0 L 50 50 L 100 50 L 100 100 L 0 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  cornerTabs: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 0 0 L 7.0710678118654755 0 L 0 7.0710678118654755 Z", fill: "#000000", stroke: "#000000" },
      { d: "M 0 92.92893218813452 L 7.0710678118654755 100 L 0 100 Z", fill: "#000000", stroke: "#000000" },
      { d: "M 92.92893218813452 0 L 100 0 L 100 7.0710678118654755 Z", fill: "#000000", stroke: "#000000" },
      { d: "M 100 92.92893218813452 L 100 100 L 92.92893218813452 100 Z", fill: "#000000", stroke: "#000000" }
    ]
  },
  cube: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 0 25 L 75 25 L 75 100 L 0 100 Z", fill: "#000000", stroke: "none" },
      { d: "M 75 25 L 100 0 L 100 75 L 75 100 Z", fill: "color-mix(in srgb, currentColor 80%, black)", stroke: "none" },
      { d: "M 0 25 L 25 0 L 100 0 L 75 25 Z", fill: "color-mix(in srgb, currentColor 80%, white)", stroke: "none" },
      {
        d: "M 0 25 L 25 0 L 100 0 L 100 75 L 75 100 L 0 100 Z M 0 25 L 75 25 L 100 0 M 75 25 L 75 100",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  curvedConnector2: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 0 C 50 0 100 50 100 100", fill: "none", stroke: "#000000" }]
  },
  curvedConnector3: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 0 C 25 0 50 25 50 50 C 50 75 75 100 100 100", fill: "none", stroke: "#000000" }]
  },
  curvedConnector4: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 C 25 0 50 12.5 50 25 C 50 37.5 62.5 50 75 50 C 87.5 50 100 75 100 100",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  curvedConnector5: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 C 25 0 50 12.5 50 25 C 50 37.5 50 50 50 50 C 50 50 50 62.5 50 75 C 50 87.5 75 100 100 100",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  curvedDownArrow: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 75 100 L 49.00768239224544 75 L 61.50768239224544 75 A 31.25 100 0 0 0 37.416898858120966 38.6950051637524 L 56.25 0 A 31.25 100 0 0 1 80.34078353412448 36.304994836247616 L 99.00768239224544 75 Z",
        fill: "#000000",
        stroke: "none"
      },
      {
        d: "M 43.75 8.348486100883193 A 31.25 100 0 0 0 16.722972521631938 107.43120402663949 L 0 100 A 31.25 100 0 0 1 35.47297252163195 0.9172820742437011 Z",
        fill: "color-mix(in srgb, currentColor 80%, black)",
        stroke: "none"
      },
      {
        d: "M 43.75 8.348486100883193 A 31.25 100 0 0 0 16.722972521631938 107.43120402663949 L 0 100 A 31.25 100 0 0 1 31.249999999999993 -1.4210854715202004e-14 L 56.25 0 A 31.25 100 0 0 1 80.34078353412448 36.304994836247616 L 99.00768239224544 75 L 75 100 L 49.00768239224544 75 L 61.50768239224544 75 A 31.25 100 0 0 0 37.416898858120966 38.6950051637524",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  curvedLeftArrow: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 75 L 25 49.00768239224544 L 25 61.50768239224544 A 100 31.25 0 0 0 60.38771276200397 41.63987137975289 A 100 31.25 0 0 1 25.00000000000007 69.9536274355093 L 25 99.00768239224544 Z",
        fill: "#000000",
        stroke: "none"
      },
      {
        d: "M 100 56.25 A 100 31.25 0 0 0 6.123233995736766e-15 25 L 0 0 A 100 31.25 0 0 1 100.00000000000001 31.249999999999993 Z",
        fill: "color-mix(in srgb, currentColor 80%, black)",
        stroke: "none"
      },
      {
        d: "M 100 56.25 A 100 31.25 0 0 0 6.123233995736766e-15 25 L 0 0 A 100 31.25 0 0 1 100.00000000000001 31.249999999999993 L 100 56.25 A 100 31.25 0 0 1 63.69500516375231 80.34078353412448 L 25 99.00768239224544 L 0 75 L 25 49.00768239224544 L 25 61.50768239224544 A 100 31.25 0 0 0 60.38771276200397 41.63987137975289",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  curvedRightArrow: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 31.25 A 100 31.25 0 0 0 36.30499483624771 55.34078353412449 L 75 49.00768239224544 L 100 75 L 75 99.00768239224544 L 75 86.50768239224544 A 100 31.25 0 0 1 38.695005163752285 62.41689885812095 Z",
        fill: "#000000",
        stroke: "none"
      },
      {
        d: "M 100 25 A 100 31.25 0 0 0 0.9172820742437295 52.02702747836806 A 100 31.25 0 0 1 100 16.55405495673611 Z",
        fill: "color-mix(in srgb, currentColor 80%, black)",
        stroke: "none"
      },
      {
        d: "M 0 31.25 A 100 31.25 0 0 0 36.30499483624771 55.34078353412449 L 75 49.00768239224544 L 100 75 L 75 99.00768239224544 L 75 86.50768239224544 A 100 31.25 0 0 1 38.695005163752285 62.41689885812095 L 0 31.25 A 100 31.25 0 0 1 99.99999999999999 -3.552713678800501e-15 L 100 25 A 100 31.25 0 0 0 0.9172820742437295 52.02702747836806",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  curvedUpArrow: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 75 0 L 99.00768239224544 25 L 86.50768239224544 25 A 31.25 100 0 0 1 58.19392633648901 60.38771276200398 A 31.25 100 0 0 0 78.06173734898155 25 L 49.00768239224544 25 Z",
        fill: "#000000",
        stroke: "none"
      },
      {
        d: "M 31.25 100 A 31.25 100 0 0 1 -3.552713678800501e-15 1.2246467991473532e-14 L 25 0 A 31.25 100 0 0 0 56.25 99.99999999999999 Z",
        fill: "color-mix(in srgb, currentColor 80%, black)",
        stroke: "none"
      },
      {
        d: "M 43.75 91.65151389911681 A 31.25 100 0 0 0 63.61781101249255 56.26380113711283 L 49.00768239224544 25 L 75 0 L 99.00768239224544 25 L 86.50768239224544 25 A 31.25 100 0 0 1 62.41689885812095 61.304994836247694 L 31.25 100 A 31.25 100 0 0 1 -3.552713678800501e-15 1.2246467991473532e-14 L 25 0 A 31.25 100 0 0 0 56.25 99.99999999999999",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  decagon: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 L 9.54915028125263 19.09836593122781 L 34.54915028125263 0.00010576881489043899 L 65.45084971874738 0.00010576881489043899 L 90.45084971874738 19.09836593122781 L 100 50 L 90.45084971874738 80.90163406877218 L 65.45084971874738 99.99989423118511 L 34.54915028125263 99.99989423118511 L 9.54915028125263 80.90163406877218 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  diagStripe: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 50 L 50 0 L 100 0 L 0 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  diamond: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 50 L 50 0 L 100 50 L 50 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  dodecagon: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 36.601851851851855 L 13.398148148148149 13.398148148148149 L 36.601851851851855 0 L 63.398148148148145 0 L 86.60185185185185 13.398148148148149 L 100 36.601851851851855 L 100 63.398148148148145 L 86.60185185185185 86.60185185185185 L 63.398148148148145 100 L 36.601851851851855 100 L 13.398148148148149 86.60185185185185 L 0 63.398148148148145 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  donut: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 A 50 50 0 0 1 49.99999999999999 -7.105427357601002e-15 A 50 50 0 0 1 100 49.99999999999998 A 50 50 0 0 1 50 99.99999999999997 A 50 50 0 0 1 0 49.99999999999998 Z M 25 50 A 25 25 0 0 0 50 75 A 25 25 0 0 0 75 50 A 25 25 0 0 0 50 25 A 25 25 0 0 0 25.000000000000007 50 Z",
        fill: "#000000",
        stroke: "#000000",
        fillRule: "evenodd",
        clipRule: "evenodd"
      }
    ]
  },
  doubleWave: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 6.25 C 16.666666666666668 -14.583333333333332 33.333333333333336 27.083333333333332 50 6.25 C 66.66666666666667 -14.583333333333332 83.33333333333334 27.083333333333332 100 6.25 L 100 93.75 C 83.33333333333334 114.58333333333333 66.66666666666667 72.91666666666667 50 93.75 C 33.333333333333336 114.58333333333333 16.666666666666668 72.91666666666667 0 93.75 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  downArrow: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 50 L 25 50 L 25 0 L 75 0 L 75 50 L 100 50 L 50 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  downArrowCallout: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 L 100 0 L 100 64.977 L 62.5 64.977 L 62.5 75 L 75 75 L 50 100 L 25 75 L 37.5 75 L 37.5 64.977 L 0 64.977 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  ellipse: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 A 50 50 0 0 1 49.99999999999999 -7.105427357601002e-15 A 50 50 0 0 1 100 49.99999999999998 A 50 50 0 0 1 50 99.99999999999997 A 50 50 0 0 1 0 49.99999999999998 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  ellipseRibbon: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 Q 18.75 9.375 37.5 11.71875 L 25 21.875 Q 50 28.125 75 21.875 L 62.5 11.71875 Q 81.25 9.375 100 0 L 87.5 42.96875 L 100 75 Q 87.5 81.25 75 84.375 L 75 96.875 Q 50 103.125 25 96.875 L 25 84.375 Q 12.5 81.25 0 75 L 12.5 42.96875 Z",
        fill: "#000000",
        stroke: "none"
      },
      {
        d: "M 37.5 24.21875 L 37.5 11.71875 L 25 21.875 Q 50 28.125 75 21.875 L 62.5 11.71875 L 62.5 24.21875 Q 50 25.78125 37.5 24.21875 Z",
        fill: "color-mix(in srgb, currentColor 80%, black)",
        stroke: "none"
      },
      {
        d: "M 0 0 Q 18.75 9.375 37.5 11.71875 L 25 21.875 Q 50 28.125 75 21.875 L 62.5 11.71875 Q 81.25 9.375 100 0 L 87.5 42.96875 L 100 75 Q 87.5 81.25 75 84.375 L 75 96.875 Q 50 103.125 25 96.875 L 25 84.375 Q 12.5 81.25 0 75 L 12.5 42.96875 Z M 25 84.375 L 25 21.875 M 75 21.875 L 75 84.375 M 37.5 11.71875 L 37.5 24.21875 M 62.5 24.21875 L 62.5 11.71875",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  ellipseRibbon2: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 100 Q 18.75 90.625 37.5 88.28125 L 25 78.125 Q 50 71.875 75 78.125 L 62.5 88.28125 Q 81.25 90.625 100 100 L 87.5 57.03125 L 100 25 Q 87.5 18.75 75 15.625 L 75 3.125 Q 50 -3.125 25 3.125 L 25 15.625 Q 12.5 18.75 0 25 L 12.5 57.03125 Z",
        fill: "#000000",
        stroke: "none"
      },
      {
        d: "M 37.5 75.78125 L 37.5 88.28125 L 25 78.125 Q 50 71.875 75 78.125 L 62.5 88.28125 L 62.5 75.78125 Q 50 74.21875 37.5 75.78125 Z",
        fill: "color-mix(in srgb, currentColor 80%, black)",
        stroke: "none"
      },
      {
        d: "M 0 100 L 12.5 57.03125 L 0 25 Q 12.5 18.75 25 15.625 L 25 3.125 Q 50 -3.125 75 3.125 L 75 15.625 Q 87.5 18.75 100 25 L 87.5 57.03125 L 100 100 Q 81.25 90.625 62.5 88.28125 L 75 78.125 Q 50 71.875 25 78.125 L 37.5 88.28125 Q 18.75 90.625 0 100 Z M 25 78.125 L 25 15.625 M 75 15.625 L 75 78.125 M 37.5 75.78125 L 37.5 88.28125 M 62.5 88.28125 L 62.5 75.78125",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  flowChartAlternateProcess: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 A 0 0 0 0 1 0 0 L 100 0 A 0 0 0 0 1 100 0 L 100 100 A 0 0 0 0 1 100 100 L 0 100 A 0 0 0 0 1 0 100 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  flowChartCollate: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 0 L 100 0 L 50 50 L 100 100 L 0 100 L 50 50 Z", fill: "#000000", stroke: "#000000" }]
  },
  flowChartConnector: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 A 50 50 0 0 1 49.99999999999999 -7.105427357601002e-15 A 50 50 0 0 1 100 49.99999999999998 A 50 50 0 0 1 50 99.99999999999997 A 50 50 0 0 1 0 49.99999999999998 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  flowChartDecision: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 50 L 50 0 L 100 50 L 50 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  flowChartDelay: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 0 L 50 0 A 50 50 0 0 1 50.00000000000002 100 L 0 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  flowChartDisplay: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 L 16.666666666666668 0 L 83.33333333333334 0 A 16.666666666666668 50 0 0 1 83.33333333333334 100 L 16.666666666666668 100 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  flowChartDocument: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 L 100 0 L 100 80.19444444444444 C 50 80.19444444444444 50 110.75 0 93.38888888888889 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  flowChartExtract: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 100 L 50 0 L 100 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  flowChartInputOutput: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 100 L 20 0 L 100 0 L 80 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  flowChartInternalStorage: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "#000000", stroke: "none" },
      { d: "M 12.5 0 L 12.5 100 M 0 12.5 L 100 12.5", fill: "none", stroke: "#000000" },
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "none", stroke: "#000000" }
    ]
  },
  flowChartMagneticDisk: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 16.666666666666668 A 50 16.666666666666668 0 0 1 100 16.66666666666666 L 100 83.33333333333334 A 50 16.666666666666668 0 0 1 0 83.33333333333334 Z",
        fill: "#000000",
        stroke: "none"
      },
      {
        d: "M 100 16.666666666666668 A 50 16.666666666666668 0 0 1 0 16.66666666666667",
        fill: "none",
        stroke: "#000000"
      },
      {
        d: "M 0 16.666666666666668 A 50 16.666666666666668 0 0 1 100 16.66666666666666 L 100 83.33333333333334 A 50 16.666666666666668 0 0 1 0 83.33333333333334 Z",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  flowChartMagneticDrum: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 16.666666666666668 0 L 83.33333333333334 0 A 16.666666666666668 50 0 0 1 83.33333333333334 100 L 16.666666666666668 100 A 16.666666666666668 50 0 0 1 16.666666666666664 0 Z",
        fill: "#000000",
        stroke: "none"
      },
      {
        d: "M 83.33333333333334 100 A 16.666666666666668 50 0 0 1 83.33333333333334 0",
        fill: "none",
        stroke: "#000000"
      },
      {
        d: "M 16.666666666666668 0 L 83.33333333333334 0 A 16.666666666666668 50 0 0 1 83.33333333333334 100 L 16.666666666666668 100 A 16.666666666666668 50 0 0 1 16.666666666666664 0 Z",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  flowChartMagneticTape: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 50 100 A 50 50 0 0 1 0 50.00000000000001 A 50 50 0 0 1 49.99999999999999 0 A 50 50 0 0 1 100 49.999999999999986 A 50 50 0 0 1 85.35533905932738 85.35533905932735 L 100 85.35533905932738 L 100 100 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  flowChartManualInput: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 20 L 100 0 L 100 100 L 0 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  flowChartManualOperation: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 0 L 100 0 L 80 100 L 20 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  flowChartMerge: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 0 L 100 0 L 50 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  flowChartMultidocument: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 96.21296296296296 C 43.04629629629629 108.99074074074073 43.04629629629629 83.43518518518518 86.08796296296296 83.43518518518518 L 86.08796296296296 17.01388888888889 L 0 17.01388888888889 Z M 7.092592592592593 17.01388888888889 L 7.092592592592593 8.402777777777777 L 92.59259259259258 8.402777777777777 L 92.59259259259258 75.24074074074073 C 89.34259259259258 75.24074074074073 86.08796296296296 75.7037037037037 86.08796296296296 75.7037037037037 L 86.08796296296296 17.01388888888889 Z M 13.759259259259258 8.402777777777777 L 13.759259259259258 0 L 100 0 L 100 66.62962962962962 C 96.29629629629629 66.62962962962962 92.59259259259258 66.97685185185185 92.59259259259258 66.97685185185185 L 92.59259259259258 8.402777777777777 Z",
        fill: "#000000",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 0 17.01388888888889 L 86.08796296296296 17.01388888888889 L 86.08796296296296 83.43518518518518 C 43.04629629629629 83.43518518518518 43.04629629629629 108.99074074074073 0 96.21296296296296 Z M 7.092592592592593 17.01388888888889 L 7.092592592592593 8.402777777777777 L 92.59259259259258 8.402777777777777 L 92.59259259259258 75.24074074074073 C 89.34259259259258 75.24074074074073 86.08796296296296 75.7037037037037 86.08796296296296 75.7037037037037 M 13.759259259259258 8.402777777777777 L 13.759259259259258 0 L 100 0 L 100 66.62962962962962 C 96.29629629629629 66.62962962962962 92.59259259259258 66.97685185185185 92.59259259259258 66.97685185185185",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  flowChartOfflineStorage: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 0 0 L 100 0 L 50 100 Z", fill: "#000000", stroke: "none" },
      { d: "M 40 80 L 60 80", fill: "none", stroke: "#000000" },
      { d: "M 0 0 L 100 0 L 50 100 Z", fill: "none", stroke: "#000000" }
    ]
  },
  flowChartOffpageConnector: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 0 L 100 0 L 100 80 L 50 100 L 0 80 Z", fill: "#000000", stroke: "#000000" }]
  },
  flowChartOnlineStorage: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 16.666666666666668 0 L 100 0 A 16.666666666666668 50 0 0 0 100 100 L 16.666666666666668 100 A 16.666666666666668 50 0 0 1 16.666666666666664 0 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  flowChartOr: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 A 50 50 0 0 1 49.99999999999999 -7.105427357601002e-15 A 50 50 0 0 1 100 49.99999999999998 A 50 50 0 0 1 50 99.99999999999997 A 50 50 0 0 1 0 49.99999999999998 Z",
        fill: "#000000",
        stroke: "none"
      },
      { d: "M 50 0 L 50 100 M 0 50 L 100 50", fill: "none", stroke: "#000000" },
      {
        d: "M 0 50 A 50 50 0 0 1 49.99999999999999 -7.105427357601002e-15 A 50 50 0 0 1 100 49.99999999999998 A 50 50 0 0 1 50 99.99999999999997 A 50 50 0 0 1 0 49.99999999999998 Z",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  flowChartPredefinedProcess: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "#000000", stroke: "none" },
      { d: "M 12.5 0 L 12.5 100 M 87.5 0 L 87.5 100", fill: "none", stroke: "#000000" },
      { d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "none", stroke: "#000000" }
    ]
  },
  flowChartPreparation: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 50 L 20 0 L 80 0 L 100 50 L 80 100 L 20 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  flowChartProcess: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  flowChartPunchedCard: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 20 L 20 0 L 100 0 L 100 100 L 0 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  flowChartPunchedTape: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 10 A 25 10 0 0 0 50 9.999999999999998 A 25 10 0 0 1 100 9.999999999999995 L 100 90 A 25 10 0 0 0 50 90 A 25 10 0 0 1 0 90 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  flowChartSort: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 0 50 L 50 0 L 100 50 L 50 100 Z", fill: "#000000", stroke: "none" },
      { d: "M 0 50 L 100 50", fill: "none", stroke: "#000000" },
      { d: "M 0 50 L 50 0 L 100 50 L 50 100 Z", fill: "none", stroke: "#000000" }
    ]
  },
  flowChartSummingJunction: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 A 50 50 0 0 1 49.99999999999999 -7.105427357601002e-15 A 50 50 0 0 1 100 49.99999999999998 A 50 50 0 0 1 50 99.99999999999997 A 50 50 0 0 1 0 49.99999999999998 Z",
        fill: "#000000",
        stroke: "none"
      },
      {
        d: "M 14.644660940672622 14.64466094067263 L 85.35533905932738 85.35533905932738 M 85.35533905932738 14.64466094067263 L 14.644660940672622 85.35533905932738",
        fill: "none",
        stroke: "#000000"
      },
      {
        d: "M 0 50 A 50 50 0 0 1 49.99999999999999 -7.105427357601002e-15 A 50 50 0 0 1 100 49.99999999999998 A 50 50 0 0 1 50 99.99999999999997 A 50 50 0 0 1 0 49.99999999999998 Z",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  flowChartTerminator: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 16.087962962962962 0 L 83.91203703703704 0 A 16.087962962962962 50 0 0 1 83.91203703703704 100 L 16.087962962962962 100 A 16.087962962962962 50 0 0 1 16.08796296296296 0 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  foldedCorner: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 0 0 L 100 0 L 100 83.333 L 83.333 100 L 0 100 Z", fill: "#000000", stroke: "none" },
      {
        d: "M 83.333 100 L 86.6664 86.6664 L 100 83.333 Z",
        fill: "color-mix(in srgb, currentColor 80%, black)",
        stroke: "none"
      },
      {
        d: "M 83.333 100 L 86.6664 86.6664 L 100 83.333 L 83.333 100 L 0 100 L 0 0 L 100 0 L 100 83.333",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  frame: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 L 100 0 L 100 100 L 0 100 Z M 12.5 12.5 L 12.5 87.5 L 87.5 87.5 L 87.5 12.5 Z",
        fill: "#000000",
        stroke: "#000000",
        fillRule: "evenodd",
        clipRule: "evenodd"
      }
    ]
  },
  funnel: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0.4865947579902823 28.47932110261916 A 50 25 0 0 1 50.363602241574895 1.7268853347203788 A 50 25 0 0 1 100.24060972515952 28.47932110261915 L 62.37835131050243 94.61983027565479 A 12.5 6.25 0 0 1 37.43984756871012 94.61983027565479 Z M 5 25 A 45 20 0 0 0 95 24.999999999999996 A 45 20 0 0 0 5 24.999999999999993 Z",
        fill: "#000000",
        stroke: "#000000",
        fillRule: "evenodd",
        clipRule: "evenodd"
      }
    ]
  },
  gear6: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 74.82470053891974 25.327459734495154 L 89.57808159568633 20.881065308239084 L 95.0067779720481 30.283843250962747 L 83.77939691528152 40.83744882470668 A 35 35 0 0 1 83.77939691528152 59.16255117529331 L 95.0067779720481 69.71615674903725 L 89.57808159568633 79.11893469176091 L 74.82470053891974 74.67254026550485 A 35 35 0 0 1 58.954696376361774 83.83509144079817 L 55.42869637636177 98.83509144079817 L 44.57130362363823 98.83509144079817 L 41.045303623638226 83.83509144079817 A 35 35 0 0 1 25.175299461080265 74.67254026550485 L 10.421918404313672 79.11893469176091 L 4.9932220279519015 69.71615674903725 L 16.220603084718476 59.16255117529332 A 35 35 0 0 1 16.22060308471847 40.837448824706684 L 4.9932220279519015 30.283843250962747 L 10.421918404313672 20.881065308239084 L 25.175299461080257 25.327459734495154 A 35 35 0 0 1 41.04530362363821 16.16490855920184 L 44.57130362363823 1.1649085592018338 L 55.42869637636177 1.1649085592018338 L 58.954696376361774 16.164908559201834 A 35 35 0 0 1 74.82470053891973 25.327459734495143 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  gear9: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 70.98043216644243 15.943848336764354 L 78.75884461652657 9.416638461451942 L 84.97288812699333 14.630840079204173 L 79.89554838334669 23.424519066271323 A 40 40 0 0 1 87.96281579807138 37.3974361068193 L 98.11703506542025 37.397170398710514 L 99.52564437161423 45.38579074787268 L 89.98370857871895 48.85848859310251 A 40 40 0 0 1 87.18197600808145 64.74790358438975 L 94.96073004592583 71.27470637126171 L 90.90480119853021 78.2997812068352 L 81.36304716068582 74.82658399370717 A 40 40 0 0 1 69.00327641227653 85.19766307013315 L 70.76679975508767 95.19757079067537 L 63.14414693842693 97.97198952208531 L 58.06726741472468 89.17804482690939 A 40 40 0 0 1 41.93273258527532 89.17804482690939 L 36.85585306157307 97.97198952208531 L 29.233200244912325 95.19757079067537 L 30.996723587723466 85.19766307013313 A 40 40 0 0 1 18.636952839314183 74.82658399370717 L 9.095198801469792 78.2997812068352 L 5.039269954074172 71.27470637126171 L 12.818023991918551 64.74790358438975 A 40 40 0 0 1 10.016291421281053 48.85848859310253 L 0.4743556283857657 45.38579074787268 L 1.8829649345797463 37.397170398710514 L 12.037184201928625 37.39743610681929 A 40 40 0 0 1 20.104451616653293 23.42451906627133 L 15.027111873006675 14.630840079204173 L 21.241155383473426 9.416638461451942 L 29.019567833557574 15.943848336764354 A 40 40 0 0 1 44.18107115260436 10.425512421903086 L 45.944071152604366 0.42551242190308614 L 54.055928847395634 0.42551242190308614 L 55.81892884739563 10.425512421903086 A 40 40 0 0 1 70.98043216644243 15.943848336764354 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  halfFrame: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 L 100 0 L 66.667 33.333 L 33.333 33.333 L 33.333 66.667 L 0 100 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  heart: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 50 25 C 70.83333333333333 -33.333333333333336 152.08333333333331 25 50 100 C -52.08333333333333 25 29.166666666666668 -33.333333333333336 50 25 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  heptagon: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M -0.0002599799999956076 64.3106646 L 9.903066619999997 19.806308549999997 L 50 0 L 90.09693338 19.806308549999997 L 100.00025998 64.3106646 L 72.25196968 100.00052685 L 27.74803032 100.00052685 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  hexagon: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 L 25 0.00002331250544074237 L 75 0.00002331250544074237 L 100 50 L 75 99.99997668749455 L 25 99.99997668749455 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  homePlate: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 0 L 50 0 L 100 50 L 50 100 L 0 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  horizontalScroll: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 100 6.25 A 6.25 6.25 0 0 1 93.75 12.5 L 93.75 6.25 A 3.125 3.125 0 0 1 87.5 6.25 L 87.5 12.5 L 6.25 12.5 A 6.25 6.25 0 0 0 8.881784197001252e-16 18.75 L 0 93.75 A 6.25 6.25 0 0 0 12.5 93.75 L 12.5 87.5 L 93.75 87.5 A 6.25 6.25 0 0 0 100 81.25 Z M 6.25 25 A 6.25 6.25 0 0 0 12.5 18.75 A 3.125 3.125 0 0 0 6.25 18.75 Z",
        fill: "#000000",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 6.25 25 A 6.25 6.25 0 0 0 12.5 18.75 A 3.125 3.125 0 0 0 6.25 18.75 Z M 93.75 12.5 A 6.25 6.25 0 0 0 98.16941738241593 1.8305826175840787 A 6.25 6.25 0 0 0 87.5 6.249999999999999 A 3.125 3.125 0 0 0 93.75 6.249999999999999 Z",
        fill: "color-mix(in srgb, currentColor 80%, black)",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 0 18.75 A 6.25 6.25 0 0 1 6.249999999999999 12.5 L 87.5 12.5 L 87.5 6.25 A 6.25 6.25 0 0 1 100 6.249999999999997 L 100 81.25 A 6.25 6.25 0 0 1 93.75 87.5 L 12.5 87.5 L 12.5 93.75 A 6.25 6.25 0 0 1 0 93.75 Z M 87.5 12.5 L 93.75 12.5 A 6.25 6.25 0 0 0 100 6.25 M 93.75 12.5 L 93.75 6.25 A 3.125 3.125 0 0 1 87.5 6.25 M 6.25 25 L 6.25 18.75 A 3.125 3.125 0 0 1 12.5 18.75 A 6.25 6.25 0 0 1 0 18.75 M 12.5 18.75 L 12.5 87.5",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  irregularSeal1: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 50 26.85185185185185 L 67.23148148148148 0 L 65.5324074074074 24.652777777777775 L 85.09259259259258 20.63425925925926 L 77.32407407407408 33.86574074074074 L 97.67129629629629 37.6712962962963 L 81.51388888888889 48.49537037037037 L 100 61.52777777777777 L 77.94907407407408 59.916666666666664 L 84.00462962962962 83.77314814814814 L 64.9074074074074 66.93055555555556 L 61.3287037037037 91.375 L 48.75925925925926 69.14351851851852 L 39.282407407407405 100 L 35.71759259259259 72.34722222222221 L 22.046296296296294 81.56018518518518 L 26.23611111111111 64.52314814814814 L 0.625 67.5324074074074 L 17.23148148148148 54.513888888888886 L 0 39.88425925925926 L 21.421296296296294 35.263888888888886 L 1.7129629629629628 10.625 L 33.85185185185185 29.259259259259256 L 38.666666666666664 10.625 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  irregularSeal2: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 53.06481481481481 20.10185185185185 L 68.47222222222221 0 L 67.24537037037037 26.74537037037037 L 83.36574074074073 14.685185185185185 L 75.83333333333333 30.24074074074074 L 100 30.763888888888886 L 78.63425925925925 43.52777777777778 L 84.58333333333333 52.26851851851852 L 75.83333333333333 56.99074074074074 L 87.39351851851852 72.37037037037037 L 67.77777777777777 66.43518518518518 L 69.17592592592592 80.41666666666666 L 56.388888888888886 73.77314814814814 L 53.75925925925926 87.23148148148148 L 45.7037037037037 80.41666666666666 L 40.27777777777778 91.25925925925925 L 34.84722222222222 83.91203703703704 L 22.76388888888889 100 L 22.24537037037037 84.44444444444444 L 5.9490740740740735 82.52314814814814 L 15.416666666666666 71.1574074074074 L 0 59.61574074074074 L 18.21759259259259 53.666666666666664 L 5.425925925925926 38.28703703703704 L 24.87037037037037 36.18981481481481 L 20.84259259259259 16.782407407407405 L 39.58333333333333 29.546296296296294 L 45.00925925925926 8.73611111111111 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  leftArrow: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 50 L 50 0 L 50 25 L 100 25 L 100 75 L 50 75 L 50 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  leftArrowCallout: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 L 25 25 L 25 37.5 L 35.022999999999996 37.5 L 35.022999999999996 0 L 100 0 L 100 100 L 35.022999999999996 100 L 35.022999999999996 62.5 L 25 62.5 L 25 75 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  leftBrace: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 100 100 A 50 8.333 0 0 1 50 91.667 L 50 58.333 A 50 8.333 0 0 0 3.061616997868383e-15 50 A 50 8.333 0 0 0 50 41.667 L 50 8.333 A 50 8.333 0 0 1 99.99999999999999 -1.7763568394002505e-15 Z",
        fill: "#000000",
        stroke: "none"
      },
      {
        d: "M 100 100 A 50 8.333 0 0 1 50 91.667 L 50 58.333 A 50 8.333 0 0 0 3.061616997868383e-15 50 A 50 8.333 0 0 0 50 41.667 L 50 8.333 A 50 8.333 0 0 1 99.99999999999999 -1.7763568394002505e-15",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  leftBracket: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 100 100 A 100 8.333 0 0 1 0 91.667 L 0 8.333 A 100 8.333 0 0 1 99.99999999999999 -1.7763568394002505e-15 Z",
        fill: "#000000",
        stroke: "none"
      },
      {
        d: "M 100 100 A 100 8.333 0 0 1 0 91.667 L 0 8.333 A 100 8.333 0 0 1 99.99999999999999 -1.7763568394002505e-15",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  leftCircularArrow: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 6.25 50.00000000000001 L 18.75 50.00000000000001 A 31.25 31.25 0 0 0 78.75627033259704 62.2327190991455 L 72.94870282721459 62.232721196358064 L 87.5 50 L 97.94870282721459 62.232721196358064 L 92.00503579491598 62.232721196358064 A 43.75 43.75 0 0 1 6.249999722517629 50.00000095282626 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  leftRightArrow: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 L 50 0 L 50 25 L 50 25 L 50 0 L 100 50 L 50 100 L 50 75 L 50 75 L 50 100 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  leftRightArrowCallout: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 L 25 25 L 25 37.5 L 25.9385 37.5 L 25.9385 0 L 74.0615 0 L 74.0615 37.5 L 75 37.5 L 75 25 L 100 50 L 75 75 L 75 62.5 L 74.0615 62.5 L 74.0615 100 L 25.9385 100 L 25.9385 62.5 L 25 62.5 L 25 75 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  leftRightCircularArrow: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 12.5 50.00000000000001 L 2.0512971727853966 37.76727880364194 L 7.9949639276016455 37.767279756468184 A 43.75 43.75 0 0 1 92.00503607239835 37.76727975646819 L 97.94870282721459 37.767278803641936 L 87.5 49.99999999999999 L 72.94870282721459 37.767278803641936 L 78.75626944045719 37.767278803641936 A 31.25 31.25 0 0 0 21.243728775263097 37.76727880364193 L 27.051297172785397 37.76727880364194 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  leftRightRibbon: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 41.6665 L 46.875 0 L 46.875 16.6665 L 50 16.6665 A 3.125 4.16675 0 0 1 50 25 A 3.125 4.16675 0 0 0 50 33.3335 L 53.125 33.3335 L 53.125 16.667 L 100 58.3335 L 53.125 100 L 53.125 83.3335 L 50 83.3335 A 3.125 4.16675 0 0 1 46.875 79.16675000000001 L 46.875 66.6665 L 46.875 66.6665 L 46.875 83.333 Z",
        fill: "#000000",
        stroke: "none"
      },
      {
        d: "M 53.125 20.83325 A 3.125 4.16675 0 0 1 50 25 A 3.125 4.16675 0 0 0 50 33.3335 L 53.125 33.3335 Z",
        fill: "color-mix(in srgb, currentColor 80%, black)",
        stroke: "none"
      },
      {
        d: "M 0 41.6665 L 46.875 0 L 46.875 16.6665 L 50 16.6665 A 3.125 4.16675 0 0 1 50 25 A 3.125 4.16675 0 0 0 50 33.3335 L 53.125 33.3335 L 53.125 16.667 L 100 58.3335 L 53.125 100 L 53.125 83.3335 L 50 83.3335 A 3.125 4.16675 0 0 1 46.875 79.16675000000001 L 46.875 66.6665 L 46.875 66.6665 L 46.875 83.333 Z M 53.125 20.83325 L 53.125 33.3335 M 46.875 29.16675 L 46.875 66.6665",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  leftRightUpArrow: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 75 L 25 50 L 25 62.5 L 37.5 62.5 L 37.5 25 L 25 25 L 50 0 L 75 25 L 62.5 25 L 62.5 62.5 L 75 62.5 L 75 50 L 100 75 L 75 100 L 75 87.5 L 25 87.5 L 25 100 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  leftUpArrow: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 75 L 25 50 L 25 62.5 L 62.5 62.5 L 62.5 25 L 50 25 L 75 0 L 100 25 L 87.5 25 L 87.5 87.5 L 25 87.5 L 25 100 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  lightningBolt: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 39.22222222222222 0 L 59.53703703703703 28.148148148148145 L 51.157407407407405 31.46759259259259 L 76.74537037037037 55.58796296296296 L 68.36574074074073 59.61574074074074 L 100 100 L 46.35185185185185 69.05092592592592 L 56.58333333333333 64.75462962962962 L 23.25 44.93055555555555 L 35.19444444444444 38.80555555555555 L 0 18.00925925925926 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  line: { viewBox: "0 0 100 100", paths: [{ d: "M 0 0 L 100 100", fill: "none", stroke: "#000000" }] },
  lineInv: { viewBox: "0 0 100 100", paths: [{ d: "M 0 100 L 100 0", fill: "none", stroke: "#000000" }] },
  mathDivide: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 50 11.790000000000004 A 11.76 11.76 0 0 1 50.00000000000001 35.31 A 11.76 11.76 0 0 1 49.99999999999999 11.790000000000004 Z M 50 88.21 A 11.76 11.76 0 0 1 50 64.68999999999998 A 11.76 11.76 0 0 1 50.00000000000001 88.21 Z M 13.255000000000003 38.24 L 86.745 38.24 L 86.745 61.76 L 13.255000000000003 61.76 Z",
        fill: "#000000",
        stroke: "#000000",
        fillRule: "evenodd",
        clipRule: "evenodd"
      }
    ]
  },
  mathEqual: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 13.255000000000003 20.599999999999998 L 86.745 20.599999999999998 L 86.745 44.12 L 13.255000000000003 44.12 Z M 13.255000000000003 55.88 L 86.745 55.88 L 86.745 79.4 L 13.255000000000003 79.4 Z",
        fill: "#000000",
        stroke: "#000000",
        fillRule: "evenodd",
        clipRule: "evenodd"
      }
    ]
  },
  mathMinus: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 13.255000000000003 38.24 L 86.745 38.24 L 86.745 61.76 L 13.255000000000003 61.76 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  mathMultiply: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 15.701924253246204 32.3330757467538 L 32.3330757467538 15.7019242532462 L 50 33.3688485064924 L 67.66692425324621 15.7019242532462 L 84.2980757467538 32.3330757467538 L 66.63115149350759 50 L 84.2980757467538 67.66692425324621 L 67.66692425324621 84.2980757467538 L 50 66.6311514935076 L 32.3330757467538 84.2980757467538 L 15.701924253246204 67.66692425324621 L 33.36884850649241 50 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  mathNotEqual: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 13.255000000000003 20.599999999999998 L 48.185994283109636 20.599999999999998 L 55.6837811089934 0 L 77.78535154987797 8.044313771019729 L 73.21545549174309 20.599999999999998 L 86.745 20.599999999999998 L 86.745 44.12 L 64.654875581802 44.12 L 60.37458562683146 55.88 L 86.745 55.88 L 86.745 79.4 L 51.81400571689038 79.4 L 44.3162188910066 100 L 22.214648450122027 91.95568622898027 L 26.78454450825693 79.4 L 13.255000000000003 79.4 L 13.255000000000003 55.88 L 35.34512441819801 55.88 L 39.62541437316855 44.12 L 13.255000000000003 44.12 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  mathPlus: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 13.255000000000003 38.24 L 38.24 38.24 L 38.24 13.255000000000003 L 61.76 13.255000000000003 L 61.76 38.24 L 86.745 38.24 L 86.745 61.76 L 61.76 61.76 L 61.76 86.745 L 38.24 86.745 L 38.24 61.76 L 13.255000000000003 61.76 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  moon: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 100 100 A 100 50 0 0 1 99.99999999999999 0 A 125 62.5 0 0 0 100 69.33752296828366 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  nonIsoscelesTrapezoid: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 100 L 25 0 L 75 0 L 100 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  noSmoking: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 A 50 50 0 0 1 49.99999999999999 -7.105427357601002e-15 A 50 50 0 0 1 100 49.99999999999998 A 50 50 0 0 1 50 99.99999999999997 A 50 50 0 0 1 0 49.99999999999998 Z M 77.5147233635495 64.81561670087828 A 31.25 31.25 0 0 0 35.18438329912174 22.4852766364505 Z M 22.4852766364505 35.18438329912172 A 31.25 31.25 0 0 0 64.81561670087828 77.51472336354949 Z",
        fill: "#000000",
        stroke: "#000000",
        fillRule: "evenodd",
        clipRule: "evenodd"
      }
    ]
  },
  notchedRightArrow: {
    viewBox: "0 0 100 100",
    paths: [
      { d: "M 0 25 L 50 25 L 50 0 L 100 50 L 50 100 L 50 75 L 0 75 L 25 50 Z", fill: "#000000", stroke: "#000000" }
    ]
  },
  octagon: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 29.289 L 29.289 0 L 70.711 0 L 100 29.289 L 100 70.711 L 70.711 100 L 29.289 100 L 0 70.711 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  parallelogram: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 100 L 25 0 L 100 0 L 75 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  pentagon: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0.00010576881489043899 38.19650407644447 L 50 0 L 99.99989423118511 38.19650407644447 L 80.90163406877218 99.99974592355554 L 19.09836593122782 99.99974592355554 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  pie: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 100 50 A 50 50 0 0 1 14.64466094067263 85.35533905932738 A 50 50 0 0 1 49.99999999999999 0 L 50 50 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  pieWedge: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 100 A 100 100 0 0 1 99.99999999999999 -1.4210854715202004e-14 L 100 100 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  plaque: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 16.667 A 16.667 16.667 0 0 0 16.667 0 L 83.333 0 A 16.667 16.667 0 0 0 100 16.666999999999998 L 100 83.333 A 16.667 16.667 0 0 0 83.333 100 L 16.667 100 A 16.667 16.667 0 0 0 1.0205594100694468e-15 83.333 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  plaqueTabs: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 L 7.0710678118654755 0 A 7.0710678118654755 7.0710678118654755 0 0 1 4.3297802811774667e-16 7.0710678118654755 Z",
        fill: "#000000",
        stroke: "#000000"
      },
      {
        d: "M 0 92.92893218813452 A 7.0710678118654755 7.0710678118654755 0 0 1 7.071067811865476 100 L 0 100 Z",
        fill: "#000000",
        stroke: "#000000"
      },
      {
        d: "M 100 0 L 100 7.0710678118654755 A 7.0710678118654755 7.0710678118654755 0 0 1 92.92893218813452 8.659560562354933e-16 Z",
        fill: "#000000",
        stroke: "#000000"
      },
      {
        d: "M 92.92893218813452 100 A 7.0710678118654755 7.0710678118654755 0 0 1 100 92.92893218813452 L 100 100 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  plus: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 25 L 25 25 L 25 0 L 75 0 L 75 25 L 100 25 L 100 75 L 75 75 L 75 100 L 25 100 L 25 75 L 0 75 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  quadArrow: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 L 22.5 27.5 L 22.5 38.75 L 38.75 38.75 L 38.75 22.5 L 27.5 22.5 L 50 0 L 72.5 22.5 L 61.25 22.5 L 61.25 38.75 L 77.5 38.75 L 77.5 27.5 L 100 50 L 77.5 72.5 L 77.5 61.25 L 61.25 61.25 L 61.25 77.5 L 72.5 77.5 L 50 100 L 27.5 77.5 L 38.75 77.5 L 38.75 61.25 L 22.5 61.25 L 22.5 72.5 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  quadArrowCallout: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 L 18.515 31.485 L 18.515 40.7425 L 25.9385 40.7425 L 25.9385 25.9385 L 40.7425 25.9385 L 40.7425 18.515 L 31.485 18.515 L 50 0 L 68.515 18.515 L 59.2575 18.515 L 59.2575 25.9385 L 74.0615 25.9385 L 74.0615 40.7425 L 81.485 40.7425 L 81.485 31.485 L 100 50 L 81.485 68.515 L 81.485 59.2575 L 74.0615 59.2575 L 74.0615 74.0615 L 59.2575 74.0615 L 59.2575 81.485 L 68.515 81.485 L 50 100 L 31.485 81.485 L 40.7425 81.485 L 40.7425 74.0615 L 25.9385 74.0615 L 25.9385 59.2575 L 18.515 59.2575 L 18.515 68.515 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  rect: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 0 L 100 0 L 100 100 L 0 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  ribbon: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 L 34.375 0 A 3.125 4.16675 0 0 1 34.375 8.3335 L 28.125 8.3335 A 3.125 4.16675 0 0 0 28.125 16.667 L 71.875 16.667 A 3.125 4.16675 0 0 0 71.875 8.3335 L 65.625 8.3335 A 3.125 4.16675 0 0 1 65.625 0 L 100 0 L 87.5 41.6665 L 100 83.333 L 75 83.333 L 75 95.83324999999999 A 3.125 4.16675 0 0 1 71.875 100 L 28.125 100 A 3.125 4.16675 0 0 1 25 95.83324999999999 L 25 83.333 L 0 83.333 L 12.5 41.6665 Z",
        fill: "#000000",
        stroke: "none"
      },
      {
        d: "M 37.5 4.16675 A 3.125 4.16675 0 0 1 34.375 8.3335 L 28.125 8.3335 A 3.125 4.16675 0 0 0 28.125 16.667 L 37.5 16.667 Z M 62.5 4.16675 A 3.125 4.16675 0 0 0 65.625 8.3335 L 71.875 8.3335 A 3.125 4.16675 0 0 1 71.875 16.667 L 62.5 16.667 Z",
        fill: "color-mix(in srgb, currentColor 80%, black)",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 0 0 L 34.375 0 A 3.125 4.16675 0 0 1 34.375 8.3335 L 28.125 8.3335 A 3.125 4.16675 0 0 0 28.125 16.667 L 71.875 16.667 A 3.125 4.16675 0 0 0 71.875 8.3335 L 65.625 8.3335 A 3.125 4.16675 0 0 1 65.625 0 L 100 0 L 87.5 41.6665 L 100 83.333 L 75 83.333 L 75 95.83324999999999 A 3.125 4.16675 0 0 1 71.875 100 L 28.125 100 A 3.125 4.16675 0 0 1 25 95.83324999999999 L 25 83.333 L 0 83.333 L 12.5 41.6665 Z M 37.5 4.16675 L 37.5 16.667 M 62.5 16.667 L 62.5 4.16675 M 25 83.333 L 25 12.500250000000001 M 75 12.500250000000001 L 75 83.333",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  ribbon2: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 100 L 34.375 100 A 3.125 4.16675 0 0 0 34.375 91.66649999999998 L 28.125 91.6665 A 3.125 4.16675 0 0 1 28.125 83.333 L 71.875 83.333 A 3.125 4.16675 0 0 1 71.875 91.66650000000001 L 65.625 91.6665 A 3.125 4.16675 0 0 0 65.625 100 L 100 100 L 87.5 58.3335 L 100 16.667 L 75 16.667 L 75 4.16675 A 3.125 4.16675 0 0 0 71.875 0 L 28.125 0 A 3.125 4.16675 0 0 0 25 4.166750000000001 L 25 16.667 L 0 16.667 L 12.5 58.3335 Z",
        fill: "#000000",
        stroke: "none"
      },
      {
        d: "M 37.5 95.83324999999999 A 3.125 4.16675 0 0 0 34.375 91.66649999999998 L 28.125 91.6665 A 3.125 4.16675 0 0 1 28.125 83.333 L 37.5 83.333 Z M 62.5 95.83324999999999 A 3.125 4.16675 0 0 1 65.625 91.66649999999998 L 71.875 91.6665 A 3.125 4.16675 0 0 0 71.875 83.333 L 62.5 83.333 Z",
        fill: "color-mix(in srgb, currentColor 80%, black)",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 0 100 L 12.5 58.3335 L 0 16.667 L 25 16.667 L 25 4.16675 A 3.125 4.16675 0 0 1 28.125 -8.881784197001252e-16 L 71.875 0 A 3.125 4.16675 0 0 1 75 4.1667499999999995 L 75 16.667 L 75 16.667 L 100 16.667 L 87.5 58.3335 L 100 100 L 65.625 100 A 3.125 4.16675 0 0 1 65.625 91.66649999999998 L 71.875 91.6665 A 3.125 4.16675 0 0 0 71.875 83.333 L 28.125 83.333 A 3.125 4.16675 0 0 0 28.125 91.66650000000001 L 34.375 91.6665 A 3.125 4.16675 0 0 1 34.375 100 Z M 37.5 83.333 L 37.5 95.83324999999999 M 62.5 95.83324999999999 L 62.5 83.333 M 25 87.49975 L 25 16.667 M 75 16.667 L 75 87.49975",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  rightArrow: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 25 L 50 25 L 50 0 L 100 50 L 50 100 L 50 75 L 0 75 Z", fill: "#000000", stroke: "#000000" }]
  },
  rightArrowCallout: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 L 64.977 0 L 64.977 37.5 L 75 37.5 L 75 25 L 100 50 L 75 75 L 75 62.5 L 64.977 62.5 L 64.977 100 L 0 100 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  rightBrace: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 A 50 8.333 0 0 1 50.00000000000001 8.332999999999998 L 50 41.667 A 50 8.333 0 0 0 100 50 A 50 8.333 0 0 0 50.000000000000014 58.333 L 50 91.667 A 50 8.333 0 0 1 3.061616997868383e-15 100 Z",
        fill: "#000000",
        stroke: "none"
      },
      {
        d: "M 0 0 A 50 8.333 0 0 1 50.00000000000001 8.332999999999998 L 50 41.667 A 50 8.333 0 0 0 100 50 A 50 8.333 0 0 0 50.000000000000014 58.333 L 50 91.667 A 50 8.333 0 0 1 3.061616997868383e-15 100",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  rightBracket: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 A 100 8.333 0 0 1 100.00000000000001 8.332999999999998 L 100 91.667 A 100 8.333 0 0 1 6.123233995736766e-15 100 Z",
        fill: "#000000",
        stroke: "none"
      },
      {
        d: "M 0 0 A 100 8.333 0 0 1 100.00000000000001 8.332999999999998 L 100 91.667 A 100 8.333 0 0 1 6.123233995736766e-15 100",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  round1Rect: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 L 83.333 0 A 16.667 16.667 0 0 1 100 16.666999999999998 L 100 100 L 0 100 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  round2DiagRect: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 16.667 0 L 100 0 A 0 0 0 0 1 100 0 L 100 83.333 A 16.667 16.667 0 0 1 83.333 100 L 0 100 A 0 0 0 0 1 0 100 L 0 16.667 A 16.667 16.667 0 0 1 16.666999999999998 -3.552713678800501e-15 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  round2SameRect: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 16.667 0 L 83.333 0 A 16.667 16.667 0 0 1 100 16.666999999999998 L 100 100 A 0 0 0 0 1 100 100 L 0 100 A 0 0 0 0 1 0 100 L 0 16.667 A 16.667 16.667 0 0 1 16.666999999999998 -3.552713678800501e-15 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  roundRect: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 16.667 A 16.667 16.667 0 0 1 16.666999999999998 -3.552713678800501e-15 L 83.333 0 A 16.667 16.667 0 0 1 100 16.666999999999998 L 100 83.333 A 16.667 16.667 0 0 1 83.333 100 L 16.667 100 A 16.667 16.667 0 0 1 0 83.333 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  rtTriangle: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 100 L 0 0 L 100 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  smileyFace: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 A 50 50 0 0 1 100 49.99999999999998 A 50 50 0 0 1 0 50.000000000000014 Z",
        fill: "#000000",
        stroke: "none"
      },
      {
        d: "M 28.77314814814815 35.0462962962963 A 5.208333333333333 5.208333333333333 0 0 1 39.18981481481482 35.0462962962963 A 5.208333333333333 5.208333333333333 0 0 1 28.77314814814815 35.0462962962963 M 60.81018518518518 35.0462962962963 A 5.208333333333333 5.208333333333333 0 0 1 71.22685185185185 35.0462962962963 A 5.208333333333333 5.208333333333333 0 0 1 60.81018518518518 35.0462962962963",
        fill: "color-mix(in srgb, currentColor 80%, black)",
        stroke: "#000000",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 22.89967279598138 71.80533333333332 Q 50 90.41733333333333 77.03703703703704 71.80533333333332",
        fill: "none",
        stroke: "#000000"
      },
      {
        d: "M 0 50 A 50 50 0 0 1 100 49.99999999999998 A 50 50 0 0 1 0 50.000000000000014 Z",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  snip1Rect: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 0 L 83.333 0 L 100 16.667 L 100 100 L 0 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  snip2DiagRect: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 L 83.333 0 L 100 16.667 L 100 100 L 100 100 L 16.667 100 L 0 83.333 L 0 0 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  snip2SameRect: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 16.667 0 L 83.333 0 L 100 16.667 L 100 100 L 100 100 L 0 100 L 0 100 L 0 16.667 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  snipRoundRect: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 16.667 0 L 83.333 0 L 100 16.667 L 100 100 L 0 100 L 0 16.667 A 16.667 16.667 0 0 1 16.666999999999998 -3.552713678800501e-15 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  squareTabs: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 L 7.0710678118654755 0 L 7.0710678118654755 7.0710678118654755 L 0 7.0710678118654755 Z",
        fill: "#000000",
        stroke: "#000000"
      },
      {
        d: "M 0 92.92893218813452 L 7.0710678118654755 92.92893218813452 L 7.0710678118654755 100 L 0 100 Z",
        fill: "#000000",
        stroke: "#000000"
      },
      {
        d: "M 92.92893218813452 0 L 100 0 L 100 7.0710678118654755 L 92.92893218813452 7.0710678118654755 Z",
        fill: "#000000",
        stroke: "#000000"
      },
      {
        d: "M 92.92893218813452 92.92893218813452 L 100 92.92893218813452 L 100 100 L 92.92893218813452 100 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  star10: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M -0.00007738000000045986 34.549 L 13.819211287416401 24.99952793 L 19.09811633 9.549 L 36.180085377416404 9.548565019999998 L 50 0 L 63.819914622583596 9.548565019999998 L 80.90188367 9.549 L 86.18078871258359 24.99952793 L 100.00007738 34.549 L 94.72174817999999 50 L 100.00007738 65.451 L 86.18078871258359 75.00047207 L 80.90188367 90.451 L 63.819914622583596 90.45143498 L 50 100 L 36.180085377416404 90.45143498 L 19.09811633 90.451 L 13.819211287416401 75.00047207 L -0.00007738000000045986 65.451 L 5.278251820000001 50 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  star12: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 L 13.77778151415994 40.294285808655474 L 6.698729810778062 25 L 23.483495705504467 23.48349570550447 L 25 6.698729810778069 L 40.294285808655474 13.77778151415994 L 50 0 L 59.705714191344526 13.77778151415994 L 75 6.698729810778069 L 76.51650429449553 23.48349570550447 L 93.30127018922194 25 L 86.22221848584006 40.294285808655474 L 100 50 L 86.22221848584006 59.705714191344526 L 93.30127018922194 75 L 76.51650429449553 76.51650429449553 L 75 93.30127018922192 L 59.705714191344526 86.22221848584006 L 50 100 L 40.294285808655474 86.22221848584006 L 25 93.30127018922192 L 23.483495705504467 76.51650429449553 L 6.698729810778062 75 L 13.77778151415994 59.705714191344526 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  star16: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 L 13.220374999999997 42.684125 L 3.8059999999999974 30.866 L 18.819875 29.166125 L 14.6445 14.6445 L 29.166125 18.819875 L 30.866 3.8059999999999974 L 42.684125 13.220374999999997 L 50 0 L 57.315875 13.220374999999997 L 69.134 3.8059999999999974 L 70.833875 18.819875 L 85.3555 14.6445 L 81.180125 29.166125 L 96.194 30.866 L 86.77962500000001 42.684125 L 100 50 L 86.77962500000001 57.315875 L 96.194 69.134 L 81.180125 70.833875 L 85.3555 85.3555 L 70.833875 81.180125 L 69.134 96.194 L 57.315875 86.77962500000001 L 50 100 L 42.684125 86.77962500000001 L 30.866 96.194 L 29.166125 81.180125 L 14.6445 85.3555 L 18.819875 70.833875 L 3.8059999999999974 69.134 L 13.220374999999997 57.315875 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  star24: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 L 12.820999999999998 45.105125 L 1.7037086855465873 37.059047744873965 L 15.354500000000002 35.6495 L 6.698729810778062 25 L 20.249375 27.1715 L 14.644660940672622 14.64466094067263 L 27.1715 20.249375 L 25 6.698729810778069 L 35.6495 15.354500000000002 L 37.059047744873965 1.7037086855465873 L 45.105125 12.820999999999998 L 50 0 L 54.894875 12.820999999999998 L 62.940952255126035 1.7037086855465873 L 64.3505 15.354500000000002 L 75 6.698729810778069 L 72.82849999999999 20.249375 L 85.35533905932738 14.64466094067263 L 79.750625 27.1715 L 93.30127018922194 25 L 84.6455 35.6495 L 98.29629131445341 37.059047744873965 L 87.179 45.105125 L 100 50 L 87.179 54.894875 L 98.29629131445341 62.940952255126035 L 84.6455 64.3505 L 93.30127018922194 75 L 79.750625 72.82849999999999 L 85.35533905932738 85.35533905932738 L 72.82849999999999 79.750625 L 75 93.30127018922192 L 64.3505 84.6455 L 62.940952255126035 98.29629131445341 L 54.894875 87.179 L 50 100 L 45.105125 87.179 L 37.059047744873965 98.29629131445341 L 35.6495 84.6455 L 25 93.30127018922192 L 27.1715 79.750625 L 14.644660940672622 85.35533905932738 L 20.249375 72.82849999999999 L 6.698729810778062 75 L 15.354500000000002 64.3505 L 1.7037086855465873 62.940952255126035 L 12.820999999999998 54.894875 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  star32: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 L 12.680750000000003 46.32425 L 0.9605000000000032 40.2455 L 14.11475 39.1145 L 3.8059999999999974 30.866 L 16.927999999999997 32.322500000000005 L 8.426499999999997 22.2215 L 21.012125 26.210375 L 14.644660940672622 14.64466094067263 L 26.210375 21.012125 L 22.2215 8.426499999999997 L 32.322500000000005 16.927999999999997 L 30.866 3.8059999999999974 L 39.1145 14.11475 L 40.2455 0.9605000000000032 L 46.32425 12.680750000000003 L 50 0 L 53.67575 12.680750000000003 L 59.7545 0.9605000000000032 L 60.8855 14.11475 L 69.134 3.8059999999999974 L 67.6775 16.927999999999997 L 77.77850000000001 8.426499999999997 L 73.789625 21.012125 L 85.35533905932738 14.64466094067263 L 78.987875 26.210375 L 91.5735 22.2215 L 83.072 32.322500000000005 L 96.194 30.866 L 85.88525 39.1145 L 99.0395 40.2455 L 87.31925 46.32425 L 100 50 L 87.31925 53.67575 L 99.0395 59.7545 L 85.88525 60.8855 L 96.194 69.134 L 83.072 67.6775 L 91.5735 77.77850000000001 L 78.987875 73.789625 L 85.35533905932738 85.35533905932738 L 73.789625 78.987875 L 77.77850000000001 91.5735 L 67.6775 83.072 L 69.134 96.194 L 60.8855 85.88525 L 59.7545 99.0395 L 53.67575 87.31925 L 50 100 L 46.32425 87.31925 L 40.2455 99.0395 L 39.1145 85.88525 L 30.866 96.194 L 32.322500000000005 83.072 L 22.2215 91.5735 L 26.210375 78.987875 L 14.644660940672622 85.35533905932738 L 21.012125 73.789625 L 8.426499999999997 77.77850000000001 L 16.927999999999997 67.6775 L 3.8059999999999974 69.134 L 14.11475 60.8855 L 0.9605000000000032 59.7545 L 12.680750000000003 53.67575 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  star4: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 L 41.161165235168156 41.161165235168156 L 50 0 L 58.838834764831844 41.161165235168156 L 100 50 L 58.838834764831844 58.838834764831844 L 50 100 L 41.161165235168156 58.838834764831844 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  star5: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0.00010576881489043899 38.19650407644447 L 38.19681185109177 38.196772907038735 L 50 0 L 61.80318814890823 38.196772907038735 L 99.99989423118511 38.19650407644447 L 69.09795960054346 61.80313916296127 L 80.90163406877218 99.99974592355554 L 50 76.39267586 L 19.09836593122782 99.99974592355554 L 30.90204039945654 61.80313916296127 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  star6: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0.000023312505433636943 25 L 33.3330602 24.999578643550826 L 50 0 L 66.6669398 24.999578643550826 L 99.99997668749457 25 L 83.3338796 50 L 99.99997668749457 75 L 66.6669398 75.00042135644918 L 50 100 L 33.3330602 75.00042135644918 L 0.000023312505433636943 75 L 16.666120399999997 50 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  star7: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M -0.0002599799999956076 64.3106646 L 15.398820088640399 44.504445983508 L 9.903066619999997 19.806308549999997 L 34.6011919420464 19.806347509263 L 50 0 L 65.3988080579536 19.806347509263 L 90.09693338 19.806308549999997 L 84.6011799113596 44.504445983508 L 100.00025998 64.3106646 L 77.7478798376276 75.302350457229 L 72.25196968 100.00052685 L 50 89.0087121 L 27.74803032 100.00052685 L 22.252120162372403 75.302350457229 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  star8: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 L 15.354500000000002 35.6495 L 14.644660940672622 14.64466094067263 L 35.6495 15.354500000000002 L 50 0 L 64.3505 15.354500000000002 L 85.35533905932738 14.64466094067263 L 84.6455 35.6495 L 100 50 L 84.6455 64.3505 L 85.35533905932738 85.35533905932738 L 64.3505 84.6455 L 50 100 L 35.6495 84.6455 L 14.644660940672622 85.35533905932738 L 15.354500000000002 64.3505 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  straightConnector1: { viewBox: "0 0 100 100", paths: [{ d: "M 0 0 L 100 100", fill: "none", stroke: "#000000" }] },
  stripedRightArrow: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 25 L 0 25 L 0 75 L 0 75 Z M 0 25 L 0 25 L 0 75 L 0 75 Z M 15.625 25 L 50 25 L 50 0 L 100 50 L 50 100 L 50 75 L 15.625 75 Z",
        fill: "#000000",
        stroke: "#000000",
        fillRule: "evenodd",
        clipRule: "evenodd"
      }
    ]
  },
  sun: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 100 50 L 79.82292175292969 57.175445556640625 L 79.82292175292969 42.824554443359375 Z M 85.35185185185185 14.643518518518519 L 76.16092175292968 33.986554443359374 L 66.01344555664062 23.83907824707031 Z M 50 0 L 57.175445556640625 20.177078247070312 L 42.824554443359375 20.177078247070312 Z M 14.643518518518519 14.643518518518519 L 33.986554443359374 23.83907824707031 L 23.83907824707031 33.986554443359374 Z M 0 50 L 20.177078247070312 42.824554443359375 L 20.177078247070312 57.175445556640625 Z M 14.643518518518519 85.35185185185185 L 23.83907824707031 66.01344555664062 L 33.986554443359374 76.16092175292968 Z M 50 100 L 42.824554443359375 79.82292175292969 L 57.175445556640625 79.82292175292969 Z M 85.35185185185185 85.35185185185185 L 66.01344555664062 76.16092175292968 L 76.16092175292968 66.01344555664062 Z M 25 50 A 25 25 0 0 1 75 49.99999999999999 A 25 25 0 0 1 25 50.00000000000001 Z",
        fill: "#000000",
        stroke: "#000000",
        fillRule: "evenodd",
        clipRule: "evenodd"
      }
    ]
  },
  swooshArrow: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 100 Q 16.666666666666668 33.333333333333336 83.333 0 L 83.333 0 L 100 7.5 L 86.14982349750278 25 L 86.14982349750278 25 Q 25 33.333333333333336 0 100 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  teardrop: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 A 50 50 0 0 1 49.99999999999999 -7.105427357601002e-15 Q 75 0 100 0 Q 100 25 100 50 A 50 50 0 0 1 50 100 A 50 50 0 0 1 0 50.00000000000001 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  trapezoid: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 100 L 25 0 L 75 0 L 100 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  triangle: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 100 L 50 0 L 100 100 Z", fill: "#000000", stroke: "#000000" }]
  },
  upArrow: {
    viewBox: "0 0 100 100",
    paths: [{ d: "M 0 50 L 50 0 L 100 50 L 75 50 L 75 100 L 25 100 L 25 50 Z", fill: "#000000", stroke: "#000000" }]
  },
  upArrowCallout: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 35.022999999999996 L 37.5 35.022999999999996 L 37.5 25 L 25 25 L 50 0 L 75 25 L 62.5 25 L 62.5 35.022999999999996 L 100 35.022999999999996 L 100 100 L 0 100 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  upDownArrow: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 50 L 50 0 L 100 50 L 75 50 L 75 50 L 100 50 L 50 100 L 0 50 L 25 50 L 25 50 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  upDownArrowCallout: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 25.9385 L 37.5 25.9385 L 37.5 25 L 25 25 L 50 0 L 75 25 L 62.5 25 L 62.5 25.9385 L 100 25.9385 L 100 74.0615 L 62.5 74.0615 L 62.5 75 L 75 75 L 50 100 L 25 75 L 37.5 75 L 37.5 74.0615 L 0 74.0615 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  uturnArrow: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 100 L 0 43.75 A 43.75 43.75 0 0 1 43.74999999999999 -7.105427357601002e-15 L 43.75 0 A 43.75 43.75 0 0 1 87.5 43.749999999999986 L 87.5 50 L 100 50 L 75 75 L 50 50 L 62.5 50 L 62.5 43.75 A 18.75 18.75 0 0 0 43.75 25 L 43.75 25 A 18.75 18.75 0 0 0 25 43.75 L 25 100 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  verticalScroll: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 6.25 100 A 6.25 6.25 0 0 0 12.5 93.75 L 6.25 93.75 A 3.125 3.125 0 0 0 6.25 87.5 L 12.5 87.5 L 12.5 6.25 A 6.25 6.25 0 0 1 18.75 -8.881784197001252e-16 L 93.75 0 A 6.25 6.25 0 0 1 93.75 12.5 L 87.5 12.5 L 87.5 93.75 A 6.25 6.25 0 0 1 81.25 100 Z M 25 6.25 A 6.25 6.25 0 0 1 18.75 12.5 A 3.125 3.125 0 0 1 18.75 6.25 Z",
        fill: "#000000",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 25 6.25 A 6.25 6.25 0 0 1 18.75 12.5 A 3.125 3.125 0 0 1 18.75 6.25 Z M 12.5 93.75 A 6.25 6.25 0 0 1 1.8305826175840787 98.16941738241593 A 6.25 6.25 0 0 1 6.249999999999999 87.5 A 3.125 3.125 0 0 1 6.250000000000001 93.75 Z",
        fill: "color-mix(in srgb, currentColor 80%, black)",
        stroke: "none",
        fillRule: "evenodd",
        clipRule: "evenodd"
      },
      {
        d: "M 12.5 87.5 L 12.5 6.25 A 6.25 6.25 0 0 1 18.75 -8.881784197001252e-16 L 93.75 0 A 6.25 6.25 0 0 1 93.75 12.5 L 87.5 12.5 L 87.5 93.75 A 6.25 6.25 0 0 1 81.25 100 L 6.25 100 A 6.25 6.25 0 0 1 6.249999999999999 87.5 Z M 18.75 0 A 6.25 6.25 0 0 1 18.750000000000004 12.5 A 3.125 3.125 0 0 1 18.750000000000004 6.25 L 25 6.25 M 87.5 12.5 L 18.75 12.5 M 6.25 87.5 A 3.125 3.125 0 0 1 6.250000000000002 93.75 L 12.5 93.75 M 6.25 100 A 6.25 6.25 0 0 0 12.5 93.75 L 12.5 87.5",
        fill: "none",
        stroke: "#000000"
      }
    ]
  },
  wave: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 12.5 C 33.333333333333336 -29.166666666666664 66.66666666666667 54.166666666666664 100 12.5 L 100 87.5 C 66.66666666666667 129.16666666666666 33.333333333333336 45.833333333333336 0 87.5 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  wedgeEllipseCallout: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 29.167 112.5 L 25.428460527844393 93.54583157970805 A 50 50 0 0 1 65.81115470846487 2.5657572339877106 A 50 50 0 0 1 43.53022094510429 99.57965267103867 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  wedgeRectCallout: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 0 L 16.666666666666668 0 L 16.666666666666668 0 L 41.666666666666664 0 L 100 0 L 100 58.333333333333336 L 100 58.333333333333336 L 100 83.33333333333333 L 100 100 L 41.666666666666664 100 L 29.167 112.5 L 16.666666666666668 100 L 0 100 L 0 83.33333333333333 L 0 58.333333333333336 L 0 58.333333333333336 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  },
  wedgeRoundRectCallout: {
    viewBox: "0 0 100 100",
    paths: [
      {
        d: "M 0 16.667 A 16.667 16.667 0 0 1 16.666999999999998 -3.552713678800501e-15 L 16.666666666666668 0 L 16.666666666666668 0 L 41.666666666666664 0 L 83.333 0 A 16.667 16.667 0 0 1 100 16.666999999999998 L 100 58.333333333333336 L 100 58.333333333333336 L 100 83.33333333333333 L 100 83.333 A 16.667 16.667 0 0 1 83.333 100 L 41.666666666666664 100 L 29.167 112.5 L 16.666666666666668 100 L 16.667 100 A 16.667 16.667 0 0 1 0 83.333 L 0 83.33333333333333 L 0 58.333333333333336 L 0 58.333333333333336 Z",
        fill: "#000000",
        stroke: "#000000"
      }
    ]
  }
};
var F = /* @__PURE__ */ new Set(["leftRightArrow", "upDownArrow"]), X = {
  leftRightArrow: `<leftRightArrow>
    <avLst xmlns="http://schemas.openxmlformats.org/drawingml/2006/main">
      <gd name="adj1" fmla="val 50000"/>
      <gd name="adj2" fmla="val 50000"/>
    </avLst>
    <gdLst xmlns="http://schemas.openxmlformats.org/drawingml/2006/main">
      <gd name="maxAdj2" fmla="*/ 50000 w ss"/>
      <gd name="a1" fmla="pin 0 adj1 100000"/>
      <gd name="a2" fmla="pin 0 adj2 maxAdj2"/>
      <gd name="x2" fmla="*/ ss a2 100000"/>
      <gd name="x3" fmla="+- r 0 x2"/>
      <gd name="dy" fmla="*/ h a1 200000"/>
      <gd name="y1" fmla="+- vc 0 dy"/>
      <gd name="y2" fmla="+- vc dy 0"/>
      <gd name="dx1" fmla="*/ y1 x2 hd2"/>
      <gd name="x1" fmla="+- x2 0 dx1"/>
      <gd name="x4" fmla="+- x3 dx1 0"/>
    </gdLst>
    <ahLst xmlns="http://schemas.openxmlformats.org/drawingml/2006/main">
      <ahXY gdRefY="adj1" minY="0" maxY="100000">
        <pos x="x3" y="y1"/>
      </ahXY>
      <ahXY gdRefX="adj2" minX="0" maxX="maxAdj2">
        <pos x="x2" y="t"/>
      </ahXY>
    </ahLst>
    <cxnLst xmlns="http://schemas.openxmlformats.org/drawingml/2006/main">
      <cxn ang="0">
        <pos x="r" y="vc"/>
      </cxn>
      <cxn ang="cd4">
        <pos x="x3" y="b"/>
      </cxn>
      <cxn ang="cd4">
        <pos x="x2" y="b"/>
      </cxn>
      <cxn ang="cd2">
        <pos x="l" y="vc"/>
      </cxn>
      <cxn ang="3cd4">
        <pos x="x2" y="t"/>
      </cxn>
      <cxn ang="3cd4">
        <pos x="x3" y="t"/>
      </cxn>
    </cxnLst>
    <rect l="x1" t="y1" r="x4" b="y2" xmlns="http://schemas.openxmlformats.org/drawingml/2006/main"/>
    <pathLst xmlns="http://schemas.openxmlformats.org/drawingml/2006/main">
      <path>
        <moveTo>
          <pt x="l" y="vc"/>
        </moveTo>
        <lnTo>
          <pt x="x2" y="t"/>
        </lnTo>
        <lnTo>
          <pt x="x2" y="y1"/>
        </lnTo>
        <lnTo>
          <pt x="x3" y="y1"/>
        </lnTo>
        <lnTo>
          <pt x="x3" y="t"/>
        </lnTo>
        <lnTo>
          <pt x="r" y="vc"/>
        </lnTo>
        <lnTo>
          <pt x="x3" y="b"/>
        </lnTo>
        <lnTo>
          <pt x="x3" y="y2"/>
        </lnTo>
        <lnTo>
          <pt x="x2" y="y2"/>
        </lnTo>
        <lnTo>
          <pt x="x2" y="b"/>
        </lnTo>
        <close/>
      </path>
    </pathLst>
  </leftRightArrow>`,
  upDownArrow: `<upDownArrow>
    <avLst xmlns="http://schemas.openxmlformats.org/drawingml/2006/main">
      <gd name="adj1" fmla="val 50000"/>
      <gd name="adj2" fmla="val 50000"/>
    </avLst>
    <gdLst xmlns="http://schemas.openxmlformats.org/drawingml/2006/main">
      <gd name="maxAdj2" fmla="*/ 50000 h ss"/>
      <gd name="a1" fmla="pin 0 adj1 100000"/>
      <gd name="a2" fmla="pin 0 adj2 maxAdj2"/>
      <gd name="y2" fmla="*/ ss a2 100000"/>
      <gd name="y3" fmla="+- b 0 y2"/>
      <gd name="dx1" fmla="*/ w a1 200000"/>
      <gd name="x1" fmla="+- hc 0 dx1"/>
      <gd name="x2" fmla="+- hc dx1 0"/>
      <gd name="dy1" fmla="*/ x1 y2 wd2"/>
      <gd name="y1" fmla="+- y2 0 dy1"/>
      <gd name="y4" fmla="+- y3 dy1 0"/>
    </gdLst>
    <ahLst xmlns="http://schemas.openxmlformats.org/drawingml/2006/main">
      <ahXY gdRefX="adj1" minX="0" maxX="100000">
        <pos x="x1" y="y3"/>
      </ahXY>
      <ahXY gdRefY="adj2" minY="0" maxY="maxAdj2">
        <pos x="l" y="y2"/>
      </ahXY>
    </ahLst>
    <cxnLst xmlns="http://schemas.openxmlformats.org/drawingml/2006/main">
      <cxn ang="3cd4">
        <pos x="hc" y="t"/>
      </cxn>
      <cxn ang="cd2">
        <pos x="l" y="y2"/>
      </cxn>
      <cxn ang="cd2">
        <pos x="x1" y="vc"/>
      </cxn>
      <cxn ang="cd2">
        <pos x="l" y="y3"/>
      </cxn>
      <cxn ang="cd4">
        <pos x="hc" y="b"/>
      </cxn>
      <cxn ang="0">
        <pos x="r" y="y3"/>
      </cxn>
      <cxn ang="0">
        <pos x="x2" y="vc"/>
      </cxn>
      <cxn ang="0">
        <pos x="r" y="y2"/>
      </cxn>
    </cxnLst>
    <rect l="x1" t="y1" r="x2" b="y4" xmlns="http://schemas.openxmlformats.org/drawingml/2006/main"/>
    <pathLst xmlns="http://schemas.openxmlformats.org/drawingml/2006/main">
      <path>
        <moveTo>
          <pt x="l" y="y2"/>
        </moveTo>
        <lnTo>
          <pt x="hc" y="t"/>
        </lnTo>
        <lnTo>
          <pt x="r" y="y2"/>
        </lnTo>
        <lnTo>
          <pt x="x2" y="y2"/>
        </lnTo>
        <lnTo>
          <pt x="x2" y="y3"/>
        </lnTo>
        <lnTo>
          <pt x="r" y="y3"/>
        </lnTo>
        <lnTo>
          <pt x="hc" y="b"/>
        </lnTo>
        <lnTo>
          <pt x="l" y="y3"/>
        </lnTo>
        <lnTo>
          <pt x="x1" y="y3"/>
        </lnTo>
        <lnTo>
          <pt x="x1" y="y2"/>
        </lnTo>
        <close/>
      </path>
    </pathLst>
  </upDownArrow>`
};
function U() {
  if (typeof DOMParser < "u") return new DOMParser();
  throw new Error("DOMParser is not available. In Node.js install @xmldom/xmldom and assign global.DOMParser.");
}
function Y(t) {
  return t ? t.charCodeAt(0) === 65279 ? t.slice(1) : t : "";
}
var p = "http://schemas.openxmlformats.org/drawingml/2006/main";
function m(t) {
  return Number.isNaN(t) || !Number.isFinite(t) ? 0 : t;
}
function B(t) {
  return typeof t == "string" && /^-?\d+(?:\.\d+)?$/.test(t.trim());
}
function g(t) {
  return t / 6e4 * (Math.PI / 180);
}
function W(t) {
  return Math.round(t * 180 * 6e4 / Math.PI);
}
function y(t, n) {
  return Math.sqrt(t * t + n * n);
}
function q(t) {
  let n = [];
  if (!t || typeof t.length != "number") return n;
  for (let o = 0; o < t.length; o += 1) {
    let L = typeof t.item == "function" ? t.item(o) : t[o];
    L && n.push(L);
  }
  return n;
}
function h(t, n, o) {
  if (!t) return [];
  if (typeof t.getElementsByTagNameNS == "function") return q(t.getElementsByTagNameNS(n, o));
  if (typeof t.getElementsByTagName == "function") {
    let l = q(t.getElementsByTagName(o));
    if (l.length) return l;
  }
  let L = [], e = [t];
  for (; e.length; ) {
    let l = e.pop();
    if (!l) continue;
    let r2 = l.childNodes;
    if (!(!r2 || typeof r2.length != "number"))
      for (let i = r2.length - 1; i >= 0; i -= 1) {
        let s = typeof r2.item == "function" ? r2.item(i) : r2[i];
        if (!s || s.nodeType !== 1) continue;
        let a = s, f = a.localName || a.nodeName || a.tagName || "", c2 = f.includes(":") ? f.split(":").pop() : f, A = !a.namespaceURI || a.namespaceURI === n;
        c2 === o && A && L.push(a), e.push(a);
      }
  }
  return L;
}
function b(t) {
  let n = [], o = t?.childNodes;
  if (!o || typeof o.length != "number") return n;
  for (let L = 0; L < o.length; L += 1) {
    let e = typeof o.item == "function" ? o.item(L) : o[L];
    e && e.nodeType === 1 && n.push(e);
  }
  return n;
}
function H(t, n) {
  let o = /* @__PURE__ */ Object.create(null), L = t, e = n;
  return o.w = L, o.h = e, o.l = 0, o.t = 0, o.r = L, o.b = e, o.hc = L / 2, o.vc = e / 2, o.ss = Math.min(L, e), [2, 3, 4, 5, 6, 8, 10, 12, 16, 20, 24, 32, 36, 40, 48, 64, 72, 96].forEach((r2) => {
    o[`wd${r2}`] = L / r2, o[`hd${r2}`] = e / r2;
  }), o;
}
function k(t, n) {
  if (t == null || t === "") return 0;
  if (typeof t == "number") return t;
  if (/^-?\d+(\.\d+)?$/.test(t)) return Number(t);
  if (/^-?[0-9]*cd[0-9]+$/.test(t)) {
    let L = t.split("cd"), e = L[0] === "" || L[0] === "-" ? +`${L[0]}1` : Number(L[0]), l = Number(L[1]);
    return l ? 216e5 / l * e : 0;
  }
  let o = n[t];
  return typeof o == "number" ? o : 0;
}
function V(t, n) {
  let o = t.trim().split(/\s+/), L = o[0], e = o.slice(1).map((l) => k(l, n));
  switch (L) {
    case "val":
      return m(e[0]);
    case "+-":
      return m(e[0] + e[1] - e[2]);
    case "*/":
      return e[2] === 0 ? 0 : m(e[0] * e[1] / e[2]);
    case "+/":
      return e[2] === 0 ? 0 : m((e[0] + e[1]) / e[2]);
    case "abs":
      return Math.abs(e[0]);
    case "max":
      return Math.max(e[0], e[1]);
    case "min":
      return Math.min(e[0], e[1]);
    case "pin":
      return Math.min(Math.max(e[0], e[1]), e[2]);
    case "mod":
      return m(Math.hypot(...e));
    case "sin": {
      let l = e[0], r2 = g(e[1]);
      return m(l * Math.sin(r2));
    }
    case "cos": {
      let l = e[0], r2 = g(e[1]);
      return m(l * Math.cos(r2));
    }
    case "atan2":
      return m(Math.atan2(e[1], e[0]));
    case "tan": {
      let l = e[0], r2 = g(e[1]);
      return m(l * Math.tan(r2));
    }
    case "at2": {
      let l = Math.atan2(e[1], e[0]);
      return W(l);
    }
    case "sat2": {
      let l = e[0], r2 = e[1], i = e[2], s = y(r2, i);
      return s === 0 ? 0 : m(l * i / s);
    }
    case "cat2": {
      let l = e[0], r2 = e[1], i = e[2], s = y(r2, i);
      return s === 0 ? m(l) : m(l * r2 / s);
    }
    case "?:":
      return e[0] >= 0 ? e[1] : e[2];
    case "sqrt":
      return e[0] < 0 ? 0 : Math.sqrt(e[0]);
    default:
      return typeof console < "u" && vue.process$1?.env?.NODE_ENV !== "production" && console.warn(`Unsupported formula operator "${L}"`), 0;
  }
}
function z(t, n) {
  let o = h(t, p, "avLst")[0];
  if (o) {
    let e = h(o, p, "gd");
    for (let l of e) {
      let r2 = l.getAttribute("name"), i = l.getAttribute("fmla");
      !r2 || !i || (n[r2] = V(i, n));
    }
  }
  let L = h(t, p, "gdLst")[0];
  if (L) {
    let e = h(L, p, "gd");
    for (let l of e) {
      let r2 = l.getAttribute("name"), i = l.getAttribute("fmla");
      !r2 || !i || (n[r2] = V(i, n));
    }
  }
}
var G = {
  darken: "color-mix(in srgb, currentColor 60%, black)",
  darkenless: "color-mix(in srgb, currentColor 80%, black)",
  lighten: "color-mix(in srgb, currentColor 60%, white)",
  lightenless: "color-mix(in srgb, currentColor 80%, white)",
  accent: "var(--preset-accent, currentColor)",
  accentlight: "color-mix(in srgb, currentColor 85%, white)"
};
function J(t) {
  if (t == null) return "#000000";
  let n = String(t).toLowerCase();
  return n === "norm" || n === "auto" ? "#000000" : n === "none" || n === "false" || n === "transparent" ? "none" : n in G ? G[n] : /^#|^rgb|^hsl|^var\(/i.test(t) ? t : "#000000";
}
function R(t) {
  if (t == null) return "#000000";
  let n = t.toLowerCase();
  return n === "none" || n === "false" ? "none" : /^#|^rgb|^hsl|^var\(/i.test(t) ? t : "#000000";
}
function Z(t, n, o, L) {
  let e = t.getAttribute("x"), l = t.getAttribute("y"), r2 = k(e, n), i = k(l, n);
  return o && B(e) && (r2 *= o), L && B(l) && (i *= L), { x: r2, y: i };
}
function f0(t, n, o, L, e) {
  let l = n.getAttribute("wR"), r2 = n.getAttribute("hR"), i = Math.abs(k(l, o)), s = Math.abs(k(r2, o));
  L && B(l) && (i *= L), e && B(r2) && (s *= e);
  let a = k(n.getAttribute("stAng"), o), f = k(n.getAttribute("swAng"), o), c2 = (a % 216e5 + 216e5) % 216e5, A = f;
  A <= -216e5 && (A = -216e5), A >= 216e5 && (A = 216e5);
  let x = g(c2), d = 0, u = 0, M = 0, w = 0;
  t ? (d = t.x, u = t.y, M = d - i * Math.cos(x), w = u - s * Math.sin(x)) : (M = o.hc || 0, w = o.vc || 0, d = M + i * Math.cos(x), u = w + s * Math.sin(x));
  let P = Math.max(1, Math.ceil(Math.abs(A) / 108e5)), C = A / P, N = [], T = c2, E = d, D = u;
  for (let O = 0; O < P; O += 1) {
    let $ = T + C, I = g($), Q = M + i * Math.cos(I), j = w + s * Math.sin(I), s0 = Math.abs(C) > 108e5 ? 1 : 0, a0 = C >= 0 ? 1 : 0;
    N.push(`A ${i} ${s} 0 ${s0} ${a0} ${Q} ${j}`), T = $, E = Q, D = j;
  }
  return { command: N.join(" "), startPoint: { x: d, y: u }, endPoint: { x: E, y: D } };
}
function e0(t, n) {
  if (t == null) return 1;
  let o = Number(t);
  return !Number.isFinite(o) || o === 0 ? 1 : n / o;
}
function t0(t, n, o, L) {
  let e = [], l = null, r2 = 0, i = false, s = false, a = e0(t.getAttribute("w"), o), f = e0(t.getAttribute("h"), L);
  for (let c2 of b(t)) {
    let A = c2.localName || c2.nodeName || "";
    switch (A.includes(":") ? A.split(":").pop() : A) {
      case "moveTo": {
        let d = h(c2, p, "pt")[0];
        if (!d) break;
        let u = Z(d, n, a, f);
        e.push(`M ${u.x} ${u.y}`), l = u, r2 += 1;
        break;
      }
      case "lnTo": {
        let d = h(c2, p, "pt")[0];
        if (!d) break;
        let u = Z(d, n, a, f);
        e.push(`L ${u.x} ${u.y}`), l = u;
        break;
      }
      case "quadBezTo": {
        let d = h(c2, p, "pt");
        if (d.length === 2) {
          let u = Z(d[0], n, a, f), M = Z(d[1], n, a, f);
          e.push(`Q ${u.x} ${u.y} ${M.x} ${M.y}`), l = M;
        }
        break;
      }
      case "cubicBezTo": {
        let d = h(c2, p, "pt");
        if (d.length === 3) {
          let u = Z(d[0], n, a, f), M = Z(d[1], n, a, f), w = Z(d[2], n, a, f);
          e.push(`C ${u.x} ${u.y} ${M.x} ${M.y} ${w.x} ${w.y}`), l = w;
        }
        break;
      }
      case "arcTo": {
        let { command: d, startPoint: u, endPoint: M } = f0(l, c2, n, a, f);
        !l && u && (e.push(`M ${u.x} ${u.y}`), r2 += 1), e.push(d), l = M, s = true;
        break;
      }
      case "close":
        e.push("Z"), l = null, i = true;
        break;
    }
  }
  return { d: e.join(" "), moveCount: r2, isClosed: i, hasArc: s };
}
var c0 = /* @__PURE__ */ new Set(["pathLst", "avLst", "gdLst", "ahLst", "cxnLst", "rect"]), n0 = 100, o0 = { width: n0, height: n0 }, u0 = (t) => h(t, p, "path").length > 0;
function p0(t) {
  let n = b(t);
  return u0(t) && !n.some((e) => {
    let l = e.localName ?? e.tagName;
    return !c0.has(l);
  }) ? [t] : n;
}
function A0(t, n, o, L) {
  let e = t.getAttribute("fill"), l = t.getAttribute("stroke"), r2 = l != null ? String(l).toLowerCase() : null, i = t.getAttribute("strokeWidth"), s = t.hasAttribute("fill"), a = t.hasAttribute("stroke"), f = R(l), c2 = s ? J(e) : void 0;
  s || (o.isClosed ? a && (f === "none" || f == null) ? c2 = r2 === "false" ? L === "arc" ? "none" : "currentColor" : "none" : c2 = "#000000" : c2 = "none"), !a && (c2 === "#000000" || c2 === "none") && (f = R(null));
  let A;
  if (i && (A = k(i, n)), (c2 === "none" || c2 == null) && (f === "none" || f == null)) return null;
  let x, d = t.getAttribute("fillRule") || t.getAttribute("fill-rule");
  return d ? x = d : c2 !== "none" && o.moveCount > 1 && (x = "evenodd"), c2 === "currentColor" && (c2 = "#000000"), { fill: c2, stroke: f, strokeWidth: A, fillRule: x, clipRule: x };
}
function h0(t, n, o) {
  let L = H(n, o);
  z(t, L);
  let e = h(t, p, "pathLst")[0];
  if (!e) return null;
  let l = [], r2 = t.localName ?? t.tagName ?? "shape";
  for (let i of h(e, p, "path")) {
    let s = t0(i, L, n, o);
    if (!s || !s.d) continue;
    let a = A0(i, L, s, r2);
    a && l.push({ d: s.d, ...a });
  }
  return l.length ? { name: r2, viewBox: `0 0 ${n} ${o}`, paths: l } : null;
}
function L0(t, n = {}) {
  let o = n.width ?? o0.width, L = n.height ?? o0.height, e = U(), l = Y(t), i = e.parseFromString(l, "application/xml").documentElement, s = [];
  for (let a of p0(i)) {
    if (a.nodeType !== 1) continue;
    let f = h0(a, o, L);
    f && s.push(f);
  }
  return s;
}
var M0 = ["fill", "stroke", "strokeWidth", "fillRule", "clipRule"], r0 = _;
function S(t) {
  if (!t) return null;
  let n = {};
  return M0.forEach((o) => {
    let L = t[o];
    if (L !== void 0)
      if (o === "strokeWidth") {
        if (typeof L == "number") n.strokeWidth = L;
        else if (typeof L == "string") {
          let e = Number(L);
          Number.isFinite(e) && (n.strokeWidth = e);
        }
      } else typeof L == "string" && (n[o] = L);
  }), Object.keys(n).length ? n : null;
}
function l0(t, n) {
  let o = t.map((e) => ({ ...e }));
  if (!n) return o;
  let L = (e, l) => typeof n == "function" ? S(n(e, l)) : Array.isArray(n) ? S(n[l]) : S(n);
  return o.map((e, l) => {
    let r2 = L(e, l);
    return r2 ? { ...e, ...r2 } : e;
  });
}
function x0(t, n, o) {
  let L = X[t];
  if (!L) return null;
  let e = `<presetRoot xmlns:a="${p}">${L}</presetRoot>`, [l] = L0(e, { width: n, height: o });
  return l ? { viewBox: l.viewBox, paths: l.paths } : null;
}
function i0(t) {
  let { preset: n, styleOverrides: o, width: L, height: e } = t;
  if (!n) throw new Error("createPresetShape requires a preset name.");
  if (F.has(n) && L != null && e != null && L !== e) {
    let i = x0(n, L, e);
    if (i) return { preset: n, viewBox: i.viewBox, paths: l0(i.paths, o) };
  }
  let r2 = r0[n];
  if (!r2) throw new Error(`Unknown preset shape: ${n}`);
  return { preset: n, viewBox: r2.viewBox, paths: l0(r2.paths, o) };
}
function k0(t) {
  let n = i0(t), o = n.paths.map((L) => {
    let e = [`d="${L.d}"`];
    return L.fill !== void 0 && e.push(`fill="${L.fill}"`), L.stroke !== void 0 && e.push(`stroke="${L.stroke}"`), L.strokeWidth !== void 0 && e.push(`stroke-width="${L.strokeWidth}"`), L.fillRule !== void 0 && e.push(`fill-rule="${L.fillRule}"`), L.clipRule !== void 0 && e.push(`clip-rule="${L.clipRule}"`), `  <path ${e.join(" ")} />`;
  }).join(`
`);
  return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${n.viewBox}" preserveAspectRatio="none">
${o}
</svg>`;
}
function validateHexColor(color) {
  if (typeof color !== "string") return void 0;
  const trimmed = color.trim();
  if (!trimmed) return void 0;
  const withoutHash = trimmed.startsWith("#") ? trimmed.slice(1) : trimmed;
  const hexPattern = /^[0-9A-Fa-f]{3}$|^[0-9A-Fa-f]{6}$/;
  if (!hexPattern.test(withoutHash)) {
    return void 0;
  }
  return `#${withoutHash}`;
}
function addValidatedGradientStops(gradient, stops) {
  stops.forEach((stop) => {
    const position = typeof stop.position === "number" && Number.isFinite(stop.position) ? Math.max(0, Math.min(1, stop.position)) : 0;
    const validatedColor = validateHexColor(stop.color);
    if (!validatedColor) {
      return;
    }
    const alpha = typeof stop.alpha === "number" && Number.isFinite(stop.alpha) ? Math.max(0, Math.min(1, stop.alpha)) : 1;
    const stopElement = document.createElementNS("http://www.w3.org/2000/svg", "stop");
    stopElement.setAttribute("offset", `${position * 100}%`);
    stopElement.setAttribute("stop-color", validatedColor);
    if (alpha < 1) {
      stopElement.setAttribute("stop-opacity", alpha.toString());
    }
    gradient.appendChild(stopElement);
  });
}
function createGradient$1(gradientData, gradientId) {
  const { gradientType, stops, angle } = gradientData;
  if (!stops || stops.length === 0) {
    return null;
  }
  let gradient;
  if (gradientType === "linear") {
    gradient = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
    gradient.setAttribute("id", gradientId);
    const radians = angle * Math.PI / 180;
    const x1 = 50 - 50 * Math.cos(radians);
    const y1 = 50 + 50 * Math.sin(radians);
    const x2 = 50 + 50 * Math.cos(radians);
    const y2 = 50 - 50 * Math.sin(radians);
    gradient.setAttribute("x1", `${x1}%`);
    gradient.setAttribute("y1", `${y1}%`);
    gradient.setAttribute("x2", `${x2}%`);
    gradient.setAttribute("y2", `${y2}%`);
  } else {
    gradient = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
    gradient.setAttribute("id", gradientId);
    gradient.setAttribute("cx", "50%");
    gradient.setAttribute("cy", "50%");
    gradient.setAttribute("r", "50%");
  }
  addValidatedGradientStops(gradient, stops);
  return gradient;
}
function applyGradientToSVG$1(svg, gradientData) {
  try {
    const gradientId = generateGradientId("gradient");
    const gradient = createGradient$1(gradientData, gradientId);
    if (!gradient) {
      return;
    }
    let defs = svg.querySelector("defs");
    if (!defs) {
      defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
      svg.insertBefore(defs, svg.firstChild);
    }
    defs.appendChild(gradient);
    const filledElements = svg.querySelectorAll('[fill]:not([fill="none"])');
    filledElements.forEach((el) => {
      el.setAttribute("fill", `url(#${gradientId})`);
    });
  } catch (error) {
    console.error("Failed to apply gradient to SVG:", error);
  }
}
function applyAlphaToSVG$1(svg, alphaData) {
  try {
    const { color, alpha } = alphaData;
    const validatedColor = validateHexColor(color);
    if (!validatedColor) {
      return;
    }
    const clampedAlpha = typeof alpha === "number" && Number.isFinite(alpha) ? Math.max(0, Math.min(1, alpha)) : 1;
    const filledElements = svg.querySelectorAll('[fill]:not([fill="none"])');
    filledElements.forEach((el) => {
      el.setAttribute("fill", validatedColor);
      el.setAttribute("fill-opacity", clampedAlpha.toString());
    });
  } catch (error) {
    console.error("Failed to apply alpha to SVG:", error);
  }
}
let gradientIdCounter = 0;
function generateGradientId(prefix2 = "gradient") {
  return `${prefix2}-${Date.now()}-${gradientIdCounter++}-${Math.random().toString(36).substring(2, 11)}`;
}
const CLASS_NAMES$1 = {
  container: "superdoc-layout",
  page: "superdoc-page",
  fragment: "superdoc-fragment",
  line: "superdoc-line",
  spread: "superdoc-spread",
  pageHeader: "superdoc-page-header",
  pageFooter: "superdoc-page-footer"
};
const DEFAULT_PAGE_STYLES = {
  background: "#fff",
  boxShadow: "0 4px 20px rgba(15, 23, 42, 0.08)",
  border: "1px solid rgba(15, 23, 42, 0.08)",
  margin: "0 auto"
};
const containerStyles = {
  display: "flex",
  flexDirection: "column",
  alignItems: "center",
  background: "transparent",
  padding: "0",
  // gap is set dynamically by renderer based on pageGap option (default: 24px)
  overflowY: "auto"
};
const containerStylesHorizontal = {
  display: "flex",
  flexDirection: "row",
  alignItems: "flex-start",
  justifyContent: "safe center",
  background: "transparent",
  padding: "0",
  // gap is set dynamically by renderer based on pageGap option (default: 20px for horizontal)
  overflowX: "auto",
  minHeight: "100%"
};
const spreadStyles = {
  display: "flex",
  flexDirection: "row",
  alignItems: "center",
  gap: "0px"
};
const pageStyles = (width, height, overrides) => {
  const merged = { ...DEFAULT_PAGE_STYLES, ...overrides || {} };
  return {
    position: "relative",
    width: `${width}px`,
    height: `${height}px`,
    minWidth: `${width}px`,
    minHeight: `${height}px`,
    flexShrink: "0",
    background: merged.background,
    boxShadow: merged.boxShadow,
    border: merged.border,
    margin: merged.margin,
    overflow: "hidden"
  };
};
const fragmentStyles = {
  position: "absolute",
  whiteSpace: "pre",
  overflow: "visible",
  boxSizing: "border-box"
};
const lineStyles = (lineHeight2) => ({
  lineHeight: `${lineHeight2}px`,
  height: `${lineHeight2}px`,
  position: "relative",
  display: "block",
  whiteSpace: "pre",
  // Allow text to overflow the line container as a safety net.
  // The primary fix uses accurate font metrics from Canvas API, but this
  // provides defense-in-depth against any remaining sub-pixel rendering
  // differences between measurement and display.
  overflow: "visible",
  zIndex: "10"
});
const PRINT_STYLES = `
@media print {
  .${CLASS_NAMES$1.container} {
    background: transparent;
    padding: 0;
  }

  .${CLASS_NAMES$1.page} {
    margin: 0;
    border: none;
    box-shadow: none;
    page-break-after: always;
  }
}
`;
const LINK_AND_TOC_STYLES = `
/* Reset browser default link styling - allow run colors to show through from inline styles
 *
 * Note: !important was removed from these rules to allow inline styles to take precedence.
 * This is necessary because OOXML hyperlink character styles apply colors via inline style
 * attributes on the run elements. The CSS cascade ensures that inline styles (applied via
 * element.style.color in applyRunStyles) override these class-based rules naturally.
 *
 * Implications:
 * - OOXML hyperlink character styles will correctly display their assigned colors
 * - Browser default link colors are still reset by these inherit rules
 * - Inline color styles from run objects override the inherit value as expected
 */
.superdoc-link {
  color: inherit;
  text-decoration: none;
}

.superdoc-link:visited {
  color: inherit;
}

.superdoc-link:hover {
  text-decoration: underline;
}

/* Focus visible for keyboard navigation (WCAG 2.1 SC 2.4.7) */
.superdoc-link:focus-visible {
  outline: 2px solid #0066cc;
  outline-offset: 2px;
  border-radius: 2px;
}

/* Remove outline for mouse users */
.superdoc-link:focus:not(:focus-visible) {
  outline: none;
}

/* Active state */
.superdoc-link:active {
  opacity: 0.8;
}

/* Print mode: show URLs after links */
@media print {
  .superdoc-link::after {
    content: " (" attr(href) ")";
    font-size: 0.9em;
    color: #666;
  }

  /* Don't show URL for anchor-only links */
  .superdoc-link[href^="#"]::after {
    content: "";
  }
}

/* High contrast mode support */
@media (prefers-contrast: high) {
  .superdoc-link:focus-visible {
    outline-width: 3px;
    outline-offset: 3px;
  }
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {
  .superdoc-link {
    transition: none;
  }
}

/* Screen reader only content (WCAG SC 1.3.1) */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

/* TOC entry specific styles - prevent wrapping */
.superdoc-toc-entry {
  white-space: nowrap !important;
}

.superdoc-toc-entry .superdoc-link {
  color: inherit !important;
  text-decoration: none !important;
  cursor: default;
}

.superdoc-toc-entry .superdoc-link:hover {
  text-decoration: none;
}

/* Override focus styles for TOC links (they're not interactive) */
.superdoc-toc-entry .superdoc-link:focus-visible {
  outline: none;
}

/* Remove focus outlines from layout engine elements */
.superdoc-layout,
.superdoc-page,
.superdoc-layout:focus,
.superdoc-page:focus {
  outline: none !important;
}
`;
const TRACK_CHANGE_STYLES = `
.superdoc-layout .track-insert-dec.hidden,
.superdoc-layout .track-delete-dec.hidden {
  display: none;
}

.superdoc-layout .track-insert-dec.highlighted {
  border-top: 1px dashed #00853d;
  border-bottom: 1px dashed #00853d;
  background-color: #399c7222;
}

.superdoc-layout .track-delete-dec.highlighted {
  border-top: 1px dashed #cb0e47;
  border-bottom: 1px dashed #cb0e47;
  background-color: #cb0e4722;
  text-decoration: line-through !important;
  text-decoration-thickness: 2px !important;
}

.superdoc-layout .track-format-dec.highlighted {
  border-bottom: 2px solid gold;
}
`;
const SDT_CONTAINER_STYLES = `
/* Document Section - Block-level container with gray border and hover tooltip */
.superdoc-document-section {
  background-color: #fafafa;
  border: 1px solid #ababab;
  border-radius: 4px;
  position: relative;
  box-sizing: border-box;
}

/* Document section tooltip - positioned above the fragment */
.superdoc-document-section__tooltip {
  position: absolute;
  top: -19px;
  left: -1px;
  max-width: 100px;
  min-width: 0;
  height: 18px;
  border: 1px solid #ababab;
  border-bottom: none;
  border-radius: 6px 6px 0 0;
  padding: 0 8px;
  align-items: center;
  font-size: 10px;
  display: none;
  z-index: 100;
  background-color: #fafafa;
  pointer-events: none;
}

.superdoc-document-section__tooltip span {
  max-width: 100%;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

/* Show tooltip on hover - adjust border radius to connect with tooltip tab */
.superdoc-document-section:hover {
  border-radius: 0 4px 4px 4px;
}

.superdoc-document-section:hover .superdoc-document-section__tooltip {
  display: flex;
  align-items: center;
}

/* Continuation styling: SDT container boundary handling for multi-fragment document sections */
/* Single fragment (both start and end): full border radius */
.superdoc-document-section[data-sdt-container-start="true"][data-sdt-container-end="true"] {
  border-radius: 4px;
}

/* First fragment of a multi-fragment SDT: top corners, no bottom border */
.superdoc-document-section[data-sdt-container-start="true"]:not([data-sdt-container-end="true"]) {
  border-radius: 4px 4px 0 0;
  border-bottom: none;
}

/* Last fragment of a multi-fragment SDT: bottom corners, no top border */
.superdoc-document-section[data-sdt-container-end="true"]:not([data-sdt-container-start="true"]) {
  border-radius: 0 0 4px 4px;
  border-top: none;
}

.superdoc-document-section[data-sdt-container-start="true"]:hover {
  border-radius: 0 4px 0 0;
}

/* Middle fragments (neither start nor end): no corners, no top/bottom borders */
.superdoc-document-section:not([data-sdt-container-start="true"]):not([data-sdt-container-end="true"]) {
  border-radius: 0;
  border-top: none;
  border-bottom: none;
}

/* Structured Content Block - Blue border container */
.superdoc-structured-content-block {
  padding: 1px;
  box-sizing: border-box;
  border-radius: 4px;
  border: 1px solid #629be7;
  position: relative;
}

/* Structured content drag handle/label - positioned above */
.superdoc-structured-content__label {
  font-size: 10px;
  align-items: center;
  justify-content: center;
  position: absolute;
  left: 2px;
  top: -19px;
  width: calc(100% - 4px);
  max-width: 110px;
  min-width: 0;
  height: 18px;
  padding: 0 4px;
  border: 1px solid #629be7;
  border-bottom: none;
  border-radius: 6px 6px 0 0;
  background-color: #629be7dd;
  box-sizing: border-box;
  z-index: 10;
  display: none;
  pointer-events: none;
}

.superdoc-structured-content__label span {
  max-width: 100%;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
}

.superdoc-structured-content-block:hover .superdoc-structured-content__label {
  display: inline-flex;
}

/* Continuation styling for structured content blocks */
/* Single fragment (both start and end): full border radius */
.superdoc-structured-content-block[data-sdt-container-start="true"][data-sdt-container-end="true"] {
  border-radius: 4px;
}

/* First fragment of a multi-fragment SDT: top corners, no bottom border */
.superdoc-structured-content-block[data-sdt-container-start="true"]:not([data-sdt-container-end="true"]) {
  border-radius: 4px 4px 0 0;
  border-bottom: none;
}

/* Last fragment of a multi-fragment SDT: bottom corners, no top border */
.superdoc-structured-content-block[data-sdt-container-end="true"]:not([data-sdt-container-start="true"]) {
  border-radius: 0 0 4px 4px;
  border-top: none;
}

/* Middle fragment (neither start nor end): no corners, no top/bottom borders */
.superdoc-structured-content-block:not([data-sdt-container-start="true"]):not([data-sdt-container-end="true"]) {
  border-radius: 0;
  border-top: none;
  border-bottom: none;
}

/* Structured Content Inline - Inline wrapper with blue border */
.superdoc-structured-content-inline {
  padding: 1px;
  box-sizing: border-box;
  border-radius: 4px;
  border: 1px solid #629be7;
  position: relative;
  display: inline;
  z-index: 10;
}

/* Hover effect for inline structured content */
.superdoc-structured-content-inline:hover {
  background-color: rgba(98, 155, 231, 0.15);
  border-color: #4a8ad9;
}

/* Inline structured content label - shown on hover */
.superdoc-structured-content-inline__label {
  position: absolute;
  bottom: calc(100% + 2px);
  left: 50%;
  transform: translateX(-50%);
  font-size: 10px;
  padding: 2px 6px;
  background-color: #629be7dd;
  color: white;
  border-radius: 4px;
  white-space: nowrap;
  z-index: 100;
  display: none;
  pointer-events: none;
}

.superdoc-structured-content-inline:hover .superdoc-structured-content-inline__label {
  display: block;
}

/* Viewing mode: remove structured content affordances */
.presentation-editor--viewing .superdoc-structured-content-block,
.presentation-editor--viewing .superdoc-structured-content-inline {
  background: none;
  border: none;
  padding: 0;
}

.presentation-editor--viewing .superdoc-structured-content-inline:hover {
  background: none;
  border: none;
}

.presentation-editor--viewing .superdoc-structured-content__label,
.presentation-editor--viewing .superdoc-structured-content-inline__label {
  display: none !important;
}

/* Print mode: hide visual styling for SDT containers */
@media print {
  .superdoc-document-section,
  .superdoc-structured-content-block,
  .superdoc-structured-content-inline {
    background: none;
    border: none;
    padding: 0;
  }

  .superdoc-document-section__tooltip,
  .superdoc-structured-content__label,
  .superdoc-structured-content-inline__label {
    display: none !important;
  }
}
`;
const FIELD_ANNOTATION_STYLES = `
/* Field annotation draggable styles */
.superdoc-layout .annotation[data-draggable="true"] {
  user-select: text;
}

.superdoc-layout .annotation::selection,
.superdoc-layout .annotation *::selection {
  background: transparent;
}
  
.superdoc-layout .annotation::-moz-selection,
.superdoc-layout .annotation *::-moz-selection  {
  background: transparent;
}

.superdoc-layout .annotation,
.superdoc-layout .annotation * {
  caret-color: transparent;
}

.superdoc-layout .annotation[data-draggable="true"]:hover {
  opacity: 0.9;
}

.superdoc-layout .annotation[data-draggable="true"]:active {
  cursor: grabbing;
}

/* Drag over indicator for drop targets */
.superdoc-layout.drag-over {
  outline: 2px dashed #b015b3;
  outline-offset: -2px;
}

/* Drop zone indicator */
.superdoc-layout .superdoc-drop-indicator {
  position: absolute;
  width: 2px;
  background-color: #b015b3;
  pointer-events: none;
  z-index: 1000;
}
`;
const IMAGE_SELECTION_STYLES = `
/* Highlight for selected images (block or inline) */
.superdoc-image-selected {
  outline: 2px solid #4a90e2;
  outline-offset: 2px;
  border-radius: 2px;
  box-shadow: 0 0 0 1px rgba(74, 144, 226, 0.35);
}

/* Ensure inline images can be targeted */
.superdoc-inline-image.superdoc-image-selected {
  outline-offset: 2px;
}
`;
const NATIVE_SELECTION_STYLES = `
/* Hide native browser selection on layout engine content.
 * We render our own selection overlay via PresentationEditor's #localSelectionLayer
 * for precise control over selection geometry across pages and zoom levels. */
.superdoc-layout *::selection {
  background: transparent;
}

.superdoc-layout *::-moz-selection {
  background: transparent;
}
`;
let printStylesInjected = false;
let linkStylesInjected = false;
let trackChangeStylesInjected = false;
let sdtContainerStylesInjected = false;
let fieldAnnotationStylesInjected = false;
let imageSelectionStylesInjected = false;
let nativeSelectionStylesInjected = false;
const ensurePrintStyles = (doc2) => {
  if (printStylesInjected || !doc2) return;
  const styleEl = doc2.createElement("style");
  styleEl.setAttribute("data-superdoc-print-styles", "true");
  styleEl.textContent = PRINT_STYLES;
  doc2.head?.appendChild(styleEl);
  printStylesInjected = true;
};
const ensureLinkStyles = (doc2) => {
  if (linkStylesInjected || !doc2) return;
  const styleEl = doc2.createElement("style");
  styleEl.setAttribute("data-superdoc-link-styles", "true");
  styleEl.textContent = LINK_AND_TOC_STYLES;
  doc2.head?.appendChild(styleEl);
  linkStylesInjected = true;
};
const ensureTrackChangeStyles = (doc2) => {
  if (trackChangeStylesInjected || !doc2) return;
  const styleEl = doc2.createElement("style");
  styleEl.setAttribute("data-superdoc-track-change-styles", "true");
  styleEl.textContent = TRACK_CHANGE_STYLES;
  doc2.head?.appendChild(styleEl);
  trackChangeStylesInjected = true;
};
const ensureSdtContainerStyles = (doc2) => {
  if (sdtContainerStylesInjected || !doc2) return;
  const styleEl = doc2.createElement("style");
  styleEl.setAttribute("data-superdoc-sdt-container-styles", "true");
  styleEl.textContent = SDT_CONTAINER_STYLES;
  doc2.head?.appendChild(styleEl);
  sdtContainerStylesInjected = true;
};
const ensureFieldAnnotationStyles = (doc2) => {
  if (fieldAnnotationStylesInjected || !doc2) return;
  const styleEl = doc2.createElement("style");
  styleEl.setAttribute("data-superdoc-field-annotation-styles", "true");
  styleEl.textContent = FIELD_ANNOTATION_STYLES;
  doc2.head?.appendChild(styleEl);
  fieldAnnotationStylesInjected = true;
};
const ensureImageSelectionStyles = (doc2) => {
  if (imageSelectionStylesInjected || !doc2) return;
  const styleEl = doc2.createElement("style");
  styleEl.setAttribute("data-superdoc-image-selection-styles", "true");
  styleEl.textContent = IMAGE_SELECTION_STYLES;
  doc2.head?.appendChild(styleEl);
  imageSelectionStylesInjected = true;
};
const ensureNativeSelectionStyles = (doc2) => {
  if (nativeSelectionStylesInjected || !doc2) return;
  const styleEl = doc2.createElement("style");
  styleEl.setAttribute("data-superdoc-native-selection-styles", "true");
  styleEl.textContent = NATIVE_SELECTION_STYLES;
  doc2.head?.appendChild(styleEl);
  nativeSelectionStylesInjected = true;
};
const DOM_CLASS_NAMES = {
  /**
   * Class name for page container elements.
   * Applied to top-level page divs in the rendered output.
   */
  PAGE: "superdoc-page",
  /**
   * Class name for fragment container elements.
   * Fragments represent logical blocks within a page (paragraphs, tables, etc.).
   */
  FRAGMENT: "superdoc-fragment",
  /**
   * Class name for line container elements.
   * Lines contain text runs and are the basic unit of layout within fragments.
   */
  LINE: "superdoc-line",
  /**
   * Class name for inline structured content (SDT) wrapper elements.
   *
   * Inline SDTs wrap regions of inline content to provide semantic structure.
   * These wrapper elements:
   * - Have `data-pm-start` and `data-pm-end` attributes for selection highlighting
   * - Should be EXCLUDED from click-to-position mapping (child spans are the targets)
   * - Display visual borders and labels on hover
   *
   * **Important:** When handling clicks or caret positioning, the child text spans
   * within this wrapper should be used for character-level positioning, not the
   * wrapper itself.
   */
  INLINE_SDT_WRAPPER: "superdoc-structured-content-inline"
};
const DEFAULT_ALLOWED_PROTOCOLS = ["http", "https", "mailto", "tel", "sms"];
const OPTIONAL_PROTOCOLS = ["ftp", "sftp", "irc"];
const BLOCKED_PROTOCOLS = ["javascript", "data", "vbscript", "file", "ssh", "ws", "wss"];
const DEFAULT_MAX_LENGTH = 2048;
const DEFAULT_TOOLTIP_MAX_LENGTH = 500;
const ANCHOR_NAME_PATTERN = /^[A-Za-z0-9._-]+$/;
function toProtocolSet(values) {
  const result = /* @__PURE__ */ new Set();
  if (!values) return result;
  values.forEach((value) => {
    if (typeof value === "string" && value.trim()) {
      result.add(value.trim().toLowerCase());
    }
  });
  return result;
}
function buildAllowedProtocols(config = {}) {
  const allowed = config.allowedProtocols?.length ? toProtocolSet(config.allowedProtocols) : new Set(DEFAULT_ALLOWED_PROTOCOLS);
  const optional = toProtocolSet(config.optionalProtocols);
  if (optional.size > 0) {
    optional.forEach((protocol) => {
      if (OPTIONAL_PROTOCOLS.includes(protocol)) {
        allowed.add(protocol);
      }
    });
  }
  return allowed;
}
function normalizeBlocklist(values) {
  const hosts = /* @__PURE__ */ new Set();
  const urls = /* @__PURE__ */ new Set();
  if (!values) {
    return { hosts, urls };
  }
  values.forEach((entry) => {
    if (!entry || typeof entry !== "string") return;
    const trimmed = entry.trim().toLowerCase();
    if (!trimmed) return;
    if (trimmed.includes("://")) {
      urls.add(trimmed);
    } else {
      hosts.add(trimmed);
    }
  });
  return { hosts, urls };
}
function parseAnchorLink(trimmed) {
  if (!trimmed.startsWith("#")) return null;
  const anchor = trimmed.slice(1);
  if (!anchor || !ANCHOR_NAME_PATTERN.test(anchor)) {
    return null;
  }
  return { href: `#${anchor}`, protocol: null, isExternal: false };
}
function isProtocolAllowed(scheme, allowedProtocols, blockedProtocols) {
  if (blockedProtocols.includes(scheme)) {
    return false;
  }
  return allowedProtocols.has(scheme);
}
function isBlockedByRedirectList(normalizedHref, parsed, blocklist) {
  const { hosts, urls } = blocklist;
  const hostname = parsed.hostname ? parsed.hostname.toLowerCase() : "";
  if (hosts.size > 0 && hostname && hosts.has(hostname)) {
    return true;
  }
  if (urls.size > 0) {
    const hrefLower = normalizedHref.toLowerCase();
    for (const blockedUrl of urls) {
      if (hrefLower.startsWith(blockedUrl)) {
        return true;
      }
    }
  }
  return false;
}
function sanitizeHref(raw, config = {}) {
  if (typeof raw !== "string") return null;
  const trimmed = raw.trim();
  if (!trimmed) return null;
  const maxLength = typeof config.maxLength === "number" ? config.maxLength : DEFAULT_MAX_LENGTH;
  if (trimmed.length > maxLength) {
    return null;
  }
  const anchorResult = parseAnchorLink(trimmed);
  if (anchorResult !== null) {
    return anchorResult;
  }
  if (trimmed.startsWith("/") || trimmed.startsWith(".") || trimmed.startsWith("//") || /^www\./i.test(trimmed)) {
    return null;
  }
  const schemeMatch = trimmed.match(/^([a-z0-9+.-]+):/i);
  if (!schemeMatch) {
    return null;
  }
  const scheme = schemeMatch[1].toLowerCase();
  const allowedProtocols = buildAllowedProtocols(config);
  const blockedProtocols = BLOCKED_PROTOCOLS.concat(config.blockedProtocols ?? []).map((p2) => p2.toLowerCase());
  if (!isProtocolAllowed(scheme, allowedProtocols, blockedProtocols)) {
    return null;
  }
  const hostStartIndex = trimmed.indexOf("://") + 3;
  let hostEndIndex = trimmed.indexOf("/", hostStartIndex);
  if (hostEndIndex === -1) {
    hostEndIndex = trimmed.indexOf("?", hostStartIndex);
  }
  if (hostEndIndex === -1) {
    hostEndIndex = trimmed.indexOf("#", hostStartIndex);
  }
  if (hostEndIndex === -1) {
    hostEndIndex = trimmed.length;
  }
  const rawHostname = trimmed.slice(hostStartIndex, hostEndIndex).toLowerCase();
  if (rawHostname && /[^\x00-\x7F]/.test(rawHostname)) {
    if (vue.process$1.env.NODE_ENV === "development" || vue.process$1.env.DEBUG_HYPERLINKS === "true") {
      console.warn(`[URL Validation] Potential homograph attack detected in hostname: ${rawHostname.slice(0, 50)}`);
    }
  }
  const queryStartIndex = trimmed.indexOf("?");
  if (queryStartIndex !== -1) {
    const queryString = trimmed.slice(queryStartIndex);
    if (/[<>"']/.test(queryString)) {
      return null;
    }
  }
  let parsed;
  try {
    parsed = new URL(trimmed);
  } catch {
    return null;
  }
  const normalizedHref = trimmed;
  const blocklist = normalizeBlocklist(config.redirectBlocklist);
  if (isBlockedByRedirectList(normalizedHref, parsed, blocklist)) {
    return null;
  }
  const isExternal = scheme === "http" || scheme === "https";
  return { href: normalizedHref, protocol: scheme, isExternal };
}
function encodeTooltip(raw, maxLength = DEFAULT_TOOLTIP_MAX_LENGTH) {
  if (typeof raw !== "string") return null;
  const trimmed = raw.trim();
  if (!trimmed) return null;
  const limit = typeof maxLength === "number" && maxLength > 0 ? maxLength : 0;
  const wasTruncated = limit > 0 && trimmed.length > limit;
  const text = limit > 0 && trimmed.length > limit ? trimmed.slice(0, limit) : trimmed;
  return {
    text,
    wasTruncated
  };
}
const UrlValidationConstants = {
  DEFAULT_ALLOWED_PROTOCOLS
};
const ALLOWED_BORDER_STYLES = /* @__PURE__ */ new Set([
  "none",
  "single",
  "double",
  "dashed",
  "dotted",
  "thick",
  "triple",
  "dotDash",
  "dotDotDash",
  "wave",
  "doubleWave"
]);
const borderStyleToCSS = (style2) => {
  if (!style2 || style2 === "none") return "none";
  if (!ALLOWED_BORDER_STYLES.has(style2)) {
    console.warn(`Invalid border style: ${style2}, using 'solid' fallback`);
    return "solid";
  }
  const styleMap = {
    none: "none",
    single: "solid",
    double: "double",
    dashed: "dashed",
    dotted: "dotted",
    thick: "solid",
    triple: "solid",
    dotDash: "dashed",
    dotDotDash: "dashed",
    wave: "solid",
    doubleWave: "solid"
  };
  return styleMap[style2];
};
const isValidHexColor = (color) => /^#[0-9A-Fa-f]{6}$/.test(color);
const applyBorder = (element, side, border) => {
  if (!border) return;
  if (border.style === "none" || border.width === 0) {
    element.style[`border${side}`] = "none";
    return;
  }
  const style2 = borderStyleToCSS(border.style);
  const width = border.width ?? 1;
  const color = border.color ?? "#000000";
  const safeColor = isValidHexColor(color) ? color : "#000000";
  const actualWidth = border.style === "thick" ? Math.max(width * 2, 3) : width;
  element.style[`border${side}`] = `${actualWidth}px ${style2} ${safeColor}`;
};
const applyCellBorders = (element, borders) => {
  if (!borders) return;
  applyBorder(element, "Top", borders.top);
  applyBorder(element, "Right", borders.right);
  applyBorder(element, "Bottom", borders.bottom);
  applyBorder(element, "Left", borders.left);
};
const borderValueToSpec = (value) => {
  if (!value) return void 0;
  if (typeof value === "object" && "none" in value && value.none) {
    return { style: "none", width: 0 };
  }
  if (typeof value === "object") {
    const raw = value;
    const width = typeof raw.width === "number" ? raw.width : typeof raw.size === "number" ? raw.size : void 0;
    const color = typeof raw.color === "string" ? raw.color : void 0;
    const space = typeof raw.space === "number" ? raw.space : void 0;
    const style2 = raw.style ?? "single";
    const spec = { style: style2 };
    if (width != null) spec.width = width;
    if (color) spec.color = color;
    if (space != null) spec.space = space;
    return spec;
  }
  return void 0;
};
const resolveTableCellBorders = (tableBorders, rowIndex, colIndex, totalRows, totalCols) => {
  const isFirstRow = rowIndex === 0;
  const isLastRow = rowIndex === totalRows - 1;
  const isFirstCol = colIndex === 0;
  const isLastCol = colIndex === totalCols - 1;
  return {
    // Top: first row gets table.top, interior rows get insideH
    top: borderValueToSpec(isFirstRow ? tableBorders?.top : tableBorders?.insideH),
    // Bottom: ONLY last row gets table.bottom (interior cells don't render bottom - it comes from cell below's top)
    bottom: borderValueToSpec(isLastRow ? tableBorders?.bottom : null),
    // Left: first col gets table.left, interior cols get insideV
    left: borderValueToSpec(isFirstCol ? tableBorders?.left : tableBorders?.insideV),
    // Right: ONLY last col gets table.right (interior cells don't render right - it comes from cell to right's left)
    right: borderValueToSpec(isLastCol ? tableBorders?.right : null)
  };
};
const clampNumber = (value, min2, max2) => Math.min(max2, Math.max(min2, value));
const mergeSortedSegments = (segments) => {
  if (segments.length <= 1) return segments;
  const merged = [];
  let current = segments[0];
  for (let i = 1; i < segments.length; i += 1) {
    const next = segments[i];
    if (next.start <= current.end) {
      current = { start: current.start, end: Math.max(current.end, next.end) };
      continue;
    }
    merged.push(current);
    current = next;
  }
  merged.push(current);
  return merged;
};
const applySquareWrapExclusionsToLines = (renderedLines, exclusions, contentWidthPx, alignmentOffsetY) => {
  if (renderedLines.length === 0 || exclusions.length === 0 || contentWidthPx <= 0) return;
  renderedLines.forEach((line) => {
    const paddingLeft = line.el.style.paddingLeft;
    const paddingRight = line.el.style.paddingRight;
    if (paddingLeft && paddingLeft !== "0px" || paddingRight && paddingRight !== "0px") {
      return;
    }
    const lineTop = line.top + alignmentOffsetY;
    const lineBottom = lineTop + line.height;
    const excludedSegments = [];
    for (const ex of exclusions) {
      if (lineBottom <= ex.top || lineTop >= ex.bottom) continue;
      if (ex.wrapText !== "bothSides") continue;
      const start2 = clampNumber(ex.left, 0, contentWidthPx);
      const end2 = clampNumber(ex.right, 0, contentWidthPx);
      if (end2 <= start2) continue;
      excludedSegments.push({ start: start2, end: end2 });
    }
    if (excludedSegments.length === 0) return;
    excludedSegments.sort((a, b2) => a.start - b2.start);
    const merged = mergeSortedSegments(excludedSegments);
    let bestStart = 0;
    let bestWidth = 0;
    let cursor = 0;
    for (const seg of merged) {
      const gapWidth = seg.start - cursor;
      if (gapWidth > bestWidth) {
        bestStart = cursor;
        bestWidth = gapWidth;
      }
      cursor = Math.max(cursor, seg.end);
    }
    const tailWidth = contentWidthPx - cursor;
    if (tailWidth > bestWidth) {
      bestStart = cursor;
      bestWidth = tailWidth;
    }
    if (bestWidth <= 0 || bestStart === 0 && bestWidth >= contentWidthPx) return;
    const marginLeft = bestStart;
    const marginRight = Math.max(0, contentWidthPx - (bestStart + bestWidth));
    line.el.style.boxSizing = "border-box";
    line.el.style.marginLeft = `${marginLeft}px`;
    line.el.style.marginRight = `${marginRight}px`;
  });
};
const FONT_FAMILY_FALLBACKS = Object.freeze({
  swiss: "Arial, sans-serif",
  roman: "Times New Roman, serif",
  modern: "Courier New, monospace",
  script: "cursive",
  decorative: "fantasy",
  system: "system-ui",
  auto: "sans-serif"
});
const DEFAULT_GENERIC_FALLBACK = "sans-serif";
const normalizeParts = (value) => (value || "").split(",").map((part) => part.trim()).filter(Boolean);
function mapWordFamilyFallback(wordFamily) {
  if (!wordFamily) return DEFAULT_GENERIC_FALLBACK;
  const mapped = FONT_FAMILY_FALLBACKS[wordFamily.toLowerCase()];
  return mapped || DEFAULT_GENERIC_FALLBACK;
}
function toCssFontFamily(fontName, options = {}) {
  if (!fontName || typeof fontName !== "string") return fontName;
  const trimmed = fontName.trim();
  if (!trimmed || trimmed.includes(",")) return trimmed;
  const { fallback, wordFamily } = options;
  const fallbackValue = fallback ?? (wordFamily ? mapWordFamilyFallback(wordFamily) : void 0) ?? DEFAULT_GENERIC_FALLBACK;
  const fallbackParts = normalizeParts(fallbackValue);
  if (fallbackParts.length === 0) {
    return trimmed;
  }
  const normalizedName = trimmed.toLowerCase();
  const includesName = fallbackParts.some((part) => part.toLowerCase() === normalizedName);
  if (includesName) {
    return fallbackParts.join(", ");
  }
  return [trimmed, ...fallbackParts].join(", ");
}
function isStructuredContentMetadata(sdt) {
  return sdt !== null && sdt !== void 0 && typeof sdt === "object" && "type" in sdt && sdt.type === "structuredContent";
}
function isDocumentSectionMetadata(sdt) {
  return sdt !== null && sdt !== void 0 && typeof sdt === "object" && "type" in sdt && sdt.type === "documentSection";
}
function getSdtContainerConfig(sdt) {
  if (isDocumentSectionMetadata(sdt)) {
    return {
      className: "superdoc-document-section",
      labelText: sdt.title ?? "Document section",
      labelClassName: "superdoc-document-section__tooltip",
      isStart: true,
      isEnd: true
    };
  }
  if (isStructuredContentMetadata(sdt) && sdt.scope === "block") {
    return {
      className: "superdoc-structured-content-block",
      labelText: sdt.alias ?? "Structured content",
      labelClassName: "superdoc-structured-content__label",
      isStart: true,
      isEnd: true
    };
  }
  return null;
}
function getSdtContainerMetadata(sdt, containerSdt) {
  if (getSdtContainerConfig(sdt)) return sdt ?? null;
  if (getSdtContainerConfig(containerSdt)) return containerSdt ?? null;
  return null;
}
function getSdtContainerKey(sdt, containerSdt) {
  const metadata = getSdtContainerMetadata(sdt, containerSdt);
  if (!metadata) return null;
  if (metadata.type === "structuredContent") {
    if (metadata.scope !== "block") return null;
    if (!metadata.id) {
      return null;
    }
    return `structuredContent:${metadata.id}`;
  }
  if (metadata.type === "documentSection") {
    const sectionId = metadata.id ?? metadata.sdBlockId;
    if (!sectionId) {
      return null;
    }
    return `documentSection:${sectionId}`;
  }
  return null;
}
function applySdtContainerStyling(doc2, container, sdt, containerSdt, boundaryOptions) {
  let config = getSdtContainerConfig(sdt);
  if (!config && containerSdt) {
    config = getSdtContainerConfig(containerSdt);
  }
  if (!config) return;
  const isStart = boundaryOptions?.isStart ?? config.isStart;
  const isEnd = boundaryOptions?.isEnd ?? config.isEnd;
  container.classList.add(config.className);
  container.dataset.sdtContainerStart = String(isStart);
  container.dataset.sdtContainerEnd = String(isEnd);
  container.style.overflow = "visible";
  if (boundaryOptions?.widthOverride != null) {
    container.style.width = `${boundaryOptions.widthOverride}px`;
  }
  if (isStart) {
    const labelEl = doc2.createElement("div");
    labelEl.className = config.labelClassName;
    const labelText = doc2.createElement("span");
    labelText.textContent = config.labelText;
    labelEl.appendChild(labelText);
    container.appendChild(labelEl);
  }
}
const LIST_MARKER_GAP$2 = 8;
function renderListMarker(params2) {
  const { doc: doc2, lineEl, markerLayout, markerMeasure, indentLeftPx } = params2;
  const markerJustification = markerLayout?.justification ?? "left";
  const markerBoxWidth = (typeof markerLayout?.markerBoxWidthPx === "number" ? markerLayout.markerBoxWidthPx : void 0) ?? markerMeasure?.markerWidth ?? 0;
  const gutter = (typeof markerLayout?.gutterWidthPx === "number" ? markerLayout.gutterWidthPx : void 0) ?? markerMeasure?.gutterWidth ?? LIST_MARKER_GAP$2;
  const markerStartPos = markerJustification === "left" ? indentLeftPx : (typeof markerLayout?.markerX === "number" ? markerLayout.markerX : void 0) ?? indentLeftPx;
  const markerLeftPos = markerStartPos - markerBoxWidth;
  const lineContainer = doc2.createElement("div");
  lineContainer.style.position = "relative";
  lineContainer.style.width = "100%";
  const markerEl = doc2.createElement("span");
  markerEl.classList.add("superdoc-paragraph-marker");
  markerEl.textContent = markerLayout?.markerText ?? "";
  markerEl.style.display = "inline-block";
  markerEl.style.fontFamily = toCssFontFamily(markerLayout?.run?.fontFamily) ?? markerLayout?.run?.fontFamily ?? "";
  if (markerLayout?.run?.fontSize != null) {
    markerEl.style.fontSize = `${markerLayout.run.fontSize}px`;
  }
  markerEl.style.fontWeight = markerLayout?.run?.bold ? "bold" : "";
  markerEl.style.fontStyle = markerLayout?.run?.italic ? "italic" : "";
  if (markerLayout?.run?.color) {
    markerEl.style.color = markerLayout.run.color;
  }
  if (markerLayout?.run?.letterSpacing != null) {
    markerEl.style.letterSpacing = `${markerLayout.run.letterSpacing}px`;
  }
  markerEl.style.position = "absolute";
  markerEl.style.left = `${markerLeftPos}px`;
  markerEl.style.width = `${markerBoxWidth}px`;
  markerEl.style.textAlign = markerJustification;
  markerEl.style.paddingRight = `${gutter}px`;
  lineEl.style.paddingLeft = `${markerStartPos}px`;
  lineContainer.appendChild(markerEl);
  lineContainer.appendChild(lineEl);
  return lineContainer;
}
function applyTableCellLineIndentation(params2) {
  const {
    lineEl,
    line,
    indent,
    indentLeftPx,
    hasListMarkerLayout,
    lineIndex,
    localStartLine,
    suppressFirstLineIndent
  } = params2;
  const paraIndentLeft = indent?.left ?? 0;
  const paraIndentRight = indent?.right ?? 0;
  const firstLineOffset = suppressFirstLineIndent ? 0 : (indent?.firstLine ?? 0) - (indent?.hanging ?? 0);
  const isFirstLine = lineIndex === 0 && localStartLine === 0;
  const hasExplicitSegmentPositioning = line.segments?.some((seg) => seg.x !== void 0) ?? false;
  if (hasListMarkerLayout && indentLeftPx) {
    if (!hasExplicitSegmentPositioning) {
      lineEl.style.paddingLeft = `${indentLeftPx}px`;
    }
  } else {
    if (hasExplicitSegmentPositioning) {
      if (isFirstLine && firstLineOffset !== 0) {
        const effectiveLeftIndent = paraIndentLeft < 0 ? 0 : paraIndentLeft;
        const adjustedPadding = effectiveLeftIndent + firstLineOffset;
        if (adjustedPadding > 0) {
          lineEl.style.paddingLeft = `${adjustedPadding}px`;
        }
      }
    } else if (paraIndentLeft && paraIndentLeft > 0) {
      lineEl.style.paddingLeft = `${paraIndentLeft}px`;
    } else if (!isFirstLine && indent?.hanging && indent.hanging > 0 && (paraIndentLeft == null || paraIndentLeft >= 0)) {
      lineEl.style.paddingLeft = `${indent.hanging}px`;
    }
  }
  if (paraIndentRight && paraIndentRight > 0) {
    lineEl.style.paddingRight = `${paraIndentRight}px`;
  }
  if (isFirstLine && firstLineOffset && !hasExplicitSegmentPositioning) {
    lineEl.style.textIndent = `${firstLineOffset}px`;
  } else if (firstLineOffset && hasExplicitSegmentPositioning) {
    lineEl.style.textIndent = "0px";
  }
}
const applyInlineStyles = (el, styles) => {
  Object.entries(styles).forEach(([key2, value]) => {
    if (value != null && value !== "" && key2 in el.style) {
      el.style[key2] = String(value);
    }
  });
};
const EMBEDDED_TABLE_VERSION = "embedded-table";
const renderEmbeddedTable = (params2) => {
  const { doc: doc2, table, measure, context, renderLine, renderDrawingContent, applySdtDataset } = params2;
  const fragment = {
    kind: "table",
    blockId: table.id,
    fromRow: 0,
    toRow: table.rows.length,
    x: 0,
    y: 0,
    width: measure.totalWidth,
    height: measure.totalHeight
  };
  const blockLookup = /* @__PURE__ */ new Map([
    [
      table.id,
      {
        block: table,
        measure,
        version: EMBEDDED_TABLE_VERSION
      }
    ]
  ]);
  const applyFragmentFrame = (el, frag) => {
    el.style.left = `${frag.x}px`;
    el.style.top = `${frag.y}px`;
    el.style.width = `${frag.width}px`;
    el.dataset.blockId = frag.blockId;
  };
  return renderTableFragment({
    doc: doc2,
    fragment,
    context,
    blockLookup,
    renderLine,
    renderDrawingContent,
    applyFragmentFrame,
    applySdtDataset,
    applyStyles: applyInlineStyles
  });
};
function applyParagraphBordersAndShading(paraWrapper, block) {
  const borders = block.attrs?.borders;
  if (borders) {
    paraWrapper.style.boxSizing = "border-box";
    const sideStyles = {
      top: { width: "border-top-width", style: "border-top-style", color: "border-top-color" },
      bottom: { width: "border-bottom-width", style: "border-bottom-style", color: "border-bottom-color" },
      left: { width: "border-left-width", style: "border-left-style", color: "border-left-color" },
      right: { width: "border-right-width", style: "border-right-style", color: "border-right-color" }
    };
    ["top", "bottom", "left", "right"].forEach((side) => {
      const border = borders[side];
      if (!border) return;
      const styleValue = border.style ?? "solid";
      let widthValue = typeof border.width === "number" ? Math.max(0, border.width) : 1;
      if (styleValue === "none") {
        widthValue = 0;
      }
      const cssKeys = sideStyles[side];
      paraWrapper.style.setProperty(cssKeys.style, styleValue);
      paraWrapper.style.setProperty(cssKeys.width, `${widthValue}px`);
      if (border.color) {
        paraWrapper.style.setProperty(cssKeys.color, border.color);
      }
    });
  }
  const shadingFill = block.attrs?.shading?.fill;
  if (shadingFill) {
    paraWrapper.style.backgroundColor = shadingFill;
  }
}
const renderTableCell = (deps) => {
  const {
    doc: doc2,
    x,
    y: y2,
    rowHeight,
    cellMeasure,
    cell,
    borders,
    useDefaultBorder,
    renderLine,
    renderDrawingContent,
    context,
    applySdtDataset,
    tableSdt,
    tableIndent,
    fromLine,
    toLine
  } = deps;
  const attrs = cell?.attrs;
  const padding = attrs?.padding || { top: 2, left: 4, right: 4, bottom: 2 };
  const paddingLeft = padding.left ?? 4;
  const paddingTop = padding.top ?? 2;
  const paddingRight = padding.right ?? 4;
  const paddingBottom = padding.bottom ?? 2;
  const cellEl = doc2.createElement("div");
  cellEl.style.position = "absolute";
  cellEl.style.left = `${x}px`;
  cellEl.style.top = `${y2}px`;
  cellEl.style.width = `${cellMeasure.width}px`;
  cellEl.style.height = `${rowHeight}px`;
  cellEl.style.boxSizing = "border-box";
  cellEl.style.overflow = "hidden";
  cellEl.style.paddingLeft = `${paddingLeft}px`;
  cellEl.style.paddingTop = `${paddingTop}px`;
  cellEl.style.paddingRight = `${paddingRight}px`;
  cellEl.style.paddingBottom = `${paddingBottom}px`;
  if (borders) {
    applyCellBorders(cellEl, borders);
  } else if (useDefaultBorder) {
    cellEl.style.border = "1px solid rgba(0,0,0,0.6)";
  }
  if (cell?.attrs?.background) {
    cellEl.style.backgroundColor = cell.attrs.background;
  }
  const cellBlocks = cell?.blocks ?? (cell?.paragraph ? [cell.paragraph] : []);
  const blockMeasures = cellMeasure?.blocks ?? (cellMeasure?.paragraph ? [cellMeasure.paragraph] : []);
  const sdtContainerKeys = cellBlocks.map((block) => {
    if (block.kind !== "paragraph") {
      return null;
    }
    const attrs2 = block.attrs;
    return getSdtContainerKey(attrs2?.sdt, attrs2?.containerSdt);
  });
  const sdtBoundaries = sdtContainerKeys.map((key2, index2) => {
    if (!key2) return void 0;
    const prev = index2 > 0 ? sdtContainerKeys[index2 - 1] : null;
    const next = index2 < sdtContainerKeys.length - 1 ? sdtContainerKeys[index2 + 1] : null;
    return { isStart: key2 !== prev, isEnd: key2 !== next };
  });
  const tableSdtKey = tableSdt ? getSdtContainerKey(tableSdt, null) : null;
  const shouldApplySdtContainerStyling = (sdt, containerSdt, blockKey) => {
    const resolvedKey = blockKey ?? getSdtContainerKey(sdt, containerSdt);
    if (tableSdtKey && resolvedKey && tableSdtKey === resolvedKey) {
      return false;
    }
    if (tableSdt && (sdt === tableSdt || containerSdt === tableSdt)) {
      return false;
    }
    return Boolean(getSdtContainerConfig(sdt) || getSdtContainerConfig(containerSdt));
  };
  const hasSdtContainer = cellBlocks.some((block, index2) => {
    const attrs2 = block.attrs;
    const blockKey = sdtContainerKeys[index2] ?? null;
    return shouldApplySdtContainerStyling(attrs2?.sdt, attrs2?.containerSdt, blockKey);
  });
  if (hasSdtContainer) {
    cellEl.style.overflow = "visible";
  }
  if (cellBlocks.length > 0 && blockMeasures.length > 0) {
    const content = doc2.createElement("div");
    content.style.position = "relative";
    content.style.width = "100%";
    content.style.height = "100%";
    content.style.display = "flex";
    content.style.flexDirection = "column";
    if (cell?.attrs?.verticalAlign === "center") {
      content.style.justifyContent = "center";
    } else if (cell?.attrs?.verticalAlign === "bottom") {
      content.style.justifyContent = "flex-end";
    } else {
      content.style.justifyContent = "flex-start";
    }
    cellEl.appendChild(content);
    content.style.zIndex = "0";
    const blockLineCounts = [];
    for (let i = 0; i < Math.min(blockMeasures.length, cellBlocks.length); i++) {
      const bm = blockMeasures[i];
      if (bm.kind === "paragraph") {
        blockLineCounts.push(bm.lines?.length || 0);
      } else {
        blockLineCounts.push(0);
      }
    }
    const totalLines = blockLineCounts.reduce((a, b2) => a + b2, 0);
    const globalFromLine = fromLine ?? 0;
    const globalToLine = toLine === -1 || toLine === void 0 ? totalLines : toLine;
    const contentWidthPx = Math.max(0, cellMeasure.width - paddingLeft - paddingRight);
    const contentHeightPx = Math.max(0, rowHeight - paddingTop - paddingBottom);
    const paragraphTopById = /* @__PURE__ */ new Map();
    let flowCursorY = 0;
    const anchoredBlocks = [];
    const renderedLines = [];
    let cumulativeLineCount = 0;
    for (let i = 0; i < Math.min(blockMeasures.length, cellBlocks.length); i++) {
      const blockMeasure = blockMeasures[i];
      const block = cellBlocks[i];
      if (blockMeasure.kind === "table" && block?.kind === "table") {
        const tableMeasure = blockMeasure;
        const tableWrapper = doc2.createElement("div");
        tableWrapper.style.position = "relative";
        tableWrapper.style.width = "100%";
        tableWrapper.style.height = `${tableMeasure.totalHeight}px`;
        tableWrapper.style.boxSizing = "border-box";
        const tableEl = renderEmbeddedTable({
          doc: doc2,
          table: block,
          measure: tableMeasure,
          context: { ...context, section: "body" },
          renderLine,
          renderDrawingContent,
          applySdtDataset
        });
        tableWrapper.appendChild(tableEl);
        content.appendChild(tableWrapper);
        flowCursorY += tableMeasure.totalHeight;
        continue;
      }
      if (blockMeasure.kind === "image" && block?.kind === "image") {
        if (block.anchor?.isAnchored) {
          anchoredBlocks.push({ block, measure: blockMeasure });
          continue;
        }
        const imageWrapper = doc2.createElement("div");
        imageWrapper.style.position = "relative";
        imageWrapper.style.width = `${blockMeasure.width}px`;
        imageWrapper.style.height = `${blockMeasure.height}px`;
        imageWrapper.style.maxWidth = "100%";
        imageWrapper.style.boxSizing = "border-box";
        applySdtDataset(imageWrapper, block.attrs?.sdt);
        const imgEl = doc2.createElement("img");
        imgEl.classList.add("superdoc-table-image");
        if (block.src) {
          imgEl.src = block.src;
        }
        imgEl.alt = block.alt ?? "";
        imgEl.style.width = "100%";
        imgEl.style.height = "100%";
        imgEl.style.objectFit = block.objectFit ?? "contain";
        if (block.objectFit === "cover") {
          imgEl.style.objectPosition = "left top";
        }
        imgEl.style.display = "block";
        imageWrapper.appendChild(imgEl);
        content.appendChild(imageWrapper);
        flowCursorY += blockMeasure.height;
        continue;
      }
      if (blockMeasure.kind === "drawing" && block?.kind === "drawing") {
        if (block.anchor?.isAnchored) {
          anchoredBlocks.push({ block, measure: blockMeasure });
          continue;
        }
        const drawingWrapper = doc2.createElement("div");
        drawingWrapper.style.position = "relative";
        drawingWrapper.style.width = `${blockMeasure.width}px`;
        drawingWrapper.style.height = `${blockMeasure.height}px`;
        drawingWrapper.style.maxWidth = "100%";
        drawingWrapper.style.boxSizing = "border-box";
        applySdtDataset(drawingWrapper, block.attrs);
        const drawingInner = doc2.createElement("div");
        drawingInner.classList.add("superdoc-table-drawing");
        drawingInner.style.width = "100%";
        drawingInner.style.height = "100%";
        drawingInner.style.display = "flex";
        drawingInner.style.alignItems = "center";
        drawingInner.style.justifyContent = "center";
        drawingInner.style.overflow = "hidden";
        if (block.drawingKind === "image" && "src" in block && block.src) {
          const img = doc2.createElement("img");
          img.classList.add("superdoc-drawing-image");
          img.src = block.src;
          img.alt = block.alt ?? "";
          img.style.width = "100%";
          img.style.height = "100%";
          img.style.objectFit = block.objectFit ?? "contain";
          if (block.objectFit === "cover") {
            img.style.objectPosition = "left top";
          }
          drawingInner.appendChild(img);
        } else if (renderDrawingContent) {
          const drawingContent = renderDrawingContent(block);
          drawingContent.style.width = "100%";
          drawingContent.style.height = "100%";
          drawingInner.appendChild(drawingContent);
        } else {
          const placeholder = doc2.createElement("div");
          placeholder.style.width = "100%";
          placeholder.style.height = "100%";
          placeholder.style.background = "repeating-linear-gradient(45deg, rgba(15,23,42,0.1), rgba(15,23,42,0.1) 6px, rgba(15,23,42,0.2) 6px, rgba(15,23,42,0.2) 12px)";
          placeholder.style.border = "1px dashed rgba(15, 23, 42, 0.3)";
          drawingInner.appendChild(placeholder);
        }
        drawingWrapper.appendChild(drawingInner);
        content.appendChild(drawingWrapper);
        flowCursorY += blockMeasure.height;
        continue;
      }
      if (blockMeasure.kind === "paragraph" && block?.kind === "paragraph") {
        const paragraphMeasure = blockMeasure;
        const lines = paragraphMeasure.lines;
        const blockLineCount = lines?.length || 0;
        paragraphTopById.set(block.id, flowCursorY);
        const wordLayout = block.attrs?.wordLayout ?? null;
        const markerLayout = wordLayout?.marker;
        const markerMeasure = paragraphMeasure.marker;
        const indentLeftPx = markerMeasure?.indentLeft ?? wordLayout?.indentLeftPx ?? (block.attrs?.indent && typeof block.attrs.indent.left === "number" ? block.attrs.indent.left : 0);
        const suppressFirstLineIndent = block.attrs?.suppressFirstLineIndent === true;
        const blockStartGlobal = cumulativeLineCount;
        const blockEndGlobal = cumulativeLineCount + blockLineCount;
        if (blockEndGlobal <= globalFromLine) {
          cumulativeLineCount += blockLineCount;
          continue;
        }
        if (blockStartGlobal >= globalToLine) {
          cumulativeLineCount += blockLineCount;
          continue;
        }
        const localStartLine = Math.max(0, globalFromLine - blockStartGlobal);
        const localEndLine = Math.min(blockLineCount, globalToLine - blockStartGlobal);
        const paraWrapper = doc2.createElement("div");
        paraWrapper.style.position = "relative";
        paraWrapper.style.left = "0";
        paraWrapper.style.width = "100%";
        applySdtDataset(paraWrapper, block.attrs?.sdt);
        const sdtBoundary = sdtBoundaries[i];
        const blockKey = sdtContainerKeys[i] ?? null;
        if (shouldApplySdtContainerStyling(block.attrs?.sdt, block.attrs?.containerSdt, blockKey)) {
          applySdtContainerStyling(doc2, paraWrapper, block.attrs?.sdt, block.attrs?.containerSdt, sdtBoundary);
        }
        applyParagraphBordersAndShading(paraWrapper, block);
        applyParagraphBorderStyles(paraWrapper, block.attrs?.borders);
        applyParagraphShadingStyles(paraWrapper, block.attrs?.shading);
        let renderedHeight = 0;
        for (let lineIdx = localStartLine; lineIdx < localEndLine && lineIdx < lines.length; lineIdx++) {
          const line = lines[lineIdx];
          const isLastLine = lineIdx === lines.length - 1;
          const lineTop = flowCursorY + renderedHeight;
          const lineEl = renderLine(
            block,
            line,
            { ...context, section: "body" },
            lineIdx,
            isLastLine
          );
          lineEl.style.paddingLeft = "";
          lineEl.style.paddingRight = "";
          lineEl.style.textIndent = "";
          const shouldRenderMarker = markerLayout && markerMeasure && lineIdx === 0 && localStartLine === 0 && markerMeasure.markerWidth > 0;
          if (shouldRenderMarker) {
            const lineContainer = renderListMarker({
              doc: doc2,
              lineEl,
              markerLayout,
              markerMeasure,
              indentLeftPx
            });
            renderedLines.push({ el: lineContainer, top: lineTop, height: line.lineHeight });
            paraWrapper.appendChild(lineContainer);
          } else {
            applyTableCellLineIndentation({
              lineEl,
              line,
              indent: block.attrs?.indent,
              indentLeftPx,
              hasListMarkerLayout: Boolean(markerLayout),
              lineIndex: lineIdx,
              localStartLine,
              suppressFirstLineIndent
            });
            renderedLines.push({ el: lineEl, top: lineTop, height: line.lineHeight });
            paraWrapper.appendChild(lineEl);
          }
          renderedHeight += line.lineHeight;
        }
        const renderedEntireBlock = localStartLine === 0 && localEndLine >= blockLineCount;
        if (renderedEntireBlock && blockMeasure.totalHeight && blockMeasure.totalHeight > renderedHeight) {
          renderedHeight = blockMeasure.totalHeight;
        }
        content.appendChild(paraWrapper);
        if (renderedHeight > 0) {
          paraWrapper.style.height = `${renderedHeight}px`;
        }
        flowCursorY += renderedHeight;
        if (renderedEntireBlock) {
          const spacingAfter = block.attrs?.spacing?.after;
          if (typeof spacingAfter === "number" && spacingAfter > 0) {
            paraWrapper.style.marginBottom = `${spacingAfter}px`;
            flowCursorY += spacingAfter;
          }
        }
        cumulativeLineCount += blockLineCount;
      }
    }
    const verticalAlign = cell?.attrs?.verticalAlign;
    const remainingSpace = contentHeightPx - flowCursorY;
    const alignmentOffsetY = verticalAlign === "center" ? Math.max(0, remainingSpace / 2) : verticalAlign === "bottom" ? Math.max(0, remainingSpace) : 0;
    const wrapExclusions = [];
    for (const entry of anchoredBlocks) {
      const anchoredBlock = entry.block;
      const anchoredMeasure = entry.measure;
      const anchor = anchoredBlock.anchor;
      if (!anchor || !anchor.isAnchored) {
        continue;
      }
      const objectWidth = anchoredMeasure.width;
      const objectHeight = anchoredMeasure.height;
      const baseLeft = anchor.offsetH ?? 0;
      const indentOffset = typeof tableIndent === "number" && Number.isFinite(tableIndent) ? tableIndent : 0;
      const left2 = anchor.hRelativeFrom === "column" ? baseLeft - x - indentOffset : baseLeft;
      const top2 = anchor.offsetV ?? 0;
      const behindDoc = anchor.behindDoc === true || anchoredBlock.wrap?.type === "None" && anchoredBlock.wrap?.behindDoc;
      const zIndex = anchoredBlock.kind === "drawing" && typeof anchoredBlock.zIndex === "number" ? anchoredBlock.zIndex : behindDoc ? -1 : 1;
      const wrap = anchoredBlock.wrap;
      if (!behindDoc && wrap?.type === "Square") {
        const wrapText = wrap.wrapText ?? "bothSides";
        const distLeft = anchoredBlock.padding?.left ?? 0;
        const distRight = anchoredBlock.padding?.right ?? 0;
        const distTop = anchoredBlock.padding?.top ?? 0;
        const distBottom = anchoredBlock.padding?.bottom ?? 0;
        wrapExclusions.push({
          left: left2 - distLeft,
          right: left2 + objectWidth + distRight,
          top: top2 - distTop,
          bottom: top2 + objectHeight + distBottom,
          wrapText
        });
      }
      if (anchoredBlock.kind === "image") {
        const imageWrapper = doc2.createElement("div");
        imageWrapper.style.position = "absolute";
        imageWrapper.style.left = `${left2}px`;
        imageWrapper.style.top = `${top2}px`;
        imageWrapper.style.width = `${objectWidth}px`;
        imageWrapper.style.height = `${objectHeight}px`;
        imageWrapper.style.maxWidth = "100%";
        imageWrapper.style.boxSizing = "border-box";
        imageWrapper.style.zIndex = String(zIndex);
        applySdtDataset(imageWrapper, anchoredBlock.attrs?.sdt);
        const imgEl = doc2.createElement("img");
        imgEl.classList.add("superdoc-table-image");
        if (anchoredBlock.src) {
          imgEl.src = anchoredBlock.src;
        }
        imgEl.alt = anchoredBlock.alt ?? "";
        imgEl.style.width = "100%";
        imgEl.style.height = "100%";
        imgEl.style.objectFit = anchoredBlock.objectFit ?? "contain";
        if (anchoredBlock.objectFit === "cover") {
          imgEl.style.objectPosition = "left top";
        }
        imgEl.style.display = "block";
        imageWrapper.appendChild(imgEl);
        content.appendChild(imageWrapper);
      } else {
        const drawingWrapper = doc2.createElement("div");
        drawingWrapper.style.position = "absolute";
        drawingWrapper.style.left = `${left2}px`;
        drawingWrapper.style.top = `${top2}px`;
        drawingWrapper.style.width = `${objectWidth}px`;
        drawingWrapper.style.height = `${objectHeight}px`;
        drawingWrapper.style.maxWidth = "100%";
        drawingWrapper.style.boxSizing = "border-box";
        drawingWrapper.style.zIndex = String(zIndex);
        applySdtDataset(drawingWrapper, anchoredBlock.attrs);
        const drawingInner = doc2.createElement("div");
        drawingInner.classList.add("superdoc-table-drawing");
        drawingInner.style.width = "100%";
        drawingInner.style.height = "100%";
        drawingInner.style.display = "flex";
        drawingInner.style.alignItems = "center";
        drawingInner.style.justifyContent = "center";
        drawingInner.style.overflow = "hidden";
        if (anchoredBlock.drawingKind === "image" && "src" in anchoredBlock && anchoredBlock.src) {
          const img = doc2.createElement("img");
          img.classList.add("superdoc-drawing-image");
          img.src = anchoredBlock.src;
          img.alt = anchoredBlock.alt ?? "";
          img.style.width = "100%";
          img.style.height = "100%";
          img.style.objectFit = anchoredBlock.objectFit ?? "contain";
          if (anchoredBlock.objectFit === "cover") {
            img.style.objectPosition = "left top";
          }
          drawingInner.appendChild(img);
        } else if (renderDrawingContent) {
          const drawingContent = renderDrawingContent(anchoredBlock);
          drawingContent.style.width = "100%";
          drawingContent.style.height = "100%";
          drawingInner.appendChild(drawingContent);
        } else {
          const placeholder = doc2.createElement("div");
          placeholder.style.width = "100%";
          placeholder.style.height = "100%";
          placeholder.style.background = "repeating-linear-gradient(45deg, rgba(15,23,42,0.1), rgba(15,23,42,0.1) 6px, rgba(15,23,42,0.2) 6px, rgba(15,23,42,0.2) 12px)";
          placeholder.style.border = "1px dashed rgba(15, 23, 42, 0.3)";
          drawingInner.appendChild(placeholder);
        }
        drawingWrapper.appendChild(drawingInner);
        content.appendChild(drawingWrapper);
      }
    }
    applySquareWrapExclusionsToLines(renderedLines, wrapExclusions, contentWidthPx, alignmentOffsetY);
  }
  return { cellElement: cellEl };
};
const renderTableRow = (deps) => {
  const {
    doc: doc2,
    container,
    rowIndex,
    y: y2,
    rowMeasure,
    row,
    totalRows,
    tableBorders,
    columnWidths,
    allRowHeights,
    tableIndent,
    context,
    renderLine,
    renderDrawingContent,
    applySdtDataset,
    tableSdt,
    continuesFromPrev,
    continuesOnNext,
    partialRow
  } = deps;
  const calculateXPosition = (gridColumnStart) => {
    let x = 0;
    for (let i = 0; i < gridColumnStart && i < columnWidths.length; i++) {
      x += columnWidths[i];
    }
    return x;
  };
  const calculateRowspanHeight = (startRowIndex, rowSpan) => {
    let totalHeight = 0;
    for (let i = 0; i < rowSpan && startRowIndex + i < allRowHeights.length; i++) {
      totalHeight += allRowHeights[startRowIndex + i];
    }
    return totalHeight;
  };
  for (let cellIndex = 0; cellIndex < rowMeasure.cells.length; cellIndex += 1) {
    const cellMeasure = rowMeasure.cells[cellIndex];
    const cell = row?.cells?.[cellIndex];
    const x = cellMeasure.gridColumnStart != null ? calculateXPosition(cellMeasure.gridColumnStart) : cellIndex === 0 ? 0 : calculateXPosition(cellIndex);
    const cellBordersAttr = cell?.attrs?.borders;
    const hasBordersAttribute = cellBordersAttr !== void 0;
    const hasExplicitBorders = hasBordersAttribute && cellBordersAttr && (cellBordersAttr.top !== void 0 || cellBordersAttr.right !== void 0 || cellBordersAttr.bottom !== void 0 || cellBordersAttr.left !== void 0);
    const gridColIndex = cellMeasure.gridColumnStart ?? cellIndex;
    const totalCols = columnWidths.length;
    let resolvedBorders;
    if (hasBordersAttribute && !hasExplicitBorders) {
      resolvedBorders = void 0;
    } else if (hasExplicitBorders && tableBorders) {
      const isFirstRow = rowIndex === 0;
      const isLastRow = rowIndex === totalRows - 1;
      const isFirstCol = gridColIndex === 0;
      const isLastCol = gridColIndex === totalCols - 1;
      const treatAsFirstRow = isFirstRow || continuesFromPrev;
      const treatAsLastRow = isLastRow || continuesOnNext;
      resolvedBorders = {
        // For top: use cell's if defined, otherwise use table's top border for first row OR continuation
        top: cellBordersAttr.top ?? borderValueToSpec(treatAsFirstRow ? tableBorders.top : tableBorders.insideH),
        // For bottom: use cell's if defined, otherwise use table's bottom border for last row OR before continuation
        bottom: cellBordersAttr.bottom ?? borderValueToSpec(treatAsLastRow ? tableBorders.bottom : void 0),
        // For left: use cell's if defined, otherwise use table's left for first col
        left: cellBordersAttr.left ?? borderValueToSpec(isFirstCol ? tableBorders.left : tableBorders.insideV),
        // For right: use cell's if defined, otherwise use table's right for last col only
        right: cellBordersAttr.right ?? borderValueToSpec(isLastCol ? tableBorders.right : void 0)
      };
    } else if (hasExplicitBorders) {
      resolvedBorders = {
        top: cellBordersAttr.top,
        bottom: cellBordersAttr.bottom,
        left: cellBordersAttr.left,
        right: cellBordersAttr.right
      };
    } else if (tableBorders) {
      const isFirstRow = rowIndex === 0;
      const isLastRow = rowIndex === totalRows - 1;
      const treatAsFirstRow = isFirstRow || continuesFromPrev;
      const treatAsLastRow = isLastRow || continuesOnNext;
      const baseBorders = resolveTableCellBorders(tableBorders, rowIndex, gridColIndex, totalRows, totalCols);
      if (baseBorders) {
        resolvedBorders = {
          // If this is a continuation (continuesFromPrev), use table's top border
          top: treatAsFirstRow ? borderValueToSpec(tableBorders.top) : baseBorders.top,
          // If this continues on next (continuesOnNext), use table's bottom border
          bottom: treatAsLastRow ? borderValueToSpec(tableBorders.bottom) : baseBorders.bottom,
          left: baseBorders.left,
          right: baseBorders.right
        };
      } else {
        resolvedBorders = void 0;
      }
    } else {
      resolvedBorders = void 0;
    }
    const rowSpan = cellMeasure.rowSpan ?? 1;
    let cellHeight;
    if (partialRow) {
      cellHeight = partialRow.partialHeight;
    } else if (rowSpan > 1) {
      cellHeight = calculateRowspanHeight(rowIndex, rowSpan);
    } else {
      cellHeight = rowMeasure.height;
    }
    const fromLine = partialRow?.fromLineByCell?.[cellIndex];
    const toLine = partialRow?.toLineByCell?.[cellIndex];
    const { cellElement } = renderTableCell({
      doc: doc2,
      x,
      y: y2,
      rowHeight: cellHeight,
      cellMeasure,
      cell,
      borders: resolvedBorders,
      useDefaultBorder: false,
      renderLine,
      renderDrawingContent,
      context,
      applySdtDataset,
      tableSdt,
      fromLine,
      toLine,
      tableIndent
    });
    container.appendChild(cellElement);
  }
};
const renderTableFragment = (deps) => {
  const {
    doc: doc2,
    fragment,
    blockLookup,
    context,
    sdtBoundary,
    renderLine,
    renderDrawingContent,
    applyFragmentFrame,
    applySdtDataset,
    applyStyles: applyStyles2
  } = deps;
  if (!doc2) {
    console.error("DomPainter: document is not available");
    if (typeof document !== "undefined") {
      const placeholder = document.createElement("div");
      placeholder.classList.add(CLASS_NAMES$1.fragment, "superdoc-error-placeholder");
      placeholder.textContent = "[Document not available]";
      placeholder.style.border = "1px dashed red";
      placeholder.style.padding = "8px";
      return placeholder;
    }
    throw new Error("Document is required for table rendering");
  }
  const lookup = blockLookup.get(fragment.blockId);
  if (!lookup || lookup.block.kind !== "table" || lookup.measure.kind !== "table") {
    console.error(`DomPainter: missing table block for fragment ${fragment.blockId}`, {
      blockId: fragment.blockId,
      lookup: lookup ? { kind: lookup.block.kind } : null
    });
    const placeholder = doc2.createElement("div");
    placeholder.classList.add(CLASS_NAMES$1.fragment, "superdoc-error-placeholder");
    placeholder.textContent = "[Table rendering error]";
    placeholder.style.border = "1px dashed red";
    placeholder.style.padding = "8px";
    return placeholder;
  }
  const block = lookup.block;
  const measure = lookup.measure;
  const tableBorders = block.attrs?.borders;
  const tableIndentValue = block.attrs?.tableIndent?.width;
  const tableIndent = typeof tableIndentValue === "number" && Number.isFinite(tableIndentValue) ? tableIndentValue : 0;
  const container = doc2.createElement("div");
  container.classList.add(CLASS_NAMES$1.fragment);
  applyStyles2(container, fragmentStyles);
  applyFragmentFrame(container, fragment);
  container.style.height = `${fragment.height}px`;
  applySdtDataset(container, block.attrs?.sdt);
  applySdtContainerStyling(doc2, container, block.attrs?.sdt, block.attrs?.containerSdt, sdtBoundary);
  container.classList.add("superdoc-table-fragment");
  if (fragment.metadata?.columnBoundaries) {
    const columnCount = measure.columnWidths.length;
    const rowCount = block.rows.length;
    const boundarySegments = [];
    for (let i = 0; i < columnCount; i++) {
      boundarySegments.push([]);
    }
    let rowY = 0;
    for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {
      const rowMeasure = measure.rows[rowIndex];
      if (!rowMeasure) continue;
      const boundariesInRow = /* @__PURE__ */ new Set();
      for (const cellMeasure of rowMeasure.cells) {
        const startCol = cellMeasure.gridColumnStart ?? 0;
        const colSpan = cellMeasure.colSpan ?? 1;
        const endCol = startCol + colSpan;
        if (startCol > 0) {
          boundariesInRow.add(startCol);
        }
        if (endCol < columnCount) {
          boundariesInRow.add(endCol);
        }
      }
      for (const boundaryCol of boundariesInRow) {
        const segments = boundarySegments[boundaryCol];
        const lastSegment = segments[segments.length - 1];
        if (lastSegment && lastSegment.toRow === rowIndex) {
          lastSegment.toRow = rowIndex + 1;
          lastSegment.height += rowMeasure.height;
        } else {
          segments.push({
            fromRow: rowIndex,
            toRow: rowIndex + 1,
            y: rowY,
            height: rowMeasure.height
          });
        }
      }
      rowY += rowMeasure.height;
    }
    const metadata = {
      columns: fragment.metadata.columnBoundaries.map((boundary) => ({
        i: boundary.index,
        x: boundary.x,
        w: boundary.width,
        min: boundary.minWidth,
        r: boundary.resizable ? 1 : 0
      })),
      // Add segments for each column boundary (segments where resize handle should appear)
      segments: boundarySegments.map(
        (segs, colIndex) => segs.map((seg) => ({
          c: colIndex,
          // column index
          y: seg.y,
          // y position
          h: seg.height
          // height of segment
        }))
      )
    };
    container.setAttribute("data-table-boundaries", JSON.stringify(metadata));
  }
  if (block.id) {
    container.setAttribute("data-sd-block-id", block.id);
  }
  const borderCollapse = block.attrs?.borderCollapse || "collapse";
  if (borderCollapse === "separate" && block.attrs?.cellSpacing) {
    container.style.borderSpacing = `${block.attrs.cellSpacing}px`;
  }
  const allRowHeights = measure.rows.map((r2, idx) => {
    if (fragment.partialRow && fragment.partialRow.rowIndex === idx) {
      return fragment.partialRow.partialHeight;
    }
    return r2?.height ?? 0;
  });
  let y2 = 0;
  if (fragment.repeatHeaderCount && fragment.repeatHeaderCount > 0) {
    for (let r2 = 0; r2 < fragment.repeatHeaderCount; r2 += 1) {
      const rowMeasure = measure.rows[r2];
      if (!rowMeasure) break;
      renderTableRow({
        doc: doc2,
        container,
        rowIndex: r2,
        y: y2,
        rowMeasure,
        row: block.rows[r2],
        totalRows: block.rows.length,
        tableBorders,
        columnWidths: measure.columnWidths,
        allRowHeights,
        tableIndent,
        context,
        renderLine,
        renderDrawingContent,
        applySdtDataset,
        tableSdt: block.attrs?.sdt ?? null,
        // Headers are always rendered as-is (no border suppression)
        continuesFromPrev: false,
        continuesOnNext: false
      });
      y2 += rowMeasure.height;
    }
  }
  for (let r2 = fragment.fromRow; r2 < fragment.toRow; r2 += 1) {
    const rowMeasure = measure.rows[r2];
    if (!rowMeasure) break;
    const isFirstRenderedBodyRow = r2 === fragment.fromRow;
    const isLastRenderedBodyRow = r2 === fragment.toRow - 1;
    const isPartialRow = fragment.partialRow && fragment.partialRow.rowIndex === r2;
    const partialRowData = isPartialRow ? fragment.partialRow : void 0;
    const actualRowHeight = partialRowData ? partialRowData.partialHeight : rowMeasure.height;
    renderTableRow({
      doc: doc2,
      container,
      rowIndex: r2,
      y: y2,
      rowMeasure,
      row: block.rows[r2],
      totalRows: block.rows.length,
      tableBorders,
      columnWidths: measure.columnWidths,
      allRowHeights,
      tableIndent,
      context,
      renderLine,
      renderDrawingContent,
      applySdtDataset,
      tableSdt: block.attrs?.sdt ?? null,
      // Draw top border if table continues from previous fragment (MS Word behavior)
      continuesFromPrev: isFirstRenderedBodyRow && fragment.continuesFromPrev === true,
      // Draw bottom border if table continues on next fragment (MS Word behavior)
      continuesOnNext: isLastRenderedBodyRow && fragment.continuesOnNext === true,
      // Pass partial row data for mid-row splits
      partialRow: partialRowData
    });
    y2 += actualRowHeight;
  }
  return container;
};
const isDevelopment = () => {
  if (typeof vue.process$1 !== "undefined" && typeof vue.process$1.env !== "undefined") {
    return vue.process$1.env.NODE_ENV === "development";
  }
  return false;
};
class ValidationStatsCollector {
  constructor() {
    this.stats = {
      totalSpans: 0,
      validSpans: 0,
      missingPmStart: 0,
      missingPmEnd: 0,
      missingBoth: 0
    };
  }
  record(hasPmStart, hasPmEnd) {
    this.stats.totalSpans++;
    if (hasPmStart && hasPmEnd) {
      this.stats.validSpans++;
    } else if (!hasPmStart && !hasPmEnd) {
      this.stats.missingBoth++;
    } else if (!hasPmStart) {
      this.stats.missingPmStart++;
    } else {
      this.stats.missingPmEnd++;
    }
  }
  getStats() {
    return { ...this.stats };
  }
  reset() {
    this.stats = {
      totalSpans: 0,
      validSpans: 0,
      missingPmStart: 0,
      missingPmEnd: 0,
      missingBoth: 0
    };
  }
  getCoveragePercent() {
    if (this.stats.totalSpans === 0) return 100;
    return this.stats.validSpans / this.stats.totalSpans * 100;
  }
  logSummary() {
    if (!isDevelopment()) return;
    const coverage = this.getCoveragePercent();
    const s = this.stats;
    if (coverage < 100) {
      console.warn("[PmPositionValidation] PM position coverage:", {
        coverage: `${coverage.toFixed(1)}%`,
        totalSpans: s.totalSpans,
        validSpans: s.validSpans,
        missingPmStart: s.missingPmStart,
        missingPmEnd: s.missingPmEnd,
        missingBoth: s.missingBoth
      });
    }
  }
}
const globalValidationStats = new ValidationStatsCollector();
function assertPmPositions(run, context) {
  const hasPmStart = run.pmStart != null;
  const hasPmEnd = run.pmEnd != null;
  globalValidationStats.record(hasPmStart, hasPmEnd);
  if (!isDevelopment()) return;
  if (!hasPmStart || !hasPmEnd) {
    const textPreview = run.text ? run.text.substring(0, 20) + (run.text.length > 20 ? "..." : "") : "(no text)";
    console.warn(`[PmPositionValidation] Missing PM positions in ${context}:`, {
      hasPmStart,
      hasPmEnd,
      textPreview,
      fallback: "Will use PM DOM coordinates for cursor positioning"
    });
  }
}
function assertFragmentPmPositions(fragment, _context) {
  const hasPmStart = fragment.pmStart != null;
  const hasPmEnd = fragment.pmEnd != null;
  globalValidationStats.record(hasPmStart, hasPmEnd);
}
const DEFAULT_PPI = 96;
const DEFAULT_RULER_HEIGHT = 25;
const TICK_SPACING_PX = DEFAULT_PPI / 8;
function generateRulerDefinition(config) {
  const ppi = config.ppi ?? DEFAULT_PPI;
  const heightPx = config.heightPx ?? DEFAULT_RULER_HEIGHT;
  const { pageSize, pageMargins } = config;
  if (!Number.isFinite(ppi) || ppi <= 0) {
    throw new Error(`Invalid PPI: ${ppi}. Must be a positive finite number.`);
  }
  if (!Number.isFinite(pageSize.width) || pageSize.width <= 0) {
    throw new Error(`Invalid page width: ${pageSize.width}. Must be a positive finite number.`);
  }
  if (!Number.isFinite(pageSize.height) || pageSize.height <= 0) {
    throw new Error(`Invalid page height: ${pageSize.height}. Must be a positive finite number.`);
  }
  if (!Number.isFinite(pageMargins.left) || pageMargins.left < 0) {
    throw new Error(`Invalid left margin: ${pageMargins.left}. Must be a non-negative finite number.`);
  }
  if (!Number.isFinite(pageMargins.right) || pageMargins.right < 0) {
    throw new Error(`Invalid right margin: ${pageMargins.right}. Must be a non-negative finite number.`);
  }
  if (pageMargins.left + pageMargins.right >= pageSize.width) {
    throw new Error(
      `Invalid margins: left (${pageMargins.left}) + right (${pageMargins.right}) must be less than page width (${pageSize.width}).`
    );
  }
  const widthPx = pageSize.width * ppi;
  const ticks = [];
  let currentX = 0;
  for (let inch = 0; inch < pageSize.width; inch++) {
    const remaining = pageSize.width - inch;
    ticks.push({
      size: "main",
      height: "20%",
      label: inch,
      x: currentX
    });
    currentX += TICK_SPACING_PX;
    for (let i = 0; i < 3; i++) {
      ticks.push({
        size: "eighth",
        height: "10%",
        x: currentX
      });
      currentX += TICK_SPACING_PX;
    }
    ticks.push({
      size: "half",
      height: "40%",
      x: currentX
    });
    currentX += TICK_SPACING_PX;
    if (remaining <= 0.5) break;
    for (let i = 0; i < 3; i++) {
      ticks.push({
        size: "eighth",
        height: "10%",
        x: currentX
      });
      currentX += TICK_SPACING_PX;
    }
  }
  return {
    widthPx,
    heightPx,
    ticks,
    leftMarginPx: pageMargins.left * ppi,
    rightMarginPx: widthPx - pageMargins.right * ppi,
    pageWidthInches: pageSize.width
  };
}
function calculateMarginFromHandle(handleX, side, pageWidthPx, ppi = DEFAULT_PPI) {
  if (side === "left") {
    return handleX / ppi;
  } else {
    return (pageWidthPx - handleX) / ppi;
  }
}
function clampHandlePosition(handleX, side, otherHandleX, pageWidthPx, minContentWidthPx = 200) {
  if (!Number.isFinite(handleX)) {
    throw new Error(`Invalid handleX: ${handleX}. Must be a finite number.`);
  }
  if (!Number.isFinite(otherHandleX)) {
    throw new Error(`Invalid otherHandleX: ${otherHandleX}. Must be a finite number.`);
  }
  if (!Number.isFinite(pageWidthPx)) {
    throw new Error(`Invalid pageWidthPx: ${pageWidthPx}. Must be a finite number.`);
  }
  if (!Number.isFinite(minContentWidthPx)) {
    throw new Error(`Invalid minContentWidthPx: ${minContentWidthPx}. Must be a finite number.`);
  }
  if (side === "left") {
    const min2 = 0;
    const max2 = otherHandleX - minContentWidthPx;
    return Math.max(min2, Math.min(max2, handleX));
  } else {
    const min2 = otherHandleX + minContentWidthPx;
    const max2 = pageWidthPx;
    return Math.max(min2, Math.min(max2, handleX));
  }
}
function generateRulerDefinitionFromPx(config) {
  const ppi = config.ppi ?? DEFAULT_PPI;
  const heightPx = config.heightPx ?? DEFAULT_RULER_HEIGHT;
  const { pageWidthPx, leftMarginPx, rightMarginPx } = config;
  if (!Number.isFinite(ppi) || ppi <= 0) {
    throw new Error(`Invalid PPI: ${ppi}. Must be a positive finite number.`);
  }
  if (!Number.isFinite(pageWidthPx) || pageWidthPx <= 0) {
    throw new Error(`Invalid page width: ${pageWidthPx}px. Must be a positive finite number.`);
  }
  if (!Number.isFinite(config.pageHeightPx) || config.pageHeightPx <= 0) {
    throw new Error(`Invalid page height: ${config.pageHeightPx}px. Must be a positive finite number.`);
  }
  if (!Number.isFinite(leftMarginPx) || leftMarginPx < 0) {
    throw new Error(`Invalid left margin: ${leftMarginPx}px. Must be a non-negative finite number.`);
  }
  if (!Number.isFinite(rightMarginPx) || rightMarginPx < 0) {
    throw new Error(`Invalid right margin: ${rightMarginPx}px. Must be a non-negative finite number.`);
  }
  if (leftMarginPx + rightMarginPx >= pageWidthPx) {
    throw new Error(
      `Invalid margins: left (${leftMarginPx}px) + right (${rightMarginPx}px) must be less than page width (${pageWidthPx}px).`
    );
  }
  const pageWidthInches = pageWidthPx / ppi;
  const ticks = [];
  let currentX = 0;
  for (let inch = 0; inch < pageWidthInches; inch++) {
    const remaining = pageWidthInches - inch;
    ticks.push({
      size: "main",
      height: "20%",
      label: inch,
      x: currentX
    });
    currentX += TICK_SPACING_PX;
    for (let i = 0; i < 3; i++) {
      ticks.push({
        size: "eighth",
        height: "10%",
        x: currentX
      });
      currentX += TICK_SPACING_PX;
    }
    ticks.push({
      size: "half",
      height: "40%",
      x: currentX
    });
    currentX += TICK_SPACING_PX;
    if (remaining <= 0.5) break;
    for (let i = 0; i < 3; i++) {
      ticks.push({
        size: "eighth",
        height: "10%",
        x: currentX
      });
      currentX += TICK_SPACING_PX;
    }
  }
  return {
    widthPx: pageWidthPx,
    heightPx,
    ticks,
    leftMarginPx,
    rightMarginPx: pageWidthPx - rightMarginPx,
    pageWidthInches
  };
}
const RULER_CLASS_NAMES = {
  /** Main ruler container */
  ruler: "superdoc-ruler",
  /** Tick mark element */
  tick: "superdoc-ruler-tick",
  /** Main (inch) tick */
  tickMain: "superdoc-ruler-tick--main",
  /** Half-inch tick */
  tickHalf: "superdoc-ruler-tick--half",
  /** Eighth-inch tick */
  tickEighth: "superdoc-ruler-tick--eighth",
  /** Inch label number */
  label: "superdoc-ruler-label",
  /** Margin handle */
  handle: "superdoc-ruler-handle",
  /** Left margin handle */
  handleLeft: "superdoc-ruler-handle--left",
  /** Right margin handle */
  handleRight: "superdoc-ruler-handle--right",
  /** Vertical indicator line during drag */
  indicator: "superdoc-ruler-indicator"
};
function createRulerElement(options) {
  const { definition, doc: doc2, interactive = false } = options;
  if (!Number.isFinite(definition.widthPx) || definition.widthPx <= 0) {
    console.warn(`[createRulerElement] Invalid ruler width: ${definition.widthPx}px. Using minimum width of 1px.`);
    definition.widthPx = Math.max(1, definition.widthPx || 1);
  }
  if (!definition.ticks || definition.ticks.length === 0) {
    console.warn("[createRulerElement] Ruler definition has no ticks. Ruler will be empty.");
  }
  const ruler = doc2.createElement("div");
  ruler.className = RULER_CLASS_NAMES.ruler;
  ruler.style.cssText = `
    position: relative;
    width: ${definition.widthPx}px;
    height: ${definition.heightPx}px;
    display: flex;
    align-items: flex-end;
    box-sizing: border-box;
    user-select: none;
    pointer-events: ${interactive ? "auto" : "none"};
  `;
  for (const tick of definition.ticks) {
    const tickEl = createTickElement(tick, doc2);
    ruler.appendChild(tickEl);
  }
  if (interactive) {
    const leftHandle = createHandleElement("left", definition.leftMarginPx, doc2, options);
    const rightHandle = createHandleElement("right", definition.rightMarginPx, doc2, options);
    ruler.appendChild(leftHandle);
    ruler.appendChild(rightHandle);
  }
  return ruler;
}
function createTickElement(tick, doc2) {
  const el = doc2.createElement("div");
  const sizeClass = tick.size === "main" ? RULER_CLASS_NAMES.tickMain : tick.size === "half" ? RULER_CLASS_NAMES.tickHalf : RULER_CLASS_NAMES.tickEighth;
  el.className = `${RULER_CLASS_NAMES.tick} ${sizeClass}`;
  el.style.cssText = `
    position: absolute;
    left: ${tick.x}px;
    bottom: 0;
    width: 1px;
    height: ${tick.height};
    background-color: #666;
    pointer-events: none;
  `;
  if (tick.label !== void 0) {
    const label = doc2.createElement("span");
    label.className = RULER_CLASS_NAMES.label;
    label.textContent = String(tick.label);
    label.style.cssText = `
      position: absolute;
      top: -16px;
      left: -2px;
      font-size: 10px;
      color: #666;
      pointer-events: none;
      user-select: none;
    `;
    el.appendChild(label);
  }
  return el;
}
function createHandleElement(side, x, doc2, options) {
  const handle = doc2.createElement("div");
  const sideClass = side === "left" ? RULER_CLASS_NAMES.handleLeft : RULER_CLASS_NAMES.handleRight;
  handle.className = `${RULER_CLASS_NAMES.handle} ${sideClass}`;
  handle.dataset.side = side;
  handle.style.cssText = `
    position: absolute;
    left: ${x}px;
    top: 0;
    width: 5px;
    height: 20px;
    margin-left: -2px;
    background-color: #ccc;
    border-radius: 4px 4px 0 0;
    cursor: grab;
    transition: background-color 150ms ease;
    z-index: 10;
  `;
  handle.addEventListener("mouseenter", () => {
    if (!handle.dataset.dragging) {
      handle.style.backgroundColor = "rgba(37, 99, 235, 0.4)";
    }
  });
  handle.addEventListener("mouseleave", () => {
    if (!handle.dataset.dragging) {
      handle.style.backgroundColor = "#ccc";
    }
  });
  if (options.onDragStart || options.onDrag || options.onDragEnd) {
    setupHandleDrag(handle, side, options);
  }
  return handle;
}
function setupHandleDrag(handle, side, options) {
  let offsetX = 0;
  const onPointerDown = (event) => {
    event.preventDefault();
    handle.dataset.dragging = "true";
    handle.style.backgroundColor = "rgba(37, 99, 235, 0.4)";
    handle.style.cursor = "grabbing";
    const rect = handle.getBoundingClientRect();
    offsetX = event.clientX - rect.left - rect.width / 2;
    handle.setPointerCapture(event.pointerId);
    options.onDragStart?.(side, event);
  };
  const onPointerMove = (event) => {
    if (handle.dataset.dragging !== "true") return;
    const ruler = handle.parentElement;
    if (!ruler) return;
    const rulerRect = ruler.getBoundingClientRect();
    const newX = event.clientX - rulerRect.left - offsetX;
    options.onDrag?.(side, newX, event);
  };
  const onPointerUp = (event) => {
    if (handle.dataset.dragging !== "true") return;
    handle.dataset.dragging = "";
    handle.style.backgroundColor = "#ccc";
    handle.style.cursor = "grab";
    handle.releasePointerCapture(event.pointerId);
    const ruler = handle.parentElement;
    if (!ruler) return;
    const rulerRect = ruler.getBoundingClientRect();
    const finalX = event.clientX - rulerRect.left - offsetX;
    options.onDragEnd?.(side, finalX, event);
  };
  handle.addEventListener("pointerdown", onPointerDown);
  handle.addEventListener("pointermove", onPointerMove);
  handle.addEventListener("pointerup", onPointerUp);
  handle.addEventListener("pointercancel", onPointerUp);
}
const RULER_STYLES = `
/* Ruler container */
.${RULER_CLASS_NAMES.ruler} {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background-color: transparent;
}

/* Tick marks base styling */
.${RULER_CLASS_NAMES.tick} {
  flex-shrink: 0;
}

/* Handle hover and active states */
.${RULER_CLASS_NAMES.handle}:hover {
  background-color: rgba(37, 99, 235, 0.4) !important;
}

.${RULER_CLASS_NAMES.handle}:active,
.${RULER_CLASS_NAMES.handle}[data-dragging="true"] {
  background-color: rgba(37, 99, 235, 0.6) !important;
  cursor: grabbing !important;
}

/* Vertical indicator animation */
.${RULER_CLASS_NAMES.indicator} {
  transition: left 16ms linear;
}

/* Print mode: hide rulers */
@media print {
  .${RULER_CLASS_NAMES.ruler} {
    display: none !important;
  }
}

/* High contrast mode support */
@media (prefers-contrast: high) {
  .${RULER_CLASS_NAMES.tick} {
    background-color: #000 !important;
  }

  .${RULER_CLASS_NAMES.label} {
    color: #000 !important;
  }

  .${RULER_CLASS_NAMES.handle} {
    background-color: #666 !important;
    border: 1px solid #000;
  }

  .${RULER_CLASS_NAMES.handle}:hover,
  .${RULER_CLASS_NAMES.handle}:active {
    background-color: #0066cc !important;
  }
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {
  .${RULER_CLASS_NAMES.handle} {
    transition: none !important;
  }

  .${RULER_CLASS_NAMES.indicator} {
    transition: none !important;
  }
}
`;
let rulerStylesInjected = false;
function ensureRulerStyles(doc2) {
  if (rulerStylesInjected || !doc2) return;
  const styleEl = doc2.createElement("style");
  styleEl.setAttribute("data-superdoc-ruler-styles", "true");
  styleEl.textContent = RULER_STYLES;
  doc2.head?.appendChild(styleEl);
  rulerStylesInjected = true;
}
const hashParagraphBorder$1 = (border) => {
  const parts = [];
  if (border.style !== void 0) parts.push(`s:${border.style}`);
  if (border.width !== void 0) parts.push(`w:${border.width}`);
  if (border.color !== void 0) parts.push(`c:${border.color}`);
  if (border.space !== void 0) parts.push(`sp:${border.space}`);
  return parts.join(",");
};
const hashParagraphBorders$1 = (borders) => {
  const parts = [];
  if (borders.top) parts.push(`t:[${hashParagraphBorder$1(borders.top)}]`);
  if (borders.right) parts.push(`r:[${hashParagraphBorder$1(borders.right)}]`);
  if (borders.bottom) parts.push(`b:[${hashParagraphBorder$1(borders.bottom)}]`);
  if (borders.left) parts.push(`l:[${hashParagraphBorder$1(borders.left)}]`);
  return parts.join(";");
};
const isNoneBorder$1 = (value) => {
  return typeof value === "object" && value !== null && "none" in value && value.none === true;
};
const isBorderSpec$1 = (value) => {
  return typeof value === "object" && value !== null && !("none" in value);
};
const hashBorderSpec$1 = (border) => {
  const parts = [];
  if (border.style !== void 0) parts.push(`s:${border.style}`);
  if (border.width !== void 0) parts.push(`w:${border.width}`);
  if (border.color !== void 0) parts.push(`c:${border.color}`);
  if (border.space !== void 0) parts.push(`sp:${border.space}`);
  return parts.join(",");
};
const hashTableBorderValue$1 = (borderValue) => {
  if (borderValue === void 0) return "";
  if (borderValue === null) return "null";
  if (isNoneBorder$1(borderValue)) return "none";
  if (isBorderSpec$1(borderValue)) {
    return hashBorderSpec$1(borderValue);
  }
  return "";
};
const hashTableBorders$1 = (borders) => {
  if (!borders) return "";
  const parts = [];
  if (borders.top !== void 0) parts.push(`t:[${hashTableBorderValue$1(borders.top)}]`);
  if (borders.right !== void 0) parts.push(`r:[${hashTableBorderValue$1(borders.right)}]`);
  if (borders.bottom !== void 0) parts.push(`b:[${hashTableBorderValue$1(borders.bottom)}]`);
  if (borders.left !== void 0) parts.push(`l:[${hashTableBorderValue$1(borders.left)}]`);
  if (borders.insideH !== void 0) parts.push(`ih:[${hashTableBorderValue$1(borders.insideH)}]`);
  if (borders.insideV !== void 0) parts.push(`iv:[${hashTableBorderValue$1(borders.insideV)}]`);
  return parts.join(";");
};
const hashCellBorders$1 = (borders) => {
  if (!borders) return "";
  const parts = [];
  if (borders.top) parts.push(`t:[${hashBorderSpec$1(borders.top)}]`);
  if (borders.right) parts.push(`r:[${hashBorderSpec$1(borders.right)}]`);
  if (borders.bottom) parts.push(`b:[${hashBorderSpec$1(borders.bottom)}]`);
  if (borders.left) parts.push(`l:[${hashBorderSpec$1(borders.left)}]`);
  return parts.join(";");
};
const hasStringProp = (run, prop) => {
  return prop in run && typeof run[prop] === "string";
};
const hasNumberProp = (run, prop) => {
  return prop in run && typeof run[prop] === "number";
};
const hasBooleanProp = (run, prop) => {
  return prop in run && typeof run[prop] === "boolean";
};
const getRunStringProp = (run, prop) => {
  if (hasStringProp(run, prop)) {
    return run[prop];
  }
  return "";
};
const getRunNumberProp = (run, prop) => {
  if (hasNumberProp(run, prop)) {
    return run[prop];
  }
  return 0;
};
const getRunBooleanProp = (run, prop) => {
  if (hasBooleanProp(run, prop)) {
    return run[prop];
  }
  return false;
};
const getRunUnderlineStyle = (run) => {
  if ("underline" in run && typeof run.underline === "boolean") {
    return run.underline ? "single" : "";
  }
  if ("underline" in run && run.underline && typeof run.underline === "object") {
    return run.underline.style ?? "";
  }
  return "";
};
const getRunUnderlineColor = (run) => {
  if ("underline" in run && run.underline && typeof run.underline === "object") {
    return run.underline.color ?? "";
  }
  return "";
};
function isMinimalWordLayout(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const obj = value;
  if (obj.marker !== void 0) {
    if (typeof obj.marker !== "object" || obj.marker === null) {
      return false;
    }
    const marker = obj.marker;
    if (marker.markerText !== void 0 && typeof marker.markerText !== "string") {
      return false;
    }
    if (marker.markerX !== void 0 && typeof marker.markerX !== "number") {
      return false;
    }
    if (marker.textStartX !== void 0 && typeof marker.textStartX !== "number") {
      return false;
    }
  }
  if (obj.indentLeftPx !== void 0) {
    if (typeof obj.indentLeftPx !== "number") {
      return false;
    }
  }
  if (obj.firstLineIndentMode !== void 0) {
    if (typeof obj.firstLineIndentMode !== "boolean") {
      return false;
    }
  }
  if (obj.textStartPx !== void 0) {
    if (typeof obj.textStartPx !== "number") {
      return false;
    }
  }
  if (obj.tabsPx !== void 0) {
    if (!Array.isArray(obj.tabsPx)) {
      return false;
    }
    for (const tab of obj.tabsPx) {
      if (typeof tab !== "number") {
        return false;
      }
    }
  }
  return true;
}
const LIST_MARKER_GAP$1 = 8;
const DEFAULT_TAB_INTERVAL_PX$1 = 48;
const DEFAULT_PAGE_HEIGHT_PX = 1056;
const DEFAULT_VIRTUALIZED_PAGE_GAP$1 = 72;
const COMMENT_EXTERNAL_COLOR = "#B1124B";
const COMMENT_INTERNAL_COLOR = "#078383";
const COMMENT_INACTIVE_ALPHA = "40";
const COMMENT_ACTIVE_ALPHA = "66";
const LINK_DATASET_KEYS = {
  blocked: "linkBlocked",
  docLocation: "linkDocLocation",
  history: "linkHistory",
  rId: "linkRid",
  truncated: "linkTooltipTruncated"
};
const MAX_HREF_LENGTH = 2048;
const SAFE_ANCHOR_PATTERN = /^[A-Za-z0-9._-]+$/;
const MAX_DATA_URL_LENGTH = 10 * 1024 * 1024;
const VALID_IMAGE_DATA_URL = /^data:image\/(png|jpeg|jpg|gif|svg\+xml|webp|bmp|ico|tiff?);base64,/i;
const MAX_RESIZE_MULTIPLIER = 3;
const FALLBACK_MAX_DIMENSION = 1e3;
const MIN_IMAGE_DIMENSION = 20;
const AMBIGUOUS_LINK_PATTERNS = /^(click here|read more|more|link|here|this|download|view)$/i;
const TRACK_CHANGE_BASE_CLASS = {
  insert: "track-insert-dec",
  delete: "track-delete-dec",
  format: "track-format-dec"
};
const TRACK_CHANGE_MODIFIER_CLASS = {
  insert: {
    review: "highlighted",
    original: "hidden",
    final: "normal",
    off: void 0
  },
  delete: {
    review: "highlighted",
    original: "normal",
    final: "hidden",
    off: void 0
  },
  format: {
    review: "highlighted",
    original: "before",
    final: "normal",
    off: void 0
  }
};
function sanitizeUrl(href) {
  if (typeof href !== "string") return null;
  const sanitized = sanitizeHref(href);
  return sanitized?.href ?? null;
}
const LINK_TARGET_SET = /* @__PURE__ */ new Set(["_blank", "_self", "_parent", "_top"]);
const normalizeAnchor = (value) => {
  if (typeof value !== "string") return null;
  const trimmed = value.trim();
  if (!trimmed) return null;
  const anchor = trimmed.startsWith("#") ? trimmed.slice(1) : trimmed;
  if (!SAFE_ANCHOR_PATTERN.test(anchor)) {
    return null;
  }
  return `#${anchor}`;
};
const isValidSafeFragment = (fragment) => {
  return SAFE_ANCHOR_PATTERN.test(fragment);
};
const encodeFragment = (fragment) => {
  try {
    return encodeURIComponent(fragment);
  } catch {
    return null;
  }
};
const appendDocLocation = (href, docLocation) => {
  if (!docLocation?.trim()) return href;
  const fragment = docLocation.trim();
  if (href?.includes("#")) return href;
  const encoded = isValidSafeFragment(fragment) ? fragment : encodeFragment(fragment);
  if (!encoded) return href;
  return href ? `${href}#${encoded}` : `#${encoded}`;
};
const buildLinkDataset = (link) => {
  const dataset = {};
  if (link.version === 2) {
    if (link.rId) dataset[LINK_DATASET_KEYS.rId] = link.rId;
    if (link.docLocation) dataset[LINK_DATASET_KEYS.docLocation] = link.docLocation;
    if (typeof link.history === "boolean") dataset[LINK_DATASET_KEYS.history] = String(link.history);
  }
  return dataset;
};
const resolveLinkTarget = (link, sanitized) => {
  if (link.target && LINK_TARGET_SET.has(link.target)) {
    return link.target;
  }
  if (sanitized && (sanitized.protocol === "http" || sanitized.protocol === "https")) {
    return "_blank";
  }
  return void 0;
};
const resolveLinkRel = (link, target) => {
  const relValues = /* @__PURE__ */ new Set();
  if (typeof link.rel === "string" && link.rel.trim()) {
    link.rel.trim().split(/\s+/).forEach((value) => {
      if (value) relValues.add(value);
    });
  }
  if (target === "_blank") {
    relValues.add("noopener");
    relValues.add("noreferrer");
  }
  if (relValues.size === 0) {
    return void 0;
  }
  return Array.from(relValues).join(" ");
};
const applyLinkDataset = (element, dataset) => {
  if (!dataset) return;
  Object.entries(dataset).forEach(([key2, value]) => {
    if (value != null) {
      element.dataset[key2] = value;
    }
  });
};
class DomPainter {
  constructor(blocks, measures, options = {}) {
    this.mount = null;
    this.doc = null;
    this.pageStates = [];
    this.currentLayout = null;
    this.changedBlocks = /* @__PURE__ */ new Set();
    this.totalPages = 0;
    this.linkIdCounter = 0;
    this.pendingTooltips = /* @__PURE__ */ new WeakMap();
    this.pageGap = 24;
    this.virtualEnabled = false;
    this.virtualWindow = 5;
    this.virtualOverscan = 0;
    this.virtualGap = DEFAULT_VIRTUALIZED_PAGE_GAP$1;
    this.virtualPaddingTop = null;
    this.topSpacerEl = null;
    this.bottomSpacerEl = null;
    this.virtualGapSpacers = [];
    this.virtualPinnedPages = [];
    this.virtualMountedKey = "";
    this.pageIndexToState = /* @__PURE__ */ new Map();
    this.virtualHeights = [];
    this.virtualOffsets = [];
    this.virtualStart = 0;
    this.virtualEnd = -1;
    this.layoutVersion = 0;
    this.layoutEpoch = 0;
    this.processedLayoutVersion = -1;
    this.currentMapping = null;
    this.onScrollHandler = null;
    this.onWindowScrollHandler = null;
    this.onResizeHandler = null;
    this.activeCommentId = null;
    this.options = options;
    this.layoutMode = options.layoutMode ?? "vertical";
    this.blockLookup = this.buildBlockLookup(blocks, measures);
    this.headerProvider = options.headerProvider;
    this.footerProvider = options.footerProvider;
    const defaultGap = this.layoutMode === "horizontal" ? 20 : 24;
    this.pageGap = typeof options.pageGap === "number" && Number.isFinite(options.pageGap) ? Math.max(0, options.pageGap) : defaultGap;
    if (this.layoutMode === "vertical" && options.virtualization?.enabled) {
      this.virtualEnabled = true;
      this.virtualWindow = Math.max(1, options.virtualization.window ?? 5);
      this.virtualOverscan = Math.max(0, options.virtualization.overscan ?? 0);
      const maybeGap = options.virtualization.gap;
      if (typeof maybeGap === "number" && Number.isFinite(maybeGap)) {
        this.virtualGap = Math.max(0, maybeGap);
      } else {
        this.virtualGap = DEFAULT_VIRTUALIZED_PAGE_GAP$1;
      }
      if (typeof options.virtualization.paddingTop === "number" && Number.isFinite(options.virtualization.paddingTop)) {
        this.virtualPaddingTop = Math.max(0, options.virtualization.paddingTop);
      }
    }
  }
  setProviders(header, footer) {
    this.headerProvider = header;
    this.footerProvider = footer;
  }
  /**
   * Pins specific page indices so they remain mounted when virtualization is enabled.
   *
   * Used by selection/drag logic to ensure endpoints can be resolved via DOM
   * even when they fall outside the current scroll window.
   */
  setVirtualizationPins(pageIndices) {
    const next = Array.from(new Set((pageIndices ?? []).filter((n) => Number.isInteger(n)))).sort((a, b2) => a - b2);
    this.virtualPinnedPages = next;
    if (this.virtualEnabled && this.mount) {
      this.updateVirtualWindow();
    }
  }
  /**
   * Sets the active comment ID for highlighting.
   * When set, only the active comment's range is highlighted.
   * When null, all comments show depth-based highlighting.
   */
  setActiveComment(commentId) {
    if (this.activeCommentId !== commentId) {
      this.activeCommentId = commentId;
      this.layoutVersion += 1;
      for (const state of this.pageIndexToState.values()) {
        state.element.remove();
      }
      this.pageIndexToState.clear();
      this.virtualMountedKey = "";
      this.pageStates = [];
    }
  }
  /**
   * Gets the currently active comment ID.
   */
  getActiveComment() {
    return this.activeCommentId;
  }
  /**
   * Updates the painter's block and measure data.
   *
   * @param blocks - Main document blocks
   * @param measures - Measures corresponding to main document blocks
   * @param headerBlocks - Optional header blocks from header/footer layout results
   * @param headerMeasures - Optional measures corresponding to header blocks
   * @param footerBlocks - Optional footer blocks from header/footer layout results
   * @param footerMeasures - Optional measures corresponding to footer blocks
   */
  setData(blocks, measures, headerBlocks, headerMeasures, footerBlocks, footerMeasures) {
    if (blocks.length !== measures.length) {
      throw new Error(
        `setData: blocks and measures arrays must have the same length. Got blocks.length=${blocks.length}, measures.length=${measures.length}`
      );
    }
    const hasHeaderBlocks = headerBlocks !== void 0;
    const hasHeaderMeasures = headerMeasures !== void 0;
    if (hasHeaderBlocks !== hasHeaderMeasures) {
      throw new Error(
        `setData: headerBlocks and headerMeasures must both be provided or both be omitted. Got headerBlocks=${hasHeaderBlocks ? "provided" : "omitted"}, headerMeasures=${hasHeaderMeasures ? "provided" : "omitted"}`
      );
    }
    if (hasHeaderBlocks && hasHeaderMeasures && headerBlocks.length !== headerMeasures.length) {
      throw new Error(
        `setData: headerBlocks and headerMeasures arrays must have the same length. Got headerBlocks.length=${headerBlocks.length}, headerMeasures.length=${headerMeasures.length}`
      );
    }
    const hasFooterBlocks = footerBlocks !== void 0;
    const hasFooterMeasures = footerMeasures !== void 0;
    if (hasFooterBlocks !== hasFooterMeasures) {
      throw new Error(
        `setData: footerBlocks and footerMeasures must both be provided or both be omitted. Got footerBlocks=${hasFooterBlocks ? "provided" : "omitted"}, footerMeasures=${hasFooterMeasures ? "provided" : "omitted"}`
      );
    }
    if (hasFooterBlocks && hasFooterMeasures && footerBlocks.length !== footerMeasures.length) {
      throw new Error(
        `setData: footerBlocks and footerMeasures arrays must have the same length. Got footerBlocks.length=${footerBlocks.length}, footerMeasures.length=${footerMeasures.length}`
      );
    }
    const nextLookup = this.buildBlockLookup(blocks, measures);
    if (headerBlocks && headerMeasures) {
      const headerLookup = this.buildBlockLookup(headerBlocks, headerMeasures);
      headerLookup.forEach((entry, id) => {
        nextLookup.set(id, entry);
      });
    }
    if (footerBlocks && footerMeasures) {
      const footerLookup = this.buildBlockLookup(footerBlocks, footerMeasures);
      footerLookup.forEach((entry, id) => {
        nextLookup.set(id, entry);
      });
    }
    const changed = /* @__PURE__ */ new Set();
    nextLookup.forEach((entry, id) => {
      const previous = this.blockLookup.get(id);
      if (!previous || previous.version !== entry.version) {
        changed.add(id);
      }
    });
    this.blockLookup = nextLookup;
    this.changedBlocks = changed;
  }
  paint(layout, mount2, mapping) {
    if (!(mount2 instanceof HTMLElement)) {
      throw new Error("DomPainter.paint requires a valid HTMLElement mount");
    }
    const doc2 = mount2.ownerDocument ?? (typeof document !== "undefined" ? document : null);
    if (!doc2) {
      throw new Error("DomPainter.paint requires a DOM-like document");
    }
    this.doc = doc2;
    const isSimpleTransaction = mapping && mapping.maps.length === 1;
    if (mapping && !isSimpleTransaction) {
      this.blockLookup.forEach((_2, id) => this.changedBlocks.add(id));
      this.currentMapping = null;
    } else {
      this.currentMapping = mapping ?? null;
    }
    ensurePrintStyles(doc2);
    ensureLinkStyles(doc2);
    ensureTrackChangeStyles(doc2);
    ensureFieldAnnotationStyles(doc2);
    ensureSdtContainerStyles(doc2);
    ensureImageSelectionStyles(doc2);
    ensureNativeSelectionStyles(doc2);
    if (this.options.ruler?.enabled) {
      ensureRulerStyles(doc2);
    }
    mount2.classList.add(CLASS_NAMES$1.container);
    if (this.mount && this.mount !== mount2) {
      this.resetState();
    }
    this.layoutVersion += 1;
    this.layoutEpoch = layout.layoutEpoch ?? 0;
    this.mount = mount2;
    this.totalPages = layout.pages.length;
    const mode = this.layoutMode;
    if (mode === "horizontal") {
      applyStyles$2(mount2, containerStylesHorizontal);
      mount2.style.gap = `${this.pageGap}px`;
      this.renderHorizontal(layout, mount2);
      this.currentLayout = layout;
      this.pageStates = [];
      this.changedBlocks.clear();
      this.currentMapping = null;
      return;
    }
    if (mode === "book") {
      applyStyles$2(mount2, containerStyles);
      this.renderBookMode(layout, mount2);
      this.currentLayout = layout;
      this.pageStates = [];
      this.changedBlocks.clear();
      this.currentMapping = null;
      return;
    }
    applyStyles$2(mount2, containerStyles);
    if (this.virtualEnabled) {
      mount2.style.gap = `${this.virtualGap}px`;
      this.renderVirtualized(layout, mount2);
      this.currentLayout = layout;
      this.changedBlocks.clear();
      this.currentMapping = null;
      return;
    }
    mount2.style.gap = `${this.pageGap}px`;
    if (!this.currentLayout || this.pageStates.length === 0) {
      this.fullRender(layout);
    } else {
      this.patchLayout(layout);
    }
    this.currentLayout = layout;
    this.changedBlocks.clear();
    this.currentMapping = null;
  }
  // ----------------
  // Virtualized path
  // ----------------
  renderVirtualized(layout, mount2) {
    if (!this.doc) return;
    this.currentLayout = layout;
    const needsInit = !this.topSpacerEl || !this.bottomSpacerEl || this.mount !== mount2;
    if (needsInit) {
      this.ensureVirtualizationSetup(mount2);
    }
    this.computeVirtualMetrics();
    this.updateVirtualWindow();
  }
  ensureVirtualizationSetup(mount2) {
    if (!this.doc) return;
    mount2.innerHTML = "";
    this.pageStates = [];
    this.pageIndexToState.clear();
    this.virtualGapSpacers = [];
    this.virtualMountedKey = "";
    this.topSpacerEl = this.doc.createElement("div");
    this.bottomSpacerEl = this.doc.createElement("div");
    this.configureSpacerElement(this.topSpacerEl, "top");
    this.configureSpacerElement(this.bottomSpacerEl, "bottom");
    mount2.appendChild(this.topSpacerEl);
    mount2.appendChild(this.bottomSpacerEl);
    this.bindVirtualizationHandlers(mount2);
  }
  configureSpacerElement(element, type) {
    element.style.width = "1px";
    element.style.height = "0px";
    element.style.flex = "0 0 auto";
    element.setAttribute("data-virtual-spacer", type);
  }
  bindVirtualizationHandlers(mount2) {
    if (this.onScrollHandler) {
      mount2.removeEventListener("scroll", this.onScrollHandler);
    }
    this.onScrollHandler = () => {
      this.updateVirtualWindow();
    };
    mount2.addEventListener("scroll", this.onScrollHandler);
    const win = this.doc?.defaultView;
    if (win) {
      if (this.onWindowScrollHandler) {
        win.removeEventListener("scroll", this.onWindowScrollHandler);
      }
      this.onWindowScrollHandler = () => {
        this.updateVirtualWindow();
      };
      win.addEventListener("scroll", this.onWindowScrollHandler, { passive: true });
      if (this.onResizeHandler) {
        win.removeEventListener("resize", this.onResizeHandler);
      }
      this.onResizeHandler = () => {
        this.updateVirtualWindow();
      };
      win.addEventListener("resize", this.onResizeHandler);
    }
  }
  computeVirtualMetrics() {
    if (!this.currentLayout) return;
    const N = this.currentLayout.pages.length;
    if (N !== this.virtualHeights.length) {
      this.virtualHeights = this.currentLayout.pages.map((p2) => p2.size?.h ?? this.currentLayout.pageSize.h);
    }
    const offsets = new Array(this.virtualHeights.length + 1);
    offsets[0] = 0;
    for (let i = 0; i < this.virtualHeights.length; i += 1) {
      offsets[i + 1] = offsets[i] + this.virtualHeights[i] + this.virtualGap;
    }
    this.virtualOffsets = offsets;
  }
  topOfIndex(i) {
    if (i <= 0) return 0;
    return this.virtualOffsets[i];
  }
  contentTotalHeight() {
    const n = this.virtualHeights.length;
    if (n <= 0) return 0;
    return this.virtualOffsets[n] - this.virtualGap;
  }
  getMountPaddingTopPx() {
    if (this.virtualPaddingTop != null) return this.virtualPaddingTop;
    if (!this.mount || !this.doc) return 0;
    const win = this.doc.defaultView;
    if (!win) return 0;
    const style2 = win.getComputedStyle(this.mount);
    const pt = style2?.paddingTop ?? "0";
    const val = Number.parseFloat(pt.replace("px", ""));
    if (Number.isFinite(val)) return Math.max(0, val);
    return 0;
  }
  updateVirtualWindow() {
    if (!this.mount || !this.topSpacerEl || !this.bottomSpacerEl || !this.currentLayout) return;
    const layout = this.currentLayout;
    const N = layout.pages.length;
    if (N === 0) {
      this.mount.innerHTML = "";
      this.processedLayoutVersion = this.layoutVersion;
      return;
    }
    const paddingTop = this.getMountPaddingTopPx();
    let scrollY;
    const isContainerScrollable = this.mount.scrollHeight > this.mount.clientHeight + 1;
    if (isContainerScrollable) {
      scrollY = Math.max(0, this.mount.scrollTop - paddingTop);
    } else {
      const rect = this.mount.getBoundingClientRect();
      scrollY = Math.max(0, -rect.top - paddingTop);
    }
    let lo = 0;
    let hi = N;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (this.topOfIndex(mid) <= scrollY) lo = mid + 1;
      else hi = mid;
    }
    const anchor = Math.max(0, lo - 1);
    const baseWindow = this.virtualWindow;
    const overscan = this.virtualOverscan;
    let start2 = anchor - Math.floor(baseWindow / 2) - overscan;
    start2 = Math.max(0, Math.min(start2, Math.max(0, N - baseWindow)));
    const end2 = Math.min(N - 1, start2 + baseWindow - 1 + overscan * 2);
    start2 = Math.max(0, Math.min(start2, end2 - baseWindow + 1));
    const needed = /* @__PURE__ */ new Set();
    for (let i = start2; i <= end2; i += 1) needed.add(i);
    for (const pageIndex of this.virtualPinnedPages) {
      const idx = Math.max(0, Math.min(pageIndex, N - 1));
      needed.add(idx);
    }
    const mounted = Array.from(needed).sort((a, b2) => a - b2);
    const mountedKey = mounted.join(",");
    const alreadyProcessedLayout = this.processedLayoutVersion === this.layoutVersion;
    if (mountedKey === this.virtualMountedKey && this.changedBlocks.size === 0 && alreadyProcessedLayout) {
      this.virtualStart = start2;
      this.virtualEnd = end2;
      this.updateSpacersForMountedPages(mounted);
      return;
    }
    this.virtualMountedKey = mountedKey;
    this.virtualStart = start2;
    this.virtualEnd = end2;
    this.updateSpacersForMountedPages(mounted);
    this.clearGapSpacers();
    for (const [idx, state] of this.pageIndexToState.entries()) {
      if (!needed.has(idx)) {
        state.element.remove();
        this.pageIndexToState.delete(idx);
      }
    }
    for (const i of mounted) {
      const page = layout.pages[i];
      const pageSize = page.size ?? layout.pageSize;
      const existing = this.pageIndexToState.get(i);
      if (!existing) {
        const newState = this.createPageState(page, pageSize);
        newState.element.dataset.pageNumber = String(page.number);
        newState.element.dataset.pageIndex = String(i);
        applyStyles$2(newState.element, pageStyles(pageSize.w, pageSize.h, this.getEffectivePageStyles()));
        this.mount.insertBefore(newState.element, this.bottomSpacerEl);
        this.pageIndexToState.set(i, newState);
      } else {
        this.patchPage(existing, page, pageSize);
      }
    }
    if (this.mount.firstChild !== this.topSpacerEl) {
      this.mount.insertBefore(this.topSpacerEl, this.mount.firstChild);
    }
    this.mount.appendChild(this.bottomSpacerEl);
    let prevIndex = null;
    for (const idx of mounted) {
      if (prevIndex != null && idx > prevIndex + 1) {
        const gap = this.doc.createElement("div");
        this.configureSpacerElement(gap, "gap");
        gap.dataset.gapFrom = String(prevIndex);
        gap.dataset.gapTo = String(idx);
        const gapHeight = this.topOfIndex(idx) - this.topOfIndex(prevIndex) - this.virtualHeights[prevIndex] - this.virtualGap * 2;
        gap.style.height = `${Math.max(0, Math.floor(gapHeight))}px`;
        this.virtualGapSpacers.push(gap);
        this.mount.insertBefore(gap, this.bottomSpacerEl);
      }
      const state = this.pageIndexToState.get(idx);
      this.mount.insertBefore(state.element, this.bottomSpacerEl);
      prevIndex = idx;
    }
    this.changedBlocks.clear();
    this.processedLayoutVersion = this.layoutVersion;
  }
  updateSpacers(start2, end2) {
    if (!this.topSpacerEl || !this.bottomSpacerEl) return;
    const top2 = this.topOfIndex(start2);
    const bottom2 = this.contentTotalHeight() - this.topOfIndex(end2 + 1);
    this.topSpacerEl.style.height = `${Math.max(0, Math.floor(top2))}px`;
    this.bottomSpacerEl.style.height = `${Math.max(0, Math.floor(bottom2))}px`;
  }
  updateSpacersForMountedPages(mountedPageIndices) {
    if (!this.topSpacerEl || !this.bottomSpacerEl) return;
    if (mountedPageIndices.length === 0) {
      this.topSpacerEl.style.height = "0px";
      this.bottomSpacerEl.style.height = "0px";
      return;
    }
    const first2 = mountedPageIndices[0];
    const last = mountedPageIndices[mountedPageIndices.length - 1];
    const n = this.virtualHeights.length;
    const clampedFirst = Math.max(0, Math.min(first2, Math.max(0, n - 1)));
    const clampedLast = Math.max(0, Math.min(last, Math.max(0, n - 1)));
    const top2 = this.topOfIndex(clampedFirst);
    const bottom2 = this.topOfIndex(n) - this.topOfIndex(clampedLast + 1) - this.virtualGap;
    this.topSpacerEl.style.height = `${Math.max(0, Math.floor(top2))}px`;
    this.bottomSpacerEl.style.height = `${Math.max(0, Math.floor(bottom2))}px`;
  }
  clearGapSpacers() {
    for (const el of this.virtualGapSpacers) {
      el.remove();
    }
    this.virtualGapSpacers = [];
  }
  renderHorizontal(layout, mount2) {
    if (!this.doc) return;
    mount2.innerHTML = "";
    layout.pages.forEach((page, pageIndex) => {
      const pageSize = page.size ?? layout.pageSize;
      const pageEl = this.renderPage(pageSize.w, pageSize.h, page);
      pageEl.dataset.pageNumber = String(page.number);
      pageEl.dataset.pageIndex = String(pageIndex);
      mount2.appendChild(pageEl);
    });
  }
  renderBookMode(layout, mount2) {
    if (!this.doc) return;
    mount2.innerHTML = "";
    const pages = layout.pages;
    if (pages.length === 0) return;
    const firstPageSize = pages[0].size ?? layout.pageSize;
    const firstPageEl = this.renderPage(firstPageSize.w, firstPageSize.h, pages[0]);
    firstPageEl.dataset.pageNumber = String(pages[0].number);
    firstPageEl.dataset.pageIndex = "0";
    mount2.appendChild(firstPageEl);
    for (let i = 1; i < pages.length; i += 2) {
      const spreadEl = this.doc.createElement("div");
      spreadEl.classList.add(CLASS_NAMES$1.spread);
      applyStyles$2(spreadEl, spreadStyles);
      const leftPage = pages[i];
      const leftPageSize = leftPage.size ?? layout.pageSize;
      const leftPageEl = this.renderPage(leftPageSize.w, leftPageSize.h, leftPage);
      leftPageEl.dataset.pageNumber = String(leftPage.number);
      leftPageEl.dataset.pageIndex = String(i);
      spreadEl.appendChild(leftPageEl);
      if (i + 1 < pages.length) {
        const rightPage = pages[i + 1];
        const rightPageSize = rightPage.size ?? layout.pageSize;
        const rightPageEl = this.renderPage(rightPageSize.w, rightPageSize.h, rightPage);
        rightPageEl.dataset.pageNumber = String(rightPage.number);
        rightPageEl.dataset.pageIndex = String(i + 1);
        spreadEl.appendChild(rightPageEl);
      }
      mount2.appendChild(spreadEl);
    }
  }
  renderPage(width, height, page) {
    if (!this.doc) {
      throw new Error("DomPainter: document is not available");
    }
    const el = this.doc.createElement("div");
    el.classList.add(CLASS_NAMES$1.page);
    applyStyles$2(el, pageStyles(width, height, this.getEffectivePageStyles()));
    el.dataset.layoutEpoch = String(this.layoutEpoch);
    if (this.options.ruler?.enabled) {
      const rulerEl = this.renderPageRuler(width, page);
      if (rulerEl) {
        el.appendChild(rulerEl);
      }
    }
    const contextBase = {
      pageNumber: page.number,
      totalPages: this.totalPages,
      section: "body",
      pageNumberText: page.numberText
    };
    const sdtBoundaries = computeSdtBoundaries(page.fragments, this.blockLookup);
    page.fragments.forEach((fragment, index2) => {
      const sdtBoundary = sdtBoundaries.get(index2);
      el.appendChild(this.renderFragment(fragment, contextBase, sdtBoundary));
    });
    this.renderDecorationsForPage(el, page);
    return el;
  }
  /**
   * Render a ruler element for a page.
   *
   * Creates a horizontal ruler with tick marks and optional interactive margin handles.
   * The ruler is positioned at the top of the page and displays inch measurements.
   *
   * @param pageWidthPx - Page width in pixels
   * @param page - Page data containing margins and optional size information
   * @returns Ruler element, or null if this.doc is unavailable or page margins are missing
   *
   * Side effects:
   * - Creates DOM elements and applies inline styles
   * - May invoke the onMarginChange callback if interactive mode is enabled
   *
   * Fallback behavior:
   * - Uses DEFAULT_PAGE_HEIGHT_PX (1056px = 11 inches) if page.size.h is not available
   * - Defaults margins to 0 if not explicitly provided
   */
  renderPageRuler(pageWidthPx, page) {
    if (!this.doc) {
      console.warn("[renderPageRuler] Cannot render ruler: document is not available.");
      return null;
    }
    if (!page.margins) {
      console.warn(`[renderPageRuler] Cannot render ruler for page ${page.number}: margins not available.`);
      return null;
    }
    const margins = page.margins;
    const leftMargin = margins.left ?? 0;
    const rightMargin = margins.right ?? 0;
    try {
      const rulerDefinition = generateRulerDefinitionFromPx({
        pageWidthPx,
        pageHeightPx: page.size?.h ?? DEFAULT_PAGE_HEIGHT_PX,
        leftMarginPx: leftMargin,
        rightMarginPx: rightMargin
      });
      const interactive = this.options.ruler?.interactive ?? false;
      const onMarginChange = this.options.ruler?.onMarginChange;
      const rulerEl = createRulerElement({
        definition: rulerDefinition,
        doc: this.doc,
        interactive,
        onDragEnd: interactive && onMarginChange ? (side, x) => {
          try {
            const ppi = 96;
            const marginInches = side === "left" ? x / ppi : (pageWidthPx - x) / ppi;
            onMarginChange(side, marginInches);
          } catch (error) {
            console.error("[renderPageRuler] Error in onMarginChange callback:", error);
          }
        } : void 0
      });
      rulerEl.style.position = "absolute";
      rulerEl.style.top = "0";
      rulerEl.style.left = "0";
      rulerEl.style.zIndex = "20";
      rulerEl.dataset.pageNumber = String(page.number);
      return rulerEl;
    } catch (error) {
      console.error(`[renderPageRuler] Failed to create ruler for page ${page.number}:`, error);
      return null;
    }
  }
  renderDecorationsForPage(pageEl, page) {
    this.renderDecorationSection(pageEl, page, "header");
    this.renderDecorationSection(pageEl, page, "footer");
  }
  renderDecorationSection(pageEl, page, kind) {
    if (!this.doc) return;
    const provider = kind === "header" ? this.headerProvider : this.footerProvider;
    const className = kind === "header" ? CLASS_NAMES$1.pageHeader : CLASS_NAMES$1.pageFooter;
    const existing = pageEl.querySelector(`.${className}`);
    const data = provider ? provider(page.number, page.margins, page) : null;
    if (!data || data.fragments.length === 0) {
      existing?.remove();
      return;
    }
    const container = existing ?? this.doc.createElement("div");
    container.className = className;
    container.innerHTML = "";
    const baseOffset = data.offset ?? (kind === "footer" ? pageEl.clientHeight - data.height : 0);
    const marginLeft = data.marginLeft ?? 0;
    const marginRight = page.margins?.right ?? 0;
    let effectiveHeight = data.height;
    let effectiveOffset = baseOffset;
    if (kind === "footer" && typeof data.contentHeight === "number" && Number.isFinite(data.contentHeight) && data.contentHeight > 0 && data.contentHeight > data.height) {
      effectiveHeight = data.contentHeight;
      effectiveOffset = baseOffset - (data.contentHeight - data.height);
    }
    container.style.position = "absolute";
    container.style.left = `${marginLeft}px`;
    if (typeof data.contentWidth === "number") {
      container.style.width = `${Math.max(0, data.contentWidth)}px`;
    } else {
      container.style.width = `calc(100% - ${marginLeft + marginRight}px)`;
    }
    container.style.pointerEvents = "none";
    container.style.height = `${effectiveHeight}px`;
    container.style.top = `${Math.max(0, effectiveOffset)}px`;
    container.style.zIndex = "1";
    container.style.overflow = "visible";
    let footerYOffset = 0;
    if (kind === "footer" && data.fragments.length > 0) {
      const contentHeight = typeof data.contentHeight === "number" ? data.contentHeight : data.fragments.reduce((max2, f) => {
        const fragHeight = "height" in f && typeof f.height === "number" ? f.height : this.estimateFragmentHeight(f);
        return Math.max(max2, f.y + Math.max(0, fragHeight));
      }, 0);
      footerYOffset = Math.max(0, effectiveHeight - contentHeight);
    }
    const context = {
      pageNumber: page.number,
      totalPages: this.totalPages,
      section: kind,
      pageNumberText: page.numberText
    };
    const behindDocFragments = [];
    const normalFragments = [];
    for (const fragment of data.fragments) {
      const isBehindDoc = (fragment.kind === "image" || fragment.kind === "drawing") && "zIndex" in fragment && fragment.zIndex === 0;
      if (isBehindDoc) {
        behindDocFragments.push(fragment);
      } else {
        normalFragments.push(fragment);
      }
    }
    const behindDocSelector = `[data-behind-doc-section="${kind}"]`;
    pageEl.querySelectorAll(behindDocSelector).forEach((el) => el.remove());
    behindDocFragments.forEach((fragment) => {
      const fragEl = this.renderFragment(fragment, context);
      const pageY = effectiveOffset + fragment.y + (kind === "footer" ? footerYOffset : 0);
      fragEl.style.top = `${pageY}px`;
      fragEl.style.left = `${marginLeft + fragment.x}px`;
      fragEl.style.zIndex = "0";
      fragEl.dataset.behindDocSection = kind;
      pageEl.insertBefore(fragEl, pageEl.firstChild);
    });
    normalFragments.forEach((fragment) => {
      const fragEl = this.renderFragment(fragment, context);
      if (footerYOffset > 0) {
        const currentTop = parseFloat(fragEl.style.top) || fragment.y;
        fragEl.style.top = `${currentTop + footerYOffset}px`;
      }
      container.appendChild(fragEl);
    });
    if (!existing) {
      pageEl.appendChild(container);
    }
  }
  resetState() {
    if (this.mount) {
      if (this.onScrollHandler) {
        try {
          this.mount.removeEventListener("scroll", this.onScrollHandler);
        } catch {
        }
      }
      if (this.onWindowScrollHandler && this.doc?.defaultView) {
        try {
          this.doc.defaultView.removeEventListener("scroll", this.onWindowScrollHandler);
        } catch {
        }
      }
      if (this.onResizeHandler && this.doc?.defaultView) {
        try {
          this.doc.defaultView.removeEventListener("resize", this.onResizeHandler);
        } catch {
        }
      }
      this.mount.innerHTML = "";
    }
    this.pageStates = [];
    this.currentLayout = null;
    this.pageIndexToState.clear();
    this.topSpacerEl = null;
    this.bottomSpacerEl = null;
    this.onScrollHandler = null;
    this.onWindowScrollHandler = null;
    this.onResizeHandler = null;
    this.layoutVersion = 0;
    this.processedLayoutVersion = -1;
  }
  fullRender(layout) {
    if (!this.mount || !this.doc) return;
    this.mount.innerHTML = "";
    this.pageStates = [];
    layout.pages.forEach((page, pageIndex) => {
      const pageSize = page.size ?? layout.pageSize;
      const pageState = this.createPageState(page, pageSize);
      pageState.element.dataset.pageNumber = String(page.number);
      pageState.element.dataset.pageIndex = String(pageIndex);
      this.mount.appendChild(pageState.element);
      this.pageStates.push(pageState);
    });
  }
  patchLayout(layout) {
    if (!this.mount || !this.doc) return;
    const nextStates = [];
    layout.pages.forEach((page, index2) => {
      const pageSize = page.size ?? layout.pageSize;
      const prevState = this.pageStates[index2];
      if (!prevState) {
        const newState = this.createPageState(page, pageSize);
        newState.element.dataset.pageNumber = String(page.number);
        newState.element.dataset.pageIndex = String(index2);
        this.mount.insertBefore(newState.element, this.mount.children[index2] ?? null);
        nextStates.push(newState);
        return;
      }
      this.patchPage(prevState, page, pageSize);
      nextStates.push(prevState);
    });
    if (this.pageStates.length > layout.pages.length) {
      for (let i = layout.pages.length; i < this.pageStates.length; i += 1) {
        this.pageStates[i]?.element.remove();
      }
    }
    this.pageStates = nextStates;
  }
  patchPage(state, page, pageSize) {
    const pageEl = state.element;
    applyStyles$2(pageEl, pageStyles(pageSize.w, pageSize.h, this.getEffectivePageStyles()));
    pageEl.dataset.pageNumber = String(page.number);
    pageEl.dataset.layoutEpoch = String(this.layoutEpoch);
    const existing = new Map(state.fragments.map((frag) => [frag.key, frag]));
    const nextFragments = [];
    const sdtBoundaries = computeSdtBoundaries(page.fragments, this.blockLookup);
    const contextBase = {
      pageNumber: page.number,
      totalPages: this.totalPages,
      section: "body",
      pageNumberText: page.numberText
    };
    page.fragments.forEach((fragment, index2) => {
      const key2 = fragmentKey(fragment);
      const current = existing.get(key2);
      const sdtBoundary = sdtBoundaries.get(index2);
      if (current) {
        existing.delete(key2);
        const sdtBoundaryMismatch = shouldRebuildForSdtBoundary(current.element, sdtBoundary);
        const needsRebuild = this.changedBlocks.has(fragment.blockId) || current.signature !== fragmentSignature(fragment, this.blockLookup) || sdtBoundaryMismatch;
        if (needsRebuild) {
          const replacement = this.renderFragment(fragment, contextBase, sdtBoundary);
          pageEl.replaceChild(replacement, current.element);
          current.element = replacement;
          current.signature = fragmentSignature(fragment, this.blockLookup);
        } else if (this.currentMapping) {
          this.updatePositionAttributes(current.element, this.currentMapping);
        }
        this.updateFragmentElement(current.element, fragment, contextBase.section);
        if (sdtBoundary?.widthOverride != null) {
          current.element.style.width = `${sdtBoundary.widthOverride}px`;
        }
        current.fragment = fragment;
        current.key = key2;
        current.context = contextBase;
        nextFragments.push(current);
        return;
      }
      const fresh = this.renderFragment(fragment, contextBase, sdtBoundary);
      pageEl.insertBefore(fresh, pageEl.children[index2] ?? null);
      nextFragments.push({
        key: key2,
        fragment,
        element: fresh,
        signature: fragmentSignature(fragment, this.blockLookup),
        context: contextBase
      });
    });
    existing.forEach((state2) => state2.element.remove());
    nextFragments.forEach((fragmentState, index2) => {
      const desiredChild = pageEl.children[index2];
      if (fragmentState.element !== desiredChild) {
        pageEl.insertBefore(fragmentState.element, desiredChild ?? null);
      }
    });
    state.fragments = nextFragments;
    this.renderDecorationsForPage(pageEl, page);
  }
  /**
   * Updates data-pm-start/data-pm-end attributes on all elements within a fragment
   * using the transaction's mapping. Skips header/footer content (separate PM coordinate space).
   * Also skips fragments that end before the edit point (their positions don't change).
   */
  updatePositionAttributes(fragmentEl, mapping) {
    if (fragmentEl.closest(".superdoc-page-header, .superdoc-page-footer")) {
      return;
    }
    try {
      const fragEnd = fragmentEl.dataset.pmEnd;
      if (fragEnd !== void 0 && fragEnd !== "") {
        const endNum = Number(fragEnd);
        if (Number.isFinite(endNum) && mapping.map(endNum, -1) === endNum) {
          return;
        }
      }
      const elements = fragmentEl.querySelectorAll("[data-pm-start], [data-pm-end]");
      const allElements = [fragmentEl, ...Array.from(elements)];
      for (const el of allElements) {
        const oldStart = el.dataset.pmStart;
        const oldEnd = el.dataset.pmEnd;
        if (oldStart !== void 0 && oldStart !== "") {
          const num = Number(oldStart);
          if (Number.isFinite(num)) {
            el.dataset.pmStart = String(mapping.map(num));
          }
        }
        if (oldEnd !== void 0 && oldEnd !== "") {
          const num = Number(oldEnd);
          if (Number.isFinite(num)) {
            el.dataset.pmEnd = String(mapping.map(num, -1));
          }
        }
      }
    } catch (error) {
      console.error("Error updating position attributes with mapping:", error);
    }
  }
  createPageState(page, pageSize) {
    if (!this.doc) {
      throw new Error("DomPainter.createPageState requires a document");
    }
    const el = this.doc.createElement("div");
    el.classList.add(CLASS_NAMES$1.page);
    applyStyles$2(el, pageStyles(pageSize.w, pageSize.h, this.getEffectivePageStyles()));
    el.dataset.layoutEpoch = String(this.layoutEpoch);
    const contextBase = {
      pageNumber: page.number,
      totalPages: this.totalPages,
      section: "body"
    };
    const sdtBoundaries = computeSdtBoundaries(page.fragments, this.blockLookup);
    const fragments = page.fragments.map((fragment, index2) => {
      const sdtBoundary = sdtBoundaries.get(index2);
      const fragmentEl = this.renderFragment(fragment, contextBase, sdtBoundary);
      el.appendChild(fragmentEl);
      return {
        key: fragmentKey(fragment),
        signature: fragmentSignature(fragment, this.blockLookup),
        fragment,
        element: fragmentEl,
        context: contextBase
      };
    });
    this.renderDecorationsForPage(el, page);
    return { element: el, fragments };
  }
  getEffectivePageStyles() {
    if (this.virtualEnabled && this.layoutMode === "vertical") {
      const base2 = this.options.pageStyles ?? {};
      return { ...base2, margin: "0 auto" };
    }
    return this.options.pageStyles;
  }
  renderFragment(fragment, context, sdtBoundary) {
    if (fragment.kind === "para") {
      return this.renderParagraphFragment(fragment, context, sdtBoundary);
    }
    if (fragment.kind === "list-item") {
      return this.renderListItemFragment(fragment, context, sdtBoundary);
    }
    if (fragment.kind === "image") {
      return this.renderImageFragment(fragment, context);
    }
    if (fragment.kind === "drawing") {
      return this.renderDrawingFragment(fragment, context);
    }
    if (fragment.kind === "table") {
      return this.renderTableFragment(fragment, context, sdtBoundary);
    }
    throw new Error(`DomPainter: unsupported fragment kind ${fragment.kind}`);
  }
  /**
   * Renders a paragraph fragment with defensive error handling.
   * Falls back to error placeholder on rendering errors to prevent full paint failure.
   *
   * @param fragment - The paragraph fragment to render
   * @param context - Rendering context with page and column information
   * @param sdtBoundary - Optional SDT boundary overrides for multi-fragment containers
   * @returns HTMLElement containing the rendered fragment or error placeholder
   */
  renderParagraphFragment(fragment, context, sdtBoundary) {
    try {
      const lookup = this.blockLookup.get(fragment.blockId);
      if (!lookup || lookup.block.kind !== "paragraph" || lookup.measure.kind !== "paragraph") {
        throw new Error(`DomPainter: missing block/measure for fragment ${fragment.blockId}`);
      }
      if (!this.doc) {
        throw new Error("DomPainter: document is not available");
      }
      const block = lookup.block;
      const measure = lookup.measure;
      const wordLayout = isMinimalWordLayout(block.attrs?.wordLayout) ? block.attrs.wordLayout : void 0;
      const fragmentEl = this.doc.createElement("div");
      fragmentEl.classList.add(CLASS_NAMES$1.fragment);
      const isTocEntry = block.attrs?.isTocEntry;
      const hasMarker = !fragment.continuesFromPrev && fragment.markerWidth && wordLayout?.marker;
      const hasSdtContainer = block.attrs?.sdt?.type === "documentSection" || block.attrs?.sdt?.type === "structuredContent" || block.attrs?.containerSdt?.type === "documentSection" || block.attrs?.containerSdt?.type === "structuredContent";
      const paraIndentForOverflow = block.attrs?.indent;
      const hasNegativeIndent = (paraIndentForOverflow?.left ?? 0) < 0 || (paraIndentForOverflow?.right ?? 0) < 0;
      const styles = isTocEntry ? { ...fragmentStyles, whiteSpace: "nowrap" } : hasMarker || hasSdtContainer || hasNegativeIndent ? { ...fragmentStyles, overflow: "visible" } : fragmentStyles;
      applyStyles$2(fragmentEl, styles);
      this.applyFragmentFrame(fragmentEl, fragment, context.section);
      if (isTocEntry) {
        fragmentEl.classList.add("superdoc-toc-entry");
      }
      if (fragment.continuesFromPrev) {
        fragmentEl.dataset.continuesFromPrev = "true";
      }
      if (fragment.continuesOnNext) {
        fragmentEl.dataset.continuesOnNext = "true";
      }
      const lines = fragment.lines ?? measure.lines.slice(fragment.fromLine, fragment.toLine);
      applyParagraphBlockStyles(fragmentEl, block.attrs);
      const { shadingLayer, borderLayer } = createParagraphDecorationLayers(this.doc, fragment.width, block.attrs);
      if (shadingLayer) {
        fragmentEl.appendChild(shadingLayer);
      }
      if (borderLayer) {
        fragmentEl.appendChild(borderLayer);
      }
      if (block.attrs?.styleId) {
        fragmentEl.dataset.styleId = block.attrs.styleId;
        fragmentEl.setAttribute("styleid", block.attrs.styleId);
      }
      this.applySdtDataset(fragmentEl, block.attrs?.sdt);
      this.applyContainerSdtDataset(fragmentEl, block.attrs?.containerSdt);
      applySdtContainerStyling(this.doc, fragmentEl, block.attrs?.sdt, block.attrs?.containerSdt, sdtBoundary);
      const dropCapDescriptor = block.attrs?.dropCapDescriptor;
      const dropCapMeasure = measure.dropCap;
      if (dropCapDescriptor && dropCapMeasure && !fragment.continuesFromPrev) {
        const dropCapEl = this.renderDropCap(dropCapDescriptor, dropCapMeasure);
        fragmentEl.appendChild(dropCapEl);
      }
      if (fragmentEl.style.paddingLeft) fragmentEl.style.removeProperty("padding-left");
      if (fragmentEl.style.paddingRight) fragmentEl.style.removeProperty("padding-right");
      if (fragmentEl.style.marginLeft) fragmentEl.style.removeProperty("margin-left");
      if (fragmentEl.style.marginRight) fragmentEl.style.removeProperty("margin-right");
      if (fragmentEl.style.textIndent) fragmentEl.style.removeProperty("text-indent");
      const paraIndent = block.attrs?.indent;
      const paraIndentLeft = paraIndent?.left ?? 0;
      const paraIndentRight = paraIndent?.right ?? 0;
      const suppressFirstLineIndent = block.attrs?.suppressFirstLineIndent === true;
      const firstLineOffset = suppressFirstLineIndent ? 0 : (paraIndent?.firstLine ?? 0) - (paraIndent?.hanging ?? 0);
      const lastRun = block.runs.length > 0 ? block.runs[block.runs.length - 1] : null;
      const paragraphEndsWithLineBreak = lastRun?.kind === "lineBreak";
      let listFirstLineMarkerTabEndPx = null;
      let listTabWidth = 0;
      let markerStartPos;
      if (!fragment.continuesFromPrev && fragment.markerWidth && wordLayout?.marker) {
        const markerTextWidth = fragment.markerTextWidth;
        const anchorPoint = paraIndentLeft - (paraIndent?.hanging ?? 0) + (paraIndent?.firstLine ?? 0);
        const markerJustification = wordLayout.marker.justification ?? "left";
        let currentPos;
        if (markerJustification === "left") {
          markerStartPos = anchorPoint;
          currentPos = markerStartPos + markerTextWidth;
        } else if (markerJustification === "right") {
          markerStartPos = anchorPoint - markerTextWidth;
          currentPos = anchorPoint;
        } else {
          markerStartPos = anchorPoint - markerTextWidth / 2;
          currentPos = markerStartPos + markerTextWidth;
        }
        const suffix2 = wordLayout.marker.suffix ?? "tab";
        if (suffix2 === "tab") {
          listTabWidth = computeTabWidth(
            currentPos,
            markerJustification,
            wordLayout.tabsPx,
            paraIndent?.hanging,
            paraIndent?.firstLine,
            paraIndentLeft
          );
        } else if (suffix2 === "space") {
          listTabWidth = 4;
        }
        listFirstLineMarkerTabEndPx = currentPos + listTabWidth;
      }
      lines.forEach((line, index2) => {
        const positiveIndentReduction = Math.max(0, paraIndentLeft) + Math.max(0, paraIndentRight);
        const fallbackAvailableWidth = Math.max(0, fragment.width - positiveIndentReduction);
        let availableWidthOverride = line.maxWidth != null ? Math.min(line.maxWidth, fallbackAvailableWidth) : fallbackAvailableWidth;
        if (index2 === 0 && listFirstLineMarkerTabEndPx != null) {
          availableWidthOverride = fragment.width - listFirstLineMarkerTabEndPx - Math.max(0, paraIndentRight);
        }
        const isLastLineOfFragment = index2 === lines.length - 1;
        const isLastLineOfParagraph = isLastLineOfFragment && !fragment.continuesOnNext;
        const shouldSkipJustifyForLastLine = isLastLineOfParagraph && !paragraphEndsWithLineBreak;
        const lineEl = this.renderLine(
          block,
          line,
          context,
          availableWidthOverride,
          fragment.fromLine + index2,
          shouldSkipJustifyForLastLine
        );
        const isListFirstLine = index2 === 0 && !fragment.continuesFromPrev && fragment.markerWidth && fragment.markerTextWidth && wordLayout?.marker;
        const hasExplicitSegmentPositioning = line.segments?.some((seg) => seg.x !== void 0);
        const isFirstLine = index2 === 0 && !fragment.continuesFromPrev;
        if (!isListFirstLine) {
          if (hasExplicitSegmentPositioning) {
            if (isFirstLine && firstLineOffset !== 0) {
              const effectiveLeftIndent = paraIndentLeft < 0 ? 0 : paraIndentLeft;
              const adjustedPadding = effectiveLeftIndent + firstLineOffset;
              if (adjustedPadding > 0) {
                lineEl.style.paddingLeft = `${adjustedPadding}px`;
              }
            }
          } else if (paraIndentLeft && paraIndentLeft > 0) {
            lineEl.style.paddingLeft = `${paraIndentLeft}px`;
          } else if (!isFirstLine && paraIndent?.hanging && paraIndent.hanging > 0 && // Only apply hanging padding when left indent is NOT negative.
          // When left indent is negative, the fragment position already accounts for it.
          // Adding padding here would shift body lines right, causing right-side overflow.
          !(paraIndentLeft != null && paraIndentLeft < 0)) {
            lineEl.style.paddingLeft = `${paraIndent.hanging}px`;
          }
        }
        if (paraIndentRight && paraIndentRight > 0) {
          lineEl.style.paddingRight = `${paraIndentRight}px`;
        }
        if (!fragment.continuesFromPrev && index2 === 0 && firstLineOffset && !isListFirstLine) {
          if (!hasExplicitSegmentPositioning) {
            lineEl.style.textIndent = `${firstLineOffset}px`;
          }
        } else if (firstLineOffset && !isListFirstLine) {
          lineEl.style.textIndent = "0px";
        }
        if (isListFirstLine) {
          const marker = wordLayout.marker;
          lineEl.style.paddingLeft = `${paraIndentLeft + (paraIndent?.firstLine ?? 0) - (paraIndent?.hanging ?? 0)}px`;
          const markerContainer = this.doc.createElement("span");
          markerContainer.style.display = "inline-block";
          markerContainer.style.wordSpacing = "0px";
          const markerEl = this.doc.createElement("span");
          markerEl.classList.add("superdoc-paragraph-marker");
          markerEl.textContent = marker.markerText ?? "";
          markerEl.style.pointerEvents = "none";
          const markerJustification = marker.justification ?? "left";
          markerContainer.style.position = "relative";
          if (markerJustification === "right") {
            markerContainer.style.position = "absolute";
            markerContainer.style.left = `${markerStartPos}px`;
          } else if (markerJustification === "center") {
            markerContainer.style.position = "absolute";
            markerContainer.style.left = `${markerStartPos - fragment.markerTextWidth / 2}px`;
            lineEl.style.paddingLeft = parseFloat(lineEl.style.paddingLeft) + fragment.markerTextWidth / 2 + "px";
          }
          markerEl.style.fontFamily = toCssFontFamily(marker.run.fontFamily) ?? marker.run.fontFamily;
          markerEl.style.fontSize = `${marker.run.fontSize}px`;
          markerEl.style.fontWeight = marker.run.bold ? "bold" : "";
          markerEl.style.fontStyle = marker.run.italic ? "italic" : "";
          if (marker.run.color) {
            markerEl.style.color = marker.run.color;
          }
          if (marker.run.letterSpacing != null) {
            markerEl.style.letterSpacing = `${marker.run.letterSpacing}px`;
          }
          markerContainer.appendChild(markerEl);
          const suffix2 = marker.suffix ?? "tab";
          if (suffix2 === "tab") {
            const tabEl = this.doc.createElement("span");
            tabEl.className = "superdoc-tab";
            tabEl.innerHTML = "&nbsp;";
            tabEl.style.display = "inline-block";
            tabEl.style.wordSpacing = "0px";
            tabEl.style.width = `${listTabWidth}px`;
            lineEl.prepend(tabEl);
          } else if (suffix2 === "space") {
            const spaceEl = this.doc.createElement("span");
            spaceEl.classList.add("superdoc-marker-suffix-space");
            spaceEl.style.wordSpacing = "0px";
            spaceEl.textContent = "";
            lineEl.prepend(spaceEl);
          }
          lineEl.prepend(markerContainer);
        }
        fragmentEl.appendChild(lineEl);
      });
      return fragmentEl;
    } catch (error) {
      console.error("[DomPainter] Fragment rendering failed:", { fragment, error });
      return this.createErrorPlaceholder(fragment.blockId, error);
    }
  }
  /**
   * Creates an error placeholder element for failed fragment renders.
   * Prevents entire paint operation from failing due to single fragment error.
   *
   * @param blockId - The block ID that failed to render
   * @param error - The error that occurred
   * @returns HTMLElement showing the error
   */
  createErrorPlaceholder(blockId, error) {
    if (!this.doc) {
      const el2 = document.createElement("div");
      el2.className = "render-error-placeholder";
      el2.style.cssText = "color: red; padding: 4px; border: 1px solid red; background: #fee;";
      el2.textContent = `[Render Error: ${blockId}]`;
      return el2;
    }
    const el = this.doc.createElement("div");
    el.className = "render-error-placeholder";
    el.style.cssText = "color: red; padding: 4px; border: 1px solid red; background: #fee;";
    el.textContent = `[Render Error: ${blockId}]`;
    if (error instanceof Error) {
      el.title = error.message;
    }
    return el;
  }
  /**
   * Renders a drop cap element as a floated span at the start of a paragraph.
   *
   * Drop caps are large initial letters that span multiple lines of text.
   * This method creates a floated element with the drop cap letter styled
   * according to the descriptor's run properties.
   *
   * @param descriptor - The drop cap descriptor with text and styling info
   * @param measure - The measured dimensions of the drop cap
   * @returns HTMLElement containing the rendered drop cap
   */
  renderDropCap(descriptor, measure) {
    const doc2 = this.doc;
    const { run, mode } = descriptor;
    const dropCapEl = doc2.createElement("span");
    dropCapEl.classList.add("superdoc-drop-cap");
    dropCapEl.textContent = run.text;
    dropCapEl.style.fontFamily = run.fontFamily;
    dropCapEl.style.fontSize = `${run.fontSize}px`;
    if (run.bold) {
      dropCapEl.style.fontWeight = "bold";
    }
    if (run.italic) {
      dropCapEl.style.fontStyle = "italic";
    }
    if (run.color) {
      dropCapEl.style.color = run.color;
    }
    if (mode === "drop") {
      dropCapEl.style.float = "left";
      dropCapEl.style.marginRight = "4px";
      dropCapEl.style.lineHeight = "1";
    } else if (mode === "margin") {
      dropCapEl.style.position = "absolute";
      dropCapEl.style.left = "0";
      dropCapEl.style.lineHeight = "1";
    }
    if (run.position && run.position !== 0) {
      dropCapEl.style.position = dropCapEl.style.position || "relative";
      dropCapEl.style.top = `${run.position}px`;
    }
    if (measure) {
      dropCapEl.style.width = `${measure.width}px`;
      dropCapEl.style.height = `${measure.height}px`;
    }
    return dropCapEl;
  }
  renderListItemFragment(fragment, context, sdtBoundary) {
    try {
      const lookup = this.blockLookup.get(fragment.blockId);
      if (!lookup || lookup.block.kind !== "list" || lookup.measure.kind !== "list") {
        throw new Error(`DomPainter: missing list data for fragment ${fragment.blockId}`);
      }
      if (!this.doc) {
        throw new Error("DomPainter: document is not available");
      }
      const block = lookup.block;
      const measure = lookup.measure;
      const item = block.items.find((entry) => entry.id === fragment.itemId);
      const itemMeasure = measure.items.find((entry) => entry.itemId === fragment.itemId);
      if (!item || !itemMeasure) {
        throw new Error(`DomPainter: missing list item ${fragment.itemId}`);
      }
      const fragmentEl = this.doc.createElement("div");
      fragmentEl.classList.add(CLASS_NAMES$1.fragment, `${CLASS_NAMES$1.fragment}-list-item`);
      applyStyles$2(fragmentEl, fragmentStyles);
      fragmentEl.style.left = `${fragment.x - fragment.markerWidth}px`;
      fragmentEl.style.top = `${fragment.y}px`;
      fragmentEl.style.width = `${fragment.markerWidth + fragment.width}px`;
      fragmentEl.dataset.blockId = fragment.blockId;
      fragmentEl.dataset.itemId = fragment.itemId;
      const paragraphMetadata = item.paragraph.attrs?.sdt;
      this.applySdtDataset(fragmentEl, paragraphMetadata);
      applySdtContainerStyling(
        this.doc,
        fragmentEl,
        paragraphMetadata,
        item.paragraph.attrs?.containerSdt,
        sdtBoundary
      );
      if (fragment.continuesFromPrev) {
        fragmentEl.dataset.continuesFromPrev = "true";
      }
      if (fragment.continuesOnNext) {
        fragmentEl.dataset.continuesOnNext = "true";
      }
      const markerEl = this.doc.createElement("span");
      markerEl.classList.add("superdoc-list-marker");
      const wordLayout = item.paragraph.attrs?.wordLayout;
      const marker = wordLayout?.marker;
      if (marker) {
        markerEl.textContent = marker.markerText ?? null;
        markerEl.style.display = "inline-block";
        markerEl.style.width = `${Math.max(0, fragment.markerWidth - LIST_MARKER_GAP$1)}px`;
        markerEl.style.paddingRight = `${LIST_MARKER_GAP$1}px`;
        markerEl.style.textAlign = marker.justification ?? "left";
        markerEl.style.fontFamily = toCssFontFamily(marker.run.fontFamily) ?? marker.run.fontFamily;
        markerEl.style.fontSize = `${marker.run.fontSize}px`;
        if (marker.run.bold) markerEl.style.fontWeight = "bold";
        if (marker.run.italic) markerEl.style.fontStyle = "italic";
        if (marker.run.color) markerEl.style.color = marker.run.color;
        if (marker.run.letterSpacing) markerEl.style.letterSpacing = `${marker.run.letterSpacing}px`;
      } else {
        markerEl.textContent = item.marker.text;
        markerEl.style.display = "inline-block";
        markerEl.style.width = `${Math.max(0, fragment.markerWidth - LIST_MARKER_GAP$1)}px`;
        markerEl.style.paddingRight = `${LIST_MARKER_GAP$1}px`;
        if (item.marker.align) {
          markerEl.style.textAlign = item.marker.align;
        }
      }
      fragmentEl.appendChild(markerEl);
      const contentEl = this.doc.createElement("div");
      contentEl.classList.add("superdoc-list-content");
      this.applySdtDataset(contentEl, paragraphMetadata);
      contentEl.style.display = "inline-block";
      contentEl.style.position = "relative";
      contentEl.style.width = `${fragment.width}px`;
      const lines = itemMeasure.paragraph.lines.slice(fragment.fromLine, fragment.toLine);
      const contentAttrs = wordLayout ? item.paragraph.attrs : stripListIndent(item.paragraph.attrs);
      applyParagraphBlockStyles(contentEl, contentAttrs);
      const { shadingLayer, borderLayer } = createParagraphDecorationLayers(this.doc, fragment.width, contentAttrs);
      if (shadingLayer) {
        contentEl.appendChild(shadingLayer);
      }
      if (borderLayer) {
        contentEl.appendChild(borderLayer);
      }
      contentEl.style.textAlign = "left";
      const paraForList = {
        ...item.paragraph,
        attrs: { ...item.paragraph.attrs || {}, alignment: "left" }
      };
      lines.forEach((line, idx) => {
        const lineEl = this.renderLine(paraForList, line, context, fragment.width, fragment.fromLine + idx, true);
        contentEl.appendChild(lineEl);
      });
      fragmentEl.appendChild(contentEl);
      return fragmentEl;
    } catch (error) {
      console.error("[DomPainter] List item fragment rendering failed:", { fragment, error });
      return this.createErrorPlaceholder(fragment.blockId, error);
    }
  }
  renderImageFragment(fragment, context) {
    try {
      const lookup = this.blockLookup.get(fragment.blockId);
      if (!lookup || lookup.block.kind !== "image" || lookup.measure.kind !== "image") {
        throw new Error(`DomPainter: missing image block for fragment ${fragment.blockId}`);
      }
      if (!this.doc) {
        throw new Error("DomPainter: document is not available");
      }
      const block = lookup.block;
      const fragmentEl = this.doc.createElement("div");
      fragmentEl.classList.add(CLASS_NAMES$1.fragment, "superdoc-image-fragment");
      applyStyles$2(fragmentEl, fragmentStyles);
      this.applyFragmentFrame(fragmentEl, fragment, context.section);
      fragmentEl.style.height = `${fragment.height}px`;
      this.applySdtDataset(fragmentEl, block.attrs?.sdt);
      this.applyContainerSdtDataset(fragmentEl, block.attrs?.containerSdt);
      if (fragment.isAnchored && fragment.zIndex != null) {
        fragmentEl.style.zIndex = String(fragment.zIndex);
      }
      if (block.id) {
        fragmentEl.setAttribute("data-sd-block-id", block.id);
      }
      if (fragment.pmStart != null) {
        fragmentEl.dataset.pmStart = String(fragment.pmStart);
      }
      if (fragment.pmEnd != null) {
        fragmentEl.dataset.pmEnd = String(fragment.pmEnd);
      }
      if (fragment.metadata && !block.attrs?.vmlWatermark) {
        fragmentEl.setAttribute("data-image-metadata", JSON.stringify(fragment.metadata));
      }
      const img = this.doc.createElement("img");
      if (block.src) {
        img.src = block.src;
      }
      img.alt = block.alt ?? "";
      img.style.width = "100%";
      img.style.height = "100%";
      img.style.objectFit = block.objectFit ?? "contain";
      if (block.objectFit === "cover") {
        img.style.objectPosition = "left top";
      }
      img.style.display = block.display === "inline" ? "inline-block" : "block";
      const filters = [];
      if (block.gain != null || block.blacklevel != null) {
        if (block.gain && typeof block.gain === "string" && block.gain.endsWith("f")) {
          const contrast = Math.max(0, parseInt(block.gain) / 65536) * (2 / 3);
          if (contrast > 0) {
            filters.push(`contrast(${contrast})`);
          }
        }
        if (block.blacklevel && typeof block.blacklevel === "string" && block.blacklevel.endsWith("f")) {
          const brightness = Math.max(0, 1 + parseInt(block.blacklevel) / 327 / 100) * 1.3;
          if (brightness > 0) {
            filters.push(`brightness(${brightness})`);
          }
        }
        if (filters.length > 0) {
          img.style.filter = filters.join(" ");
        }
      }
      fragmentEl.appendChild(img);
      return fragmentEl;
    } catch (error) {
      console.error("[DomPainter] Image fragment rendering failed:", { fragment, error });
      return this.createErrorPlaceholder(fragment.blockId, error);
    }
  }
  renderDrawingFragment(fragment, context) {
    try {
      const lookup = this.blockLookup.get(fragment.blockId);
      if (!lookup || lookup.block.kind !== "drawing" || lookup.measure.kind !== "drawing") {
        throw new Error(`DomPainter: missing drawing block for fragment ${fragment.blockId}`);
      }
      if (!this.doc) {
        throw new Error("DomPainter: document is not available");
      }
      const block = lookup.block;
      const isVectorShapeBlock = block.kind === "drawing" && block.drawingKind === "vectorShape";
      const fragmentEl = this.doc.createElement("div");
      fragmentEl.classList.add(CLASS_NAMES$1.fragment, "superdoc-drawing-fragment");
      applyStyles$2(fragmentEl, fragmentStyles);
      this.applyFragmentFrame(fragmentEl, fragment, context.section);
      fragmentEl.style.height = `${fragment.height}px`;
      fragmentEl.style.position = "absolute";
      fragmentEl.style.overflow = "hidden";
      if (fragment.isAnchored && fragment.zIndex != null) {
        fragmentEl.style.zIndex = String(fragment.zIndex);
      }
      const innerWrapper = this.doc.createElement("div");
      innerWrapper.classList.add("superdoc-drawing-inner");
      innerWrapper.style.position = "absolute";
      innerWrapper.style.left = "50%";
      innerWrapper.style.top = "50%";
      innerWrapper.style.width = `${fragment.geometry.width}px`;
      innerWrapper.style.height = `${fragment.geometry.height}px`;
      innerWrapper.style.transformOrigin = "center";
      const scale = fragment.scale ?? 1;
      const transforms = ["translate(-50%, -50%)"];
      if (!isVectorShapeBlock) {
        transforms.push(`rotate(${fragment.geometry.rotation ?? 0}deg)`);
        transforms.push(`scaleX(${fragment.geometry.flipH ? -1 : 1})`);
        transforms.push(`scaleY(${fragment.geometry.flipV ? -1 : 1})`);
      }
      transforms.push(`scale(${scale})`);
      innerWrapper.style.transform = transforms.join(" ");
      innerWrapper.appendChild(this.renderDrawingContent(block, fragment, context));
      fragmentEl.appendChild(innerWrapper);
      return fragmentEl;
    } catch (error) {
      console.error("[DomPainter] Drawing fragment rendering failed:", { fragment, error });
      return this.createErrorPlaceholder(fragment.blockId, error);
    }
  }
  renderDrawingContent(block, fragment, context) {
    if (!this.doc) {
      throw new Error("DomPainter: document is not available");
    }
    if (block.drawingKind === "image") {
      return this.createDrawingImageElement(block);
    }
    if (block.drawingKind === "vectorShape") {
      return this.createVectorShapeElement(block, fragment.geometry, true, 1, 1, context);
    }
    if (block.drawingKind === "shapeGroup") {
      return this.createShapeGroupElement(block, context);
    }
    return this.createDrawingPlaceholder();
  }
  createDrawingImageElement(block) {
    const drawing = block;
    const img = this.doc.createElement("img");
    img.classList.add("superdoc-drawing-image");
    if (drawing.src) {
      img.src = drawing.src;
    }
    img.alt = drawing.alt ?? "";
    img.style.width = "100%";
    img.style.height = "100%";
    img.style.objectFit = drawing.objectFit ?? "contain";
    if (drawing.objectFit === "cover") {
      img.style.objectPosition = "left top";
    }
    img.style.display = "block";
    return img;
  }
  createVectorShapeElement(block, geometry, applyTransforms = false, groupScaleX = 1, groupScaleY = 1, context) {
    const container = this.doc.createElement("div");
    container.classList.add("superdoc-vector-shape");
    container.style.width = "100%";
    container.style.height = "100%";
    container.style.position = "relative";
    container.style.overflow = "hidden";
    const { offsetX, offsetY, innerWidth, innerHeight: innerHeight2 } = this.getEffectExtentMetrics(block);
    const contentContainer = this.doc.createElement("div");
    contentContainer.style.position = "absolute";
    contentContainer.style.left = `${offsetX}px`;
    contentContainer.style.top = `${offsetY}px`;
    contentContainer.style.width = `${innerWidth}px`;
    contentContainer.style.height = `${innerHeight2}px`;
    const svgMarkup = block.shapeKind ? this.tryCreatePresetSvg(block, innerWidth, innerHeight2) : null;
    if (svgMarkup) {
      const svgElement = this.parseSafeSvg(svgMarkup);
      if (svgElement) {
        svgElement.setAttribute("width", "100%");
        svgElement.setAttribute("height", "100%");
        svgElement.style.display = "block";
        if (block.fillColor && typeof block.fillColor === "object") {
          if ("type" in block.fillColor && block.fillColor.type === "gradient") {
            applyGradientToSVG$1(svgElement, block.fillColor);
          } else if ("type" in block.fillColor && block.fillColor.type === "solidWithAlpha") {
            applyAlphaToSVG$1(svgElement, block.fillColor);
          }
        }
        this.applyLineEnds(svgElement, block);
        if (applyTransforms && geometry) {
          this.applyVectorShapeTransforms(svgElement, geometry);
        }
        contentContainer.appendChild(svgElement);
        if (block.textContent && block.textContent.parts.length > 0) {
          const textDiv = this.createFallbackTextElement(
            block.textContent,
            block.textAlign ?? "center",
            block.textVerticalAlign,
            block.textInsets,
            groupScaleX,
            groupScaleY,
            context
          );
          contentContainer.appendChild(textDiv);
        }
        container.appendChild(contentContainer);
        return container;
      }
    }
    this.applyFallbackShapeStyle(contentContainer, block);
    if (block.textContent && block.textContent.parts.length > 0) {
      const textDiv = this.createFallbackTextElement(
        block.textContent,
        block.textAlign ?? "center",
        block.textVerticalAlign,
        block.textInsets,
        groupScaleX,
        groupScaleY,
        context
      );
      contentContainer.appendChild(textDiv);
    }
    if (applyTransforms && geometry) {
      this.applyVectorShapeTransforms(contentContainer, geometry);
    }
    container.appendChild(contentContainer);
    return container;
  }
  /**
   * Apply fill and stroke styles to a fallback shape container
   */
  applyFallbackShapeStyle(container, block) {
    if (block.fillColor === null) {
      container.style.background = "none";
    } else if (typeof block.fillColor === "string") {
      container.style.background = block.fillColor;
    } else if (typeof block.fillColor === "object" && "type" in block.fillColor) {
      if (block.fillColor.type === "solidWithAlpha") {
        const alpha = block.fillColor.alpha;
        const color = block.fillColor.color;
        container.style.background = color;
        container.style.opacity = alpha.toString();
      } else if (block.fillColor.type === "gradient") {
        container.style.background = "rgba(15, 23, 42, 0.1)";
      }
    } else {
      container.style.background = "rgba(15, 23, 42, 0.1)";
    }
    if (block.strokeColor === null) {
      container.style.border = "none";
    } else if (typeof block.strokeColor === "string") {
      const strokeWidth = block.strokeWidth ?? 1;
      container.style.border = `${strokeWidth}px solid ${block.strokeColor}`;
    } else {
      container.style.border = "1px solid rgba(15, 23, 42, 0.3)";
    }
  }
  /**
   * Create a fallback text element for shapes without SVG
   * @param textContent - Text content with formatting
   * @param textAlign - Horizontal text alignment
   * @param textVerticalAlign - Vertical text alignment (top, center, bottom)
   * @param textInsets - Text insets in pixels (top, right, bottom, left)
   * @param groupScaleX - Scale factor applied by parent group (for counter-scaling)
   * @param groupScaleY - Scale factor applied by parent group (for counter-scaling)
   */
  createFallbackTextElement(textContent2, textAlign, textVerticalAlign, textInsets, groupScaleX = 1, groupScaleY = 1, context) {
    const textDiv = this.doc.createElement("div");
    textDiv.style.position = "absolute";
    textDiv.style.top = "0";
    textDiv.style.left = "0";
    textDiv.style.width = "100%";
    textDiv.style.height = "100%";
    textDiv.style.display = "flex";
    textDiv.style.flexDirection = "column";
    const verticalAlign = textVerticalAlign ?? "center";
    if (verticalAlign === "top") {
      textDiv.style.justifyContent = "flex-start";
    } else if (verticalAlign === "bottom") {
      textDiv.style.justifyContent = "flex-end";
    } else {
      textDiv.style.justifyContent = "center";
    }
    if (textInsets) {
      textDiv.style.padding = `${textInsets.top}px ${textInsets.right}px ${textInsets.bottom}px ${textInsets.left}px`;
    } else {
      textDiv.style.padding = "10px";
    }
    textDiv.style.boxSizing = "border-box";
    textDiv.style.wordWrap = "break-word";
    textDiv.style.overflowWrap = "break-word";
    textDiv.style.overflow = "hidden";
    textDiv.style.minWidth = "0";
    textDiv.style.fontSize = "12px";
    textDiv.style.lineHeight = "1.2";
    if (groupScaleX !== 1 || groupScaleY !== 1) {
      const counterScaleX = 1 / groupScaleX;
      const counterScaleY = 1 / groupScaleY;
      textDiv.style.transform = `scale(${counterScaleX}, ${counterScaleY})`;
      textDiv.style.transformOrigin = "top left";
      textDiv.style.width = `${100 * groupScaleX}%`;
      textDiv.style.height = `${100 * groupScaleY}%`;
    }
    if (textAlign === "center") {
      textDiv.style.textAlign = "center";
    } else if (textAlign === "right" || textAlign === "r") {
      textDiv.style.textAlign = "right";
    } else {
      textDiv.style.textAlign = "left";
    }
    let currentParagraph = this.doc.createElement("div");
    currentParagraph.style.width = "100%";
    currentParagraph.style.minWidth = "0";
    currentParagraph.style.whiteSpace = "normal";
    const resolvePartText = (part) => {
      if (part.fieldType === "PAGE") {
        return context?.pageNumberText ?? String(context?.pageNumber ?? 1);
      }
      if (part.fieldType === "NUMPAGES") {
        return String(context?.totalPages ?? 1);
      }
      return part.text;
    };
    textContent2.parts.forEach((part) => {
      if (part.isLineBreak) {
        textDiv.appendChild(currentParagraph);
        currentParagraph = this.doc.createElement("div");
        currentParagraph.style.width = "100%";
        currentParagraph.style.minWidth = "0";
        currentParagraph.style.whiteSpace = "normal";
        if (part.isEmptyParagraph) {
          currentParagraph.style.minHeight = "1em";
        }
      } else {
        const span = this.doc.createElement("span");
        span.textContent = resolvePartText(part);
        if (part.formatting) {
          if (part.formatting.bold) {
            span.style.fontWeight = "bold";
          }
          if (part.formatting.italic) {
            span.style.fontStyle = "italic";
          }
          if (part.formatting.fontFamily) {
            span.style.fontFamily = part.formatting.fontFamily;
          }
          if (part.formatting.color) {
            const validatedColor = validateHexColor(part.formatting.color);
            if (validatedColor) {
              span.style.color = validatedColor;
            }
          }
          if (part.formatting.fontSize) {
            span.style.fontSize = `${part.formatting.fontSize}px`;
          }
        }
        currentParagraph.appendChild(span);
      }
    });
    textDiv.appendChild(currentParagraph);
    return textDiv;
  }
  tryCreatePresetSvg(block, widthOverride, heightOverride) {
    try {
      let fillColor;
      if (block.fillColor === null) {
        fillColor = "none";
      } else if (typeof block.fillColor === "string") {
        fillColor = block.fillColor;
      }
      const strokeColor = block.strokeColor === null ? "none" : typeof block.strokeColor === "string" ? block.strokeColor : void 0;
      if (block.shapeKind === "line" || block.shapeKind === "straightConnector1") {
        const width = widthOverride ?? block.geometry.width;
        const height = heightOverride ?? block.geometry.height;
        const stroke = strokeColor ?? "#000000";
        const strokeWidth = block.strokeWidth ?? 1;
        return `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
  <line x1="0" y1="0" x2="${width}" y2="${height}" stroke="${stroke}" stroke-width="${strokeWidth}" />
</svg>`;
      }
      return k0({
        preset: block.shapeKind ?? "",
        styleOverrides: () => ({
          fill: fillColor,
          stroke: strokeColor,
          strokeWidth: block.strokeWidth ?? void 0
        }),
        width: widthOverride ?? block.geometry.width,
        height: heightOverride ?? block.geometry.height
      });
    } catch (error) {
      console.warn(`[DomPainter] Unable to render preset shape "${block.shapeKind}":`, error);
      return null;
    }
  }
  parseSafeSvg(markup) {
    const DOMParserCtor = this.doc?.defaultView?.DOMParser ?? (typeof DOMParser !== "undefined" ? DOMParser : null);
    if (!DOMParserCtor) {
      return null;
    }
    const parser = new DOMParserCtor();
    const parsed = parser.parseFromString(markup, "image/svg+xml");
    if (!parsed || parsed.getElementsByTagName("parsererror").length > 0) {
      return null;
    }
    const svgElement = parsed.documentElement;
    if (!svgElement) return null;
    this.stripUnsafeSvgContent(svgElement);
    const imported = this.doc?.importNode(svgElement, true);
    return imported ? imported : null;
  }
  stripUnsafeSvgContent(element) {
    element.querySelectorAll("script").forEach((script) => script.remove());
    const sanitize = (node) => {
      Array.from(node.attributes).forEach((attr) => {
        if (attr.name.toLowerCase().startsWith("on")) {
          node.removeAttribute(attr.name);
        }
      });
      Array.from(node.children).forEach((child) => {
        sanitize(child);
      });
    };
    sanitize(element);
  }
  getEffectExtentMetrics(block) {
    const left2 = block.effectExtent?.left ?? 0;
    const top2 = block.effectExtent?.top ?? 0;
    const right2 = block.effectExtent?.right ?? 0;
    const bottom2 = block.effectExtent?.bottom ?? 0;
    const width = block.geometry.width ?? 0;
    const height = block.geometry.height ?? 0;
    const innerWidth = Math.max(0, width - left2 - right2);
    const innerHeight2 = Math.max(0, height - top2 - bottom2);
    return { offsetX: left2, offsetY: top2, innerWidth, innerHeight: innerHeight2 };
  }
  applyLineEnds(svgElement, block) {
    const lineEnds = block.lineEnds;
    if (!lineEnds) return;
    if (block.strokeColor === null) return;
    const strokeColor = typeof block.strokeColor === "string" ? block.strokeColor : "#000000";
    const strokeWidth = block.strokeWidth ?? 1;
    if (strokeWidth <= 0) return;
    const target = this.findLineEndTarget(svgElement);
    if (!target) return;
    const defs = this.ensureSvgDefs(svgElement);
    const baseId = this.sanitizeSvgId(`sd-line-${block.id}`);
    if (lineEnds.tail) {
      const id = `${baseId}-tail`;
      this.appendLineEndMarker(
        defs,
        id,
        lineEnds.tail,
        strokeColor,
        strokeWidth,
        true,
        block.effectExtent ?? void 0
      );
      target.setAttribute("marker-start", `url(#${id})`);
    }
    if (lineEnds.head) {
      const id = `${baseId}-head`;
      this.appendLineEndMarker(
        defs,
        id,
        lineEnds.head,
        strokeColor,
        strokeWidth,
        false,
        block.effectExtent ?? void 0
      );
      target.setAttribute("marker-end", `url(#${id})`);
    }
  }
  findLineEndTarget(svgElement) {
    const line = svgElement.querySelector("line");
    if (line) return line;
    const path = svgElement.querySelector("path");
    if (path) return path;
    const polyline = svgElement.querySelector("polyline");
    return polyline;
  }
  ensureSvgDefs(svgElement) {
    const existing = svgElement.querySelector("defs");
    if (existing) return existing;
    const defs = this.doc.createElementNS("http://www.w3.org/2000/svg", "defs");
    svgElement.insertBefore(defs, svgElement.firstChild);
    return defs;
  }
  appendLineEndMarker(defs, id, lineEnd, strokeColor, _strokeWidth, isStart, effectExtent) {
    if (defs.querySelector(`#${id}`)) return;
    const marker = this.doc.createElementNS("http://www.w3.org/2000/svg", "marker");
    marker.setAttribute("id", id);
    marker.setAttribute("viewBox", "0 0 10 10");
    marker.setAttribute("orient", "auto");
    const sizeScale = (value) => {
      if (value === "sm") return 0.75;
      if (value === "lg") return 1.25;
      return 1;
    };
    const effectMax = effectExtent ? Math.max(effectExtent.left ?? 0, effectExtent.right ?? 0, effectExtent.top ?? 0, effectExtent.bottom ?? 0) : 0;
    const useEffectExtent = Number.isFinite(effectMax) && effectMax > 0;
    const markerWidth = useEffectExtent ? effectMax * 2 : 4 * sizeScale(lineEnd.length);
    const markerHeight = useEffectExtent ? effectMax * 2 : 4 * sizeScale(lineEnd.width);
    marker.setAttribute("markerUnits", useEffectExtent ? "userSpaceOnUse" : "strokeWidth");
    marker.setAttribute("markerWidth", markerWidth.toString());
    marker.setAttribute("markerHeight", markerHeight.toString());
    marker.setAttribute("refX", isStart ? "0" : "10");
    marker.setAttribute("refY", "5");
    const shape = this.createLineEndShape(lineEnd.type ?? "triangle", strokeColor, isStart);
    marker.appendChild(shape);
    defs.appendChild(marker);
  }
  createLineEndShape(type, strokeColor, isStart) {
    const normalized = type.toLowerCase();
    if (normalized === "diamond") {
      const path2 = this.doc.createElementNS("http://www.w3.org/2000/svg", "path");
      path2.setAttribute("d", "M 0 5 L 5 0 L 10 5 L 5 10 Z");
      path2.setAttribute("fill", strokeColor);
      path2.setAttribute("stroke", "none");
      return path2;
    }
    if (normalized === "oval") {
      const circle = this.doc.createElementNS("http://www.w3.org/2000/svg", "circle");
      circle.setAttribute("cx", "5");
      circle.setAttribute("cy", "5");
      circle.setAttribute("r", "5");
      circle.setAttribute("fill", strokeColor);
      circle.setAttribute("stroke", "none");
      return circle;
    }
    const path = this.doc.createElementNS("http://www.w3.org/2000/svg", "path");
    const d = isStart ? "M 10 0 L 0 5 L 10 10 Z" : "M 0 0 L 10 5 L 0 10 Z";
    path.setAttribute("d", d);
    path.setAttribute("fill", strokeColor);
    path.setAttribute("stroke", "none");
    return path;
  }
  sanitizeSvgId(value) {
    return value.replace(/[^a-zA-Z0-9_-]/g, "");
  }
  applyVectorShapeTransforms(target, geometry) {
    const transforms = [];
    if (geometry.rotation) {
      transforms.push(`rotate(${geometry.rotation}deg)`);
    }
    if (geometry.flipH) {
      transforms.push("scaleX(-1)");
    }
    if (geometry.flipV) {
      transforms.push("scaleY(-1)");
    }
    if (transforms.length > 0) {
      target.style.transformOrigin = "center";
      target.style.transform = transforms.join(" ");
    } else {
      target.style.removeProperty("transform");
      target.style.removeProperty("transform-origin");
    }
  }
  createShapeGroupElement(block, context) {
    const groupEl = this.doc.createElement("div");
    groupEl.classList.add("superdoc-shape-group");
    groupEl.style.position = "relative";
    groupEl.style.width = "100%";
    groupEl.style.height = "100%";
    const groupTransform = block.groupTransform;
    let contentContainer = groupEl;
    const groupScaleX = 1;
    const groupScaleY = 1;
    if (groupTransform) {
      const inner = this.doc.createElement("div");
      inner.style.position = "absolute";
      inner.style.left = "0";
      inner.style.top = "0";
      const childWidth = groupTransform.childWidth ?? groupTransform.width ?? block.geometry.width ?? 0;
      const childHeight = groupTransform.childHeight ?? groupTransform.height ?? block.geometry.height ?? 0;
      inner.style.width = `${Math.max(1, childWidth)}px`;
      inner.style.height = `${Math.max(1, childHeight)}px`;
      const transforms = [];
      const offsetX = groupTransform.childX ?? 0;
      const offsetY = groupTransform.childY ?? 0;
      if (offsetX || offsetY) {
        transforms.push(`translate(${-offsetX}px, ${-offsetY}px)`);
      }
      if (transforms.length > 0) {
        inner.style.transformOrigin = "top left";
        inner.style.transform = transforms.join(" ");
      }
      groupEl.appendChild(inner);
      contentContainer = inner;
    }
    block.shapes.forEach((child) => {
      const childContent = this.createGroupChildContent(child, groupScaleX, groupScaleY, context);
      if (!childContent) return;
      const attrs = child.attrs ?? {};
      const wrapper = this.doc.createElement("div");
      wrapper.classList.add("superdoc-shape-group__child");
      wrapper.style.position = "absolute";
      wrapper.style.left = `${attrs.x ?? 0}px`;
      wrapper.style.top = `${attrs.y ?? 0}px`;
      const childWidthValue = typeof attrs.width === "number" ? attrs.width : block.geometry.width;
      const childHeightValue = typeof attrs.height === "number" ? attrs.height : block.geometry.height;
      wrapper.style.width = `${Math.max(1, childWidthValue)}px`;
      wrapper.style.height = `${Math.max(1, childHeightValue)}px`;
      wrapper.style.transformOrigin = "center";
      const transforms = [];
      if (attrs.rotation) {
        transforms.push(`rotate(${attrs.rotation}deg)`);
      }
      if (attrs.flipH) {
        transforms.push("scaleX(-1)");
      }
      if (attrs.flipV) {
        transforms.push("scaleY(-1)");
      }
      if (transforms.length > 0) {
        wrapper.style.transform = transforms.join(" ");
      }
      childContent.style.width = "100%";
      childContent.style.height = "100%";
      wrapper.appendChild(childContent);
      contentContainer.appendChild(wrapper);
    });
    return groupEl;
  }
  createGroupChildContent(child, groupScaleX = 1, groupScaleY = 1, context) {
    if (child.shapeType === "vectorShape" && "fillColor" in child.attrs) {
      const attrs = child.attrs;
      const childGeometry = {
        width: attrs.width ?? 0,
        height: attrs.height ?? 0,
        rotation: attrs.rotation ?? 0,
        flipH: attrs.flipH ?? false,
        flipV: attrs.flipV ?? false
      };
      const vectorChild = {
        drawingKind: "vectorShape",
        kind: "drawing",
        id: `${attrs.shapeId ?? child.shapeType}`,
        geometry: childGeometry,
        padding: void 0,
        margin: void 0,
        anchor: void 0,
        wrap: void 0,
        attrs: child.attrs,
        drawingContentId: void 0,
        drawingContent: void 0,
        shapeKind: attrs.kind,
        fillColor: attrs.fillColor,
        strokeColor: attrs.strokeColor,
        strokeWidth: attrs.strokeWidth,
        lineEnds: attrs.lineEnds,
        textContent: attrs.textContent,
        textAlign: attrs.textAlign,
        textVerticalAlign: attrs.textVerticalAlign,
        textInsets: attrs.textInsets
      };
      return this.createVectorShapeElement(vectorChild, childGeometry, false, groupScaleX, groupScaleY, context);
    }
    if (child.shapeType === "image" && "src" in child.attrs) {
      const attrs = child.attrs;
      const img = this.doc.createElement("img");
      img.src = attrs.src;
      img.alt = attrs.alt ?? "";
      img.style.objectFit = "contain";
      img.style.display = "block";
      return img;
    }
    return this.createDrawingPlaceholder();
  }
  createDrawingPlaceholder() {
    const placeholder = this.doc.createElement("div");
    placeholder.classList.add("superdoc-drawing-placeholder");
    placeholder.style.width = "100%";
    placeholder.style.height = "100%";
    placeholder.style.background = "repeating-linear-gradient(45deg, rgba(15,23,42,0.1), rgba(15,23,42,0.1) 6px, rgba(15,23,42,0.2) 6px, rgba(15,23,42,0.2) 12px)";
    placeholder.style.border = "1px dashed rgba(15, 23, 42, 0.3)";
    return placeholder;
  }
  renderTableFragment(fragment, context, sdtBoundary) {
    if (!this.doc) {
      throw new Error("DomPainter: document is not available");
    }
    const applyFragmentFrameWithSection = (el, frag) => {
      this.applyFragmentFrame(el, frag, context.section);
    };
    const renderLineForTableCell = (block, line, ctx2, lineIndex, isLastLine) => {
      const lastRun = block.runs.length > 0 ? block.runs[block.runs.length - 1] : null;
      const paragraphEndsWithLineBreak = lastRun?.kind === "lineBreak";
      const shouldSkipJustify = isLastLine && !paragraphEndsWithLineBreak;
      return this.renderLine(block, line, ctx2, void 0, lineIndex, shouldSkipJustify);
    };
    const renderDrawingContentForTableCell = (block) => {
      if (block.drawingKind === "image") {
        return this.createDrawingImageElement(block);
      }
      if (block.drawingKind === "shapeGroup") {
        return this.createShapeGroupElement(block, context);
      }
      if (block.drawingKind === "vectorShape") {
        return this.createVectorShapeElement(block, block.geometry, false, 1, 1, context);
      }
      return this.createDrawingPlaceholder();
    };
    return renderTableFragment({
      doc: this.doc,
      fragment,
      context,
      blockLookup: this.blockLookup,
      sdtBoundary,
      renderLine: renderLineForTableCell,
      renderDrawingContent: renderDrawingContentForTableCell,
      applyFragmentFrame: applyFragmentFrameWithSection,
      applySdtDataset: this.applySdtDataset.bind(this),
      applyStyles: applyStyles$2
    });
  }
  /**
   * Extract link data from a run, including sanitization.
   * @returns Sanitized link data or null if invalid/missing
   */
  extractLinkData(run) {
    if (run.kind === "tab" || run.kind === "image" || run.kind === "lineBreak") {
      return null;
    }
    const link = run.link;
    if (!link) {
      return null;
    }
    return this.buildLinkRenderData(link);
  }
  buildLinkRenderData(link) {
    const dataset = buildLinkDataset(link);
    const sanitized = typeof link.href === "string" ? sanitizeHref(link.href) : null;
    const anchorHref = normalizeAnchor(link.anchor ?? link.name ?? "");
    let href = sanitized?.href ?? anchorHref;
    if (link.version === 2) {
      href = appendDocLocation(href, link.docLocation ?? null);
    }
    if (sanitized) {
      if (sanitized.href && typeof link.href === "string") {
        const hostStartIndex = link.href.indexOf("://") + 3;
        let hostEndIndex = link.href.indexOf("/", hostStartIndex);
        if (hostEndIndex === -1) {
          hostEndIndex = link.href.indexOf("?", hostStartIndex);
        }
        if (hostEndIndex === -1) {
          hostEndIndex = link.href.indexOf("#", hostStartIndex);
        }
        if (hostEndIndex === -1) {
          hostEndIndex = link.href.length;
        }
        link.href.slice(hostStartIndex, hostEndIndex);
      }
    }
    if (sanitized && sanitized.href.length > MAX_HREF_LENGTH) {
      console.warn(`[DomPainter] Rejecting URL exceeding ${MAX_HREF_LENGTH} characters`);
      return { blocked: true, dataset: { [LINK_DATASET_KEYS.blocked]: "true" } };
    }
    if (!href) {
      if (typeof link.href === "string" && link.href.trim()) {
        dataset[LINK_DATASET_KEYS.blocked] = "true";
        console.warn(`[DomPainter] Blocked potentially unsafe URL: ${link.href.slice(0, 50)}`);
        return { blocked: true, dataset };
      }
      const hadAnchor = (link.anchor ?? link.name ?? null) != null;
      if (Object.keys(dataset).length > 0 || hadAnchor) {
        dataset[LINK_DATASET_KEYS.blocked] = "true";
        return { blocked: true, dataset };
      }
      return null;
    }
    const target = resolveLinkTarget(link, sanitized);
    const rel = resolveLinkRel(link, target);
    const tooltipSource = link.version === 2 ? link.tooltip ?? link.title : link.title;
    const tooltipResult = tooltipSource ? encodeTooltip(tooltipSource) : null;
    const tooltip = tooltipResult?.text ?? null;
    if (tooltipResult?.wasTruncated) {
      dataset[LINK_DATASET_KEYS.truncated] = "true";
    }
    return {
      href,
      target,
      rel,
      tooltip,
      dataset: Object.keys(dataset).length > 0 ? dataset : void 0,
      blocked: false
    };
  }
  /**
   * Apply tooltip accessibility using aria-describedby for better screen reader support.
   * Creates a visually-hidden element containing the tooltip text and links it to the anchor.
   *
   * @param elem - The anchor element to enhance
   * @param tooltip - The tooltip text to make accessible
   * @returns The unique ID generated for this link
   */
  applyTooltipAccessibility(elem, tooltip) {
    const linkId = `superdoc-link-${++this.linkIdCounter}`;
    elem.id = linkId;
    if (!tooltip || !this.doc) return linkId;
    elem.setAttribute("title", tooltip);
    const descId = `link-desc-${linkId}`;
    const descElem = this.doc.createElement("span");
    descElem.id = descId;
    descElem.className = "sr-only";
    descElem.textContent = tooltip;
    if (elem.parentElement) {
      elem.parentElement.appendChild(descElem);
      elem.setAttribute("aria-describedby", descId);
    } else {
      console.warn("[DomPainter] Unable to add aria-describedby for tooltip (element not in DOM)");
    }
    return linkId;
  }
  /**
   * Enhance accessibility of a link element with ARIA labels and attributes.
   * Adds descriptive ARIA labels for ambiguous text and target=_blank links (WCAG 2.4.4).
   *
   * @param elem - The anchor element to enhance
   * @param linkData - Link metadata including href and target
   * @param textContent - The visible link text to analyze for ambiguity
   */
  enhanceAccessibility(elem, linkData, textContent2) {
    if (!linkData.href) return;
    const trimmedText = textContent2.trim().toLowerCase();
    if (AMBIGUOUS_LINK_PATTERNS.test(trimmedText)) {
      try {
        const url = new URL(linkData.href);
        const hostname = url.hostname.replace(/^www\./, "");
        const ariaLabel = `${textContent2.trim()} - ${hostname}`;
        elem.setAttribute("aria-label", ariaLabel);
        return;
      } catch {
        elem.setAttribute("aria-label", `${textContent2.trim()} - external link`);
        return;
      }
    }
    if (linkData.target === "_blank" && !elem.getAttribute("aria-label")) {
      elem.setAttribute("aria-label", `${textContent2.trim()} (opens in new tab)`);
    }
  }
  /**
   * Apply link attributes to an anchor element.
   */
  applyLinkAttributes(elem, linkData) {
    if (!linkData.href) return;
    elem.href = linkData.href;
    elem.classList.add("superdoc-link");
    if (linkData.target) {
      elem.target = linkData.target;
    } else {
      elem.removeAttribute("target");
    }
    if (linkData.rel) {
      elem.rel = linkData.rel;
    } else {
      elem.removeAttribute("rel");
    }
    if (linkData.tooltip) {
      elem.title = linkData.tooltip;
    } else {
      elem.removeAttribute("title");
    }
    elem.setAttribute("role", "link");
    elem.setAttribute("tabindex", "0");
  }
  /**
   * Render a single run as an HTML element (span or anchor).
   */
  /**
   * Type guard to check if a run is an image run.
   */
  isImageRun(run) {
    return run.kind === "image";
  }
  /**
   * Type guard to check if a run is a line break run.
   */
  isLineBreakRun(run) {
    return run.kind === "lineBreak";
  }
  /**
   * Type guard to check if a run is a break run.
   */
  isBreakRun(run) {
    return run.kind === "break";
  }
  /**
   * Type guard to check if a run is a field annotation run.
   */
  isFieldAnnotationRun(run) {
    return run.kind === "fieldAnnotation";
  }
  renderRun(run, context, trackedConfig) {
    if (this.isImageRun(run)) {
      return this.renderImageRun(run);
    }
    if (this.isFieldAnnotationRun(run)) {
      return this.renderFieldAnnotationRun(run);
    }
    if (this.isLineBreakRun(run)) {
      return null;
    }
    if (this.isBreakRun(run)) {
      return null;
    }
    if (!("text" in run) || !run.text || !this.doc) {
      return null;
    }
    const linkData = this.extractLinkData(run);
    const isActiveLink = !!(linkData && !linkData.blocked && linkData.href);
    const elem = isActiveLink ? this.doc.createElement("a") : this.doc.createElement("span");
    const text = resolveRunText(run, context);
    elem.textContent = text;
    if (linkData?.dataset) {
      applyLinkDataset(elem, linkData.dataset);
    }
    if (linkData?.blocked) {
      elem.dataset[LINK_DATASET_KEYS.blocked] = "true";
      elem.setAttribute("role", "text");
      elem.setAttribute("aria-label", "Invalid link - not clickable");
    }
    if (isActiveLink && linkData) {
      this.applyLinkAttributes(elem, linkData);
      this.enhanceAccessibility(elem, linkData, text);
      if (linkData.tooltip) {
        this.pendingTooltips.set(elem, linkData.tooltip);
      }
    }
    applyRunStyles(elem, run, isActiveLink);
    const textRun = run;
    const commentAnnotations = textRun.comments;
    const hasAnyComment = !!commentAnnotations?.length;
    const commentHighlight = getCommentHighlight(textRun, this.activeCommentId);
    if (commentHighlight.color && !textRun.highlight && hasAnyComment) {
      elem.style.backgroundColor = commentHighlight.color;
      if (commentHighlight.hasNestedComments && commentHighlight.baseColor) {
        const borderColor = `${commentHighlight.baseColor}99`;
        elem.style.boxShadow = `inset 1px 0 0 ${borderColor}, inset -1px 0 0 ${borderColor}`;
      } else {
        elem.style.boxShadow = "";
      }
    }
    if (hasAnyComment) {
      elem.dataset.commentIds = commentAnnotations.map((c2) => c2.commentId).join(",");
      if (commentAnnotations.some((c2) => c2.internal)) {
        elem.dataset.commentInternal = "true";
      }
      elem.classList.add("superdoc-comment-highlight");
    }
    elem.style.zIndex = "1";
    applyRunDataAttributes(elem, run.dataAttrs);
    assertPmPositions(run, "paragraph text run");
    if (run.pmStart != null) elem.dataset.pmStart = String(run.pmStart);
    if (run.pmEnd != null) elem.dataset.pmEnd = String(run.pmEnd);
    elem.dataset.layoutEpoch = String(this.layoutEpoch);
    if (trackedConfig) {
      this.applyTrackedChangeDecorations(elem, run, trackedConfig);
    }
    this.applySdtDataset(elem, run.sdt);
    return elem;
  }
  /**
   * Renders an ImageRun as an inline <img> element.
   *
   * SECURITY NOTES:
   * - Data URLs are validated against VALID_IMAGE_DATA_URL regex to ensure proper format
   * - Size limit (MAX_DATA_URL_LENGTH) prevents DoS attacks from extremely large images
   * - Only allows safe image MIME types (png, jpeg, gif, etc.) with base64 encoding
   * - Non-data URLs are sanitized through sanitizeUrl to prevent XSS
   *
   * METADATA ATTRIBUTE:
   * - Adds `data-image-metadata` attribute to enable interactive resizing via ImageResizeOverlay
   * - Metadata includes: originalWidth, originalHeight, aspectRatio, min/max dimensions
   * - Only added when run.width > 0 && run.height > 0 to prevent invalid metadata
   * - Max dimensions: 3x original size or 1000px (whichever is larger)
   * - Min dimensions: 20px to ensure visibility and interactivity
   *
   * @param run - The ImageRun to render containing image source, dimensions, and spacing
   * @returns HTMLElement (img) or null if src is missing or invalid
   *
   * @example
   * ```typescript
   * // Valid data URL with metadata
   * renderImageRun({ kind: 'image', src: 'data:image/png;base64,iVBORw...', width: 100, height: 100 })
   * // Returns: <img> element with data-image-metadata attribute
   *
   * // Invalid dimensions - no metadata
   * renderImageRun({ kind: 'image', src: 'data:image/png;base64,iVBORw...', width: 0, height: 0 })
   * // Returns: <img> element WITHOUT data-image-metadata attribute
   *
   * // Invalid MIME type
   * renderImageRun({ kind: 'image', src: 'data:text/html;base64,PHNjcmlwdD4...', width: 100, height: 100 })
   * // Returns: null (blocked)
   *
   * // HTTP URL
   * renderImageRun({ kind: 'image', src: 'https://example.com/image.png', width: 100, height: 100 })
   * // Returns: <img> element (after sanitization) with data-image-metadata attribute
   * ```
   */
  renderImageRun(run) {
    if (!this.doc || !run.src) {
      return null;
    }
    const img = this.doc.createElement("img");
    img.classList.add("superdoc-inline-image");
    const isDataUrl = typeof run.src === "string" && run.src.startsWith("data:");
    if (isDataUrl) {
      if (run.src.length > MAX_DATA_URL_LENGTH) {
        return null;
      }
      if (!VALID_IMAGE_DATA_URL.test(run.src)) {
        return null;
      }
      img.src = run.src;
    } else {
      const sanitized = sanitizeUrl(run.src);
      if (sanitized) {
        img.src = sanitized;
      } else {
        return null;
      }
    }
    img.width = run.width;
    img.height = run.height;
    if (run.width > 0 && run.height > 0) {
      const aspectRatio = run.width / run.height;
      const inlineImageMetadata = {
        originalWidth: run.width,
        originalHeight: run.height,
        // Max dimensions: MAX_RESIZE_MULTIPLIER x original size or FALLBACK_MAX_DIMENSION, whichever is larger
        // This provides generous constraints while preventing excessive scaling
        maxWidth: Math.max(run.width * MAX_RESIZE_MULTIPLIER, FALLBACK_MAX_DIMENSION),
        maxHeight: Math.max(run.height * MAX_RESIZE_MULTIPLIER, FALLBACK_MAX_DIMENSION),
        aspectRatio,
        // Min dimensions: MIN_IMAGE_DIMENSION to ensure images remain visible and interactive
        minWidth: MIN_IMAGE_DIMENSION,
        minHeight: MIN_IMAGE_DIMENSION
      };
      img.setAttribute("data-image-metadata", JSON.stringify(inlineImageMetadata));
    }
    img.alt = run.alt ?? "";
    if (run.title) {
      img.title = run.title;
    }
    img.style.display = "inline-block";
    img.style.verticalAlign = run.verticalAlign ?? "bottom";
    if (run.distTop) {
      img.style.marginTop = `${run.distTop}px`;
    }
    if (run.distBottom) {
      img.style.marginBottom = `${run.distBottom}px`;
    }
    if (run.distLeft) {
      img.style.marginLeft = `${run.distLeft}px`;
    }
    if (run.distRight) {
      img.style.marginRight = `${run.distRight}px`;
    }
    img.style.zIndex = "1";
    assertPmPositions(run, "inline image run");
    if (run.pmStart != null) {
      img.dataset.pmStart = String(run.pmStart);
    }
    if (run.pmEnd != null) {
      img.dataset.pmEnd = String(run.pmEnd);
    }
    img.dataset.layoutEpoch = String(this.layoutEpoch);
    this.applySdtDataset(img, run.sdt);
    if (run.dataAttrs) {
      applyRunDataAttributes(img, run.dataAttrs);
    }
    return img;
  }
  /**
   * Renders a FieldAnnotationRun as an inline "pill" element matching super-editor's visual appearance.
   *
   * Field annotations are styled inline elements that display form fields with:
   * - Outer span with border, border-radius, padding, and background color
   * - Inner span containing the displayLabel or type-specific content (image, link, etc.)
   *
   * @param run - The FieldAnnotationRun to render containing field configuration and styling
   * @returns HTMLElement (span) or null if document is not available
   *
   * @example
   * ```typescript
   * // Text variant
   * renderFieldAnnotationRun({ kind: 'fieldAnnotation', variant: 'text', displayLabel: 'Full Name', fieldColor: '#980043' })
   * // Returns: <span class="annotation" style="border: 2px solid #b015b3; ..."><span class="annotation-content">Full Name</span></span>
   *
   * // Image variant with imageSrc
   * renderFieldAnnotationRun({ kind: 'fieldAnnotation', variant: 'image', displayLabel: 'Photo', imageSrc: 'data:image/png;...' })
   * // Returns: <span class="annotation"><span class="annotation-content"><img src="..." /></span></span>
   *
   * // Link variant
   * renderFieldAnnotationRun({ kind: 'fieldAnnotation', variant: 'link', displayLabel: 'Website', linkUrl: 'https://example.com' })
   * // Returns: <span class="annotation"><span class="annotation-content"><a href="...">https://example.com</a></span></span>
   * ```
   */
  renderFieldAnnotationRun(run) {
    if (!this.doc) {
      return null;
    }
    if (run.hidden) {
      const hidden = this.doc.createElement("span");
      hidden.style.display = "none";
      if (run.pmStart != null) hidden.dataset.pmStart = String(run.pmStart);
      if (run.pmEnd != null) hidden.dataset.pmEnd = String(run.pmEnd);
      hidden.dataset.layoutEpoch = String(this.layoutEpoch);
      return hidden;
    }
    const defaultBorderColor = "#b015b3";
    const defaultFieldColor = "#980043";
    const annotation = this.doc.createElement("span");
    annotation.classList.add("annotation");
    annotation.setAttribute("aria-label", "Field annotation");
    const showHighlight = run.highlighted !== false;
    if (showHighlight) {
      const borderColor = run.borderColor || defaultBorderColor;
      annotation.style.border = `2px solid ${borderColor}`;
      annotation.style.borderRadius = "2px";
      annotation.style.padding = "1px 2px";
      annotation.style.boxSizing = "border-box";
      const fieldColor = run.fieldColor || defaultFieldColor;
      const bgColor = fieldColor.length === 7 ? `${fieldColor}33` : fieldColor;
      if (run.textHighlight) {
        annotation.style.backgroundColor = run.textHighlight;
      } else {
        annotation.style.backgroundColor = bgColor;
      }
    }
    if (run.visibility === "hidden") {
      annotation.style.visibility = "hidden";
    }
    if (run.size) {
      if (run.size.width) {
        const requiresImage = run.variant === "image" || run.variant === "signature";
        if (!requiresImage || run.imageSrc) {
          annotation.style.width = `${run.size.width}px`;
          annotation.style.display = "inline-block";
          annotation.style.overflow = "hidden";
        }
      }
      if (run.size.height && run.variant !== "html") {
        const requiresImage = run.variant === "image" || run.variant === "signature";
        if (!requiresImage || run.imageSrc) {
          annotation.style.height = `${run.size.height}px`;
        }
      }
    }
    if (run.fontFamily) {
      annotation.style.fontFamily = run.fontFamily;
    }
    if (run.fontSize) {
      const fontSize2 = typeof run.fontSize === "number" ? `${run.fontSize}pt` : run.fontSize;
      annotation.style.fontSize = fontSize2;
    }
    if (run.textColor) {
      annotation.style.color = run.textColor;
    }
    if (run.bold) {
      annotation.style.fontWeight = "bold";
    }
    if (run.italic) {
      annotation.style.fontStyle = "italic";
    }
    if (run.underline) {
      annotation.style.textDecoration = "underline";
    }
    annotation.style.zIndex = "1";
    const content = this.doc.createElement("span");
    content.classList.add("annotation-content");
    content.style.pointerEvents = "none";
    content.setAttribute("contenteditable", "false");
    switch (run.variant) {
      case "image":
      case "signature": {
        if (run.imageSrc) {
          const img = this.doc.createElement("img");
          const isDataUrl = run.imageSrc.startsWith("data:");
          if (isDataUrl) {
            if (run.imageSrc.length <= MAX_DATA_URL_LENGTH && VALID_IMAGE_DATA_URL.test(run.imageSrc)) {
              img.src = run.imageSrc;
            } else {
              content.textContent = run.displayLabel;
              break;
            }
          } else {
            const sanitized = sanitizeHref(run.imageSrc);
            if (sanitized) {
              img.src = sanitized.href;
            } else {
              content.textContent = run.displayLabel;
              break;
            }
          }
          img.alt = run.displayLabel;
          img.style.height = "auto";
          img.style.maxWidth = "100%";
          img.style.pointerEvents = "none";
          img.style.verticalAlign = "middle";
          if (run.variant === "signature") {
            img.style.maxHeight = "28px";
          }
          content.appendChild(img);
          annotation.style.display = "inline-block";
          content.style.display = "inline-block";
          annotation.style.lineHeight = "normal";
          content.style.lineHeight = "normal";
        } else {
          content.textContent = run.displayLabel || (run.variant === "signature" ? "Signature" : "");
        }
        break;
      }
      case "link": {
        if (run.linkUrl) {
          const link = this.doc.createElement("a");
          const sanitized = sanitizeHref(run.linkUrl);
          if (sanitized) {
            link.href = sanitized.href;
            link.target = "_blank";
            link.rel = "noopener noreferrer";
            link.textContent = run.linkUrl;
            link.style.textDecoration = "none";
            content.style.pointerEvents = "all";
            content.appendChild(link);
          } else {
            content.textContent = run.displayLabel;
          }
        } else {
          content.textContent = run.displayLabel;
        }
        break;
      }
      case "html": {
        if (run.rawHtml && typeof run.rawHtml === "string") {
          content.innerHTML = run.rawHtml.trim();
          annotation.style.display = "inline-block";
          content.style.display = "inline-block";
          annotation.style.lineHeight = "normal";
          content.style.lineHeight = "normal";
        } else {
          content.textContent = run.displayLabel;
        }
        break;
      }
      case "text":
      case "checkbox":
      default: {
        content.textContent = run.displayLabel;
        break;
      }
    }
    annotation.appendChild(content);
    annotation.dataset.type = run.variant;
    if (run.fieldId) {
      annotation.dataset.fieldId = run.fieldId;
    }
    if (run.fieldType) {
      annotation.dataset.fieldType = run.fieldType;
    }
    annotation.draggable = true;
    annotation.dataset.draggable = "true";
    if (run.displayLabel) {
      annotation.dataset.displayLabel = run.displayLabel;
    }
    if (run.variant) {
      annotation.dataset.variant = run.variant;
    }
    assertPmPositions(run, "field annotation run");
    if (run.pmStart != null) {
      annotation.dataset.pmStart = String(run.pmStart);
    }
    if (run.pmEnd != null) {
      annotation.dataset.pmEnd = String(run.pmEnd);
    }
    annotation.dataset.layoutEpoch = String(this.layoutEpoch);
    this.applySdtDataset(annotation, run.sdt);
    return annotation;
  }
  /**
   * Renders a single line of a paragraph block.
   *
   * @param block - The paragraph block containing the line
   * @param line - The line measurement data
   * @param context - Rendering context with fragment information
   * @param availableWidthOverride - Optional override for available width used in justification calculations
   * @param lineIndex - Optional zero-based index of the line within the fragment
   * @param skipJustify - When true, prevents justification even if alignment is 'justify'
   * @returns The rendered line element
   */
  renderLine(block, line, context, availableWidthOverride, lineIndex, skipJustify) {
    if (!this.doc) {
      throw new Error("DomPainter: document is not available");
    }
    const el = this.doc.createElement("div");
    el.classList.add(CLASS_NAMES$1.line);
    applyStyles$2(el, lineStyles(line.lineHeight));
    el.dataset.layoutEpoch = String(this.layoutEpoch);
    const styleId = block.attrs?.styleId;
    if (styleId) {
      el.setAttribute("styleid", styleId);
    }
    const alignment2 = block.attrs?.alignment;
    if (alignment2 === "center" || alignment2 === "right") {
      el.style.textAlign = alignment2;
    } else {
      el.style.textAlign = "left";
    }
    const lineRange = computeLinePmRange$1(block, line);
    if (lineRange.pmStart != null) {
      el.dataset.pmStart = String(lineRange.pmStart);
    }
    if (lineRange.pmEnd != null) {
      el.dataset.pmEnd = String(lineRange.pmEnd);
    }
    let runsForLine = sliceRunsForLine$1(block, line);
    const trackedConfig = this.resolveTrackedChangesConfig(block);
    if (runsForLine.length === 0) {
      const span = this.doc.createElement("span");
      span.classList.add("superdoc-empty-run");
      if (lineRange.pmStart != null) {
        span.dataset.pmStart = String(lineRange.pmStart);
      }
      if (lineRange.pmEnd != null) {
        span.dataset.pmEnd = String(lineRange.pmEnd);
      }
      span.innerHTML = "&nbsp;";
      el.appendChild(span);
    }
    if (line.leaders && line.leaders.length > 0) {
      line.leaders.forEach((ld) => {
        const leaderEl = this.doc.createElement("div");
        leaderEl.classList.add("superdoc-leader");
        leaderEl.setAttribute("data-style", ld.style);
        leaderEl.style.position = "absolute";
        leaderEl.style.left = `${ld.from}px`;
        leaderEl.style.width = `${Math.max(0, ld.to - ld.from)}px`;
        const baselineOffset = Math.max(1, Math.round(Math.max(1, line.descent * 0.5)));
        leaderEl.style.bottom = `${baselineOffset}px`;
        leaderEl.style.height = ld.style === "heavy" ? "2px" : "1px";
        leaderEl.style.pointerEvents = "none";
        leaderEl.style.zIndex = "0";
        if (ld.style === "dot" || ld.style === "middleDot") {
          leaderEl.style.borderBottom = "1px dotted currentColor";
        } else if (ld.style === "hyphen") {
          leaderEl.style.borderBottom = "1px dashed currentColor";
        } else if (ld.style === "underscore") {
          leaderEl.style.borderBottom = "1px solid currentColor";
        } else if (ld.style === "heavy") {
          leaderEl.style.borderBottom = "2px solid currentColor";
        }
        el.appendChild(leaderEl);
      });
    }
    if (line.bars && line.bars.length > 0) {
      line.bars.forEach((bar) => {
        const barEl = this.doc.createElement("div");
        barEl.classList.add("superdoc-tab-bar");
        barEl.style.position = "absolute";
        barEl.style.left = `${bar.x}px`;
        barEl.style.top = "0px";
        barEl.style.bottom = "0px";
        barEl.style.width = "1px";
        barEl.style.background = "currentColor";
        barEl.style.opacity = "0.6";
        barEl.style.pointerEvents = "none";
        el.appendChild(barEl);
      });
    }
    const hasExplicitPositioning = line.segments?.some((seg) => seg.x !== void 0);
    const availableWidth = availableWidthOverride ?? line.maxWidth ?? line.width;
    const justifyShouldApply = shouldApplyJustify({
      alignment: block.attrs?.alignment,
      hasExplicitPositioning: hasExplicitPositioning ?? false,
      // Caller already folds last-line + trailing lineBreak behavior into skipJustify.
      isLastLineOfParagraph: false,
      paragraphEndsWithLineBreak: false,
      skipJustifyOverride: skipJustify
    });
    const countSpaces2 = (text) => {
      let count = 0;
      for (let i = 0; i < text.length; i += 1) {
        if (SPACE_CHARS$1.has(text[i])) count += 1;
      }
      return count;
    };
    if (justifyShouldApply) {
      const stableDataAttrs = (attrs) => {
        if (!attrs) return void 0;
        const keys2 = Object.keys(attrs).sort();
        const out = {};
        keys2.forEach((key2) => {
          out[key2] = attrs[key2];
        });
        return out;
      };
      const mergeSignature = (run) => JSON.stringify({
        kind: run.kind ?? "text",
        fontFamily: run.fontFamily,
        fontSize: run.fontSize,
        bold: run.bold ?? false,
        italic: run.italic ?? false,
        letterSpacing: run.letterSpacing ?? null,
        color: run.color ?? null,
        underline: run.underline ?? null,
        strike: run.strike ?? false,
        highlight: run.highlight ?? null,
        textTransform: run.textTransform ?? null,
        token: run.token ?? null,
        pageRefMetadata: run.pageRefMetadata ?? null,
        trackedChange: run.trackedChange ?? null,
        sdt: run.sdt ?? null,
        link: run.link ?? null,
        comments: run.comments ?? null,
        dataAttrs: stableDataAttrs(run.dataAttrs) ?? null
      });
      const isWhitespaceOnly = (text) => {
        if (text.length === 0) return false;
        for (let i = 0; i < text.length; i += 1) {
          if (!SPACE_CHARS$1.has(text[i])) return false;
        }
        return true;
      };
      const cloneTextRun = (run) => ({
        ...run,
        comments: run.comments ? [...run.comments] : void 0,
        dataAttrs: run.dataAttrs ? { ...run.dataAttrs } : void 0,
        underline: run.underline ? { ...run.underline } : void 0,
        pageRefMetadata: run.pageRefMetadata ? { ...run.pageRefMetadata } : void 0
      });
      const normalized = runsForLine.map((run) => {
        if (run.kind !== "text" && run.kind !== void 0 || !("text" in run)) return run;
        return cloneTextRun(run);
      });
      const merged = [];
      for (let i = 0; i < normalized.length; i += 1) {
        const run = normalized[i];
        if (run.kind !== "text" && run.kind !== void 0 || !("text" in run)) {
          merged.push(run);
          continue;
        }
        const textRun = run;
        if (!isWhitespaceOnly(textRun.text ?? "")) {
          merged.push(textRun);
          continue;
        }
        const prev = merged[merged.length - 1];
        if (prev && (prev.kind === "text" || prev.kind === void 0) && "text" in prev) {
          const prevTextRun = prev;
          if (mergeSignature(prevTextRun) === mergeSignature(textRun)) {
            const extra = textRun.text ?? "";
            prevTextRun.text = (prevTextRun.text ?? "") + extra;
            if (prevTextRun.pmStart != null) {
              prevTextRun.pmEnd = prevTextRun.pmStart + prevTextRun.text.length;
            } else if (prevTextRun.pmEnd != null) {
              prevTextRun.pmEnd = prevTextRun.pmEnd + extra.length;
            }
            continue;
          }
        }
        const next = normalized[i + 1];
        if (next && (next.kind === "text" || next.kind === void 0) && "text" in next) {
          const nextTextRun = next;
          if (mergeSignature(nextTextRun) === mergeSignature(textRun)) {
            const extra = textRun.text ?? "";
            nextTextRun.text = extra + (nextTextRun.text ?? "");
            if (textRun.pmStart != null) {
              nextTextRun.pmStart = textRun.pmStart;
            } else if (nextTextRun.pmStart != null) {
              nextTextRun.pmStart = nextTextRun.pmStart - extra.length;
            }
            if (nextTextRun.pmStart != null && nextTextRun.pmEnd == null) {
              nextTextRun.pmEnd = nextTextRun.pmStart + nextTextRun.text.length;
            }
            continue;
          }
        }
        merged.push(textRun);
      }
      runsForLine = merged;
      const hasNonSpaceText = runsForLine.some(
        (run) => (run.kind === "text" || run.kind === void 0) && "text" in run && (run.text ?? "").trim().length > 0
      );
      if (hasNonSpaceText) {
        for (let i = runsForLine.length - 1; i >= 0; i -= 1) {
          const run = runsForLine[i];
          if (run.kind !== "text" && run.kind !== void 0 || !("text" in run)) continue;
          const text = run.text ?? "";
          let trimCount = 0;
          for (let j = text.length - 1; j >= 0 && text[j] === " "; j -= 1) {
            trimCount += 1;
          }
          if (trimCount === 0) break;
          const nextText = text.slice(0, Math.max(0, text.length - trimCount));
          if (nextText.length === 0) {
            runsForLine.splice(i, 1);
            continue;
          }
          run.text = nextText;
          if (run.pmEnd != null) {
            run.pmEnd = run.pmEnd - trimCount;
          }
          break;
        }
      }
    }
    const spaceCount = line.spaceCount ?? runsForLine.reduce((sum, run) => {
      if (run.kind !== "text" && run.kind !== void 0 || !("text" in run) || run.text == null) return sum;
      return sum + countSpaces2(run.text);
    }, 0);
    const lineWidth = line.naturalWidth ?? line.width;
    const spacingPerSpace = calculateJustifySpacing({
      lineWidth,
      availableWidth,
      spaceCount,
      shouldJustify: justifyShouldApply
    });
    if (spacingPerSpace !== 0) {
      el.style.wordSpacing = `${spacingPerSpace}px`;
    }
    if (hasExplicitPositioning && line.segments) {
      const paraIndent = block.attrs?.indent;
      const indentLeft = paraIndent?.left ?? 0;
      const firstLine = paraIndent?.firstLine ?? 0;
      const hanging = paraIndent?.hanging ?? 0;
      const isFirstLineOfPara = lineIndex === 0 || lineIndex === void 0;
      const firstLineOffsetForCumX = isFirstLineOfPara ? firstLine - hanging : 0;
      const wordLayoutValue = block.attrs?.wordLayout;
      const wordLayout = isMinimalWordLayout(wordLayoutValue) ? wordLayoutValue : void 0;
      const isListParagraph = Boolean(wordLayout?.marker);
      const rawTextStartPx = typeof wordLayout?.marker?.textStartX === "number" && Number.isFinite(wordLayout.marker.textStartX) ? wordLayout.marker.textStartX : typeof wordLayout?.textStartPx === "number" && Number.isFinite(wordLayout.textStartPx) ? wordLayout.textStartPx : void 0;
      const listIndentOffset = isFirstLineOfPara ? rawTextStartPx ?? indentLeft : indentLeft;
      const indentOffset = isListParagraph ? listIndentOffset : indentLeft + firstLineOffsetForCumX;
      let cumulativeX = 0;
      const segmentsByRun = /* @__PURE__ */ new Map();
      line.segments.forEach((segment) => {
        const list = segmentsByRun.get(segment.runIndex);
        if (list) {
          list.push(segment);
        } else {
          segmentsByRun.set(segment.runIndex, [segment]);
        }
      });
      const findImmediateNextSegmentX = (fromRunIndex) => {
        const nextRunIdx = fromRunIndex + 1;
        if (nextRunIdx <= line.toRun) {
          const nextSegments = segmentsByRun.get(nextRunIdx);
          if (nextSegments && nextSegments.length > 0) {
            const firstSegment = nextSegments[0];
            return firstSegment.x;
          }
        }
        return void 0;
      };
      for (let runIndex = line.fromRun; runIndex <= line.toRun; runIndex += 1) {
        const baseRun = block.runs[runIndex];
        if (!baseRun) continue;
        if (baseRun.kind === "tab") {
          const immediateNextX = findImmediateNextSegmentX(runIndex);
          const tabStartX = cumulativeX;
          const tabEndX = immediateNextX !== void 0 ? immediateNextX : tabStartX + (baseRun.width ?? 0);
          const actualTabWidth = tabEndX - tabStartX;
          const tabEl = this.doc.createElement("span");
          tabEl.style.position = "absolute";
          tabEl.style.left = `${tabStartX + indentOffset}px`;
          tabEl.style.top = "0px";
          tabEl.style.width = `${actualTabWidth}px`;
          tabEl.style.height = `${line.lineHeight}px`;
          tabEl.style.display = "inline-block";
          tabEl.style.pointerEvents = "none";
          tabEl.style.zIndex = "1";
          if (baseRun.underline) {
            const underlineStyle = baseRun.underline.style ?? "single";
            const underlineColor = baseRun.underline.color ?? "#000000";
            const borderStyle = underlineStyle === "double" ? "double" : "solid";
            tabEl.style.borderBottom = `1px ${borderStyle} ${underlineColor}`;
          } else {
            tabEl.style.visibility = "hidden";
          }
          if (styleId) {
            tabEl.setAttribute("styleid", styleId);
          }
          if (baseRun.pmStart != null) tabEl.dataset.pmStart = String(baseRun.pmStart);
          if (baseRun.pmEnd != null) tabEl.dataset.pmEnd = String(baseRun.pmEnd);
          tabEl.dataset.layoutEpoch = String(this.layoutEpoch);
          el.appendChild(tabEl);
          cumulativeX = tabEndX;
          continue;
        }
        if (this.isImageRun(baseRun)) {
          const elem = this.renderRun(baseRun, context, trackedConfig);
          if (elem) {
            if (styleId) {
              elem.setAttribute("styleid", styleId);
            }
            const runSegments2 = segmentsByRun.get(runIndex);
            const baseSegX = runSegments2 && runSegments2[0]?.x !== void 0 ? runSegments2[0].x : cumulativeX;
            const segX = baseSegX + indentOffset;
            const segWidth = (runSegments2 && runSegments2[0]?.width !== void 0 ? runSegments2[0].width : elem.offsetWidth) ?? 0;
            elem.style.position = "absolute";
            elem.style.left = `${segX}px`;
            el.appendChild(elem);
            cumulativeX = baseSegX + segWidth;
          }
          continue;
        }
        if (this.isLineBreakRun(baseRun)) {
          continue;
        }
        if (this.isBreakRun(baseRun)) {
          continue;
        }
        if (this.isFieldAnnotationRun(baseRun)) {
          const elem = this.renderRun(baseRun, context, trackedConfig);
          if (elem) {
            if (styleId) {
              elem.setAttribute("styleid", styleId);
            }
            const runSegments2 = segmentsByRun.get(runIndex);
            const baseSegX = runSegments2 && runSegments2[0]?.x !== void 0 ? runSegments2[0].x : cumulativeX;
            const segX = baseSegX + indentOffset;
            const segWidth = (runSegments2 && runSegments2[0]?.width !== void 0 ? runSegments2[0].width : 0) ?? 0;
            elem.style.position = "absolute";
            elem.style.left = `${segX}px`;
            el.appendChild(elem);
            cumulativeX = baseSegX + segWidth;
          }
          continue;
        }
        const runSegments = segmentsByRun.get(runIndex);
        if (!runSegments || runSegments.length === 0) {
          continue;
        }
        if (!("text" in baseRun)) {
          continue;
        }
        const baseText = baseRun.text ?? "";
        const runPmStart = baseRun.pmStart ?? null;
        const fallbackPmEnd = runPmStart != null && baseRun.pmEnd == null ? runPmStart + baseText.length : baseRun.pmEnd ?? null;
        runSegments.forEach((segment) => {
          const segmentText = baseText.slice(segment.fromChar, segment.toChar);
          if (!segmentText) return;
          const pmSliceStart = runPmStart != null ? runPmStart + segment.fromChar : void 0;
          const pmSliceEnd = runPmStart != null ? runPmStart + segment.toChar : fallbackPmEnd ?? void 0;
          const segmentRun = {
            ...baseRun,
            text: segmentText,
            pmStart: pmSliceStart,
            pmEnd: pmSliceEnd
          };
          const elem = this.renderRun(segmentRun, context, trackedConfig);
          if (elem) {
            if (styleId) {
              elem.setAttribute("styleid", styleId);
            }
            const baseX = segment.x !== void 0 ? segment.x : cumulativeX;
            const xPos = baseX + indentOffset;
            elem.style.position = "absolute";
            elem.style.left = `${xPos}px`;
            el.appendChild(elem);
            let width = segment.width ?? 0;
            if (width <= 0 && this.doc) {
              const measureEl = elem.cloneNode(true);
              measureEl.style.position = "absolute";
              measureEl.style.visibility = "hidden";
              measureEl.style.left = "-9999px";
              this.doc.body.appendChild(measureEl);
              width = measureEl.offsetWidth;
              this.doc.body.removeChild(measureEl);
            }
            cumulativeX = baseX + width;
          }
        });
      }
    } else {
      let currentInlineSdtWrapper = null;
      let currentInlineSdtId = null;
      const closeCurrentWrapper = () => {
        if (currentInlineSdtWrapper) {
          el.appendChild(currentInlineSdtWrapper);
          currentInlineSdtWrapper = null;
          currentInlineSdtId = null;
        }
      };
      runsForLine.forEach((run) => {
        const runSdt = run.sdt;
        const isInlineSdt = runSdt?.type === "structuredContent" && runSdt?.scope === "inline";
        const runSdtId = isInlineSdt && runSdt?.id ? String(runSdt.id) : null;
        if (runSdtId !== currentInlineSdtId) {
          closeCurrentWrapper();
        }
        if (run.kind === "tab") {
          const tabEl = this.doc.createElement("span");
          tabEl.classList.add("superdoc-tab");
          const tabWidth = run.width ?? 48;
          tabEl.style.display = "inline-block";
          tabEl.style.width = `${tabWidth}px`;
          tabEl.style.height = `${line.lineHeight}px`;
          tabEl.style.verticalAlign = "bottom";
          if (run.underline) {
            const underlineStyle = run.underline.style ?? "single";
            const underlineColor = run.underline.color ?? "#000000";
            const borderStyle = underlineStyle === "double" ? "double" : "solid";
            tabEl.style.borderBottom = `1px ${borderStyle} ${underlineColor}`;
          }
          if (styleId) {
            tabEl.setAttribute("styleid", styleId);
          }
          if (run.pmStart != null) tabEl.dataset.pmStart = String(run.pmStart);
          if (run.pmEnd != null) tabEl.dataset.pmEnd = String(run.pmEnd);
          tabEl.dataset.layoutEpoch = String(this.layoutEpoch);
          el.appendChild(tabEl);
          return;
        }
        const elem = this.renderRun(run, context, trackedConfig);
        if (elem) {
          if (styleId) {
            elem.setAttribute("styleid", styleId);
          }
          if (isInlineSdt && runSdtId && this.doc) {
            if (!currentInlineSdtWrapper) {
              currentInlineSdtWrapper = this.doc.createElement("span");
              currentInlineSdtWrapper.className = DOM_CLASS_NAMES.INLINE_SDT_WRAPPER;
              currentInlineSdtWrapper.dataset.layoutEpoch = String(this.layoutEpoch);
              currentInlineSdtId = runSdtId;
              this.applySdtDataset(currentInlineSdtWrapper, runSdt);
              const alias = runSdt?.alias || "Inline content";
              const labelEl = this.doc.createElement("span");
              labelEl.className = `${DOM_CLASS_NAMES.INLINE_SDT_WRAPPER}__label`;
              labelEl.textContent = alias;
              currentInlineSdtWrapper.appendChild(labelEl);
            }
            const wrapperPmStart = currentInlineSdtWrapper.dataset.pmStart;
            const wrapperPmEnd = currentInlineSdtWrapper.dataset.pmEnd;
            if (run.pmStart != null) {
              if (!wrapperPmStart || run.pmStart < parseInt(wrapperPmStart, 10)) {
                currentInlineSdtWrapper.dataset.pmStart = String(run.pmStart);
              }
            }
            if (run.pmEnd != null) {
              if (!wrapperPmEnd || run.pmEnd > parseInt(wrapperPmEnd, 10)) {
                currentInlineSdtWrapper.dataset.pmEnd = String(run.pmEnd);
              }
            }
            currentInlineSdtWrapper.appendChild(elem);
          } else {
            el.appendChild(elem);
          }
        }
      });
      closeCurrentWrapper();
    }
    const anchors = el.querySelectorAll("a[href]");
    anchors.forEach((anchor) => {
      const pendingTooltip = this.pendingTooltips.get(anchor);
      if (pendingTooltip) {
        this.applyTooltipAccessibility(anchor, pendingTooltip);
        this.pendingTooltips.delete(anchor);
      }
    });
    return el;
  }
  resolveTrackedChangesConfig(block) {
    const attrs = block.attrs ?? {};
    const mode = attrs.trackedChangesMode ?? "review";
    const enabled = attrs.trackedChangesEnabled !== false;
    return { mode, enabled };
  }
  applyTrackedChangeDecorations(elem, run, config) {
    if (!config.enabled || config.mode === "off") {
      return;
    }
    const textRun = run;
    const meta = textRun.trackedChange;
    if (!meta) {
      return;
    }
    const baseClass = TRACK_CHANGE_BASE_CLASS[meta.kind];
    if (baseClass) {
      elem.classList.add(baseClass);
    }
    const modifier = TRACK_CHANGE_MODIFIER_CLASS[meta.kind]?.[config.mode];
    if (modifier) {
      elem.classList.add(modifier);
    }
    elem.dataset.trackChangeId = meta.id;
    elem.dataset.trackChangeKind = meta.kind;
    if (meta.author) {
      elem.dataset.trackChangeAuthor = meta.author;
    }
    if (meta.authorEmail) {
      elem.dataset.trackChangeAuthorEmail = meta.authorEmail;
    }
    if (meta.authorImage) {
      elem.dataset.trackChangeAuthorImage = meta.authorImage;
    }
    if (meta.date) {
      elem.dataset.trackChangeDate = meta.date;
    }
  }
  /**
   * Updates an existing fragment element's position and dimensions in place.
   * Used during incremental updates to efficiently reposition fragments without full re-render.
   *
   * @param el - The HTMLElement representing the fragment to update
   * @param fragment - The fragment data containing updated position and dimensions
   * @param section - The document section ('body', 'header', 'footer') containing this fragment.
   *                  Affects PM position validation - only body sections validate PM positions.
   *                  If undefined, defaults to 'body' section behavior.
   */
  updateFragmentElement(el, fragment, section) {
    this.applyFragmentFrame(el, fragment, section);
    if (fragment.kind === "image") {
      el.style.height = `${fragment.height}px`;
    }
    if (fragment.kind === "drawing") {
      el.style.height = `${fragment.height}px`;
    }
  }
  /**
   * Applies fragment positioning, dimensions, and metadata to an HTML element.
   * Sets CSS positioning, block ID, and PM position data attributes for paragraph fragments.
   *
   * @param el - The HTMLElement to apply fragment properties to
   * @param fragment - The fragment data containing position, dimensions, and PM position information
   * @param section - The document section ('body', 'header', 'footer') containing this fragment.
   *                  Controls PM position validation behavior:
   *                  - 'body' or undefined: PM positions are validated and required for paragraph fragments
   *                  - 'header' or 'footer': PM position validation is skipped (these sections have separate PM coordinate spaces)
   *                  When undefined, defaults to 'body' section behavior (validation enabled).
   */
  applyFragmentFrame(el, fragment, section) {
    el.style.left = `${fragment.x}px`;
    el.style.top = `${fragment.y}px`;
    el.style.width = `${fragment.width}px`;
    el.dataset.blockId = fragment.blockId;
    el.dataset.layoutEpoch = String(this.layoutEpoch);
    if (fragment.kind === "para") {
      if (section === "body" || section === void 0) {
        assertFragmentPmPositions(fragment);
      }
      if (fragment.pmStart != null) {
        el.dataset.pmStart = String(fragment.pmStart);
      } else {
        delete el.dataset.pmStart;
      }
      if (fragment.pmEnd != null) {
        el.dataset.pmEnd = String(fragment.pmEnd);
      } else {
        delete el.dataset.pmEnd;
      }
      if (fragment.continuesFromPrev) {
        el.dataset.continuesFromPrev = "true";
      } else {
        delete el.dataset.continuesFromPrev;
      }
      if (fragment.continuesOnNext) {
        el.dataset.continuesOnNext = "true";
      } else {
        delete el.dataset.continuesOnNext;
      }
    }
  }
  /**
   * Estimates the height of a fragment when explicit height is not available.
   *
   * This method provides fallback height calculations for footer bottom-alignment
   * by consulting measure data for paragraphs and list items, or using the
   * fragment's height property for tables, images, and drawings.
   *
   * @param fragment - The fragment to estimate height for
   * @returns Estimated height in pixels, or 0 if height cannot be determined
   */
  estimateFragmentHeight(fragment) {
    const lookup = this.blockLookup.get(fragment.blockId);
    const measure = lookup?.measure;
    if (fragment.kind === "para" && measure?.kind === "paragraph") {
      return measure.totalHeight;
    }
    if (fragment.kind === "list-item" && measure?.kind === "list") {
      return measure.totalHeight;
    }
    if (fragment.kind === "table") {
      return fragment.height;
    }
    if (fragment.kind === "image" || fragment.kind === "drawing") {
      return fragment.height;
    }
    return 0;
  }
  buildBlockLookup(blocks, measures) {
    if (blocks.length !== measures.length) {
      throw new Error("DomPainter requires the same number of blocks and measures");
    }
    const lookup = /* @__PURE__ */ new Map();
    blocks.forEach((block, index2) => {
      lookup.set(block.id, {
        block,
        measure: measures[index2],
        version: deriveBlockVersion(block)
      });
    });
    return lookup;
  }
  static {
    this.SDT_DATASET_KEYS = [
      "sdtType",
      "sdtId",
      "sdtFieldId",
      "sdtFieldType",
      "sdtFieldVariant",
      "sdtFieldVisibility",
      "sdtFieldHidden",
      "sdtFieldLocked",
      "sdtScope",
      "sdtTag",
      "sdtAlias",
      "sdtSectionTitle",
      "sdtSectionType",
      "sdtSectionLocked",
      "sdtDocpartGallery",
      "sdtDocpartId",
      "sdtDocpartInstruction"
    ];
  }
  /**
   * Helper to set a string dataset attribute if the value is truthy.
   */
  setDatasetString(el, key2, value) {
    if (value) {
      el.dataset[key2] = value;
    }
  }
  /**
   * Helper to set a boolean dataset attribute if the value is not null/undefined.
   */
  setDatasetBoolean(el, key2, value) {
    if (value != null) {
      el.dataset[key2] = String(value);
    }
  }
  /**
   * Applies SDT (Structured Document Tag) metadata to an element's dataset as data-sdt-* attributes.
   * Supports field annotations, structured content, document sections, and doc parts.
   * Clears existing SDT metadata before applying new values.
   *
   * @param el - The HTML element to annotate
   * @param metadata - The SDT metadata to render as data attributes
   */
  applySdtDataset(el, metadata) {
    if (!el?.dataset) return;
    this.clearSdtDataset(el);
    if (!metadata) return;
    el.dataset.sdtType = metadata.type;
    if ("id" in metadata && metadata.id != null) {
      el.dataset.sdtId = String(metadata.id);
    }
    if (metadata.type === "fieldAnnotation") {
      this.setDatasetString(el, "sdtFieldId", metadata.fieldId);
      this.setDatasetString(el, "sdtFieldType", metadata.fieldType);
      this.setDatasetString(el, "sdtFieldVariant", metadata.variant);
      this.setDatasetString(el, "sdtFieldVisibility", metadata.visibility);
      this.setDatasetBoolean(el, "sdtFieldHidden", metadata.hidden);
      this.setDatasetBoolean(el, "sdtFieldLocked", metadata.isLocked);
    } else if (metadata.type === "structuredContent") {
      this.setDatasetString(el, "sdtScope", metadata.scope);
      this.setDatasetString(el, "sdtTag", metadata.tag);
      this.setDatasetString(el, "sdtAlias", metadata.alias);
    } else if (metadata.type === "documentSection") {
      this.setDatasetString(el, "sdtSectionTitle", metadata.title);
      this.setDatasetString(el, "sdtSectionType", metadata.sectionType);
      this.setDatasetBoolean(el, "sdtSectionLocked", metadata.isLocked);
    } else if (metadata.type === "docPartObject") {
      this.setDatasetString(el, "sdtDocpartGallery", metadata.gallery);
      this.setDatasetString(el, "sdtDocpartId", metadata.uniqueId);
      this.setDatasetString(el, "sdtDocpartInstruction", metadata.instruction);
    }
  }
  clearSdtDataset(el) {
    DomPainter.SDT_DATASET_KEYS.forEach((key2) => {
      delete el.dataset[key2];
    });
  }
  /**
   * Applies container SDT metadata to an element's dataset (data-sdt-container-* attributes).
   * Used when a block has both primary SDT metadata (e.g., docPartObject) and container
   * metadata (e.g., documentSection). The container metadata is rendered with a "Container"
   * prefix to distinguish it from the primary SDT metadata.
   *
   * @param el - The HTML element to annotate
   * @param metadata - The container SDT metadata (typically documentSection)
   */
  applyContainerSdtDataset(el, metadata) {
    if (!el?.dataset) return;
    if (!metadata) return;
    el.dataset.sdtContainerType = metadata.type;
    if ("id" in metadata && metadata.id != null) {
      el.dataset.sdtContainerId = String(metadata.id);
    }
    if (metadata.type === "documentSection") {
      this.setDatasetString(el, "sdtContainerSectionTitle", metadata.title);
      this.setDatasetString(el, "sdtContainerSectionType", metadata.sectionType);
      this.setDatasetBoolean(el, "sdtContainerSectionLocked", metadata.isLocked);
    }
  }
}
const getFragmentSdtContainerKey = (fragment, blockLookup) => {
  const lookup = blockLookup.get(fragment.blockId);
  if (!lookup) return null;
  const block = lookup.block;
  if (fragment.kind === "para" && block.kind === "paragraph") {
    const attrs = block.attrs;
    return getSdtContainerKey(attrs?.sdt, attrs?.containerSdt);
  }
  if (fragment.kind === "list-item" && block.kind === "list") {
    const item = block.items.find((listItem) => listItem.id === fragment.itemId);
    const attrs = item?.paragraph.attrs;
    return getSdtContainerKey(attrs?.sdt, attrs?.containerSdt);
  }
  if (fragment.kind === "table" && block.kind === "table") {
    const attrs = block.attrs;
    return getSdtContainerKey(attrs?.sdt, attrs?.containerSdt);
  }
  return null;
};
const computeSdtBoundaries = (fragments, blockLookup) => {
  const boundaries = /* @__PURE__ */ new Map();
  const containerKeys = fragments.map((fragment) => getFragmentSdtContainerKey(fragment, blockLookup));
  let i = 0;
  while (i < fragments.length) {
    const currentKey = containerKeys[i];
    if (!currentKey) {
      i += 1;
      continue;
    }
    let groupRight = fragments[i].x + fragments[i].width;
    let j = i;
    while (j + 1 < fragments.length && containerKeys[j + 1] === currentKey) {
      j += 1;
      const fragmentRight = fragments[j].x + fragments[j].width;
      if (fragmentRight > groupRight) {
        groupRight = fragmentRight;
      }
    }
    for (let k2 = i; k2 <= j; k2 += 1) {
      const fragment = fragments[k2];
      boundaries.set(k2, {
        isStart: k2 === i,
        isEnd: k2 === j,
        widthOverride: groupRight - fragment.x
      });
    }
    i = j + 1;
  }
  return boundaries;
};
const shouldRebuildForSdtBoundary = (element, boundary) => {
  if (!boundary) return false;
  const startAttr = element.dataset.sdtContainerStart;
  const endAttr = element.dataset.sdtContainerEnd;
  const expectedStart = String(boundary.isStart ?? true);
  const expectedEnd = String(boundary.isEnd ?? true);
  if (startAttr === void 0 || endAttr === void 0) {
    return true;
  }
  return startAttr !== expectedStart || endAttr !== expectedEnd;
};
const fragmentKey = (fragment) => {
  if (fragment.kind === "para") {
    return `para:${fragment.blockId}:${fragment.fromLine}:${fragment.toLine}`;
  }
  if (fragment.kind === "list-item") {
    return `list-item:${fragment.blockId}:${fragment.itemId}:${fragment.fromLine}:${fragment.toLine}`;
  }
  if (fragment.kind === "image") {
    return `image:${fragment.blockId}:${fragment.x}:${fragment.y}`;
  }
  if (fragment.kind === "drawing") {
    return `drawing:${fragment.blockId}:${fragment.x}:${fragment.y}`;
  }
  if (fragment.kind === "table") {
    const partialKey = fragment.partialRow ? `:${fragment.partialRow.fromLineByCell.join(",")}-${fragment.partialRow.toLineByCell.join(",")}` : "";
    return `table:${fragment.blockId}:${fragment.fromRow}:${fragment.toRow}${partialKey}`;
  }
  const _exhaustiveCheck = fragment;
  return _exhaustiveCheck;
};
const fragmentSignature = (fragment, lookup) => {
  const base2 = lookup.get(fragment.blockId)?.version ?? "missing";
  if (fragment.kind === "para") {
    return [
      base2,
      fragment.fromLine,
      fragment.toLine,
      fragment.continuesFromPrev ? 1 : 0,
      fragment.continuesOnNext ? 1 : 0,
      fragment.markerWidth ?? ""
      // Include markerWidth to trigger re-render when list status changes
    ].join("|");
  }
  if (fragment.kind === "list-item") {
    return [
      base2,
      fragment.itemId,
      fragment.fromLine,
      fragment.toLine,
      fragment.continuesFromPrev ? 1 : 0,
      fragment.continuesOnNext ? 1 : 0
    ].join("|");
  }
  if (fragment.kind === "image") {
    return [base2, fragment.width, fragment.height].join("|");
  }
  if (fragment.kind === "drawing") {
    return [
      base2,
      fragment.drawingKind,
      fragment.drawingContentId ?? "",
      fragment.width,
      fragment.height,
      fragment.geometry.width,
      fragment.geometry.height,
      fragment.geometry.rotation ?? 0,
      fragment.scale ?? 1,
      fragment.zIndex ?? ""
    ].join("|");
  }
  if (fragment.kind === "table") {
    const partialSig = fragment.partialRow ? `${fragment.partialRow.fromLineByCell.join(",")}-${fragment.partialRow.toLineByCell.join(",")}-${fragment.partialRow.partialHeight}` : "";
    return [
      base2,
      fragment.fromRow,
      fragment.toRow,
      fragment.width,
      fragment.height,
      fragment.continuesFromPrev ? 1 : 0,
      fragment.continuesOnNext ? 1 : 0,
      fragment.repeatHeaderCount ?? 0,
      partialSig
    ].join("|");
  }
  return base2;
};
const hasListMarkerProperties = (attrs) => {
  if (!attrs || typeof attrs !== "object") return false;
  const obj = attrs;
  if (!obj.numberingProperties || typeof obj.numberingProperties !== "object") return false;
  const numProps = obj.numberingProperties;
  if ("numId" in numProps) {
    const numId = numProps.numId;
    if (typeof numId !== "number" && typeof numId !== "string") return false;
  }
  if ("ilvl" in numProps) {
    const ilvl = numProps.ilvl;
    if (typeof ilvl !== "number") return false;
  }
  if ("wordLayout" in obj && obj.wordLayout !== void 0) {
    if (typeof obj.wordLayout !== "object" || obj.wordLayout === null) return false;
    const wordLayout = obj.wordLayout;
    if ("marker" in wordLayout && wordLayout.marker !== void 0) {
      if (typeof wordLayout.marker !== "object" || wordLayout.marker === null) return false;
      const marker = wordLayout.marker;
      if ("markerText" in marker && marker.markerText !== void 0) {
        if (typeof marker.markerText !== "string") return false;
      }
    }
  }
  return true;
};
const deriveBlockVersion = (block) => {
  if (block.kind === "paragraph") {
    const markerVersion = hasListMarkerProperties(block.attrs) ? `marker:${block.attrs.numberingProperties.numId ?? ""}:${block.attrs.numberingProperties.ilvl ?? 0}:${block.attrs.wordLayout?.marker?.markerText ?? ""}` : "";
    const runsVersion = block.runs.map((run) => {
      if (run.kind === "image") {
        const imgRun = run;
        return [
          "img",
          imgRun.src,
          imgRun.width,
          imgRun.height,
          imgRun.alt ?? "",
          imgRun.title ?? "",
          imgRun.distTop ?? "",
          imgRun.distBottom ?? "",
          imgRun.distLeft ?? "",
          imgRun.distRight ?? ""
          // Note: pmStart/pmEnd intentionally excluded to prevent O(n) change detection
        ].join(",");
      }
      if (run.kind === "lineBreak") {
        return "linebreak";
      }
      if (run.kind === "tab") {
        return [run.text ?? "", "tab"].join(",");
      }
      if (run.kind === "fieldAnnotation") {
        const size2 = run.size ? `${run.size.width ?? ""}x${run.size.height ?? ""}` : "";
        const highlighted = run.highlighted !== false ? 1 : 0;
        return [
          "field",
          run.variant ?? "",
          run.displayLabel ?? "",
          run.fieldColor ?? "",
          run.borderColor ?? "",
          highlighted,
          run.hidden ? 1 : 0,
          run.visibility ?? "",
          run.imageSrc ?? "",
          run.linkUrl ?? "",
          run.rawHtml ?? "",
          size2,
          run.fontFamily ?? "",
          run.fontSize ?? "",
          run.textColor ?? "",
          run.textHighlight ?? "",
          run.bold ? 1 : 0,
          run.italic ? 1 : 0,
          run.underline ? 1 : 0,
          run.fieldId ?? "",
          run.fieldType ?? ""
        ].join(",");
      }
      const textRun = run;
      return [
        textRun.text ?? "",
        textRun.fontFamily,
        textRun.fontSize,
        textRun.bold ? 1 : 0,
        textRun.italic ? 1 : 0,
        textRun.color ?? "",
        // Text decorations - ensures DOM updates when decoration properties change.
        textRun.underline?.style ?? "",
        textRun.underline?.color ?? "",
        textRun.strike ? 1 : 0,
        textRun.highlight ?? "",
        textRun.letterSpacing != null ? textRun.letterSpacing : "",
        // Note: pmStart/pmEnd intentionally excluded to prevent O(n) change detection
        textRun.token ?? "",
        // Tracked changes - force re-render when added or removed tracked change
        textRun.trackedChange ? 1 : 0,
        // Comment annotations - force re-render when comments are enabled/disabled
        textRun.comments?.length ?? 0
      ].join(",");
    }).join("|");
    const attrs = block.attrs;
    const paragraphAttrsVersion = attrs ? [
      attrs.alignment ?? "",
      attrs.spacing?.before ?? "",
      attrs.spacing?.after ?? "",
      attrs.spacing?.line ?? "",
      attrs.spacing?.lineRule ?? "",
      attrs.indent?.left ?? "",
      attrs.indent?.right ?? "",
      attrs.indent?.firstLine ?? "",
      attrs.indent?.hanging ?? "",
      attrs.borders ? hashParagraphBorders$1(attrs.borders) : "",
      attrs.shading?.fill ?? "",
      attrs.shading?.color ?? "",
      attrs.direction ?? "",
      attrs.rtl ? "1" : "",
      attrs.tabs?.length ? JSON.stringify(attrs.tabs) : ""
    ].join(":") : "";
    const parts = [markerVersion, runsVersion, paragraphAttrsVersion].filter(Boolean);
    return parts.join("|");
  }
  if (block.kind === "list") {
    return block.items.map((item) => `${item.id}:${item.marker.text}:${deriveBlockVersion(item.paragraph)}`).join("|");
  }
  if (block.kind === "image") {
    return [block.src ?? "", block.width ?? "", block.height ?? "", block.alt ?? "", block.title ?? ""].join("|");
  }
  if (block.kind === "drawing") {
    if (block.drawingKind === "image") {
      const imageLike = block;
      return [
        "drawing:image",
        imageLike.src ?? "",
        imageLike.width ?? "",
        imageLike.height ?? "",
        imageLike.alt ?? ""
      ].join("|");
    }
    if (block.drawingKind === "vectorShape") {
      const vector = block;
      return [
        "drawing:vector",
        vector.shapeKind ?? "",
        vector.fillColor ?? "",
        vector.strokeColor ?? "",
        vector.strokeWidth ?? "",
        vector.geometry.width,
        vector.geometry.height,
        vector.geometry.rotation ?? 0,
        vector.geometry.flipH ? 1 : 0,
        vector.geometry.flipV ? 1 : 0
      ].join("|");
    }
    if (block.drawingKind === "shapeGroup") {
      const group = block;
      const childSignature = group.shapes.map((child) => `${child.shapeType}:${JSON.stringify(child.attrs ?? {})}`).join(";");
      return [
        "drawing:group",
        group.geometry.width,
        group.geometry.height,
        group.groupTransform ? JSON.stringify(group.groupTransform) : "",
        childSignature
      ].join("|");
    }
    return `drawing:unknown:${block.id}`;
  }
  if (block.kind === "table") {
    const tableBlock = block;
    const hashString = (seed, value) => {
      let hash22 = seed >>> 0;
      for (let i = 0; i < value.length; i++) {
        hash22 ^= value.charCodeAt(i);
        hash22 = Math.imul(hash22, 16777619);
      }
      return hash22 >>> 0;
    };
    const hashNumber = (seed, value) => {
      const n = Number.isFinite(value) ? value : 0;
      let hash22 = seed ^ n;
      hash22 = Math.imul(hash22, 16777619);
      hash22 ^= hash22 >>> 13;
      return hash22 >>> 0;
    };
    let hash2 = 2166136261;
    hash2 = hashString(hash2, block.id);
    hash2 = hashNumber(hash2, tableBlock.rows.length);
    hash2 = (tableBlock.columnWidths ?? []).reduce((acc, width) => hashNumber(acc, Math.round(width * 1e3)), hash2);
    const rows = tableBlock.rows ?? [];
    for (const row of rows) {
      if (!row || !Array.isArray(row.cells)) continue;
      hash2 = hashNumber(hash2, row.cells.length);
      for (const cell of row.cells) {
        if (!cell) continue;
        const cellBlocks = cell.blocks ?? (cell.paragraph ? [cell.paragraph] : []);
        hash2 = hashNumber(hash2, cellBlocks.length);
        hash2 = hashNumber(hash2, cell.rowSpan ?? 1);
        hash2 = hashNumber(hash2, cell.colSpan ?? 1);
        if (cell.attrs) {
          const cellAttrs = cell.attrs;
          if (cellAttrs.borders) {
            hash2 = hashString(hash2, hashCellBorders$1(cellAttrs.borders));
          }
          if (cellAttrs.padding) {
            const p2 = cellAttrs.padding;
            hash2 = hashNumber(hash2, p2.top ?? 0);
            hash2 = hashNumber(hash2, p2.right ?? 0);
            hash2 = hashNumber(hash2, p2.bottom ?? 0);
            hash2 = hashNumber(hash2, p2.left ?? 0);
          }
          if (cellAttrs.verticalAlign) {
            hash2 = hashString(hash2, cellAttrs.verticalAlign);
          }
          if (cellAttrs.background) {
            hash2 = hashString(hash2, cellAttrs.background);
          }
        }
        for (const cellBlock of cellBlocks) {
          hash2 = hashString(hash2, cellBlock?.kind ?? "unknown");
          if (cellBlock?.kind === "paragraph") {
            const paragraphBlock = cellBlock;
            const runs = paragraphBlock.runs ?? [];
            hash2 = hashNumber(hash2, runs.length);
            const attrs = paragraphBlock.attrs;
            if (attrs) {
              hash2 = hashString(hash2, attrs.alignment ?? "");
              hash2 = hashNumber(hash2, attrs.spacing?.before ?? 0);
              hash2 = hashNumber(hash2, attrs.spacing?.after ?? 0);
              hash2 = hashNumber(hash2, attrs.spacing?.line ?? 0);
              hash2 = hashString(hash2, attrs.spacing?.lineRule ?? "");
              hash2 = hashNumber(hash2, attrs.indent?.left ?? 0);
              hash2 = hashNumber(hash2, attrs.indent?.right ?? 0);
              hash2 = hashNumber(hash2, attrs.indent?.firstLine ?? 0);
              hash2 = hashNumber(hash2, attrs.indent?.hanging ?? 0);
              hash2 = hashString(hash2, attrs.shading?.fill ?? "");
              hash2 = hashString(hash2, attrs.shading?.color ?? "");
              hash2 = hashString(hash2, attrs.direction ?? "");
              hash2 = hashString(hash2, attrs.rtl ? "1" : "");
              if (attrs.borders) {
                hash2 = hashString(hash2, hashParagraphBorders$1(attrs.borders));
              }
            }
            for (const run of runs) {
              if ("text" in run && typeof run.text === "string") {
                hash2 = hashString(hash2, run.text);
              }
              hash2 = hashNumber(hash2, run.pmStart ?? -1);
              hash2 = hashNumber(hash2, run.pmEnd ?? -1);
              hash2 = hashString(hash2, getRunStringProp(run, "color"));
              hash2 = hashString(hash2, getRunStringProp(run, "highlight"));
              hash2 = hashString(hash2, getRunBooleanProp(run, "bold") ? "1" : "");
              hash2 = hashString(hash2, getRunBooleanProp(run, "italic") ? "1" : "");
              hash2 = hashNumber(hash2, getRunNumberProp(run, "fontSize"));
              hash2 = hashString(hash2, getRunStringProp(run, "fontFamily"));
              hash2 = hashString(hash2, getRunUnderlineStyle(run));
              hash2 = hashString(hash2, getRunUnderlineColor(run));
              hash2 = hashString(hash2, getRunBooleanProp(run, "strike") ? "1" : "");
            }
          }
        }
      }
    }
    if (tableBlock.attrs) {
      const tblAttrs = tableBlock.attrs;
      if (tblAttrs.borders) {
        hash2 = hashString(hash2, hashTableBorders$1(tblAttrs.borders));
      }
      if (tblAttrs.borderCollapse) {
        hash2 = hashString(hash2, tblAttrs.borderCollapse);
      }
      if (tblAttrs.cellSpacing !== void 0) {
        hash2 = hashNumber(hash2, tblAttrs.cellSpacing);
      }
    }
    return [block.id, tableBlock.rows.length, hash2.toString(16)].join("|");
  }
  return block.id;
};
const applyRunStyles = (element, run, _isLink = false) => {
  if (run.kind === "tab" || run.kind === "image" || run.kind === "lineBreak" || run.kind === "break" || run.kind === "fieldAnnotation") {
    return;
  }
  element.style.fontFamily = run.fontFamily;
  element.style.fontSize = `${run.fontSize}px`;
  if (run.bold) element.style.fontWeight = "bold";
  if (run.italic) element.style.fontStyle = "italic";
  if (run.color) element.style.color = run.color;
  if (run.letterSpacing != null) {
    element.style.letterSpacing = `${run.letterSpacing}px`;
  }
  if (run.highlight) {
    element.style.backgroundColor = run.highlight;
  }
  if (run.textTransform) {
    element.style.textTransform = run.textTransform;
  }
  const decorations = [];
  if (run.underline) {
    decorations.push("underline");
    const u = run.underline;
    element.style.textDecorationStyle = u.style && u.style !== "single" ? u.style : "solid";
    if (u.color) {
      element.style.textDecorationColor = u.color;
    }
  }
  if (run.strike) {
    decorations.push("line-through");
  }
  if (decorations.length > 0) {
    element.style.textDecorationLine = decorations.join(" ");
  }
};
const getCommentHighlight = (run, activeCommentId) => {
  const comments = run.comments;
  if (!comments || comments.length === 0) return {};
  const matchesId = (c2, id) => c2.commentId === id || c2.importedId === id;
  if (activeCommentId != null) {
    const activeComment = comments.find(
      (c2) => matchesId(c2, activeCommentId)
    );
    if (activeComment) {
      const base3 = activeComment.internal ? COMMENT_INTERNAL_COLOR : COMMENT_EXTERNAL_COLOR;
      const nestedComments = comments.filter(
        (c2) => !matchesId(c2, activeCommentId)
      );
      return {
        color: `${base3}${COMMENT_ACTIVE_ALPHA}`,
        baseColor: base3,
        hasNestedComments: nestedComments.length > 0
      };
    }
    const primary2 = comments[0];
    const base22 = primary2.internal ? COMMENT_INTERNAL_COLOR : COMMENT_EXTERNAL_COLOR;
    return { color: `${base22}${COMMENT_INACTIVE_ALPHA}` };
  }
  const primary = comments[0];
  const base2 = primary.internal ? COMMENT_INTERNAL_COLOR : COMMENT_EXTERNAL_COLOR;
  return { color: `${base2}${COMMENT_INACTIVE_ALPHA}` };
};
const applyRunDataAttributes = (element, dataAttrs) => {
  if (!dataAttrs) return;
  Object.entries(dataAttrs).forEach(([key2, value]) => {
    if (typeof key2 !== "string" || !key2.toLowerCase().startsWith("data-")) return;
    if (typeof value !== "string") return;
    try {
      element.setAttribute(key2, value);
    } catch (error) {
      if (vue.process$1.env.NODE_ENV === "development") {
        console.warn(`[DomPainter] Failed to set data attribute "${key2}":`, error);
      }
    }
  });
};
const applyParagraphBlockStyles = (element, attrs) => {
  if (!attrs) return;
  if (attrs.styleId) {
    element.setAttribute("styleid", attrs.styleId);
  }
  if (attrs.alignment) {
    element.style.textAlign = attrs.alignment === "justify" ? "left" : attrs.alignment;
  }
  if (attrs.dropCap) {
    element.classList.add("sd-editor-dropcap");
  }
  const indent = attrs.indent;
  if (indent) {
    if (indent.left && indent.left > 0) {
      element.style.paddingLeft = `${indent.left}px`;
    }
    if (indent.right && indent.right > 0) {
      element.style.paddingRight = `${indent.right}px`;
    }
    const hasNegativeLeftIndent = indent.left != null && indent.left < 0;
    if (!hasNegativeLeftIndent) {
      const textIndent = (indent.firstLine ?? 0) - (indent.hanging ?? 0);
      if (textIndent) {
        element.style.textIndent = `${textIndent}px`;
      }
    }
  }
};
const getParagraphBorderBox = (fragmentWidth, indent) => {
  const indentLeft = Number.isFinite(indent?.left) ? indent.left : 0;
  const indentRight = Number.isFinite(indent?.right) ? indent.right : 0;
  const firstLine = Number.isFinite(indent?.firstLine) ? indent.firstLine : 0;
  const hanging = Number.isFinite(indent?.hanging) ? indent.hanging : 0;
  const firstLineOffset = firstLine - hanging;
  const minLeftInset = Math.min(indentLeft, indentLeft + firstLineOffset);
  const leftInset = Math.max(0, minLeftInset);
  const rightInset = Math.max(0, indentRight);
  return {
    leftInset,
    width: Math.max(0, fragmentWidth - leftInset - rightInset)
  };
};
const createParagraphDecorationLayers = (doc2, fragmentWidth, attrs) => {
  if (!attrs?.borders && !attrs?.shading) return {};
  const borderBox = getParagraphBorderBox(fragmentWidth, attrs.indent);
  const baseStyles = {
    position: "absolute",
    top: "0px",
    bottom: "0px",
    left: `${borderBox.leftInset}px`,
    width: `${borderBox.width}px`,
    pointerEvents: "none",
    boxSizing: "border-box"
  };
  let shadingLayer;
  if (attrs.shading) {
    shadingLayer = doc2.createElement("div");
    shadingLayer.classList.add("superdoc-paragraph-shading");
    Object.assign(shadingLayer.style, baseStyles);
    applyParagraphShadingStyles(shadingLayer, attrs.shading);
  }
  let borderLayer;
  if (attrs.borders) {
    borderLayer = doc2.createElement("div");
    borderLayer.classList.add("superdoc-paragraph-border");
    Object.assign(borderLayer.style, baseStyles);
    borderLayer.style.zIndex = "1";
    applyParagraphBorderStyles(borderLayer, attrs.borders);
  }
  return { shadingLayer, borderLayer };
};
const BORDER_SIDES = ["top", "right", "bottom", "left"];
const applyParagraphBorderStyles = (element, borders) => {
  if (!borders) return;
  element.style.boxSizing = "border-box";
  BORDER_SIDES.forEach((side) => {
    const border = borders[side];
    if (!border) return;
    setBorderSideStyle(element, side, border);
  });
};
const setBorderSideStyle = (element, side, border) => {
  const cssSide = side;
  const resolvedStyle = border.style && border.style !== "none" ? border.style : border.style === "none" ? "none" : "solid";
  if (resolvedStyle === "none") {
    element.style.setProperty(`border-${cssSide}-style`, "none");
    element.style.setProperty(`border-${cssSide}-width`, "0px");
    if (border.color) {
      element.style.setProperty(`border-${cssSide}-color`, border.color);
    }
    return;
  }
  const width = border.width != null ? Math.max(0, border.width) : void 0;
  element.style.setProperty(`border-${cssSide}-style`, resolvedStyle);
  element.style.setProperty(`border-${cssSide}-width`, `${width ?? 1}px`);
  element.style.setProperty(`border-${cssSide}-color`, border.color ?? "#000");
};
const stripListIndent = (attrs) => {
  if (!attrs?.indent || attrs.indent.left == null) {
    return attrs;
  }
  const nextIndent = { ...attrs.indent };
  delete nextIndent.left;
  return {
    ...attrs,
    indent: Object.keys(nextIndent).length > 0 ? nextIndent : void 0
  };
};
const applyParagraphShadingStyles = (element, shading) => {
  if (!shading?.fill) return;
  element.style.backgroundColor = shading.fill;
};
const sliceRunsForLine$1 = (block, line) => {
  const result = [];
  for (let runIndex = line.fromRun; runIndex <= line.toRun; runIndex += 1) {
    const run = block.runs[runIndex];
    if (!run) continue;
    if (run.kind === "image") {
      result.push(run);
      continue;
    }
    if (run.kind === "lineBreak") {
      result.push(run);
      continue;
    }
    if (run.kind === "break") {
      result.push(run);
      continue;
    }
    if (run.kind === "tab") {
      result.push(run);
      continue;
    }
    if (run.kind === "fieldAnnotation") {
      result.push(run);
      continue;
    }
    if (!("text" in run)) {
      continue;
    }
    const text = run.text ?? "";
    const isFirstRun = runIndex === line.fromRun;
    const isLastRun = runIndex === line.toRun;
    const runLength = text.length;
    const runPmStart = run.pmStart ?? null;
    const fallbackPmEnd = runPmStart != null && run.pmEnd == null ? runPmStart + runLength : run.pmEnd ?? null;
    if (isFirstRun || isLastRun) {
      const start2 = isFirstRun ? line.fromChar : 0;
      const end2 = isLastRun ? line.toChar : text.length;
      const slice2 = text.slice(start2, end2);
      if (!slice2) continue;
      const pmSliceStart = runPmStart != null ? runPmStart + start2 : void 0;
      const pmSliceEnd = runPmStart != null ? runPmStart + end2 : fallbackPmEnd ?? void 0;
      const sliced = {
        ...run,
        text: slice2,
        pmStart: pmSliceStart,
        pmEnd: pmSliceEnd,
        comments: run.comments ? [...run.comments] : void 0
      };
      result.push(sliced);
    } else {
      result.push(run);
    }
  }
  return result;
};
const applyStyles$2 = (el, styles) => {
  Object.entries(styles).forEach(([key2, value]) => {
    if (value != null && value !== "" && key2 in el.style) {
      el.style[key2] = String(value);
    }
  });
};
const resolveRunText = (run, context) => {
  const runToken = "token" in run ? run.token : void 0;
  if (run.kind === "tab") {
    return run.text;
  }
  if (run.kind === "image") {
    return "";
  }
  if (run.kind === "lineBreak") {
    return "";
  }
  if (run.kind === "break") {
    return "";
  }
  if (!("text" in run)) {
    return "";
  }
  if (!runToken) {
    return run.text ?? "";
  }
  if (runToken === "pageNumber") {
    return context.pageNumberText ?? String(context.pageNumber);
  }
  if (runToken === "totalPageCount") {
    return context.totalPages ? String(context.totalPages) : run.text ?? "";
  }
  return run.text ?? "";
};
const computeTabWidth = (currentPos, justification, tabs, hangingIndent, firstLineIndent, leftIndent) => {
  const nextDefaultTabStop = currentPos + DEFAULT_TAB_INTERVAL_PX$1 - currentPos % DEFAULT_TAB_INTERVAL_PX$1;
  let tabWidth;
  if ((justification ?? "left") === "left") {
    const explicitTabs = [...tabs ?? []];
    if (hangingIndent && hangingIndent > 0) {
      const implicitTabPos = leftIndent;
      explicitTabs.push(implicitTabPos);
      explicitTabs.sort((a, b2) => {
        if (typeof a === "number" && typeof b2 === "number") {
          return a - b2;
        }
        return 0;
      });
    }
    let targetTabStop;
    if (Array.isArray(explicitTabs) && explicitTabs.length > 0) {
      for (const tab of explicitTabs) {
        if (typeof tab === "number" && tab > currentPos) {
          targetTabStop = tab;
          break;
        }
      }
    }
    if (targetTabStop === void 0) {
      targetTabStop = nextDefaultTabStop;
    }
    tabWidth = targetTabStop - currentPos;
  } else if (justification === "right") {
    if (firstLineIndent != null && firstLineIndent > 0) {
      tabWidth = nextDefaultTabStop - currentPos;
    } else {
      tabWidth = hangingIndent ?? 0;
    }
  } else {
    tabWidth = nextDefaultTabStop - currentPos;
  }
  return tabWidth;
};
const createDomPainter = (options) => {
  const painter = new DomPainter(options.blocks, options.measures, {
    pageStyles: options.pageStyles,
    layoutMode: options.layoutMode,
    pageGap: options.pageGap,
    headerProvider: options.headerProvider,
    footerProvider: options.footerProvider,
    virtualization: options.virtualization,
    ruler: options.ruler
  });
  return {
    paint(layout, mount2, mapping) {
      painter.paint(layout, mount2, mapping);
    },
    setData(blocks, measures, headerBlocks, headerMeasures, footerBlocks, footerMeasures) {
      painter.setData(blocks, measures, headerBlocks, headerMeasures, footerBlocks, footerMeasures);
    },
    // Non-standard extension for demo app to avoid re-instantiating on provider changes
    setProviders(header, footer) {
      painter.setProviders(header, footer);
    },
    setVirtualizationPins(pageIndices) {
      painter.setVirtualizationPins(pageIndices);
    },
    setActiveComment(commentId) {
      painter.setActiveComment(commentId);
    },
    getActiveComment() {
      return painter.getActiveComment();
    }
  };
};
const DEFAULT_CONFIG = {
  logLevel: "off",
  hud: false,
  dumpRects: false,
  disableRectDedupe: false
};
const levelOrder = {
  error: 0,
  warn: 1,
  info: 2,
  verbose: 3
};
function getSelectionDebugConfig() {
  if (typeof window === "undefined") {
    return DEFAULT_CONFIG;
  }
  window.superdocDebug ??= {};
  window.superdocDebug.selection ??= {};
  const cfg = window.superdocDebug.selection;
  return {
    logLevel: cfg.logLevel ?? DEFAULT_CONFIG.logLevel,
    hud: cfg.hud ?? DEFAULT_CONFIG.hud,
    dumpRects: cfg.dumpRects ?? DEFAULT_CONFIG.dumpRects,
    disableRectDedupe: cfg.disableRectDedupe ?? DEFAULT_CONFIG.disableRectDedupe
  };
}
function debugLog(level, message, data) {
  const cfg = getSelectionDebugConfig();
  if (cfg.logLevel === "off") return;
  if (levelOrder[level] > levelOrder[cfg.logLevel]) return;
  const prefix2 = "[Selection]";
  if (data) {
    console.log(prefix2, message, data);
  } else {
    console.log(prefix2, message);
  }
}
const HUD_DATA_ATTR = "data-superdoc-selection-debug-hud";
function updateSelectionDebugHud(host, state) {
  const cfg = getSelectionDebugConfig();
  const doc2 = host.ownerDocument ?? (typeof document !== "undefined" ? document : null);
  if (!doc2) return;
  const existing = host.querySelector(`[${HUD_DATA_ATTR}="true"]`);
  if (!cfg.hud) {
    existing?.remove();
    return;
  }
  const hud = existing ?? doc2.createElement("div");
  hud.setAttribute(HUD_DATA_ATTR, "true");
  hud.style.position = "absolute";
  hud.style.top = "8px";
  hud.style.left = "8px";
  hud.style.zIndex = "9999";
  hud.style.maxWidth = "420px";
  hud.style.padding = "6px 8px";
  hud.style.borderRadius = "6px";
  hud.style.background = "rgba(0, 0, 0, 0.72)";
  hud.style.color = "white";
  hud.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
  hud.style.fontSize = "12px";
  hud.style.lineHeight = "1.3";
  hud.style.pointerEvents = "none";
  hud.style.whiteSpace = "pre";
  const behind = Math.max(0, state.docEpoch - state.layoutEpoch);
  const selectionText = state.selection ? `${state.selection.from}..${state.selection.to}` : "null";
  const pointerText = state.lastPointer ? `${state.lastPointer.clientX},${state.lastPointer.clientY} -> ${Math.round(state.lastPointer.x)},${Math.round(
    state.lastPointer.y
  )}` : "null";
  const hitText = state.lastHit ? `${state.lastHit.source} pos=${state.lastHit.pos ?? "null"} epoch=${state.lastHit.layoutEpoch ?? "null"} mapped=${state.lastHit.mappedPos ?? "null"}` : "null";
  hud.textContent = [
    `docEpoch=${state.docEpoch} layoutEpoch=${state.layoutEpoch} behind=${behind}`,
    `selection=${selectionText}`,
    `pointer=${pointerText}`,
    `hit=${hitText}`
  ].join("\n");
  if (!existing) {
    host.appendChild(hud);
  }
}
class DomPositionIndex {
  #entries = [];
  get size() {
    return this.#entries.length;
  }
  /**
   * Rebuilds the index by scanning the container for elements with PM position attributes.
   *
   * @param container - The root DOM element to scan (typically the painter host)
   * @param options - Options controlling index behavior
   *
   * @remarks
   * This method performs the following steps:
   * 1. Queries all elements with both data-pm-start and data-pm-end attributes
   * 2. Filters out inline SDT wrapper elements (which are metadata containers)
   * 3. If leafOnly is true (default), filters out container elements that have descendant
   *    PM-position elements, keeping only leaf elements
   * 4. Validates that pmStart and pmEnd are finite numbers with pmEnd >= pmStart
   * 5. Sorts entries by pmStart (ascending), then by pmEnd (ascending)
   *
   * The leafOnly filtering prevents indexing container elements like pages, lines, and
   * fragments which would otherwise overlap with run-level spans and complicate lookups.
   *
   * The sorting ensures that binary search operations work correctly and that entries
   * with the same start position are ordered by their end position.
   *
   * Safe to call multiple times - each call completely replaces the index. The previous
   * index is discarded.
   */
  rebuild(container, options = {}) {
    const leafOnly = options.leafOnly !== false;
    const nodes = Array.from(container.querySelectorAll("[data-pm-start][data-pm-end]"));
    const entries = [];
    const pmNodes = [];
    for (const node of nodes) {
      if (!(node instanceof HTMLElement)) continue;
      pmNodes.push(node);
    }
    const nonLeaf = /* @__PURE__ */ new WeakSet();
    if (leafOnly) {
      const pmNodeSet = /* @__PURE__ */ new WeakSet();
      pmNodes.forEach((n) => pmNodeSet.add(n));
      for (const node of pmNodes) {
        let parent = node.parentElement;
        while (parent && parent !== container) {
          if (pmNodeSet.has(parent)) {
            nonLeaf.add(parent);
          }
          parent = parent.parentElement;
        }
      }
    }
    for (const node of pmNodes) {
      if (node.classList.contains(DOM_CLASS_NAMES.INLINE_SDT_WRAPPER)) continue;
      if (node.closest(".superdoc-page-header, .superdoc-page-footer")) continue;
      if (leafOnly && nonLeaf.has(node)) continue;
      const pmStart = Number(node.dataset.pmStart ?? "NaN");
      const pmEnd = Number(node.dataset.pmEnd ?? "NaN");
      if (!Number.isFinite(pmStart) || !Number.isFinite(pmEnd)) continue;
      if (pmEnd < pmStart) continue;
      entries.push({ pmStart, pmEnd, el: node });
    }
    entries.sort((a, b2) => a.pmStart - b2.pmStart !== 0 ? a.pmStart - b2.pmStart : a.pmEnd - b2.pmEnd);
    this.#entries = entries;
    const isVerbose = getSelectionDebugConfig().logLevel === "verbose";
    if (isVerbose) {
      const counts = { total: entries.length, body: 0, header: 0, footer: 0 };
      const bodySamples = [];
      const headerSamples = [];
      const footerSamples = [];
      for (const entry of entries) {
        const pageEl = entry.el.closest(`.${DOM_CLASS_NAMES.PAGE}`);
        const pageIndex = pageEl?.dataset.pageIndex ?? null;
        const section = entry.el.closest(".superdoc-page-header") ? "header" : entry.el.closest(".superdoc-page-footer") ? "footer" : "body";
        if (section === "header") {
          counts.header += 1;
          if (headerSamples.length < 10) {
            headerSamples.push({
              pmStart: entry.pmStart,
              pmEnd: entry.pmEnd,
              pageIndex,
              text: (entry.el.textContent ?? "").slice(0, 40)
            });
          }
          continue;
        }
        if (section === "footer") {
          counts.footer += 1;
          if (footerSamples.length < 10) {
            footerSamples.push({
              pmStart: entry.pmStart,
              pmEnd: entry.pmEnd,
              pageIndex,
              text: (entry.el.textContent ?? "").slice(0, 40)
            });
          }
          continue;
        }
        counts.body += 1;
        if (bodySamples.length < 10) {
          bodySamples.push({
            pmStart: entry.pmStart,
            pmEnd: entry.pmEnd,
            pageIndex,
            text: (entry.el.textContent ?? "").slice(0, 40)
          });
        }
      }
      debugLog(
        "verbose",
        `DomPositionIndex: rebuild summary ${JSON.stringify({
          counts,
          bodySamples,
          headerSamples,
          footerSamples
        })}`
      );
    }
  }
  /**
   * Finds the index entry whose position range contains the given position.
   *
   * @param pos - The ProseMirror position to look up
   * @returns The entry containing this position, or null if none found
   *
   * @remarks
   * Uses binary search (upper bound) to efficiently find the rightmost entry whose
   * pmStart is less than or equal to pos, then validates that pos is within the
   * entry's [pmStart, pmEnd] range.
   *
   * Time complexity: O(log n) where n is the number of entries.
   *
   * Returns null if:
   * - The position is not a finite number
   * - The index is empty
   * - No entry contains the position (position is in a gap between entries)
   *
   * For positions that fall exactly on entry boundaries:
   * - If pos equals entry.pmStart, the entry is returned
   * - If pos equals entry.pmEnd, the entry is returned
   * - Due to sorting, if multiple entries could match, the first in sort order is returned
   */
  findEntryAtPosition(pos) {
    if (!Number.isFinite(pos)) return null;
    const entries = this.#entries;
    if (entries.length === 0) return null;
    let lo = 0;
    let hi = entries.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (entries[mid].pmStart <= pos) {
        lo = mid + 1;
      } else {
        hi = mid;
      }
    }
    const idx = lo - 1;
    if (idx < 0) return null;
    const entry = entries[idx];
    if (pos < entry.pmStart || pos > entry.pmEnd) return null;
    return entry;
  }
  findElementAtPosition(pos) {
    return this.findEntryAtPosition(pos)?.el ?? null;
  }
  /**
   * Finds all index entries whose position ranges overlap with the given range.
   *
   * @param from - The start of the query range (inclusive)
   * @param to - The end of the query range (exclusive)
   * @returns Array of entries that overlap the range, in index order
   *
   * @remarks
   * An entry overlaps the query range [start, end) if:
   * - entry.pmStart < end (entry starts before query range ends)
   * - entry.pmEnd > start (entry ends after query range starts)
   *
   * The algorithm:
   * 1. Normalizes the range (swaps from/to if necessary)
   * 2. Uses binary search to find the first potentially overlapping entry
   * 3. Scans forward, collecting overlapping entries until entries start beyond the range
   *
   * Time complexity: O(log n + k) where n is total entries and k is the number of matching entries.
   *
   * Returns empty array if:
   * - Either from or to is not a finite number
   * - from equals to (zero-length range)
   * - The index is empty
   * - No entries overlap the range
   *
   * Edge cases:
   * - Zero-length ranges (from === to) return empty array
   * - Reversed ranges are automatically normalized (from > to is handled)
   */
  findEntriesInRange(from3, to) {
    if (!Number.isFinite(from3) || !Number.isFinite(to)) return [];
    const start2 = Math.min(from3, to);
    const end2 = Math.max(from3, to);
    if (start2 === end2) return [];
    const entries = this.#entries;
    if (entries.length === 0) return [];
    let lo = 0;
    let hi = entries.length;
    while (lo < hi) {
      const mid = lo + hi >>> 1;
      if (entries[mid].pmStart < start2) {
        lo = mid + 1;
      } else {
        hi = mid;
      }
    }
    let idx = Math.max(0, lo - 1);
    while (idx < entries.length && entries[idx].pmEnd < start2) {
      idx += 1;
    }
    const out = [];
    for (let i = idx; i < entries.length; i += 1) {
      const entry = entries[i];
      if (entry.pmStart >= end2) break;
      if (entry.pmEnd <= start2) continue;
      out.push(entry);
    }
    return out;
  }
  /**
   * Finds all DOM elements whose position ranges overlap with the given range.
   *
   * @param from - The start of the query range (inclusive)
   * @param to - The end of the query range (exclusive)
   * @returns Array of DOM elements that overlap the range, in index order
   *
   * @remarks
   * This is a convenience method that calls findEntriesInRange() and extracts the
   * element references from each entry.
   *
   * See findEntriesInRange() for details on the overlap algorithm and edge cases.
   */
  findElementsInRange(from3, to) {
    return this.findEntriesInRange(from3, to).map((e) => e.el);
  }
}
class DomPositionIndexObserverManager {
  #windowRoot;
  #getPainterHost;
  #onRebuild;
  #observer = null;
  #rebuildScheduled = false;
  #rebuildRafId = null;
  /**
   * Creates a new DomPositionIndexObserverManager.
   *
   * @param options - Configuration options
   * @param options.windowRoot - The window object to use for MutationObserver and requestAnimationFrame
   * @param options.getPainterHost - Function that returns the current painter host element (may change over time)
   * @param options.onRebuild - Callback invoked when a rebuild should occur
   */
  constructor(options) {
    this.#windowRoot = options.windowRoot;
    this.#getPainterHost = options.getPainterHost;
    this.#onRebuild = options.onRebuild;
  }
  /**
   * Initializes the MutationObserver and begins observing the painter host.
   *
   * @remarks
   * Creates a new MutationObserver that watches for child list changes and schedules
   * rebuilds when mutations occur. Automatically calls resume() to start observing.
   *
   * If the environment does not support MutationObserver, this method returns early
   * without error. If an observer already exists, it is disconnected before creating
   * a new one.
   *
   * Safe to call multiple times (e.g., when the painter host changes).
   */
  setup() {
    if (typeof this.#windowRoot.MutationObserver !== "function") {
      return;
    }
    this.#observer?.disconnect();
    this.#observer = new this.#windowRoot.MutationObserver(() => {
      this.scheduleRebuild();
    });
    this.resume();
  }
  /**
   * Pauses observation by disconnecting the MutationObserver.
   *
   * @remarks
   * Use this during periods of known rapid DOM changes (e.g., layout updates) to avoid
   * unnecessary rebuild scheduling. The observer can be reactivated by calling resume().
   *
   * Safe to call when no observer exists or when already paused.
   */
  pause() {
    this.#observer?.disconnect();
  }
  /**
   * Resumes observation by reconnecting the MutationObserver to the painter host.
   *
   * @remarks
   * Attempts to observe the painter host's childList changes. If the observer doesn't exist,
   * the painter host is not available, or the observe() call fails, this method returns
   * gracefully without throwing.
   *
   * Safe to call multiple times or when already observing.
   */
  resume() {
    const observer = this.#observer;
    if (!observer) return;
    const painterHost = this.#getPainterHost();
    if (!painterHost) return;
    try {
      observer.observe(painterHost, { childList: true });
    } catch {
    }
  }
  /**
   * Permanently tears down the observer and cancels any scheduled rebuilds.
   *
   * @remarks
   * After calling destroy(), this instance should not be used again. The observer is
   * disconnected, all references are cleared, and any pending rebuild is cancelled.
   *
   * Safe to call multiple times.
   */
  destroy() {
    this.#observer?.disconnect();
    this.#observer = null;
    this.#rebuildScheduled = false;
    if (this.#rebuildRafId != null && typeof this.#windowRoot.cancelAnimationFrame === "function") {
      this.#windowRoot.cancelAnimationFrame(this.#rebuildRafId);
    }
    this.#rebuildRafId = null;
  }
  /**
   * Schedules a debounced rebuild of the DomPositionIndex.
   *
   * @remarks
   * Uses requestAnimationFrame to debounce multiple rapid mutations into a single rebuild.
   * If a rebuild is already scheduled, this method returns early without scheduling another.
   *
   * The rebuild callback is only invoked if:
   * - The painter host still exists
   * - The painter host is still connected to the DOM
   *
   * This prevents unnecessary rebuilds when the painter host has been removed or is being
   * torn down.
   */
  scheduleRebuild() {
    if (this.#rebuildScheduled) return;
    this.#rebuildScheduled = true;
    this.#rebuildRafId = this.#windowRoot.requestAnimationFrame(() => {
      this.#rebuildScheduled = false;
      this.#rebuildRafId = null;
      const painterHost = this.#getPainterHost();
      if (!painterHost?.isConnected) return;
      this.#onRebuild();
    });
  }
}
function computeSelectionRectsFromDom(options, from3, to) {
  const painterHost = options.painterHost;
  if (!painterHost) return null;
  const layout = options.layout;
  if (!layout) return null;
  if (!Number.isFinite(from3) || !Number.isFinite(to)) return null;
  const start2 = Math.min(from3, to);
  const end2 = Math.max(from3, to);
  if (start2 === end2) return [];
  if (options.domPositionIndex.size === 0) {
    options.rebuildDomPositionIndex();
  }
  const zoom = options.zoom;
  const pageHeight = options.pageHeight;
  const pageGap = options.pageGap;
  const pageEls = Array.from(
    painterHost.querySelectorAll(`.${DOM_CLASS_NAMES.PAGE}[data-page-index]`)
  );
  const out = [];
  let rebuiltOnce = false;
  const debugConfig = getSelectionDebugConfig();
  const isVerbose = debugConfig.logLevel === "verbose";
  const dumpRects = isVerbose && debugConfig.dumpRects;
  const disableRectDedupe = debugConfig.disableRectDedupe;
  const entryDebugInfo = (entry) => {
    const pageEl = entry.el.closest(`.${DOM_CLASS_NAMES.PAGE}`);
    const section = entry.el.closest(".superdoc-page-header") ? "header" : entry.el.closest(".superdoc-page-footer") ? "footer" : "body";
    return {
      pmStart: entry.pmStart,
      pmEnd: entry.pmEnd,
      pageIndex: pageEl?.dataset.pageIndex ?? null,
      section,
      connected: entry.el.isConnected,
      layoutEpoch: entry.el.dataset.layoutEpoch ?? null,
      pageEpoch: pageEl?.dataset.layoutEpoch ?? null,
      text: (entry.el.textContent ?? "").slice(0, 80)
    };
  };
  const rectDebugInfo = (rect) => ({
    x: rect.x,
    y: rect.y,
    width: rect.width,
    height: rect.height,
    top: rect.top,
    left: rect.left,
    right: rect.right,
    bottom: rect.bottom
  });
  for (const pageEl of pageEls) {
    const pageIndex = Number(pageEl.dataset.pageIndex ?? "NaN");
    if (!Number.isFinite(pageIndex)) continue;
    const page = layout.pages[pageIndex];
    if (!page) continue;
    let pagePmStart = Infinity;
    let pagePmEnd = -Infinity;
    for (const fragment of page.fragments) {
      const pmStart = fragment.pmStart;
      const pmEnd = fragment.pmEnd;
      if (typeof pmStart === "number" && Number.isFinite(pmStart)) pagePmStart = Math.min(pagePmStart, pmStart);
      if (typeof pmEnd === "number" && Number.isFinite(pmEnd)) pagePmEnd = Math.max(pagePmEnd, pmEnd);
    }
    if (!Number.isFinite(pagePmStart) || !Number.isFinite(pagePmEnd) || pagePmEnd <= pagePmStart) {
      continue;
    }
    const sliceFrom = Math.max(start2, pagePmStart);
    const sliceTo = Math.min(end2, pagePmEnd);
    if (sliceFrom >= sliceTo) continue;
    let sliceEntries = options.domPositionIndex.findEntriesInRange(sliceFrom, sliceTo);
    if (sliceEntries.length === 0) {
      continue;
    }
    if (isVerbose) {
      debugLog(
        "verbose",
        `DOM selection rects: slice entries ${JSON.stringify({
          pageIndex,
          sliceFrom,
          sliceTo,
          entriesCount: sliceEntries.length,
          entriesPreview: sliceEntries.slice(0, 20).map(entryDebugInfo)
        })}`
      );
    }
    let startEntry = options.domPositionIndex.findEntryAtPosition(sliceFrom) ?? sliceEntries[0];
    let endEntry = options.domPositionIndex.findEntryAtPosition(sliceTo) ?? sliceEntries[sliceEntries.length - 1];
    if (isVerbose) {
      debugLog(
        "verbose",
        `DOM selection rects: boundaries ${JSON.stringify({
          pageIndex,
          sliceFrom,
          sliceTo,
          start: entryDebugInfo(startEntry),
          end: entryDebugInfo(endEntry)
        })}`
      );
    }
    let startContained = pageEl.contains(startEntry.el);
    let endContained = pageEl.contains(endEntry.el);
    if (!startContained || !endContained) {
      if (isVerbose) {
        debugLog(
          "verbose",
          `DOM selection rects: boundary containment ${JSON.stringify({
            pageIndex,
            sliceFrom,
            sliceTo,
            startContained,
            endContained
          })}`
        );
      }
      if (!rebuiltOnce) {
        options.rebuildDomPositionIndex();
        rebuiltOnce = true;
        sliceEntries = options.domPositionIndex.findEntriesInRange(sliceFrom, sliceTo);
        if (sliceEntries.length === 0) continue;
        startEntry = options.domPositionIndex.findEntryAtPosition(sliceFrom) ?? sliceEntries[0];
        endEntry = options.domPositionIndex.findEntryAtPosition(sliceTo) ?? sliceEntries[sliceEntries.length - 1];
        startContained = pageEl.contains(startEntry.el);
        endContained = pageEl.contains(endEntry.el);
        if (isVerbose) {
          debugLog(
            "verbose",
            `DOM selection rects: boundary containment after rebuild ${JSON.stringify({
              pageIndex,
              sliceFrom,
              sliceTo,
              startContained,
              endContained,
              start: entryDebugInfo(startEntry),
              end: entryDebugInfo(endEntry)
            })}`
          );
        }
      }
      if (!startContained || !endContained) {
        debugLog(
          "warn",
          `DOM selection rects: stale index after rebuild ${JSON.stringify({
            pageIndex,
            sliceFrom,
            sliceTo,
            start: entryDebugInfo(startEntry),
            end: entryDebugInfo(endEntry)
          })}`
        );
        return null;
      }
    }
    const doc2 = pageEl.ownerDocument ?? document;
    const range = doc2.createRange();
    try {
      if (!setDomRangeStart(range, startEntry, sliceFrom)) return null;
      if (!setDomRangeEnd(range, endEntry, sliceTo)) return null;
    } catch (error) {
      debugLog("warn", "DOM selection rects: Range boundary set failed", { error: String(error) });
      return null;
    }
    let clientRects = [];
    try {
      let rawRects = Array.from(range.getClientRects());
      if (dumpRects) {
        debugLog(
          "verbose",
          `DOM selection rects: raw rects ${JSON.stringify({
            pageIndex,
            sliceFrom,
            sliceTo,
            rects: rawRects.map(rectDebugInfo)
          })}`
        );
      }
      let missingEntries = null;
      if (typeof range.intersectsNode === "function") {
        for (const entry of sliceEntries) {
          try {
            if (!range.intersectsNode(entry.el)) {
              missingEntries ??= [];
              missingEntries.push(entry);
            }
          } catch {
          }
        }
      }
      if (missingEntries && missingEntries.length > 0) {
        if (isVerbose) {
          debugLog(
            "verbose",
            `DOM selection rects: range missing entries ${JSON.stringify({
              pageIndex,
              sliceFrom,
              sliceTo,
              missingCount: missingEntries.length,
              missingPreview: missingEntries.slice(0, 20).map(entryDebugInfo)
            })}`
          );
        }
        rawRects = collectClientRectsByLine(doc2, sliceEntries, sliceFrom, sliceTo);
        if (dumpRects) {
          debugLog(
            "verbose",
            `DOM selection rects: fallback raw rects ${JSON.stringify({
              pageIndex,
              sliceFrom,
              sliceTo,
              rects: rawRects.map(rectDebugInfo)
            })}`
          );
        }
      }
      clientRects = disableRectDedupe ? rawRects : deduplicateOverlappingRects(rawRects);
      if (dumpRects) {
        debugLog(
          "verbose",
          `DOM selection rects: final rects ${JSON.stringify({
            pageIndex,
            sliceFrom,
            sliceTo,
            dedupeDisabled: disableRectDedupe,
            rects: clientRects.map(rectDebugInfo)
          })}`
        );
        const nonPositive = clientRects.filter(
          (rect) => !Number.isFinite(rect.width) || !Number.isFinite(rect.height) || rect.width <= 0 || rect.height <= 0
        );
        if (nonPositive.length > 0) {
          debugLog(
            "verbose",
            `DOM selection rects: non-positive rects ${JSON.stringify({
              pageIndex,
              sliceFrom,
              sliceTo,
              rects: nonPositive.map(rectDebugInfo)
            })}`
          );
        }
      }
    } catch (error) {
      debugLog("warn", "DOM selection rects: getClientRects failed", { error: String(error) });
      return null;
    }
    const pageRect = pageEl.getBoundingClientRect();
    for (const r2 of clientRects) {
      const width = r2.width / zoom;
      const height = r2.height / zoom;
      if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) continue;
      const localX = (r2.left - pageRect.left) / zoom;
      const localY = (r2.top - pageRect.top) / zoom;
      if (!Number.isFinite(localX) || !Number.isFinite(localY)) continue;
      out.push({
        pageIndex,
        x: localX,
        y: pageIndex * (pageHeight + pageGap) + localY,
        width: Math.max(1, width),
        height: Math.max(1, height)
      });
    }
  }
  return out;
}
function collectClientRectsByLine(doc2, entries, sliceFrom, sliceTo) {
  const rects = [];
  const lineMap = /* @__PURE__ */ new Map();
  const looseEntries = [];
  for (const entry of entries) {
    const lineEl = entry.el.closest(".superdoc-line");
    if (!lineEl) {
      looseEntries.push(entry);
      continue;
    }
    const list = lineMap.get(lineEl);
    if (list) {
      list.push(entry);
    } else {
      lineMap.set(lineEl, [entry]);
    }
  }
  for (const [, lineEntries] of lineMap) {
    lineEntries.sort((a, b2) => a.pmStart - b2.pmStart !== 0 ? a.pmStart - b2.pmStart : a.pmEnd - b2.pmEnd);
    const linePmStart = lineEntries[0]?.pmStart ?? Infinity;
    const linePmEnd = lineEntries[lineEntries.length - 1]?.pmEnd ?? -Infinity;
    if (!Number.isFinite(linePmStart) || !Number.isFinite(linePmEnd) || linePmEnd <= linePmStart) continue;
    const lineFrom = Math.max(sliceFrom, linePmStart);
    const lineTo = Math.min(sliceTo, linePmEnd);
    if (lineFrom >= lineTo) continue;
    const startEntry = lineEntries.find((entry) => lineFrom >= entry.pmStart && lineFrom <= entry.pmEnd) ?? lineEntries[0];
    const endEntry = lineEntries.find((entry) => lineTo >= entry.pmStart && lineTo <= entry.pmEnd) ?? lineEntries[lineEntries.length - 1];
    const range = doc2.createRange();
    try {
      if (!setDomRangeStart(range, startEntry, lineFrom)) continue;
      if (!setDomRangeEnd(range, endEntry, lineTo)) continue;
    } catch {
      continue;
    }
    rects.push(...Array.from(range.getClientRects()));
  }
  for (const entry of looseEntries) {
    const entryFrom = Math.max(sliceFrom, entry.pmStart);
    const entryTo = Math.min(sliceTo, entry.pmEnd);
    if (entryFrom >= entryTo) continue;
    const range = doc2.createRange();
    try {
      if (!setDomRangeStart(range, entry, entryFrom)) continue;
      if (!setDomRangeEnd(range, entry, entryTo)) continue;
    } catch {
      continue;
    }
    rects.push(...Array.from(range.getClientRects()));
  }
  return rects;
}
function setDomRangeStart(range, entry, pos) {
  const el = entry.el;
  const pmStart = entry.pmStart;
  const firstChild = el.firstChild;
  if (firstChild && firstChild.nodeType === Node.TEXT_NODE) {
    const textNode = firstChild;
    const charIndex = mapPmPosToCharIndex(pos, pmStart, entry.pmEnd, textNode.length);
    range.setStart(textNode, charIndex);
    return true;
  }
  if (!el.isConnected || !el.parentNode) return false;
  if (pos <= pmStart) {
    range.setStartBefore(el);
    return true;
  }
  range.setStartAfter(el);
  return true;
}
function setDomRangeEnd(range, entry, pos) {
  const el = entry.el;
  const pmStart = entry.pmStart;
  const firstChild = el.firstChild;
  if (firstChild && firstChild.nodeType === Node.TEXT_NODE) {
    const textNode = firstChild;
    const charIndex = mapPmPosToCharIndex(pos, pmStart, entry.pmEnd, textNode.length);
    range.setEnd(textNode, charIndex);
    return true;
  }
  if (!el.isConnected || !el.parentNode) return false;
  if (pos <= pmStart) {
    range.setEndBefore(el);
    return true;
  }
  range.setEndAfter(el);
  return true;
}
function computeDomCaretPageLocal(options, pos) {
  if (!options.painterHost) return null;
  if (options.domPositionIndex.size === 0) {
    options.rebuildDomPositionIndex();
  }
  let entry = options.domPositionIndex.findEntryAtPosition(pos);
  if (entry && !entry.el.isConnected) {
    options.rebuildDomPositionIndex();
    entry = options.domPositionIndex.findEntryAtPosition(pos);
  }
  if (!entry) return null;
  const targetEl = entry.el;
  const page = targetEl.closest(`.${DOM_CLASS_NAMES.PAGE}`);
  if (!page) return null;
  const pageRect = page.getBoundingClientRect();
  const zoom = options.zoom;
  const textNode = targetEl.firstChild;
  if (!textNode || textNode.nodeType !== Node.TEXT_NODE) {
    const elRect = targetEl.getBoundingClientRect();
    return {
      pageIndex: Number(page.dataset.pageIndex ?? "0"),
      x: (elRect.left - pageRect.left) / zoom,
      y: (elRect.top - pageRect.top) / zoom
    };
  }
  const charIndex = mapPmPosToCharIndex(pos, entry.pmStart, entry.pmEnd, textNode.length);
  const range = document.createRange();
  range.setStart(textNode, charIndex);
  range.setEnd(textNode, charIndex);
  const rangeRect = range.getBoundingClientRect();
  const lineEl = targetEl.closest(".superdoc-line");
  const lineRect = lineEl?.getBoundingClientRect() ?? rangeRect;
  return {
    pageIndex: Number(page.dataset.pageIndex ?? "0"),
    x: (rangeRect.left - pageRect.left) / zoom,
    y: (lineRect.top - pageRect.top) / zoom
  };
}
function mapPmPosToCharIndex(pos, pmStart, pmEnd, textLength) {
  if (!Number.isFinite(pos) || !Number.isFinite(pmStart) || !Number.isFinite(pmEnd)) {
    return 0;
  }
  if (textLength <= 0) {
    return 0;
  }
  const pmRange = pmEnd - pmStart;
  if (!Number.isFinite(pmRange) || pmRange <= 0) {
    return 0;
  }
  if (pmRange === textLength) {
    const mapped = pos - pmStart;
    return Math.min(textLength, Math.max(0, mapped));
  }
  if (pos <= pmStart) {
    return 0;
  }
  if (pos >= pmEnd) {
    return textLength;
  }
  const midpoint = pmStart + pmRange / 2;
  return pos <= midpoint ? 0 : textLength;
}
const Y_SORT_THRESHOLD_PX = 2;
const Y_SAME_LINE_THRESHOLD_PX = 3;
const HORIZONTAL_OVERLAP_THRESHOLD = 0.8;
function deduplicateOverlappingRects(rects) {
  if (rects.length <= 1) return rects;
  const sorted = [...rects].sort((a, b2) => {
    const yDiff = a.y - b2.y;
    if (Math.abs(yDiff) > Y_SORT_THRESHOLD_PX) return yDiff;
    return a.x - b2.x;
  });
  const result = [];
  const groups = [];
  let currentGroup = [];
  for (const rect of sorted) {
    if (currentGroup.length === 0) {
      currentGroup.push(rect);
      continue;
    }
    const groupY = currentGroup[0].y;
    if (Math.abs(rect.y - groupY) <= Y_SAME_LINE_THRESHOLD_PX) {
      currentGroup.push(rect);
    } else {
      groups.push(currentGroup);
      currentGroup = [rect];
    }
  }
  if (currentGroup.length > 0) {
    groups.push(currentGroup);
  }
  const SIZE_EPS_PX = 0.5;
  const X_DUPLICATE_EPS_PX = 1;
  const hasSignificantOverlap = (a, b2) => {
    const xOverlapStart = Math.max(a.x, b2.x);
    const xOverlapEnd = Math.min(a.x + a.width, b2.x + b2.width);
    const hasHorizontalOverlap = xOverlapEnd > xOverlapStart;
    if (!hasHorizontalOverlap) return false;
    const overlapWidth = Math.max(0, xOverlapEnd - xOverlapStart);
    const minWidth = Math.min(a.width, b2.width);
    return minWidth > 0 && overlapWidth / minWidth > HORIZONTAL_OVERLAP_THRESHOLD;
  };
  const isLargerRect = (a, b2) => {
    return a.width > b2.width + SIZE_EPS_PX || a.height > b2.height + SIZE_EPS_PX;
  };
  for (const group of groups) {
    const unique2 = [];
    for (const rect of group) {
      const isDuplicate = unique2.some((existing) => {
        const xClose = Math.abs(existing.x - rect.x) <= X_DUPLICATE_EPS_PX;
        const yClose = Math.abs(existing.y - rect.y) <= Y_SAME_LINE_THRESHOLD_PX;
        const widthClose = Math.abs(existing.width - rect.width) <= SIZE_EPS_PX;
        const heightClose = Math.abs(existing.height - rect.height) <= SIZE_EPS_PX;
        return xClose && yClose && widthClose && heightClose;
      });
      if (!isDuplicate) {
        unique2.push(rect);
      }
    }
    if (unique2.length <= 1) {
      result.push(...unique2);
      continue;
    }
    const containers = /* @__PURE__ */ new Set();
    for (const rect of unique2) {
      for (const other of unique2) {
        if (rect === other) continue;
        if (!hasSignificantOverlap(rect, other)) continue;
        if (isLargerRect(rect, other)) {
          containers.add(rect);
          break;
        }
      }
    }
    const filtered = unique2.filter((rect) => !containers.has(rect));
    result.push(...filtered.length > 0 ? filtered : unique2);
  }
  return result;
}
function getPageOffsetX(options) {
  if (!options.painterHost || !options.viewportHost) {
    return null;
  }
  const pageEl = options.painterHost.querySelector(
    `.superdoc-page[data-page-index="${options.pageIndex}"]`
  );
  if (!pageEl) return null;
  const pageRect = pageEl.getBoundingClientRect();
  const viewportRect = options.viewportHost.getBoundingClientRect();
  const offsetX = (pageRect.left - viewportRect.left) / options.zoom;
  return offsetX;
}
function convertPageLocalToOverlayCoords(options) {
  if (!Number.isFinite(options.pageIndex) || options.pageIndex < 0) {
    console.warn(
      `[PresentationEditor] #convertPageLocalToOverlayCoords: Invalid pageIndex ${options.pageIndex}. Expected a finite non-negative number.`
    );
    return null;
  }
  if (!Number.isFinite(options.pageLocalX)) {
    console.warn(
      `[PresentationEditor] #convertPageLocalToOverlayCoords: Invalid pageLocalX ${options.pageLocalX}. Expected a finite number.`
    );
    return null;
  }
  if (!Number.isFinite(options.pageLocalY)) {
    console.warn(
      `[PresentationEditor] #convertPageLocalToOverlayCoords: Invalid pageLocalY ${options.pageLocalY}. Expected a finite number.`
    );
    return null;
  }
  const pageOffsetX = getPageOffsetX({
    painterHost: options.painterHost,
    viewportHost: options.viewportHost,
    zoom: options.zoom,
    pageIndex: options.pageIndex
  }) ?? 0;
  return {
    x: pageOffsetX + options.pageLocalX,
    y: options.pageIndex * (options.pageHeight + options.pageGap) + options.pageLocalY
  };
}
function normalizeClientPoint(options, clientX, clientY) {
  if (!Number.isFinite(clientX) || !Number.isFinite(clientY)) {
    return null;
  }
  const rect = options.viewportHost.getBoundingClientRect();
  const scrollLeft = options.visibleHost.scrollLeft ?? 0;
  const scrollTop = options.visibleHost.scrollTop ?? 0;
  const baseX = (clientX - rect.left + scrollLeft) / options.zoom;
  const baseY = (clientY - rect.top + scrollTop) / options.zoom;
  let adjustedX = baseX;
  const doc2 = options.visibleHost.ownerDocument ?? document;
  const hitChain = typeof doc2.elementsFromPoint === "function" ? doc2.elementsFromPoint(clientX, clientY) : [];
  const pageEl = Array.isArray(hitChain) ? hitChain.find((el) => el?.classList?.contains("superdoc-page")) : null;
  if (pageEl) {
    const pageIndex = Number(pageEl.dataset.pageIndex ?? "NaN");
    if (Number.isFinite(pageIndex)) {
      const pageOffsetX = options.getPageOffsetX(pageIndex);
      if (pageOffsetX != null) {
        adjustedX = baseX - pageOffsetX;
      }
    }
  }
  return {
    x: adjustedX,
    y: baseY
  };
}
function getPageElementByIndex(painterHost, pageIndex) {
  if (!painterHost) return null;
  const pageElements = painterHost.querySelectorAll("[data-page-index]");
  for (let i = 0; i < pageElements.length; i++) {
    const el = pageElements[i];
    const dataPageIndex = el.getAttribute("data-page-index");
    if (dataPageIndex && parseInt(dataPageIndex, 10) === pageIndex) {
      return el;
    }
  }
  return null;
}
function inchesToPx(value) {
  if (value == null) return void 0;
  const num = Number(value);
  if (!Number.isFinite(num)) return void 0;
  return num * 96;
}
function parseColumns(raw) {
  if (!raw || typeof raw !== "object") return void 0;
  const columnSource = raw;
  const rawCount = Number(columnSource.count ?? columnSource.num ?? columnSource.numberOfColumns ?? 1);
  if (!Number.isFinite(rawCount) || rawCount <= 1) {
    return void 0;
  }
  const count = Math.max(1, Math.floor(rawCount));
  const gap = inchesToPx(columnSource.space ?? columnSource.gap) ?? 0;
  return { count, gap };
}
function createLayoutMetrics(perf, startMark, layout, blocks) {
  if (!perf || startMark == null || typeof perf.now !== "function") {
    return void 0;
  }
  const durationMs = Math.max(0, perf.now() - startMark);
  return {
    durationMs,
    blockCount: blocks.length,
    pageCount: layout.pages?.length ?? 0
  };
}
var SectionType = /* @__PURE__ */ ((SectionType2) => {
  SectionType2["CONTINUOUS"] = "continuous";
  SectionType2["NEXT_PAGE"] = "nextPage";
  SectionType2["EVEN_PAGE"] = "evenPage";
  SectionType2["ODD_PAGE"] = "oddPage";
  return SectionType2;
})(SectionType || {});
const DEFAULT_PARAGRAPH_SECTION_TYPE = "nextPage";
const DEFAULT_BODY_SECTION_TYPE = "continuous";
const TWIPS_PER_INCH$4 = 1440;
const PX_PER_INCH$3 = 96;
const DEFAULT_COLUMN_GAP_INCHES = 0.5;
function twipsToPixels$1(twips) {
  const n = Number(twips);
  return Number.isFinite(n) ? n / TWIPS_PER_INCH$4 * PX_PER_INCH$3 : void 0;
}
function parseColumnCount(rawValue) {
  if (rawValue == null) return 1;
  const count = Number(rawValue);
  return Number.isFinite(count) && count > 0 ? count : 1;
}
function parseColumnGap(gapTwips) {
  if (gapTwips == null) return DEFAULT_COLUMN_GAP_INCHES;
  const gap = Number(gapTwips);
  return Number.isFinite(gap) ? gap / TWIPS_PER_INCH$4 : DEFAULT_COLUMN_GAP_INCHES;
}
function extractNormalizedMargins(attrs) {
  const sectionMargins = attrs.sectionMargins;
  return {
    headerPx: typeof sectionMargins?.header === "number" ? sectionMargins.header * 96 : void 0,
    footerPx: typeof sectionMargins?.footer === "number" ? sectionMargins.footer * 96 : void 0
  };
}
function extractSectionType(elements) {
  const typeEl = elements.find((el) => el?.name === "w:type");
  const val = typeEl?.attributes?.["w:val"];
  if (val === "continuous" || val === "nextPage" || val === "evenPage" || val === "oddPage") {
    return val;
  }
  return "nextPage";
}
function extractPageSizeAndOrientation(elements) {
  const pgSz = elements.find((el) => el?.name === "w:pgSz");
  if (!pgSz?.attributes) {
    return { pageSizePx: void 0, orientation: void 0 };
  }
  const a = pgSz.attributes;
  const widthPx = a["w:w"] != null ? twipsToPixels$1(a["w:w"]) : void 0;
  const heightPx = a["w:h"] != null ? twipsToPixels$1(a["w:h"]) : void 0;
  let pageSizePx;
  if (widthPx != null && heightPx != null) {
    pageSizePx = { w: widthPx, h: heightPx };
  }
  let orientation;
  const orient = a["w:orient"];
  if (orient === "portrait" || orient === "landscape") {
    orientation = orient;
  } else if (widthPx != null && heightPx != null) {
    orientation = heightPx > widthPx ? "portrait" : "landscape";
  }
  return { pageSizePx, orientation };
}
function extractFallbackMargins(elements, currentHeader, currentFooter) {
  const pgMar = elements.find((el) => el?.name === "w:pgMar");
  const a = pgMar?.attributes || {};
  return {
    headerPx: currentHeader ?? (a["w:header"] != null ? twipsToPixels$1(a["w:header"]) : void 0),
    footerPx: currentFooter ?? (a["w:footer"] != null ? twipsToPixels$1(a["w:footer"]) : void 0),
    topPx: a["w:top"] != null ? twipsToPixels$1(a["w:top"]) : void 0,
    rightPx: a["w:right"] != null ? twipsToPixels$1(a["w:right"]) : void 0,
    bottomPx: a["w:bottom"] != null ? twipsToPixels$1(a["w:bottom"]) : void 0,
    leftPx: a["w:left"] != null ? twipsToPixels$1(a["w:left"]) : void 0
  };
}
function extractHeaderFooterRefs(elements, refName) {
  const refs = elements.filter((el) => el?.name === refName);
  if (!refs.length) return void 0;
  const out = {};
  refs.forEach((ref) => {
    const refType = ref?.attributes?.["w:type"];
    const typeKey = refType === "first" || refType === "even" || refType === "odd" || refType === "default" ? refType : "default";
    const id = ref?.attributes?.["r:id"];
    if (typeof id === "string" || typeof id === "number") {
      out[typeKey] = String(id);
    }
  });
  return Object.keys(out).length ? out : void 0;
}
function extractPageNumbering(elements) {
  const pgNumType = elements.find((el) => el?.name === "w:pgNumType");
  if (!pgNumType?.attributes) return void 0;
  const fmtRaw = pgNumType.attributes["w:fmt"];
  const validFormats = [
    "decimal",
    "lowerLetter",
    "upperLetter",
    "lowerRoman",
    "upperRoman",
    "numberInDash"
  ];
  const fmt = validFormats.includes(fmtRaw) ? fmtRaw : void 0;
  const startRaw = pgNumType.attributes["w:start"];
  const startNum = startRaw != null ? Number(startRaw) : void 0;
  const effectiveFormat = fmt ?? (Number.isFinite(startNum) ? "decimal" : void 0);
  return {
    format: effectiveFormat,
    ...Number.isFinite(startNum) ? { start: Number(startNum) } : {}
  };
}
function extractColumns(elements) {
  const cols = elements.find((el) => el?.name === "w:cols");
  if (!cols?.attributes) return void 0;
  const count = parseColumnCount(cols.attributes["w:num"]);
  const gapInches = parseColumnGap(cols.attributes["w:space"]);
  return {
    count,
    gap: gapInches * PX_PER_INCH$3
  };
}
function extractVerticalAlign(elements) {
  const vAlign = elements.find((el) => el?.name === "w:vAlign");
  if (!vAlign?.attributes) return void 0;
  const val = vAlign.attributes["w:val"];
  if (val === "top" || val === "center" || val === "bottom" || val === "both") {
    return val;
  }
  return void 0;
}
function extractSectionData(para) {
  const attrs = para.attrs ?? {};
  let { headerPx, footerPx } = extractNormalizedMargins(attrs);
  const paragraphProperties = typeof attrs.paragraphProperties === "object" && attrs.paragraphProperties !== null ? attrs.paragraphProperties : void 0;
  const sectPrElements = paragraphProperties?.sectPr && typeof paragraphProperties.sectPr === "object" && "elements" in paragraphProperties.sectPr && Array.isArray(paragraphProperties.sectPr.elements) ? paragraphProperties.sectPr.elements : void 0;
  if (!sectPrElements) {
    return headerPx == null && footerPx == null ? null : { headerPx, footerPx };
  }
  const type = extractSectionType(sectPrElements);
  const { pageSizePx, orientation } = extractPageSizeAndOrientation(sectPrElements);
  const titlePg = sectPrElements.some((el) => el?.name === "w:titlePg");
  const fallbackMargins = extractFallbackMargins(sectPrElements, headerPx, footerPx);
  headerPx = fallbackMargins.headerPx;
  footerPx = fallbackMargins.footerPx;
  const { topPx, rightPx, bottomPx, leftPx } = fallbackMargins;
  const headerRefs = extractHeaderFooterRefs(sectPrElements, "w:headerReference");
  const footerRefs = extractHeaderFooterRefs(sectPrElements, "w:footerReference");
  const numbering = extractPageNumbering(sectPrElements);
  const columnsPx = extractColumns(sectPrElements);
  const vAlign = extractVerticalAlign(sectPrElements);
  return {
    headerPx,
    footerPx,
    topPx,
    rightPx,
    bottomPx,
    leftPx,
    type,
    pageSizePx,
    orientation,
    columnsPx,
    titlePg,
    headerRefs,
    footerRefs,
    numbering,
    vAlign
  };
}
function isSectPrElement(value) {
  return typeof value === "object" && value !== null && value.type === "element" && value.name === "w:sectPr";
}
function hasSectPr(node) {
  if (node.type !== "paragraph" || !node.attrs) return false;
  const attrs = node.attrs;
  const paragraphProperties = attrs.paragraphProperties;
  if (!paragraphProperties || typeof paragraphProperties !== "object") return false;
  const sectPr = paragraphProperties.sectPr;
  return isSectPrElement(sectPr) || typeof sectPr === "object" && sectPr !== null && "elements" in sectPr && Array.isArray(sectPr.elements);
}
function getSectPrFromNode(node) {
  if (!node.attrs) return null;
  const attrs = node.attrs;
  const paragraphProperties = attrs.paragraphProperties;
  if (!paragraphProperties || typeof paragraphProperties !== "object") return null;
  const sectPr = paragraphProperties.sectPr;
  return isSectPrElement(sectPr) ? sectPr : null;
}
function createSectionBreakBlock(section, blockIdGen, extraAttrs) {
  return {
    kind: "sectionBreak",
    id: blockIdGen("sectionBreak"),
    margins: section.margins ?? { header: 0, footer: 0 },
    type: section.type,
    attrs: {
      source: "sectPr",
      sectionIndex: section.sectionIndex,
      ...extraAttrs
    },
    ...section.pageSize && { pageSize: section.pageSize },
    ...section.orientation && { orientation: section.orientation },
    ...section.columns && { columns: section.columns },
    ...section.numbering ? { numbering: section.numbering } : {},
    ...section.headerRefs && { headerRefs: section.headerRefs },
    ...section.footerRefs && { footerRefs: section.footerRefs },
    ...section.vAlign && { vAlign: section.vAlign }
  };
}
function shouldRequirePageBoundary(current, next) {
  if (!next) return false;
  if (current.orientation && next.orientation && current.orientation !== next.orientation) {
    return true;
  }
  if (current.pageSize && next.pageSize) {
    if (current.pageSize.w !== next.pageSize.w || current.pageSize.h !== next.pageSize.h) {
      return true;
    }
  }
  return false;
}
function hasIntrinsicBoundarySignals(_2) {
  return false;
}
const DEFAULT_HEADER_FOOTER_MARGIN_PX = 0;
function shouldIgnoreSectionBreak(paragraph, index2, total, hasBodySectPr) {
  const paragraphAttrs = paragraph.attrs ?? {};
  const paragraphProperties = paragraphAttrs?.paragraphProperties;
  const sectPr = paragraphProperties?.sectPr;
  if (!sectPr) return true;
  const hasElements = Array.isArray(sectPr.elements) && sectPr.elements.length > 0;
  const hasNormalizedMargins = (() => {
    const normalizedMargins = paragraphAttrs.sectionMargins;
    if (!normalizedMargins) return false;
    return normalizedMargins.header != null || normalizedMargins.footer != null;
  })();
  const isLastParagraphBreak = index2 === total - 1 && !hasBodySectPr;
  if (!hasElements && !hasNormalizedMargins && !isLastParagraphBreak) return true;
  return false;
}
function findParagraphsWithSectPr(doc2) {
  const paragraphs = [];
  let paragraphIndex = 0;
  const getNodeChildren = (node) => {
    if (Array.isArray(node.content)) return node.content;
    const content = node.content;
    if (content && typeof content.forEach === "function") {
      const children = [];
      content.forEach((child) => {
        children.push(child);
      });
      return children;
    }
    return [];
  };
  const visitNode = (node) => {
    if (node.type === "paragraph") {
      if (hasSectPr(node)) {
        paragraphs.push({ index: paragraphIndex, node });
      }
      paragraphIndex++;
      return;
    }
    if (node.type === "index") {
      getNodeChildren(node).forEach(visitNode);
    }
  };
  if (doc2.content) {
    for (const node of doc2.content) {
      visitNode(node);
    }
  }
  return { paragraphs, totalCount: paragraphIndex };
}
function buildSectionRangesFromParagraphs(paragraphs, hasBodySectPr) {
  const ranges = [];
  let currentStart = 0;
  paragraphs.forEach((item, idx) => {
    if (shouldIgnoreSectionBreak(item.node, idx, paragraphs.length, hasBodySectPr)) {
      return;
    }
    const sectionData = extractSectionData(item.node);
    if (!sectionData) return;
    const sectPr = getSectPrFromNode(item.node);
    const hasAnyMargin = sectionData.headerPx != null || sectionData.footerPx != null || sectionData.topPx != null || sectionData.rightPx != null || sectionData.bottomPx != null || sectionData.leftPx != null;
    const range = {
      sectionIndex: idx,
      startParagraphIndex: currentStart,
      endParagraphIndex: item.index,
      sectPr,
      margins: hasAnyMargin ? {
        header: sectionData.headerPx ?? DEFAULT_HEADER_FOOTER_MARGIN_PX,
        footer: sectionData.footerPx ?? DEFAULT_HEADER_FOOTER_MARGIN_PX,
        top: sectionData.topPx,
        right: sectionData.rightPx,
        bottom: sectionData.bottomPx,
        left: sectionData.leftPx
      } : null,
      pageSize: sectionData.pageSizePx ?? null,
      orientation: sectionData.orientation ?? null,
      columns: sectionData.columnsPx ?? null,
      type: sectionData.type ?? DEFAULT_PARAGRAPH_SECTION_TYPE,
      titlePg: sectionData.titlePg ?? false,
      headerRefs: sectionData.headerRefs,
      footerRefs: sectionData.footerRefs,
      numbering: sectionData.numbering,
      vAlign: sectionData.vAlign
    };
    ranges.push(range);
    currentStart = item.index + 1;
  });
  return ranges;
}
function publishSectionMetadata(sectionRanges, options) {
  if (!options?.sectionMetadata) {
    return;
  }
  options.sectionMetadata.length = 0;
  sectionRanges.forEach((section) => {
    options.sectionMetadata?.push({
      sectionIndex: section.sectionIndex,
      headerRefs: section.headerRefs,
      footerRefs: section.footerRefs,
      numbering: section.numbering,
      titlePg: section.titlePg,
      vAlign: section.vAlign
    });
  });
}
function createFinalSectionFromBodySectPr(bodySectPr, currentStart, totalParagraphs, sectionIndex) {
  const clampedStart = Math.max(0, Math.min(currentStart, Math.max(totalParagraphs - 1, 0)));
  const tempNode = {
    attrs: {
      paragraphProperties: { sectPr: bodySectPr }
    }
  };
  const bodySectionData = extractSectionData(tempNode);
  if (!bodySectionData) return null;
  const hasAnyMargin = bodySectionData.headerPx != null || bodySectionData.footerPx != null || bodySectionData.topPx != null || bodySectionData.rightPx != null || bodySectionData.bottomPx != null || bodySectionData.leftPx != null;
  return {
    sectionIndex,
    startParagraphIndex: clampedStart,
    endParagraphIndex: totalParagraphs - 1,
    sectPr: bodySectPr,
    margins: hasAnyMargin ? {
      header: bodySectionData.headerPx ?? DEFAULT_HEADER_FOOTER_MARGIN_PX,
      footer: bodySectionData.footerPx ?? DEFAULT_HEADER_FOOTER_MARGIN_PX,
      top: bodySectionData.topPx,
      right: bodySectionData.rightPx,
      bottom: bodySectionData.bottomPx,
      left: bodySectionData.leftPx
    } : null,
    pageSize: bodySectionData.pageSizePx ?? null,
    orientation: bodySectionData.orientation ?? null,
    columns: bodySectionData.columnsPx ?? null,
    type: bodySectionData.type ?? DEFAULT_BODY_SECTION_TYPE,
    titlePg: bodySectionData.titlePg ?? false,
    headerRefs: bodySectionData.headerRefs,
    footerRefs: bodySectionData.footerRefs,
    numbering: bodySectionData.numbering,
    vAlign: bodySectionData.vAlign
  };
}
function createDefaultFinalSection(currentStart, totalParagraphs, sectionIndex) {
  return {
    sectionIndex,
    startParagraphIndex: currentStart,
    endParagraphIndex: totalParagraphs - 1,
    sectPr: null,
    margins: null,
    pageSize: null,
    orientation: null,
    columns: null,
    type: DEFAULT_BODY_SECTION_TYPE,
    titlePg: false,
    headerRefs: void 0,
    footerRefs: void 0
  };
}
function analyzeSectionRanges(doc2, bodySectPr) {
  const { paragraphs, totalCount } = findParagraphsWithSectPr(doc2);
  const hasBody = Boolean(bodySectPr);
  const ranges = buildSectionRangesFromParagraphs(paragraphs, hasBody);
  const currentStart = ranges.length > 0 ? ranges[ranges.length - 1].endParagraphIndex + 1 : 0;
  if (isSectPrElement(bodySectPr)) {
    const finalSection = createFinalSectionFromBodySectPr(
      bodySectPr,
      Math.min(currentStart, totalCount),
      totalCount,
      ranges.length
    );
    if (finalSection) {
      ranges.push(finalSection);
    }
  } else if (ranges.length > 0) {
    const fallbackFinal = createDefaultFinalSection(Math.min(currentStart, totalCount), totalCount, ranges.length);
    if (fallbackFinal) {
      fallbackFinal.type = DEFAULT_PARAGRAPH_SECTION_TYPE;
      ranges.push(fallbackFinal);
    }
  }
  return ranges;
}
const TWIPS_PER_INCH$3 = 1440;
const PX_PER_INCH$2 = 96;
const PX_PER_PT = 96 / 72;
SectionType.NEXT_PAGE;
SectionType.CONTINUOUS;
const VALID_TRACKED_MODES = ["review", "original", "final", "off"];
const DEFAULT_HYPERLINK_CONFIG$1 = {
  enableRichHyperlinks: false
};
const ATOMIC_INLINE_TYPES = /* @__PURE__ */ new Set([
  "image",
  "hardBreak",
  "lineBreak",
  "page-number",
  "total-page-number",
  "indexEntry",
  "tab",
  "footnoteReference",
  "passthroughInline",
  "bookmarkEnd"
]);
const TOKEN_INLINE_TYPES = /* @__PURE__ */ new Map([
  ["page-number", "pageNumber"],
  ["total-page-number", "totalPageCount"]
]);
const isValidTrackedMode = (value) => {
  return typeof value === "string" && VALID_TRACKED_MODES.includes(value);
};
const isTextRun$4 = (run) => {
  return "text" in run && run.kind !== "tab";
};
const stripTrackedChangeFromRun = (run) => {
  if (!isTextRun$4(run)) return;
  if ("trackedChange" in run && run.trackedChange) {
    delete run.trackedChange;
  }
};
const shouldHideTrackedNode = (meta, config) => {
  if (!meta || !config || !config.enabled) return false;
  if (config.mode === "original" && meta.kind === "insert") return true;
  if (config.mode === "final" && meta.kind === "delete") return true;
  return false;
};
const annotateBlockWithTrackedChange = (block, meta, config) => {
  if (!meta) return;
  if (!config || !config.enabled || config.mode === "off") return;
  block.attrs = {
    ...block.attrs ?? {},
    trackedChange: meta
  };
};
const resetRunFormatting = (run) => {
  delete run.bold;
  delete run.italic;
  delete run.color;
  delete run.underline;
  delete run.strike;
  delete run.highlight;
  delete run.link;
  delete run.letterSpacing;
};
const applyFormatChangeMarks = (run, config, hyperlinkConfig, applyMarksToRun2, themeColors, enableComments = true) => {
  const tracked = run.trackedChange;
  if (!tracked || tracked.kind !== "format") {
    return;
  }
  if (config.mode !== "original") {
    return;
  }
  const beforeMarks = tracked.before;
  if (!beforeMarks || beforeMarks.length === 0) {
    resetRunFormatting(run);
    return;
  }
  const isValidMarkArray = beforeMarks.every(
    (mark) => mark !== null && typeof mark === "object" && "type" in mark && typeof mark.type === "string"
  );
  if (!isValidMarkArray) {
    if (vue.process$1.env.NODE_ENV === "development") {
      console.warn("[PM-Adapter] Invalid before marks in tracked change, resetting formatting");
    }
    resetRunFormatting(run);
    return;
  }
  resetRunFormatting(run);
  try {
    applyMarksToRun2(run, beforeMarks, hyperlinkConfig, themeColors, void 0, enableComments);
  } catch (error) {
    if (vue.process$1.env.NODE_ENV === "development") {
      console.warn("[PM-Adapter] Error applying format change marks, resetting formatting:", error);
    }
    resetRunFormatting(run);
  }
};
const applyTrackedChangesModeToRuns = (runs, config, hyperlinkConfig, applyMarksToRun2, themeColors, enableComments = true) => {
  if (!config) {
    return runs;
  }
  const metadataDisabled = !config.enabled || config.mode === "off";
  const hideInsertions = config.enabled && config.mode === "original";
  const hideDeletions = config.enabled && config.mode === "final";
  if (!hideInsertions && !hideDeletions) {
    if (metadataDisabled) {
      runs.forEach((run) => stripTrackedChangeFromRun(run));
    } else {
      runs.forEach((run) => {
        if (isTextRun$4(run)) {
          applyFormatChangeMarks(run, config, hyperlinkConfig, applyMarksToRun2, themeColors, enableComments);
        }
      });
    }
    return runs;
  }
  const filtered = [];
  runs.forEach((run) => {
    if (!isTextRun$4(run)) {
      filtered.push(run);
      return;
    }
    const tracked = run.trackedChange;
    if (!tracked) {
      filtered.push(run);
      return;
    }
    if (hideInsertions && tracked.kind === "insert") {
      return;
    }
    if (hideDeletions && tracked.kind === "delete") {
      return;
    }
    filtered.push(run);
  });
  if (metadataDisabled) {
    filtered.forEach((run) => stripTrackedChangeFromRun(run));
  } else {
    filtered.forEach((run) => {
      if (isTextRun$4(run)) {
        applyFormatChangeMarks(
          run,
          config,
          hyperlinkConfig || DEFAULT_HYPERLINK_CONFIG$1,
          applyMarksToRun2,
          themeColors,
          enableComments
        );
      }
    });
    if ((config.mode === "original" || config.mode === "final") && config.enabled) {
      filtered.forEach((run) => {
        if (isTextRun$4(run) && run.trackedChange && (run.trackedChange.kind === "insert" || run.trackedChange.kind === "delete")) {
          delete run.trackedChange;
        }
      });
    }
  }
  return filtered;
};
const twipsToPx$2 = (value) => value / TWIPS_PER_INCH$3 * PX_PER_INCH$2;
const ptToPx = (pt) => {
  if (pt == null || !Number.isFinite(pt)) return void 0;
  return pt * PX_PER_PT;
};
const isFiniteNumber = (value) => typeof value === "number" && Number.isFinite(value);
const isPlainObject$3 = (value) => value !== null && typeof value === "object" && !Array.isArray(value);
const normalizePrefix = (value) => {
  if (!value) return "";
  return String(value);
};
const pickNumber = (value) => {
  if (isFiniteNumber(value)) return value;
  if (typeof value === "string") {
    const parsed = parseFloat(value);
    return Number.isFinite(parsed) ? parsed : void 0;
  }
  return void 0;
};
const normalizeColor$1 = (value) => {
  if (typeof value !== "string") return void 0;
  const trimmed = value.trim();
  if (!trimmed || trimmed === "auto" || trimmed === "none") return void 0;
  return trimmed.startsWith("#") ? trimmed : `#${trimmed}`;
};
function coerceNumber(value) {
  if (isFiniteNumber(value)) return Number(value);
  if (typeof value === "string" && value.trim() !== "") {
    const parsed = Number(value);
    return Number.isFinite(parsed) ? parsed : void 0;
  }
  return void 0;
}
function coercePositiveNumber(value, fallback) {
  if (!isFiniteNumber(fallback) || fallback <= 0) {
    throw new Error(`coercePositiveNumber: fallback must be a positive number, got ${fallback}`);
  }
  const numeric = coerceNumber(value);
  if (numeric != null && numeric > 0) {
    return numeric;
  }
  return fallback;
}
function coerceBoolean(value) {
  if (typeof value === "boolean") return value;
  if (typeof value === "number") {
    if (value === 1) return true;
    if (value === 0) return false;
    return void 0;
  }
  if (typeof value === "string") {
    const normalized = value.trim().toLowerCase();
    if (["true", "1", "yes", "on"].includes(normalized)) return true;
    if (["false", "0", "no", "off"].includes(normalized)) return false;
  }
  return void 0;
}
const toBoolean$2 = (value) => {
  if (typeof value === "boolean") return value;
  if (typeof value === "string") {
    const v = value.trim().toLowerCase();
    if (v === "true" || v === "1") return true;
    if (v === "false" || v === "0") return false;
  }
  if (typeof value === "number") {
    if (value === 1) return true;
    if (value === 0) return false;
  }
  return void 0;
};
function toBoxSpacing$1(spacing) {
  if (!spacing) {
    return void 0;
  }
  const result = {};
  ["top", "right", "bottom", "left"].forEach((side) => {
    const value = spacing[side];
    if (isFiniteNumber(value)) {
      result[side] = Number(value);
    }
  });
  return Object.keys(result).length > 0 ? result : void 0;
}
const buildPositionMap = (root2, options) => {
  const map3 = /* @__PURE__ */ new WeakMap();
  const atomNodeTypes = new Set(ATOMIC_INLINE_TYPES);
  if (options?.atomNodeTypes) {
    for (const nodeType of options.atomNodeTypes) {
      if (typeof nodeType === "string" && nodeType.length > 0) {
        atomNodeTypes.add(nodeType);
      }
    }
  }
  const visit = (node, pos) => {
    if (node.type === "text") {
      const size2 = node.text?.length ?? 0;
      const end22 = pos + size2;
      map3.set(node, { start: pos, end: end22 });
      return end22;
    }
    if (atomNodeTypes.has(node.type)) {
      const end22 = pos + 1;
      map3.set(node, { start: pos, end: end22 });
      return end22;
    }
    const open = node.type === "doc" ? 0 : 1;
    const close = node.type === "doc" ? 0 : 1;
    let nextPos = pos + open;
    const content = Array.isArray(node.content) ? node.content : [];
    map3.set(node, { start: pos, end: pos });
    content.forEach((child) => {
      nextPos = visit(child, nextPos);
    });
    const end2 = nextPos + close;
    map3.set(node, { start: pos, end: end2 });
    return end2;
  };
  visit(root2, 0);
  return map3;
};
const createBlockIdGenerator = (prefix2 = "") => {
  let counter = 0;
  return (kind) => `${prefix2}${counter++}-${kind}`;
};
function toDrawingContentSnapshot(value) {
  if (!value || typeof value !== "object") return void 0;
  const raw = value;
  const name = raw.name;
  if (typeof name !== "string") return void 0;
  const snapshot = { name };
  if (raw.attributes && typeof raw.attributes === "object" && !Array.isArray(raw.attributes)) {
    snapshot.attributes = { ...raw.attributes };
  }
  if (Array.isArray(raw.elements)) {
    const validElements = raw.elements.filter(
      (el) => el != null && typeof el === "object"
    );
    if (validElements.length > 0) {
      snapshot.elements = validElements;
    }
  }
  return snapshot;
}
function isShapeGroupTransform(value) {
  if (!value || typeof value !== "object") return false;
  const maybe = value;
  return isFiniteNumber(maybe.x) || isFiniteNumber(maybe.y) || isFiniteNumber(maybe.width) || isFiniteNumber(maybe.height) || isFiniteNumber(maybe.childWidth) || isFiniteNumber(maybe.childHeight) || isFiniteNumber(maybe.childX) || isFiniteNumber(maybe.childY);
}
function normalizeShapeSize(value) {
  if (!value || typeof value !== "object") return void 0;
  const maybe = value;
  const width = coerceNumber(maybe.width);
  const height = coerceNumber(maybe.height);
  if (width == null && height == null) {
    return void 0;
  }
  const result = {};
  if (width != null) result.width = width;
  if (height != null) result.height = height;
  return result;
}
const LINE_END_SIZES = /* @__PURE__ */ new Set(["sm", "med", "lg"]);
const normalizeLineEnd = (value) => {
  if (!value || typeof value !== "object") return void 0;
  const maybe = value;
  const type = typeof maybe.type === "string" ? maybe.type : void 0;
  if (!type || type === "none") return void 0;
  const width = typeof maybe.width === "string" && LINE_END_SIZES.has(maybe.width) ? maybe.width : void 0;
  const length2 = typeof maybe.length === "string" && LINE_END_SIZES.has(maybe.length) ? maybe.length : void 0;
  return { type, width, length: length2 };
};
function normalizeLineEnds(value) {
  if (!value || typeof value !== "object") return void 0;
  const maybe = value;
  const head = normalizeLineEnd(maybe.head);
  const tail = normalizeLineEnd(maybe.tail);
  if (!head && !tail) return void 0;
  return { head, tail };
}
function normalizeEffectExtent(value) {
  if (!value || typeof value !== "object") return void 0;
  const maybe = value;
  const left2 = coerceNumber(maybe.left);
  const top2 = coerceNumber(maybe.top);
  const right2 = coerceNumber(maybe.right);
  const bottom2 = coerceNumber(maybe.bottom);
  if (left2 == null && top2 == null && right2 == null && bottom2 == null) {
    return void 0;
  }
  const clamp2 = (val) => val != null && val > 0 ? val : 0;
  return {
    left: clamp2(left2),
    top: clamp2(top2),
    right: clamp2(right2),
    bottom: clamp2(bottom2)
  };
}
function normalizeShapeGroupChildren(value) {
  if (!Array.isArray(value)) return [];
  return value.filter((child) => {
    if (!child || typeof child !== "object") return false;
    return typeof child.shapeType === "string";
  });
}
function normalizeMediaKey(value) {
  if (!value) return void 0;
  return value.replace(/\\/g, "/").replace(/^(\.\/|\/)+/, "");
}
function inferExtensionFromPath(value) {
  if (!value) return void 0;
  const fileName = value.split("/").pop()?.split("\\").pop();
  if (!fileName || fileName.startsWith(".")) return void 0;
  const parts = fileName.split(".");
  if (parts.length < 2) return void 0;
  const ext = parts.at(-1);
  if (!ext || ext.length === 0) return void 0;
  return ext.toLowerCase();
}
function hydrateImageBlocks(blocks, mediaFiles) {
  if (!mediaFiles || Object.keys(mediaFiles).length === 0) {
    return blocks;
  }
  const normalizedMedia = /* @__PURE__ */ new Map();
  Object.entries(mediaFiles).forEach(([key2, value]) => {
    const normalized = normalizeMediaKey(key2);
    if (normalized) {
      normalizedMedia.set(normalized, value);
    }
  });
  if (normalizedMedia.size === 0) {
    return blocks;
  }
  const resolveImageSrc = (src, relId, attrSrc, extension) => {
    if (!src || src.startsWith("data:")) {
      return void 0;
    }
    const candidates = /* @__PURE__ */ new Set();
    candidates.add(src);
    if (attrSrc) candidates.add(attrSrc);
    if (relId) {
      const inferredExt = extension ?? inferExtensionFromPath(src) ?? "jpeg";
      candidates.add(`word/media/${relId}.${inferredExt}`);
      candidates.add(`media/${relId}.${inferredExt}`);
    }
    for (const candidate of candidates) {
      const normalized = normalizeMediaKey(candidate);
      if (!normalized) continue;
      const base64 = normalizedMedia.get(normalized);
      if (!base64) continue;
      const finalExt = extension ?? inferExtensionFromPath(normalized) ?? "jpeg";
      return base64.startsWith("data:") ? base64 : `data:image/${finalExt};base64,${base64}`;
    }
    return void 0;
  };
  const hydrateRuns = (runs) => {
    let hasChanges = false;
    const hydratedRuns = runs.map((run) => {
      if (run.kind !== "image") {
        return run;
      }
      const imageRun = run;
      if (!imageRun.src || imageRun.src.startsWith("data:")) {
        return run;
      }
      const resolvedSrc = resolveImageSrc(imageRun.src);
      if (resolvedSrc) {
        hasChanges = true;
        return { ...imageRun, src: resolvedSrc };
      }
      return run;
    });
    return hasChanges ? hydratedRuns : runs;
  };
  return blocks.map((block) => {
    const hydrateBlock = (blk) => {
      if (blk.kind === "image") {
        if (!blk.src || blk.src.startsWith("data:")) {
          return blk;
        }
        const attrs = blk.attrs ?? {};
        const relId = typeof attrs.rId === "string" ? attrs.rId : void 0;
        const attrSrc = typeof attrs.src === "string" ? attrs.src : void 0;
        const extension = typeof attrs.extension === "string" ? attrs.extension.toLowerCase() : void 0;
        const resolvedSrc = resolveImageSrc(blk.src, relId, attrSrc, extension);
        if (resolvedSrc) {
          return { ...blk, src: resolvedSrc };
        }
        return blk;
      }
      if (blk.kind === "paragraph") {
        const paragraphBlock = blk;
        if (!paragraphBlock.runs || paragraphBlock.runs.length === 0) {
          return blk;
        }
        const hydratedRuns = hydrateRuns(paragraphBlock.runs);
        if (hydratedRuns !== paragraphBlock.runs) {
          return { ...paragraphBlock, runs: hydratedRuns };
        }
        return blk;
      }
      if (blk.kind === "table") {
        let rowsChanged = false;
        const newRows = blk.rows.map((row) => {
          let cellsChanged = false;
          const newCells = row.cells.map((cell) => {
            let cellChanged = false;
            const hydratedBlocks = (cell.blocks ?? (cell.paragraph ? [cell.paragraph] : [])).map(
              (cb) => hydrateBlock(cb)
            );
            if (cell.blocks && hydratedBlocks !== cell.blocks) {
              cellChanged = true;
            }
            let hydratedParagraph = cell.paragraph;
            if (!cell.blocks && cell.paragraph && cell.paragraph.kind === "paragraph") {
              const hydratedPara = hydrateBlock(cell.paragraph);
              if (hydratedPara !== cell.paragraph) {
                hydratedParagraph = hydratedPara;
                cellChanged = true;
              }
            }
            if (cellChanged) {
              return {
                ...cell,
                // Cast to expected type - hydrateBlock preserves block kinds, just hydrates image sources
                blocks: hydratedBlocks.length > 0 ? hydratedBlocks : cell.blocks,
                paragraph: hydratedParagraph
              };
            }
            return cell;
          });
          if (newCells.some((c2, idx) => c2 !== row.cells[idx])) {
            cellsChanged = true;
          }
          if (cellsChanged) {
            rowsChanged = true;
            return { ...row, cells: newCells };
          }
          return row;
        });
        if (rowsChanged) {
          return { ...blk, rows: newRows };
        }
        return blk;
      }
      if (blk.kind === "drawing") {
        const drawingBlock = blk;
        if (drawingBlock.drawingKind !== "shapeGroup") {
          return blk;
        }
        const shapeGroupBlock = drawingBlock;
        if (!shapeGroupBlock.shapes || shapeGroupBlock.shapes.length === 0) {
          return blk;
        }
        let shapesChanged = false;
        const hydratedShapes = shapeGroupBlock.shapes.map((shape) => {
          if (shape.shapeType !== "image") {
            return shape;
          }
          const imageChild = shape;
          const src = imageChild.attrs?.src;
          if (!src || src.startsWith("data:")) {
            return shape;
          }
          const resolvedSrc = resolveImageSrc(src);
          if (resolvedSrc) {
            shapesChanged = true;
            return {
              ...imageChild,
              attrs: { ...imageChild.attrs, src: resolvedSrc }
            };
          }
          return shape;
        });
        if (shapesChanged) {
          return { ...shapeGroupBlock, shapes: hydratedShapes };
        }
        return blk;
      }
      return blk;
    };
    return hydrateBlock(block);
  });
}
function isGradientFill(value) {
  if (!isPlainObject$3(value)) return false;
  if (value.type !== "gradient") return false;
  const gradientType = value.gradientType;
  if (gradientType !== "linear" && gradientType !== "radial") return false;
  if (gradientType === "linear") {
    if (typeof value.angle !== "number" || !Number.isFinite(value.angle)) {
      return false;
    }
  }
  if (!Array.isArray(value.stops) || value.stops.length === 0) return false;
  return value.stops.every((stop) => {
    if (!isPlainObject$3(stop)) return false;
    return typeof stop.position === "number" && Number.isFinite(stop.position) && typeof stop.color === "string" && (stop.alpha === void 0 || typeof stop.alpha === "number" && Number.isFinite(stop.alpha));
  });
}
function isSolidFillWithAlpha(value) {
  return isPlainObject$3(value) && value.type === "solidWithAlpha" && typeof value.color === "string" && typeof value.alpha === "number";
}
function normalizeFillColor(value) {
  if (value === null) return null;
  if (typeof value === "string") return value;
  if (isGradientFill(value)) return value;
  if (isSolidFillWithAlpha(value)) return value;
  return void 0;
}
function normalizeStrokeColor(value) {
  if (value === null) return null;
  if (typeof value === "string") return value;
  return void 0;
}
function normalizeTextContent(value) {
  if (!isPlainObject$3(value)) return void 0;
  if (!Array.isArray(value.parts)) return void 0;
  if (value.parts.length === 0) return void 0;
  const validParts = value.parts.filter((p2) => isPlainObject$3(p2) && typeof p2.text === "string");
  if (validParts.length === 0) return void 0;
  const result = {
    parts: validParts
  };
  if (["left", "center", "right"].includes(value.horizontalAlign)) {
    result.horizontalAlign = value.horizontalAlign;
  }
  return result;
}
function normalizeTextVerticalAlign(value) {
  if (typeof value !== "string") return void 0;
  if (value === "top" || value === "center" || value === "bottom") {
    return value;
  }
  return void 0;
}
function normalizeTextInsets(value) {
  if (!isPlainObject$3(value)) return void 0;
  const top2 = pickNumber(value.top);
  const right2 = pickNumber(value.right);
  const bottom2 = pickNumber(value.bottom);
  const left2 = pickNumber(value.left);
  if (top2 == null || right2 == null || bottom2 == null || left2 == null) {
    return void 0;
  }
  return { top: top2, right: right2, bottom: bottom2, left: left2 };
}
const OOXML_Z_INDEX_BASE = 251658240;
function normalizeZIndex(originalAttributes) {
  if (!isPlainObject$3(originalAttributes)) return void 0;
  const relativeHeight = originalAttributes.relativeHeight;
  if (typeof relativeHeight !== "number") return void 0;
  return Math.max(0, relativeHeight - OOXML_Z_INDEX_BASE);
}
const VALID_LINK_TARGETS = /* @__PURE__ */ new Set(["_blank", "_self", "_parent", "_top"]);
const toTrimmedString = (value) => {
  if (typeof value !== "string") return void 0;
  const trimmed = value.trim();
  return trimmed ? trimmed : void 0;
};
const toOptionalBoolean = (value) => {
  if (typeof value === "boolean") return value;
  if (typeof value === "string") {
    const normalized = value.trim().toLowerCase();
    if (!normalized) return void 0;
    if (normalized === "true" || normalized === "1" || normalized === "yes" || normalized === "on") return true;
    if (normalized === "false" || normalized === "0" || normalized === "no" || normalized === "off") return false;
  }
  return void 0;
};
const migrateLegacyLink = (link) => {
  if (link.version === 2) {
    return link;
  }
  return {
    version: 2,
    href: link.href,
    title: link.title
    // All other fields are optional and default to undefined
  };
};
const buildFlowRunLink = (attrs) => {
  const sanitizedHref = typeof attrs.href === "string" && attrs.href.trim() ? sanitizeHref(attrs.href) : null;
  const anchor = toTrimmedString(attrs.anchor);
  const legacyName = toTrimmedString(attrs.name);
  const docLocation = toTrimmedString(attrs.docLocation);
  const rId = toTrimmedString(attrs.rId);
  if (!sanitizedHref && !anchor && !legacyName && !docLocation && !rId) {
    return null;
  }
  const link = { version: 2 };
  if (sanitizedHref) {
    link.href = sanitizedHref.href;
  }
  const title = toTrimmedString(attrs.title);
  if (title) {
    link.title = title;
  }
  const tooltip = toTrimmedString(attrs.tooltip);
  if (tooltip) {
    link.tooltip = tooltip;
  }
  const target = toTrimmedString(attrs.target);
  if (target && VALID_LINK_TARGETS.has(target)) {
    link.target = target;
  }
  const rel = toTrimmedString(attrs.rel);
  if (rel) {
    link.rel = rel;
  }
  if (anchor) {
    link.anchor = anchor;
  }
  if (legacyName) {
    link.name = legacyName;
  }
  if (docLocation) {
    link.docLocation = docLocation;
  }
  if (rId) {
    link.rId = rId;
  }
  const history2 = toOptionalBoolean(attrs.history);
  if (history2 != null) {
    link.history = history2;
  }
  return link;
};
const TRACK_INSERT_MARK = "trackInsert";
const TRACK_DELETE_MARK = "trackDelete";
const TRACK_FORMAT_MARK = "trackFormat";
const TRACK_CHANGE_KIND_MAP = {
  [TRACK_INSERT_MARK]: "insert",
  [TRACK_DELETE_MARK]: "delete",
  [TRACK_FORMAT_MARK]: "format"
};
const TRACK_CHANGE_PRIORITY = {
  insert: 3,
  delete: 3,
  format: 1
};
const MAX_RUN_MARK_JSON_LENGTH = 1e4;
const MAX_RUN_MARK_ARRAY_LENGTH = 100;
const MAX_RUN_MARK_DEPTH = 5;
const validateDepth = (obj, currentDepth = 0) => {
  if (currentDepth > MAX_RUN_MARK_DEPTH) {
    return false;
  }
  if (obj && typeof obj === "object") {
    const values = Array.isArray(obj) ? obj : Object.values(obj);
    for (const value of values) {
      if (!validateDepth(value, currentDepth + 1)) {
        return false;
      }
    }
  }
  return true;
};
const parseThemePercentage = (value) => {
  if (typeof value !== "string") return void 0;
  const trimmed = value.trim();
  if (!trimmed) return void 0;
  const parsed = Number.parseInt(trimmed, 16);
  if (Number.isNaN(parsed)) return void 0;
  return Math.max(0, Math.min(parsed / 255, 1));
};
const expandHex = (hex2) => {
  const normalized = hex2.replace("#", "");
  if (normalized.length === 3) {
    return normalized.split("").map((char) => char + char).join("");
  }
  return normalized;
};
const hexToRgb = (hex2) => {
  const cleaned = expandHex(hex2);
  if (cleaned.length !== 6) return null;
  const r2 = Number.parseInt(cleaned.slice(0, 2), 16);
  const g2 = Number.parseInt(cleaned.slice(2, 4), 16);
  const b2 = Number.parseInt(cleaned.slice(4, 6), 16);
  if ([r2, g2, b2].some((channel) => Number.isNaN(channel))) return null;
  return { r: r2, g: g2, b: b2 };
};
const rgbToHex = (value) => {
  const toHex2 = (channel) => {
    const normalized = Math.max(0, Math.min(255, channel));
    return normalized.toString(16).padStart(2, "0").toUpperCase();
  };
  return `#${toHex2(value.r)}${toHex2(value.g)}${toHex2(value.b)}`;
};
const applyThemeTint = (baseHex, ratio) => {
  const rgb = hexToRgb(baseHex);
  if (!rgb) return baseHex;
  const tinted = {
    r: Math.round(rgb.r + (255 - rgb.r) * ratio),
    g: Math.round(rgb.g + (255 - rgb.g) * ratio),
    b: Math.round(rgb.b + (255 - rgb.b) * ratio)
  };
  return rgbToHex(tinted);
};
const applyThemeShade = (baseHex, ratio) => {
  const rgb = hexToRgb(baseHex);
  if (!rgb) return baseHex;
  const shaded = {
    r: Math.round(rgb.r * ratio),
    g: Math.round(rgb.g * ratio),
    b: Math.round(rgb.b * ratio)
  };
  return rgbToHex(shaded);
};
const getLuminance = (hexColor) => {
  const rgb = hexToRgb(hexColor);
  if (!rgb) return 1;
  const toLinear = (channel) => {
    const c2 = channel / 255;
    return c2 <= 0.03928 ? c2 / 12.92 : Math.pow((c2 + 0.055) / 1.055, 2.4);
  };
  const R2 = toLinear(rgb.r);
  const G2 = toLinear(rgb.g);
  const B2 = toLinear(rgb.b);
  return 0.2126 * R2 + 0.7152 * G2 + 0.0722 * B2;
};
const WCAG_AA_LUMINANCE_THRESHOLD = 0.18;
const resolveAutoColor = (backgroundColor) => {
  const luminance = getLuminance(backgroundColor);
  return luminance < WCAG_AA_LUMINANCE_THRESHOLD ? "#FFFFFF" : "#000000";
};
const resolveThemeColor = (attrs, themeColors) => {
  if (!attrs || !themeColors) return void 0;
  const rawKey = attrs.themeColor;
  if (typeof rawKey !== "string") return void 0;
  const key2 = rawKey.trim();
  if (!key2) return void 0;
  const base2 = themeColors[key2];
  if (!base2) return void 0;
  const tint = parseThemePercentage(attrs.themeTint);
  const shade = parseThemePercentage(attrs.themeShade);
  let computed = base2;
  if (tint != null) {
    computed = applyThemeTint(computed, tint);
  }
  if (shade != null) {
    computed = applyThemeShade(computed, shade);
  }
  return computed;
};
const resolveColorFromAttributes = (attrs, themeColors) => {
  if (!attrs) return void 0;
  if (typeof attrs.color === "string") {
    const normalized = normalizeColor$1(attrs.color);
    if (normalized) {
      return normalized;
    }
  }
  const theme = resolveThemeColor(attrs, themeColors);
  if (theme) {
    return normalizeColor$1(theme);
  }
  return void 0;
};
const MAX_DATA_ATTR_COUNT = 50;
const MAX_DATA_ATTR_VALUE_LENGTH = 1e3;
const MAX_DATA_ATTR_NAME_LENGTH = 100;
const pushCommentAnnotation = (run, attrs) => {
  const commentId = typeof attrs?.commentId === "string" ? attrs.commentId : void 0;
  const importedId = typeof attrs?.importedId === "string" ? attrs.importedId : void 0;
  const internal = attrs?.internal === true;
  const trackedChange = attrs?.trackedChange === true;
  if (!commentId && !importedId) return;
  const annotations = run.comments ? [...run.comments] : [];
  const key2 = `${commentId ?? ""}::${importedId ?? ""}`;
  const exists2 = annotations.some((c2) => `${c2.commentId ?? ""}::${c2.importedId ?? ""}` === key2);
  if (!exists2) {
    annotations.push({
      commentId: commentId ?? importedId,
      importedId,
      internal,
      trackedChange
    });
  }
  run.comments = annotations;
};
const extractDataAttributes = (attrs) => {
  if (!attrs) return void 0;
  const result = {};
  let attrCount = 0;
  for (const [key2, value] of Object.entries(attrs)) {
    if (typeof key2 !== "string" || !key2.toLowerCase().startsWith("data-")) {
      continue;
    }
    if (attrCount >= MAX_DATA_ATTR_COUNT) {
      if (vue.process$1.env.NODE_ENV === "development") {
        console.warn(`[PM-Adapter] Rejecting data attributes exceeding ${MAX_DATA_ATTR_COUNT} limit`);
      }
      break;
    }
    if (key2.length > MAX_DATA_ATTR_NAME_LENGTH) {
      if (vue.process$1.env.NODE_ENV === "development") {
        console.warn(
          `[PM-Adapter] Rejecting data attribute name exceeding ${MAX_DATA_ATTR_NAME_LENGTH} chars: ${key2.substring(0, 50)}...`
        );
      }
      continue;
    }
    if (value == null) {
      continue;
    }
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      const stringValue = String(value);
      if (stringValue.length > MAX_DATA_ATTR_VALUE_LENGTH) {
        if (vue.process$1.env.NODE_ENV === "development") {
          console.warn(
            `[PM-Adapter] Rejecting data attribute value exceeding ${MAX_DATA_ATTR_VALUE_LENGTH} chars for key: ${key2}`
          );
        }
        continue;
      }
      result[key2] = stringValue;
      attrCount++;
    }
  }
  return Object.keys(result).length > 0 ? result : void 0;
};
const normalizeRunMarkList = (value) => {
  if (!value) return void 0;
  let entries = value;
  if (typeof value === "string") {
    if (value.length > MAX_RUN_MARK_JSON_LENGTH) {
      if (vue.process$1.env.NODE_ENV === "development") {
        console.warn(`[PM-Adapter] Rejecting run mark JSON payload exceeding ${MAX_RUN_MARK_JSON_LENGTH} chars`);
      }
      return void 0;
    }
    try {
      entries = JSON.parse(value);
    } catch (error) {
      if (vue.process$1.env.NODE_ENV === "development") {
        console.warn("[PM-Adapter] Failed to parse run mark JSON:", error);
      }
      return void 0;
    }
  }
  if (!Array.isArray(entries)) {
    return void 0;
  }
  if (entries.length > MAX_RUN_MARK_ARRAY_LENGTH) {
    if (vue.process$1.env.NODE_ENV === "development") {
      console.warn(`[PM-Adapter] Rejecting run mark array exceeding ${MAX_RUN_MARK_ARRAY_LENGTH} entries`);
    }
    return void 0;
  }
  if (!validateDepth(entries)) {
    if (vue.process$1.env.NODE_ENV === "development") {
      console.warn(`[PM-Adapter] Rejecting run mark array exceeding depth ${MAX_RUN_MARK_DEPTH}`);
    }
    return void 0;
  }
  const normalized = entries.map((entry) => {
    if (!entry || typeof entry !== "object") return null;
    const record = entry;
    const type = typeof record.type === "string" ? record.type : void 0;
    if (!type) return null;
    const attrs = record.attrs && typeof record.attrs === "object" ? record.attrs : void 0;
    return { type, attrs };
  }).filter(Boolean);
  return normalized.length ? normalized : void 0;
};
const pickTrackedChangeKind = (markType) => {
  return TRACK_CHANGE_KIND_MAP[markType];
};
const deriveTrackedChangeId = (kind, attrs) => {
  if (attrs && typeof attrs.id === "string" && attrs.id.trim()) {
    return attrs.id;
  }
  const authorEmail = attrs && typeof attrs.authorEmail === "string" ? attrs.authorEmail : "unknown";
  const date = attrs && typeof attrs.date === "string" ? attrs.date : "unknown";
  const unique2 = `${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
  return `${kind}-${authorEmail}-${date}-${unique2}`;
};
const buildTrackedChangeMetaFromMark = (mark) => {
  const kind = pickTrackedChangeKind(mark.type);
  if (!kind) return void 0;
  const attrs = mark.attrs ?? {};
  const meta = {
    kind,
    id: deriveTrackedChangeId(kind, attrs)
  };
  if (typeof attrs.author === "string" && attrs.author) {
    meta.author = attrs.author;
  }
  if (typeof attrs.authorEmail === "string" && attrs.authorEmail) {
    meta.authorEmail = attrs.authorEmail;
  }
  if (typeof attrs.authorImage === "string" && attrs.authorImage) {
    meta.authorImage = attrs.authorImage;
  }
  if (typeof attrs.date === "string" && attrs.date) {
    meta.date = attrs.date;
  }
  if (kind === "format") {
    meta.before = normalizeRunMarkList(attrs.before);
    meta.after = normalizeRunMarkList(attrs.after);
  }
  return meta;
};
const selectTrackedChangeMeta = (existing, next) => {
  if (!existing) return next;
  const existingPriority = TRACK_CHANGE_PRIORITY[existing.kind] ?? 0;
  const nextPriority = TRACK_CHANGE_PRIORITY[next.kind] ?? 0;
  if (nextPriority > existingPriority) {
    return next;
  }
  return existing;
};
const trackedChangesCompatible = (a, b2) => {
  const aMeta = a.trackedChange;
  const bMeta = b2.trackedChange;
  if (!aMeta && !bMeta) return true;
  if (!aMeta || !bMeta) return false;
  return aMeta.kind === bMeta.kind && aMeta.id === bMeta.id;
};
const collectTrackedChangeFromMarks = (marks) => {
  if (!marks || !marks.length) return void 0;
  return marks.reduce((current, mark) => {
    const meta = buildTrackedChangeMetaFromMark(mark);
    if (!meta) return current;
    return selectTrackedChangeMeta(current, meta);
  }, void 0);
};
const normalizeUnderlineStyle = (value) => {
  if (value === "none") {
    return void 0;
  }
  if (value === void 0 || value === null) {
    return "single";
  }
  if (typeof value === "boolean") {
    return value ? "single" : void 0;
  }
  if (typeof value === "number") {
    return value === 0 ? void 0 : "single";
  }
  if (typeof value === "string") {
    const normalized = value.trim().toLowerCase();
    if (!normalized) {
      return "single";
    }
    if (normalized === "none" || normalized === "0" || normalized === "false" || normalized === "off") {
      return void 0;
    }
    if (normalized === "double" || normalized === "dotted" || normalized === "dashed" || normalized === "wavy") {
      return normalized;
    }
    return "single";
  }
  return "single";
};
const normalizeBooleanMarkValue = (value) => {
  if (value === void 0 || value === null) {
    return void 0;
  }
  if (typeof value === "boolean") {
    return value;
  }
  if (typeof value === "number") {
    return value !== 0;
  }
  if (typeof value === "string") {
    const normalized = value.trim().toLowerCase();
    if (normalized === "0" || normalized === "false" || normalized === "off" || normalized === "none") {
      return false;
    }
    if (normalized === "1" || normalized === "true" || normalized === "on") {
      return true;
    }
  }
  return Boolean(value);
};
const MAX_FONT_FAMILY_LENGTH = 200;
const sanitizeFontFamily = (fontFamily2) => {
  if (!fontFamily2 || typeof fontFamily2 !== "string") {
    return void 0;
  }
  let sanitized = fontFamily2.trim();
  if (sanitized.length > MAX_FONT_FAMILY_LENGTH) {
    if (vue.process$1.env.NODE_ENV === "development") {
      console.warn(`[PM-Adapter] Font family name exceeds ${MAX_FONT_FAMILY_LENGTH} character limit`);
    }
    return void 0;
  }
  const lowerCased = sanitized.toLowerCase();
  const dangerousSchemes = ["javascript:", "data:", "vbscript:"];
  if (dangerousSchemes.some((scheme) => lowerCased.includes(scheme))) {
    if (vue.process$1.env.NODE_ENV === "development") {
      console.warn("[PM-Adapter] Rejected font family containing dangerous URI scheme");
    }
    return void 0;
  }
  sanitized = sanitized.replace(/["']/g, "");
  const cssInjectionPattern = /[;{}()@<>]/;
  if (cssInjectionPattern.test(sanitized)) {
    if (vue.process$1.env.NODE_ENV === "development") {
      console.warn("[PM-Adapter] Rejected font family containing CSS injection characters");
    }
    return void 0;
  }
  sanitized = sanitized.replace(/[\r\n\t\f\v]/g, " ");
  sanitized = sanitized.replace(/\s+/g, " ").trim();
  if (!sanitized) {
    return void 0;
  }
  return sanitized;
};
const normalizeFontSizePx = (value) => {
  if (isFiniteNumber(value)) return value;
  if (typeof value !== "string") return void 0;
  const trimmed = value.trim();
  if (!trimmed) return void 0;
  const numeric = Number.parseFloat(trimmed);
  if (!Number.isFinite(numeric)) return void 0;
  const unit = trimmed.match(/[a-zA-Z%]+$/)?.[0]?.toLowerCase();
  if (unit === "pt") {
    return ptToPx(numeric);
  }
  return numeric;
};
const applyTextStyleMark = (run, attrs, themeColors) => {
  const resolvedColor = resolveColorFromAttributes(attrs, themeColors);
  if (resolvedColor) {
    run.color = resolvedColor;
  }
  if (typeof attrs.fontFamily === "string" && attrs.fontFamily.trim()) {
    const sanitized = sanitizeFontFamily(attrs.fontFamily);
    if (sanitized) {
      run.fontFamily = sanitized;
    }
  }
  const fontSizePx = normalizeFontSizePx(attrs.fontSize);
  if (fontSizePx !== void 0 && fontSizePx >= 1 && fontSizePx <= 1e3) {
    run.fontSize = fontSizePx;
  } else if (attrs.fontSize !== void 0) ;
  if (isFiniteNumber(attrs.letterSpacing)) {
    const spacing = Number(attrs.letterSpacing);
    if (spacing >= -100 && spacing <= 100) {
      run.letterSpacing = spacing;
    }
  }
  if (typeof attrs.textTransform === "string") {
    const transform = attrs.textTransform;
    if (transform === "uppercase" || transform === "lowercase" || transform === "capitalize" || transform === "none") {
      run.textTransform = transform;
    }
  }
};
const DEFAULT_HYPERLINK_CONFIG = {
  enableRichHyperlinks: false
};
const applyMarksToRun = (run, marks, hyperlinkConfig = DEFAULT_HYPERLINK_CONFIG, themeColors, backgroundColor, enableComments = true) => {
  if (!enableComments && "comments" in run && run.comments) {
    delete run.comments;
  }
  const isTabRun2 = run.kind === "tab";
  let markSetColor = false;
  marks.forEach((mark) => {
    const forwardedDataAttrs = extractDataAttributes(mark.attrs);
    try {
      switch (mark.type) {
        case TRACK_INSERT_MARK:
        case TRACK_DELETE_MARK:
        case TRACK_FORMAT_MARK: {
          if (!isTabRun2) {
            const tracked = buildTrackedChangeMetaFromMark(mark);
            if (tracked) {
              run.trackedChange = selectTrackedChangeMeta(run.trackedChange, tracked);
            }
          }
          break;
        }
        case "bold": {
          const normalized = normalizeBooleanMarkValue(mark.attrs?.value);
          if (normalized === false) {
            delete run.bold;
          } else {
            run.bold = true;
          }
          break;
        }
        case "italic": {
          const normalized = normalizeBooleanMarkValue(mark.attrs?.value);
          if (normalized === false) {
            delete run.italic;
          } else {
            run.italic = true;
          }
          break;
        }
        case "textStyle":
          if (!isTabRun2) {
            const colorBefore = run.color;
            applyTextStyleMark(run, mark.attrs ?? {}, themeColors);
            if (run.color !== colorBefore && run.color !== void 0) {
              markSetColor = true;
            }
          }
          break;
        case "commentMark":
        case "comment": {
          if (!isTabRun2 && enableComments) {
            pushCommentAnnotation(run, mark.attrs ?? {});
          }
          break;
        }
        case "underline": {
          const underlineValue = mark.attrs?.underlineType ?? mark.attrs?.value ?? mark.attrs?.underline ?? mark.attrs?.style;
          const style2 = normalizeUnderlineStyle(underlineValue);
          if (style2) {
            const underlineColor = resolveColorFromAttributes(mark.attrs ?? {}, themeColors);
            run.underline = {
              style: style2,
              color: underlineColor ?? run.underline?.color
            };
          } else if (underlineValue !== void 0 && underlineValue !== null) {
            delete run.underline;
          }
          break;
        }
        case "strike": {
          const normalized = normalizeBooleanMarkValue(mark.attrs?.value);
          if (normalized === false) {
            delete run.strike;
          } else {
            run.strike = true;
          }
          break;
        }
        case "highlight":
          run.highlight = resolveColorFromAttributes(mark.attrs ?? {}, themeColors);
          break;
        case "link": {
          if (!isTabRun2) {
            const attrs = mark.attrs ?? {};
            if (hyperlinkConfig.enableRichHyperlinks) {
              try {
                const link = buildFlowRunLink(attrs);
                if (link) {
                  run.link = link;
                }
              } catch (error) {
                if (vue.process$1.env.NODE_ENV === "development") {
                  console.warn("[PM-Adapter] Failed to build rich hyperlink:", error);
                }
              }
            } else if (typeof attrs.href === "string" && attrs.href.trim()) {
              try {
                const sanitized = sanitizeHref(attrs.href);
                if (sanitized && sanitized.href) {
                  const legacyLink = {
                    href: sanitized.href,
                    title: typeof attrs.title === "string" ? attrs.title : void 0
                  };
                  run.link = migrateLegacyLink(legacyLink);
                }
              } catch (error) {
                if (vue.process$1.env.NODE_ENV === "development") {
                  console.warn("[PM-Adapter] Failed to sanitize link href:", error);
                }
              }
            }
          }
          break;
        }
        default:
          break;
      }
    } catch (error) {
      if (vue.process$1.env.NODE_ENV === "development") {
        console.warn(`[PM-Adapter] Failed to apply mark ${mark.type}:`, error);
      }
    }
    if (forwardedDataAttrs && !isTabRun2) {
      run.dataAttrs = { ...run.dataAttrs ?? {}, ...forwardedDataAttrs };
    }
  });
  if (!isTabRun2 && !markSetColor && backgroundColor) {
    const normalizedExisting = normalizeColor$1(run.color);
    const normalizedUpper = normalizedExisting?.toUpperCase();
    const isDefaultBlack = normalizedUpper === "#000000" || normalizedUpper === "#000";
    const isAutoColorValue = typeof run.color === "string" && ["auto", "none"].includes(run.color.trim().replace(/^#/, "").toLowerCase());
    if (!normalizedExisting || isAutoColorValue || isDefaultBlack) {
      run.color = resolveAutoColor(backgroundColor);
    }
  }
};
function textNodeToRun(textNode, positions, defaultFont, defaultSize, inheritedMarks = [], sdtMetadata, hyperlinkConfig = DEFAULT_HYPERLINK_CONFIG$1, themeColors) {
  const run = {
    text: textNode.text || "",
    fontFamily: defaultFont,
    fontSize: defaultSize
  };
  const pos = positions.get(textNode);
  if (pos) {
    run.pmStart = pos.start;
    run.pmEnd = pos.end;
  }
  applyMarksToRun(run, [...textNode.marks ?? [], ...inheritedMarks ?? []], hyperlinkConfig, themeColors);
  if (sdtMetadata) {
    run.sdt = sdtMetadata;
  }
  return run;
}
function tabNodeToRun(node, positions, tabIndex, paragraphAttrs, inheritedMarks = []) {
  const pos = positions.get(node);
  if (!pos) return null;
  const tabStops = paragraphAttrs.tabs;
  const indent = paragraphAttrs.indent;
  const run = {
    kind: "tab",
    text: "	",
    pmStart: pos.start,
    pmEnd: pos.end,
    tabIndex,
    tabStops,
    indent,
    leader: node.attrs?.leader ?? null
  };
  const marks = [...node.marks ?? [], ...inheritedMarks ?? []];
  if (marks.length > 0) {
    applyMarksToRun(run, marks);
  }
  return run;
}
function tokenNodeToRun(node, positions, defaultFont, defaultSize, inheritedMarks = [], token, hyperlinkConfig = DEFAULT_HYPERLINK_CONFIG$1, themeColors) {
  const run = {
    text: "0",
    token,
    fontFamily: defaultFont,
    fontSize: defaultSize
  };
  const pos = positions.get(node);
  if (pos) {
    run.pmStart = pos.start;
    run.pmEnd = pos.end;
  }
  const nodeMarks = node.marks ?? [];
  const marksAsAttrs = Array.isArray(node.attrs?.marksAsAttrs) ? node.attrs.marksAsAttrs : [];
  const effectiveMarks = nodeMarks.length > 0 ? nodeMarks : marksAsAttrs;
  const marks = [...effectiveMarks, ...inheritedMarks ?? []];
  applyMarksToRun(run, marks, hyperlinkConfig, themeColors);
  if (marksAsAttrs.length > 0) {
    run._explicitFont = true;
  }
  return run;
}
const EIGHTHS_PER_POINT = 8;
const MIN_BORDER_SIZE_PX = 0.5;
const MAX_BORDER_SIZE_PX = 100;
const borderSizeToPx = (size2) => {
  if (!isFiniteNumber(size2)) return void 0;
  if (size2 <= 0) return 0;
  const points = size2 / EIGHTHS_PER_POINT;
  const pixelValue = points * PX_PER_PT;
  return Math.min(MAX_BORDER_SIZE_PX, Math.max(MIN_BORDER_SIZE_PX, pixelValue));
};
const normalizeColorWithDefault = (color) => {
  if (!color || color === "auto") return "#000000";
  return color.startsWith("#") ? color : `#${color}`;
};
function convertBorderSpec(ooxmlBorder) {
  if (!ooxmlBorder || typeof ooxmlBorder !== "object" || ooxmlBorder === null) {
    return void 0;
  }
  const border = ooxmlBorder;
  const hasValidStructure = Object.keys(border).length > 0;
  if (!hasValidStructure) return void 0;
  const { val, size: size2, color } = border;
  if (size2 !== void 0 && typeof size2 !== "number") return void 0;
  if (color !== void 0 && typeof color !== "string") return void 0;
  if (val !== void 0 && typeof val !== "string") return void 0;
  const sizeNumber = typeof size2 === "number" ? size2 : void 0;
  const colorString = typeof color === "string" ? color : void 0;
  if (val === "nil" || val === "none" || sizeNumber === 0) {
    return { style: "none", width: 0 };
  }
  const width = borderSizeToPx(sizeNumber);
  if (width == null) return void 0;
  const normalizedColor = normalizeColorWithDefault(colorString);
  return {
    style: val || "single",
    width,
    color: normalizedColor
  };
}
function convertTableBorderValue(ooxmlBorder) {
  if (!ooxmlBorder || typeof ooxmlBorder !== "object") return void 0;
  const border = ooxmlBorder;
  if (Object.keys(border).length === 0) {
    return void 0;
  }
  const { val, size: size2, color } = border;
  if (val === "nil" || val === "none" || size2 === 0) {
    return { none: true };
  }
  const width = borderSizeToPx(size2);
  if (width == null) return void 0;
  const normalizedColor = normalizeColorWithDefault(color);
  return {
    style: val || "single",
    width,
    color: normalizedColor
  };
}
const BORDER_STYLES = /* @__PURE__ */ new Set([
  "none",
  "single",
  "double",
  "dashed",
  "dotted",
  "thick",
  "triple",
  "dotDash",
  "dotDotDash",
  "wave",
  "doubleWave"
]);
function isBorderStyle(value) {
  return typeof value === "string" && BORDER_STYLES.has(value);
}
function isTableBorderValue(value) {
  if (value === null) return true;
  if (typeof value !== "object") return false;
  const obj = value;
  if (obj.none === true) return true;
  if ("val" in obj || "size" in obj) return false;
  const hasValidKey = "style" in obj || "width" in obj || "color" in obj || "space" in obj;
  return hasValidKey && (!("style" in obj) || obj.style == null || isBorderStyle(obj.style));
}
function extractTableBorders(bordersInput) {
  if (!bordersInput || typeof bordersInput !== "object") {
    return void 0;
  }
  const sides = ["top", "right", "bottom", "left", "insideH", "insideV"];
  const borders = {};
  for (const side of sides) {
    const raw = bordersInput[side];
    if (raw == null) continue;
    if (isTableBorderValue(raw)) {
      borders[side] = raw;
    } else {
      const converted = convertTableBorderValue(raw);
      if (converted !== void 0) {
        borders[side] = converted;
      }
    }
  }
  return Object.keys(borders).length > 0 ? borders : void 0;
}
function extractCellBorders(cellAttrs) {
  if (!cellAttrs?.borders) return void 0;
  const bordersData = cellAttrs.borders;
  const borders = {};
  for (const side of ["top", "right", "bottom", "left"]) {
    const spec = convertBorderSpec(bordersData[side]);
    if (spec) {
      borders[side] = spec;
    }
  }
  return Object.keys(borders).length > 0 ? borders : void 0;
}
function extractCellPadding(cellAttrs) {
  const cellMargins = cellAttrs?.cellMargins;
  if (!cellMargins || typeof cellMargins !== "object") return void 0;
  const padding = {};
  const margins = cellMargins;
  if (typeof margins.top === "number") padding.top = margins.top;
  if (typeof margins.right === "number") padding.right = margins.right;
  if (typeof margins.bottom === "number") padding.bottom = margins.bottom;
  if (typeof margins.left === "number") padding.left = margins.left;
  return Object.keys(padding).length > 0 ? padding : void 0;
}
const normalizeParagraphBorders = (value) => {
  if (!value || typeof value !== "object") return void 0;
  const source = value;
  const sides = ["top", "right", "bottom", "left"];
  const borders = {};
  sides.forEach((side) => {
    const normalized = normalizeBorderSide(source[side]);
    if (normalized) {
      borders[side] = normalized;
    }
  });
  return Object.keys(borders).length > 0 ? borders : void 0;
};
const normalizeBorderSide = (value) => {
  if (!value || typeof value !== "object") return void 0;
  const raw = value;
  const style2 = mapBorderStyle(raw.val);
  if (style2 === "none") return void 0;
  const width = pickNumber(raw.size);
  const widthPx = borderSizeToPx(width);
  const color = normalizeColor$1(raw.color);
  const space = pickNumber(raw.space);
  if (!style2 && widthPx == null && space == null && !color) {
    return void 0;
  }
  const border = {};
  if (style2) {
    border.style = style2;
  }
  if (widthPx != null) border.width = Math.max(0, widthPx);
  if (color) border.color = color;
  if (space != null) border.space = Math.max(0, space);
  return border;
};
const mapBorderStyle = (value) => {
  if (typeof value !== "string") return void 0;
  const normalized = value.toLowerCase();
  if (normalized === "nil" || normalized === "none") {
    return "none";
  }
  if (normalized === "double") {
    return "double";
  }
  if (normalized === "dashed" || normalized === "dashsmallgap" || normalized === "dashlargegap") {
    return "dashed";
  }
  if (normalized === "dotted" || normalized === "dot") {
    return "dotted";
  }
  return "solid";
};
const normalizeParagraphShading = (value) => {
  if (!value || typeof value !== "object") return void 0;
  const source = value;
  const shading = {};
  const fill = normalizeShadingColor(source.fill);
  if (fill) shading.fill = fill;
  const color = normalizeShadingColor(source.color);
  if (color) shading.color = color;
  const val = normalizeString(source.val);
  if (val) shading.val = val;
  const themeColor = normalizeString(source.themeColor);
  if (themeColor) shading.themeColor = themeColor;
  const themeFill = normalizeString(source.themeFill);
  if (themeFill) shading.themeFill = themeFill;
  const themeFillShade = normalizeString(source.themeFillShade);
  if (themeFillShade) shading.themeFillShade = themeFillShade;
  const themeFillTint = normalizeString(source.themeFillTint);
  if (themeFillTint) shading.themeFillTint = themeFillTint;
  const themeShade = normalizeString(source.themeShade);
  if (themeShade) shading.themeShade = themeShade;
  const themeTint = normalizeString(source.themeTint);
  if (themeTint) shading.themeTint = themeTint;
  return Object.keys(shading).length > 0 ? shading : void 0;
};
const normalizeShadingColor = (value) => {
  const normalized = normalizeColor$1(value);
  if (!normalized) return void 0;
  if (normalized.toLowerCase() === "#auto") {
    return void 0;
  }
  return normalized;
};
const normalizeString = (value) => {
  if (typeof value !== "string") return void 0;
  const trimmed = value.trim();
  return trimmed ? trimmed : void 0;
};
const MAX_AUTO_LINE_MULTIPLIER = 10;
const normalizeAlignment = (value) => {
  switch (value) {
    case "center":
    case "right":
    case "justify":
    case "left":
      return value;
    case "both":
    case "distribute":
    case "numTab":
    case "thaiDistribute":
      return "justify";
    case "end":
      return "right";
    case "start":
      return "left";
    default:
      return void 0;
  }
};
const normalizeParagraphSpacing = (value, isList2) => {
  if (!value || typeof value !== "object") return void 0;
  const spacing = {};
  let before = pickNumber(value.before);
  let after = pickNumber(value.after);
  const lineRaw = pickNumber(value.line);
  const lineRule = normalizeLineRule(value.lineRule);
  const beforeAutospacing = value.beforeAutospacing;
  const afterAutospacing = value.afterAutospacing;
  if (beforeAutospacing && isList2) {
    before = void 0;
  }
  if (afterAutospacing && isList2) {
    after = void 0;
  }
  const line = normalizeLineValue(lineRaw, lineRule);
  if (before != null) spacing.before = twipsToPx$2(before);
  if (after != null) spacing.after = twipsToPx$2(after);
  if (line != null) spacing.line = line;
  if (lineRule != null) spacing.lineRule = lineRule;
  if (beforeAutospacing != null) spacing.beforeAutospacing = beforeAutospacing;
  if (afterAutospacing != null) spacing.afterAutospacing = afterAutospacing;
  return Object.keys(spacing).length > 0 ? spacing : void 0;
};
const normalizeLineValue = (value, lineRule) => {
  if (value == null) return void 0;
  if (lineRule === "auto") {
    if (value > 0 && value <= MAX_AUTO_LINE_MULTIPLIER) {
      return value;
    }
    return value / 240;
  }
  return twipsToPx$2(value);
};
const normalizeLineRule = (value) => {
  if (value === "auto" || value === "exact" || value === "atLeast") {
    return value;
  }
  return void 0;
};
const PX_TO_TWIPS = 15;
const TWIPS_THRESHOLD = 1e3;
const normalizeOoxmlTabs = (tabs) => {
  if (!Array.isArray(tabs)) return void 0;
  const normalized = [];
  for (const entry of tabs) {
    if (!entry || typeof entry !== "object") continue;
    const rawEntry = entry;
    const isNestedTab = Boolean(rawEntry.tab && typeof rawEntry.tab === "object");
    const source = isNestedTab ? rawEntry.tab : rawEntry;
    const posTwips = resolveTabPosition(source, isNestedTab);
    if (posTwips == null) continue;
    const val = normalizeTabVal(source.val ?? source.align ?? source.alignment ?? source.type ?? source.tabType);
    if (!val) continue;
    const tab = {
      val,
      pos: posTwips
    };
    const leader = normalizeTabLeader(source.leader);
    if (leader) tab.leader = leader;
    normalized.push(tab);
  }
  return normalized.length > 0 ? normalized : void 0;
};
const resolveTabPosition = (source, treatPosAsTwips = false) => {
  const originalPos = pickNumber(source.originalPos);
  if (originalPos != null) {
    return originalPos;
  }
  const posValue = pickNumber(source.pos ?? source.position ?? source.offset);
  if (posValue == null) {
    return void 0;
  }
  if (treatPosAsTwips) {
    return posValue;
  }
  if (posValue > TWIPS_THRESHOLD) {
    return posValue;
  } else {
    return Math.round(posValue * PX_TO_TWIPS);
  }
};
const normalizeTabVal = (value) => {
  switch (value) {
    case "start":
    case "center":
    case "end":
    case "decimal":
    case "bar":
    case "clear":
      return value;
    case "left":
    case "num":
      return "start";
    // Legacy mapping for RTL support
    case "right":
      return "end";
    // Legacy mapping for RTL support
    case "dec":
      return "decimal";
    // Abbreviation mapping
    default:
      return void 0;
  }
};
const normalizeTabLeader = (value) => {
  switch (value) {
    case "none":
    case "dot":
    case "hyphen":
    case "heavy":
    case "underscore":
    case "middleDot":
      return value;
    case "thick":
      return "heavy";
    // Legacy mapping
    default:
      return void 0;
  }
};
const DEFAULT_LIST_HANGING_PX$1 = 18;
const TWIPS_PER_INCH$2 = 1440;
const PIXELS_PER_INCH = 96;
const TWIPS_PER_PIXEL = Math.round(TWIPS_PER_INCH$2 / PIXELS_PER_INCH);
const PIXELS_PER_TWIP = 1 / TWIPS_PER_PIXEL;
const toFiniteNumber = (value) => {
  if (value == null) return null;
  const numeric = Number(value);
  return Number.isFinite(numeric) ? numeric : null;
};
const twipsToPixels = (twips) => {
  const numeric = toFiniteNumber(twips);
  if (numeric == null) return 0;
  return numeric * PIXELS_PER_TWIP;
};
const RESERVED_NUM_ID_KEYS = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
const NO_ABSTRACT_ID_KEY = "__no_abstract__";
const toKey$1 = (value) => String(value);
const validateNumId = (numId) => {
  if (typeof numId === "string") {
    const trimmed = numId.trim();
    if (trimmed === "") {
      throw new Error("Invalid numId: empty string. NumId must be a non-empty string or number.");
    }
    if (RESERVED_NUM_ID_KEYS.has(trimmed)) {
      throw new Error(`Invalid numId: reserved property name "${trimmed}". NumId cannot be a prototype-polluting key.`);
    }
  }
  if (typeof numId === "number" && !Number.isFinite(numId)) {
    throw new Error(`Invalid numId: ${numId}. NumId must be a finite number.`);
  }
};
const getSortedPositions = (map3) => Object.keys(map3).map((p2) => parseInt(p2, 10)).filter((value) => Number.isFinite(value)).sort((a, b2) => a - b2);
const createNumberingManager = () => {
  let countersMap = {};
  let abstractCountersMap = {};
  const startsMap = {};
  let abstractIdMap = {};
  let lastSeenMap = {};
  let pathCache = {};
  let cacheEnabled = false;
  const setStartSettings = (numId, level, startValue, restartValue) => {
    const normalizedRestart = restartValue == null ? void 0 : restartValue;
    validateNumId(numId);
    if (level < 0 || !Number.isFinite(level)) {
      throw new Error(`Invalid level: ${level}. Level must be a non-negative finite number.`);
    }
    if (!Number.isFinite(startValue)) {
      throw new Error(`Invalid startValue: ${startValue}. Start value must be a finite number.`);
    }
    if (normalizedRestart !== void 0 && !Number.isFinite(normalizedRestart)) {
      throw new Error(`Invalid restartValue: ${restartValue}. Restart value must be a finite number.`);
    }
    const key2 = toKey$1(numId);
    if (!startsMap[key2]) {
      startsMap[key2] = {};
    }
    if (!startsMap[key2][level]) {
      startsMap[key2][level] = {};
    }
    startsMap[key2][level].start = startValue;
    startsMap[key2][level].restart = normalizedRestart;
  };
  const ensureCounters = (map3, numId, level) => {
    if (!map3[numId]) {
      map3[numId] = {};
    }
    if (!map3[numId][level]) {
      map3[numId][level] = {};
    }
  };
  const setCounter = (numId, level, pos, value, abstractId) => {
    validateNumId(numId);
    if (level < 0 || !Number.isFinite(level)) {
      throw new Error(`Invalid level: ${level}. Level must be a non-negative finite number.`);
    }
    if (pos < 0 || !Number.isFinite(pos)) {
      throw new Error(`Invalid position: ${pos}. Position must be a non-negative finite number.`);
    }
    if (!Number.isFinite(value)) {
      throw new Error(`Invalid value: ${value}. Value must be a finite number.`);
    }
    const numKey = toKey$1(numId);
    const resolvedAbstractId = abstractId != null ? toKey$1(abstractId) : NO_ABSTRACT_ID_KEY;
    ensureCounters(countersMap, numKey, level);
    countersMap[numKey][level][pos] = value;
    abstractIdMap[numKey] = resolvedAbstractId;
    ensureCounters(abstractCountersMap, resolvedAbstractId, level);
    abstractCountersMap[resolvedAbstractId][level][pos] = value;
    if (!cacheEnabled) {
      return;
    }
    if (!lastSeenMap[numKey]) {
      lastSeenMap[numKey] = {};
    }
    const lastEntry = lastSeenMap[numKey][level];
    if (!lastEntry || pos > lastEntry.pos) {
      lastSeenMap[numKey][level] = { pos, count: value };
    }
  };
  const getCounter = (numId, level, pos) => {
    validateNumId(numId);
    if (level < 0 || !Number.isFinite(level)) {
      throw new Error(`Invalid level: ${level}. Level must be a non-negative finite number.`);
    }
    if (pos < 0 || !Number.isFinite(pos)) {
      throw new Error(`Invalid position: ${pos}. Position must be a non-negative finite number.`);
    }
    const numKey = toKey$1(numId);
    const numIdData = countersMap[numKey];
    if (numIdData == null) {
      return null;
    }
    const levelMap = numIdData[level];
    if (levelMap == null) {
      return null;
    }
    const value = levelMap[pos];
    if (value == null) {
      return null;
    }
    return value;
  };
  const findPreviousPosition = (levelData, pos, numKey, level) => {
    const startValue = startsMap?.[numKey]?.[level]?.start ?? 1;
    let previousPos = null;
    let previousCount = startValue - 1;
    if (cacheEnabled) {
      const cachedLast = lastSeenMap?.[numKey]?.[level];
      if (cachedLast && cachedLast.pos < pos) {
        previousPos = cachedLast.pos;
        previousCount = cachedLast.count;
      }
    }
    if (previousPos == null) {
      const candidates = getSortedPositions(levelData).filter((p2) => p2 < pos);
      const fallbackPos = candidates[candidates.length - 1];
      if (fallbackPos != null) {
        previousPos = fallbackPos;
        previousCount = levelData[fallbackPos];
      }
    }
    return { pos: previousPos, count: previousCount, startValue };
  };
  const shouldRestartCounter = (abstractIdKey, level, previousPos, pos, restartSetting) => {
    const usedLevels = [];
    for (let lvl = 0; lvl < level; lvl++) {
      const levelDataMap = abstractCountersMap?.[abstractIdKey]?.[lvl] || {};
      const hasUsed = getSortedPositions(levelDataMap).some((p2) => p2 > previousPos && p2 < pos);
      if (hasUsed) {
        usedLevels.push(lvl);
      }
    }
    if (usedLevels.length === 0) {
      return false;
    }
    if (restartSetting == null) {
      return true;
    }
    return usedLevels.some((lvl) => lvl <= restartSetting);
  };
  const calculateCounter = (numId, level, pos, abstractId) => {
    validateNumId(numId);
    if (level < 0 || !Number.isFinite(level)) {
      throw new Error(`Invalid level: ${level}. Level must be a non-negative finite number.`);
    }
    if (pos < 0 || !Number.isFinite(pos)) {
      throw new Error(`Invalid position: ${pos}. Position must be a non-negative finite number.`);
    }
    const numKey = toKey$1(numId);
    const resolvedAbstractId = abstractId != null ? toKey$1(abstractId) : NO_ABSTRACT_ID_KEY;
    abstractIdMap[numKey] = resolvedAbstractId;
    const restartSetting = startsMap?.[numKey]?.[level]?.restart;
    const levelData = countersMap?.[numKey]?.[level] || {};
    const { pos: previousPos, count: previousCount, startValue } = findPreviousPosition(levelData, pos, numKey, level);
    if (!Number.isFinite(startValue)) {
      throw new Error(`Invalid startValue: ${startValue}. Start value must be a finite number.`);
    }
    let calculatedValue;
    if (restartSetting === 0) {
      calculatedValue = previousCount + 1;
    } else if (previousPos == null) {
      calculatedValue = startValue;
    } else {
      const abstractIdKey = abstractIdMap[numKey];
      if (shouldRestartCounter(abstractIdKey, level, previousPos, pos, restartSetting)) {
        calculatedValue = startValue;
      } else {
        calculatedValue = previousCount + 1;
      }
    }
    if (!Number.isFinite(calculatedValue)) {
      throw new Error(`Calculated counter value is not finite: ${calculatedValue}`);
    }
    if (calculatedValue > Number.MAX_SAFE_INTEGER) {
      throw new Error(
        `Counter overflow: calculated value ${calculatedValue} exceeds maximum safe integer ${Number.MAX_SAFE_INTEGER}`
      );
    }
    return calculatedValue;
  };
  const getAncestorsPath = (numId, level, pos) => {
    validateNumId(numId);
    if (level < 0 || !Number.isFinite(level)) {
      throw new Error(`Invalid level: ${level}. Level must be a non-negative finite number.`);
    }
    if (pos < 0 || !Number.isFinite(pos)) {
      throw new Error(`Invalid position: ${pos}. Position must be a non-negative finite number.`);
    }
    const numKey = toKey$1(numId);
    if (cacheEnabled && pathCache?.[numKey]?.[level]?.[pos]) {
      return pathCache[numKey][level][pos];
    }
    const path = [];
    const abstractId = abstractIdMap[numKey] ?? NO_ABSTRACT_ID_KEY;
    for (let lvl = 0; lvl < level; lvl++) {
      const startCount = startsMap?.[numKey]?.[lvl]?.start ?? 1;
      const levelData = abstractCountersMap?.[abstractId]?.[lvl] || {};
      const previousPos = getSortedPositions(levelData).filter((p2) => p2 < pos).pop();
      if (previousPos == null) {
        path.push(startCount);
      } else {
        path.push(levelData[previousPos]);
      }
    }
    if (cacheEnabled) {
      if (!pathCache[numKey]) {
        pathCache[numKey] = {};
      }
      if (!pathCache[numKey][level]) {
        pathCache[numKey][level] = {};
      }
      pathCache[numKey][level][pos] = path;
    }
    return path;
  };
  const calculatePath = (numId, level, pos) => {
    validateNumId(numId);
    if (level < 0 || !Number.isFinite(level)) {
      throw new Error(`Invalid level: ${level}. Level must be a non-negative finite number.`);
    }
    if (pos < 0 || !Number.isFinite(pos)) {
      throw new Error(`Invalid position: ${pos}. Position must be a non-negative finite number.`);
    }
    const path = getAncestorsPath(numId, level, pos);
    const myCount = getCounter(numId, level, pos);
    if (myCount != null) {
      path.push(myCount);
    }
    return path;
  };
  const clearAllState = () => {
    lastSeenMap = {};
    pathCache = {};
    countersMap = {};
    abstractCountersMap = {};
    abstractIdMap = {};
  };
  const getCountersMap = () => countersMap;
  const enableCache = () => {
    cacheEnabled = true;
    clearAllState();
  };
  const disableCache = () => {
    cacheEnabled = false;
    clearAllState();
  };
  return {
    setStartSettings,
    setCounter,
    getCounter,
    calculateCounter,
    getAncestorsPath,
    calculatePath,
    getCountersMap,
    clearAllState,
    enableCache,
    disableCache
  };
};
function computeWordParagraphLayout(input) {
  const { paragraph, markerRun, listRenderingAttrs } = input;
  const layout = {
    indentLeftPx: paragraph.indent?.left ?? 0,
    hangingPx: paragraph.indent?.hanging ?? 0,
    firstLinePx: paragraph.indent?.firstLine,
    tabsPx: paragraph.tabs?.map((tab) => twipsToPixels(tab.pos)) ?? [],
    textStartPx: paragraph.indent?.left ?? 0,
    marker: void 0,
    defaultTabIntervalPx: paragraph.tabIntervalTwips
  };
  const hasFirstLineIndent = paragraph.indent?.firstLine != null && Number.isFinite(paragraph.indent.firstLine) && paragraph.indent.firstLine > 0 && !paragraph.indent.hanging;
  let markerBoxWidthPx;
  let markerX;
  if (hasFirstLineIndent) {
    markerBoxWidthPx = DEFAULT_LIST_HANGING_PX$1;
    markerX = layout.indentLeftPx + (layout.firstLinePx ?? 0);
    layout.textStartPx = markerX + markerBoxWidthPx;
    layout.hangingPx = 0;
    layout.firstLineIndentMode = true;
  } else {
    if (layout.hangingPx === 0) {
      markerBoxWidthPx = DEFAULT_LIST_HANGING_PX$1;
    } else {
      markerBoxWidthPx = layout.hangingPx;
    }
    markerX = layout.indentLeftPx - markerBoxWidthPx;
    layout.hangingPx = markerBoxWidthPx;
  }
  layout.marker = {
    markerText: listRenderingAttrs.markerText,
    // markerBoxWidthPx: markerBoxWidthPx + 1000,
    // markerX,
    // textStartX: layout.textStartPx,
    // Gutter is the small gap between marker and text, not the full marker box width
    // gutterWidthPx: LIST_MARKER_GAP,
    justification: listRenderingAttrs.justification ?? "left",
    suffix: normalizeSuffix(listRenderingAttrs.suffix),
    run: markerRun
  };
  return layout;
}
const normalizeSuffix = (suffix2) => {
  if (suffix2 === "tab" || suffix2 === "space" || suffix2 === "nothing") {
    return suffix2;
  }
  return "tab";
};
const DEFAULT_DECIMAL_SEPARATOR$1 = ".";
const DEFAULT_TAB_INTERVAL_TWIPS$2 = 720;
const normalizeColor = (value) => {
  if (typeof value !== "string") return void 0;
  const trimmed = value.trim();
  if (!trimmed || trimmed.toLowerCase() === "auto") return void 0;
  const upper = trimmed.startsWith("#") ? trimmed.slice(1) : trimmed;
  return `#${upper.toUpperCase()}`;
};
const deepClone = (obj) => {
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map((item) => deepClone(item));
  }
  const clone = {};
  for (const key2 in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key2)) {
      clone[key2] = deepClone(obj[key2]);
    }
  }
  return clone;
};
const normalizeIndentTwipsToPx = (indent) => {
  if (!indent) return void 0;
  const result = {};
  const toNum = (v) => {
    if (typeof v === "string" && v.trim() !== "" && isFinite(Number(v))) return Number(v);
    if (isFiniteNumber(v)) return Number(v);
    return void 0;
  };
  const left2 = toNum(indent.left);
  const right2 = toNum(indent.right);
  const firstLine = toNum(indent.firstLine);
  const hanging = toNum(indent.hanging);
  if (left2 != null) result.left = twipsToPx$2(left2);
  if (right2 != null) result.right = twipsToPx$2(right2);
  if (firstLine != null) result.firstLine = twipsToPx$2(firstLine);
  if (hanging != null) result.hanging = twipsToPx$2(hanging);
  return Object.keys(result).length > 0 ? result : void 0;
};
const normalizeFramePr = (value) => {
  if (!value) return void 0;
  const frame = {};
  if (value.wrap) {
    frame.wrap = value.wrap;
  }
  if (value.x != null) {
    frame.x = twipsToPx$2(value.x);
  }
  if (value.y != null) {
    frame.y = twipsToPx$2(value.y);
  }
  if (value.xAlign) {
    frame.xAlign = value.xAlign;
  }
  if (value.yAlign) {
    frame.yAlign = value.yAlign;
  }
  if (value.hAnchor) {
    frame.hAnchor = value.hAnchor;
  }
  if (value.vAnchor) {
    frame.vAnchor = value.vAnchor;
  }
  return Object.keys(frame).length > 0 ? frame : void 0;
};
const normalizeNumberingProperties = (value) => {
  if (value?.numId === 0) {
    return void 0;
  }
  return value;
};
const normalizeDropCap = (framePr, para, converterContext) => {
  if (!framePr || !framePr.dropCap || framePr.dropCap === "none") return void 0;
  const dropCap = framePr.dropCap;
  const dropCapMode = typeof dropCap === "string" ? dropCap.toLowerCase() : "drop";
  const linesValue = pickNumber(framePr.lines);
  const dropCapRunInfo = extractDropCapRunFromParagraph(para, converterContext);
  if (dropCapRunInfo) {
    const descriptor = {
      mode: dropCapMode === "margin" ? "margin" : "drop",
      lines: linesValue != null && linesValue > 0 ? linesValue : 3,
      run: dropCapRunInfo
    };
    if (framePr.wrap) {
      descriptor.wrap = framePr.wrap === "auto" ? void 0 : framePr.wrap;
    }
    return descriptor;
  }
};
const DEFAULT_DROP_CAP_FONT_SIZE_PX = 64;
const DEFAULT_DROP_CAP_FONT_FAMILY = "Times New Roman";
const extractDropCapRunFromParagraph = (para, converterContext) => {
  const content = para.content;
  if (!Array.isArray(content) || content.length === 0) {
    return null;
  }
  const firstRun = content.find((node) => node?.type === "run");
  if (!firstRun || !Array.isArray(firstRun.content)) {
    return null;
  }
  const textNode = firstRun.content.find(
    (node) => node?.type === "text" && typeof node.text === "string" && node.text.length > 0
  );
  if (!textNode || !textNode.text) {
    return null;
  }
  const text = textNode.text;
  const runProperties = firstRun.attrs?.runProperties ?? {};
  let resolvedRunProperties;
  if (converterContext) {
    resolvedRunProperties = superEditor_converter.resolveRunProperties(converterContext, runProperties, {}, null, false, false);
  } else {
    resolvedRunProperties = runProperties;
  }
  const runAttrs = computeRunAttrs(
    resolvedRunProperties,
    converterContext,
    DEFAULT_DROP_CAP_FONT_SIZE_PX,
    DEFAULT_DROP_CAP_FONT_FAMILY
  );
  const dropCapRun = {
    text,
    fontFamily: runAttrs.fontFamily,
    fontSize: runAttrs.fontSize,
    bold: runAttrs.bold,
    italic: runAttrs.italic,
    color: runAttrs.color,
    position: resolvedRunProperties.position != null ? ptToPx(resolvedRunProperties.position / 2) : void 0
  };
  return dropCapRun;
};
const computeParagraphAttrs = (para, converterContext) => {
  const attrs = para.attrs ?? {};
  const paragraphProperties = attrs.paragraphProperties ?? {};
  let resolvedParagraphProperties;
  if (!converterContext) {
    resolvedParagraphProperties = paragraphProperties;
  } else {
    resolvedParagraphProperties = superEditor_converter.resolveParagraphProperties(
      converterContext,
      paragraphProperties,
      converterContext.tableInfo
    );
  }
  const normalizedSpacing = normalizeParagraphSpacing(
    resolvedParagraphProperties.spacing,
    Boolean(resolvedParagraphProperties.numberingProperties)
  );
  const normalizedIndent = normalizeIndentTwipsToPx(resolvedParagraphProperties.indent);
  const normalizedTabStops = normalizeOoxmlTabs(resolvedParagraphProperties.tabStops);
  const normalizedAlignment = normalizeAlignment(resolvedParagraphProperties.justification);
  const normalizedBorders = normalizeParagraphBorders(resolvedParagraphProperties.borders);
  const normalizedShading = normalizeParagraphShading(resolvedParagraphProperties.shading);
  const paragraphDecimalSeparator = DEFAULT_DECIMAL_SEPARATOR$1;
  const tabIntervalTwips = DEFAULT_TAB_INTERVAL_TWIPS$2;
  const normalizedFramePr = normalizeFramePr(resolvedParagraphProperties.framePr);
  const floatAlignment = normalizedFramePr?.xAlign;
  const normalizedNumberingProperties = normalizeNumberingProperties(resolvedParagraphProperties.numberingProperties);
  const dropCapDescriptor = normalizeDropCap(resolvedParagraphProperties.framePr, para, converterContext);
  const normalizedListRendering = attrs.listRendering;
  const paragraphAttrs = {
    styleId: resolvedParagraphProperties.styleId,
    alignment: normalizedAlignment,
    spacing: normalizedSpacing,
    contextualSpacing: resolvedParagraphProperties.contextualSpacing,
    indent: normalizedIndent,
    dropCapDescriptor,
    frame: normalizedFramePr,
    numberingProperties: normalizedNumberingProperties,
    borders: normalizedBorders,
    shading: normalizedShading,
    tabs: normalizedTabStops,
    decimalSeparator: paragraphDecimalSeparator,
    tabIntervalTwips,
    keepNext: resolvedParagraphProperties.keepNext,
    keepLines: resolvedParagraphProperties.keepLines,
    floatAlignment,
    pageBreakBefore: resolvedParagraphProperties.pageBreakBefore
  };
  if (normalizedNumberingProperties && normalizedListRendering) {
    const markerRunProperties = superEditor_converter.resolveRunProperties(
      converterContext,
      resolvedParagraphProperties.runProperties,
      resolvedParagraphProperties,
      converterContext.tableInfo,
      true,
      Boolean(paragraphProperties.numberingProperties)
    );
    paragraphAttrs.wordLayout = computeWordParagraphLayout({
      paragraph: paragraphAttrs,
      listRenderingAttrs: normalizedListRendering,
      markerRun: computeRunAttrs(markerRunProperties, converterContext)
    });
  }
  return { paragraphAttrs, resolvedParagraphProperties };
};
const computeRunAttrs = (runProps, converterContext, defaultFontSizePx = 12, defaultFontFamily = "Times New Roman") => {
  let fontFamily2;
  if (converterContext) {
    fontFamily2 = superEditor_converter.resolveDocxFontFamily(runProps.fontFamily, converterContext.docx) || defaultFontFamily;
  } else {
    fontFamily2 = runProps.fontFamily?.ascii || runProps.fontFamily?.hAnsi || runProps.fontFamily?.eastAsia || defaultFontFamily;
  }
  return {
    fontFamily: toCssFontFamily(fontFamily2),
    fontSize: runProps.fontSize ? ptToPx(runProps.fontSize / 2) : defaultFontSizePx,
    bold: runProps.bold,
    italic: runProps.italic,
    underline: runProps.underline && runProps.underline["w:val"] && runProps.underline["w:val"] !== "none" ? {
      style: runProps.underline["w:val"] || "single",
      color: runProps.underline["w:color"] || void 0
    } : null,
    strike: runProps.strike,
    color: normalizeColor(runProps.color?.val),
    highlight: runProps.highlight?.["w:val"] || void 0,
    smallCaps: runProps.smallCaps,
    allCaps: runProps?.textTransform === "uppercase",
    letterSpacing: runProps.letterSpacing ? twipsToPx$2(runProps.letterSpacing) : void 0,
    lang: runProps.lang?.val || void 0
  };
};
const sdtMetadataCache = /* @__PURE__ */ new Map();
function resolveSdtMetadata(input) {
  if (!input) return void 0;
  const { nodeType, attrs, cacheKey: explicitKey } = input;
  if (!nodeType) return void 0;
  const normalizedAttrs = isPlainObject$2(attrs) ? attrs : {};
  const cacheKey = buildSdtCacheKey(nodeType, normalizedAttrs, explicitKey);
  if (cacheKey && sdtMetadataCache.has(cacheKey)) {
    return sdtMetadataCache.get(cacheKey);
  }
  let metadata;
  switch (nodeType) {
    case "fieldAnnotation":
      metadata = normalizeFieldAnnotationMetadata(normalizedAttrs);
      break;
    case "structuredContent":
    case "structuredContentBlock":
      metadata = normalizeStructuredContentMetadata(nodeType, normalizedAttrs);
      break;
    case "documentSection":
      metadata = normalizeDocumentSectionMetadata(normalizedAttrs);
      break;
    case "docPartObject":
      metadata = normalizeDocPartMetadata(normalizedAttrs);
      break;
  }
  if (metadata && cacheKey) {
    sdtMetadataCache.set(cacheKey, metadata);
  }
  return metadata;
}
function normalizeFieldAnnotationMetadata(attrs) {
  const fieldId = toOptionalString(attrs.fieldId) ?? "";
  const formatting = extractFormatting(attrs);
  const size2 = normalizeSize(attrs.size);
  const extras = isPlainObject$2(attrs.extras) ? attrs.extras : null;
  const marks = isPlainObject$2(attrs.marks) ? attrs.marks : void 0;
  return {
    type: "fieldAnnotation",
    fieldId,
    variant: normalizeFieldAnnotationVariant(attrs.type),
    fieldType: toOptionalString(attrs.fieldType),
    displayLabel: toOptionalString(attrs.displayLabel),
    defaultDisplayLabel: toOptionalString(attrs.defaultDisplayLabel),
    alias: toOptionalString(attrs.alias),
    fieldColor: normalizeColorValue(attrs.fieldColor),
    borderColor: normalizeColorValue(attrs.borderColor),
    highlighted: toBoolean$1(attrs.highlighted, true),
    fontFamily: toNullableString(attrs.fontFamily),
    fontSize: normalizeFontSize$1(attrs.fontSize),
    textColor: normalizeColorValue(attrs.textColor) ?? null,
    textHighlight: normalizeColorValue(attrs.textHighlight) ?? null,
    linkUrl: toNullableString(attrs.linkUrl),
    imageSrc: toNullableString(attrs.imageSrc),
    rawHtml: attrs.rawHtml ?? void 0,
    size: size2 ?? null,
    extras,
    multipleImage: toBoolean$1(attrs.multipleImage, false),
    hash: toOptionalString(attrs.hash) ?? null,
    generatorIndex: toNumber(attrs.generatorIndex),
    sdtId: toOptionalString(attrs.sdtId) ?? null,
    hidden: toBoolean$1(attrs.hidden, false),
    visibility: normalizeVisibility(attrs.visibility),
    isLocked: toBoolean$1(attrs.isLocked, false),
    formatting,
    marks
  };
}
function normalizeStructuredContentMetadata(nodeType, attrs) {
  return {
    type: "structuredContent",
    scope: nodeType === "structuredContentBlock" ? "block" : "inline",
    id: toNullableString(attrs.id),
    tag: toOptionalString(attrs.tag),
    alias: toOptionalString(attrs.alias),
    sdtPr: attrs.sdtPr
  };
}
function normalizeDocumentSectionMetadata(attrs) {
  return {
    type: "documentSection",
    id: toNullableString(attrs.id),
    title: toOptionalString(attrs.title) ?? null,
    description: toOptionalString(attrs.description) ?? null,
    sectionType: toOptionalString(attrs.sectionType) ?? null,
    isLocked: toBoolean$1(attrs.isLocked, false),
    sdBlockId: toNullableString(attrs.sdBlockId)
  };
}
function normalizeDocPartMetadata(attrs) {
  return {
    type: "docPartObject",
    gallery: toOptionalString(attrs.docPartGallery ?? attrs.gallery) ?? null,
    // Source uniqueId from attrs.id (PM adapter uses getDocPartObjectId which extracts attrs.id)
    // Fall back to attrs.uniqueId for compatibility
    uniqueId: toOptionalString(attrs.id ?? attrs.uniqueId) ?? null,
    alias: toOptionalString(attrs.alias) ?? null,
    instruction: toOptionalString(attrs.instruction) ?? null
  };
}
function isPlainObject$2(value) {
  return !!value && typeof value === "object" && !Array.isArray(value);
}
function toOptionalString(value) {
  if (value == null) return void 0;
  if (typeof value === "string") {
    const trimmed = value.trim();
    return trimmed.length ? trimmed : void 0;
  }
  return String(value);
}
function toNullableString(value) {
  const str = toOptionalString(value);
  return str ?? null;
}
function toBoolean$1(value, fallback) {
  if (typeof value === "boolean") return value;
  if (typeof value === "string") {
    const lower = value.toLowerCase();
    if (lower === "true") return true;
    if (lower === "false") return false;
  }
  if (value == null) return fallback;
  return Boolean(value);
}
function normalizeVisibility(value) {
  if (typeof value !== "string") return void 0;
  const normalized = value.toLowerCase();
  if (normalized === "visible" || normalized === "hidden") {
    return normalized;
  }
  return void 0;
}
function normalizeColorValue(value) {
  if (typeof value !== "string") return void 0;
  const trimmed = value.trim();
  if (!trimmed || trimmed.toLowerCase() === "none") return void 0;
  return trimmed;
}
function normalizeFontSize$1(value) {
  if (value == null) return null;
  if (typeof value === "number") {
    return Number.isFinite(value) ? value : null;
  }
  if (typeof value === "string") {
    const trimmed = value.trim();
    return trimmed.length ? trimmed : null;
  }
  return null;
}
function toNumber(value) {
  if (typeof value === "number") {
    return Number.isFinite(value) ? value : null;
  }
  if (typeof value === "string") {
    const parsed = parseFloat(value);
    return Number.isFinite(parsed) ? parsed : null;
  }
  return null;
}
function normalizeSize(value) {
  if (!isPlainObject$2(value)) return null;
  const obj = value;
  const width = toNumber(obj.width);
  const height = toNumber(obj.height);
  if (width == null && height == null) return null;
  const result = {};
  if (width != null) result.width = width;
  if (height != null) result.height = height;
  return result;
}
function normalizeFieldAnnotationVariant(value) {
  if (typeof value !== "string") return void 0;
  const normalized = value.toLowerCase();
  if (normalized === "text" || normalized === "image" || normalized === "signature" || normalized === "checkbox" || normalized === "html" || normalized === "link") {
    return normalized;
  }
  return void 0;
}
function extractFormatting(attrs) {
  const bold = toBoolean$1(attrs.bold, false);
  const italic = toBoolean$1(attrs.italic, false);
  const underline = toBoolean$1(attrs.underline, false);
  const formatting = {};
  if (bold) formatting.bold = true;
  if (italic) formatting.italic = true;
  if (underline) formatting.underline = true;
  return Object.keys(formatting).length ? formatting : void 0;
}
function buildSdtCacheKey(nodeType, attrs, explicitKey) {
  const provided = toOptionalString(explicitKey);
  if (provided) {
    return `${nodeType}:${provided}`;
  }
  const hash2 = toOptionalString(attrs.hash);
  if (hash2) {
    return `${nodeType}:${hash2}`;
  }
  const id = toOptionalString(attrs.id);
  if (id) {
    return `${nodeType}:${id}`;
  }
  return void 0;
}
function getNodeInstruction(node) {
  if (typeof node.attrs !== "object" || node.attrs === null) return void 0;
  const attrs = node.attrs;
  return typeof attrs.instruction === "string" ? attrs.instruction : void 0;
}
function getDocPartGallery(node) {
  if (typeof node.attrs !== "object" || node.attrs === null) return void 0;
  const attrs = node.attrs;
  return typeof attrs.docPartGallery === "string" ? attrs.docPartGallery : void 0;
}
function getDocPartObjectId(node) {
  if (typeof node.attrs !== "object" || node.attrs === null) return void 0;
  const attrs = node.attrs;
  return typeof attrs.id === "string" ? attrs.id : void 0;
}
function resolveNodeSdtMetadata(node, overrideType) {
  const attrs = node.attrs;
  if (!attrs) return void 0;
  const nodeType = overrideType ?? node.type;
  if (!nodeType) return void 0;
  const cacheKey = typeof attrs.hash === "string" ? attrs.hash : typeof attrs.id === "string" ? attrs.id : typeof attrs.fieldId === "string" ? attrs.fieldId : void 0;
  return resolveSdtMetadata({
    nodeType,
    attrs,
    cacheKey
  });
}
function applySdtMetadataToParagraphBlocks(blocks, metadata) {
  if (!metadata) return;
  blocks.forEach((block) => {
    if (block.kind !== "paragraph") return;
    if (!block.attrs) block.attrs = {};
    block.attrs.sdt = metadata;
  });
}
function applySdtMetadataToTableBlock(tableBlock, metadata) {
  if (!metadata || !tableBlock || tableBlock.kind !== "table") return;
  const table = tableBlock;
  if (!table.attrs) table.attrs = {};
  table.attrs.sdt = metadata;
  table.rows?.forEach((row) => {
    row.cells?.forEach((cell) => {
      const cellBlocks = cell.blocks;
      if (cellBlocks && cellBlocks.length > 0) {
        applySdtMetadataToParagraphBlocks(cellBlocks, metadata);
        cellBlocks.forEach((block) => {
          if (block.kind === "table") {
            applySdtMetadataToTableBlock(block, metadata);
          }
        });
        return;
      }
      if (cell.paragraph) {
        applySdtMetadataToParagraphBlocks([cell.paragraph], metadata);
      }
    });
  });
}
function applyTocMetadata(blocks, metadata) {
  blocks.forEach((block) => {
    if (block.kind === "paragraph") {
      if (!block.attrs) block.attrs = {};
      block.attrs.isTocEntry = true;
      if (!block.attrs.sdt) {
        block.attrs.sdt = {
          type: "docPartObject",
          gallery: metadata.gallery,
          uniqueId: metadata.uniqueId,
          instruction: metadata.instruction
        };
      }
      if (metadata.instruction) {
        block.attrs.tocInstruction = metadata.instruction;
      }
    }
  });
}
function processTocChildren(children, metadata, context, outputArrays) {
  const paragraphConverter = context.converters.paragraphToFlowBlocks;
  const { docPartGallery, docPartObjectId, tocInstruction } = metadata;
  const { blocks, recordBlockKind } = outputArrays;
  children.forEach((child) => {
    if (child.type === "paragraph") {
      const paragraphBlocks = paragraphConverter({
        para: child,
        nextBlockId: context.nextBlockId,
        positions: context.positions,
        trackedChangesConfig: context.trackedChangesConfig,
        bookmarks: context.bookmarks,
        hyperlinkConfig: context.hyperlinkConfig,
        converters: context.converters,
        enableComments: context.enableComments,
        converterContext: context.converterContext
      });
      applyTocMetadata(paragraphBlocks, {
        gallery: docPartGallery,
        uniqueId: docPartObjectId,
        instruction: tocInstruction
      });
      applySdtMetadataToParagraphBlocks(
        paragraphBlocks.filter((b2) => b2.kind === "paragraph"),
        metadata.sdtMetadata
      );
      paragraphBlocks.forEach((block) => {
        blocks.push(block);
        recordBlockKind(block.kind);
      });
    } else if (child.type === "tableOfContents" && Array.isArray(child.content)) {
      const childInstruction = getNodeInstruction(child);
      const finalInstruction = childInstruction ?? tocInstruction;
      processTocChildren(
        child.content,
        { docPartGallery, docPartObjectId, tocInstruction: finalInstruction, sdtMetadata: metadata.sdtMetadata },
        context,
        outputArrays
      );
    }
  });
}
function handleTableOfContentsNode(node, context) {
  if (!Array.isArray(node.content)) return;
  const {
    blocks,
    recordBlockKind,
    nextBlockId,
    positions,
    trackedChangesConfig,
    bookmarks,
    hyperlinkConfig,
    converters: converters2,
    converterContext,
    themeColors,
    enableComments
  } = context;
  const tocInstruction = getNodeInstruction(node);
  const paragraphToFlowBlocks2 = converters2.paragraphToFlowBlocks;
  node.content.forEach((child) => {
    if (child.type === "paragraph") {
      const paragraphBlocks = paragraphToFlowBlocks2({
        para: child,
        nextBlockId,
        positions,
        trackedChangesConfig,
        bookmarks,
        themeColors,
        hyperlinkConfig,
        converters: converters2,
        enableComments,
        converterContext
      });
      paragraphBlocks.forEach((block) => {
        if (block.kind === "paragraph") {
          if (!block.attrs) block.attrs = {};
          block.attrs.isTocEntry = true;
          if (tocInstruction) block.attrs.tocInstruction = tocInstruction;
        }
        blocks.push(block);
        recordBlockKind(block.kind);
      });
    }
  });
}
const getIndexChildren = (node) => {
  if (Array.isArray(node.content)) return node.content;
  const content = node.content;
  if (content && typeof content.forEach === "function") {
    const children = [];
    content.forEach((child) => {
      children.push(child);
    });
    return children;
  }
  return [];
};
function handleIndexNode(node, context) {
  const children = getIndexChildren(node);
  if (children.length === 0) return;
  const {
    blocks,
    recordBlockKind,
    nextBlockId,
    positions,
    trackedChangesConfig,
    bookmarks,
    hyperlinkConfig,
    sectionState,
    converters: converters2,
    themeColors,
    enableComments
  } = context;
  const paragraphToFlowBlocks2 = converters2.paragraphToFlowBlocks;
  children.forEach((child) => {
    if (child.type !== "paragraph") {
      return;
    }
    if (sectionState?.ranges?.length > 0) {
      const nextSection = sectionState.ranges[sectionState.currentSectionIndex + 1];
      if (nextSection && sectionState.currentParagraphIndex === nextSection.startParagraphIndex) {
        const currentSection = sectionState.ranges[sectionState.currentSectionIndex];
        const requiresPageBoundary = shouldRequirePageBoundary(currentSection, nextSection) || hasIntrinsicBoundarySignals();
        const extraAttrs = requiresPageBoundary ? { requirePageBoundary: true } : void 0;
        const sectionBreak = createSectionBreakBlock(nextSection, nextBlockId, extraAttrs);
        blocks.push(sectionBreak);
        recordBlockKind(sectionBreak.kind);
        sectionState.currentSectionIndex++;
      }
    }
    const paragraphBlocks = paragraphToFlowBlocks2({
      para: child,
      nextBlockId,
      positions,
      trackedChangesConfig,
      bookmarks,
      hyperlinkConfig,
      themeColors,
      converterContext: context.converterContext,
      enableComments,
      converters: converters2
    });
    paragraphBlocks.forEach((block) => {
      blocks.push(block);
      recordBlockKind(block.kind);
    });
    sectionState.currentParagraphIndex++;
  });
}
function handleStructuredContentBlockNode(node, context) {
  if (!Array.isArray(node.content)) return;
  const {
    blocks,
    recordBlockKind,
    nextBlockId,
    positions,
    trackedChangesConfig,
    bookmarks,
    hyperlinkConfig,
    converters: converters2,
    converterContext,
    enableComments,
    themeColors
  } = context;
  const structuredContentMetadata = resolveNodeSdtMetadata(node, "structuredContentBlock");
  const paragraphToFlowBlocks2 = converters2.paragraphToFlowBlocks;
  node.content.forEach((child) => {
    if (child.type === "paragraph") {
      const paragraphBlocks = paragraphToFlowBlocks2({
        para: child,
        nextBlockId,
        positions,
        trackedChangesConfig,
        bookmarks,
        hyperlinkConfig,
        themeColors,
        enableComments,
        converters: converters2,
        converterContext
      });
      applySdtMetadataToParagraphBlocks(
        paragraphBlocks.filter((b2) => b2.kind === "paragraph"),
        structuredContentMetadata
      );
      paragraphBlocks.forEach((block) => {
        blocks.push(block);
        recordBlockKind(block.kind);
      });
    } else if (child.type === "table") {
      const tableNodeToBlock2 = converters2?.tableNodeToBlock;
      if (tableNodeToBlock2) {
        const tableBlock = tableNodeToBlock2({
          node: child,
          nextBlockId,
          positions,
          trackedChangesConfig,
          bookmarks,
          hyperlinkConfig,
          themeColors,
          enableComments,
          converters: converters2,
          converterContext
        });
        if (tableBlock) {
          applySdtMetadataToTableBlock(tableBlock, structuredContentMetadata);
          blocks.push(tableBlock);
          recordBlockKind(tableBlock.kind);
        }
      }
    }
  });
}
function processParagraphChild(child, sectionMetadata, context, output, converters2) {
  const paragraphBlocks = converters2.paragraphToFlowBlocks({
    para: child,
    nextBlockId: context.nextBlockId,
    positions: context.positions,
    trackedChangesConfig: void 0,
    // trackedChanges
    bookmarks: context.bookmarks,
    hyperlinkConfig: context.hyperlinkConfig,
    converters: converters2,
    enableComments: context.enableComments,
    converterContext: context.converterContext
  });
  applySdtMetadataToParagraphBlocks(
    paragraphBlocks.filter((b2) => b2.kind === "paragraph"),
    sectionMetadata
  );
  paragraphBlocks.forEach((block) => {
    output.blocks.push(block);
    output.recordBlockKind(block.kind);
  });
}
function processTableChild(child, sectionMetadata, context, output, converters2) {
  const tableBlock = converters2.tableNodeToBlock({
    node: child,
    nextBlockId: context.nextBlockId,
    positions: context.positions,
    trackedChangesConfig: context.trackedChangesConfig,
    bookmarks: context.bookmarks,
    hyperlinkConfig: context.hyperlinkConfig,
    enableComments: context.enableComments,
    converters: converters2,
    converterContext: context.converterContext
  });
  if (tableBlock) {
    applySdtMetadataToTableBlock(tableBlock, sectionMetadata);
    output.blocks.push(tableBlock);
    output.recordBlockKind(tableBlock.kind);
  }
}
function processImageChild(child, sectionMetadata, context, output, converters2) {
  const imageBlock = converters2.imageNodeToBlock(child, context.nextBlockId, context.positions);
  if (imageBlock && imageBlock.kind === "image") {
    if (sectionMetadata) {
      if (!imageBlock.attrs) imageBlock.attrs = {};
      imageBlock.attrs.sdt = sectionMetadata;
    }
    output.blocks.push(imageBlock);
    output.recordBlockKind(imageBlock.kind);
  }
}
function processNestedStructuredContent(child, sectionMetadata, context, output, converters2) {
  const nestedMetadata = resolveNodeSdtMetadata(child, "structuredContentBlock");
  child.content?.forEach((grandchild) => {
    if (grandchild.type === "paragraph") {
      const paragraphBlocks = converters2.paragraphToFlowBlocks({
        para: grandchild,
        nextBlockId: context.nextBlockId,
        positions: context.positions,
        trackedChangesConfig: context.trackedChangesConfig,
        bookmarks: context.bookmarks,
        hyperlinkConfig: context.hyperlinkConfig,
        converters: converters2,
        enableComments: context.enableComments,
        converterContext: context.converterContext,
        themeColors: context.themeColors
      });
      const paraOnly = paragraphBlocks.filter((b2) => b2.kind === "paragraph");
      applySdtMetadataToParagraphBlocks(paraOnly, nestedMetadata);
      applySdtMetadataToParagraphBlocks(paraOnly, sectionMetadata);
      paragraphBlocks.forEach((block) => {
        output.blocks.push(block);
        output.recordBlockKind(block.kind);
      });
    } else if (grandchild.type === "table") {
      const tableBlock = converters2.tableNodeToBlock({
        node: grandchild,
        nextBlockId: context.nextBlockId,
        positions: context.positions,
        trackedChangesConfig: context.trackedChangesConfig,
        bookmarks: context.bookmarks,
        hyperlinkConfig: context.hyperlinkConfig,
        enableComments: context.enableComments,
        themeColors: context.themeColors,
        converters: converters2,
        converterContext: context.converterContext
      });
      if (tableBlock) {
        if (nestedMetadata) applySdtMetadataToTableBlock(tableBlock, nestedMetadata);
        applySdtMetadataToTableBlock(tableBlock, sectionMetadata);
        output.blocks.push(tableBlock);
        output.recordBlockKind(tableBlock.kind);
      }
    }
  });
}
function processDocumentPartObject(child, sectionMetadata, context, output, converters2) {
  const docPartGallery = getDocPartGallery(child);
  const docPartObjectId = getDocPartObjectId(child);
  const tocInstruction = getNodeInstruction(child);
  const docPartSdtMetadata = resolveNodeSdtMetadata(child, "docPartObject");
  if (docPartGallery === "Table of Contents") {
    const blocksBeforeToc = output.blocks.length;
    processTocChildren(
      Array.from(child.content ?? []),
      { docPartGallery, docPartObjectId, tocInstruction, sdtMetadata: docPartSdtMetadata },
      {
        nextBlockId: context.nextBlockId,
        positions: context.positions,
        bookmarks: context.bookmarks,
        hyperlinkConfig: context.hyperlinkConfig,
        enableComments: context.enableComments,
        themeColors: context.themeColors,
        converters: converters2,
        converterContext: context.converterContext
      },
      { blocks: output.blocks, recordBlockKind: output.recordBlockKind }
    );
    for (let i = blocksBeforeToc; i < output.blocks.length; i++) {
      const block = output.blocks[i];
      if (block.kind === "paragraph") {
        const existingMetadata = block.attrs?.sdt;
        if (existingMetadata?.type === "docPartObject") {
          if (sectionMetadata) {
            if (!block.attrs) block.attrs = {};
            block.attrs.containerSdt = sectionMetadata;
          }
        } else {
          applySdtMetadataToParagraphBlocks([block], sectionMetadata);
        }
      }
    }
  }
}
function processDocumentSectionChildren(children, sectionMetadata, context, output, converters2) {
  children.forEach((child) => {
    if (child.type === "paragraph") {
      processParagraphChild(child, sectionMetadata, context, output, converters2);
    } else if (child.type === "table") {
      processTableChild(child, sectionMetadata, context, output, converters2);
    } else if (child.type === "image") {
      processImageChild(child, sectionMetadata, context, output, converters2);
    } else if (child.type === "structuredContentBlock" && Array.isArray(child.content)) {
      processNestedStructuredContent(child, sectionMetadata, context, output, converters2);
    } else if (child.type === "documentPartObject" && Array.isArray(child.content)) {
      processDocumentPartObject(child, sectionMetadata, context, output, converters2);
    }
  });
}
function handleDocumentSectionNode(node, context) {
  if (!Array.isArray(node.content)) return;
  const {
    blocks,
    recordBlockKind,
    nextBlockId,
    positions,
    bookmarks,
    hyperlinkConfig,
    converters: converters2,
    enableComments,
    converterContext,
    trackedChangesConfig,
    themeColors
  } = context;
  const sectionMetadata = resolveNodeSdtMetadata(node, "documentSection");
  processDocumentSectionChildren(
    node.content,
    sectionMetadata,
    {
      nextBlockId,
      positions,
      bookmarks,
      trackedChangesConfig,
      hyperlinkConfig,
      themeColors,
      enableComments,
      converterContext
    },
    { blocks, recordBlockKind },
    converters2
  );
}
function handleDocumentPartObjectNode(node, context) {
  if (!Array.isArray(node.content)) return;
  const {
    blocks,
    recordBlockKind,
    nextBlockId,
    positions,
    bookmarks,
    hyperlinkConfig,
    converters: converters2,
    converterContext,
    enableComments,
    trackedChangesConfig,
    themeColors
  } = context;
  const docPartGallery = getDocPartGallery(node);
  const docPartObjectId = getDocPartObjectId(node);
  const tocInstruction = getNodeInstruction(node);
  const docPartSdtMetadata = resolveNodeSdtMetadata(node, "docPartObject");
  const paragraphToFlowBlocks2 = converters2.paragraphToFlowBlocks;
  if (docPartGallery === "Table of Contents") {
    processTocChildren(
      Array.from(node.content),
      { docPartGallery, docPartObjectId, tocInstruction, sdtMetadata: docPartSdtMetadata },
      {
        nextBlockId,
        positions,
        bookmarks,
        hyperlinkConfig,
        enableComments,
        trackedChangesConfig,
        converters: converters2,
        converterContext
      },
      { blocks, recordBlockKind }
    );
  } else if (paragraphToFlowBlocks2) {
    for (const child of node.content) {
      if (child.type === "paragraph") {
        const childBlocks = paragraphToFlowBlocks2({
          para: child,
          nextBlockId,
          positions,
          trackedChangesConfig,
          bookmarks,
          hyperlinkConfig,
          converters: converters2,
          themeColors,
          enableComments,
          converterContext
        });
        for (const block of childBlocks) {
          blocks.push(block);
          recordBlockKind(block.kind);
        }
      }
    }
  }
}
const WRAP_TYPES$1 = /* @__PURE__ */ new Set(["None", "Square", "Tight", "Through", "TopAndBottom", "Inline"]);
const WRAP_TEXT_VALUES$1 = /* @__PURE__ */ new Set(["bothSides", "left", "right", "largest"]);
const H_RELATIVE_VALUES$1 = /* @__PURE__ */ new Set(["column", "page", "margin"]);
const V_RELATIVE_VALUES$1 = /* @__PURE__ */ new Set(["paragraph", "page", "margin"]);
const H_ALIGN_VALUES$1 = /* @__PURE__ */ new Set(["left", "center", "right"]);
const V_ALIGN_VALUES$1 = /* @__PURE__ */ new Set(["top", "center", "bottom"]);
const getAttrs$1 = (node) => {
  return isPlainObject$3(node.attrs) ? node.attrs : {};
};
const isHiddenDrawing$1 = (attrs) => {
  if (toBoolean$2(attrs.hidden) === true) return true;
  return typeof attrs.visibility === "string" && attrs.visibility.toLowerCase() === "hidden";
};
const normalizeWrapType$1 = (value) => {
  if (typeof value !== "string") return void 0;
  return WRAP_TYPES$1.has(value) ? value : void 0;
};
const normalizeWrapText$1 = (value) => {
  if (typeof value !== "string") return void 0;
  return WRAP_TEXT_VALUES$1.has(value) ? value : void 0;
};
const normalizePolygon$1 = (value) => {
  if (!Array.isArray(value)) return void 0;
  const polygon = [];
  value.forEach((point) => {
    if (!Array.isArray(point) || point.length < 2) return;
    const x = pickNumber(point[0]);
    const y2 = pickNumber(point[1]);
    if (x == null || y2 == null) return;
    polygon.push([x, y2]);
  });
  return polygon.length > 0 ? polygon : void 0;
};
const normalizeWrap$2 = (value) => {
  if (!isPlainObject$3(value)) {
    return void 0;
  }
  const type = normalizeWrapType$1(value.type);
  if (!type || type === "Inline") {
    return void 0;
  }
  const wrap = { type };
  const attrs = isPlainObject$3(value.attrs) ? value.attrs : {};
  const wrapText = normalizeWrapText$1(attrs.wrapText);
  if (wrapText) {
    wrap.wrapText = wrapText;
  }
  const distTop = pickNumber(attrs.distTop ?? attrs.distT);
  if (distTop != null) wrap.distTop = distTop;
  const distBottom = pickNumber(attrs.distBottom ?? attrs.distB);
  if (distBottom != null) wrap.distBottom = distBottom;
  const distLeft = pickNumber(attrs.distLeft ?? attrs.distL);
  if (distLeft != null) wrap.distLeft = distLeft;
  const distRight = pickNumber(attrs.distRight ?? attrs.distR);
  if (distRight != null) wrap.distRight = distRight;
  const polygon = normalizePolygon$1(attrs.polygon);
  if (polygon) {
    wrap.polygon = polygon;
  }
  const behindDoc = toBoolean$2(attrs.behindDoc);
  if (behindDoc != null) {
    wrap.behindDoc = behindDoc;
  }
  return wrap;
};
const normalizeAnchorRelative$1 = (value, allowed) => {
  if (typeof value !== "string") return void 0;
  return allowed.has(value) ? value : void 0;
};
const normalizeAnchorAlign$1 = (value, allowed) => {
  if (typeof value !== "string") return void 0;
  return allowed.has(value) ? value : void 0;
};
const normalizeAnchorData$1 = (value, attrs, wrapBehindDoc) => {
  const raw = isPlainObject$3(value) ? value : void 0;
  const marginOffset = isPlainObject$3(attrs.marginOffset) ? attrs.marginOffset : void 0;
  const simplePos = isPlainObject$3(attrs.simplePos) ? attrs.simplePos : void 0;
  const originalAttrs = isPlainObject$3(attrs.originalAttributes) ? attrs.originalAttributes : void 0;
  const isAnchored = attrs.isAnchor === true || Boolean(raw);
  const anchor = {};
  if (isAnchored) {
    anchor.isAnchored = true;
  }
  const hRelative = normalizeAnchorRelative$1(raw?.hRelativeFrom, H_RELATIVE_VALUES$1);
  if (hRelative) anchor.hRelativeFrom = hRelative;
  const vRelative = normalizeAnchorRelative$1(raw?.vRelativeFrom, V_RELATIVE_VALUES$1);
  if (vRelative) anchor.vRelativeFrom = vRelative;
  const alignH = normalizeAnchorAlign$1(raw?.alignH, H_ALIGN_VALUES$1);
  if (alignH) anchor.alignH = alignH;
  const alignV = normalizeAnchorAlign$1(raw?.alignV, V_ALIGN_VALUES$1);
  if (alignV) anchor.alignV = alignV;
  const offsetH = pickNumber(marginOffset?.horizontal ?? marginOffset?.left ?? raw?.offsetH ?? simplePos?.x);
  if (offsetH != null) anchor.offsetH = offsetH;
  const offsetV = pickNumber(marginOffset?.top ?? marginOffset?.vertical ?? raw?.offsetV ?? simplePos?.y);
  if (offsetV != null) anchor.offsetV = offsetV;
  const behindDoc = toBoolean$2(raw?.behindDoc ?? wrapBehindDoc ?? originalAttrs?.behindDoc);
  if (behindDoc != null) anchor.behindDoc = behindDoc;
  const hasData = anchor.isAnchored || anchor.hRelativeFrom != null || anchor.vRelativeFrom != null || anchor.alignH != null || anchor.alignV != null || anchor.offsetH != null || anchor.offsetV != null || anchor.behindDoc != null;
  return hasData ? anchor : void 0;
};
const buildDrawingBlock = (rawAttrs, nextBlockId, positions, node, geometry, drawingKind, extraProps) => {
  const normalizedWrap = normalizeWrap$2(rawAttrs.wrap);
  const baseAnchor = normalizeAnchorData$1(rawAttrs.anchorData, rawAttrs, normalizedWrap?.behindDoc);
  const pos = positions.get(node);
  const attrsWithPm = { ...rawAttrs };
  if (pos) {
    attrsWithPm.pmStart = pos.start;
    attrsWithPm.pmEnd = pos.end;
  }
  const zIndexFromRelativeHeight = normalizeZIndex(rawAttrs.originalAttributes);
  const finalZIndex = zIndexFromRelativeHeight ?? coerceNumber(rawAttrs.zIndex);
  return {
    kind: "drawing",
    id: nextBlockId("drawing"),
    drawingKind,
    padding: toBoxSpacing$1(rawAttrs.padding),
    margin: toBoxSpacing$1(rawAttrs.marginOffset) ?? toBoxSpacing$1(rawAttrs.margin),
    anchor: baseAnchor,
    wrap: normalizedWrap,
    zIndex: finalZIndex,
    drawingContentId: typeof rawAttrs.drawingContentId === "string" ? rawAttrs.drawingContentId : void 0,
    drawingContent: toDrawingContentSnapshot(rawAttrs.drawingContent),
    attrs: attrsWithPm,
    geometry,
    shapeKind: typeof rawAttrs.kind === "string" ? rawAttrs.kind : void 0,
    fillColor: normalizeFillColor(rawAttrs.fillColor),
    strokeColor: normalizeStrokeColor(rawAttrs.strokeColor),
    strokeWidth: coerceNumber(rawAttrs.strokeWidth),
    textContent: normalizeTextContent(rawAttrs.textContent),
    textAlign: typeof rawAttrs.textAlign === "string" ? rawAttrs.textAlign : void 0,
    textVerticalAlign: normalizeTextVerticalAlign(rawAttrs.textVerticalAlign),
    textInsets: normalizeTextInsets(rawAttrs.textInsets),
    ...extraProps
  };
};
function vectorShapeNodeToDrawingBlock(node, nextBlockId, positions) {
  const rawAttrs = getAttrs$1(node);
  if (isHiddenDrawing$1(rawAttrs)) {
    return null;
  }
  const effectExtent = normalizeEffectExtent(rawAttrs.effectExtent);
  const baseWidth = coercePositiveNumber(rawAttrs.width, 1);
  const baseHeight = coercePositiveNumber(rawAttrs.height, 1);
  const extraWidth = (effectExtent?.left ?? 0) + (effectExtent?.right ?? 0);
  const extraHeight = (effectExtent?.top ?? 0) + (effectExtent?.bottom ?? 0);
  const geometry = {
    width: coercePositiveNumber(baseWidth + extraWidth, 1),
    height: coercePositiveNumber(baseHeight + extraHeight, 1),
    rotation: coerceNumber(rawAttrs.rotation) ?? 0,
    flipH: coerceBoolean(rawAttrs.flipH) ?? false,
    flipV: coerceBoolean(rawAttrs.flipV) ?? false
  };
  const lineEnds = normalizeLineEnds(rawAttrs.lineEnds);
  return buildDrawingBlock(rawAttrs, nextBlockId, positions, node, geometry, "vectorShape", {
    lineEnds,
    effectExtent
  });
}
function shapeGroupNodeToDrawingBlock(node, nextBlockId, positions) {
  const rawAttrs = getAttrs$1(node);
  if (isHiddenDrawing$1(rawAttrs)) {
    return null;
  }
  const groupTransform = isShapeGroupTransform(rawAttrs.groupTransform) ? { ...rawAttrs.groupTransform } : void 0;
  const size2 = normalizeShapeSize(rawAttrs.size);
  const width = size2?.width ?? groupTransform?.width ?? 1;
  const height = size2?.height ?? groupTransform?.height ?? 1;
  const geometry = {
    width: coercePositiveNumber(width, 1),
    height: coercePositiveNumber(height, 1),
    rotation: coerceNumber(rawAttrs.rotation) ?? 0,
    flipH: coerceBoolean(rawAttrs.flipH) ?? false,
    flipV: coerceBoolean(rawAttrs.flipV) ?? false
  };
  return buildDrawingBlock(rawAttrs, nextBlockId, positions, node, geometry, "shapeGroup", {
    groupTransform,
    shapes: normalizeShapeGroupChildren(rawAttrs.shapes),
    size: size2
  });
}
function shapeContainerNodeToDrawingBlock(node, nextBlockId, positions) {
  const rawAttrs = getAttrs$1(node);
  if (isHiddenDrawing$1(rawAttrs)) {
    return null;
  }
  const geometry = {
    width: coercePositiveNumber(rawAttrs.width, 1),
    height: coercePositiveNumber(rawAttrs.height, 1),
    rotation: coerceNumber(rawAttrs.rotation) ?? 0,
    flipH: coerceBoolean(rawAttrs.flipH) ?? false,
    flipV: coerceBoolean(rawAttrs.flipV) ?? false
  };
  return buildDrawingBlock(rawAttrs, nextBlockId, positions, node, geometry, "vectorShape");
}
function shapeTextboxNodeToDrawingBlock(node, nextBlockId, positions) {
  const rawAttrs = getAttrs$1(node);
  if (isHiddenDrawing$1(rawAttrs)) {
    return null;
  }
  const geometry = {
    width: coercePositiveNumber(rawAttrs.width, 1),
    height: coercePositiveNumber(rawAttrs.height, 1),
    rotation: coerceNumber(rawAttrs.rotation) ?? 0,
    flipH: coerceBoolean(rawAttrs.flipH) ?? false,
    flipV: coerceBoolean(rawAttrs.flipV) ?? false
  };
  return buildDrawingBlock(rawAttrs, nextBlockId, positions, node, geometry, "vectorShape");
}
function handleVectorShapeNode(node, context) {
  const { blocks, recordBlockKind, nextBlockId, positions } = context;
  const drawingBlock = vectorShapeNodeToDrawingBlock(node, nextBlockId, positions);
  if (drawingBlock) {
    blocks.push(drawingBlock);
    recordBlockKind(drawingBlock.kind);
  }
}
function handleShapeGroupNode(node, context) {
  const { blocks, recordBlockKind, nextBlockId, positions } = context;
  const drawingBlock = shapeGroupNodeToDrawingBlock(node, nextBlockId, positions);
  if (drawingBlock) {
    blocks.push(drawingBlock);
    recordBlockKind(drawingBlock.kind);
  }
}
function handleShapeContainerNode(node, context) {
  const { blocks, recordBlockKind, nextBlockId, positions } = context;
  const drawingBlock = shapeContainerNodeToDrawingBlock(node, nextBlockId, positions);
  if (drawingBlock) {
    blocks.push(drawingBlock);
    recordBlockKind(drawingBlock.kind);
  }
}
function handleShapeTextboxNode(node, context) {
  const { blocks, recordBlockKind, nextBlockId, positions } = context;
  const drawingBlock = shapeTextboxNodeToDrawingBlock(node, nextBlockId, positions);
  if (drawingBlock) {
    blocks.push(drawingBlock);
    recordBlockKind(drawingBlock.kind);
  }
}
const getAttrs = (node) => {
  return isPlainObject$3(node.attrs) ? { ...node.attrs } : {};
};
const parseFullWidth = (value) => {
  if (typeof value === "string") {
    const trimmed = value.trim();
    if (trimmed.endsWith("%")) {
      return { width: trimmed === "100%" ? 1 : null, isFullWidth: trimmed === "100%" };
    }
    return { width: pickNumber(trimmed) ?? null, isFullWidth: false };
  }
  return { width: pickNumber(value) ?? null, isFullWidth: false };
};
function contentBlockNodeToDrawingBlock(node, nextBlockId, positions) {
  const rawAttrs = getAttrs(node);
  const indentLeft = pickNumber(rawAttrs.hrIndentLeft);
  const indentRight = pickNumber(rawAttrs.hrIndentRight);
  if (rawAttrs.horizontalRule !== true) {
    return null;
  }
  const size2 = isPlainObject$3(rawAttrs.size) ? rawAttrs.size : void 0;
  const { width, isFullWidth } = parseFullWidth(size2?.width);
  const height = pickNumber(size2?.height);
  if (!height || height <= 0) {
    return null;
  }
  if (!isFullWidth && (!width || width <= 0)) {
    return null;
  }
  if (isFullWidth) {
    rawAttrs.isFullWidth = true;
  }
  if (indentLeft != null || indentRight != null) {
    rawAttrs.hrIndentLeft = indentLeft;
    rawAttrs.hrIndentRight = indentRight;
  }
  if (typeof rawAttrs.background === "string" && rawAttrs.background.trim()) {
    rawAttrs.fillColor = rawAttrs.background;
  }
  const geometry = {
    width: isFullWidth ? 1 : width ?? 1,
    height,
    rotation: 0,
    flipH: false,
    flipV: false
  };
  return buildDrawingBlock(rawAttrs, nextBlockId, positions, node, geometry, "vectorShape", {
    strokeColor: null
  });
}
const DEFAULT_IMAGE_DIMENSION_PX = 100;
function isInlineImage(node) {
  const attrs = node.attrs ?? {};
  const wrap = attrs.wrap;
  const rawWrapType = wrap?.type;
  if (rawWrapType === "Inline") {
    return true;
  }
  if (rawWrapType && rawWrapType !== "Inline") {
    return false;
  }
  if (attrs.inline === true) {
    return true;
  }
  if (attrs.display === "inline") {
    return true;
  }
  return false;
}
const isNodeHidden = (node) => {
  const attrs = node.attrs ?? {};
  if (attrs.hidden === true) return true;
  return typeof attrs.visibility === "string" && attrs.visibility.toLowerCase() === "hidden";
};
function imageNodeToRun(node, positions, activeSdt) {
  if (isNodeHidden(node)) {
    return null;
  }
  const attrs = node.attrs ?? {};
  const src = typeof attrs.src === "string" ? attrs.src : "";
  if (!src) {
    return null;
  }
  const size2 = attrs.size ?? {};
  const width = typeof size2.width === "number" && Number.isFinite(size2.width) && size2.width > 0 ? size2.width : DEFAULT_IMAGE_DIMENSION_PX;
  const height = typeof size2.height === "number" && Number.isFinite(size2.height) && size2.height > 0 ? size2.height : DEFAULT_IMAGE_DIMENSION_PX;
  const wrap = isPlainObject$3(attrs.wrap) ? attrs.wrap : {};
  const wrapAttrs = isPlainObject$3(wrap.attrs) ? wrap.attrs : {};
  const run = {
    kind: "image",
    src,
    width,
    height
  };
  if (typeof attrs.alt === "string") run.alt = attrs.alt;
  if (typeof attrs.title === "string") run.title = attrs.title;
  const distTop = pickNumber(wrapAttrs.distTop ?? wrapAttrs.distT);
  if (distTop != null) run.distTop = distTop;
  const distBottom = pickNumber(wrapAttrs.distBottom ?? wrapAttrs.distB);
  if (distBottom != null) run.distBottom = distBottom;
  const distLeft = pickNumber(wrapAttrs.distLeft ?? wrapAttrs.distL);
  if (distLeft != null) run.distLeft = distLeft;
  const distRight = pickNumber(wrapAttrs.distRight ?? wrapAttrs.distR);
  if (distRight != null) run.distRight = distRight;
  run.verticalAlign = "bottom";
  const pos = positions.get(node);
  if (pos) {
    run.pmStart = pos.start;
    run.pmEnd = pos.end;
  }
  if (activeSdt) {
    run.sdt = activeSdt;
  }
  return run;
}
function fieldAnnotationNodeToRun(node, positions, fieldMetadata) {
  const attrs = node.attrs ?? {};
  const rawVariant = attrs.type ?? fieldMetadata?.variant ?? "text";
  const validVariants = ["text", "image", "signature", "checkbox", "html", "link"];
  const variant = validVariants.includes(rawVariant) ? rawVariant : "text";
  const displayLabel = (typeof attrs.displayLabel === "string" ? attrs.displayLabel : void 0) || (typeof attrs.defaultDisplayLabel === "string" ? attrs.defaultDisplayLabel : void 0) || (typeof fieldMetadata?.displayLabel === "string" ? fieldMetadata.displayLabel : void 0) || (typeof fieldMetadata?.defaultDisplayLabel === "string" ? fieldMetadata.defaultDisplayLabel : void 0) || (typeof attrs.alias === "string" ? attrs.alias : void 0) || (typeof fieldMetadata?.alias === "string" ? fieldMetadata.alias : void 0) || "";
  const run = {
    kind: "fieldAnnotation",
    variant,
    displayLabel
  };
  const fieldId = typeof attrs.fieldId === "string" ? attrs.fieldId : fieldMetadata?.fieldId;
  if (fieldId) run.fieldId = fieldId;
  const fieldType = typeof attrs.fieldType === "string" ? attrs.fieldType : fieldMetadata?.fieldType;
  if (fieldType) run.fieldType = fieldType;
  const fieldColor = typeof attrs.fieldColor === "string" ? attrs.fieldColor : fieldMetadata?.fieldColor;
  if (fieldColor) run.fieldColor = fieldColor;
  const borderColor = typeof attrs.borderColor === "string" ? attrs.borderColor : fieldMetadata?.borderColor;
  if (borderColor) run.borderColor = borderColor;
  const highlighted = attrs.highlighted ?? fieldMetadata?.highlighted;
  if (highlighted === false) run.highlighted = false;
  if (attrs.hidden === true || fieldMetadata?.hidden === true) run.hidden = true;
  const visibility = attrs.visibility ?? fieldMetadata?.visibility;
  if (visibility === "hidden") run.visibility = "hidden";
  const imageSrc = typeof attrs.imageSrc === "string" ? attrs.imageSrc : fieldMetadata?.imageSrc;
  if (imageSrc) run.imageSrc = imageSrc;
  const linkUrl = typeof attrs.linkUrl === "string" ? attrs.linkUrl : fieldMetadata?.linkUrl;
  if (linkUrl) run.linkUrl = linkUrl;
  const rawHtml = attrs.rawHtml ?? fieldMetadata?.rawHtml;
  if (typeof rawHtml === "string") run.rawHtml = rawHtml;
  const size2 = attrs.size ?? fieldMetadata?.size;
  if (size2 && (typeof size2.width === "number" || typeof size2.height === "number")) {
    run.size = {
      width: typeof size2.width === "number" ? size2.width : void 0,
      height: typeof size2.height === "number" ? size2.height : void 0
    };
  }
  const fontFamily2 = attrs.fontFamily ?? fieldMetadata?.fontFamily;
  if (typeof fontFamily2 === "string") run.fontFamily = fontFamily2;
  const fontSize2 = attrs.fontSize ?? fieldMetadata?.fontSize;
  if (typeof fontSize2 === "string" || typeof fontSize2 === "number") run.fontSize = fontSize2;
  const textColor = attrs.textColor ?? fieldMetadata?.textColor;
  if (typeof textColor === "string") run.textColor = textColor;
  const textHighlight = attrs.textHighlight ?? fieldMetadata?.textHighlight;
  if (typeof textHighlight === "string") run.textHighlight = textHighlight;
  const formatting = fieldMetadata?.formatting;
  if (attrs.bold === true) run.bold = true;
  else if (attrs.bold !== false && formatting?.bold === true) run.bold = true;
  if (attrs.italic === true) run.italic = true;
  else if (attrs.italic !== false && formatting?.italic === true) run.italic = true;
  if (attrs.underline === true) run.underline = true;
  else if (attrs.underline !== false && formatting?.underline === true) run.underline = true;
  const pos = positions.get(node);
  if (pos) {
    run.pmStart = pos.start;
    run.pmEnd = pos.end;
  }
  if (fieldMetadata) {
    run.sdt = fieldMetadata;
  }
  return run;
}
const isTextRun$3 = (run) => {
  const kind = run.kind;
  return (kind === void 0 || kind === "text") && "text" in run;
};
const dataAttrsCompatible = (a, b2) => {
  const aAttrs = a.dataAttrs;
  const bAttrs = b2.dataAttrs;
  if (!aAttrs && !bAttrs) return true;
  if (!aAttrs || !bAttrs) return false;
  const aKeys = Object.keys(aAttrs).sort();
  const bKeys = Object.keys(bAttrs).sort();
  if (aKeys.length !== bKeys.length) return false;
  for (let i = 0; i < aKeys.length; i++) {
    const key2 = aKeys[i];
    if (key2 !== bKeys[i] || aAttrs[key2] !== bAttrs[key2]) {
      return false;
    }
  }
  return true;
};
const commentsCompatible = (a, b2) => {
  const aComments = a.comments ?? [];
  const bComments = b2.comments ?? [];
  if (aComments.length === 0 && bComments.length === 0) return true;
  if (aComments.length !== bComments.length) return false;
  const normalize2 = (c2) => `${c2.commentId ?? ""}::${c2.importedId ?? ""}::${c2.internal ? "1" : "0"}`;
  const aKeys = aComments.map(normalize2).sort();
  const bKeys = bComments.map(normalize2).sort();
  for (let i = 0; i < aKeys.length; i++) {
    if (aKeys[i] !== bKeys[i]) return false;
  }
  return true;
};
function mergeAdjacentRuns(runs) {
  if (runs.length <= 1) return runs;
  const merged = [];
  let current = runs[0];
  for (let i = 1; i < runs.length; i++) {
    const next = runs[i];
    const canMerge = isTextRun$3(current) && isTextRun$3(next) && !current.token && !next.token && current.pmStart != null && current.pmEnd != null && next.pmStart != null && next.pmEnd != null && current.pmEnd === next.pmStart && current.fontFamily === next.fontFamily && current.fontSize === next.fontSize && current.bold === next.bold && current.italic === next.italic && current.underline === next.underline && current.strike === next.strike && current.color === next.color && current.highlight === next.highlight && (current.letterSpacing ?? 0) === (next.letterSpacing ?? 0) && trackedChangesCompatible(current, next) && dataAttrsCompatible(current, next) && commentsCompatible(current, next);
    if (canMerge) {
      const currText = current.text ?? "";
      const nextText = next.text ?? "";
      current = {
        ...current,
        text: currText + nextText,
        pmEnd: next.pmEnd
      };
    } else {
      merged.push(current);
      current = next;
    }
  }
  merged.push(current);
  return merged;
}
const applyInlineRunProperties = (run, runProperties, converterContext) => {
  if (!runProperties) {
    return run;
  }
  const runAttrs = computeRunAttrs(runProperties, converterContext);
  return { ...run, ...runAttrs };
};
function extractDefaultFontProperties(converterContext, paragraphProperties) {
  const defaultRunAttrs = computeRunAttrs(
    superEditor_converter.resolveRunProperties(
      converterContext,
      paragraphProperties.runProperties,
      paragraphProperties,
      converterContext.tableInfo,
      false,
      false
    ),
    converterContext
  );
  return {
    defaultFont: defaultRunAttrs.fontFamily,
    defaultSize: defaultRunAttrs.fontSize
  };
}
function paragraphToFlowBlocks({
  para,
  nextBlockId,
  positions,
  trackedChangesConfig,
  bookmarks,
  hyperlinkConfig = DEFAULT_HYPERLINK_CONFIG$1,
  themeColors,
  converters: converters2,
  converterContext,
  enableComments = true
}) {
  const paragraphProps = typeof para.attrs?.paragraphProperties === "object" && para.attrs.paragraphProperties !== null ? para.attrs.paragraphProperties : {};
  const baseBlockId = nextBlockId("paragraph");
  const { paragraphAttrs, resolvedParagraphProperties } = computeParagraphAttrs(para, converterContext);
  const blocks = [];
  const paraAttrs = para.attrs ?? {};
  const rawParagraphProps = typeof paraAttrs.paragraphProperties === "object" && paraAttrs.paragraphProperties !== null ? paraAttrs.paragraphProperties : void 0;
  const hasSectPr2 = Boolean(rawParagraphProps?.sectPr);
  const isSectPrMarker = hasSectPr2 || paraAttrs.pageBreakSource === "sectPr";
  const { defaultFont, defaultSize } = extractDefaultFontProperties(converterContext, resolvedParagraphProperties);
  if (paragraphAttrs.pageBreakBefore) {
    blocks.push({
      kind: "pageBreak",
      id: nextBlockId("pageBreak"),
      attrs: { source: "pageBreakBefore" }
    });
  }
  if (!para.content || para.content.length === 0) {
    if (paragraphProps.runProperties?.vanish) {
      return blocks;
    }
    const paraPos = positions.get(para);
    const emptyRun = {
      text: "",
      fontFamily: defaultFont,
      fontSize: defaultSize
    };
    if (paraPos) {
      emptyRun.pmStart = paraPos.start + 1;
      emptyRun.pmEnd = paraPos.start + 1;
    }
    let emptyParagraphAttrs = deepClone(paragraphAttrs);
    if (isSectPrMarker) {
      if (emptyParagraphAttrs) {
        emptyParagraphAttrs.sectPrMarker = true;
      } else {
        emptyParagraphAttrs = { sectPrMarker: true };
      }
    }
    blocks.push({
      kind: "paragraph",
      id: baseBlockId,
      runs: [emptyRun],
      attrs: deepClone(paragraphAttrs)
    });
    return blocks;
  }
  let currentRuns = [];
  let partIndex = 0;
  let tabOrdinal = 0;
  let suppressedByVanish = false;
  const toSuperscriptDigits2 = (value) => {
    const map3 = {
      "0": "",
      "1": "",
      "2": "",
      "3": "",
      "4": "",
      "5": "",
      "6": "",
      "7": "",
      "8": "",
      "9": ""
    };
    return String(value ?? "").split("").map((ch) => map3[ch] ?? ch).join("");
  };
  const resolveFootnoteDisplayNumber2 = (id) => {
    const key2 = id == null ? null : String(id);
    if (!key2) return null;
    const mapping = converterContext?.footnoteNumberById;
    const mapped = mapping && typeof mapping === "object" ? mapping[key2] : void 0;
    return typeof mapped === "number" && Number.isFinite(mapped) && mapped > 0 ? mapped : null;
  };
  const nextId = () => partIndex === 0 ? baseBlockId : `${baseBlockId}-${partIndex}`;
  const attachAnchorParagraphId = (block, anchorParagraphId) => {
    const applicableKinds = /* @__PURE__ */ new Set(["drawing", "image", "table"]);
    if (!applicableKinds.has(block.kind)) {
      return block;
    }
    const blockWithAttrs = block;
    return {
      ...blockWithAttrs,
      attrs: {
        ...blockWithAttrs.attrs ?? {},
        anchorParagraphId
      }
    };
  };
  const flushParagraph = () => {
    if (currentRuns.length === 0) {
      return;
    }
    const runs = currentRuns;
    currentRuns = [];
    blocks.push({
      kind: "paragraph",
      id: nextId(),
      runs,
      attrs: deepClone(paragraphAttrs)
    });
    partIndex += 1;
  };
  const visitNode = (node, inheritedMarks = [], activeSdt, activeRunProperties, activeHidden = false) => {
    if (node.type === "footnoteReference") {
      const mergedMarks = [...node.marks ?? [], ...inheritedMarks ?? []];
      const refPos = positions.get(node);
      const id = node.attrs?.id;
      const displayId = resolveFootnoteDisplayNumber2(id) ?? id ?? "*";
      const displayText = toSuperscriptDigits2(displayId);
      let run = textNodeToRun(
        { type: "text", text: displayText },
        positions,
        defaultFont,
        defaultSize,
        [],
        // marks applied after linked styles/base defaults
        activeSdt,
        hyperlinkConfig,
        themeColors
      );
      applyMarksToRun(run, mergedMarks, hyperlinkConfig, themeColors);
      run = applyInlineRunProperties(run, activeRunProperties, converterContext);
      if (refPos) {
        run.pmStart = refPos.start;
        run.pmEnd = refPos.end;
      }
      currentRuns.push(run);
      return;
    }
    if (activeHidden && node.type !== "run") {
      suppressedByVanish = true;
      return;
    }
    if (node.type === "text" && node.text) {
      let run = textNodeToRun(
        node,
        positions,
        defaultFont,
        defaultSize,
        [],
        // Empty marks - will be applied after linked styles
        activeSdt,
        hyperlinkConfig,
        themeColors
      );
      applyMarksToRun(
        run,
        [...node.marks ?? [], ...inheritedMarks ?? []],
        hyperlinkConfig,
        themeColors,
        converterContext?.backgroundColor,
        enableComments
      );
      run = applyInlineRunProperties(run, activeRunProperties, converterContext);
      currentRuns.push(run);
      return;
    }
    if (node.type === "run" && Array.isArray(node.content)) {
      const mergedMarks = [...node.marks ?? [], ...inheritedMarks ?? []];
      const runProperties = node.attrs?.runProperties ?? {};
      const runVanish = runProperties?.vanish;
      const nextHidden = runVanish === void 0 ? activeHidden : runVanish;
      if (nextHidden) {
        suppressedByVanish = true;
        return;
      }
      const resolvedRunProperties = superEditor_converter.resolveRunProperties(
        converterContext,
        runProperties,
        resolvedParagraphProperties,
        converterContext.tableInfo,
        false,
        false
      );
      node.content.forEach((child) => visitNode(child, mergedMarks, activeSdt, resolvedRunProperties, nextHidden));
      return;
    }
    if (node.type === "structuredContent" && Array.isArray(node.content)) {
      const inlineMetadata = resolveNodeSdtMetadata(node, "structuredContent");
      const nextSdt = inlineMetadata ?? activeSdt;
      node.content.forEach((child) => visitNode(child, inheritedMarks, nextSdt, activeRunProperties, activeHidden));
      return;
    }
    if (node.type === "fieldAnnotation") {
      if (activeHidden) {
        suppressedByVanish = true;
        return;
      }
      const fieldMetadata = resolveNodeSdtMetadata(node, "fieldAnnotation");
      let contentText;
      if (Array.isArray(node.content) && node.content.length > 0) {
        const extractText = (n) => {
          if (n.type === "text" && typeof n.text === "string") return n.text;
          if (Array.isArray(n.content)) {
            return n.content.map(extractText).join("");
          }
          return "";
        };
        contentText = node.content.map(extractText).join("");
      }
      const nodeForRun = contentText && contentText.length > 0 ? { ...node, attrs: { ...node.attrs ?? {}, displayLabel: contentText } } : node;
      const run = fieldAnnotationNodeToRun(nodeForRun, positions, fieldMetadata);
      currentRuns.push(run);
      return;
    }
    if (node.type === "pageReference") {
      if (activeHidden) {
        suppressedByVanish = true;
        return;
      }
      const instruction = getNodeInstruction(node) || "";
      const nodeAttrs = typeof node.attrs === "object" && node.attrs !== null ? node.attrs : {};
      const refMarks = Array.isArray(nodeAttrs.marksAsAttrs) ? nodeAttrs.marksAsAttrs : [];
      const mergedMarks = [...refMarks, ...inheritedMarks ?? []];
      const bookmarkMatch = instruction.match(/PAGEREF\s+"?([^"\s\\]+)"?/i);
      const bookmarkId = bookmarkMatch ? bookmarkMatch[1] : "";
      let runProperties = {};
      if (bookmarkId) {
        let fallbackText = "??";
        if (Array.isArray(node.content) && node.content.length > 0) {
          const extractText = (n) => {
            if (n.type === "run") {
              runProperties = n.attrs?.runProperties ?? {};
            }
            if (n.type === "text" && n.text) return n.text;
            if (Array.isArray(n.content)) {
              return n.content.map(extractText).join("");
            }
            return "";
          };
          fallbackText = node.content.map(extractText).join("").trim() || "??";
        }
        const pageRefPos = positions.get(node);
        let tokenRun = textNodeToRun(
          { type: "text", text: fallbackText },
          positions,
          defaultFont,
          defaultSize,
          [],
          // Empty marks - will be applied after linked styles
          activeSdt,
          hyperlinkConfig,
          themeColors
        );
        const resolvedRunProperties = superEditor_converter.resolveRunProperties(
          converterContext,
          runProperties,
          resolvedParagraphProperties,
          null,
          false,
          false
        );
        applyMarksToRun(
          tokenRun,
          mergedMarks,
          hyperlinkConfig,
          themeColors,
          converterContext?.backgroundColor,
          enableComments
        );
        tokenRun = applyInlineRunProperties(tokenRun, resolvedRunProperties, converterContext);
        if (pageRefPos) {
          tokenRun.pmStart = pageRefPos.start;
          tokenRun.pmEnd = pageRefPos.end;
        }
        tokenRun.token = "pageReference";
        tokenRun.pageRefMetadata = {
          bookmarkId,
          instruction
        };
        if (activeSdt) {
          tokenRun.sdt = activeSdt;
        }
        currentRuns.push(tokenRun);
      } else if (Array.isArray(node.content)) {
        node.content.forEach((child) => visitNode(child, mergedMarks, activeSdt, activeRunProperties));
      }
      return;
    }
    if (node.type === "bookmarkStart") {
      const nodeAttrs = typeof node.attrs === "object" && node.attrs !== null ? node.attrs : {};
      const bookmarkName = typeof nodeAttrs.name === "string" ? nodeAttrs.name : void 0;
      if (bookmarkName && bookmarks) {
        const nodePos = positions.get(node);
        if (nodePos) {
          bookmarks.set(bookmarkName, nodePos.start);
        }
      }
      if (Array.isArray(node.content)) {
        node.content.forEach((child) => visitNode(child, inheritedMarks, activeSdt, activeRunProperties));
      }
      return;
    }
    if (node.type === "tab") {
      const tabRun = tabNodeToRun(node, positions, tabOrdinal, paragraphAttrs, inheritedMarks);
      tabOrdinal += 1;
      if (tabRun) {
        currentRuns.push(tabRun);
      }
      return;
    }
    if (TOKEN_INLINE_TYPES.has(node.type)) {
      const tokenKind = TOKEN_INLINE_TYPES.get(node.type);
      if (tokenKind) {
        const marksAsAttrs = Array.isArray(node.attrs?.marksAsAttrs) ? node.attrs.marksAsAttrs : [];
        const nodeMarks = node.marks ?? [];
        const effectiveMarks = nodeMarks.length > 0 ? nodeMarks : marksAsAttrs;
        const mergedMarks = [...effectiveMarks, ...inheritedMarks ?? []];
        let tokenRun = tokenNodeToRun(
          node,
          positions,
          defaultFont,
          defaultSize,
          inheritedMarks,
          tokenKind,
          hyperlinkConfig,
          themeColors
        );
        if (activeSdt) {
          tokenRun.sdt = activeSdt;
        }
        if (mergedMarks.length > 0) {
          applyMarksToRun(
            tokenRun,
            mergedMarks,
            hyperlinkConfig,
            themeColors,
            converterContext?.backgroundColor,
            enableComments
          );
        }
        applyInlineRunProperties(tokenRun, activeRunProperties, converterContext);
        console.debug("[token-debug] paragraph-token-run", {
          token: tokenRun.token,
          fontFamily: tokenRun.fontFamily,
          fontSize: tokenRun.fontSize,
          inlineStyleId: paragraphProps.styleId || null,
          mergedMarksCount: mergedMarks.length
        });
        tokenRun = applyInlineRunProperties(tokenRun, activeRunProperties, converterContext);
        currentRuns.push(tokenRun);
      }
      return;
    }
    if (node.type === "image") {
      if (activeHidden) {
        suppressedByVanish = true;
        return;
      }
      if (isNodeHidden(node)) {
        return;
      }
      const isInline2 = isInlineImage(node);
      if (isInline2) {
        const imageRun = imageNodeToRun(node, positions, activeSdt);
        if (imageRun) {
          currentRuns.push(imageRun);
        }
        return;
      }
      const anchorParagraphId = nextId();
      flushParagraph();
      const mergedMarks = [...node.marks ?? [], ...inheritedMarks ?? []];
      const trackedMeta = trackedChangesConfig?.enabled ? collectTrackedChangeFromMarks(mergedMarks) : void 0;
      if (shouldHideTrackedNode(trackedMeta, trackedChangesConfig)) {
        return;
      }
      if (converters2?.imageNodeToBlock) {
        const imageBlock = converters2.imageNodeToBlock(node, nextBlockId, positions, trackedMeta, trackedChangesConfig);
        if (imageBlock && imageBlock.kind === "image") {
          annotateBlockWithTrackedChange(imageBlock, trackedMeta, trackedChangesConfig);
          blocks.push(attachAnchorParagraphId(imageBlock, anchorParagraphId));
        }
      }
      return;
    }
    if (node.type === "contentBlock") {
      if (activeHidden) {
        suppressedByVanish = true;
        return;
      }
      const attrs = node.attrs ?? {};
      if (attrs.horizontalRule === true) {
        const anchorParagraphId = nextId();
        flushParagraph();
        const indent = paragraphAttrs?.indent;
        const hrIndentLeft = typeof indent?.left === "number" ? indent.left : void 0;
        const hrIndentRight = typeof indent?.right === "number" ? indent.right : void 0;
        const hasIndent = typeof hrIndentLeft === "number" && hrIndentLeft !== 0 || typeof hrIndentRight === "number" && hrIndentRight !== 0;
        const hrNode = hasIndent ? { ...node, attrs: { ...attrs, hrIndentLeft, hrIndentRight } } : node;
        const convert = converters2?.contentBlockNodeToDrawingBlock ?? contentBlockNodeToDrawingBlock;
        const drawingBlock = convert(hrNode, nextBlockId, positions);
        if (drawingBlock) {
          blocks.push(attachAnchorParagraphId(drawingBlock, anchorParagraphId));
        }
      }
      return;
    }
    if (node.type === "vectorShape") {
      if (activeHidden) {
        suppressedByVanish = true;
        return;
      }
      if (isNodeHidden(node)) {
        return;
      }
      const anchorParagraphId = nextId();
      flushParagraph();
      if (converters2?.vectorShapeNodeToDrawingBlock) {
        const drawingBlock = converters2.vectorShapeNodeToDrawingBlock(node, nextBlockId, positions);
        if (drawingBlock) {
          blocks.push(attachAnchorParagraphId(drawingBlock, anchorParagraphId));
        }
      }
      return;
    }
    if (node.type === "shapeGroup") {
      if (activeHidden) {
        suppressedByVanish = true;
        return;
      }
      if (isNodeHidden(node)) {
        return;
      }
      const anchorParagraphId = nextId();
      flushParagraph();
      if (converters2?.shapeGroupNodeToDrawingBlock) {
        const drawingBlock = converters2.shapeGroupNodeToDrawingBlock(node, nextBlockId, positions);
        if (drawingBlock) {
          blocks.push(attachAnchorParagraphId(drawingBlock, anchorParagraphId));
        }
      }
      return;
    }
    if (node.type === "shapeContainer") {
      if (activeHidden) {
        suppressedByVanish = true;
        return;
      }
      if (isNodeHidden(node)) {
        return;
      }
      const anchorParagraphId = nextId();
      flushParagraph();
      if (converters2?.shapeContainerNodeToDrawingBlock) {
        const drawingBlock = converters2.shapeContainerNodeToDrawingBlock(node, nextBlockId, positions);
        if (drawingBlock) {
          blocks.push(attachAnchorParagraphId(drawingBlock, anchorParagraphId));
        }
      }
      return;
    }
    if (node.type === "shapeTextbox") {
      if (activeHidden) {
        suppressedByVanish = true;
        return;
      }
      if (isNodeHidden(node)) {
        return;
      }
      const anchorParagraphId = nextId();
      flushParagraph();
      if (converters2?.shapeTextboxNodeToDrawingBlock) {
        const drawingBlock = converters2.shapeTextboxNodeToDrawingBlock(node, nextBlockId, positions);
        if (drawingBlock) {
          blocks.push(attachAnchorParagraphId(drawingBlock, anchorParagraphId));
        }
      }
      return;
    }
    if (node.type === "table") {
      if (activeHidden) {
        suppressedByVanish = true;
        return;
      }
      const anchorParagraphId = nextId();
      flushParagraph();
      if (converters2?.tableNodeToBlock) {
        const tableBlock = converters2.tableNodeToBlock({
          node,
          nextBlockId,
          positions,
          trackedChangesConfig,
          bookmarks,
          hyperlinkConfig,
          themeColors,
          converterContext,
          converters: converters2,
          enableComments
        });
        if (tableBlock) {
          blocks.push(attachAnchorParagraphId(tableBlock, anchorParagraphId));
        }
      }
      return;
    }
    if (node.type === "hardBreak" || node.type === "lineBreak") {
      if (activeHidden) {
        suppressedByVanish = true;
        return;
      }
      const attrs = node.attrs ?? {};
      const breakType = attrs.pageBreakType ?? attrs.lineBreakType ?? "line";
      if (breakType === "page") {
        flushParagraph();
        blocks.push({
          kind: "pageBreak",
          id: nextId(),
          attrs: node.attrs || {}
        });
        return;
      }
      if (breakType === "column") {
        flushParagraph();
        blocks.push({
          kind: "columnBreak",
          id: nextId(),
          attrs: node.attrs || {}
        });
        return;
      }
      const lineBreakRun = { kind: "lineBreak", attrs: {} };
      const lbAttrs = {};
      if (attrs.lineBreakType) lbAttrs.lineBreakType = String(attrs.lineBreakType);
      if (attrs.clear) lbAttrs.clear = String(attrs.clear);
      if (Object.keys(lbAttrs).length > 0) {
        lineBreakRun.attrs = lbAttrs;
      } else {
        delete lineBreakRun.attrs;
      }
      const pos = positions.get(node);
      if (pos) {
        lineBreakRun.pmStart = pos.start;
        lineBreakRun.pmEnd = pos.end;
      }
      if (activeSdt) {
        lineBreakRun.sdt = activeSdt;
      }
      currentRuns.push(lineBreakRun);
      return;
    }
  };
  para.content.forEach((child) => {
    visitNode(child, [], void 0, void 0);
  });
  flushParagraph();
  const hasParagraphBlock = blocks.some((block) => block.kind === "paragraph");
  if (!hasParagraphBlock && !suppressedByVanish && !paragraphProps.runProperties?.vanish) {
    blocks.push({
      kind: "paragraph",
      id: baseBlockId,
      runs: [
        {
          text: "",
          fontFamily: defaultFont,
          fontSize: defaultSize
        }
      ],
      attrs: deepClone(paragraphAttrs)
    });
  }
  blocks.forEach((block) => {
    if (block.kind === "paragraph" && block.runs.length > 1) {
      block.runs = mergeAdjacentRuns(block.runs);
    }
  });
  if (!trackedChangesConfig) {
    return blocks;
  }
  const processedBlocks = [];
  blocks.forEach((block) => {
    if (block.kind !== "paragraph") {
      processedBlocks.push(block);
      return;
    }
    const filteredRuns = applyTrackedChangesModeToRuns(
      block.runs,
      trackedChangesConfig,
      hyperlinkConfig,
      applyMarksToRun,
      themeColors,
      enableComments
    );
    if (trackedChangesConfig.enabled && filteredRuns.length === 0) {
      return;
    }
    block.runs = filteredRuns;
    block.attrs = {
      ...block.attrs ?? {},
      trackedChangesMode: trackedChangesConfig.mode,
      trackedChangesEnabled: trackedChangesConfig.enabled
    };
    processedBlocks.push(block);
  });
  return processedBlocks;
}
function handleParagraphNode(node, context) {
  const {
    blocks,
    recordBlockKind,
    nextBlockId,
    positions,
    trackedChangesConfig,
    bookmarks,
    hyperlinkConfig,
    sectionState,
    converters: converters2,
    converterContext,
    themeColors,
    enableComments
  } = context;
  const { ranges: sectionRanges, currentSectionIndex, currentParagraphIndex } = sectionState;
  if (sectionRanges.length > 0) {
    const nextSection = sectionRanges[currentSectionIndex + 1];
    if (nextSection && currentParagraphIndex === nextSection.startParagraphIndex) {
      const currentSection = sectionRanges[currentSectionIndex];
      const requiresPageBoundary = shouldRequirePageBoundary(currentSection, nextSection) || hasIntrinsicBoundarySignals();
      const extraAttrs = requiresPageBoundary ? { requirePageBoundary: true } : void 0;
      const sectionBreak = createSectionBreakBlock(nextSection, nextBlockId, extraAttrs);
      blocks.push(sectionBreak);
      recordBlockKind(sectionBreak.kind);
      sectionState.currentSectionIndex++;
    }
  }
  const paragraphToFlowBlocks2 = converters2.paragraphToFlowBlocks;
  const paragraphBlocks = paragraphToFlowBlocks2({
    para: node,
    nextBlockId,
    positions,
    trackedChangesConfig,
    bookmarks,
    hyperlinkConfig,
    themeColors,
    converterContext,
    converters: converters2,
    enableComments
  });
  paragraphBlocks.forEach((block) => {
    blocks.push(block);
    recordBlockKind(block.kind);
  });
  sectionState.currentParagraphIndex++;
}
const WRAP_TYPES = /* @__PURE__ */ new Set(["None", "Square", "Tight", "Through", "TopAndBottom", "Inline"]);
const WRAP_TEXT_VALUES = /* @__PURE__ */ new Set(["bothSides", "left", "right", "largest"]);
const H_RELATIVE_VALUES = /* @__PURE__ */ new Set(["column", "page", "margin"]);
const V_RELATIVE_VALUES = /* @__PURE__ */ new Set(["paragraph", "page", "margin"]);
const H_ALIGN_VALUES = /* @__PURE__ */ new Set(["left", "center", "right"]);
const V_ALIGN_VALUES = /* @__PURE__ */ new Set(["top", "center", "bottom"]);
const isPlainObject$1 = (value) => typeof value === "object" && value !== null && !Array.isArray(value);
const isAllowedObjectFit = (value) => {
  return value === "contain" || value === "cover" || value === "fill" || value === "scale-down";
};
const isHiddenDrawing = (attrs) => {
  if (toBoolean(attrs.hidden) === true) return true;
  return typeof attrs.visibility === "string" && attrs.visibility.toLowerCase() === "hidden";
};
function toBoxSpacing(spacing) {
  if (!spacing) {
    return void 0;
  }
  const result = {};
  ["top", "right", "bottom", "left"].forEach((side) => {
    const value = spacing[side];
    if (isFiniteNumber(value)) {
      result[side] = Number(value);
    }
  });
  return Object.keys(result).length > 0 ? result : void 0;
}
const normalizeWrapType = (value) => {
  if (typeof value !== "string") return void 0;
  return WRAP_TYPES.has(value) ? value : void 0;
};
const normalizeWrapText = (value) => {
  if (typeof value !== "string") return void 0;
  return WRAP_TEXT_VALUES.has(value) ? value : void 0;
};
const normalizePolygon = (value) => {
  if (!Array.isArray(value)) return void 0;
  const polygon = [];
  value.forEach((point) => {
    if (!Array.isArray(point) || point.length < 2) return;
    const x = pickNumber(point[0]);
    const y2 = pickNumber(point[1]);
    if (x == null || y2 == null) return;
    polygon.push([x, y2]);
  });
  return polygon.length > 0 ? polygon : void 0;
};
const toBoolean = (value) => {
  if (value === void 0 || value === null) return void 0;
  if (typeof value === "boolean") return value;
  if (typeof value === "number") {
    if (value === 1) return true;
    if (value === 0) return false;
  }
  if (typeof value === "string") {
    const normalized = value.trim().toLowerCase();
    if (normalized === "1" || normalized === "true") return true;
    if (normalized === "0" || normalized === "false") return false;
  }
  return void 0;
};
const normalizeWrap$1 = (value) => {
  if (!isPlainObject$1(value)) {
    return void 0;
  }
  const type = normalizeWrapType(value.type);
  if (!type) {
    return void 0;
  }
  const wrap = { type };
  const attrs = isPlainObject$1(value.attrs) ? value.attrs : {};
  const wrapText = normalizeWrapText(attrs.wrapText);
  if (wrapText) {
    wrap.wrapText = wrapText;
  }
  const distTop = pickNumber(attrs.distTop ?? attrs.distT);
  if (distTop != null) wrap.distTop = distTop;
  const distBottom = pickNumber(attrs.distBottom ?? attrs.distB);
  if (distBottom != null) wrap.distBottom = distBottom;
  const distLeft = pickNumber(attrs.distLeft ?? attrs.distL);
  if (distLeft != null) wrap.distLeft = distLeft;
  const distRight = pickNumber(attrs.distRight ?? attrs.distR);
  if (distRight != null) wrap.distRight = distRight;
  const polygon = normalizePolygon(attrs.polygon);
  if (polygon) {
    wrap.polygon = polygon;
  }
  const behindDoc = toBoolean(attrs.behindDoc);
  if (behindDoc != null) {
    wrap.behindDoc = behindDoc;
  }
  return wrap;
};
const normalizeAnchorRelative = (value, allowed) => {
  if (typeof value !== "string") return void 0;
  return allowed.has(value) ? value : void 0;
};
const normalizeAnchorAlign = (value, allowed) => {
  if (typeof value !== "string") return void 0;
  return allowed.has(value) ? value : void 0;
};
const normalizeAnchorData = (value, attrs, wrapBehindDoc) => {
  const raw = isPlainObject$1(value) ? value : void 0;
  const marginOffset = isPlainObject$1(attrs.marginOffset) ? attrs.marginOffset : void 0;
  const simplePos = isPlainObject$1(attrs.simplePos) ? attrs.simplePos : void 0;
  const originalAttrs = isPlainObject$1(attrs.originalAttributes) ? attrs.originalAttributes : void 0;
  const isAnchored = attrs.isAnchor === true || Boolean(raw);
  const anchor = {};
  if (isAnchored) {
    anchor.isAnchored = true;
  }
  const hRelative = normalizeAnchorRelative(raw?.hRelativeFrom, H_RELATIVE_VALUES);
  if (hRelative) anchor.hRelativeFrom = hRelative;
  const vRelative = normalizeAnchorRelative(raw?.vRelativeFrom, V_RELATIVE_VALUES);
  if (vRelative) anchor.vRelativeFrom = vRelative;
  const alignH = normalizeAnchorAlign(raw?.alignH, H_ALIGN_VALUES);
  if (alignH) anchor.alignH = alignH;
  const alignV = normalizeAnchorAlign(raw?.alignV, V_ALIGN_VALUES);
  if (alignV) anchor.alignV = alignV;
  const offsetH = pickNumber(marginOffset?.horizontal ?? marginOffset?.left ?? raw?.offsetH ?? simplePos?.x);
  if (offsetH != null) anchor.offsetH = offsetH;
  const offsetV = pickNumber(marginOffset?.top ?? marginOffset?.vertical ?? raw?.offsetV ?? simplePos?.y);
  if (offsetV != null) anchor.offsetV = offsetV;
  const behindDoc = toBoolean(raw?.behindDoc ?? wrapBehindDoc ?? originalAttrs?.behindDoc);
  if (behindDoc != null) anchor.behindDoc = behindDoc;
  const hasData = anchor.isAnchored || anchor.hRelativeFrom != null || anchor.vRelativeFrom != null || anchor.alignH != null || anchor.alignV != null || anchor.offsetH != null || anchor.offsetV != null || anchor.behindDoc != null;
  return hasData ? anchor : void 0;
};
function imageNodeToBlock(node, nextBlockId, positions, _trackedMeta, _trackedChanges) {
  const attrs = node.attrs ?? {};
  if (isHiddenDrawing(attrs)) {
    return null;
  }
  if (!attrs.src || typeof attrs.src !== "string") {
    return null;
  }
  const pos = positions.get(node);
  const attrsWithPm = { ...attrs };
  if (pos) {
    attrsWithPm.pmStart = pos.start;
    attrsWithPm.pmEnd = pos.end;
  }
  const size2 = attrs.size ?? {};
  const width = typeof size2.width === "number" && Number.isFinite(size2.width) ? size2.width : void 0;
  const height = typeof size2.height === "number" && Number.isFinite(size2.height) ? size2.height : void 0;
  const explicitDisplay = typeof attrs.display === "string" ? attrs.display : void 0;
  const normalizedWrap = normalizeWrap$1(attrs.wrap);
  let anchor = normalizeAnchorData(attrs.anchorData, attrs, normalizedWrap?.behindDoc);
  if (!anchor && normalizedWrap) {
    anchor = { isAnchored: true };
    if (normalizedWrap.behindDoc != null) {
      anchor.behindDoc = normalizedWrap.behindDoc;
    }
  }
  const isInline2 = normalizedWrap?.type === "Inline" || typeof attrs.inline === "boolean" && attrs.inline;
  const display = explicitDisplay === "inline" || explicitDisplay === "block" ? explicitDisplay : isInline2 ? "inline" : "block";
  const explicitObjectFit = typeof attrs.objectFit === "string" ? attrs.objectFit : void 0;
  const shouldCover = attrs.shouldCover === true;
  const isAnchor = anchor?.isAnchored ?? (typeof attrs.isAnchor === "boolean" ? attrs.isAnchor : false);
  const objectFit = isAllowedObjectFit(explicitObjectFit) ? explicitObjectFit : shouldCover ? "cover" : display === "inline" ? "scale-down" : isAnchor ? "contain" : "contain";
  return {
    kind: "image",
    id: nextBlockId("image"),
    src: attrs.src,
    width,
    height,
    alt: typeof attrs.alt === "string" ? attrs.alt : void 0,
    title: typeof attrs.title === "string" ? attrs.title : void 0,
    objectFit,
    display,
    padding: toBoxSpacing(attrs.padding),
    margin: toBoxSpacing(attrs.marginOffset),
    anchor,
    wrap: normalizedWrap,
    attrs: attrsWithPm,
    // VML image adjustments for watermark effects
    gain: typeof attrs.gain === "string" || typeof attrs.gain === "number" ? attrs.gain : void 0,
    blacklevel: typeof attrs.blacklevel === "string" || typeof attrs.blacklevel === "number" ? attrs.blacklevel : void 0
  };
}
function handleImageNode(node, context) {
  const { blocks, recordBlockKind, nextBlockId, positions, trackedChangesConfig } = context;
  const trackedMeta = trackedChangesConfig.enabled ? collectTrackedChangeFromMarks(node.marks ?? []) : void 0;
  if (shouldHideTrackedNode(trackedMeta, trackedChangesConfig)) {
    return;
  }
  const imageBlock = imageNodeToBlock(node, nextBlockId, positions);
  if (imageBlock && imageBlock.kind === "image") {
    annotateBlockWithTrackedChange(imageBlock, trackedMeta, trackedChangesConfig);
    blocks.push(imageBlock);
    recordBlockKind(imageBlock.kind);
  }
}
const hasTableStyleContext = (context) => {
  return Boolean(context?.docx);
};
const hydrateTableStyleAttrs = (tableNode, context) => {
  const hydration = {};
  const tableProps = tableNode.attrs?.tableProperties ?? null;
  if (tableProps) {
    const padding = convertCellMarginsToPx(tableProps.cellMargins);
    if (padding) hydration.cellPadding = padding;
    if (tableProps.borders && typeof tableProps.borders === "object") {
      hydration.borders = clonePlainObject(tableProps.borders);
    }
    if (!hydration.justification && typeof tableProps.justification === "string") {
      hydration.justification = tableProps.justification;
    }
    const tableWidth = normalizeTableWidth(tableProps.tableWidth);
    if (tableWidth) {
      hydration.tableWidth = tableWidth;
    }
  }
  const styleId = typeof tableNode.attrs?.tableStyleId === "string" ? tableNode.attrs.tableStyleId : void 0;
  if (styleId && hasTableStyleContext(context)) {
    const referenced = superEditor_converter._getReferencedTableStyles(styleId, { docx: context.docx });
    if (referenced) {
      if (!hydration.borders && referenced.borders) {
        hydration.borders = clonePlainObject(referenced.borders);
      }
      if (!hydration.cellPadding && referenced.cellMargins) {
        const padding = convertCellMarginsToPx(referenced.cellMargins);
        if (padding) hydration.cellPadding = padding;
      }
      if (!hydration.justification && referenced.justification) {
        hydration.justification = referenced.justification;
      }
    }
    const paragraphProps = extractTableStyleParagraphProps(styleId, context.docx);
    if (paragraphProps) {
      hydration.paragraphProps = paragraphProps;
    }
  }
  if (Object.keys(hydration).length > 0) {
    return hydration;
  }
  return null;
};
const clonePlainObject = (value) => ({ ...value });
const convertCellMarginsToPx = (margins) => {
  if (!margins || typeof margins !== "object") return void 0;
  const spacing = {};
  const keyMap = {
    top: "top",
    bottom: "bottom",
    left: "left",
    right: "right",
    marginTop: "top",
    marginBottom: "bottom",
    marginLeft: "left",
    marginRight: "right"
  };
  Object.entries(margins).forEach(([key2, value]) => {
    const side = keyMap[key2];
    if (!side) return;
    const px = measurementToPx(value);
    if (px != null) spacing[side] = px;
  });
  return Object.keys(spacing).length ? spacing : void 0;
};
const measurementToPx = (value) => {
  if (typeof value === "number") return value;
  if (!value || typeof value !== "object") return void 0;
  const entry = value;
  if (typeof entry.value !== "number") return void 0;
  if (!entry.type || entry.type === "px" || entry.type === "pixel") return entry.value;
  if (entry.type === "dxa") return twipsToPx$2(entry.value);
  return void 0;
};
const normalizeTableWidth = (value) => {
  if (!value || typeof value !== "object") return void 0;
  const measurement = value;
  const raw = typeof measurement.width === "number" ? measurement.width : measurement.value;
  if (typeof raw !== "number") return void 0;
  if (!measurement.type || measurement.type === "px" || measurement.type === "pixel") {
    return { width: raw, type: measurement.type ?? "px" };
  }
  if (measurement.type === "dxa") {
    return { width: twipsToPx$2(raw), type: "px" };
  }
  return { width: raw, type: measurement.type };
};
const extractTableStyleParagraphProps = (styleId, docx) => {
  try {
    const stylesXml = docx["word/styles.xml"];
    if (!stylesXml?.elements?.[0]?.elements) return void 0;
    const styleElements = stylesXml.elements[0].elements.filter((el) => el.name === "w:style");
    const styleTag = styleElements.find((el) => el.attributes?.["w:styleId"] === styleId);
    if (!styleTag?.elements) {
      return void 0;
    }
    const pPr = styleTag.elements.find((el) => el.name === "w:pPr");
    if (!pPr?.elements) {
      return void 0;
    }
    const spacingEl = pPr.elements.find((el) => el.name === "w:spacing");
    if (!spacingEl?.attributes) {
      return void 0;
    }
    const attrs = spacingEl.attributes;
    const spacing = {};
    const before = parseIntSafe$1(attrs["w:before"]);
    const after = parseIntSafe$1(attrs["w:after"]);
    const line = parseIntSafe$1(attrs["w:line"]);
    const rawLineRule = attrs["w:lineRule"];
    const lineRule = rawLineRule === "auto" || rawLineRule === "exact" || rawLineRule === "atLeast" ? rawLineRule : void 0;
    if (before != null) spacing.before = twipsToPx$2(before);
    if (after != null) spacing.after = twipsToPx$2(after);
    if (line != null) {
      if (lineRule === "auto") {
        spacing.line = line / 240;
      } else {
        spacing.line = twipsToPx$2(line);
      }
    }
    if (lineRule) spacing.lineRule = lineRule;
    const result = Object.keys(spacing).length > 0 ? { spacing } : void 0;
    return result;
  } catch {
    return void 0;
  }
};
const parseIntSafe$1 = (value) => {
  if (value == null) return void 0;
  const num = typeof value === "number" ? value : parseInt(String(value), 10);
  return Number.isFinite(num) ? num : void 0;
};
const isTableRowNode = (node) => node.type === "tableRow" || node.type === "table_row";
const isTableCellNode = (node) => node.type === "tableCell" || node.type === "table_cell" || node.type === "tableHeader" || node.type === "table_header";
const normalizeRowHeight = (rowProps) => {
  if (!rowProps || typeof rowProps !== "object") return void 0;
  const rawRowHeight = rowProps.rowHeight;
  if (!rawRowHeight || typeof rawRowHeight !== "object") return void 0;
  const heightObj = rawRowHeight;
  const rawValue = pickNumber(heightObj.value ?? heightObj.val);
  if (rawValue == null) return void 0;
  const rawRule = heightObj.rule ?? heightObj.hRule;
  const rule = rawRule === "exact" || rawRule === "atLeast" || rawRule === "auto" ? rawRule : "atLeast";
  const valuePx = twipsToPx$2(rawValue);
  return {
    value: valuePx,
    rule
  };
};
const parseTableCell = (args) => {
  const { cellNode, rowIndex, cellIndex, numCells, numRows, context, defaultCellPadding, tableProperties } = args;
  if (!isTableCellNode(cellNode) || !Array.isArray(cellNode.content)) {
    return null;
  }
  const blocks = [];
  const cellBackground = cellNode.attrs?.background;
  let cellBackgroundColor;
  if (cellBackground && typeof cellBackground.color === "string") {
    const rawColor = cellBackground.color.trim();
    if (rawColor) {
      const normalized = rawColor.startsWith("#") ? rawColor : `#${rawColor}`;
      if (/^#[0-9A-Fa-f]{3}([0-9A-Fa-f]{3})?$/.test(normalized)) {
        cellBackgroundColor = normalized;
      }
    }
  }
  const cellConverterContext = tableProperties || cellBackgroundColor ? {
    ...context.converterContext,
    ...tableProperties && { tableInfo: { tableProperties, rowIndex, cellIndex, numCells, numRows } },
    ...cellBackgroundColor && { backgroundColor: cellBackgroundColor }
  } : context.converterContext;
  const paragraphToFlowBlocks2 = context.converters.paragraphToFlowBlocks;
  const tableNodeToBlock2 = context.converters?.tableNodeToBlock;
  const appendParagraphBlocks = (paragraphBlocks, sdtMetadata) => {
    applySdtMetadataToParagraphBlocks(
      paragraphBlocks.filter((block) => block.kind === "paragraph"),
      sdtMetadata
    );
    paragraphBlocks.forEach((block) => {
      if (block.kind === "paragraph" || block.kind === "image" || block.kind === "drawing") {
        blocks.push(block);
      }
    });
  };
  for (const childNode of cellNode.content) {
    if (childNode.type === "paragraph") {
      if (!paragraphToFlowBlocks2) continue;
      const paragraphBlocks = paragraphToFlowBlocks2({
        para: childNode,
        nextBlockId: context.nextBlockId,
        positions: context.positions,
        trackedChangesConfig: context.trackedChangesConfig,
        bookmarks: context.bookmarks,
        hyperlinkConfig: context.hyperlinkConfig,
        themeColors: context.themeColors,
        converterContext: cellConverterContext,
        converters: context.converters,
        enableComments: context.enableComments
      });
      appendParagraphBlocks(paragraphBlocks);
      continue;
    }
    if (childNode.type === "structuredContentBlock" && Array.isArray(childNode.content)) {
      const structuredContentMetadata = resolveNodeSdtMetadata(childNode, "structuredContentBlock");
      for (const nestedNode of childNode.content) {
        if (nestedNode.type === "paragraph") {
          if (!paragraphToFlowBlocks2) continue;
          const paragraphBlocks = paragraphToFlowBlocks2({
            para: nestedNode,
            nextBlockId: context.nextBlockId,
            positions: context.positions,
            trackedChangesConfig: context.trackedChangesConfig,
            bookmarks: context.bookmarks,
            hyperlinkConfig: context.hyperlinkConfig,
            themeColors: context.themeColors,
            converterContext: cellConverterContext,
            converters: context.converters,
            enableComments: context.enableComments
          });
          appendParagraphBlocks(paragraphBlocks, structuredContentMetadata);
          continue;
        }
        if (nestedNode.type === "table" && tableNodeToBlock2) {
          const tableBlock = tableNodeToBlock2({
            node: nestedNode,
            nextBlockId: context.nextBlockId,
            positions: context.positions,
            trackedChangesConfig: context.trackedChangesConfig,
            bookmarks: context.bookmarks,
            hyperlinkConfig: context.hyperlinkConfig,
            themeColors: context.themeColors,
            converterContext: context.converterContext,
            converters: context.converters,
            enableComments: context.enableComments
          });
          if (tableBlock && tableBlock.kind === "table") {
            applySdtMetadataToTableBlock(tableBlock, structuredContentMetadata);
            blocks.push(tableBlock);
          }
          continue;
        }
      }
      continue;
    }
    if (childNode.type === "table" && tableNodeToBlock2) {
      const tableBlock = tableNodeToBlock2({
        node: childNode,
        nextBlockId: context.nextBlockId,
        positions: context.positions,
        trackedChangesConfig: context.trackedChangesConfig,
        bookmarks: context.bookmarks,
        hyperlinkConfig: context.hyperlinkConfig,
        themeColors: context.themeColors,
        converterContext: context.converterContext,
        converters: context.converters,
        enableComments: context.enableComments
      });
      if (tableBlock && tableBlock.kind === "table") {
        blocks.push(tableBlock);
      }
      continue;
    }
    if (childNode.type === "image" && context.converters?.imageNodeToBlock) {
      const mergedMarks = [...childNode.marks ?? []];
      const trackedMeta = context.trackedChangesConfig ? collectTrackedChangeFromMarks(mergedMarks) : void 0;
      if (shouldHideTrackedNode(trackedMeta, context.trackedChangesConfig)) {
        continue;
      }
      const imageBlock = context.converters.imageNodeToBlock(
        childNode,
        context.nextBlockId,
        context.positions,
        trackedMeta,
        context.trackedChangesConfig
      );
      if (imageBlock && imageBlock.kind === "image") {
        annotateBlockWithTrackedChange(imageBlock, trackedMeta, context.trackedChangesConfig);
        blocks.push(imageBlock);
      }
      continue;
    }
    if (childNode.type === "vectorShape" && context.converters?.vectorShapeNodeToDrawingBlock) {
      const drawingBlock = context.converters.vectorShapeNodeToDrawingBlock(
        childNode,
        context.nextBlockId,
        context.positions
      );
      if (drawingBlock && drawingBlock.kind === "drawing") {
        blocks.push(drawingBlock);
      }
      continue;
    }
    if (childNode.type === "shapeGroup" && context.converters?.shapeGroupNodeToDrawingBlock) {
      const drawingBlock = context.converters.shapeGroupNodeToDrawingBlock(
        childNode,
        context.nextBlockId,
        context.positions
      );
      if (drawingBlock && drawingBlock.kind === "drawing") {
        blocks.push(drawingBlock);
      }
      continue;
    }
    if (childNode.type === "shapeContainer" && context.converters?.shapeContainerNodeToDrawingBlock) {
      const drawingBlock = context.converters.shapeContainerNodeToDrawingBlock(
        childNode,
        context.nextBlockId,
        context.positions
      );
      if (drawingBlock && drawingBlock.kind === "drawing") {
        blocks.push(drawingBlock);
      }
      continue;
    }
    if (childNode.type === "shapeTextbox" && context.converters?.shapeTextboxNodeToDrawingBlock) {
      const drawingBlock = context.converters.shapeTextboxNodeToDrawingBlock(
        childNode,
        context.nextBlockId,
        context.positions
      );
      if (drawingBlock && drawingBlock.kind === "drawing") {
        blocks.push(drawingBlock);
      }
      continue;
    }
  }
  if (blocks.length === 0) {
    return null;
  }
  const cellAttrs = {};
  const borders = extractCellBorders(cellNode.attrs ?? {});
  if (borders) cellAttrs.borders = borders;
  const padding = extractCellPadding(cellNode.attrs ?? {}) ?? (defaultCellPadding ? { ...defaultCellPadding } : void 0);
  if (padding) cellAttrs.padding = padding;
  const verticalAlign = cellNode.attrs?.verticalAlign;
  const normalizedVerticalAlign = verticalAlign === "middle" ? "center" : verticalAlign === "center" ? "center" : verticalAlign;
  if (normalizedVerticalAlign === "top" || normalizedVerticalAlign === "center" || normalizedVerticalAlign === "bottom") {
    cellAttrs.verticalAlign = normalizedVerticalAlign;
  }
  const background = cellNode.attrs?.background;
  if (background && typeof background.color === "string") {
    const bgColor = background.color;
    cellAttrs.background = bgColor.startsWith("#") ? bgColor : `#${bgColor}`;
  }
  const tableCellProperties = cellNode.attrs?.tableCellProperties;
  if (tableCellProperties && typeof tableCellProperties === "object") {
    cellAttrs.tableCellProperties = tableCellProperties;
  }
  const rowSpan = pickNumber(cellNode.attrs?.rowspan);
  const colSpan = pickNumber(cellNode.attrs?.colspan);
  return {
    id: context.nextBlockId(`cell-${rowIndex}-${cellIndex}`),
    blocks,
    // Backward compatibility: set paragraph to first block if it's a paragraph
    paragraph: blocks[0]?.kind === "paragraph" ? blocks[0] : void 0,
    rowSpan: rowSpan ?? void 0,
    colSpan: colSpan ?? void 0,
    attrs: Object.keys(cellAttrs).length > 0 ? cellAttrs : void 0
  };
};
const parseTableRow = (args) => {
  const { rowNode, rowIndex, context, defaultCellPadding, tableProperties, numRows } = args;
  if (!isTableRowNode(rowNode) || !Array.isArray(rowNode.content)) {
    return null;
  }
  const cells = [];
  rowNode.content.forEach((cellNode, cellIndex) => {
    const parsedCell = parseTableCell({
      cellNode,
      rowIndex,
      cellIndex,
      context,
      defaultCellPadding,
      tableProperties,
      numCells: rowNode?.content?.length || 1,
      numRows
    });
    if (parsedCell) {
      cells.push(parsedCell);
    }
  });
  if (cells.length === 0) return null;
  const rowProps = rowNode.attrs?.tableRowProperties;
  const rowHeight = normalizeRowHeight(rowProps);
  const attrs = rowProps && typeof rowProps === "object" ? {
    tableRowProperties: rowProps,
    ...rowHeight ? { rowHeight } : {}
  } : rowHeight ? { rowHeight } : void 0;
  return {
    id: context.nextBlockId(`row-${rowIndex}`),
    cells,
    attrs
  };
};
function extractFloatingTableAnchorWrap(node) {
  const tableProperties = node.attrs?.tableProperties;
  const floatingProps = tableProperties?.floatingTableProperties;
  if (!floatingProps) {
    return {};
  }
  const hasPositioning = floatingProps.tblpX !== void 0 || floatingProps.tblpY !== void 0 || floatingProps.tblpXSpec !== void 0 || floatingProps.tblpYSpec !== void 0 || floatingProps.horzAnchor !== void 0 || floatingProps.vertAnchor !== void 0;
  if (!hasPositioning) {
    return {};
  }
  const mapHorzAnchor = (val) => {
    switch (val) {
      case "page":
        return "page";
      case "margin":
        return "margin";
      case "text":
      default:
        return "column";
    }
  };
  const mapVertAnchor = (val) => {
    switch (val) {
      case "page":
        return "page";
      case "margin":
        return "margin";
      case "text":
      default:
        return "paragraph";
    }
  };
  const anchor = {
    isAnchored: true,
    hRelativeFrom: mapHorzAnchor(floatingProps.horzAnchor),
    vRelativeFrom: mapVertAnchor(floatingProps.vertAnchor)
  };
  if (floatingProps.tblpXSpec) {
    anchor.alignH = floatingProps.tblpXSpec;
  }
  if (floatingProps.tblpYSpec) {
    anchor.alignV = floatingProps.tblpYSpec;
  }
  if (floatingProps.tblpX !== void 0) {
    anchor.offsetH = twipsToPx$2(floatingProps.tblpX);
  }
  if (floatingProps.tblpY !== void 0) {
    anchor.offsetV = twipsToPx$2(floatingProps.tblpY);
  }
  const hasDistances = floatingProps.leftFromText !== void 0 || floatingProps.rightFromText !== void 0 || floatingProps.topFromText !== void 0 || floatingProps.bottomFromText !== void 0;
  const wrap = {
    type: "Square",
    // Floating tables with text distances use square wrapping
    wrapText: "bothSides"
    // Default to text on both sides
  };
  if (hasDistances) {
    if (floatingProps.topFromText !== void 0) {
      wrap.distTop = twipsToPx$2(floatingProps.topFromText);
    }
    if (floatingProps.bottomFromText !== void 0) {
      wrap.distBottom = twipsToPx$2(floatingProps.bottomFromText);
    }
    if (floatingProps.leftFromText !== void 0) {
      wrap.distLeft = twipsToPx$2(floatingProps.leftFromText);
    }
    if (floatingProps.rightFromText !== void 0) {
      wrap.distRight = twipsToPx$2(floatingProps.rightFromText);
    }
  }
  return { anchor, wrap };
}
function tableNodeToBlock({
  node,
  nextBlockId,
  positions,
  trackedChangesConfig,
  bookmarks,
  hyperlinkConfig,
  themeColors,
  converterContext,
  converters: converters2,
  enableComments
}) {
  if (!Array.isArray(node.content) || node.content.length === 0) return null;
  const paragraphConverter = converters2.paragraphToFlowBlocks;
  if (!paragraphConverter) return null;
  const parserDeps = {
    nextBlockId,
    positions,
    trackedChangesConfig,
    bookmarks,
    hyperlinkConfig,
    themeColors,
    converterContext,
    converters: converters2,
    enableComments
  };
  const hydratedTableStyle = hydrateTableStyleAttrs(node, converterContext);
  const defaultCellPadding = hydratedTableStyle?.cellPadding;
  const rows = [];
  node.content.forEach((rowNode, rowIndex) => {
    const parsedRow = parseTableRow({
      rowNode,
      rowIndex,
      numRows: node?.content?.length ?? 1,
      context: parserDeps,
      defaultCellPadding,
      tableProperties: node.attrs?.tableProperties
    });
    if (parsedRow) {
      rows.push(parsedRow);
    }
  });
  if (rows.length === 0) return null;
  const tableAttrs = {};
  const getBorderSource = () => {
    if (node.attrs?.borders && typeof node.attrs.borders === "object" && node.attrs.borders !== null) {
      return node.attrs.borders;
    }
    if (hydratedTableStyle?.borders && typeof hydratedTableStyle.borders === "object" && hydratedTableStyle.borders !== null) {
      return hydratedTableStyle.borders;
    }
    return void 0;
  };
  const borderSource = getBorderSource();
  const tableBorders = extractTableBorders(borderSource);
  if (tableBorders) tableAttrs.borders = tableBorders;
  if (node.attrs?.borderCollapse) {
    tableAttrs.borderCollapse = node.attrs.borderCollapse;
  }
  if (node.attrs?.tableCellSpacing) {
    tableAttrs.cellSpacing = node.attrs.tableCellSpacing;
  }
  if (node.attrs?.justification) {
    tableAttrs.justification = node.attrs.justification;
  } else if (hydratedTableStyle?.justification) {
    tableAttrs.justification = hydratedTableStyle.justification;
  }
  if (node.attrs?.tableWidth) {
    tableAttrs.tableWidth = node.attrs.tableWidth;
  } else if (hydratedTableStyle?.tableWidth) {
    tableAttrs.tableWidth = hydratedTableStyle.tableWidth;
  }
  if (node.attrs?.tableIndent && typeof node.attrs.tableIndent === "object") {
    tableAttrs.tableIndent = { ...node.attrs.tableIndent };
  }
  const tableLayout = node.attrs?.tableLayout;
  if (tableLayout) {
    tableAttrs.tableLayout = tableLayout;
  }
  const tableProperties = node.attrs?.tableProperties;
  if (tableProperties && typeof tableProperties === "object") {
    tableAttrs.tableProperties = tableProperties;
  }
  let columnWidths = void 0;
  const twipsToPixels2 = (twips) => {
    const PIXELS_PER_INCH2 = 96;
    return twips / 1440 * PIXELS_PER_INCH2;
  };
  const hasUserEditedGrid = node.attrs?.userEdited === true && Array.isArray(node.attrs?.grid) && node.attrs.grid.length > 0;
  if (hasUserEditedGrid) {
    columnWidths = node.attrs.grid.filter((col) => col != null && typeof col === "object").map((col) => {
      const twips = typeof col.col === "number" ? col.col : 0;
      return twips > 0 ? twipsToPixels2(twips) : 0;
    }).filter((width) => width > 0);
    if (columnWidths.length === 0) {
      columnWidths = void 0;
    }
  }
  if (!columnWidths && Array.isArray(node.content) && node.content.length > 0) {
    const firstRow = node.content[0];
    if (firstRow && isTableRowNode(firstRow) && Array.isArray(firstRow.content) && firstRow.content.length > 0) {
      const tempWidths = [];
      for (const cellNode of firstRow.content) {
        if (cellNode && isTableCellNode(cellNode) && cellNode.attrs?.colwidth !== void 0) {
          const colwidth = cellNode.attrs.colwidth;
          if (Array.isArray(colwidth)) {
            tempWidths.push(...colwidth.filter((w) => typeof w === "number" && w > 0));
          } else if (typeof colwidth === "number" && colwidth > 0) {
            tempWidths.push(colwidth);
          }
        }
      }
      if (tempWidths.length > 0) {
        columnWidths = tempWidths;
      }
    }
  }
  if (!columnWidths && Array.isArray(node.attrs?.grid) && node.attrs.grid.length > 0) {
    columnWidths = node.attrs.grid.filter((col) => col != null && typeof col === "object").map((col) => {
      const twips = typeof col.col === "number" ? col.col : 0;
      return twips > 0 ? twipsToPixels2(twips) : 0;
    }).filter((width) => width > 0);
    if (columnWidths.length === 0) {
      columnWidths = void 0;
    }
  }
  const { anchor, wrap } = extractFloatingTableAnchorWrap(node);
  const tableBlock = {
    kind: "table",
    id: nextBlockId("table"),
    rows,
    attrs: Object.keys(tableAttrs).length > 0 ? tableAttrs : void 0,
    columnWidths,
    ...anchor ? { anchor } : {},
    ...wrap ? { wrap } : {}
  };
  return tableBlock;
}
function handleTableNode(node, context) {
  const {
    blocks,
    recordBlockKind,
    nextBlockId,
    positions,
    trackedChangesConfig,
    bookmarks,
    hyperlinkConfig,
    converters: converters2,
    converterContext,
    enableComments
  } = context;
  const tableBlock = tableNodeToBlock({
    node,
    nextBlockId,
    positions,
    trackedChangesConfig,
    bookmarks,
    hyperlinkConfig,
    themeColors: void 0,
    converterContext,
    converters: converters2,
    enableComments
  });
  if (tableBlock) {
    blocks.push(tableBlock);
    recordBlockKind(tableBlock.kind);
  }
}
const DEFAULT_FONT = "Times New Roman";
const DEFAULT_SIZE = 10 / 0.75;
const nodeHandlers = {
  paragraph: handleParagraphNode,
  tableOfContents: handleTableOfContentsNode,
  index: handleIndexNode,
  structuredContentBlock: handleStructuredContentBlockNode,
  documentSection: handleDocumentSectionNode,
  table: handleTableNode,
  documentPartObject: handleDocumentPartObjectNode,
  // orderedList and bulletList removed - list handling moved out of layout-engine
  image: handleImageNode,
  vectorShape: handleVectorShapeNode,
  shapeGroup: handleShapeGroupNode,
  shapeContainer: handleShapeContainerNode,
  shapeTextbox: handleShapeTextboxNode
};
const converters = {
  contentBlockNodeToDrawingBlock,
  imageNodeToBlock,
  vectorShapeNodeToDrawingBlock,
  shapeGroupNodeToDrawingBlock,
  shapeContainerNodeToDrawingBlock,
  shapeTextboxNodeToDrawingBlock,
  tableNodeToBlock,
  paragraphToFlowBlocks
};
function toFlowBlocks(pmDoc, options) {
  const defaultFont = options?.defaultFont ?? DEFAULT_FONT;
  const defaultSize = options?.defaultSize ?? DEFAULT_SIZE;
  const instrumentation = options?.instrumentation;
  const idPrefix = normalizePrefix(options?.blockIdPrefix);
  const doc2 = pmDoc;
  if (!doc2.content) {
    return { blocks: [], bookmarks: /* @__PURE__ */ new Map() };
  }
  const trackedChangesMode = isValidTrackedMode(options?.trackedChangesMode) ? options.trackedChangesMode : "review";
  const enableTrackedChanges = options?.enableTrackedChanges ?? true;
  const trackedChangesConfig = {
    mode: trackedChangesMode,
    enabled: enableTrackedChanges
  };
  const hyperlinkConfig = {
    enableRichHyperlinks: options?.enableRichHyperlinks ?? false
  };
  const enableComments = options?.enableComments ?? true;
  const converterContext = normalizeConverterContext(
    options?.converterContext,
    defaultFont,
    defaultSize
  );
  const blocks = [];
  const bookmarks = /* @__PURE__ */ new Map();
  const positions = options?.positions ?? (options?.atomNodeTypes ? buildPositionMap(doc2, { atomNodeTypes: options.atomNodeTypes }) : buildPositionMap(doc2));
  const nextBlockId = createBlockIdGenerator(idPrefix);
  const blockCounts = {};
  const recordBlockKind = (kind) => {
    blockCounts[kind] = (blockCounts[kind] ?? 0) + 1;
  };
  const bodySectionProps = doc2.attrs?.bodySectPr ?? doc2.attrs?.sectPr;
  const sectionRanges = options?.emitSectionBreaks ? analyzeSectionRanges(doc2, bodySectionProps) : [];
  publishSectionMetadata(sectionRanges, options);
  if (sectionRanges.length > 0 && sectionRanges[0]) {
    const sectionBreak = createSectionBreakBlock(sectionRanges[0], nextBlockId, { isFirstSection: true });
    blocks.push(sectionBreak);
    recordBlockKind(sectionBreak.kind);
  }
  const handlerContext = {
    blocks,
    recordBlockKind,
    nextBlockId,
    positions,
    defaultFont,
    defaultSize,
    converterContext,
    trackedChangesConfig,
    hyperlinkConfig,
    enableComments,
    bookmarks,
    sectionState: {
      ranges: sectionRanges,
      currentSectionIndex: 0,
      currentParagraphIndex: 0
    },
    converters,
    themeColors: options?.themeColors
  };
  doc2.content.forEach((node) => {
    const handler = nodeHandlers[node.type];
    if (handler) {
      handler(node, handlerContext);
    }
  });
  if (sectionRanges.length > 0) {
    const lastSectionIndex = sectionRanges.length - 1;
    const lastSection = sectionRanges[lastSectionIndex];
    if (handlerContext.sectionState.currentSectionIndex < lastSectionIndex) {
      const sectionBreak = createSectionBreakBlock(lastSection, nextBlockId);
      blocks.push(sectionBreak);
      recordBlockKind(sectionBreak.kind);
    }
  }
  instrumentation?.log?.({ totalBlocks: blocks.length, blockCounts, bookmarks: bookmarks.size });
  const hydratedBlocks = hydrateImageBlocks(blocks, options?.mediaFiles);
  const mergedBlocks = mergeDropCapParagraphs(hydratedBlocks);
  return { blocks: mergedBlocks, bookmarks };
}
function mergeDropCapParagraphs(blocks) {
  const result = [];
  let i = 0;
  while (i < blocks.length) {
    const block = blocks[i];
    if (block.kind === "paragraph" && block.attrs?.dropCapDescriptor && i + 1 < blocks.length) {
      const dropCapBlock = block;
      const nextBlock = blocks[i + 1];
      if (nextBlock.kind === "paragraph") {
        const textBlock = nextBlock;
        const mergedBlock = {
          kind: "paragraph",
          id: textBlock.id,
          runs: textBlock.runs,
          attrs: {
            ...textBlock.attrs,
            dropCapDescriptor: dropCapBlock.attrs?.dropCapDescriptor,
            // Clear the legacy dropCap flag on the merged block
            dropCap: void 0
          }
        };
        result.push(mergedBlock);
        i += 2;
        continue;
      }
    }
    result.push(block);
    i += 1;
  }
  return result;
}
function normalizeConverterContext(context, defaultFont, defaultSize) {
  if (!context) {
    context = {
      translatedNumbering: {},
      translatedLinkedStyles: {
        docDefaults: {},
        latentStyles: {},
        styles: {}
      }
    };
  }
  if (!context.translatedLinkedStyles.docDefaults) {
    context.translatedLinkedStyles.docDefaults = {};
  }
  if (!context.translatedLinkedStyles.docDefaults.runProperties) {
    context.translatedLinkedStyles.docDefaults.runProperties = {};
  }
  if (!context.translatedLinkedStyles.docDefaults.runProperties.fontFamily) {
    context.translatedLinkedStyles.docDefaults.runProperties.fontFamily = {};
  }
  if (!context.translatedLinkedStyles.docDefaults.runProperties.fontFamily.ascii) {
    context.translatedLinkedStyles.docDefaults.runProperties.fontFamily.ascii = defaultFont;
  }
  if (!context.translatedLinkedStyles.docDefaults.runProperties.fontSize) {
    context.translatedLinkedStyles.docDefaults.runProperties.fontSize = defaultSize * 0.75 * 2;
  }
  return context;
}
function buildFootnotesInput(editorState, converter, converterContext, themeColors) {
  if (!editorState) return null;
  const footnoteNumberById = converterContext?.footnoteNumberById;
  const importedFootnotes = Array.isArray(converter?.footnotes) ? converter.footnotes : [];
  if (importedFootnotes.length === 0) return null;
  const refs = [];
  const idsInUse = /* @__PURE__ */ new Set();
  editorState.doc.descendants((node, pos) => {
    if (node.type?.name !== "footnoteReference") return;
    const id = node.attrs?.id;
    if (id == null) return;
    const key2 = String(id);
    const insidePos = Math.min(pos + 1, editorState.doc.content.size);
    refs.push({ id: key2, pos: insidePos });
    idsInUse.add(key2);
  });
  if (refs.length === 0) return null;
  const blocksById = /* @__PURE__ */ new Map();
  idsInUse.forEach((id) => {
    const entry = importedFootnotes.find((f) => String(f?.id) === id);
    const content = entry?.content;
    if (!Array.isArray(content) || content.length === 0) return;
    try {
      const clonedContent = JSON.parse(JSON.stringify(content));
      const footnoteDoc = { type: "doc", content: clonedContent };
      const result = toFlowBlocks(footnoteDoc, {
        blockIdPrefix: `footnote-${id}-`,
        enableRichHyperlinks: true,
        themeColors,
        converterContext
      });
      if (result?.blocks?.length) {
        ensureFootnoteMarker(result.blocks, id, footnoteNumberById);
        blocksById.set(id, result.blocks);
      }
    } catch (_2) {
    }
  });
  if (blocksById.size === 0) return null;
  return {
    refs,
    blocksById,
    gap: 2,
    topPadding: 4,
    dividerHeight: 1
  };
}
function isFootnoteMarker(run) {
  return Boolean(run.dataAttrs?.["data-sd-footnote-number"]);
}
function findRunWithPositions(runs) {
  return runs.find((r2) => {
    if (isFootnoteMarker(r2)) return false;
    return typeof r2.pmStart === "number" && Number.isFinite(r2.pmStart) && typeof r2.pmEnd === "number" && Number.isFinite(r2.pmEnd);
  });
}
function resolveDisplayNumber(id, footnoteNumberById) {
  if (!footnoteNumberById || typeof footnoteNumberById !== "object") return 1;
  const num = footnoteNumberById[id];
  if (typeof num === "number" && Number.isFinite(num) && num > 0) return num;
  return 1;
}
function toSuperscriptDigits$1(value) {
  const SUPERSCRIPT_MAP = {
    "0": "",
    "1": "",
    "2": "",
    "3": "",
    "4": "",
    "5": "",
    "6": "",
    "7": "",
    "8": "",
    "9": ""
  };
  const str = String(value ?? "");
  return str.split("").map((ch) => SUPERSCRIPT_MAP[ch] ?? ch).join("");
}
function computeMarkerPositions(baseRun, markerLength) {
  if (baseRun?.pmStart == null) {
    return { pmStart: null, pmEnd: null };
  }
  const pmStart = baseRun.pmStart;
  const pmEnd = baseRun.pmEnd != null ? Math.max(pmStart, Math.min(baseRun.pmEnd, pmStart + markerLength)) : pmStart + markerLength;
  return { pmStart, pmEnd };
}
function ensureFootnoteMarker(blocks, id, footnoteNumberById) {
  const firstParagraph = blocks.find((b2) => b2?.kind === "paragraph");
  if (!firstParagraph) return;
  const runs = Array.isArray(firstParagraph.runs) ? firstParagraph.runs : [];
  const displayNumber = resolveDisplayNumber(id, footnoteNumberById);
  const markerText = toSuperscriptDigits$1(displayNumber);
  const baseRun = findRunWithPositions(runs);
  const { pmStart, pmEnd } = computeMarkerPositions(baseRun, markerText.length);
  const existingMarker = runs.find(isFootnoteMarker);
  if (existingMarker) {
    if (pmStart != null && pmEnd != null) {
      if (existingMarker.pmStart == null) existingMarker.pmStart = pmStart;
      if (existingMarker.pmEnd == null) existingMarker.pmEnd = pmEnd;
    }
    return;
  }
  const firstTextRun = runs.find((r2) => typeof r2.text === "string");
  const markerRun = {
    kind: "text",
    text: markerText,
    dataAttrs: { "data-sd-footnote-number": "true" },
    fontFamily: typeof firstTextRun?.fontFamily === "string" ? firstTextRun.fontFamily : "Arial",
    fontSize: typeof firstTextRun?.fontSize === "number" && Number.isFinite(firstTextRun.fontSize) ? firstTextRun.fontSize : 12
  };
  if (pmStart != null) markerRun.pmStart = pmStart;
  if (pmEnd != null) markerRun.pmEnd = pmEnd;
  if (firstTextRun?.color != null) markerRun.color = firstTextRun.color;
  runs.unshift(markerRun);
  firstParagraph.runs = runs;
}
function safeCleanup(fn2, context) {
  try {
    fn2();
  } catch (error) {
    console.warn(`[PresentationEditor] ${context} cleanup failed:`, error);
  }
}
function createHiddenHost(doc2, widthPx) {
  const host = doc2.createElement("div");
  host.className = "presentation-editor__hidden-host";
  host.style.setProperty("position", "fixed");
  host.style.setProperty("left", "-9999px");
  host.style.setProperty("top", "0");
  if (widthPx >= 0) {
    host.style.setProperty("width", `${widthPx}px`);
  }
  host.style.setProperty("overflow-anchor", "none");
  host.style.setProperty("pointer-events", "none");
  host.style.setProperty("opacity", "0");
  host.style.setProperty("z-index", "-1");
  host.style.setProperty("user-select", "none");
  return host;
}
function getFallbackCursorColor(clientId, fallbackColors) {
  return fallbackColors[clientId % fallbackColors.length];
}
function validateCursorColor(color, clientId, fallbackColors) {
  return color.match(/^#[0-9A-Fa-f]{6}$/) ? color : getFallbackCursorColor(clientId, fallbackColors);
}
function normalizeAwarenessStates(options) {
  const provider = options.provider;
  if (!provider?.awareness) return /* @__PURE__ */ new Map();
  const editorState = options.editorState;
  if (!editorState) return /* @__PURE__ */ new Map();
  const ystate = ySyncPluginKey.getState(editorState);
  if (!ystate) return /* @__PURE__ */ new Map();
  const states = provider.awareness?.getStates?.();
  const normalized = /* @__PURE__ */ new Map();
  states?.forEach((aw, clientId) => {
    if (clientId === provider.awareness?.clientID) return;
    const awState = aw;
    if (!awState.cursor) return;
    try {
      const anchor = relativePositionToAbsolutePosition(
        ystate.doc,
        ystate.type,
        Y__namespace.createRelativePositionFromJSON(awState.cursor.anchor),
        ystate.binding.mapping
      );
      const head = relativePositionToAbsolutePosition(
        ystate.doc,
        ystate.type,
        Y__namespace.createRelativePositionFromJSON(awState.cursor.head),
        ystate.binding.mapping
      );
      if (anchor === null || head === null) return;
      const docSize = editorState.doc.content.size;
      const clampedAnchor = Math.max(0, Math.min(anchor, docSize));
      const clampedHead = Math.max(0, Math.min(head, docSize));
      const previousState = options.previousState.get(clientId);
      const positionChanged = !previousState || previousState.anchor !== clampedAnchor || previousState.head !== clampedHead;
      normalized.set(clientId, {
        clientId,
        user: {
          name: awState.user?.name,
          email: awState.user?.email,
          color: awState.user?.color || getFallbackCursorColor(clientId, options.fallbackColors)
        },
        anchor: clampedAnchor,
        head: clampedHead,
        updatedAt: positionChanged ? Date.now() : previousState?.updatedAt ?? Date.now()
      });
    } catch (error) {
      console.warn(`Failed to normalize cursor for client ${clientId}:`, error);
    }
  });
  const staleThreshold = Date.now() - options.staleTimeoutMs;
  const staleClients = [];
  options.previousState.forEach((cursor, clientId) => {
    if (cursor.updatedAt < staleThreshold && !normalized.has(clientId)) {
      staleClients.push(clientId);
    }
  });
  staleClients.forEach((clientId) => {
    options.previousState.delete(clientId);
  });
  return normalized;
}
let measurementCanvas = null;
let measurementCtx = null;
const TAB_CHAR_LENGTH = 1;
const SPACE_CHARS = SPACE_CHARS$1;
const isTabRun$1 = (run) => run?.kind === "tab";
const isWordChar$3 = (char) => {
  if (!char) return false;
  const code = char.charCodeAt(0);
  return code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || char === "'";
};
const capitalizeText$2 = (text) => {
  if (!text) return text;
  let result = "";
  for (let i = 0; i < text.length; i += 1) {
    const prevChar = i > 0 ? text[i - 1] : "";
    const ch = text[i];
    result += isWordChar$3(ch) && !isWordChar$3(prevChar) ? ch.toUpperCase() : ch;
  }
  return result;
};
const applyTextTransform$2 = (text, transform) => {
  if (!text || !transform || transform === "none") return text;
  if (transform === "uppercase") return text.toUpperCase();
  if (transform === "lowercase") return text.toLowerCase();
  if (transform === "capitalize") return capitalizeText$2(text);
  return text;
};
function getMeasurementContext() {
  if (measurementCtx) return measurementCtx;
  if (typeof document === "undefined") {
    if (vue.process$1.env.NODE_ENV !== "test") {
      console.warn("[text-measurement] Canvas not available (non-browser environment)");
    }
    return null;
  }
  measurementCanvas = document.createElement("canvas");
  try {
    measurementCtx = measurementCanvas.getContext("2d");
  } catch {
    measurementCtx = null;
  }
  if (!measurementCtx && vue.process$1.env.NODE_ENV !== "test") {
    console.warn("[text-measurement] Failed to create 2D context");
  }
  return measurementCtx;
}
const countSpaces = (text) => {
  let spaces = 0;
  for (let i = 0; i < text.length; i += 1) {
    if (SPACE_CHARS.has(text[i])) {
      spaces += 1;
    }
  }
  return spaces;
};
const getJustifyAdjustment = (block, line, availableWidthOverride, alignmentOverride, isLastLineOfParagraph, paragraphEndsWithLineBreak, skipJustifyOverride) => {
  if (block.kind !== "paragraph") {
    return { extraPerSpace: 0, totalSpaces: 0 };
  }
  if (block.runs.length === 0) {
    return { extraPerSpace: 0, totalSpaces: 0 };
  }
  const alignment2 = alignmentOverride ?? block.attrs?.alignment;
  const hasExplicitPositioning = line.segments?.some((seg) => seg.x !== void 0) ?? false;
  const lastRunIndex = block.runs.length - 1;
  const lastRun = block.runs[lastRunIndex];
  const derivedIsLastLine = line.toRun >= lastRunIndex;
  const derivedEndsWithLineBreak = lastRun ? lastRun.kind === "lineBreak" : false;
  const shouldJustify = shouldApplyJustify({
    alignment: alignment2,
    hasExplicitPositioning,
    isLastLineOfParagraph: derivedIsLastLine,
    paragraphEndsWithLineBreak: derivedEndsWithLineBreak,
    skipJustifyOverride
  });
  if (!shouldJustify) {
    return { extraPerSpace: 0, totalSpaces: 0 };
  }
  let totalSpaces = line.spaceCount ?? 0;
  if (totalSpaces === 0) {
    const runs = sliceRunsForLine(block, line);
    totalSpaces = runs.reduce((sum, run) => {
      if (isTabRun$1(run) || "src" in run || run.kind === "lineBreak" || run.kind === "break" || run.kind === "fieldAnnotation") {
        return sum;
      }
      return sum + countSpaces(run.text ?? "");
    }, 0);
  }
  const availableWidth = availableWidthOverride ?? line.maxWidth ?? line.width;
  const lineWidth = line.naturalWidth ?? line.width;
  const extraPerSpace = calculateJustifySpacing({
    lineWidth,
    availableWidth,
    spaceCount: totalSpaces,
    shouldJustify: true
    // Already checked above
  });
  return {
    extraPerSpace,
    totalSpaces
  };
};
function getRunFontString(run) {
  if (run.kind === "tab" || run.kind === "lineBreak" || run.kind === "break" || run.kind === "fieldAnnotation" || "src" in run) {
    return "normal normal 16px Arial";
  }
  const style2 = run.italic ? "italic" : "normal";
  const weight = run.bold ? "bold" : "normal";
  const fontSize2 = run.fontSize ?? 16;
  const fontFamily2 = run.fontFamily ?? "Arial";
  return `${style2} ${weight} ${fontSize2}px ${fontFamily2}`;
}
function sliceRunsForLine(block, line) {
  const result = [];
  if (block.kind !== "paragraph") return result;
  for (let runIndex = line.fromRun; runIndex <= line.toRun; runIndex += 1) {
    const run = block.runs[runIndex];
    if (!run) continue;
    if (isTabRun$1(run)) {
      result.push(run);
      continue;
    }
    if ("src" in run) {
      result.push(run);
      continue;
    }
    if (run.kind === "lineBreak") {
      result.push(run);
      continue;
    }
    if (run.kind === "break") {
      result.push(run);
      continue;
    }
    if (run.kind === "fieldAnnotation") {
      result.push(run);
      continue;
    }
    const text = run.text ?? "";
    const isFirstRun = runIndex === line.fromRun;
    const isLastRun = runIndex === line.toRun;
    if (isFirstRun || isLastRun) {
      const start2 = isFirstRun ? line.fromChar : 0;
      const end2 = isLastRun ? line.toChar : text.length;
      const slice2 = text.slice(start2, end2);
      const pmStart = run.pmStart != null ? run.pmStart + start2 : run.pmEnd != null ? run.pmEnd - (text.length - start2) : void 0;
      const pmEnd = run.pmStart != null ? run.pmStart + end2 : run.pmEnd != null ? run.pmEnd - (text.length - end2) : void 0;
      result.push({
        ...run,
        text: slice2,
        pmStart,
        pmEnd
      });
    } else {
      result.push(run);
    }
  }
  return result;
}
function measureCharacterX(block, line, charOffset, availableWidthOverride, alignmentOverride) {
  const ctx2 = getMeasurementContext();
  const availableWidth = availableWidthOverride ?? line.maxWidth ?? // Fallback: if no maxWidth, approximate available width as line width (no slack)
  line.width;
  const justify = getJustifyAdjustment(block, line, availableWidth, alignmentOverride);
  const alignment2 = alignmentOverride ?? (block.kind === "paragraph" ? block.attrs?.alignment : void 0);
  const renderedLineWidth = alignment2 === "justify" && justify.extraPerSpace !== 0 ? availableWidth : line.width;
  const hasExplicitPositioning = line.segments?.some((seg) => seg.x !== void 0);
  const alignmentOffset = !hasExplicitPositioning && alignment2 === "center" ? Math.max(0, (availableWidth - renderedLineWidth) / 2) : !hasExplicitPositioning && alignment2 === "right" ? Math.max(0, availableWidth - renderedLineWidth) : 0;
  if (hasExplicitPositioning && line.segments && ctx2) {
    return measureCharacterXSegmentBased(block, line, charOffset, ctx2);
  }
  if (!ctx2) {
    const runs2 = sliceRunsForLine(block, line);
    const charsInLine = Math.max(
      1,
      runs2.reduce((sum, run) => {
        if (isTabRun$1(run)) return sum + TAB_CHAR_LENGTH;
        if ("src" in run || run.kind === "lineBreak" || run.kind === "break" || run.kind === "fieldAnnotation")
          return sum;
        return sum + (run.text ?? "").length;
      }, 0)
    );
    return charOffset / charsInLine * renderedLineWidth;
  }
  const runs = sliceRunsForLine(block, line);
  let currentX = 0;
  let currentCharOffset = 0;
  let spaceTally = 0;
  for (const run of runs) {
    if (isTabRun$1(run)) {
      const runLength2 = TAB_CHAR_LENGTH;
      const tabWidth = run.width ?? 0;
      if (currentCharOffset + runLength2 >= charOffset) {
        const offsetInRun = charOffset - currentCharOffset;
        return currentX + (offsetInRun <= 0 ? 0 : tabWidth);
      }
      currentX += tabWidth;
      currentCharOffset += runLength2;
      continue;
    }
    const text = "src" in run || run.kind === "lineBreak" || run.kind === "break" || run.kind === "fieldAnnotation" ? "" : run.text ?? "";
    const runLength = text.length;
    const transform = isTabRun$1(run) || "src" in run || run.kind === "lineBreak" || run.kind === "break" || run.kind === "fieldAnnotation" ? void 0 : run.textTransform;
    const displayText = applyTextTransform$2(text, transform);
    if (currentCharOffset + runLength >= charOffset) {
      const offsetInRun = charOffset - currentCharOffset;
      ctx2.font = getRunFontString(run);
      const textUpToTarget = displayText.slice(0, offsetInRun);
      const measured2 = ctx2.measureText(textUpToTarget);
      const spacingWidth = computeLetterSpacingWidth(run, offsetInRun, runLength);
      const spacesInPortion = justify.extraPerSpace !== 0 ? countSpaces(text.slice(0, offsetInRun)) : 0;
      return alignmentOffset + currentX + measured2.width + spacingWidth + justify.extraPerSpace * (spaceTally + spacesInPortion);
    }
    ctx2.font = getRunFontString(run);
    const measured = ctx2.measureText(displayText);
    const runLetterSpacing = computeLetterSpacingWidth(run, runLength, runLength);
    const spacesInRun = justify.extraPerSpace !== 0 ? countSpaces(text) : 0;
    currentX += measured.width + runLetterSpacing + justify.extraPerSpace * spacesInRun;
    spaceTally += spacesInRun;
    currentCharOffset += runLength;
  }
  return alignmentOffset + currentX;
}
function measureCharacterXSegmentBased(block, line, charOffset, ctx2) {
  if (block.kind !== "paragraph" || !line.segments) return 0;
  let lineCharCount = 0;
  for (const segment of line.segments) {
    const run = block.runs[segment.runIndex];
    if (!run) continue;
    const segmentChars = segment.toChar - segment.fromChar;
    if (lineCharCount + segmentChars >= charOffset) {
      const offsetInSegment = charOffset - lineCharCount;
      let segmentBaseX = segment.x;
      if (segmentBaseX === void 0) {
        segmentBaseX = 0;
        for (const prevSeg of line.segments) {
          if (prevSeg === segment) break;
          const prevRun = block.runs[prevSeg.runIndex];
          if (!prevRun) continue;
          if (prevSeg.x !== void 0) {
            segmentBaseX = prevSeg.x + (prevSeg.width ?? 0);
          } else {
            segmentBaseX += prevSeg.width ?? 0;
          }
        }
      }
      if (isTabRun$1(run)) {
        return segmentBaseX + (offsetInSegment > 0 ? segment.width ?? 0 : 0);
      }
      if ("src" in run || run.kind === "lineBreak" || run.kind === "break" || run.kind === "fieldAnnotation") {
        return segmentBaseX + (offsetInSegment >= segmentChars ? segment.width ?? 0 : 0);
      }
      const text = run.text ?? "";
      const transform = "textTransform" in run ? run.textTransform : void 0;
      const displayText = applyTextTransform$2(text, transform);
      const displaySegmentText = displayText.slice(segment.fromChar, segment.toChar);
      const textUpToTarget = displaySegmentText.slice(0, offsetInSegment);
      ctx2.font = getRunFontString(run);
      const measured = ctx2.measureText(textUpToTarget);
      const spacingWidth = computeLetterSpacingWidth(run, offsetInSegment, segmentChars);
      return segmentBaseX + measured.width + spacingWidth;
    }
    lineCharCount += segmentChars;
  }
  return line.width;
}
function charOffsetToPm(block, line, charOffset, fallbackPmStart) {
  if (!Number.isFinite(charOffset) || !Number.isFinite(fallbackPmStart)) {
    console.warn("[charOffsetToPm] Invalid input:", { charOffset, fallbackPmStart });
    return fallbackPmStart;
  }
  const safeCharOffset = Math.max(0, charOffset);
  if (block.kind !== "paragraph") {
    return fallbackPmStart + safeCharOffset;
  }
  const runs = sliceRunsForLine(block, line);
  let cursor = 0;
  let lastPm = fallbackPmStart;
  for (const run of runs) {
    const isTab = isTabRun$1(run);
    const text = "src" in run || run.kind === "lineBreak" || run.kind === "break" || run.kind === "fieldAnnotation" ? "" : run.text ?? "";
    const runLength = isTab ? TAB_CHAR_LENGTH : text.length;
    const runPmStart = typeof run.pmStart === "number" ? run.pmStart : null;
    const runPmEnd = typeof run.pmEnd === "number" ? run.pmEnd : runPmStart != null ? runPmStart + runLength : null;
    if (runPmStart != null) {
      lastPm = runPmStart;
    }
    if (safeCharOffset <= cursor + runLength) {
      const offsetInRun = Math.max(0, safeCharOffset - cursor);
      return runPmStart != null ? runPmStart + Math.min(offsetInRun, runLength) : fallbackPmStart + safeCharOffset;
    }
    if (runPmEnd != null) {
      lastPm = runPmEnd;
    }
    cursor += runLength;
  }
  return lastPm;
}
function findCharacterAtX(block, line, x, pmStart, availableWidthOverride, alignmentOverride) {
  const ctx2 = getMeasurementContext();
  const availableWidth = availableWidthOverride ?? line.maxWidth ?? // Fallback: approximate with line width when no maxWidth is present
  line.width;
  const justify = getJustifyAdjustment(block, line, availableWidth, alignmentOverride);
  const alignment2 = alignmentOverride ?? (block.kind === "paragraph" ? block.attrs?.alignment : void 0);
  const renderedLineWidth = alignment2 === "justify" ? line.width + Math.max(0, availableWidth - line.width) : line.width;
  const hasExplicitPositioning = line.segments?.some((seg) => seg.x !== void 0);
  const alignmentOffset = !hasExplicitPositioning && alignment2 === "center" ? Math.max(0, (availableWidth - renderedLineWidth) / 2) : !hasExplicitPositioning && alignment2 === "right" ? Math.max(0, availableWidth - renderedLineWidth) : 0;
  if (!ctx2) {
    const runs2 = sliceRunsForLine(block, line);
    const charsInLine = Math.max(
      1,
      runs2.reduce((sum, run) => {
        if (isTabRun$1(run)) return sum + TAB_CHAR_LENGTH;
        if ("src" in run || run.kind === "lineBreak" || run.kind === "break" || run.kind === "fieldAnnotation")
          return sum;
        return sum + (run.text ?? "").length;
      }, 0)
    );
    const ratio = Math.max(0, Math.min(1, (x - alignmentOffset) / renderedLineWidth));
    const charOffset = Math.round(ratio * charsInLine);
    const pmPosition2 = charOffsetToPm(block, line, charOffset, pmStart);
    return {
      charOffset,
      pmPosition: pmPosition2
    };
  }
  const runs = sliceRunsForLine(block, line);
  const safeX = Math.max(0, Math.min(renderedLineWidth, x - alignmentOffset));
  let currentX = 0;
  let currentCharOffset = 0;
  let spaceTally = 0;
  for (const run of runs) {
    if (isTabRun$1(run)) {
      const tabWidth = run.width ?? 0;
      const startX = currentX;
      const endX = currentX + tabWidth;
      if (safeX <= endX) {
        const midpoint = startX + tabWidth / 2;
        const offsetInRun = safeX < midpoint ? 0 : TAB_CHAR_LENGTH;
        const charOffset = currentCharOffset + offsetInRun;
        const pmPosition2 = charOffsetToPm(block, line, charOffset, pmStart);
        return {
          charOffset,
          pmPosition: pmPosition2
        };
      }
      currentX = endX;
      currentCharOffset += TAB_CHAR_LENGTH;
      continue;
    }
    const text = "src" in run || run.kind === "lineBreak" || run.kind === "break" || run.kind === "fieldAnnotation" ? "" : run.text ?? "";
    const runLength = text.length;
    const transform = isTabRun$1(run) || "src" in run || run.kind === "lineBreak" || run.kind === "break" || run.kind === "fieldAnnotation" ? void 0 : run.textTransform;
    const displayText = applyTextTransform$2(text, transform);
    if (runLength === 0) continue;
    ctx2.font = getRunFontString(run);
    for (let i = 0; i <= runLength; i++) {
      const textUpToChar = displayText.slice(0, i);
      const measured2 = ctx2.measureText(textUpToChar);
      const spacesInPortion = justify.extraPerSpace > 0 ? countSpaces(text.slice(0, i)) : 0;
      const charX = currentX + measured2.width + computeLetterSpacingWidth(run, i, runLength) + justify.extraPerSpace * (spaceTally + spacesInPortion);
      if (charX >= safeX) {
        if (i === 0) {
          const pmPosition3 = charOffsetToPm(block, line, currentCharOffset, pmStart);
          return {
            charOffset: currentCharOffset,
            pmPosition: pmPosition3
          };
        }
        const prevText = displayText.slice(0, i - 1);
        const prevMeasured = ctx2.measureText(prevText);
        const prevX = currentX + prevMeasured.width + computeLetterSpacingWidth(run, i - 1, runLength);
        const distToPrev = Math.abs(safeX - prevX);
        const distToCurrent = Math.abs(safeX - charX);
        const charOffset = distToPrev < distToCurrent ? currentCharOffset + i - 1 : currentCharOffset + i;
        const pmPosition2 = charOffsetToPm(block, line, charOffset, pmStart);
        return {
          charOffset,
          pmPosition: pmPosition2
        };
      }
    }
    const measured = ctx2.measureText(displayText);
    const runLetterSpacing = computeLetterSpacingWidth(run, runLength, runLength);
    const spacesInRun = justify.extraPerSpace > 0 ? countSpaces(text) : 0;
    currentX += measured.width + runLetterSpacing + justify.extraPerSpace * spacesInRun;
    spaceTally += spacesInRun;
    currentCharOffset += runLength;
  }
  const pmPosition = charOffsetToPm(block, line, currentCharOffset, pmStart);
  return {
    charOffset: currentCharOffset,
    pmPosition
  };
}
const computeLetterSpacingWidth = (run, precedingChars, runLength) => {
  if (isTabRun$1(run) || "src" in run || run.kind === "fieldAnnotation" || !("letterSpacing" in run) || !run.letterSpacing) {
    return 0;
  }
  const maxGaps = Math.max(runLength - 1, 0);
  if (maxGaps === 0) {
    return 0;
  }
  const clamped = Math.min(Math.max(precedingChars, 0), maxGaps);
  return clamped * run.letterSpacing;
};
const log = (...args) => {
};
const CLASS_NAMES = {
  page: DOM_CLASS_NAMES.PAGE,
  fragment: DOM_CLASS_NAMES.FRAGMENT,
  line: DOM_CLASS_NAMES.LINE
};
function clickToPositionDom(domContainer, clientX, clientY) {
  const pageEl = findPageElement(domContainer, clientX, clientY);
  if (!pageEl) {
    return null;
  }
  const pageRect = pageEl.getBoundingClientRect();
  const pageLocalX = clientX - pageRect.left;
  const pageLocalY = clientY - pageRect.top;
  const viewX = pageRect.left + pageLocalX;
  const viewY = pageRect.top + pageLocalY;
  log("Page found:", {
    pageIndex: pageEl.dataset.pageIndex,
    pageRect: { left: pageRect.left, top: pageRect.top, width: pageRect.width, height: pageRect.height },
    viewCoords: { viewX, viewY }
  });
  let hitChain = [];
  const doc2 = document;
  const hasElementsFromPoint = typeof doc2.elementsFromPoint === "function";
  if (hasElementsFromPoint) {
    try {
      hitChain = doc2.elementsFromPoint(viewX, viewY) ?? [];
    } catch {
    }
  }
  if (!Array.isArray(hitChain)) {
    return null;
  }
  const hitChainData = hitChain.map((el) => {
    const rect = el.getBoundingClientRect();
    return {
      tag: el.tagName,
      classes: el.className,
      blockId: el.dataset?.blockId,
      pmStart: el.dataset?.pmStart,
      pmEnd: el.dataset?.pmEnd,
      rect: {
        top: Math.round(rect.top),
        bottom: Math.round(rect.bottom),
        left: Math.round(rect.left),
        right: Math.round(rect.right),
        height: Math.round(rect.height)
      }
    };
  });
  log("Hit chain elements:", JSON.stringify(hitChainData, null, 2));
  const allFragments = Array.from(pageEl.querySelectorAll(`.${CLASS_NAMES.fragment}`));
  const fragmentData = allFragments.map((el) => {
    const rect = el.getBoundingClientRect();
    return {
      blockId: el.dataset.blockId,
      pmStart: el.dataset.pmStart,
      pmEnd: el.dataset.pmEnd,
      rect: {
        top: Math.round(rect.top),
        bottom: Math.round(rect.bottom),
        left: Math.round(rect.left),
        right: Math.round(rect.right),
        height: Math.round(rect.height)
      }
    };
  });
  log("All fragments on page:", JSON.stringify(fragmentData, null, 2));
  const fragmentEl = hitChain.find((el) => el.classList?.contains?.(CLASS_NAMES.fragment));
  if (!fragmentEl) {
    if (hasElementsFromPoint) {
      return null;
    }
    const fallbackFragment = pageEl.querySelector(`.${CLASS_NAMES.fragment}`);
    if (!fallbackFragment) {
      return null;
    }
    log("Using fallback fragment (no elementsFromPoint):", {
      blockId: fallbackFragment.dataset.blockId,
      pmStart: fallbackFragment.dataset.pmStart,
      pmEnd: fallbackFragment.dataset.pmEnd
    });
    const result2 = processFragment(fallbackFragment, viewX, viewY);
    return result2;
  }
  log("Fragment found:", {
    blockId: fragmentEl.dataset.blockId,
    pmStart: fragmentEl.dataset.pmStart,
    pmEnd: fragmentEl.dataset.pmEnd
  });
  const hitChainLine = hitChain.find(
    (el) => el.classList?.contains?.(CLASS_NAMES.line) && el.dataset?.pmStart !== void 0 && el.dataset?.pmEnd !== void 0
  );
  if (hitChainLine) {
    log("Using hit chain line directly:", {
      pmStart: hitChainLine.dataset.pmStart,
      pmEnd: hitChainLine.dataset.pmEnd
    });
    const result2 = processLineElement(hitChainLine, viewX);
    return result2;
  }
  const result = processFragment(fragmentEl, viewX, viewY);
  return result;
}
function findPageElement(domContainer, clientX, clientY) {
  if (domContainer.classList?.contains?.(CLASS_NAMES.page)) {
    return domContainer;
  }
  const doc2 = document;
  if (typeof doc2.elementsFromPoint === "function") {
    try {
      const hitChain = doc2.elementsFromPoint(clientX, clientY);
      if (Array.isArray(hitChain)) {
        const pageEl = hitChain.find((el) => el.classList?.contains?.(CLASS_NAMES.page));
        if (pageEl) {
          return pageEl;
        }
      }
    } catch {
    }
  }
  const pages = Array.from(domContainer.querySelectorAll(`.${CLASS_NAMES.page}`));
  for (const page of pages) {
    const rect = page.getBoundingClientRect();
    if (clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom) {
      return page;
    }
  }
  if (pages.length > 0) {
    return pages[0];
  }
  return null;
}
function processFragment(fragmentEl, viewX, viewY) {
  log("processFragment:", { viewX, viewY, blockId: fragmentEl.dataset.blockId });
  const lineEls = Array.from(fragmentEl.querySelectorAll(`.${CLASS_NAMES.line}`));
  log(
    "Lines in fragment:",
    lineEls.map((el, i) => {
      const rect = el.getBoundingClientRect();
      return {
        index: i,
        pmStart: el.dataset.pmStart,
        pmEnd: el.dataset.pmEnd,
        rect: { top: rect.top, bottom: rect.bottom, left: rect.left, right: rect.right }
      };
    })
  );
  if (lineEls.length === 0) {
    return null;
  }
  const lineEl = findLineAtY(lineEls, viewY);
  if (!lineEl) {
    return null;
  }
  const lineStart = Number(lineEl.dataset.pmStart ?? "NaN");
  const lineEnd = Number(lineEl.dataset.pmEnd ?? "NaN");
  const lineRect = lineEl.getBoundingClientRect();
  log("Selected line:", {
    pmStart: lineStart,
    pmEnd: lineEnd,
    rect: { top: lineRect.top, bottom: lineRect.bottom, left: lineRect.left, right: lineRect.right }
  });
  if (!Number.isFinite(lineStart) || !Number.isFinite(lineEnd)) {
    return null;
  }
  const spanEls = Array.from(lineEl.querySelectorAll("span, a")).filter(
    (el) => el.dataset.pmStart !== void 0 && el.dataset.pmEnd !== void 0 && !el.classList.contains(DOM_CLASS_NAMES.INLINE_SDT_WRAPPER)
  );
  log(
    "Spans/anchors in line:",
    spanEls.map((el, i) => {
      const rect = el.getBoundingClientRect();
      return {
        index: i,
        tag: el.tagName,
        pmStart: el.dataset.pmStart,
        pmEnd: el.dataset.pmEnd,
        text: el.textContent?.substring(0, 20) + (el.textContent && el.textContent.length > 20 ? "..." : ""),
        visibility: el.style.visibility,
        rect: { left: rect.left, right: rect.right, width: rect.width }
      };
    })
  );
  if (spanEls.length === 0) {
    return lineStart;
  }
  const firstRect = spanEls[0].getBoundingClientRect();
  if (viewX <= firstRect.left) {
    return lineStart;
  }
  const lastRect = spanEls[spanEls.length - 1].getBoundingClientRect();
  if (viewX >= lastRect.right) {
    return lineEnd;
  }
  const targetEl = findSpanAtX(spanEls, viewX);
  if (!targetEl) {
    return lineStart;
  }
  const spanStart = Number(targetEl.dataset.pmStart ?? "NaN");
  const spanEnd = Number(targetEl.dataset.pmEnd ?? "NaN");
  const targetRect = targetEl.getBoundingClientRect();
  log("Target element:", {
    tag: targetEl.tagName,
    pmStart: spanStart,
    pmEnd: spanEnd,
    text: targetEl.textContent?.substring(0, 30),
    visibility: targetEl.style.visibility,
    rect: { left: targetRect.left, right: targetRect.right, width: targetRect.width },
    pageX: viewX,
    pageY: viewY
  });
  if (!Number.isFinite(spanStart) || !Number.isFinite(spanEnd)) {
    return null;
  }
  const firstChild = targetEl.firstChild;
  if (!firstChild || firstChild.nodeType !== Node.TEXT_NODE || !firstChild.textContent) {
    const elRect = targetEl.getBoundingClientRect();
    const closerToLeft = Math.abs(viewX - elRect.left) <= Math.abs(viewX - elRect.right);
    const snapPos = closerToLeft ? spanStart : spanEnd;
    return snapPos;
  }
  const textNode = firstChild;
  const charIndex = findCharIndexAtX(textNode, targetEl, viewX);
  const pos = mapCharIndexToPm(spanStart, spanEnd, textNode.length, charIndex);
  return pos;
}
function mapCharIndexToPm(spanStart, spanEnd, textLength, charIndex) {
  if (!Number.isFinite(spanStart) || !Number.isFinite(spanEnd)) {
    return spanStart;
  }
  if (textLength <= 0) {
    return spanStart;
  }
  const pmRange = spanEnd - spanStart;
  if (!Number.isFinite(pmRange) || pmRange <= 0) {
    return spanStart;
  }
  if (pmRange === textLength) {
    const mapped = spanStart + charIndex;
    return Math.min(spanEnd, Math.max(spanStart, mapped));
  }
  const ratio = charIndex / textLength;
  return ratio <= 0.5 ? spanStart : spanEnd;
}
function processLineElement(lineEl, viewX) {
  const lineStart = Number(lineEl.dataset.pmStart ?? "NaN");
  const lineEnd = Number(lineEl.dataset.pmEnd ?? "NaN");
  const lineRect = lineEl.getBoundingClientRect();
  log("processLineElement:", {
    pmStart: lineStart,
    pmEnd: lineEnd,
    rect: { top: lineRect.top, bottom: lineRect.bottom, left: lineRect.left, right: lineRect.right }
  });
  if (!Number.isFinite(lineStart) || !Number.isFinite(lineEnd)) {
    return null;
  }
  const spanEls = Array.from(lineEl.querySelectorAll("span, a")).filter(
    (el) => el.dataset.pmStart !== void 0 && el.dataset.pmEnd !== void 0 && !el.classList.contains(DOM_CLASS_NAMES.INLINE_SDT_WRAPPER)
  );
  log(
    "Spans/anchors in line:",
    spanEls.map((el, i) => {
      const rect = el.getBoundingClientRect();
      return {
        index: i,
        tag: el.tagName,
        pmStart: el.dataset.pmStart,
        pmEnd: el.dataset.pmEnd,
        text: el.textContent?.substring(0, 20) + (el.textContent && el.textContent.length > 20 ? "..." : ""),
        visibility: el.style.visibility,
        rect: { left: rect.left, right: rect.right, width: rect.width }
      };
    })
  );
  if (spanEls.length === 0) {
    return lineStart;
  }
  const firstRect = spanEls[0].getBoundingClientRect();
  if (viewX <= firstRect.left) {
    return lineStart;
  }
  const lastRect = spanEls[spanEls.length - 1].getBoundingClientRect();
  if (viewX >= lastRect.right) {
    return lineEnd;
  }
  const targetEl = findSpanAtX(spanEls, viewX);
  if (!targetEl) {
    return lineStart;
  }
  const spanStart = Number(targetEl.dataset.pmStart ?? "NaN");
  const spanEnd = Number(targetEl.dataset.pmEnd ?? "NaN");
  const targetRect = targetEl.getBoundingClientRect();
  log("Target element:", {
    tag: targetEl.tagName,
    pmStart: spanStart,
    pmEnd: spanEnd,
    text: targetEl.textContent?.substring(0, 30),
    visibility: targetEl.style.visibility,
    rect: { left: targetRect.left, right: targetRect.right, width: targetRect.width }
  });
  if (!Number.isFinite(spanStart) || !Number.isFinite(spanEnd)) {
    return null;
  }
  const firstChild = targetEl.firstChild;
  if (!firstChild || firstChild.nodeType !== Node.TEXT_NODE || !firstChild.textContent) {
    const elRect = targetEl.getBoundingClientRect();
    const closerToLeft = Math.abs(viewX - elRect.left) <= Math.abs(viewX - elRect.right);
    const snapPos = closerToLeft ? spanStart : spanEnd;
    return snapPos;
  }
  const textNode = firstChild;
  const charIndex = findCharIndexAtX(textNode, targetEl, viewX);
  const pos = spanStart + charIndex;
  return pos;
}
function findLineAtY(lineEls, viewY) {
  if (lineEls.length === 0) {
    return null;
  }
  for (let i = 0; i < lineEls.length; i++) {
    const lineEl = lineEls[i];
    const rect = lineEl.getBoundingClientRect();
    if (viewY >= rect.top && viewY <= rect.bottom) {
      log("findLineAtY: Found line at index", i, {
        pmStart: lineEl.dataset.pmStart,
        pmEnd: lineEl.dataset.pmEnd,
        rect: { top: rect.top, bottom: rect.bottom },
        viewY
      });
      return lineEl;
    }
  }
  const lastLine = lineEls[lineEls.length - 1];
  log("findLineAtY: Y beyond all lines, using last line:", {
    pmStart: lastLine.dataset.pmStart,
    pmEnd: lastLine.dataset.pmEnd,
    viewY
  });
  return lastLine;
}
function findSpanAtX(spanEls, viewX) {
  if (spanEls.length === 0) {
    return null;
  }
  let targetSpan = spanEls[0];
  for (let i = 0; i < spanEls.length; i++) {
    const span = spanEls[i];
    const rect = span.getBoundingClientRect();
    if (viewX >= rect.left && viewX <= rect.right) {
      log("findSpanAtX: Found containing element at index", i, {
        tag: span.tagName,
        pmStart: span.dataset.pmStart,
        pmEnd: span.dataset.pmEnd,
        rect: { left: rect.left, right: rect.right },
        viewX
      });
      return span;
    }
    if (viewX > rect.right) {
      targetSpan = span;
    }
  }
  log("findSpanAtX: No containing element, using nearest:", {
    tag: targetSpan.tagName,
    pmStart: targetSpan.dataset.pmStart,
    pmEnd: targetSpan.dataset.pmEnd,
    viewX
  });
  return targetSpan;
}
function findCharIndexAtX(textNode, container, targetX) {
  const text = textNode.textContent ?? "";
  const baseLeft = container.getBoundingClientRect().left;
  const range = document.createRange();
  let lo = 0;
  let hi = text.length;
  while (lo < hi) {
    const mid = Math.floor((lo + hi) / 2);
    range.setStart(textNode, 0);
    range.setEnd(textNode, mid);
    const w = range.getBoundingClientRect().width;
    const x = baseLeft + w;
    if (x < targetX) {
      lo = mid + 1;
    } else {
      hi = mid;
    }
  }
  const index2 = Math.max(0, Math.min(text.length, lo));
  const measureAt = (i) => {
    range.setStart(textNode, 0);
    range.setEnd(textNode, i);
    return baseLeft + range.getBoundingClientRect().width;
  };
  const xAt = measureAt(index2);
  const distAt = Math.abs(xAt - targetX);
  if (index2 > 0) {
    const xPrev = measureAt(index2 - 1);
    const distPrev = Math.abs(xPrev - targetX);
    if (distPrev < distAt) {
      return index2 - 1;
    }
  }
  return index2;
}
const LIST_MARKER_GAP = 8;
const MIN_MARKER_GUTTER = 24;
const DEFAULT_LIST_INDENT_BASE_PX = 24;
const DEFAULT_LIST_INDENT_STEP_PX = 24;
const DEFAULT_LIST_HANGING_PX = 18;
const SPACE_SUFFIX_GAP_PX = 4;
function resolveListTextStartPx(wordLayout, indentLeft, firstLine, hanging, measureMarkerText) {
  const marker = wordLayout?.marker;
  if (!marker) {
    const textStartPx = wordLayout?.firstLineIndentMode === true && typeof wordLayout.textStartPx === "number" && Number.isFinite(wordLayout.textStartPx) ? wordLayout.textStartPx : void 0;
    return textStartPx;
  }
  const markerBoxWidth = typeof marker.markerBoxWidthPx === "number" && Number.isFinite(marker.markerBoxWidthPx) ? marker.markerBoxWidthPx : 0;
  let markerTextWidth = typeof marker.glyphWidthPx === "number" && Number.isFinite(marker.glyphWidthPx) ? marker.glyphWidthPx : void 0;
  if (markerTextWidth == null && marker.markerText) {
    markerTextWidth = measureMarkerText(marker.markerText, marker);
  }
  if (!Number.isFinite(markerTextWidth) || markerTextWidth !== void 0 && markerTextWidth < 0) {
    markerTextWidth = markerBoxWidth;
  }
  const finalMarkerTextWidth = Math.max(0, markerTextWidth ?? 0);
  let markerStartPos;
  if (wordLayout?.firstLineIndentMode === true && typeof marker.markerX === "number" && Number.isFinite(marker.markerX)) {
    markerStartPos = marker.markerX;
  } else {
    markerStartPos = indentLeft - hanging + firstLine;
  }
  if (!Number.isFinite(markerStartPos)) {
    markerStartPos = 0;
  }
  const currentPos = markerStartPos + finalMarkerTextWidth;
  const suffix2 = marker.suffix ?? "tab";
  if (suffix2 === "space") {
    return markerStartPos + finalMarkerTextWidth + SPACE_SUFFIX_GAP_PX;
  }
  if (suffix2 === "nothing") {
    return markerStartPos + finalMarkerTextWidth;
  }
  const markerJustification = marker.justification ?? "left";
  const markerWidthEffective = Math.max(
    typeof marker.markerBoxWidthPx === "number" && Number.isFinite(marker.markerBoxWidthPx) ? marker.markerBoxWidthPx : 0,
    finalMarkerTextWidth
  );
  if (markerJustification !== "left") {
    const gutterWidth2 = typeof marker.gutterWidthPx === "number" && Number.isFinite(marker.gutterWidthPx) && marker.gutterWidthPx > 0 ? marker.gutterWidthPx : LIST_MARKER_GAP;
    return markerStartPos + finalMarkerTextWidth + Math.max(gutterWidth2, LIST_MARKER_GAP);
  }
  if (wordLayout?.firstLineIndentMode === true) {
    let targetTabStop;
    if (Array.isArray(wordLayout.tabsPx)) {
      for (const tab of wordLayout.tabsPx) {
        if (typeof tab === "number" && tab > currentPos) {
          targetTabStop = tab;
          break;
        }
      }
    }
    const textStartTarget2 = typeof marker.textStartX === "number" && Number.isFinite(marker.textStartX) ? marker.textStartX : wordLayout.textStartPx;
    let tabWidth2;
    if (targetTabStop !== void 0) {
      tabWidth2 = targetTabStop - currentPos;
    } else if (textStartTarget2 !== void 0 && Number.isFinite(textStartTarget2) && textStartTarget2 > currentPos) {
      tabWidth2 = textStartTarget2 - currentPos;
    } else {
      tabWidth2 = LIST_MARKER_GAP;
    }
    if (tabWidth2 < LIST_MARKER_GAP) {
      tabWidth2 = LIST_MARKER_GAP;
    }
    return markerStartPos + finalMarkerTextWidth + tabWidth2;
  }
  const textStartTarget = typeof wordLayout?.textStartPx === "number" && Number.isFinite(wordLayout.textStartPx) ? wordLayout.textStartPx : void 0;
  const gutterWidth = typeof marker.gutterWidthPx === "number" && Number.isFinite(marker.gutterWidthPx) && marker.gutterWidthPx > 0 ? marker.gutterWidthPx : LIST_MARKER_GAP;
  const currentPosStandard = markerStartPos + markerWidthEffective;
  if (textStartTarget !== void 0) {
    const gap = Math.max(textStartTarget - currentPosStandard, gutterWidth);
    return currentPosStandard + gap;
  }
  const textStart = indentLeft + firstLine;
  let tabWidth = textStart - currentPosStandard;
  if (tabWidth <= 0) {
    tabWidth = gutterWidth;
  } else if (tabWidth < LIST_MARKER_GAP) {
    tabWidth = Math.max(tabWidth, gutterWidth);
  }
  return currentPosStandard + tabWidth;
}
function getWordLayoutConfig(block) {
  if (!block || block.kind !== "paragraph") {
    return void 0;
  }
  return block.attrs?.wordLayout;
}
function isListItem(markerWidth, block) {
  const hasMarkerWidth = markerWidth > 0;
  if (hasMarkerWidth) {
    return true;
  }
  if (!block || block.kind !== "paragraph") {
    return false;
  }
  const wordLayout = getWordLayoutConfig(block);
  const rawAttrs = block.attrs;
  const hasListItemAttr = rawAttrs?.listItem != null;
  const hasListAttrs = hasListItemAttr || block.attrs?.numberingProperties != null || wordLayout?.marker != null;
  if (hasListAttrs) {
    return true;
  }
  const hangingIndent = block.attrs?.indent?.hanging ?? 0;
  const paraIndentLeft = block.attrs?.indent?.left ?? 0;
  const hasHangingIndentPattern = hangingIndent > 0 && paraIndentLeft > 0;
  return hasHangingIndentPattern;
}
function calculateTextStartIndent(params2) {
  const {
    isFirstLine,
    isListItem: isListItem2,
    markerWidth,
    markerTextWidth,
    paraIndentLeft,
    firstLineIndent,
    hangingIndent,
    wordLayout
  } = params2;
  const firstLineOffset = firstLineIndent - hangingIndent;
  const effectiveMarkerTextWidth = typeof markerTextWidth === "number" && Number.isFinite(markerTextWidth) && markerTextWidth > 0 ? markerTextWidth : markerWidth;
  let indentAdjust = paraIndentLeft;
  if (isListItem2 && isFirstLine) {
    const resolvedTextStart = resolveListTextStartPx(
      wordLayout,
      paraIndentLeft,
      Math.max(firstLineIndent, 0),
      Math.max(hangingIndent, 0),
      () => effectiveMarkerTextWidth
      // Use measured marker text width when available
    );
    if (typeof resolvedTextStart === "number" && Number.isFinite(resolvedTextStart)) {
      indentAdjust = resolvedTextStart;
    } else {
      const explicitTextStart = wordLayout?.marker?.textStartX ?? wordLayout?.textStartPx;
      const isStandardHangingList = hangingIndent > 0 && wordLayout?.firstLineIndentMode !== true;
      const textStartLooksValid = typeof explicitTextStart === "number" && Number.isFinite(explicitTextStart) && (!isStandardHangingList || explicitTextStart > paraIndentLeft);
      if (textStartLooksValid) {
        indentAdjust = explicitTextStart;
      } else if (wordLayout?.firstLineIndentMode === true) {
        indentAdjust = paraIndentLeft + Math.max(firstLineIndent, 0) + markerWidth;
      } else if (isStandardHangingList && effectiveMarkerTextWidth > 0) {
        const markerStartPos = Math.max(0, paraIndentLeft - hangingIndent + firstLineIndent);
        const gutterWidthCandidate = wordLayout?.gutterWidthPx;
        const gutterWidth = typeof gutterWidthCandidate === "number" && Number.isFinite(gutterWidthCandidate) ? gutterWidthCandidate : wordLayout?.marker?.gutterWidthPx ?? LIST_MARKER_GAP;
        indentAdjust = markerStartPos + effectiveMarkerTextWidth + gutterWidth;
      }
    }
  } else if (isFirstLine && !isListItem2) {
    indentAdjust += firstLineOffset;
  }
  return indentAdjust;
}
function extractParagraphIndent(indent) {
  const left2 = typeof indent?.left === "number" && Number.isFinite(indent.left) ? indent.left : 0;
  const right2 = typeof indent?.right === "number" && Number.isFinite(indent.right) ? indent.right : 0;
  const firstLine = typeof indent?.firstLine === "number" && Number.isFinite(indent.firstLine) ? indent.firstLine : 0;
  const hanging = typeof indent?.hanging === "number" && Number.isFinite(indent.hanging) ? indent.hanging : 0;
  return { left: left2, right: right2, firstLine, hanging };
}
const defaultHeaderFooterIdentifier = () => ({
  headerIds: { default: null, first: null, even: null, odd: null },
  footerIds: { default: null, first: null, even: null, odd: null },
  titlePg: false,
  alternateHeaders: false
});
const extractIdentifierFromConverter = (converter) => {
  const identifier = defaultHeaderFooterIdentifier();
  if (!converter) return identifier;
  const headerIds = converter.headerIds ?? {};
  const footerIds = converter.footerIds ?? {};
  identifier.headerIds = {
    default: headerIds.default ?? null,
    first: headerIds.first ?? null,
    even: headerIds.even ?? null,
    odd: headerIds.odd ?? null
  };
  identifier.footerIds = {
    default: footerIds.default ?? null,
    first: footerIds.first ?? null,
    even: footerIds.even ?? null,
    odd: footerIds.odd ?? null
  };
  identifier.titlePg = Boolean(headerIds.titlePg ?? footerIds.titlePg ?? false);
  identifier.alternateHeaders = Boolean(converter.pageStyles?.alternateHeaders ?? false);
  return identifier;
};
const getHeaderFooterType = (pageNumber, identifier, options) => {
  if (pageNumber <= 0) return null;
  const kind = options?.kind ?? "header";
  const ids = kind === "header" ? identifier.headerIds : identifier.footerIds;
  const hasFirst = Boolean(ids.first);
  const hasEven = Boolean(ids.even);
  const hasOdd = Boolean(ids.odd);
  const hasDefault = Boolean(ids.default);
  const titlePgEnabled = identifier.titlePg && hasFirst;
  const isFirstPage = pageNumber === 1;
  if (isFirstPage && titlePgEnabled) {
    return "first";
  }
  if (identifier.alternateHeaders) {
    if (pageNumber % 2 === 0 && (hasEven || hasDefault)) {
      return hasEven ? "even" : "default";
    }
    if (pageNumber % 2 === 1 && (hasOdd || hasDefault)) {
      return hasOdd ? "odd" : "default";
    }
  }
  if (hasDefault) {
    return "default";
  }
  return null;
};
const defaultMultiSectionIdentifier = () => ({
  headerIds: { default: null, first: null, even: null, odd: null },
  footerIds: { default: null, first: null, even: null, odd: null },
  titlePg: false,
  alternateHeaders: false,
  sectionCount: 0,
  sectionHeaderIds: /* @__PURE__ */ new Map(),
  sectionFooterIds: /* @__PURE__ */ new Map(),
  sectionTitlePg: /* @__PURE__ */ new Map()
});
function buildMultiSectionIdentifier(sectionMetadata, pageStyles2, converterIds) {
  const identifier = defaultMultiSectionIdentifier();
  identifier.alternateHeaders = Boolean(pageStyles2?.alternateHeaders ?? false);
  identifier.sectionCount = sectionMetadata.length;
  for (const section of sectionMetadata) {
    const idx = section.sectionIndex;
    if (section.headerRefs) {
      identifier.sectionHeaderIds.set(idx, {
        default: section.headerRefs.default ?? null,
        first: section.headerRefs.first ?? null,
        even: section.headerRefs.even ?? null,
        odd: section.headerRefs.odd ?? null
      });
    }
    if (section.footerRefs) {
      identifier.sectionFooterIds.set(idx, {
        default: section.footerRefs.default ?? null,
        first: section.footerRefs.first ?? null,
        even: section.footerRefs.even ?? null,
        odd: section.footerRefs.odd ?? null
      });
    }
    identifier.sectionTitlePg.set(idx, section.titlePg === true);
  }
  const section0Headers = identifier.sectionHeaderIds.get(0);
  const section0Footers = identifier.sectionFooterIds.get(0);
  if (section0Headers) {
    identifier.headerIds = { ...section0Headers };
  }
  if (section0Footers) {
    identifier.footerIds = { ...section0Footers };
  }
  identifier.titlePg = identifier.sectionTitlePg.get(0) ?? false;
  if (converterIds?.headerIds) {
    if (!identifier.titlePg && converterIds.headerIds.titlePg) {
      identifier.titlePg = true;
    }
    identifier.headerIds.default = identifier.headerIds.default ?? converterIds.headerIds.default ?? null;
    identifier.headerIds.first = identifier.headerIds.first ?? converterIds.headerIds.first ?? null;
    identifier.headerIds.even = identifier.headerIds.even ?? converterIds.headerIds.even ?? null;
    identifier.headerIds.odd = identifier.headerIds.odd ?? converterIds.headerIds.odd ?? null;
  }
  if (converterIds?.footerIds) {
    if (!identifier.titlePg && converterIds.footerIds.titlePg) {
      identifier.titlePg = true;
    }
    identifier.footerIds.default = identifier.footerIds.default ?? converterIds.footerIds.default ?? null;
    identifier.footerIds.first = identifier.footerIds.first ?? converterIds.footerIds.first ?? null;
    identifier.footerIds.even = identifier.footerIds.even ?? converterIds.footerIds.even ?? null;
    identifier.footerIds.odd = identifier.footerIds.odd ?? converterIds.footerIds.odd ?? null;
  }
  return identifier;
}
function getHeaderFooterTypeForSection(pageNumber, sectionIndex, identifier, options) {
  if (pageNumber <= 0) return null;
  const kind = options?.kind ?? "header";
  const sectionPageNumber = options?.sectionPageNumber ?? pageNumber;
  const sectionIds = kind === "header" ? identifier.sectionHeaderIds.get(sectionIndex) : identifier.sectionFooterIds.get(sectionIndex);
  const ids = sectionIds ?? (kind === "header" ? identifier.headerIds : identifier.footerIds);
  const hasFirst = Boolean(ids.first);
  const hasEven = Boolean(ids.even);
  const hasOdd = Boolean(ids.odd);
  const hasDefault = Boolean(ids.default);
  const sectionTitlePg = identifier.sectionTitlePg.has(sectionIndex) ? identifier.sectionTitlePg.get(sectionIndex) : identifier.titlePg;
  const titlePgEnabled = sectionTitlePg === true;
  const isFirstPageOfSection = sectionPageNumber === 1;
  if (isFirstPageOfSection && titlePgEnabled) {
    if (hasFirst || hasDefault || hasEven || hasOdd) return "first";
    return null;
  }
  if (identifier.alternateHeaders) {
    if (pageNumber % 2 === 0 && (hasEven || hasDefault)) {
      return hasEven ? "even" : "default";
    }
    if (pageNumber % 2 === 1 && (hasOdd || hasDefault)) {
      return hasOdd ? "odd" : "default";
    }
  }
  if (hasDefault) {
    return "default";
  }
  return null;
}
function createFloatingObjectManager(columns, margins, pageWidth) {
  const zones = [];
  let currentColumns = columns;
  let currentMargins = margins;
  let currentPageWidth = pageWidth;
  let marginLeft = Math.max(0, currentMargins?.left ?? 0);
  return {
    registerDrawing(drawingBlock, measure, anchorY, columnIndex, pageNumber) {
      if (!drawingBlock.anchor?.isAnchored) {
        return;
      }
      const { wrap, anchor } = drawingBlock;
      const wrapType = wrap?.type ?? "Inline";
      if (wrapType === "Inline" || wrapType === "None") {
        return;
      }
      const objectWidth = measure.width ?? 0;
      const objectHeight = measure.height ?? 0;
      const x = computeAnchorX(anchor, columnIndex, currentColumns, objectWidth, currentMargins, currentPageWidth);
      const y2 = anchorY + (anchor.offsetV ?? 0);
      const zone = {
        imageBlockId: drawingBlock.id,
        pageNumber,
        columnIndex,
        bounds: {
          x,
          y: y2,
          width: objectWidth,
          height: objectHeight
        },
        distances: {
          top: wrap?.distTop ?? 0,
          bottom: wrap?.distBottom ?? 0,
          left: wrap?.distLeft ?? 0,
          right: wrap?.distRight ?? 0
        },
        wrapMode: computeWrapMode(wrap),
        polygon: wrap?.polygon
      };
      zones.push(zone);
    },
    registerTable(tableBlock, measure, anchorY, columnIndex, pageNumber) {
      if (!tableBlock.anchor?.isAnchored) {
        return;
      }
      const { wrap, anchor } = tableBlock;
      const wrapType = wrap?.type ?? "None";
      if (wrapType === "None") {
        return;
      }
      const tableWidth = measure.totalWidth ?? 0;
      const tableHeight = measure.totalHeight ?? 0;
      const x = computeTableAnchorX(anchor, columnIndex, currentColumns, tableWidth, currentMargins, currentPageWidth);
      const y2 = anchorY + (anchor.offsetV ?? 0);
      const zone = {
        imageBlockId: tableBlock.id,
        // Reusing imageBlockId field for table id
        pageNumber,
        columnIndex,
        bounds: {
          x,
          y: y2,
          width: tableWidth,
          height: tableHeight
        },
        distances: {
          top: wrap?.distTop ?? 0,
          bottom: wrap?.distBottom ?? 0,
          left: wrap?.distLeft ?? 0,
          right: wrap?.distRight ?? 0
        },
        wrapMode: computeTableWrapMode(wrap)
      };
      zones.push(zone);
    },
    getExclusionsForLine(lineY, lineHeight2, columnIndex, pageNumber) {
      const result = zones.filter((zone) => {
        if (zone.pageNumber !== pageNumber || zone.columnIndex !== columnIndex) {
          return false;
        }
        const lineTop = lineY;
        const lineBottom = lineY + lineHeight2;
        const zoneTop = zone.bounds.y - zone.distances.top;
        const zoneBottom = zone.bounds.y + zone.bounds.height + zone.distances.bottom;
        const overlaps = lineBottom > zoneTop && lineTop < zoneBottom;
        return overlaps;
      });
      return result;
    },
    computeAvailableWidth(lineY, lineHeight2, baseWidth, columnIndex, pageNumber) {
      const exclusions = this.getExclusionsForLine(lineY, lineHeight2, columnIndex, pageNumber);
      if (exclusions.length === 0) {
        return { width: baseWidth, offsetX: 0 };
      }
      const wrappingZones = exclusions.filter((zone) => zone.wrapMode !== "none");
      if (wrappingZones.length === 0) {
        return { width: baseWidth, offsetX: 0 };
      }
      const leftFloats = [];
      const rightFloats = [];
      const columnOrigin = marginLeft + columnIndex * (currentColumns.width + currentColumns.gap);
      const columnCenter = columnOrigin + baseWidth / 2;
      for (const zone of wrappingZones) {
        if (zone.wrapMode === "left") {
          leftFloats.push(zone);
        } else if (zone.wrapMode === "right") {
          rightFloats.push(zone);
        } else if (zone.wrapMode === "both" || zone.wrapMode === "largest") {
          const zoneCenter = zone.bounds.x + zone.bounds.width / 2;
          if (zoneCenter < columnCenter) {
            leftFloats.push(zone);
          } else {
            rightFloats.push(zone);
          }
        }
      }
      let leftBoundary = 0;
      for (const zone of leftFloats) {
        const boundary = zone.bounds.x + zone.bounds.width + zone.distances.left + zone.distances.right;
        leftBoundary = Math.max(leftBoundary, boundary);
      }
      const columnRightEdge = columnOrigin + baseWidth;
      let rightBoundary = columnRightEdge;
      for (const zone of rightFloats) {
        const boundary = zone.bounds.x - zone.distances.left - zone.distances.right;
        rightBoundary = Math.min(rightBoundary, boundary);
      }
      const availableWidth = rightBoundary - leftBoundary;
      const offsetX = Math.max(0, leftBoundary - columnOrigin);
      if (availableWidth <= 0) {
        return { width: 1, offsetX: 0 };
      }
      return { width: availableWidth, offsetX };
    },
    getAllFloatsForPage(pageNumber) {
      return zones.filter((z2) => z2.pageNumber === pageNumber);
    },
    clear() {
      zones.length = 0;
    },
    /**
     * Update layout context used for positioning and wrapping (columns, margins, page width).
     * This method should be called when the layout configuration changes (e.g., section breaks,
     * column changes, page size changes) to ensure floating objects are positioned and wrapped
     * correctly relative to the new layout boundaries.
     *
     * @param nextColumns - Column layout configuration (width, gap, count)
     * @param nextMargins - Optional page margins (left, right) in pixels
     * @param nextPageWidth - Optional total page width in pixels
     */
    setLayoutContext(nextColumns, nextMargins, nextPageWidth) {
      currentColumns = nextColumns;
      currentMargins = nextMargins;
      currentPageWidth = nextPageWidth;
      marginLeft = Math.max(0, currentMargins?.left ?? 0);
    }
  };
}
function computeAnchorX(anchor, columnIndex, columns, imageWidth, margins, pageWidth) {
  const alignH = anchor.alignH ?? "left";
  const offsetH = anchor.offsetH ?? 0;
  const marginLeft = Math.max(0, margins?.left ?? 0);
  const marginRight = Math.max(0, margins?.right ?? 0);
  const contentWidth = pageWidth != null ? Math.max(1, pageWidth - (marginLeft + marginRight)) : columns.width;
  const contentLeft = marginLeft;
  const columnLeft = contentLeft + columnIndex * (columns.width + columns.gap);
  const relativeFrom = anchor.hRelativeFrom ?? "column";
  let baseX;
  let availableWidth;
  if (relativeFrom === "page") {
    baseX = 0;
    availableWidth = pageWidth != null ? pageWidth : contentWidth + marginLeft + marginRight;
  } else if (relativeFrom === "margin") {
    baseX = contentLeft;
    availableWidth = contentWidth;
  } else {
    baseX = columnLeft;
    availableWidth = columns.width;
  }
  const result = alignH === "left" ? baseX + offsetH : alignH === "right" ? baseX + availableWidth - imageWidth - offsetH : alignH === "center" ? baseX + (availableWidth - imageWidth) / 2 + offsetH : baseX;
  return result;
}
function computeWrapMode(wrap, _anchor) {
  if (!wrap) return "none";
  const wrapText = wrap.wrapText ?? "bothSides";
  if (wrap.type === "TopAndBottom") {
    return "none";
  }
  if (wrapText === "left") return "right";
  if (wrapText === "right") return "left";
  if (wrapText === "largest") return "largest";
  return "both";
}
function computeTableAnchorX(anchor, columnIndex, columns, tableWidth, margins, pageWidth) {
  const alignH = anchor.alignH ?? "left";
  const offsetH = anchor.offsetH ?? 0;
  const marginLeft = Math.max(0, margins?.left ?? 0);
  const marginRight = Math.max(0, margins?.right ?? 0);
  const contentWidth = pageWidth != null ? Math.max(1, pageWidth - (marginLeft + marginRight)) : columns.width;
  const contentLeft = marginLeft;
  const columnLeft = contentLeft + columnIndex * (columns.width + columns.gap);
  const relativeFrom = anchor.hRelativeFrom ?? "column";
  let baseX;
  let availableWidth;
  if (relativeFrom === "page") {
    if (columns.count === 1) {
      baseX = contentLeft;
      availableWidth = contentWidth;
    } else {
      baseX = 0;
      availableWidth = pageWidth != null ? pageWidth : contentWidth;
    }
  } else if (relativeFrom === "margin") {
    baseX = contentLeft;
    availableWidth = contentWidth;
  } else {
    baseX = columnLeft;
    availableWidth = columns.width;
  }
  let effectiveAlignH = alignH;
  if (alignH === "inside") effectiveAlignH = "left";
  if (alignH === "outside") effectiveAlignH = "right";
  const result = effectiveAlignH === "left" ? baseX + offsetH : effectiveAlignH === "right" ? baseX + availableWidth - tableWidth - offsetH : effectiveAlignH === "center" ? baseX + (availableWidth - tableWidth) / 2 + offsetH : baseX;
  return result;
}
function computeTableWrapMode(wrap) {
  if (!wrap) return "none";
  if (wrap.type === "None") {
    return "none";
  }
  const wrapText = wrap.wrapText ?? "bothSides";
  if (wrapText === "left") return "right";
  if (wrapText === "right") return "left";
  if (wrapText === "largest") return "largest";
  return "both";
}
function computeNextSectionPropsAtBreak(blocks) {
  const nextSectionPropsAtBreak = /* @__PURE__ */ new Map();
  const docxBreakIndexes = [];
  for (let i = 0; i < blocks.length; i += 1) {
    const block = blocks[i];
    if (!block || block.kind !== "sectionBreak") continue;
    if (block.attrs?.source !== "sectPr") continue;
    docxBreakIndexes.push(i);
  }
  const snapshotProps = (source) => {
    const props = {};
    if (source.kind !== "sectionBreak") return props;
    if (source.margins) {
      props.margins = {
        header: source.margins.header,
        footer: source.margins.footer,
        top: source.margins.top,
        right: source.margins.right,
        bottom: source.margins.bottom,
        left: source.margins.left
      };
    }
    if (source.pageSize) {
      props.pageSize = { w: source.pageSize.w, h: source.pageSize.h };
    }
    if (source.columns) {
      props.columns = { count: source.columns.count, gap: source.columns.gap };
    }
    if (source.orientation) {
      props.orientation = source.orientation;
    }
    if (source.vAlign) {
      props.vAlign = source.vAlign;
    }
    return props;
  };
  docxBreakIndexes.forEach((index2, ordinal) => {
    const current = blocks[index2];
    const nextIndex = docxBreakIndexes[ordinal + 1];
    const useCurrent = current?.kind === "sectionBreak" && current.attrs?.isFirstSection;
    const source = useCurrent || typeof nextIndex !== "number" ? current : blocks[nextIndex];
    nextSectionPropsAtBreak.set(index2, snapshotProps(source));
  });
  return nextSectionPropsAtBreak;
}
const SINGLE_COLUMN_DEFAULT = { count: 1, gap: 0 };
function getColumnConfig(blockColumns) {
  return blockColumns ? { count: blockColumns.count, gap: blockColumns.gap } : { ...SINGLE_COLUMN_DEFAULT };
}
function isColumnConfigChanging(blockColumns, activeColumns) {
  if (blockColumns) {
    return blockColumns.count !== activeColumns.count || blockColumns.gap !== activeColumns.gap;
  }
  return activeColumns.count > 1;
}
function scheduleSectionBreak(block, state, baseMargins, maxHeaderContentHeight = 0, maxFooterContentHeight = 0) {
  const next = { ...state };
  const calcRequiredTopMargin = (headerDistance, baseTop) => {
    if (maxHeaderContentHeight > 0) {
      return Math.max(baseTop, headerDistance + maxHeaderContentHeight);
    }
    return baseTop;
  };
  const calcRequiredBottomMargin = (footerDistance, baseBottom) => {
    if (maxFooterContentHeight > 0) {
      return Math.max(baseBottom, footerDistance + maxFooterContentHeight);
    }
    return baseBottom;
  };
  if (block.attrs?.isFirstSection && !next.hasAnyPages) {
    if (block.pageSize) {
      next.activePageSize = { w: block.pageSize.w, h: block.pageSize.h };
      next.pendingPageSize = null;
    }
    if (block.orientation) {
      next.activeOrientation = block.orientation;
      next.pendingOrientation = null;
    }
    const headerDistance = typeof block.margins?.header === "number" ? Math.max(0, block.margins.header) : next.activeHeaderDistance;
    const footerDistance = typeof block.margins?.footer === "number" ? Math.max(0, block.margins.footer) : next.activeFooterDistance;
    const sectionTop = typeof block.margins?.top === "number" ? Math.max(0, block.margins.top) : baseMargins.top;
    const sectionBottom = typeof block.margins?.bottom === "number" ? Math.max(0, block.margins.bottom) : baseMargins.bottom;
    if (block.margins?.header !== void 0) {
      next.activeHeaderDistance = headerDistance;
      next.pendingHeaderDistance = headerDistance;
    }
    if (block.margins?.footer !== void 0) {
      next.activeFooterDistance = footerDistance;
      next.pendingFooterDistance = footerDistance;
    }
    if (block.margins?.top !== void 0 || block.margins?.header !== void 0) {
      next.activeTopMargin = calcRequiredTopMargin(headerDistance, sectionTop);
      next.pendingTopMargin = next.activeTopMargin;
    }
    if (block.margins?.bottom !== void 0 || block.margins?.footer !== void 0) {
      next.activeBottomMargin = calcRequiredBottomMargin(footerDistance, sectionBottom);
      next.pendingBottomMargin = next.activeBottomMargin;
    }
    if (block.margins?.left !== void 0) {
      const leftMargin = Math.max(0, block.margins.left);
      next.activeLeftMargin = leftMargin;
      next.pendingLeftMargin = leftMargin;
    }
    if (block.margins?.right !== void 0) {
      const rightMargin = Math.max(0, block.margins.right);
      next.activeRightMargin = rightMargin;
      next.pendingRightMargin = rightMargin;
    }
    next.activeColumns = getColumnConfig(block.columns);
    next.pendingColumns = null;
    return { decision: { forcePageBreak: false, forceMidPageRegion: false }, state: next };
  }
  const headerPx = block.margins?.header;
  const footerPx = block.margins?.footer;
  const topPx = block.margins?.top;
  const bottomPx = block.margins?.bottom;
  const nextTop = next.pendingTopMargin ?? next.activeTopMargin;
  const nextBottom = next.pendingBottomMargin ?? next.activeBottomMargin;
  const nextLeft = next.pendingLeftMargin ?? next.activeLeftMargin;
  const nextRight = next.pendingRightMargin ?? next.activeRightMargin;
  const nextHeader = next.pendingHeaderDistance ?? next.activeHeaderDistance;
  const nextFooter = next.pendingFooterDistance ?? next.activeFooterDistance;
  if (typeof headerPx === "number" || typeof topPx === "number") {
    const newHeaderDist = typeof headerPx === "number" ? Math.max(0, headerPx) : nextHeader;
    const sectionTop = typeof topPx === "number" ? Math.max(0, topPx) : baseMargins.top;
    next.pendingHeaderDistance = newHeaderDist;
    next.pendingTopMargin = calcRequiredTopMargin(newHeaderDist, sectionTop);
  } else {
    next.pendingTopMargin = nextTop;
    next.pendingHeaderDistance = nextHeader;
  }
  if (typeof footerPx === "number" || typeof bottomPx === "number") {
    const newFooterDist = typeof footerPx === "number" ? Math.max(0, footerPx) : nextFooter;
    const sectionBottom = typeof bottomPx === "number" ? Math.max(0, bottomPx) : baseMargins.bottom;
    next.pendingFooterDistance = newFooterDist;
    next.pendingBottomMargin = calcRequiredBottomMargin(newFooterDist, sectionBottom);
  } else {
    next.pendingBottomMargin = nextBottom;
    next.pendingFooterDistance = nextFooter;
  }
  if (typeof block.margins?.left === "number") {
    next.pendingLeftMargin = Math.max(0, block.margins.left);
  } else {
    next.pendingLeftMargin = nextLeft;
  }
  if (typeof block.margins?.right === "number") {
    next.pendingRightMargin = Math.max(0, block.margins.right);
  } else {
    next.pendingRightMargin = nextRight;
  }
  if (block.pageSize) {
    next.pendingPageSize = { w: block.pageSize.w, h: block.pageSize.h };
  }
  if (block.orientation) {
    next.pendingOrientation = block.orientation;
  }
  const sectionType = block.type ?? "continuous";
  const isColumnsChanging = isColumnConfigChanging(block.columns, next.activeColumns);
  if (block.attrs?.requirePageBoundary) {
    next.pendingColumns = getColumnConfig(block.columns);
    return { decision: { forcePageBreak: true, forceMidPageRegion: false }, state: next };
  }
  switch (sectionType) {
    case "nextPage": {
      next.pendingColumns = getColumnConfig(block.columns);
      return { decision: { forcePageBreak: true, forceMidPageRegion: false }, state: next };
    }
    case "evenPage": {
      next.pendingColumns = getColumnConfig(block.columns);
      return {
        decision: { forcePageBreak: true, forceMidPageRegion: false, requiredParity: "even" },
        state: next
      };
    }
    case "oddPage": {
      next.pendingColumns = getColumnConfig(block.columns);
      return {
        decision: { forcePageBreak: true, forceMidPageRegion: false, requiredParity: "odd" },
        state: next
      };
    }
    case "continuous":
    default: {
      if (isColumnsChanging) {
        next.pendingColumns = getColumnConfig(block.columns);
        return { decision: { forcePageBreak: false, forceMidPageRegion: true }, state: next };
      }
      next.pendingColumns = getColumnConfig(block.columns);
      return { decision: { forcePageBreak: false, forceMidPageRegion: false }, state: next };
    }
  }
}
function applyPendingToActive(state) {
  const next = { ...state };
  if (next.pendingTopMargin != null) {
    next.activeTopMargin = next.pendingTopMargin;
  }
  if (next.pendingBottomMargin != null) {
    next.activeBottomMargin = next.pendingBottomMargin;
  }
  if (next.pendingLeftMargin != null) {
    next.activeLeftMargin = next.pendingLeftMargin;
  }
  if (next.pendingRightMargin != null) {
    next.activeRightMargin = next.pendingRightMargin;
  }
  if (next.pendingHeaderDistance != null) {
    next.activeHeaderDistance = next.pendingHeaderDistance;
  }
  if (next.pendingFooterDistance != null) {
    next.activeFooterDistance = next.pendingFooterDistance;
  }
  if (next.pendingPageSize != null) {
    next.activePageSize = next.pendingPageSize;
  }
  if (next.pendingColumns != null) {
    next.activeColumns = next.pendingColumns;
  }
  if (next.pendingOrientation != null) {
    next.activeOrientation = next.pendingOrientation;
  }
  next.pendingTopMargin = null;
  next.pendingBottomMargin = null;
  next.pendingLeftMargin = null;
  next.pendingRightMargin = null;
  next.pendingHeaderDistance = null;
  next.pendingFooterDistance = null;
  next.pendingPageSize = null;
  next.pendingColumns = null;
  next.pendingOrientation = null;
  return next;
}
const isTextRun$2 = (run) => {
  const runWithKind = run;
  return !runWithKind.kind || runWithKind.kind === "text";
};
const isEmptyTextParagraph = (block) => {
  const runs = block.runs;
  if (!runs || runs.length === 0) return true;
  if (runs.length !== 1) return false;
  const run = runs[0];
  if (!isTextRun$2(run)) return false;
  return typeof run.text === "string" && run.text.length === 0;
};
const shouldSuppressSpacingForEmpty = (block, side) => {
  if (!isEmptyTextParagraph(block)) return false;
  const attrs = block.attrs;
  const spacingExplicit = attrs?.spacingExplicit;
  if (!spacingExplicit) return false;
  if (side === "before") {
    return !spacingExplicit.before;
  }
  return !spacingExplicit.after;
};
function normalizeLines(measure) {
  if (measure.lines.length > 0) {
    return measure.lines;
  }
  return [
    {
      fromRun: 0,
      fromChar: 0,
      toRun: 0,
      toChar: 0,
      width: 0,
      ascent: 0,
      descent: 0,
      lineHeight: measure.totalHeight || 0
    }
  ];
}
function sliceLines(lines, startIndex, availableHeight) {
  let height = 0;
  let index2 = startIndex;
  while (index2 < lines.length) {
    const lineHeight2 = lines[index2].lineHeight || 0;
    if (height > 0 && height + lineHeight2 > availableHeight) {
      break;
    }
    height += lineHeight2;
    index2 += 1;
  }
  if (index2 === startIndex) {
    height = lines[startIndex].lineHeight || 0;
    index2 += 1;
  }
  return {
    toLine: index2,
    height
  };
}
const computeFragmentPmRange = (block, lines, fromLine, toLine) => computeFragmentPmRange$1(block, lines, fromLine, toLine);
const extractBlockPmRange = (block) => {
  if (!block || !block.attrs) {
    return {};
  }
  const attrs = block.attrs;
  const start2 = typeof attrs.pmStart === "number" ? attrs.pmStart : void 0;
  const end2 = typeof attrs.pmEnd === "number" ? attrs.pmEnd : void 0;
  return {
    pmStart: start2,
    pmEnd: end2 ?? (start2 != null ? start2 + 1 : void 0)
  };
};
const getParagraphAttrs = (block) => {
  if (!block.attrs || typeof block.attrs !== "object") {
    return void 0;
  }
  return block.attrs;
};
const asString = (value) => {
  return typeof value === "string" ? value : void 0;
};
const asBoolean$1 = (value) => {
  if (value === true || value === 1) return true;
  if (typeof value === "string") {
    const normalized = value.toLowerCase();
    return normalized === "true" || normalized === "1" || normalized === "on";
  }
  return false;
};
const asSafeNumber = (value) => {
  if (typeof value !== "number") {
    return 0;
  }
  if (!Number.isFinite(value) || value < 0) {
    return 0;
  }
  return value;
};
function calculateFirstLineIndent(block, measure) {
  const wordLayout = block.attrs?.wordLayout;
  if (!wordLayout?.firstLineIndentMode) {
    return 0;
  }
  if (!wordLayout.marker || !measure.marker) {
    return 0;
  }
  const markerWidthRaw = measure.marker.markerWidth ?? wordLayout.marker.markerBoxWidthPx ?? 0;
  const markerWidth = Number.isFinite(markerWidthRaw) && markerWidthRaw >= 0 ? markerWidthRaw : 0;
  const gutterWidthRaw = measure.marker.gutterWidth ?? 0;
  const gutterWidth = Number.isFinite(gutterWidthRaw) && gutterWidthRaw >= 0 ? gutterWidthRaw : 0;
  return markerWidth + gutterWidth;
}
function layoutParagraphBlock(ctx2, anchors) {
  const { block, measure, columnWidth, ensurePage, advanceColumn, columnX, floatManager } = ctx2;
  const remeasureParagraph2 = ctx2.remeasureParagraph;
  const blockAttrs = getParagraphAttrs(block);
  const frame = blockAttrs?.frame;
  if (anchors?.anchoredDrawings?.length) {
    for (const entry of anchors.anchoredDrawings) {
      if (anchors.placedAnchoredIds.has(entry.block.id)) continue;
      const state = ensurePage();
      const vRelativeFrom = entry.block.anchor?.vRelativeFrom;
      const alignV = entry.block.anchor?.alignV;
      const offsetV = entry.block.anchor?.offsetV ?? 0;
      const imageHeight = entry.measure.height;
      const contentTop = state.topMargin;
      const contentBottom = state.contentBottom;
      const contentHeight = Math.max(0, contentBottom - contentTop);
      let anchorY;
      if (vRelativeFrom === "margin") {
        if (alignV === "top") {
          anchorY = contentTop + offsetV;
        } else if (alignV === "bottom") {
          anchorY = contentBottom - imageHeight + offsetV;
        } else if (alignV === "center") {
          anchorY = contentTop + (contentHeight - imageHeight) / 2 + offsetV;
        } else {
          anchorY = contentTop + offsetV;
        }
      } else if (vRelativeFrom === "page") {
        if (alignV === "top") {
          anchorY = offsetV;
        } else if (alignV === "bottom") {
          const pageHeight = contentBottom + (anchors.pageMargins.bottom ?? 0);
          anchorY = pageHeight - imageHeight + offsetV;
        } else if (alignV === "center") {
          const pageHeight = contentBottom + (anchors.pageMargins.bottom ?? 0);
          anchorY = (pageHeight - imageHeight) / 2 + offsetV;
        } else {
          anchorY = offsetV;
        }
      } else if (vRelativeFrom === "paragraph") {
        const baseAnchorY = state.cursorY;
        const firstLineHeight = measure.lines?.[0]?.lineHeight ?? 0;
        if (alignV === "top") {
          anchorY = baseAnchorY + offsetV;
        } else if (alignV === "bottom") {
          anchorY = baseAnchorY + firstLineHeight - imageHeight + offsetV;
        } else if (alignV === "center") {
          anchorY = baseAnchorY + (firstLineHeight - imageHeight) / 2 + offsetV;
        } else {
          anchorY = baseAnchorY + offsetV;
        }
      } else {
        const baseAnchorY = state.cursorY;
        anchorY = baseAnchorY + offsetV;
      }
      floatManager.registerDrawing(entry.block, entry.measure, anchorY, state.columnIndex, state.page.number);
      const anchorX = entry.block.anchor ? computeAnchorX(
        entry.block.anchor,
        state.columnIndex,
        anchors.columns,
        entry.measure.width,
        { left: anchors.pageMargins.left, right: anchors.pageMargins.right },
        anchors.pageWidth
      ) : columnX(state.columnIndex);
      const pmRange = extractBlockPmRange(entry.block);
      if (entry.block.kind === "image" && entry.measure.kind === "image") {
        const pageContentHeight = Math.max(0, state.contentBottom - state.topMargin);
        const relativeFrom = entry.block.anchor?.hRelativeFrom ?? "column";
        const marginLeft = anchors.pageMargins.left ?? 0;
        const marginRight = anchors.pageMargins.right ?? 0;
        let maxWidth;
        if (relativeFrom === "page") {
          maxWidth = anchors.columns.count === 1 ? anchors.pageWidth - marginLeft - marginRight : anchors.pageWidth;
        } else if (relativeFrom === "margin") {
          maxWidth = anchors.pageWidth - marginLeft - marginRight;
        } else {
          maxWidth = anchors.columns.width;
        }
        const aspectRatio = entry.measure.width > 0 && entry.measure.height > 0 ? entry.measure.width / entry.measure.height : 1;
        const minWidth = 20;
        const minHeight = minWidth / aspectRatio;
        const metadata = {
          originalWidth: entry.measure.width,
          originalHeight: entry.measure.height,
          maxWidth,
          maxHeight: pageContentHeight,
          aspectRatio,
          minWidth,
          minHeight
        };
        const fragment = {
          kind: "image",
          blockId: entry.block.id,
          x: anchorX,
          y: anchorY,
          width: entry.measure.width,
          height: entry.measure.height,
          isAnchored: true,
          zIndex: entry.block.anchor?.behindDoc ? 0 : 1,
          metadata
        };
        if (pmRange.pmStart != null) fragment.pmStart = pmRange.pmStart;
        if (pmRange.pmEnd != null) fragment.pmEnd = pmRange.pmEnd;
        state.page.fragments.push(fragment);
      } else if (entry.block.kind === "drawing" && entry.measure.kind === "drawing") {
        const fragment = {
          kind: "drawing",
          blockId: entry.block.id,
          drawingKind: entry.block.drawingKind,
          x: anchorX,
          y: anchorY,
          width: entry.measure.width,
          height: entry.measure.height,
          geometry: entry.measure.geometry,
          scale: entry.measure.scale,
          isAnchored: true,
          zIndex: entry.block.anchor?.behindDoc ? 0 : 1,
          drawingContentId: entry.block.drawingContentId
        };
        if (pmRange.pmStart != null) fragment.pmStart = pmRange.pmStart;
        if (pmRange.pmEnd != null) fragment.pmEnd = pmRange.pmEnd;
        state.page.fragments.push(fragment);
      }
      anchors.placedAnchoredIds.add(entry.block.id);
    }
  }
  let lines = normalizeLines(measure);
  const measurementWidth = lines[0]?.maxWidth;
  const paraIndent = block.attrs?.indent;
  const indentLeft = typeof paraIndent?.left === "number" && Number.isFinite(paraIndent.left) ? paraIndent.left : 0;
  const indentRight = typeof paraIndent?.right === "number" && Number.isFinite(paraIndent.right) ? paraIndent.right : 0;
  const negativeLeftIndent = indentLeft < 0 ? indentLeft : 0;
  const negativeRightIndent = indentRight < 0 ? indentRight : 0;
  const remeasureWidth = Math.max(1, columnWidth - indentLeft - indentRight);
  let didRemeasureForColumnWidth = false;
  let remeasuredMarkerInfo;
  if (typeof remeasureParagraph2 === "function" && typeof measurementWidth === "number" && measurementWidth > remeasureWidth) {
    const firstLineIndent = calculateFirstLineIndent(block, measure);
    const newMeasure = remeasureParagraph2(block, columnWidth, firstLineIndent);
    const newLines = normalizeLines(newMeasure);
    lines = newLines;
    didRemeasureForColumnWidth = true;
    if (newMeasure.marker) {
      remeasuredMarkerInfo = newMeasure.marker;
    }
  }
  let fromLine = 0;
  const attrs = getParagraphAttrs(block);
  const spacing = attrs?.spacing ?? {};
  const spacingExplicit = attrs?.spacingExplicit;
  const styleId = asString(attrs?.styleId);
  const contextualSpacing = asBoolean$1(attrs?.contextualSpacing);
  let spacingBefore = Math.max(0, Number(spacing.before ?? spacing.lineSpaceBefore ?? 0));
  let spacingAfter = ctx2.overrideSpacingAfter ?? Math.max(0, Number(spacing.after ?? spacing.lineSpaceAfter ?? 0));
  const emptyTextParagraph = isEmptyTextParagraph(block);
  if (emptyTextParagraph && spacingExplicit) {
    if (!spacingExplicit.before) spacingBefore = 0;
    if (!spacingExplicit.after) spacingAfter = 0;
  }
  const baseSpacingBefore = spacingBefore;
  let appliedSpacingBefore = spacingBefore === 0;
  let lastState = null;
  const isPositionedFrame = frame?.wrap === "none";
  if (isPositionedFrame) {
    let state = ensurePage();
    if (state.cursorY >= state.contentBottom) {
      state = advanceColumn(state);
    }
    const maxLineWidth = lines.reduce((max2, line) => Math.max(max2, line.width ?? 0), 0);
    const fragmentWidth = maxLineWidth || columnWidth;
    let x = columnX(state.columnIndex);
    if (frame.xAlign === "right") {
      x += columnWidth - fragmentWidth;
    } else if (frame.xAlign === "center") {
      x += (columnWidth - fragmentWidth) / 2;
    }
    if (typeof frame.x === "number" && Number.isFinite(frame.x)) {
      x += frame.x;
    }
    const yOffset = typeof frame.y === "number" && Number.isFinite(frame.y) ? frame.y : 0;
    const fragment = {
      kind: "para",
      blockId: block.id,
      fromLine: 0,
      toLine: lines.length,
      x,
      y: state.cursorY + yOffset,
      width: fragmentWidth,
      ...computeFragmentPmRange(block, lines, 0, lines.length)
    };
    if (measure.marker || remeasuredMarkerInfo) {
      const effectiveMarkerInfo = remeasuredMarkerInfo ?? measure.marker;
      fragment.markerWidth = effectiveMarkerInfo?.markerWidth ?? measure.marker?.markerWidth ?? 0;
      const markerTextWidth = remeasuredMarkerInfo?.markerTextWidth ?? measure.marker?.markerTextWidth;
      if (markerTextWidth != null) {
        fragment.markerTextWidth = markerTextWidth;
      }
    }
    state.page.fragments.push(fragment);
    state.trailingSpacing = 0;
    state.lastParagraphStyleId = styleId;
    return;
  }
  let narrowestWidth = columnWidth;
  let narrowestOffsetX = 0;
  let didRemeasureForFloats = false;
  if (typeof remeasureParagraph2 === "function") {
    const tempState = ensurePage();
    let tempY = tempState.cursorY;
    if (!appliedSpacingBefore && spacingBefore > 0) {
      const prevTrailing = tempState.trailingSpacing ?? 0;
      const neededSpacingBefore = Math.max(spacingBefore - prevTrailing, 0);
      tempY += neededSpacingBefore;
    }
    for (let i = 0; i < lines.length; i++) {
      const lineY = tempY;
      const lineHeight2 = lines[i]?.lineHeight || 0;
      const { width: availableWidth, offsetX: computedOffset } = floatManager.computeAvailableWidth(
        lineY,
        lineHeight2,
        columnWidth,
        tempState.columnIndex,
        tempState.page.number
      );
      if (availableWidth < narrowestWidth) {
        narrowestWidth = availableWidth;
        narrowestOffsetX = computedOffset;
      }
      tempY += lineHeight2;
    }
    const narrowestRemeasureWidth = Math.max(1, narrowestWidth - indentLeft - indentRight);
    if (narrowestRemeasureWidth < remeasureWidth) {
      const firstLineIndent = calculateFirstLineIndent(block, measure);
      const newMeasure = remeasureParagraph2(block, narrowestRemeasureWidth, firstLineIndent);
      const newLines = normalizeLines(newMeasure);
      lines = newLines;
      didRemeasureForFloats = true;
      if (newMeasure.marker) {
        remeasuredMarkerInfo = newMeasure.marker;
      }
    }
  }
  while (fromLine < lines.length) {
    let state = ensurePage();
    if (state.trailingSpacing == null) state.trailingSpacing = 0;
    if (contextualSpacing && state.lastParagraphStyleId && styleId && state.lastParagraphStyleId === styleId) {
      spacingBefore = 0;
      const prevTrailing = asSafeNumber(state.trailingSpacing);
      if (prevTrailing > 0) {
        state.cursorY -= prevTrailing;
        state.trailingSpacing = 0;
      }
    }
    const keepLines = attrs?.keepLines === true;
    if (keepLines && fromLine === 0) {
      const prevTrailing = state.trailingSpacing ?? 0;
      const neededSpacingBefore = Math.max(spacingBefore - prevTrailing, 0);
      const pageContentHeight = state.contentBottom - state.topMargin;
      const fullHeight = lines.reduce((sum, line) => sum + (line.lineHeight || 0), 0);
      const fitsOnBlankPage = fullHeight + baseSpacingBefore <= pageContentHeight;
      const remainingHeightAfterSpacing = state.contentBottom - (state.cursorY + neededSpacingBefore);
      if (fitsOnBlankPage && state.page.fragments.length > 0 && fullHeight > remainingHeightAfterSpacing) {
        state = advanceColumn(state);
        spacingBefore = baseSpacingBefore;
        appliedSpacingBefore = spacingBefore === 0;
        continue;
      }
    }
    if (!appliedSpacingBefore && spacingBefore > 0) {
      while (!appliedSpacingBefore) {
        const prevTrailing = state.trailingSpacing ?? 0;
        const neededSpacingBefore = Math.max(spacingBefore - prevTrailing, 0);
        if (state.cursorY + neededSpacingBefore > state.contentBottom) {
          if (state.cursorY <= state.topMargin) {
            state.trailingSpacing = 0;
            appliedSpacingBefore = true;
            break;
          }
          state = advanceColumn(state);
          if (state.trailingSpacing == null) state.trailingSpacing = 0;
          continue;
        }
        if (neededSpacingBefore > 0) {
          state.cursorY += neededSpacingBefore;
        }
        state.trailingSpacing = 0;
        appliedSpacingBefore = true;
      }
    } else {
      state.trailingSpacing = 0;
    }
    if (state.cursorY >= state.contentBottom) {
      state = advanceColumn(state);
    }
    const availableHeight = state.contentBottom - state.cursorY;
    if (availableHeight <= 0) {
      state = advanceColumn(state);
    }
    const nextLineHeight = lines[fromLine].lineHeight || 0;
    const remainingHeight = state.contentBottom - state.cursorY;
    if (state.page.fragments.length > 0 && remainingHeight < nextLineHeight) {
      state = advanceColumn(state);
    }
    let effectiveColumnWidth = columnWidth;
    let offsetX = 0;
    if (didRemeasureForFloats) {
      effectiveColumnWidth = narrowestWidth;
      offsetX = narrowestOffsetX;
    }
    const slice2 = sliceLines(lines, fromLine, state.contentBottom - state.cursorY);
    const fragmentHeight = slice2.height;
    const adjustedX = columnX(state.columnIndex) + offsetX + negativeLeftIndent;
    const adjustedWidth = effectiveColumnWidth - negativeLeftIndent - negativeRightIndent;
    const fragment = {
      kind: "para",
      blockId: block.id,
      fromLine,
      toLine: slice2.toLine,
      x: adjustedX,
      y: state.cursorY,
      width: adjustedWidth,
      ...computeFragmentPmRange(block, lines, fromLine, slice2.toLine)
    };
    if (didRemeasureForColumnWidth) {
      fragment.lines = lines.slice(fromLine, slice2.toLine);
    }
    if ((measure.marker || remeasuredMarkerInfo) && fromLine === 0) {
      const effectiveMarkerInfo = remeasuredMarkerInfo ?? measure.marker;
      fragment.markerWidth = effectiveMarkerInfo?.markerWidth ?? measure.marker?.markerWidth ?? 0;
      const markerTextWidth = remeasuredMarkerInfo?.markerTextWidth ?? measure.marker?.markerTextWidth;
      if (markerTextWidth != null) {
        fragment.markerTextWidth = markerTextWidth;
      }
      const gutterWidth = remeasuredMarkerInfo?.gutterWidth ?? measure.marker?.gutterWidth;
      if (gutterWidth != null) {
        fragment.markerGutter = gutterWidth;
      }
    }
    if (fromLine > 0) fragment.continuesFromPrev = true;
    if (slice2.toLine < lines.length) fragment.continuesOnNext = true;
    const floatAlignment = block.attrs?.floatAlignment;
    if (floatAlignment && (floatAlignment === "right" || floatAlignment === "center")) {
      let maxLineWidth = 0;
      for (let i = fromLine; i < slice2.toLine; i++) {
        if (lines[i].width > maxLineWidth) {
          maxLineWidth = lines[i].width;
        }
      }
      if (floatAlignment === "right") {
        fragment.x = columnX(state.columnIndex) + offsetX + (effectiveColumnWidth - maxLineWidth);
      } else if (floatAlignment === "center") {
        fragment.x = columnX(state.columnIndex) + offsetX + (effectiveColumnWidth - maxLineWidth) / 2;
      }
    }
    state.page.fragments.push(fragment);
    state.cursorY += fragmentHeight;
    lastState = state;
    fromLine = slice2.toLine;
  }
  if (lastState) {
    if (spacingAfter > 0) {
      let targetState = lastState;
      let appliedSpacingAfter = spacingAfter;
      if (targetState.cursorY + spacingAfter > targetState.contentBottom) {
        targetState = advanceColumn(targetState);
        appliedSpacingAfter = 0;
      } else {
        targetState.cursorY += spacingAfter;
      }
      targetState.trailingSpacing = appliedSpacingAfter;
    } else {
      lastState.trailingSpacing = 0;
    }
    lastState.lastParagraphStyleId = styleId;
  }
}
function layoutImageBlock({
  block,
  measure,
  columns,
  ensurePage,
  advanceColumn,
  columnX
}) {
  if (block.anchor?.isAnchored) {
    return;
  }
  const marginTop = Math.max(0, block.margin?.top ?? 0);
  const marginBottom = Math.max(0, block.margin?.bottom ?? 0);
  const marginLeft = Math.max(0, block.margin?.left ?? 0);
  const marginRight = Math.max(0, block.margin?.right ?? 0);
  const maxWidth = Math.max(0, columns.width - (marginLeft + marginRight));
  let width = measure.width;
  let height = measure.height;
  if (width > maxWidth && maxWidth > 0) {
    const scale = maxWidth / width;
    width = maxWidth;
    height *= scale;
  }
  let state = ensurePage();
  const pageContentHeight = Math.max(0, state.contentBottom - state.topMargin);
  if (height > pageContentHeight && pageContentHeight > 0) {
    const scale = pageContentHeight / height;
    height = pageContentHeight;
    width *= scale;
  }
  const requiredHeight = marginTop + height + marginBottom;
  if (state.cursorY + requiredHeight > state.contentBottom && state.cursorY > state.topMargin) {
    state = advanceColumn(state);
  }
  const pmRange = extractBlockPmRange(block);
  const aspectRatio = measure.width > 0 && measure.height > 0 ? measure.width / measure.height : 1;
  const minWidth = 20;
  const minHeight = minWidth / aspectRatio;
  const metadata = {
    originalWidth: measure.width,
    originalHeight: measure.height,
    maxWidth,
    maxHeight: pageContentHeight,
    aspectRatio,
    minWidth,
    minHeight
  };
  const fragment = {
    kind: "image",
    blockId: block.id,
    x: columnX(state.columnIndex) + marginLeft,
    y: state.cursorY + marginTop,
    width,
    height,
    pmStart: pmRange.pmStart,
    pmEnd: pmRange.pmEnd,
    metadata
  };
  state.page.fragments.push(fragment);
  state.cursorY += requiredHeight;
}
function layoutDrawingBlock({
  block,
  measure,
  columns,
  ensurePage,
  advanceColumn,
  columnX
}) {
  if (block.anchor?.isAnchored) {
    return;
  }
  const marginTop = Math.max(0, block.margin?.top ?? 0);
  const marginBottom = Math.max(0, block.margin?.bottom ?? 0);
  const marginLeft = Math.max(0, block.margin?.left ?? 0);
  const marginRight = Math.max(0, block.margin?.right ?? 0);
  const maxWidth = Math.max(0, columns.width - (marginLeft + marginRight));
  let width = measure.width;
  let height = measure.height;
  const attrs = block.attrs;
  const indentLeft = typeof attrs?.hrIndentLeft === "number" ? attrs.hrIndentLeft : 0;
  const indentRight = typeof attrs?.hrIndentRight === "number" ? attrs.hrIndentRight : 0;
  const maxWidthForBlock = attrs?.isFullWidth === true && maxWidth > 0 ? Math.max(1, maxWidth - indentLeft - indentRight) : maxWidth;
  if (width > maxWidthForBlock && maxWidthForBlock > 0) {
    const scale = maxWidthForBlock / width;
    width = maxWidthForBlock;
    height *= scale;
  }
  let state = ensurePage();
  const pageContentHeight = Math.max(0, state.contentBottom - state.topMargin);
  if (height > pageContentHeight && pageContentHeight > 0) {
    const scale = pageContentHeight / height;
    height = pageContentHeight;
    width *= scale;
  }
  const requiredHeight = marginTop + height + marginBottom;
  if (state.cursorY + requiredHeight > state.contentBottom && state.cursorY > state.topMargin) {
    state = advanceColumn(state);
  }
  const pmRange = extractBlockPmRange(block);
  const fragment = {
    kind: "drawing",
    blockId: block.id,
    drawingKind: block.drawingKind,
    x: columnX(state.columnIndex) + marginLeft + indentLeft,
    y: state.cursorY + marginTop,
    width,
    height,
    geometry: measure.geometry,
    scale: measure.scale,
    drawingContentId: block.drawingContentId,
    zIndex: block.zIndex,
    pmStart: pmRange.pmStart,
    pmEnd: pmRange.pmEnd
  };
  state.page.fragments.push(fragment);
  state.cursorY += requiredHeight;
}
function getTableIndentWidth(attrs) {
  if (!attrs) {
    return 0;
  }
  const tableIndent = attrs.tableIndent;
  if (!tableIndent || typeof tableIndent !== "object") {
    return 0;
  }
  const width = tableIndent.width;
  if (width === void 0 || width === null) {
    return 0;
  }
  if (typeof width !== "number") {
    return 0;
  }
  if (!Number.isFinite(width)) {
    return 0;
  }
  return width;
}
function applyTableIndent(x, width, indent) {
  return {
    x: x + indent,
    width: Math.max(0, width - indent)
  };
}
function resolveTableFrame(baseX, columnWidth, tableWidth, attrs) {
  const width = Math.min(columnWidth, tableWidth);
  const justification = typeof attrs?.justification === "string" ? attrs.justification : void 0;
  if (justification === "center") {
    return { x: baseX + Math.max(0, (columnWidth - width) / 2), width };
  }
  if (justification === "right" || justification === "end") {
    return { x: baseX + Math.max(0, columnWidth - width), width };
  }
  const tableIndent = getTableIndentWidth(attrs);
  return applyTableIndent(baseX, width, tableIndent);
}
function calculateColumnMinWidth() {
  const DEFAULT_MIN_WIDTH = 10;
  return DEFAULT_MIN_WIDTH;
}
function generateColumnBoundaries(measure) {
  const boundaries = [];
  let xPosition = 0;
  for (let i = 0; i < measure.columnWidths.length; i++) {
    const width = measure.columnWidths[i];
    const minWidth = calculateColumnMinWidth();
    const boundary = {
      index: i,
      x: xPosition,
      width,
      minWidth,
      resizable: true
      // All columns resizable initially
    };
    boundaries.push(boundary);
    xPosition += width;
  }
  return boundaries;
}
function countHeaderRows(block) {
  let count = 0;
  for (let i = 0; i < block.rows.length; i++) {
    const row = block.rows[i];
    const repeatHeader = row.attrs?.tableRowProperties?.repeatHeader;
    if (repeatHeader === true) {
      count++;
    } else {
      break;
    }
  }
  return count;
}
function sumRowHeights(rows, fromRow, toRow) {
  let total = 0;
  for (let i = fromRow; i < toRow && i < rows.length; i++) {
    total += rows[i].height;
  }
  return total;
}
function calculateFragmentHeight(fragment, measure, _headerCount) {
  let height = 0;
  if (fragment.repeatHeaderCount && fragment.repeatHeaderCount > 0) {
    height += sumRowHeights(measure.rows, 0, fragment.repeatHeaderCount);
  }
  height += sumRowHeights(measure.rows, fragment.fromRow, fragment.toRow);
  return height;
}
const MIN_PARTIAL_ROW_HEIGHT = 20;
function getCellLines(cell) {
  if (cell.blocks && cell.blocks.length > 0) {
    const allLines = [];
    for (const block of cell.blocks) {
      if (block.kind === "paragraph") {
        if (block.kind === "paragraph" && "lines" in block) {
          const paraBlock = block;
          if (paraBlock.lines) {
            allLines.push(...paraBlock.lines);
          }
        }
      }
    }
    return allLines;
  }
  if (cell.paragraph?.lines) {
    return cell.paragraph.lines;
  }
  return [];
}
function getCellPadding(cellIdx, blockRow) {
  const padding = blockRow?.cells?.[cellIdx]?.attrs?.padding ?? {};
  return {
    top: padding.top ?? 2,
    bottom: padding.bottom ?? 2,
    left: padding.left ?? 4,
    right: padding.right ?? 4
  };
}
function getCellTotalLines(cell) {
  return getCellLines(cell).length;
}
const ROW_HEIGHT_EPSILON = 0.1;
function getRowContentHeight(blockRow, rowMeasure) {
  let contentHeight = 0;
  for (let cellIdx = 0; cellIdx < rowMeasure.cells.length; cellIdx++) {
    const cell = rowMeasure.cells[cellIdx];
    const cellPadding = getCellPadding(cellIdx, blockRow);
    const paddingTotal = cellPadding.top + cellPadding.bottom;
    const lines = getCellLines(cell);
    const linesHeight = lines.reduce((sum, line) => sum + (line.lineHeight || 0), 0);
    contentHeight = Math.max(contentHeight, linesHeight + paddingTotal);
  }
  return contentHeight;
}
function hasExplicitRowHeightSlack(blockRow, rowMeasure) {
  const rowHeightSpec = blockRow?.attrs?.rowHeight;
  if (!rowHeightSpec || rowHeightSpec.value == null || !Number.isFinite(rowHeightSpec.value)) {
    return false;
  }
  const contentHeight = getRowContentHeight(blockRow, rowMeasure);
  return rowMeasure.height > contentHeight + ROW_HEIGHT_EPSILON;
}
function mergePmRange(target, range) {
  if (typeof range.pmStart === "number") {
    target.pmStart = target.pmStart == null ? range.pmStart : Math.min(target.pmStart, range.pmStart);
  }
  if (typeof range.pmEnd === "number") {
    target.pmEnd = target.pmEnd == null ? range.pmEnd : Math.max(target.pmEnd, range.pmEnd);
  }
}
function computeCellPmRange(cell, cellMeasure, fromLine, toLine) {
  const range = {};
  if (!cell || !cellMeasure) return range;
  const cellBlocks = cell.blocks ?? (cell.paragraph ? [cell.paragraph] : []);
  const blockMeasures = cellMeasure.blocks ?? (cellMeasure.paragraph ? [cellMeasure.paragraph] : []);
  const maxBlocks = Math.min(cellBlocks.length, blockMeasures.length);
  let cumulativeLineCount = 0;
  for (let i = 0; i < maxBlocks; i++) {
    const block = cellBlocks[i];
    const blockMeasure = blockMeasures[i];
    if (blockMeasure.kind === "paragraph" && block?.kind === "paragraph") {
      const paraMeasure = blockMeasure;
      const lines = paraMeasure.lines;
      const blockLineCount = lines?.length ?? 0;
      const blockStartGlobal = cumulativeLineCount;
      const blockEndGlobal = cumulativeLineCount + blockLineCount;
      const localFrom = Math.max(fromLine, blockStartGlobal) - blockStartGlobal;
      const localTo = Math.min(toLine, blockEndGlobal) - blockStartGlobal;
      if (lines && lines.length > 0 && localFrom < localTo) {
        mergePmRange(range, computeFragmentPmRange(block, lines, localFrom, localTo));
      } else {
        mergePmRange(range, extractBlockPmRange(block));
      }
      cumulativeLineCount += blockLineCount;
      continue;
    }
    mergePmRange(range, extractBlockPmRange(block));
  }
  return range;
}
function computeTableFragmentPmRange(block, measure, fromRow, toRow, partialRow) {
  const range = {};
  for (let rowIndex = fromRow; rowIndex < toRow; rowIndex++) {
    const row = block.rows[rowIndex];
    const rowMeasure = measure.rows[rowIndex];
    if (!row || !rowMeasure) continue;
    const isPartial = partialRow?.rowIndex === rowIndex;
    const cellCount = Math.min(row.cells.length, rowMeasure.cells.length);
    for (let cellIndex = 0; cellIndex < cellCount; cellIndex++) {
      const cell = row.cells[cellIndex];
      const cellMeasure = rowMeasure.cells[cellIndex];
      if (!cell || !cellMeasure) continue;
      const totalLines = getCellTotalLines(cellMeasure);
      let fromLine = 0;
      let toLine = totalLines;
      if (isPartial) {
        const hasValidFromLineByCell = partialRow?.fromLineByCell && cellIndex < partialRow.fromLineByCell.length;
        const hasValidToLineByCell = partialRow?.toLineByCell && cellIndex < partialRow.toLineByCell.length;
        if (hasValidFromLineByCell) {
          const rawFrom = partialRow.fromLineByCell[cellIndex];
          if (typeof rawFrom === "number" && rawFrom >= 0) {
            fromLine = rawFrom;
          }
        }
        if (hasValidToLineByCell) {
          const rawTo = partialRow.toLineByCell[cellIndex];
          if (typeof rawTo === "number") {
            toLine = rawTo === -1 ? totalLines : rawTo;
          }
        }
      }
      fromLine = Math.max(0, Math.min(fromLine, totalLines));
      toLine = Math.max(0, Math.min(toLine, totalLines));
      if (toLine < fromLine) {
        toLine = fromLine;
      }
      mergePmRange(range, computeCellPmRange(cell, cellMeasure, fromLine, toLine));
    }
  }
  return range;
}
function applyTableFragmentPmRange(fragment, block, measure) {
  const range = computeTableFragmentPmRange(block, measure, fragment.fromRow, fragment.toRow, fragment.partialRow);
  if (range.pmStart != null) {
    fragment.pmStart = range.pmStart;
  }
  if (range.pmEnd != null) {
    fragment.pmEnd = range.pmEnd;
  }
}
function computePartialRow(rowIndex, blockRow, measure, availableHeight, fromLineByCell) {
  const row = measure.rows[rowIndex];
  if (!row) {
    throw new Error(`Invalid rowIndex ${rowIndex}: measure.rows has ${measure.rows.length} rows`);
  }
  const cellCount = row.cells.length;
  const startLines = fromLineByCell || new Array(cellCount).fill(0);
  const toLineByCell = [];
  const heightByCell = [];
  const cellPaddings = row.cells.map((_2, idx) => getCellPadding(idx, blockRow));
  for (let cellIdx = 0; cellIdx < cellCount; cellIdx++) {
    const cell = row.cells[cellIdx];
    const startLine = startLines[cellIdx] || 0;
    const cellPadding = cellPaddings[cellIdx];
    const availableForLines = Math.max(0, availableHeight - (cellPadding.top + cellPadding.bottom));
    const lines = getCellLines(cell);
    let cumulativeHeight = 0;
    let cutLine = startLine;
    for (let i = startLine; i < lines.length; i++) {
      const lineHeight2 = lines[i].lineHeight || 0;
      if (cumulativeHeight + lineHeight2 > availableForLines) {
        break;
      }
      cumulativeHeight += lineHeight2;
      cutLine = i + 1;
    }
    toLineByCell.push(cutLine);
    heightByCell.push(cumulativeHeight);
  }
  let actualPartialHeight = 0;
  let maxPaddingTotal = 0;
  for (let cellIdx = 0; cellIdx < cellCount; cellIdx++) {
    const cellPadding = cellPaddings[cellIdx];
    const paddingTotal = cellPadding.top + cellPadding.bottom;
    maxPaddingTotal = Math.max(maxPaddingTotal, paddingTotal);
    actualPartialHeight = Math.max(actualPartialHeight, heightByCell[cellIdx] + paddingTotal);
  }
  const madeProgress = toLineByCell.some((cutLine, idx) => cutLine > (startLines[idx] || 0));
  const isFirstPart = startLines.every((l) => l === 0);
  const allCellsExhausted = toLineByCell.every((cutLine, idx) => {
    const totalLines = getCellTotalLines(row.cells[idx]);
    return cutLine >= totalLines;
  });
  const isLastPart = allCellsExhausted || !madeProgress;
  if (actualPartialHeight === 0 && isFirstPart) {
    actualPartialHeight = maxPaddingTotal;
  }
  return {
    rowIndex,
    fromLineByCell: startLines,
    toLineByCell,
    isFirstPart,
    isLastPart,
    partialHeight: actualPartialHeight
  };
}
function findSplitPoint(block, measure, startRow, availableHeight, fullPageHeight, _pendingPartialRow) {
  let accumulatedHeight = 0;
  let lastFitRow = startRow;
  for (let i = startRow; i < block.rows.length; i++) {
    const row = block.rows[i];
    const rowMeasure = measure.rows[i];
    const rowHeight = rowMeasure?.height || 0;
    let cantSplit = row.attrs?.tableRowProperties?.cantSplit === true;
    if (rowMeasure && hasExplicitRowHeightSlack(row, rowMeasure) && (!fullPageHeight || rowHeight <= fullPageHeight)) {
      cantSplit = true;
    }
    if (accumulatedHeight + rowHeight <= availableHeight) {
      accumulatedHeight += rowHeight;
      lastFitRow = i + 1;
    } else {
      const remainingHeight = availableHeight - accumulatedHeight;
      if (fullPageHeight && rowHeight > fullPageHeight) {
        const partialRow = computePartialRow(i, block.rows[i], measure, remainingHeight);
        return { endRow: i + 1, partialRow };
      }
      if (cantSplit) {
        if (lastFitRow === startRow) {
          return { endRow: startRow, partialRow: null };
        }
        return { endRow: lastFitRow, partialRow: null };
      }
      if (remainingHeight >= MIN_PARTIAL_ROW_HEIGHT) {
        const partialRow = computePartialRow(i, block.rows[i], measure, remainingHeight);
        const hasContent = partialRow.toLineByCell.some(
          (cutLine, idx) => cutLine > (partialRow.fromLineByCell[idx] || 0)
        );
        if (hasContent) {
          return { endRow: i + 1, partialRow };
        }
      }
      return { endRow: lastFitRow, partialRow: null };
    }
  }
  return { endRow: block.rows.length, partialRow: null };
}
function generateFragmentMetadata(measure, _fromRow, _toRow, _repeatHeaderCount) {
  return {
    columnBoundaries: generateColumnBoundaries(measure),
    coordinateSystem: "fragment"
  };
}
function layoutMonolithicTable(context) {
  let state = context.ensurePage();
  if (state.cursorY + context.measure.totalHeight > state.contentBottom && state.page.fragments.length > 0) {
    state = context.advanceColumn(state);
  }
  state = context.ensurePage();
  const height = Math.min(context.measure.totalHeight, state.contentBottom - state.cursorY);
  const metadata = {
    columnBoundaries: generateColumnBoundaries(context.measure),
    coordinateSystem: "fragment"
  };
  const baseX = context.columnX(state.columnIndex);
  const baseWidth = Math.min(context.columnWidth, context.measure.totalWidth || context.columnWidth);
  const { x, width } = resolveTableFrame(baseX, context.columnWidth, baseWidth, context.block.attrs);
  const fragment = {
    kind: "table",
    blockId: context.block.id,
    fromRow: 0,
    toRow: context.block.rows.length,
    x,
    y: state.cursorY,
    width,
    height,
    metadata
  };
  applyTableFragmentPmRange(fragment, context.block, context.measure);
  state.page.fragments.push(fragment);
  state.cursorY += height;
}
function layoutTableBlock({
  block,
  measure,
  columnWidth,
  ensurePage,
  advanceColumn,
  columnX
}) {
  if (block.anchor?.isAnchored) {
    return;
  }
  const tableProps = block.attrs?.tableProperties;
  const floatingProps = tableProps?.floatingTableProperties;
  if (floatingProps && Object.keys(floatingProps).length > 0) {
    layoutMonolithicTable({ block, measure, columnWidth, ensurePage, advanceColumn, columnX });
    return;
  }
  const headerCount = countHeaderRows(block);
  const headerHeight = headerCount > 0 ? sumRowHeights(measure.rows, 0, headerCount) : 0;
  let state = ensurePage();
  const availableHeight = state.contentBottom - state.cursorY;
  const hasPriorFragments = state.page.fragments.length > 0;
  const hasMeasuredRows = measure.rows.length > 0 && block.rows.length > 0;
  if (hasMeasuredRows && hasPriorFragments) {
    const firstRowCantSplit = block.rows[0]?.attrs?.tableRowProperties?.cantSplit === true;
    const firstRowHeight = measure.rows[0]?.height ?? measure.totalHeight ?? 0;
    const firstRowSlack = hasExplicitRowHeightSlack(block.rows[0], measure.rows[0]);
    const firstRowFitsPage = firstRowHeight <= state.contentBottom;
    const treatFirstRowAsCantSplit = firstRowCantSplit || firstRowSlack && firstRowFitsPage;
    if (treatFirstRowAsCantSplit) {
      if (firstRowHeight > availableHeight) {
        state = advanceColumn(state);
      }
    } else {
      const partial = computePartialRow(0, block.rows[0], measure, availableHeight);
      const madeProgress = partial.toLineByCell.some(
        (toLine, idx) => toLine > (partial.fromLineByCell[idx] || 0)
      );
      const hasRenderableHeight = partial.partialHeight > 0;
      if (!madeProgress || !hasRenderableHeight) {
        state = advanceColumn(state);
      }
    }
  } else if (hasPriorFragments) {
    let minRequiredHeight = 0;
    if (measure.rows.length > 0) {
      minRequiredHeight = sumRowHeights(measure.rows, 0, 1);
    } else if (measure.totalHeight > 0) {
      minRequiredHeight = measure.totalHeight;
    }
    if (minRequiredHeight > availableHeight) {
      state = advanceColumn(state);
    }
  }
  let currentRow = 0;
  let isTableContinuation = false;
  let pendingPartialRow = null;
  if (block.rows.length === 0 && measure.totalHeight > 0) {
    const height = Math.min(measure.totalHeight, state.contentBottom - state.cursorY);
    const metadata = {
      columnBoundaries: generateColumnBoundaries(measure),
      coordinateSystem: "fragment"
    };
    const baseX = columnX(state.columnIndex);
    const baseWidth = Math.min(columnWidth, measure.totalWidth || columnWidth);
    const { x, width } = resolveTableFrame(baseX, columnWidth, baseWidth, block.attrs);
    const fragment = {
      kind: "table",
      blockId: block.id,
      fromRow: 0,
      toRow: 0,
      x,
      y: state.cursorY,
      width,
      height,
      metadata
    };
    applyTableFragmentPmRange(fragment, block, measure);
    state.page.fragments.push(fragment);
    state.cursorY += height;
    return;
  }
  while (currentRow < block.rows.length || pendingPartialRow !== null) {
    state = ensurePage();
    const availableHeight2 = state.contentBottom - state.cursorY;
    let repeatHeaderCount = 0;
    if (currentRow === 0 && !pendingPartialRow) {
      repeatHeaderCount = 0;
    } else {
      if (headerCount > 0 && headerHeight <= availableHeight2) {
        repeatHeaderCount = headerCount;
      } else if (headerCount > 0 && headerHeight > availableHeight2) {
        repeatHeaderCount = 0;
      }
    }
    const availableForBody = repeatHeaderCount > 0 ? availableHeight2 - headerHeight : availableHeight2;
    const fullPageHeight = state.contentBottom;
    if (pendingPartialRow !== null) {
      const rowIndex = pendingPartialRow.rowIndex;
      const fromLineByCell = pendingPartialRow.toLineByCell;
      const continuationPartialRow = computePartialRow(
        rowIndex,
        block.rows[rowIndex],
        measure,
        availableForBody,
        fromLineByCell
      );
      const madeProgress = continuationPartialRow.toLineByCell.some(
        (toLine, idx) => toLine > (fromLineByCell[idx] || 0)
      );
      const hasRemainingLinesAfterContinuation = continuationPartialRow.toLineByCell.some(
        (toLine, idx) => {
          const totalLines = getCellTotalLines(measure.rows[rowIndex].cells[idx]);
          return toLine < totalLines;
        }
      );
      const hadRemainingLinesBefore = fromLineByCell.some((fromLine, idx) => {
        const totalLines = getCellTotalLines(measure.rows[rowIndex].cells[idx]);
        return fromLine < totalLines;
      });
      const fragmentHeight2 = continuationPartialRow.partialHeight + (repeatHeaderCount > 0 ? headerHeight : 0);
      if (fragmentHeight2 > 0 && madeProgress) {
        const baseX2 = columnX(state.columnIndex);
        const baseWidth2 = Math.min(columnWidth, measure.totalWidth || columnWidth);
        const { x: x2, width: width2 } = resolveTableFrame(baseX2, columnWidth, baseWidth2, block.attrs);
        const fragment2 = {
          kind: "table",
          blockId: block.id,
          fromRow: rowIndex,
          toRow: rowIndex + 1,
          x: x2,
          y: state.cursorY,
          width: width2,
          height: fragmentHeight2,
          continuesFromPrev: true,
          continuesOnNext: hasRemainingLinesAfterContinuation || rowIndex + 1 < block.rows.length,
          repeatHeaderCount,
          partialRow: continuationPartialRow,
          metadata: generateFragmentMetadata(measure)
        };
        applyTableFragmentPmRange(fragment2, block, measure);
        state.page.fragments.push(fragment2);
        state.cursorY += fragmentHeight2;
      }
      const rowComplete = !hasRemainingLinesAfterContinuation;
      if (rowComplete) {
        currentRow = rowIndex + 1;
        pendingPartialRow = null;
      } else if (!madeProgress && hadRemainingLinesBefore) {
        state = advanceColumn(state);
      } else {
        pendingPartialRow = continuationPartialRow;
      }
      isTableContinuation = true;
      continue;
    }
    const bodyStartRow = currentRow;
    const { endRow, partialRow } = findSplitPoint(block, measure, bodyStartRow, availableForBody, fullPageHeight);
    if (endRow === bodyStartRow && partialRow === null && state.page.fragments.length > 0) {
      state = advanceColumn(state);
      continue;
    }
    if (endRow === bodyStartRow && partialRow === null) {
      const forcedPartialRow = computePartialRow(bodyStartRow, block.rows[bodyStartRow], measure, availableForBody);
      const forcedEndRow = bodyStartRow + 1;
      const fragmentHeight2 = forcedPartialRow.partialHeight + (repeatHeaderCount > 0 ? headerHeight : 0);
      const baseX2 = columnX(state.columnIndex);
      const baseWidth2 = Math.min(columnWidth, measure.totalWidth || columnWidth);
      const { x: x2, width: width2 } = resolveTableFrame(baseX2, columnWidth, baseWidth2, block.attrs);
      const fragment2 = {
        kind: "table",
        blockId: block.id,
        fromRow: bodyStartRow,
        toRow: forcedEndRow,
        x: x2,
        y: state.cursorY,
        width: width2,
        height: fragmentHeight2,
        continuesFromPrev: isTableContinuation,
        continuesOnNext: !forcedPartialRow.isLastPart || forcedEndRow < block.rows.length,
        repeatHeaderCount,
        partialRow: forcedPartialRow,
        metadata: generateFragmentMetadata(measure)
      };
      applyTableFragmentPmRange(fragment2, block, measure);
      state.page.fragments.push(fragment2);
      state.cursorY += fragmentHeight2;
      pendingPartialRow = forcedPartialRow;
      isTableContinuation = true;
      continue;
    }
    let fragmentHeight;
    if (partialRow) {
      const fullRowsHeight = sumRowHeights(measure.rows, bodyStartRow, endRow - 1);
      fragmentHeight = fullRowsHeight + partialRow.partialHeight + (repeatHeaderCount > 0 ? headerHeight : 0);
    } else {
      fragmentHeight = calculateFragmentHeight(
        { fromRow: bodyStartRow, toRow: endRow, repeatHeaderCount },
        measure
      );
    }
    const baseX = columnX(state.columnIndex);
    const baseWidth = Math.min(columnWidth, measure.totalWidth || columnWidth);
    const { x, width } = resolveTableFrame(baseX, columnWidth, baseWidth, block.attrs);
    const fragment = {
      kind: "table",
      blockId: block.id,
      fromRow: bodyStartRow,
      toRow: endRow,
      x,
      y: state.cursorY,
      width,
      height: fragmentHeight,
      continuesFromPrev: isTableContinuation,
      continuesOnNext: endRow < block.rows.length || (partialRow ? !partialRow.isLastPart : false),
      repeatHeaderCount,
      partialRow: partialRow || void 0,
      metadata: generateFragmentMetadata(measure)
    };
    applyTableFragmentPmRange(fragment, block, measure);
    state.page.fragments.push(fragment);
    state.cursorY += fragmentHeight;
    if (partialRow && !partialRow.isLastPart) {
      pendingPartialRow = partialRow;
      currentRow = partialRow.rowIndex;
    } else {
      currentRow = endRow;
      pendingPartialRow = null;
    }
    isTableContinuation = true;
  }
}
function createAnchoredTableFragment(block, measure, x, y2) {
  const metadata = {
    columnBoundaries: generateColumnBoundaries(measure),
    coordinateSystem: "fragment"
  };
  const fragment = {
    kind: "table",
    blockId: block.id,
    fromRow: 0,
    toRow: block.rows.length,
    x,
    y: y2,
    width: measure.totalWidth ?? 0,
    height: measure.totalHeight ?? 0,
    metadata
  };
  applyTableFragmentPmRange(fragment, block, measure);
  return fragment;
}
function isPageRelativeAnchor(block) {
  const vRelativeFrom = block.anchor?.vRelativeFrom;
  return vRelativeFrom === "margin" || vRelativeFrom === "page";
}
function collectPreRegisteredAnchors(blocks, measures) {
  const result = [];
  const len = Math.min(blocks.length, measures.length);
  for (let i = 0; i < len; i += 1) {
    const block = blocks[i];
    const measure = measures[i];
    const isImage = block.kind === "image" && measure?.kind === "image";
    const isDrawing = block.kind === "drawing" && measure?.kind === "drawing";
    if (!isImage && !isDrawing) continue;
    const drawingBlock = block;
    const drawingMeasure = measure;
    if (!drawingBlock.anchor?.isAnchored) {
      continue;
    }
    if (isPageRelativeAnchor(drawingBlock)) {
      result.push({ block: drawingBlock, measure: drawingMeasure });
    }
  }
  return result;
}
function collectAnchoredDrawings(blocks, measures) {
  const map3 = /* @__PURE__ */ new Map();
  const len = Math.min(blocks.length, measures.length);
  const paragraphIndexById = /* @__PURE__ */ new Map();
  for (let i = 0; i < len; i += 1) {
    const block = blocks[i];
    if (block.kind === "paragraph") {
      paragraphIndexById.set(block.id, i);
    }
  }
  const nearestPrevParagraph = (fromIndex) => {
    for (let i = fromIndex - 1; i >= 0; i -= 1) {
      if (blocks[i].kind === "paragraph") return i;
    }
    return null;
  };
  const nearestNextParagraph = (fromIndex) => {
    for (let i = fromIndex + 1; i < len; i += 1) {
      if (blocks[i].kind === "paragraph") return i;
    }
    return null;
  };
  for (let i = 0; i < len; i += 1) {
    const block = blocks[i];
    const measure = measures[i];
    const isImage = block.kind === "image" && measure?.kind === "image";
    const isDrawing = block.kind === "drawing" && measure?.kind === "drawing";
    if (!isImage && !isDrawing) continue;
    const drawingBlock = block;
    const drawingMeasure = measure;
    if (!drawingBlock.anchor?.isAnchored) {
      continue;
    }
    if (isPageRelativeAnchor(drawingBlock)) {
      continue;
    }
    const anchorParagraphId = typeof drawingBlock.attrs === "object" && drawingBlock.attrs ? drawingBlock.attrs.anchorParagraphId : void 0;
    let anchorParaIndex = typeof anchorParagraphId === "string" ? paragraphIndexById.get(anchorParagraphId) ?? null : null;
    if (anchorParaIndex == null) {
      anchorParaIndex = nearestPrevParagraph(i);
    }
    if (anchorParaIndex == null) anchorParaIndex = nearestNextParagraph(i);
    if (anchorParaIndex == null) continue;
    const list = map3.get(anchorParaIndex) ?? [];
    list.push({ block: drawingBlock, measure: drawingMeasure });
    map3.set(anchorParaIndex, list);
  }
  return map3;
}
function collectAnchoredTables(blocks, measures) {
  const map3 = /* @__PURE__ */ new Map();
  const paragraphIndexById = /* @__PURE__ */ new Map();
  for (let i = 0; i < blocks.length; i += 1) {
    const block = blocks[i];
    if (block.kind === "paragraph") {
      paragraphIndexById.set(block.id, i);
    }
  }
  const nearestPrevParagraph = (fromIndex) => {
    for (let i = fromIndex - 1; i >= 0; i -= 1) {
      if (blocks[i].kind === "paragraph") return i;
    }
    return null;
  };
  const nearestNextParagraph = (fromIndex) => {
    for (let i = fromIndex + 1; i < blocks.length; i += 1) {
      if (blocks[i].kind === "paragraph") return i;
    }
    return null;
  };
  for (let i = 0; i < blocks.length; i += 1) {
    const block = blocks[i];
    const measure = measures[i];
    if (block.kind !== "table" || measure?.kind !== "table") continue;
    const tableBlock = block;
    const tableMeasure = measure;
    if (!tableBlock.anchor?.isAnchored) continue;
    const anchorParagraphId = typeof tableBlock.attrs === "object" && tableBlock.attrs ? tableBlock.attrs.anchorParagraphId : void 0;
    let anchorParaIndex = typeof anchorParagraphId === "string" ? paragraphIndexById.get(anchorParagraphId) ?? null : null;
    if (anchorParaIndex == null) {
      anchorParaIndex = nearestPrevParagraph(i);
    }
    if (anchorParaIndex == null) anchorParaIndex = nearestNextParagraph(i);
    if (anchorParaIndex == null) continue;
    const list = map3.get(anchorParaIndex) ?? [];
    list.push({ block: tableBlock, measure: tableMeasure });
    map3.set(anchorParaIndex, list);
  }
  return map3;
}
function createPaginator(opts) {
  const states = [];
  const pages = [];
  const getActiveColumnsForState = (state) => {
    if (state.activeConstraintIndex >= 0 && state.constraintBoundaries[state.activeConstraintIndex]) {
      return state.constraintBoundaries[state.activeConstraintIndex].columns;
    }
    return opts.getActiveColumns();
  };
  const columnX = (columnIndex) => {
    const cols = opts.getCurrentColumns();
    return opts.margins.left + columnIndex * (cols.width + cols.gap);
  };
  const startNewPage = () => {
    if (opts.onNewPage) opts.onNewPage(void 0);
    const topMargin = opts.getActiveTopMargin();
    const bottomMargin = opts.getActiveBottomMargin();
    const headerDistance = opts.getActiveHeaderDistance();
    const footerDistance = opts.getActiveFooterDistance();
    const currentPageSize = opts.getActivePageSize();
    const defaultPageSize = opts.getDefaultPageSize();
    const contentBottom = currentPageSize.h - bottomMargin;
    const contentHeight = contentBottom - topMargin;
    if (contentHeight <= 0) {
      throw new Error("layoutDocument: pageSize and margins yield non-positive content area");
    }
    const pageMargins = {
      top: topMargin,
      bottom: bottomMargin,
      left: opts.margins.left,
      right: opts.margins.right,
      header: headerDistance,
      footer: footerDistance
    };
    const pageSizeOverride = currentPageSize.w !== defaultPageSize.w || currentPageSize.h !== defaultPageSize.h ? currentPageSize : void 0;
    const state = {
      page: opts.createPage(pages.length + 1, pageMargins, pageSizeOverride),
      cursorY: topMargin,
      columnIndex: 0,
      topMargin,
      contentBottom,
      constraintBoundaries: [],
      activeConstraintIndex: -1,
      trailingSpacing: 0,
      lastParagraphStyleId: void 0
    };
    states.push(state);
    pages.push(state.page);
    if (opts.onNewPage) opts.onNewPage(state);
    return state;
  };
  const ensurePage = () => {
    const last = states[states.length - 1];
    if (last) return last;
    return startNewPage();
  };
  const advanceColumn = (state) => {
    const activeCols = getActiveColumnsForState(state);
    if (state.columnIndex < activeCols.count - 1) {
      state.columnIndex += 1;
      if (state.activeConstraintIndex >= 0 && state.constraintBoundaries[state.activeConstraintIndex]) {
        state.cursorY = state.constraintBoundaries[state.activeConstraintIndex].y;
      } else {
        state.cursorY = state.topMargin;
      }
      state.trailingSpacing = 0;
      state.lastParagraphStyleId = void 0;
      return state;
    }
    return startNewPage();
  };
  return {
    pages,
    states,
    startNewPage,
    ensurePage,
    advanceColumn,
    columnX,
    getActiveColumnsForState
  };
}
function toUpperRoman(num) {
  if (num < 1 || num > 3999) {
    return String(num);
  }
  const values = [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];
  const numerals = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"];
  let result = "";
  let remaining = num;
  for (let i = 0; i < values.length; i++) {
    while (remaining >= values[i]) {
      result += numerals[i];
      remaining -= values[i];
    }
  }
  return result;
}
function toLowerRoman(num) {
  return toUpperRoman(num).toLowerCase();
}
function toUpperLetter(num) {
  if (num < 1) {
    return "A";
  }
  let result = "";
  let n = num;
  while (n > 0) {
    const remainder = (n - 1) % 26;
    result = String.fromCharCode(65 + remainder) + result;
    n = Math.floor((n - 1) / 26);
  }
  return result;
}
function toLowerLetter(num) {
  return toUpperLetter(num).toLowerCase();
}
function formatPageNumber(pageNumber, format) {
  const num = Math.max(1, pageNumber);
  switch (format) {
    case "decimal":
      return String(num);
    case "upperRoman":
      return toUpperRoman(num);
    case "lowerRoman":
      return toLowerRoman(num);
    case "upperLetter":
      return toUpperLetter(num);
    case "lowerLetter":
      return toLowerLetter(num);
    case "numberInDash":
      return `-${num}-`;
    default:
      return String(num);
  }
}
function computeDisplayPageNumber(pages, sections) {
  const result = [];
  if (pages.length === 0) {
    return result;
  }
  const sectionMap = /* @__PURE__ */ new Map();
  for (const section of sections) {
    sectionMap.set(section.sectionIndex, section);
  }
  let runningCounter = 1;
  let currentSectionIndex = -1;
  for (let i = 0; i < pages.length; i++) {
    const page = pages[i];
    const pageSectionIndex = page.sectionIndex ?? 0;
    if (pageSectionIndex !== currentSectionIndex) {
      const sectionMetadata2 = sectionMap.get(pageSectionIndex);
      if (sectionMetadata2?.numbering?.start !== void 0) {
        runningCounter = sectionMetadata2.numbering.start;
      }
      currentSectionIndex = pageSectionIndex;
    }
    const sectionMetadata = sectionMap.get(pageSectionIndex);
    const format = sectionMetadata?.numbering?.format ?? "decimal";
    const displayNumber = runningCounter;
    const displayText = formatPageNumber(displayNumber, format);
    result.push({
      physicalPage: page.number,
      displayNumber,
      displayText,
      sectionIndex: pageSectionIndex
    });
    runningCounter++;
  }
  return result;
}
const DEFAULT_BALANCING_CONFIG = {
  // Max 10 iterations to find balance
  minColumnHeight: 20
  // Minimum 20px content per column
};
function getFragmentHeight(fragment, measureMap) {
  if (fragment.kind === "para") {
    const measure = measureMap.get(fragment.blockId);
    if (!measure || measure.kind !== "paragraph" || !measure.lines) {
      return 0;
    }
    let sum = 0;
    const fromLine = fragment.fromLine ?? 0;
    const toLine = fragment.toLine ?? measure.lines.length;
    for (let i = fromLine; i < toLine; i++) {
      sum += measure.lines[i]?.lineHeight ?? 0;
    }
    return sum;
  }
  if (fragment.kind === "image" || fragment.kind === "drawing" || fragment.kind === "table") {
    if (typeof fragment.height === "number") {
      return fragment.height;
    }
    const measure = measureMap.get(fragment.blockId);
    if (measure && typeof measure.height === "number") {
      return measure.height;
    }
  }
  return 0;
}
function balancePageColumns(fragments, columns, margins, topMargin, measureMap) {
  if (columns.count <= 1 || fragments.length === 0) {
    return;
  }
  const columnX = (columnIndex) => {
    return margins.left + columnIndex * (columns.width + columns.gap);
  };
  const rowMap = /* @__PURE__ */ new Map();
  fragments.forEach((fragment, idx) => {
    const y2 = Math.round(fragment.y);
    if (!rowMap.has(y2)) {
      rowMap.set(y2, []);
    }
    const height = getFragmentHeight(fragment, measureMap);
    rowMap.get(y2).push({
      fragment,
      height,
      originalIndex: idx
    });
  });
  const sortedRows = [...rowMap.entries()].sort((a, b2) => a[0] - b2[0]);
  let totalHeight = 0;
  for (const [, rowFragments] of sortedRows) {
    const maxHeight = Math.max(...rowFragments.map((f) => f.height));
    totalHeight += maxHeight;
  }
  const targetHeight = totalHeight / columns.count;
  if (targetHeight < DEFAULT_BALANCING_CONFIG.minColumnHeight) {
    return;
  }
  let currentColumn = 0;
  let currentColumnHeight = 0;
  let currentY = topMargin;
  for (const [, rowFragments] of sortedRows) {
    const rowHeight = Math.max(...rowFragments.map((f) => f.height));
    if (currentColumnHeight > 0 && currentColumnHeight + rowHeight >= targetHeight && currentColumn < columns.count - 1) {
      currentColumn++;
      currentColumnHeight = 0;
      currentY = topMargin;
    }
    const colX = columnX(currentColumn);
    for (const info of rowFragments) {
      info.fragment.x = colX;
      info.fragment.y = currentY;
      info.fragment.width = columns.width;
    }
    currentColumnHeight += rowHeight;
    currentY += rowHeight;
  }
}
function resolvePageNumberTokens(layout, blocks, measures, numberingCtx) {
  const affectedBlockIds = /* @__PURE__ */ new Set();
  const updatedBlocks = /* @__PURE__ */ new Map();
  if (!layout?.pages || layout.pages.length === 0) {
    return { affectedBlockIds, updatedBlocks };
  }
  if (!numberingCtx || !numberingCtx.displayPages || numberingCtx.totalPages < 1) {
    console.warn("[resolvePageTokens] Invalid numbering context - skipping resolution");
    return { affectedBlockIds, updatedBlocks };
  }
  const blockMap = /* @__PURE__ */ new Map();
  const blockHasTokensFlags = /* @__PURE__ */ new Map();
  for (let i = 0; i < blocks.length; i++) {
    const block = blocks[i];
    blockMap.set(block.id, block);
    if (block.kind === "paragraph" && block.attrs && "hasPageTokens" in block.attrs) {
      blockHasTokensFlags.set(block.id, Boolean(block.attrs.hasPageTokens));
    }
  }
  const totalPagesStr = String(numberingCtx.totalPages);
  const processedBlocks = /* @__PURE__ */ new Set();
  for (const page of layout.pages) {
    const pageIndex = page.number - 1;
    const displayPageInfo = numberingCtx.displayPages[pageIndex];
    if (!displayPageInfo) {
      console.warn(`[resolvePageTokens] No display page info for page ${page.number} - skipping`);
      continue;
    }
    const displayPageText = displayPageInfo.displayText;
    for (const fragment of page.fragments) {
      if (fragment.kind !== "para") continue;
      const blockId = fragment.blockId;
      if (processedBlocks.has(blockId)) continue;
      const hasTokensFlag = blockHasTokensFlags.get(blockId);
      if (hasTokensFlag === false) continue;
      const block = blockMap.get(blockId);
      if (!block || block.kind !== "paragraph") continue;
      const wasModified = hasPageTokens$1(block);
      if (!wasModified) {
        processedBlocks.add(blockId);
        continue;
      }
      const clonedBlock = cloneBlockWithResolvedTokens(block, displayPageText, totalPagesStr);
      updatedBlocks.set(blockId, clonedBlock);
      affectedBlockIds.add(blockId);
      processedBlocks.add(blockId);
    }
  }
  return { affectedBlockIds, updatedBlocks };
}
function hasPageTokens$1(block) {
  for (const run of block.runs) {
    if ("token" in run && (run.token === "pageNumber" || run.token === "totalPageCount")) {
      return true;
    }
  }
  return false;
}
function cloneBlockWithResolvedTokens(block, displayPageText, totalPagesStr) {
  const clonedRuns = block.runs.map((run) => {
    if ("token" in run && run.token) {
      if (run.token === "pageNumber") {
        const { token: _token, ...runWithoutToken } = run;
        return {
          ...runWithoutToken,
          text: displayPageText
        };
      } else if (run.token === "totalPageCount") {
        const { token: _token, ...runWithoutToken } = run;
        return {
          ...runWithoutToken,
          text: totalPagesStr
        };
      }
    }
    return run;
  });
  return {
    ...block,
    runs: clonedRuns
  };
}
const DEFAULT_PARAGRAPH_LINE_HEIGHT_PX = 20;
function hasHeight(fragment) {
  return fragment.kind === "image" || fragment.kind === "drawing" || fragment.kind === "table";
}
function getParagraphSpacingBefore(block) {
  const spacing = block.attrs?.spacing;
  const value = spacing?.before ?? spacing?.lineSpaceBefore;
  if (shouldSuppressSpacingForEmpty(block, "before")) return 0;
  return typeof value === "number" && Number.isFinite(value) && value > 0 ? value : 0;
}
function getParagraphSpacingAfter$1(block) {
  const spacing = block.attrs?.spacing;
  const value = spacing?.after ?? spacing?.lineSpaceAfter;
  if (shouldSuppressSpacingForEmpty(block, "after")) return 0;
  return typeof value === "number" && Number.isFinite(value) && value > 0 ? value : 0;
}
function getMeasureHeight(block, measure) {
  switch (measure.kind) {
    case "paragraph":
      return measure.totalHeight;
    case "table":
      return measure.totalHeight;
    case "list":
      return measure.totalHeight;
    case "image":
    case "drawing":
      return measure.height;
    case "sectionBreak":
    case "pageBreak":
    case "columnBreak":
      return 0;
    default: {
      return block.kind === "paragraph" ? DEFAULT_PARAGRAPH_LINE_HEIGHT_PX : 0;
    }
  }
}
function computeKeepNextChains(blocks) {
  const chains = /* @__PURE__ */ new Map();
  const processedIndices = /* @__PURE__ */ new Set();
  for (let i = 0; i < blocks.length; i++) {
    if (processedIndices.has(i)) continue;
    const block = blocks[i];
    if (block.kind !== "paragraph") continue;
    const paraBlock = block;
    if (paraBlock.attrs?.keepNext !== true) continue;
    const memberIndices = [i];
    let endIndex = i;
    for (let j = i + 1; j < blocks.length; j++) {
      const nextBlock = blocks[j];
      if (nextBlock.kind === "sectionBreak" || nextBlock.kind === "pageBreak" || nextBlock.kind === "columnBreak") {
        break;
      }
      if (nextBlock.kind !== "paragraph") {
        break;
      }
      const nextPara = nextBlock;
      if (nextPara.attrs?.keepNext === true) {
        memberIndices.push(j);
        endIndex = j;
        processedIndices.add(j);
      } else {
        break;
      }
    }
    const anchorIndex = endIndex + 1 < blocks.length ? endIndex + 1 : -1;
    if (anchorIndex !== -1) {
      const anchorBlock = blocks[anchorIndex];
      if (anchorBlock.kind === "sectionBreak" || anchorBlock.kind === "pageBreak" || anchorBlock.kind === "columnBreak") {
        if (memberIndices.length > 1) {
          chains.set(i, {
            startIndex: i,
            endIndex,
            memberIndices,
            anchorIndex: -1
          });
        }
        continue;
      }
    }
    chains.set(i, {
      startIndex: i,
      endIndex,
      memberIndices,
      anchorIndex
    });
  }
  return chains;
}
function calculateChainHeight(chain, blocks, measures, state) {
  let totalHeight = 0;
  let prevStyleId;
  let prevSpacingAfter = 0;
  let prevContextualSpacing = false;
  let isFirstMember = true;
  for (const memberIndex of chain.memberIndices) {
    const block = blocks[memberIndex];
    const measure = measures[memberIndex];
    if (!measure) continue;
    const spacingBefore = getParagraphSpacingBefore(block);
    const spacingAfter = getParagraphSpacingAfter$1(block);
    const styleId = typeof block.attrs?.styleId === "string" ? block.attrs?.styleId : void 0;
    const contextualSpacing = block.attrs?.contextualSpacing === true;
    if (isFirstMember) {
      const prevTrailing = Number.isFinite(state.trailingSpacing) && state.trailingSpacing > 0 ? state.trailingSpacing : 0;
      const sameAsLastOnPage = styleId && state.lastParagraphStyleId === styleId;
      const effectiveSpacingBefore = contextualSpacing && sameAsLastOnPage ? 0 : Math.max(spacingBefore - prevTrailing, 0);
      totalHeight += effectiveSpacingBefore;
      isFirstMember = false;
    } else {
      const sameStyle = styleId && prevStyleId && styleId === prevStyleId;
      const effectiveSpacingAfterPrev = prevContextualSpacing && sameStyle ? 0 : prevSpacingAfter;
      const effectiveSpacingBefore = contextualSpacing && sameStyle ? 0 : spacingBefore;
      const interParagraphSpacing = Math.max(effectiveSpacingAfterPrev, effectiveSpacingBefore);
      totalHeight += interParagraphSpacing;
    }
    totalHeight += getMeasureHeight(block, measure);
    prevStyleId = styleId;
    prevSpacingAfter = spacingAfter;
    prevContextualSpacing = contextualSpacing;
  }
  if (chain.anchorIndex !== -1) {
    const anchorBlock = blocks[chain.anchorIndex];
    const anchorMeasure = measures[chain.anchorIndex];
    if (anchorBlock && anchorMeasure) {
      if (anchorBlock.kind === "paragraph" && anchorMeasure.kind === "paragraph") {
        const anchorSpacingBefore = getParagraphSpacingBefore(anchorBlock);
        const anchorStyleId = typeof anchorBlock.attrs?.styleId === "string" ? anchorBlock.attrs?.styleId : void 0;
        const anchorContextualSpacing = anchorBlock.attrs?.contextualSpacing === true;
        const sameStyle = anchorStyleId && prevStyleId && anchorStyleId === prevStyleId;
        const effectiveSpacingAfterPrev = prevContextualSpacing && sameStyle ? 0 : prevSpacingAfter;
        const effectiveAnchorSpacingBefore = anchorContextualSpacing && sameStyle ? 0 : anchorSpacingBefore;
        const interParagraphSpacing = Math.max(effectiveSpacingAfterPrev, effectiveAnchorSpacingBefore);
        const firstLineHeight = anchorMeasure.lines[0]?.lineHeight;
        const anchorHeight = typeof firstLineHeight === "number" && Number.isFinite(firstLineHeight) && firstLineHeight > 0 ? firstLineHeight : getMeasureHeight(anchorBlock, anchorMeasure);
        totalHeight += interParagraphSpacing + anchorHeight;
      } else {
        const isAnchoredTable = anchorBlock.kind === "table" && anchorBlock.anchor?.isAnchored === true;
        if (!isAnchoredTable) {
          totalHeight += prevSpacingAfter + getMeasureHeight(anchorBlock, anchorMeasure);
        }
      }
    }
  }
  return totalHeight;
}
const DEFAULT_PAGE_SIZE$2 = { w: 612, h: 792 };
const DEFAULT_MARGINS$2 = { top: 72, right: 72, bottom: 72, left: 72 };
const COLUMN_EPSILON$1 = 1e-4;
const asBoolean = (value) => {
  if (value === true || value === 1) return true;
  if (typeof value === "string") {
    const normalized = value.toLowerCase();
    return normalized === "true" || normalized === "1" || normalized === "on";
  }
  return false;
};
const layoutDebugEnabled$1 = typeof vue.process$1 !== "undefined" && typeof vue.process$1.env !== "undefined" && Boolean(vue.process$1.env.SD_DEBUG_LAYOUT);
const layoutLog = (...args) => {
  if (!layoutDebugEnabled$1) return;
  console.log(...args);
};
function layoutDocument(blocks, measures, options = {}) {
  if (blocks.length !== measures.length) {
    throw new Error(
      `layoutDocument expected measures for every block (blocks=${blocks.length}, measures=${measures.length})`
    );
  }
  const pageSize = options.pageSize ?? DEFAULT_PAGE_SIZE$2;
  const margins = {
    top: options.margins?.top ?? DEFAULT_MARGINS$2.top,
    right: options.margins?.right ?? DEFAULT_MARGINS$2.right,
    bottom: options.margins?.bottom ?? DEFAULT_MARGINS$2.bottom,
    left: options.margins?.left ?? DEFAULT_MARGINS$2.left,
    header: options.margins?.header ?? options.margins?.top ?? DEFAULT_MARGINS$2.top,
    footer: options.margins?.footer ?? options.margins?.bottom ?? DEFAULT_MARGINS$2.bottom
  };
  const baseContentWidth = pageSize.w - (margins.left + margins.right);
  if (baseContentWidth <= 0) {
    throw new Error("layoutDocument: pageSize and margins yield non-positive content area");
  }
  const validateContentHeight = (height) => {
    if (height === void 0) return 0;
    if (!Number.isFinite(height) || height < 0) return 0;
    return height;
  };
  const headerContentHeights = options.headerContentHeights;
  const footerContentHeights = options.footerContentHeights;
  const headerContentHeightsByRId = options.headerContentHeightsByRId;
  const footerContentHeightsByRId = options.footerContentHeightsByRId;
  const getVariantTypeForPage = (sectionPageNumber, titlePgEnabled, alternateHeaders) => {
    if (sectionPageNumber === 1 && titlePgEnabled) {
      return "first";
    }
    return "default";
  };
  const getHeaderHeightForPage = (variantType, headerRef) => {
    if (headerRef && headerContentHeightsByRId?.has(headerRef)) {
      return validateContentHeight(headerContentHeightsByRId.get(headerRef));
    }
    if (headerContentHeights) {
      return validateContentHeight(headerContentHeights[variantType]);
    }
    return 0;
  };
  const getFooterHeightForPage = (variantType, footerRef) => {
    if (footerRef && footerContentHeightsByRId?.has(footerRef)) {
      return validateContentHeight(footerContentHeightsByRId.get(footerRef));
    }
    if (footerContentHeights) {
      return validateContentHeight(footerContentHeights[variantType]);
    }
    return 0;
  };
  const calculateEffectiveTopMargin = (headerContentHeight, currentHeaderDistance, baseTopMargin) => {
    if (headerContentHeight > 0) {
      return Math.max(baseTopMargin, currentHeaderDistance + headerContentHeight);
    }
    return baseTopMargin;
  };
  const calculateEffectiveBottomMargin = (footerContentHeight, currentFooterDistance, baseBottomMargin) => {
    if (footerContentHeight > 0) {
      return Math.max(baseBottomMargin, currentFooterDistance + footerContentHeight);
    }
    return baseBottomMargin;
  };
  const maxHeaderContentHeight = headerContentHeights ? Math.max(
    0,
    validateContentHeight(headerContentHeights.default),
    validateContentHeight(headerContentHeights.first),
    validateContentHeight(headerContentHeights.even),
    validateContentHeight(headerContentHeights.odd)
  ) : 0;
  const maxFooterContentHeight = footerContentHeights ? Math.max(
    0,
    validateContentHeight(footerContentHeights.default),
    validateContentHeight(footerContentHeights.first),
    validateContentHeight(footerContentHeights.even),
    validateContentHeight(footerContentHeights.odd)
  ) : 0;
  const headerDistance = margins.header ?? margins.top;
  const footerDistance = margins.footer ?? margins.bottom;
  const defaultHeaderHeight = getHeaderHeightForPage("default", void 0);
  const defaultFooterHeight = getFooterHeightForPage("default", void 0);
  const effectiveTopMargin = calculateEffectiveTopMargin(defaultHeaderHeight, headerDistance, margins.top);
  const effectiveBottomMargin = calculateEffectiveBottomMargin(defaultFooterHeight, footerDistance, margins.bottom);
  let activeTopMargin = effectiveTopMargin;
  let activeBottomMargin = effectiveBottomMargin;
  let activeLeftMargin = margins.left;
  let activeRightMargin = margins.right;
  let pendingTopMargin = null;
  let pendingBottomMargin = null;
  let pendingLeftMargin = null;
  let pendingRightMargin = null;
  let activeSectionBaseTopMargin = margins.top;
  let activeSectionBaseBottomMargin = margins.bottom;
  let pendingSectionBaseTopMargin = null;
  let pendingSectionBaseBottomMargin = null;
  let activeHeaderDistance = margins.header ?? margins.top;
  let pendingHeaderDistance = null;
  let activeFooterDistance = margins.footer ?? margins.bottom;
  let pendingFooterDistance = null;
  let activePageSize = { w: pageSize.w, h: pageSize.h };
  let pendingPageSize = null;
  let activeColumns = options.columns ?? { count: 1, gap: 0 };
  let pendingColumns = null;
  let activeOrientation = null;
  let pendingOrientation = null;
  let activeVAlign = null;
  let pendingVAlign = void 0;
  const paginatorMargins = { left: activeLeftMargin, right: activeRightMargin };
  const floatManager = createFloatingObjectManager(
    normalizeColumns(activeColumns, activePageSize.w - (activeLeftMargin + activeRightMargin)),
    { left: activeLeftMargin, right: activeRightMargin },
    activePageSize.w
  );
  const nextSectionPropsAtBreak = computeNextSectionPropsAtBreak(blocks);
  const scheduleSectionBreakCompat = (block, state, baseMargins) => {
    if (typeof scheduleSectionBreak === "function") {
      return scheduleSectionBreak(block, state, baseMargins, maxHeaderContentHeight, maxFooterContentHeight);
    }
    const next = { ...state };
    if (block.attrs?.isFirstSection && !next.hasAnyPages) {
      if (block.pageSize) {
        next.activePageSize = { w: block.pageSize.w, h: block.pageSize.h };
        next.pendingPageSize = null;
      }
      if (block.orientation) {
        next.activeOrientation = block.orientation;
        next.pendingOrientation = null;
      }
      const headerDistance2 = typeof block.margins?.header === "number" ? Math.max(0, block.margins.header) : next.activeHeaderDistance;
      const footerDistance2 = typeof block.margins?.footer === "number" ? Math.max(0, block.margins.footer) : next.activeFooterDistance;
      const sectionTop = typeof block.margins?.top === "number" ? Math.max(0, block.margins.top) : baseMargins.top;
      const sectionBottom = typeof block.margins?.bottom === "number" ? Math.max(0, block.margins.bottom) : baseMargins.bottom;
      if (block.margins?.header !== void 0) {
        next.activeHeaderDistance = headerDistance2;
        next.pendingHeaderDistance = headerDistance2;
      }
      if (block.margins?.footer !== void 0) {
        next.activeFooterDistance = footerDistance2;
        next.pendingFooterDistance = footerDistance2;
      }
      if (block.margins?.top !== void 0 || block.margins?.header !== void 0) {
        const requiredTop = maxHeaderContentHeight > 0 ? headerDistance2 + maxHeaderContentHeight : 0;
        next.activeTopMargin = Math.max(sectionTop, requiredTop);
        next.pendingTopMargin = next.activeTopMargin;
      }
      if (block.margins?.bottom !== void 0 || block.margins?.footer !== void 0) {
        const requiredBottom = maxFooterContentHeight > 0 ? footerDistance2 + maxFooterContentHeight : 0;
        next.activeBottomMargin = Math.max(sectionBottom, requiredBottom);
        next.pendingBottomMargin = next.activeBottomMargin;
      }
      if (block.margins?.left !== void 0) {
        const leftMargin = Math.max(0, block.margins.left);
        next.activeLeftMargin = leftMargin;
        next.pendingLeftMargin = leftMargin;
      }
      if (block.margins?.right !== void 0) {
        const rightMargin = Math.max(0, block.margins.right);
        next.activeRightMargin = rightMargin;
        next.pendingRightMargin = rightMargin;
      }
      if (block.columns) {
        next.activeColumns = { count: block.columns.count, gap: block.columns.gap };
        next.pendingColumns = null;
      } else {
        next.activeColumns = { count: 1, gap: 0 };
        next.pendingColumns = null;
      }
      if (block.headerRefs || block.footerRefs) {
        const baseSectionRefs = pendingSectionRefs ?? activeSectionRefs;
        const nextSectionRefs = {
          ...block.headerRefs && { headerRefs: block.headerRefs },
          ...block.footerRefs && { footerRefs: block.footerRefs }
        };
        pendingSectionRefs = mergeSectionRefs(baseSectionRefs, nextSectionRefs);
        layoutLog(`[Layout] First section: Scheduled pendingSectionRefs:`, pendingSectionRefs);
      }
      const firstSectionIndexRaw = block.attrs?.sectionIndex;
      const firstMetadataIndex = typeof firstSectionIndexRaw === "number" ? firstSectionIndexRaw : Number(firstSectionIndexRaw ?? NaN);
      if (Number.isFinite(firstMetadataIndex)) {
        activeSectionIndex = firstMetadataIndex;
      }
      const firstSectionMetadata = Number.isFinite(firstMetadataIndex) ? sectionMetadataList[firstMetadataIndex] : void 0;
      if (firstSectionMetadata?.numbering) {
        if (firstSectionMetadata.numbering.format) activeNumberFormat = firstSectionMetadata.numbering.format;
        if (typeof firstSectionMetadata.numbering.start === "number") {
          activePageCounter = firstSectionMetadata.numbering.start;
        }
      }
      return { decision: { forcePageBreak: false, forceMidPageRegion: false }, state: next };
    }
    const headerPx = block.margins?.header;
    const footerPx = block.margins?.footer;
    const topPx = block.margins?.top;
    const bottomPx = block.margins?.bottom;
    const leftPx = block.margins?.left;
    const rightPx = block.margins?.right;
    const nextTop = next.pendingTopMargin ?? next.activeTopMargin;
    const nextBottom = next.pendingBottomMargin ?? next.activeBottomMargin;
    const nextLeft = next.pendingLeftMargin ?? next.activeLeftMargin;
    const nextRight = next.pendingRightMargin ?? next.activeRightMargin;
    const nextHeader = next.pendingHeaderDistance ?? next.activeHeaderDistance;
    const nextFooter = next.pendingFooterDistance ?? next.activeFooterDistance;
    next.pendingHeaderDistance = typeof headerPx === "number" ? Math.max(0, headerPx) : nextHeader;
    next.pendingFooterDistance = typeof footerPx === "number" ? Math.max(0, footerPx) : nextFooter;
    if (typeof headerPx === "number" || typeof topPx === "number") {
      const sectionTop = typeof topPx === "number" ? Math.max(0, topPx) : baseMargins.top;
      const sectionHeader = next.pendingHeaderDistance;
      const requiredTop = maxHeaderContentHeight > 0 ? sectionHeader + maxHeaderContentHeight : sectionHeader;
      next.pendingTopMargin = Math.max(sectionTop, requiredTop);
    } else {
      next.pendingTopMargin = nextTop;
    }
    if (typeof footerPx === "number" || typeof bottomPx === "number") {
      const sectionFooter = next.pendingFooterDistance;
      const sectionBottom = typeof bottomPx === "number" ? Math.max(0, bottomPx) : baseMargins.bottom;
      const requiredBottom = maxFooterContentHeight > 0 ? sectionFooter + maxFooterContentHeight : sectionFooter;
      next.pendingBottomMargin = Math.max(sectionBottom, requiredBottom);
    } else {
      next.pendingBottomMargin = nextBottom;
    }
    next.pendingLeftMargin = typeof leftPx === "number" ? Math.max(0, leftPx) : nextLeft;
    next.pendingRightMargin = typeof rightPx === "number" ? Math.max(0, rightPx) : nextRight;
    if (block.pageSize) next.pendingPageSize = { w: block.pageSize.w, h: block.pageSize.h };
    if (block.orientation) next.pendingOrientation = block.orientation;
    const sectionType = block.type ?? "continuous";
    const isColumnsChanging = block.columns && (block.columns.count !== next.activeColumns.count || block.columns.gap !== next.activeColumns.gap) || !block.columns && next.activeColumns.count > 1;
    const sectionIndexRaw = block.attrs?.sectionIndex;
    const metadataIndex = typeof sectionIndexRaw === "number" ? sectionIndexRaw : Number(sectionIndexRaw ?? NaN);
    if (Number.isFinite(metadataIndex)) {
      pendingSectionIndex = metadataIndex;
    }
    const sectionMetadata = Number.isFinite(metadataIndex) ? sectionMetadataList[metadataIndex] : void 0;
    if (sectionMetadata?.numbering) {
      pendingNumbering = { ...sectionMetadata.numbering };
    } else if (block.numbering) {
      pendingNumbering = { ...block.numbering };
    }
    if (block.headerRefs || block.footerRefs) {
      const baseSectionRefs = pendingSectionRefs ?? activeSectionRefs;
      const nextSectionRefs = {
        ...block.headerRefs && { headerRefs: block.headerRefs },
        ...block.footerRefs && { footerRefs: block.footerRefs }
      };
      pendingSectionRefs = mergeSectionRefs(baseSectionRefs, nextSectionRefs);
      layoutLog(`[Layout] Compat fallback: Scheduled pendingSectionRefs:`, pendingSectionRefs);
    }
    const getColumnConfig2 = () => block.columns ? { count: block.columns.count, gap: block.columns.gap } : { count: 1, gap: 0 };
    if (block.attrs?.requirePageBoundary) {
      next.pendingColumns = getColumnConfig2();
      return { decision: { forcePageBreak: true, forceMidPageRegion: false }, state: next };
    }
    if (sectionType === "nextPage") {
      next.pendingColumns = getColumnConfig2();
      return { decision: { forcePageBreak: true, forceMidPageRegion: false }, state: next };
    }
    if (sectionType === "evenPage") {
      next.pendingColumns = getColumnConfig2();
      return { decision: { forcePageBreak: true, forceMidPageRegion: false, requiredParity: "even" }, state: next };
    }
    if (sectionType === "oddPage") {
      next.pendingColumns = getColumnConfig2();
      return { decision: { forcePageBreak: true, forceMidPageRegion: false, requiredParity: "odd" }, state: next };
    }
    if (isColumnsChanging) {
      next.pendingColumns = getColumnConfig2();
      return { decision: { forcePageBreak: false, forceMidPageRegion: true }, state: next };
    }
    next.pendingColumns = getColumnConfig2();
    return { decision: { forcePageBreak: false, forceMidPageRegion: false }, state: next };
  };
  const createPage = (number, pageMargins, pageSizeOverride) => {
    const page = {
      number,
      fragments: [],
      margins: pageMargins
    };
    if (pageSizeOverride) {
      page.size = pageSizeOverride;
    }
    if (activeOrientation) {
      page.orientation = activeOrientation;
    }
    if (activeVAlign && activeVAlign !== "top") {
      page.vAlign = activeVAlign;
      page.baseMargins = {
        top: activeSectionBaseTopMargin,
        bottom: activeSectionBaseBottomMargin
      };
    }
    return page;
  };
  let pageCount = 0;
  let activeNumberFormat = "decimal";
  let activePageCounter = 1;
  let pendingNumbering = null;
  const normalizeRefs = (refs) => refs && Object.keys(refs).length > 0 ? refs : void 0;
  const mergeSectionRefs = (base2, next) => {
    if (!base2 && !next) return null;
    const headerRefs = normalizeRefs(next?.headerRefs) ?? normalizeRefs(base2?.headerRefs);
    const footerRefs = normalizeRefs(next?.footerRefs) ?? normalizeRefs(base2?.footerRefs);
    if (!headerRefs && !footerRefs) return null;
    return {
      ...headerRefs && { headerRefs },
      ...footerRefs && { footerRefs }
    };
  };
  const sectionMetadataList = options.sectionMetadata ?? [];
  const initialSectionMetadata = sectionMetadataList[0];
  if (initialSectionMetadata?.numbering?.format) {
    activeNumberFormat = initialSectionMetadata.numbering.format;
  }
  if (typeof initialSectionMetadata?.numbering?.start === "number") {
    activePageCounter = initialSectionMetadata.numbering.start;
  }
  let activeSectionRefs = null;
  let pendingSectionRefs = null;
  if (initialSectionMetadata?.headerRefs || initialSectionMetadata?.footerRefs) {
    activeSectionRefs = {
      ...initialSectionMetadata.headerRefs && { headerRefs: initialSectionMetadata.headerRefs },
      ...initialSectionMetadata.footerRefs && { footerRefs: initialSectionMetadata.footerRefs }
    };
  }
  if (initialSectionMetadata?.vAlign) {
    activeVAlign = initialSectionMetadata.vAlign;
  }
  let activeSectionIndex = initialSectionMetadata?.sectionIndex ?? 0;
  let pendingSectionIndex = null;
  const sectionFirstPageNumbers = /* @__PURE__ */ new Map();
  const paginator = createPaginator({
    margins: paginatorMargins,
    getActiveTopMargin: () => activeTopMargin,
    getActiveBottomMargin: () => {
      const reserves = options.footnoteReservedByPageIndex;
      const pageIndex = Math.max(0, pageCount - 1);
      const reserve = Array.isArray(reserves) ? reserves[pageIndex] : 0;
      const reservePx = typeof reserve === "number" && Number.isFinite(reserve) && reserve > 0 ? reserve : 0;
      return activeBottomMargin + reservePx;
    },
    getActiveHeaderDistance: () => activeHeaderDistance,
    getActiveFooterDistance: () => activeFooterDistance,
    getActivePageSize: () => activePageSize,
    getDefaultPageSize: () => pageSize,
    getActiveColumns: () => activeColumns,
    getCurrentColumns: () => getCurrentColumns(),
    createPage,
    onNewPage: (state) => {
      if (!state) {
        const isEnteringNewSection = pendingSectionIndex !== null;
        const applied = applyPendingToActive({
          activeTopMargin,
          activeBottomMargin,
          activeLeftMargin,
          activeRightMargin,
          pendingTopMargin,
          pendingBottomMargin,
          pendingLeftMargin,
          pendingRightMargin,
          activeHeaderDistance,
          activeFooterDistance,
          pendingHeaderDistance,
          pendingFooterDistance,
          activePageSize,
          pendingPageSize,
          activeColumns,
          pendingColumns,
          activeOrientation,
          pendingOrientation,
          hasAnyPages: pageCount > 0
        });
        activeTopMargin = applied.activeTopMargin;
        activeBottomMargin = applied.activeBottomMargin;
        activeLeftMargin = applied.activeLeftMargin;
        activeRightMargin = applied.activeRightMargin;
        pendingTopMargin = applied.pendingTopMargin;
        pendingBottomMargin = applied.pendingBottomMargin;
        pendingLeftMargin = applied.pendingLeftMargin;
        pendingRightMargin = applied.pendingRightMargin;
        activeHeaderDistance = applied.activeHeaderDistance;
        activeFooterDistance = applied.activeFooterDistance;
        pendingHeaderDistance = applied.pendingHeaderDistance;
        pendingFooterDistance = applied.pendingFooterDistance;
        activePageSize = applied.activePageSize;
        pendingPageSize = applied.pendingPageSize;
        activeColumns = applied.activeColumns;
        pendingColumns = applied.pendingColumns;
        activeOrientation = applied.activeOrientation;
        pendingOrientation = applied.pendingOrientation;
        cachedColumnsState.state = null;
        paginatorMargins.left = activeLeftMargin;
        paginatorMargins.right = activeRightMargin;
        const contentWidth = activePageSize.w - (activeLeftMargin + activeRightMargin);
        floatManager.setLayoutContext(
          normalizeColumns(activeColumns, contentWidth),
          { left: activeLeftMargin, right: activeRightMargin },
          activePageSize.w
        );
        if (pendingNumbering) {
          if (pendingNumbering.format) activeNumberFormat = pendingNumbering.format;
          if (typeof pendingNumbering.start === "number" && Number.isFinite(pendingNumbering.start)) {
            activePageCounter = pendingNumbering.start;
          }
          pendingNumbering = null;
        }
        if (pendingSectionRefs) {
          activeSectionRefs = mergeSectionRefs(activeSectionRefs, pendingSectionRefs);
          pendingSectionRefs = null;
        }
        if (pendingSectionIndex !== null) {
          activeSectionIndex = pendingSectionIndex;
          pendingSectionIndex = null;
        }
        if (pendingVAlign !== void 0) {
          activeVAlign = pendingVAlign;
          pendingVAlign = void 0;
        }
        if (pendingSectionBaseTopMargin !== null) {
          activeSectionBaseTopMargin = pendingSectionBaseTopMargin;
          pendingSectionBaseTopMargin = null;
        }
        if (pendingSectionBaseBottomMargin !== null) {
          activeSectionBaseBottomMargin = pendingSectionBaseBottomMargin;
          pendingSectionBaseBottomMargin = null;
        }
        pageCount += 1;
        const newPageNumber = pageCount;
        if (isEnteringNewSection || !sectionFirstPageNumbers.has(activeSectionIndex)) {
          sectionFirstPageNumbers.set(activeSectionIndex, newPageNumber);
        }
        const firstPageInSection = sectionFirstPageNumbers.get(activeSectionIndex) ?? newPageNumber;
        const sectionPageNumber = newPageNumber - firstPageInSection + 1;
        const sectionMetadata = sectionMetadataList[activeSectionIndex];
        const titlePgEnabled = sectionMetadata?.titlePg ?? false;
        const variantType = getVariantTypeForPage(sectionPageNumber, titlePgEnabled);
        let headerRef = activeSectionRefs?.headerRefs?.[variantType];
        let footerRef = activeSectionRefs?.footerRefs?.[variantType];
        let effectiveVariantType = variantType;
        if (!headerRef && variantType !== "default" && activeSectionIndex > 0) {
          const prevSectionMetadata = sectionMetadataList[activeSectionIndex - 1];
          if (prevSectionMetadata?.headerRefs?.[variantType]) {
            headerRef = prevSectionMetadata.headerRefs[variantType];
            layoutLog(
              `[Layout] Page ${newPageNumber}: Inheriting header '${variantType}' from section ${activeSectionIndex - 1}: ${headerRef}`
            );
          }
        }
        if (!footerRef && variantType !== "default" && activeSectionIndex > 0) {
          const prevSectionMetadata = sectionMetadataList[activeSectionIndex - 1];
          if (prevSectionMetadata?.footerRefs?.[variantType]) {
            footerRef = prevSectionMetadata.footerRefs[variantType];
            layoutLog(
              `[Layout] Page ${newPageNumber}: Inheriting footer '${variantType}' from section ${activeSectionIndex - 1}: ${footerRef}`
            );
          }
        }
        if (!headerRef && variantType !== "default" && activeSectionRefs?.headerRefs?.default) {
          headerRef = activeSectionRefs.headerRefs.default;
          effectiveVariantType = "default";
        }
        if (!footerRef && variantType !== "default" && activeSectionRefs?.footerRefs?.default) {
          footerRef = activeSectionRefs.footerRefs.default;
        }
        const headerHeight = getHeaderHeightForPage(effectiveVariantType, headerRef);
        const footerHeight = getFooterHeightForPage(
          variantType !== "default" && !activeSectionRefs?.footerRefs?.[variantType] ? "default" : variantType,
          footerRef
        );
        activeTopMargin = calculateEffectiveTopMargin(headerHeight, activeHeaderDistance, activeSectionBaseTopMargin);
        activeBottomMargin = calculateEffectiveBottomMargin(
          footerHeight,
          activeFooterDistance,
          activeSectionBaseBottomMargin
        );
        layoutLog(
          `[Layout] Page ${newPageNumber}: Using variant '${variantType}' - headerHeight: ${headerHeight}, footerHeight: ${footerHeight}`
        );
        layoutLog(
          `[Layout] Page ${newPageNumber}: Adjusted margins - top: ${activeTopMargin}, bottom: ${activeBottomMargin} (base: ${activeSectionBaseTopMargin}, ${activeSectionBaseBottomMargin})`
        );
        return;
      }
      if (state?.page) {
        state.page.numberText = formatPageNumber(activePageCounter, activeNumberFormat);
        state.page.sectionIndex = activeSectionIndex;
        layoutLog(`[Layout] Page ${state.page.number}: Stamped sectionIndex:`, activeSectionIndex);
        if (activeSectionRefs) {
          state.page.sectionRefs = {
            ...activeSectionRefs.headerRefs && { headerRefs: activeSectionRefs.headerRefs },
            ...activeSectionRefs.footerRefs && { footerRefs: activeSectionRefs.footerRefs }
          };
          layoutLog(`[Layout] Page ${state.page.number}: Stamped sectionRefs:`, state.page.sectionRefs);
        } else {
          layoutLog(`[Layout] Page ${state.page.number}: No activeSectionRefs to stamp`);
        }
        activePageCounter += 1;
      }
    }
  });
  const pages = paginator.pages;
  const states = paginator.states;
  const getActiveColumnsForState = paginator.getActiveColumnsForState;
  let cachedColumnsState = { state: null, constraintIndex: -2, contentWidth: -1, colsConfig: null, normalized: null };
  const getCurrentColumns = () => {
    const currentContentWidth = activePageSize.w - (activeLeftMargin + activeRightMargin);
    const state = states[states.length - 1] ?? null;
    const colsConfig = state ? getActiveColumnsForState(state) : activeColumns;
    const constraintIndex = state ? state.activeConstraintIndex : -1;
    if (cachedColumnsState.state === state && cachedColumnsState.constraintIndex === constraintIndex && cachedColumnsState.contentWidth === currentContentWidth && cachedColumnsState.colsConfig?.count === colsConfig.count && cachedColumnsState.colsConfig?.gap === colsConfig.gap && cachedColumnsState.normalized) {
      return cachedColumnsState.normalized;
    }
    const normalized = normalizeColumns(colsConfig, currentContentWidth);
    cachedColumnsState = {
      state,
      constraintIndex,
      contentWidth: currentContentWidth,
      colsConfig: { count: colsConfig.count, gap: colsConfig.gap },
      normalized
    };
    return normalized;
  };
  const columnX = paginator.columnX;
  const advanceColumn = paginator.advanceColumn;
  const startMidPageRegion = (state, newColumns) => {
    const boundary = {
      y: state.cursorY,
      columns: newColumns
    };
    state.constraintBoundaries.push(boundary);
    state.activeConstraintIndex = state.constraintBoundaries.length - 1;
    state.columnIndex = 0;
    layoutLog(`[Layout] *** COLUMNS CHANGED MID-PAGE ***`);
    layoutLog(`  OLD activeColumns: ${JSON.stringify(activeColumns)}`);
    layoutLog(`  NEW activeColumns: ${JSON.stringify(newColumns)}`);
    layoutLog(`  Current page: ${state.page.number}, cursorY: ${state.cursorY}`);
    activeColumns = newColumns;
    cachedColumnsState.state = null;
    const contentWidth = activePageSize.w - (activeLeftMargin + activeRightMargin);
    floatManager.setLayoutContext(
      normalizeColumns(activeColumns, contentWidth),
      { left: activeLeftMargin, right: activeRightMargin },
      activePageSize.w
    );
  };
  const anchoredByParagraph = collectAnchoredDrawings(blocks, measures);
  const anchoredTablesByParagraph = collectAnchoredTables(blocks, measures);
  const placedAnchoredIds = /* @__PURE__ */ new Set();
  const placedAnchoredTableIds = /* @__PURE__ */ new Set();
  const preRegisteredAnchors = collectPreRegisteredAnchors(blocks, measures);
  const preRegisteredPositions = /* @__PURE__ */ new Map();
  for (const entry of preRegisteredAnchors) {
    const state = paginator.ensurePage();
    const vRelativeFrom = entry.block.anchor?.vRelativeFrom ?? "paragraph";
    const alignV = entry.block.anchor?.alignV ?? "top";
    const offsetV = entry.block.anchor?.offsetV ?? 0;
    const imageHeight = entry.measure.height ?? 0;
    const contentTop = state.topMargin;
    const contentBottom = state.contentBottom;
    const contentHeight = Math.max(0, contentBottom - contentTop);
    let anchorY;
    if (vRelativeFrom === "margin") {
      if (alignV === "top") {
        anchorY = contentTop + offsetV;
      } else if (alignV === "bottom") {
        anchorY = contentBottom - imageHeight + offsetV;
      } else if (alignV === "center") {
        anchorY = contentTop + (contentHeight - imageHeight) / 2 + offsetV;
      } else {
        anchorY = contentTop + offsetV;
      }
    } else if (vRelativeFrom === "page") {
      if (alignV === "top") {
        anchorY = offsetV;
      } else if (alignV === "bottom") {
        const pageHeight = contentBottom + (state.page.margins?.bottom ?? activeBottomMargin);
        anchorY = pageHeight - imageHeight + offsetV;
      } else if (alignV === "center") {
        const pageHeight = contentBottom + (state.page.margins?.bottom ?? activeBottomMargin);
        anchorY = (pageHeight - imageHeight) / 2 + offsetV;
      } else {
        anchorY = offsetV;
      }
    } else {
      anchorY = contentTop + offsetV;
    }
    const anchorX = entry.block.anchor ? computeAnchorX(
      entry.block.anchor,
      state.columnIndex,
      normalizeColumns(activeColumns, activePageSize.w - (activeLeftMargin + activeRightMargin)),
      entry.measure.width,
      { left: activeLeftMargin, right: activeRightMargin },
      activePageSize.w
    ) : activeLeftMargin;
    floatManager.registerDrawing(entry.block, entry.measure, anchorY, state.columnIndex, state.page.number);
    preRegisteredPositions.set(entry.block.id, { anchorX, anchorY, pageNumber: state.page.number });
  }
  const keepNextChains = computeKeepNextChains(blocks);
  const midChainIndices = /* @__PURE__ */ new Set();
  for (const chain of keepNextChains.values()) {
    for (let i = 1; i < chain.memberIndices.length; i++) {
      midChainIndices.add(chain.memberIndices[i]);
    }
  }
  for (let index2 = 0; index2 < blocks.length; index2 += 1) {
    const block = blocks[index2];
    const measure = measures[index2];
    if (!measure) {
      throw new Error(`layoutDocument: missing measure for block ${block.id}`);
    }
    layoutLog(`[Layout] Block ${index2} (${block.kind}) - ID: ${block.id}`);
    layoutLog(`  activeColumns: ${JSON.stringify(activeColumns)}`);
    layoutLog(`  pendingColumns: ${JSON.stringify(pendingColumns)}`);
    if (block.kind === "sectionBreak") {
      const sectionBlock = block;
      layoutLog(`  sectionBreak.columns: ${JSON.stringify(sectionBlock.columns)}`);
      layoutLog(`  sectionBreak.type: ${sectionBlock.type}`);
    }
    if (block.kind === "sectionBreak") {
      if (measure.kind !== "sectionBreak") {
        throw new Error(`layoutDocument: expected sectionBreak measure for block ${block.id}`);
      }
      let effectiveBlock = block;
      const ahead = nextSectionPropsAtBreak.get(index2);
      const hasSectionIndex = typeof effectiveBlock.attrs?.sectionIndex === "number";
      if (ahead && effectiveBlock.attrs?.source === "sectPr" && !hasSectionIndex && ahead) {
        effectiveBlock = {
          ...effectiveBlock,
          margins: ahead.margins ? { ...effectiveBlock.margins ?? {}, ...ahead.margins } : effectiveBlock.margins ?? {},
          pageSize: ahead.pageSize ?? effectiveBlock.pageSize,
          columns: ahead.columns ?? effectiveBlock.columns,
          orientation: ahead.orientation ?? effectiveBlock.orientation,
          vAlign: ahead.vAlign ?? effectiveBlock.vAlign
        };
      }
      const sectionState = {
        activeTopMargin,
        activeBottomMargin,
        activeLeftMargin,
        activeRightMargin,
        pendingTopMargin,
        pendingBottomMargin,
        pendingLeftMargin,
        pendingRightMargin,
        activeHeaderDistance,
        activeFooterDistance,
        pendingHeaderDistance,
        pendingFooterDistance,
        activePageSize,
        pendingPageSize,
        activeColumns,
        pendingColumns,
        activeOrientation,
        pendingOrientation,
        hasAnyPages: states.length > 0
      };
      const _sched = scheduleSectionBreakCompat(effectiveBlock, sectionState, {
        top: margins.top,
        bottom: margins.bottom
      });
      const breakInfo = _sched.decision;
      const updatedState = _sched.state ?? sectionState;
      layoutLog(`[Layout] ========== SECTION BREAK SCHEDULED ==========`);
      layoutLog(`  Block index: ${index2}`);
      layoutLog(`  effectiveBlock.columns: ${JSON.stringify(effectiveBlock.columns)}`);
      layoutLog(`  effectiveBlock.type: ${effectiveBlock.type}`);
      layoutLog(`  breakInfo.forcePageBreak: ${breakInfo.forcePageBreak}`);
      layoutLog(`  breakInfo.forceMidPageRegion: ${breakInfo.forceMidPageRegion}`);
      layoutLog(
        `  BEFORE: activeColumns = ${JSON.stringify(sectionState.activeColumns)}, pendingColumns = ${JSON.stringify(sectionState.pendingColumns)}`
      );
      layoutLog(
        `  AFTER: activeColumns = ${JSON.stringify(updatedState.activeColumns)}, pendingColumns = ${JSON.stringify(updatedState.pendingColumns)}`
      );
      layoutLog(`[Layout] ========== END SECTION BREAK ==========`);
      activeTopMargin = updatedState.activeTopMargin;
      activeBottomMargin = updatedState.activeBottomMargin;
      activeLeftMargin = updatedState.activeLeftMargin;
      activeRightMargin = updatedState.activeRightMargin;
      pendingTopMargin = updatedState.pendingTopMargin;
      pendingBottomMargin = updatedState.pendingBottomMargin;
      pendingLeftMargin = updatedState.pendingLeftMargin;
      pendingRightMargin = updatedState.pendingRightMargin;
      activeHeaderDistance = updatedState.activeHeaderDistance;
      activeFooterDistance = updatedState.activeFooterDistance;
      pendingHeaderDistance = updatedState.pendingHeaderDistance;
      pendingFooterDistance = updatedState.pendingFooterDistance;
      activePageSize = updatedState.activePageSize;
      pendingPageSize = updatedState.pendingPageSize;
      activeColumns = updatedState.activeColumns;
      pendingColumns = updatedState.pendingColumns;
      activeOrientation = updatedState.activeOrientation;
      pendingOrientation = updatedState.pendingOrientation;
      const isFirstSection = effectiveBlock.attrs?.isFirstSection && states.length === 0;
      const blockTopMargin = effectiveBlock.margins?.top;
      const blockBottomMargin = effectiveBlock.margins?.bottom;
      if (isFirstSection) {
        activeSectionBaseTopMargin = typeof blockTopMargin === "number" ? blockTopMargin : margins.top;
        activeSectionBaseBottomMargin = typeof blockBottomMargin === "number" ? blockBottomMargin : margins.bottom;
      } else if (blockTopMargin !== void 0 || blockBottomMargin !== void 0) {
        if (blockTopMargin !== void 0) {
          pendingSectionBaseTopMargin = typeof blockTopMargin === "number" ? blockTopMargin : margins.top;
        }
        if (blockBottomMargin !== void 0) {
          pendingSectionBaseBottomMargin = typeof blockBottomMargin === "number" ? blockBottomMargin : margins.bottom;
        }
      }
      const sectionVAlign = effectiveBlock.vAlign ?? null;
      const isFirstSectionForVAlign = effectiveBlock.attrs?.isFirstSection && states.length === 0;
      if (isFirstSectionForVAlign) {
        activeVAlign = sectionVAlign;
        pendingVAlign = void 0;
      } else {
        pendingVAlign = sectionVAlign;
      }
      if (effectiveBlock.headerRefs || effectiveBlock.footerRefs) {
        const baseSectionRefs = pendingSectionRefs ?? activeSectionRefs;
        const nextSectionRefs = {
          ...effectiveBlock.headerRefs && { headerRefs: effectiveBlock.headerRefs },
          ...effectiveBlock.footerRefs && { footerRefs: effectiveBlock.footerRefs }
        };
        pendingSectionRefs = mergeSectionRefs(baseSectionRefs, nextSectionRefs);
        layoutLog(`[Layout] After scheduleSectionBreakCompat: Scheduled pendingSectionRefs:`, pendingSectionRefs);
      }
      const sectionIndexRaw = effectiveBlock.attrs?.sectionIndex;
      const metadataIndex = typeof sectionIndexRaw === "number" ? sectionIndexRaw : Number(sectionIndexRaw ?? NaN);
      if (Number.isFinite(metadataIndex)) {
        if (isFirstSection) {
          activeSectionIndex = metadataIndex;
        } else {
          pendingSectionIndex = metadataIndex;
        }
      }
      const sectionMetadata = Number.isFinite(metadataIndex) ? sectionMetadataList[metadataIndex] : void 0;
      if (sectionMetadata?.numbering) {
        if (isFirstSection) {
          if (sectionMetadata.numbering.format) activeNumberFormat = sectionMetadata.numbering.format;
          if (typeof sectionMetadata.numbering.start === "number") {
            activePageCounter = sectionMetadata.numbering.start;
          }
        } else {
          pendingNumbering = { ...sectionMetadata.numbering };
        }
      } else if (effectiveBlock.numbering) {
        if (isFirstSection) {
          if (effectiveBlock.numbering.format) activeNumberFormat = effectiveBlock.numbering.format;
          if (typeof effectiveBlock.numbering.start === "number") {
            activePageCounter = effectiveBlock.numbering.start;
          }
        } else {
          pendingNumbering = { ...effectiveBlock.numbering };
        }
      }
      if (breakInfo.forceMidPageRegion && updatedState.pendingColumns) {
        let state = paginator.ensurePage();
        const columnIndexBefore = state.columnIndex;
        const newColumns = updatedState.pendingColumns;
        if (columnIndexBefore >= newColumns.count) {
          state = paginator.startNewPage();
        }
        startMidPageRegion(state, newColumns);
      }
      if (breakInfo.forcePageBreak) {
        let state = paginator.ensurePage();
        if (state.page.fragments.length > 0) {
          layoutLog(`[Layout] Starting new page due to section break (forcePageBreak=true)`);
          layoutLog(
            `  Before: activeColumns = ${JSON.stringify(activeColumns)}, pendingColumns = ${JSON.stringify(pendingColumns)}`
          );
          state = paginator.startNewPage();
          layoutLog(
            `  After page ${state.page.number} created: activeColumns = ${JSON.stringify(activeColumns)}, pendingColumns = ${JSON.stringify(pendingColumns)}`
          );
        }
        if (breakInfo.requiredParity) {
          const currentPageNumber = state.page.number;
          const isCurrentEven = currentPageNumber % 2 === 0;
          const needsEven = breakInfo.requiredParity === "even";
          if (needsEven && !isCurrentEven || !needsEven && isCurrentEven) {
            layoutLog(`[Layout] Inserting blank page for parity (need ${breakInfo.requiredParity})`);
            state = paginator.startNewPage();
          }
        }
      }
      continue;
    }
    if (block.kind === "paragraph") {
      if (measure.kind !== "paragraph") {
        throw new Error(`layoutDocument: expected paragraph measure for block ${block.id}`);
      }
      const paraBlock = block;
      const isEmpty2 = !paraBlock.runs || paraBlock.runs.length === 0 || paraBlock.runs.length === 1 && (!paraBlock.runs[0].kind || paraBlock.runs[0].kind === "text") && (!paraBlock.runs[0].text || paraBlock.runs[0].text === "");
      if (isEmpty2) {
        const isSectPrMarker = paraBlock.attrs?.sectPrMarker === true;
        const prevBlock = index2 > 0 ? blocks[index2 - 1] : null;
        const nextBlock = index2 < blocks.length - 1 ? blocks[index2 + 1] : null;
        const nextSectionBreak = nextBlock?.kind === "sectionBreak" ? nextBlock : null;
        const nextBreakType = nextSectionBreak?.type ?? (nextSectionBreak?.attrs?.source === "sectPr" ? "nextPage" : void 0);
        const nextBreakForcesPage = nextSectionBreak && (nextBreakType === "nextPage" || nextBreakType === "evenPage" || nextBreakType === "oddPage" || nextSectionBreak.attrs?.requirePageBoundary === true);
        if (isSectPrMarker && nextBreakForcesPage) {
          continue;
        }
        if (prevBlock?.kind === "pageBreak" && nextBlock?.kind === "sectionBreak") {
          continue;
        }
      }
      const anchorsForPara = anchoredByParagraph.get(index2);
      const tablesForPara = anchoredTablesByParagraph.get(index2);
      if (tablesForPara) {
        const state = paginator.ensurePage();
        for (const { block: tableBlock, measure: tableMeasure } of tablesForPara) {
          if (placedAnchoredTableIds.has(tableBlock.id)) continue;
          floatManager.registerTable(tableBlock, tableMeasure, state.cursorY, state.columnIndex, state.page.number);
          const anchorX = tableBlock.anchor?.offsetH ?? columnX(state.columnIndex);
          const anchorY = state.cursorY + (tableBlock.anchor?.offsetV ?? 0);
          const tableFragment = createAnchoredTableFragment(tableBlock, tableMeasure, anchorX, anchorY);
          state.page.fragments.push(tableFragment);
          placedAnchoredTableIds.add(tableBlock.id);
        }
      }
      const chain = keepNextChains.get(index2);
      if (midChainIndices.has(index2)) ;
      else if (chain) {
        let state = paginator.ensurePage();
        const availableHeight = state.contentBottom - state.cursorY;
        const firstMemberBlock = blocks[chain.startIndex];
        const firstMemberStyleId = typeof firstMemberBlock.attrs?.styleId === "string" ? firstMemberBlock.attrs?.styleId : void 0;
        const firstMemberContextualSpacing = firstMemberBlock.attrs?.contextualSpacing === true;
        const contextualSpacingApplies = firstMemberContextualSpacing && firstMemberStyleId && state.lastParagraphStyleId === firstMemberStyleId;
        const prevTrailing = Number.isFinite(state.trailingSpacing) && state.trailingSpacing > 0 ? state.trailingSpacing : 0;
        const effectiveAvailableHeight = contextualSpacingApplies ? availableHeight + prevTrailing : availableHeight;
        const chainHeight = calculateChainHeight(chain, blocks, measures, state);
        const pageContentHeight = state.contentBottom - state.topMargin;
        const chainFitsOnBlankPage = chainHeight <= pageContentHeight;
        if (chainFitsOnBlankPage && chainHeight > effectiveAvailableHeight && state.page.fragments.length > 0) {
          state = paginator.advanceColumn(state);
        }
      } else if (paraBlock.attrs?.keepNext === true) {
        const nextBlock = blocks[index2 + 1];
        const nextMeasure = measures[index2 + 1];
        if (nextBlock && nextMeasure && nextBlock.kind !== "sectionBreak" && nextBlock.kind !== "pageBreak" && nextBlock.kind !== "columnBreak") {
          const shouldSkipAnchoredTable = nextBlock.kind === "table" && nextBlock.anchor?.isAnchored === true;
          if (!shouldSkipAnchoredTable) {
            let state = paginator.ensurePage();
            const availableHeight = state.contentBottom - state.cursorY;
            const spacingBefore = getParagraphSpacingBefore(paraBlock);
            const spacingAfter = getParagraphSpacingAfter$1(paraBlock);
            const prevTrailing = Number.isFinite(state.trailingSpacing) && state.trailingSpacing > 0 ? state.trailingSpacing : 0;
            const currentStyleId = typeof paraBlock.attrs?.styleId === "string" ? paraBlock.attrs?.styleId : void 0;
            const currentContextualSpacing = asBoolean(paraBlock.attrs?.contextualSpacing);
            const contextualSpacingApplies = currentContextualSpacing && currentStyleId && state.lastParagraphStyleId === currentStyleId;
            const effectiveSpacingBefore = contextualSpacingApplies ? 0 : Math.max(spacingBefore - prevTrailing, 0);
            const currentHeight = getMeasureHeight(paraBlock, measure);
            const nextHeight = getMeasureHeight(nextBlock, nextMeasure);
            const nextIsParagraph = nextBlock.kind === "paragraph" && nextMeasure.kind === "paragraph";
            const nextSpacingBefore = nextIsParagraph ? getParagraphSpacingBefore(nextBlock) : 0;
            const nextStyleId = nextIsParagraph && typeof nextBlock.attrs?.styleId === "string" ? nextBlock.attrs?.styleId : void 0;
            const nextContextualSpacing = nextIsParagraph && asBoolean(nextBlock.attrs?.contextualSpacing);
            const sameStyleAsNext = currentStyleId && nextStyleId && nextStyleId === currentStyleId;
            const effectiveSpacingAfter = currentContextualSpacing && sameStyleAsNext ? 0 : spacingAfter;
            const effectiveNextSpacingBefore = nextContextualSpacing && sameStyleAsNext ? 0 : nextSpacingBefore;
            const interParagraphSpacing = nextIsParagraph ? Math.max(effectiveSpacingAfter, effectiveNextSpacingBefore) : effectiveSpacingAfter;
            const nextFirstLineHeight = (() => {
              if (!nextIsParagraph) {
                return nextHeight;
              }
              const firstLineHeight = nextMeasure.lines[0]?.lineHeight;
              if (typeof firstLineHeight === "number" && Number.isFinite(firstLineHeight) && firstLineHeight > 0) {
                return firstLineHeight;
              }
              return nextHeight;
            })();
            const combinedHeight = nextIsParagraph ? effectiveSpacingBefore + currentHeight + interParagraphSpacing + nextFirstLineHeight : effectiveSpacingBefore + currentHeight + spacingAfter + nextHeight;
            const effectiveAvailableHeight = contextualSpacingApplies ? availableHeight + prevTrailing : availableHeight;
            if (combinedHeight > effectiveAvailableHeight && state.page.fragments.length > 0) {
              state = paginator.advanceColumn(state);
            }
          }
        }
      }
      let overrideSpacingAfter;
      const curStyleId = typeof paraBlock.attrs?.styleId === "string" ? paraBlock.attrs.styleId : void 0;
      const curContextualSpacing = asBoolean(paraBlock.attrs?.contextualSpacing);
      if (curContextualSpacing && curStyleId) {
        const nextBlock = index2 < blocks.length - 1 ? blocks[index2 + 1] : null;
        if (nextBlock?.kind === "paragraph") {
          const nextStyleId = typeof nextBlock.attrs?.styleId === "string" ? nextBlock.attrs?.styleId : void 0;
          if (nextStyleId === curStyleId) {
            overrideSpacingAfter = 0;
          }
        }
      }
      layoutParagraphBlock(
        {
          block,
          measure,
          columnWidth: getCurrentColumns().width,
          ensurePage: paginator.ensurePage,
          advanceColumn: paginator.advanceColumn,
          columnX,
          floatManager,
          remeasureParagraph: options.remeasureParagraph,
          overrideSpacingAfter
        },
        anchorsForPara ? {
          anchoredDrawings: anchorsForPara,
          pageWidth: activePageSize.w,
          pageMargins: {
            top: activeTopMargin,
            bottom: activeBottomMargin,
            left: activeLeftMargin,
            right: activeRightMargin
          },
          columns: getCurrentColumns(),
          placedAnchoredIds
        } : void 0
      );
      continue;
    }
    if (block.kind === "image") {
      if (measure.kind !== "image") {
        throw new Error(`layoutDocument: expected image measure for block ${block.id}`);
      }
      const preRegPos = preRegisteredPositions.get(block.id);
      if (preRegPos && Number.isFinite(preRegPos.anchorX) && Number.isFinite(preRegPos.anchorY) && Number.isFinite(preRegPos.pageNumber)) {
        const state = paginator.ensurePage();
        const imgBlock = block;
        const imgMeasure = measure;
        const pageContentHeight = Math.max(0, state.contentBottom - state.topMargin);
        const relativeFrom = imgBlock.anchor?.hRelativeFrom ?? "column";
        const cols = getCurrentColumns();
        let maxWidth;
        if (relativeFrom === "page") {
          maxWidth = cols.count === 1 ? activePageSize.w - (activeLeftMargin + activeRightMargin) : activePageSize.w;
        } else if (relativeFrom === "margin") {
          maxWidth = activePageSize.w - (activeLeftMargin + activeRightMargin);
        } else {
          maxWidth = cols.width;
        }
        const aspectRatio = imgMeasure.width > 0 && imgMeasure.height > 0 ? imgMeasure.width / imgMeasure.height : 1;
        const minWidth = 20;
        const minHeight = minWidth / aspectRatio;
        const metadata = {
          originalWidth: imgMeasure.width,
          originalHeight: imgMeasure.height,
          maxWidth,
          maxHeight: pageContentHeight,
          aspectRatio,
          minWidth,
          minHeight
        };
        const fragment = {
          kind: "image",
          blockId: imgBlock.id,
          x: preRegPos.anchorX,
          y: preRegPos.anchorY,
          width: imgMeasure.width,
          height: imgMeasure.height,
          isAnchored: true,
          zIndex: imgBlock.anchor?.behindDoc ? 0 : 1,
          metadata
        };
        const attrs = imgBlock.attrs;
        if (attrs?.pmStart != null) fragment.pmStart = attrs.pmStart;
        if (attrs?.pmEnd != null) fragment.pmEnd = attrs.pmEnd;
        state.page.fragments.push(fragment);
        placedAnchoredIds.add(imgBlock.id);
        continue;
      }
      layoutImageBlock({
        block,
        measure,
        columns: getCurrentColumns(),
        ensurePage: paginator.ensurePage,
        advanceColumn: paginator.advanceColumn,
        columnX
      });
      continue;
    }
    if (block.kind === "drawing") {
      if (measure.kind !== "drawing") {
        throw new Error(`layoutDocument: expected drawing measure for block ${block.id}`);
      }
      layoutDrawingBlock({
        block,
        measure,
        columns: getCurrentColumns(),
        ensurePage: paginator.ensurePage,
        advanceColumn: paginator.advanceColumn,
        columnX
      });
      continue;
    }
    if (block.kind === "table") {
      if (measure.kind !== "table") {
        throw new Error(`layoutDocument: expected table measure for block ${block.id}`);
      }
      layoutTableBlock({
        block,
        measure,
        columnWidth: getCurrentColumns().width,
        ensurePage: paginator.ensurePage,
        advanceColumn: paginator.advanceColumn,
        columnX
      });
      continue;
    }
    if (block.kind === "pageBreak") {
      if (measure.kind !== "pageBreak") {
        throw new Error(`layoutDocument: expected pageBreak measure for block ${block.id}`);
      }
      paginator.startNewPage();
      continue;
    }
    if (block.kind === "columnBreak") {
      if (measure.kind !== "columnBreak") {
        throw new Error(`layoutDocument: expected columnBreak measure for block ${block.id}`);
      }
      const state = paginator.ensurePage();
      const activeCols = getActiveColumnsForState(state);
      if (state.columnIndex < activeCols.count - 1) {
        advanceColumn(state);
      } else {
        paginator.startNewPage();
      }
      continue;
    }
    throw new Error(`layoutDocument: unsupported block kind for ${block.id}`);
  }
  while (pages.length > 0 && pages[pages.length - 1].fragments.length === 0) {
    pages.pop();
  }
  for (const page of pages) {
    if (!page.vAlign || page.vAlign === "top") {
      continue;
    }
    if (page.fragments.length === 0) {
      continue;
    }
    const pageSizeForPage = page.size ?? pageSize;
    const baseTop = page.baseMargins?.top ?? page.margins?.top ?? margins.top;
    const baseBottom = page.baseMargins?.bottom ?? page.margins?.bottom ?? margins.bottom;
    const contentTop = baseTop;
    const contentBottom = pageSizeForPage.h - baseBottom;
    const contentHeight = contentBottom - contentTop;
    let minY = Infinity;
    let maxY = -Infinity;
    for (const fragment of page.fragments) {
      if (fragment.y < minY) minY = fragment.y;
      let fragmentBottom = fragment.y;
      if (hasHeight(fragment)) {
        fragmentBottom += fragment.height;
      } else {
        const lineCount = fragment.toLine - fragment.fromLine;
        fragmentBottom += lineCount * DEFAULT_PARAGRAPH_LINE_HEIGHT_PX;
      }
      if (fragmentBottom > maxY) maxY = fragmentBottom;
    }
    const actualContentHeight = maxY - minY;
    const availableSpace = contentHeight - actualContentHeight;
    if (availableSpace <= 0) {
      continue;
    }
    let yOffset = 0;
    if (page.vAlign === "center") {
      yOffset = availableSpace / 2;
    } else if (page.vAlign === "bottom") {
      yOffset = availableSpace;
    } else if (page.vAlign === "both") {
      yOffset = availableSpace / 2;
    }
    if (yOffset > 0) {
      for (const fragment of page.fragments) {
        fragment.y += yOffset;
      }
    }
  }
  if (activeColumns.count > 1) {
    const contentWidth = pageSize.w - (activeLeftMargin + activeRightMargin);
    const normalizedCols = normalizeColumns(activeColumns, contentWidth);
    const measureMap = /* @__PURE__ */ new Map();
    const blockSectionMap = /* @__PURE__ */ new Map();
    blocks.forEach((block, idx) => {
      const measure = measures[idx];
      if (measure) {
        measureMap.set(block.id, measure);
      }
      const blockWithAttrs = block;
      const sectionIdx = blockWithAttrs.attrs?.sectionIndex;
      if (typeof sectionIdx === "number") {
        blockSectionMap.set(block.id, sectionIdx);
      }
    });
    for (const page of pages) {
      if (page === pages[pages.length - 1] && page.fragments.length > 0) {
        const uniqueXPositions = new Set(page.fragments.map((f) => Math.round(f.x)));
        const hasExplicitColumnStructure = uniqueXPositions.size > 1;
        if (hasExplicitColumnStructure) {
          continue;
        }
        const uniqueWidths = new Set(page.fragments.map((f) => Math.round(f.width)));
        const hasMixedColumnWidths = uniqueWidths.size > 1;
        if (hasMixedColumnWidths) {
          continue;
        }
        const fragmentSections = /* @__PURE__ */ new Set();
        for (const f of page.fragments) {
          const section = blockSectionMap.get(f.blockId);
          if (section !== void 0) {
            fragmentSections.add(section);
          }
        }
        const hasMixedSections = fragmentSections.size > 1;
        const fragmentsToBalance = hasMixedSections ? page.fragments.filter((f) => {
          const fragSection = blockSectionMap.get(f.blockId);
          return fragSection === activeSectionIndex;
        }) : page.fragments;
        if (fragmentsToBalance.length > 0) {
          balancePageColumns(
            fragmentsToBalance,
            normalizedCols,
            { left: activeLeftMargin },
            activeTopMargin,
            measureMap
          );
        }
      }
    }
  }
  return {
    pageSize,
    pages,
    // Note: columns here reflects the effective default for subsequent pages
    // after processing sections. Page/region-specific column changes are encoded
    // implicitly via fragment positions. Consumers should not assume this is
    // a static document-wide value.
    columns: activeColumns.count > 1 ? { count: activeColumns.count, gap: activeColumns.gap } : void 0
  };
}
function layoutHeaderFooter(blocks, measures, constraints) {
  if (blocks.length !== measures.length) {
    throw new Error(
      `layoutHeaderFooter expected measures for every block (blocks=${blocks.length}, measures=${measures.length})`
    );
  }
  const width = Number(constraints?.width);
  const height = Number(constraints?.height);
  if (!Number.isFinite(width) || width <= 0) {
    throw new Error("layoutHeaderFooter: width must be positive");
  }
  if (!Number.isFinite(height) || height <= 0) {
    return { pages: [], height: 0 };
  }
  const marginLeft = constraints.margins?.left ?? 0;
  const transformedBlocks = marginLeft > 0 ? blocks.map((block) => {
    const hasPageRelativeAnchor = (block.kind === "image" || block.kind === "drawing") && block.anchor?.hRelativeFrom === "page" && block.anchor.offsetH != null;
    if (hasPageRelativeAnchor) {
      return {
        ...block,
        anchor: {
          ...block.anchor,
          offsetH: block.anchor.offsetH - marginLeft
        }
      };
    }
    return block;
  }) : blocks;
  const layout = layoutDocument(transformedBlocks, measures, {
    pageSize: { w: width, h: height },
    margins: { top: 0, right: 0, bottom: 0, left: 0 }
  });
  const idToIndex = /* @__PURE__ */ new Map();
  for (let i = 0; i < blocks.length; i += 1) {
    idToIndex.set(blocks[i].id, i);
  }
  let minY = 0;
  let maxY = 0;
  for (const page of layout.pages) {
    for (const fragment of page.fragments) {
      const idx = idToIndex.get(fragment.blockId);
      if (idx == null) continue;
      const block = blocks[idx];
      const measure = measures[idx];
      const isAnchoredFragment = (fragment.kind === "image" || fragment.kind === "drawing") && fragment.isAnchored === true;
      if (isAnchoredFragment) {
        if (block.kind !== "image" && block.kind !== "drawing") {
          throw new Error(
            `Type mismatch: fragment kind is ${fragment.kind} but block kind is ${block.kind} for block ${block.id}`
          );
        }
        const anchoredBlock = block;
        if (anchoredBlock.anchor?.behindDoc) {
          continue;
        }
      }
      if (fragment.y < minY) minY = fragment.y;
      let bottom2 = fragment.y;
      if (fragment.kind === "para" && measure?.kind === "paragraph") {
        let sum = 0;
        for (let li = fragment.fromLine; li < fragment.toLine; li += 1) {
          sum += measure.lines[li]?.lineHeight ?? 0;
        }
        bottom2 += sum;
        const spacingAfter = block?.attrs?.spacing?.after;
        if (spacingAfter && fragment.toLine === measure.lines.length) {
          bottom2 += Math.max(0, Number(spacingAfter));
        }
      } else if (fragment.kind === "image") {
        const h2 = typeof fragment.height === "number" ? fragment.height : measure?.height ?? 0;
        bottom2 += h2;
      } else if (fragment.kind === "drawing") {
        const drawingHeight = typeof fragment.height === "number" ? fragment.height : measure?.height ?? 0;
        bottom2 += drawingHeight;
      } else if (fragment.kind === "list-item") {
        const listMeasure = measure;
        if (listMeasure) {
          const item = listMeasure.items.find((it) => it.itemId === fragment.itemId);
          if (item?.paragraph) {
            let sum = 0;
            for (let li = fragment.fromLine; li < fragment.toLine; li += 1) {
              sum += item.paragraph.lines[li]?.lineHeight ?? 0;
            }
            bottom2 += sum;
          }
        }
      }
      if (bottom2 > maxY) maxY = bottom2;
    }
  }
  return {
    height: maxY - minY,
    minY,
    maxY,
    pages: layout.pages.map((page) => ({ number: page.number, fragments: page.fragments }))
  };
}
function normalizeColumns(input, contentWidth) {
  const rawCount = Number.isFinite(input?.count) ? Math.floor(input.count) : 1;
  const count = Math.max(1, rawCount || 1);
  const gap = Math.max(0, input?.gap ?? 0);
  const totalGap = gap * (count - 1);
  const width = (contentWidth - totalGap) / count;
  if (width <= COLUMN_EPSILON$1) {
    return {
      count: 1,
      gap: 0,
      width: contentWidth
    };
  }
  return {
    count,
    gap,
    width
  };
}
const fieldAnnotationKey = (run) => {
  if (run.kind !== "fieldAnnotation") return "";
  const annotation = run;
  const sizeKey = annotation.size ? `${annotation.size.width ?? ""}x${annotation.size.height ?? ""}` : "";
  const highlightKey = annotation.highlighted === false ? "nohl" : "hl";
  const hiddenKey = annotation.hidden ? "hidden" : "";
  return [
    annotation.variant ?? "",
    annotation.displayLabel ?? "",
    annotation.imageSrc ?? "",
    annotation.rawHtml ?? "",
    annotation.linkUrl ?? "",
    annotation.fontFamily ?? "",
    annotation.fontSize ?? "",
    annotation.bold ? "b" : "",
    annotation.italic ? "i" : "",
    annotation.underline ? "u" : "",
    highlightKey,
    hiddenKey,
    annotation.visibility ?? "",
    sizeKey
  ].join("|");
};
const hasTrackedChange = (run) => {
  return "trackedChange" in run && run.trackedChange !== void 0 && run.trackedChange !== null;
};
const resolveTrackedChangesEnabled = (attrs, defaultEnabled = true) => {
  if (!attrs || !("trackedChangesEnabled" in attrs)) {
    return defaultEnabled;
  }
  return attrs.trackedChangesEnabled !== false;
};
const hashParagraphBorder = (border) => {
  const parts = [];
  if (border.style !== void 0) parts.push(`s:${border.style}`);
  if (border.width !== void 0) parts.push(`w:${border.width}`);
  if (border.color !== void 0) parts.push(`c:${border.color}`);
  if (border.space !== void 0) parts.push(`sp:${border.space}`);
  return parts.join(",");
};
const hashParagraphBorders = (borders) => {
  const parts = [];
  if (borders.top) parts.push(`t:[${hashParagraphBorder(borders.top)}]`);
  if (borders.right) parts.push(`r:[${hashParagraphBorder(borders.right)}]`);
  if (borders.bottom) parts.push(`b:[${hashParagraphBorder(borders.bottom)}]`);
  if (borders.left) parts.push(`l:[${hashParagraphBorder(borders.left)}]`);
  return parts.join(";");
};
function isNoneBorder(value) {
  return typeof value === "object" && value !== null && "none" in value && value.none === true;
}
function isBorderSpec(value) {
  return typeof value === "object" && value !== null && !("none" in value);
}
const hashBorderSpec = (border) => {
  const parts = [];
  if (border.style !== void 0) parts.push(`s:${border.style}`);
  if (border.width !== void 0) parts.push(`w:${border.width}`);
  if (border.color !== void 0) parts.push(`c:${border.color}`);
  if (border.space !== void 0) parts.push(`sp:${border.space}`);
  return parts.join(",");
};
const hashTableBorderValue = (borderValue) => {
  if (borderValue === void 0) return "";
  if (borderValue === null) return "null";
  if (isNoneBorder(borderValue)) return "none";
  if (isBorderSpec(borderValue)) {
    return hashBorderSpec(borderValue);
  }
  return "";
};
const hashTableBorders = (borders) => {
  if (!borders) return "";
  const parts = [];
  if (borders.top !== void 0) parts.push(`t:[${hashTableBorderValue(borders.top)}]`);
  if (borders.right !== void 0) parts.push(`r:[${hashTableBorderValue(borders.right)}]`);
  if (borders.bottom !== void 0) parts.push(`b:[${hashTableBorderValue(borders.bottom)}]`);
  if (borders.left !== void 0) parts.push(`l:[${hashTableBorderValue(borders.left)}]`);
  if (borders.insideH !== void 0) parts.push(`ih:[${hashTableBorderValue(borders.insideH)}]`);
  if (borders.insideV !== void 0) parts.push(`iv:[${hashTableBorderValue(borders.insideV)}]`);
  return parts.join(";");
};
const hashCellBorders = (borders) => {
  if (!borders) return "";
  const parts = [];
  if (borders.top) parts.push(`t:[${hashBorderSpec(borders.top)}]`);
  if (borders.right) parts.push(`r:[${hashBorderSpec(borders.right)}]`);
  if (borders.bottom) parts.push(`b:[${hashBorderSpec(borders.bottom)}]`);
  if (borders.left) parts.push(`l:[${hashBorderSpec(borders.left)}]`);
  return parts.join(";");
};
function hasComments$1(run) {
  return "comments" in run && Array.isArray(run.comments) && run.comments.length > 0;
}
const MAX_CACHE_SIZE$1 = 1e4;
const BYTES_PER_ENTRY_ESTIMATE = 5e3;
const hashParagraphFrame = (frame) => {
  const parts = [];
  if (frame.wrap !== void 0) parts.push(`w:${frame.wrap}`);
  if (frame.x !== void 0) parts.push(`x:${frame.x}`);
  if (frame.y !== void 0) parts.push(`y:${frame.y}`);
  if (frame.xAlign !== void 0) parts.push(`xa:${frame.xAlign}`);
  if (frame.yAlign !== void 0) parts.push(`ya:${frame.yAlign}`);
  if (frame.hAnchor !== void 0) parts.push(`ha:${frame.hAnchor}`);
  if (frame.vAnchor !== void 0) parts.push(`va:${frame.vAnchor}`);
  return parts.join(",");
};
const hashRuns = (block) => {
  if (block.kind === "table") {
    const tableBlock = block;
    const cellHashes = [];
    if (!tableBlock.rows) {
      return `${block.id}:table:`;
    }
    for (const row of tableBlock.rows) {
      if (!row.cells) {
        continue;
      }
      for (const cell of row.cells) {
        if (cell.attrs) {
          const cellAttrs = cell.attrs;
          const cellAttrParts = [];
          if (cellAttrs.borders) {
            cellAttrParts.push(`cb:${hashCellBorders(cellAttrs.borders)}`);
          }
          if (cellAttrs.padding) {
            const p2 = cellAttrs.padding;
            cellAttrParts.push(`cp:${p2.top ?? 0}:${p2.right ?? 0}:${p2.bottom ?? 0}:${p2.left ?? 0}`);
          }
          if (cellAttrs.verticalAlign) {
            cellAttrParts.push(`va:${cellAttrs.verticalAlign}`);
          }
          if (cellAttrs.background) {
            cellAttrParts.push(`bg:${cellAttrs.background}`);
          }
          if (cellAttrParts.length > 0) {
            cellHashes.push(`ca:${cellAttrParts.join(":")}`);
          }
        }
        const cellBlocks = cell.blocks ?? (cell.paragraph ? [cell.paragraph] : []);
        for (const cellBlock of cellBlocks) {
          const paragraphBlock = cellBlock;
          if (!paragraphBlock.runs) {
            continue;
          }
          for (const run of paragraphBlock.runs) {
            const text = "text" in run && typeof run.text === "string" ? run.text : "";
            const bold = "bold" in run ? run.bold : false;
            const italic = "italic" in run ? run.italic : false;
            const color = "color" in run ? run.color : void 0;
            const fontSize2 = "fontSize" in run ? run.fontSize : void 0;
            const fontFamily2 = "fontFamily" in run ? run.fontFamily : void 0;
            const highlight = "highlight" in run ? run.highlight : void 0;
            const marks = [
              bold ? "b" : "",
              italic ? "i" : "",
              color ?? "",
              fontSize2 !== void 0 ? `fs:${fontSize2}` : "",
              fontFamily2 ? `ff:${fontFamily2}` : "",
              highlight ? `hl:${highlight}` : ""
            ].join("");
            const commentHash = hasComments$1(run) ? run.comments.map((c2) => `${c2.commentId ?? ""}:${c2.internal ? "1" : "0"}`).join("|") : "";
            let trackedKey = "";
            if (hasTrackedChange(run)) {
              const tc = run.trackedChange;
              const beforeHash = tc.before ? JSON.stringify(tc.before) : "";
              const afterHash = tc.after ? JSON.stringify(tc.after) : "";
              trackedKey = `|tc:${tc.kind ?? ""}:${tc.id ?? ""}:${tc.author ?? ""}:${tc.date ?? ""}:${beforeHash}:${afterHash}`;
            }
            const commentKey = commentHash ? `|cm:${commentHash}` : "";
            cellHashes.push(`${text}:${marks}${trackedKey}${commentKey}`);
          }
          if (paragraphBlock.attrs) {
            const attrs = paragraphBlock.attrs;
            const parts = [];
            if (attrs.alignment) parts.push(`al:${attrs.alignment}`);
            if (attrs.spacing) {
              const s = attrs.spacing;
              if (s.before !== void 0) parts.push(`sb:${s.before}`);
              if (s.after !== void 0) parts.push(`sa:${s.after}`);
              if (s.line !== void 0) parts.push(`sl:${s.line}`);
              if (s.lineRule) parts.push(`sr:${s.lineRule}`);
            }
            if (attrs.indent) {
              const ind = attrs.indent;
              if (ind.left !== void 0) parts.push(`il:${ind.left}`);
              if (ind.right !== void 0) parts.push(`ir:${ind.right}`);
              if (ind.firstLine !== void 0) parts.push(`if:${ind.firstLine}`);
              if (ind.hanging !== void 0) parts.push(`ih:${ind.hanging}`);
            }
            if (attrs.borders) {
              parts.push(`br:${hashParagraphBorders(attrs.borders)}`);
            }
            if (attrs.shading) {
              const sh = attrs.shading;
              if (sh.fill) parts.push(`shf:${sh.fill}`);
              if (sh.color) parts.push(`shc:${sh.color}`);
            }
            if (attrs.direction) parts.push(`dir:${attrs.direction}`);
            if (attrs.rtl) parts.push("rtl");
            if (parts.length > 0) {
              cellHashes.push(`pa:${parts.join(":")}`);
            }
          }
        }
      }
    }
    let tableAttrsKey = "";
    if (tableBlock.attrs) {
      const tblAttrs = tableBlock.attrs;
      const tableAttrParts = [];
      if (tblAttrs.borders) {
        tableAttrParts.push(`tb:${hashTableBorders(tblAttrs.borders)}`);
      }
      if (tblAttrs.borderCollapse) {
        tableAttrParts.push(`bc:${tblAttrs.borderCollapse}`);
      }
      if (tblAttrs.cellSpacing !== void 0) {
        tableAttrParts.push(`cs:${tblAttrs.cellSpacing}`);
      }
      if (tableAttrParts.length > 0) {
        tableAttrsKey = `|ta:${tableAttrParts.join(":")}`;
      }
    }
    const contentHash = cellHashes.join("|");
    return `${block.id}:table:${contentHash}${tableAttrsKey}`;
  }
  if (block.kind !== "paragraph") return block.id;
  const trackedMode = block.attrs && "trackedChangesMode" in block.attrs && block.attrs.trackedChangesMode || "review";
  const trackedEnabled = resolveTrackedChangesEnabled(block.attrs, true);
  const runsHash = block.runs.map((run) => {
    if (run.kind === "image") {
      const imgRun = run;
      const srcHash = imgRun.src.slice(0, 50);
      return `img:${srcHash}:${imgRun.width}x${imgRun.height}`;
    }
    if (run.kind === "fieldAnnotation") {
      return `fa:${fieldAnnotationKey(run)}`;
    }
    const text = "src" in run || run.kind === "lineBreak" || run.kind === "break" ? "" : run.text ?? "";
    const bold = "bold" in run ? run.bold : false;
    const italic = "italic" in run ? run.italic : false;
    const color = "color" in run ? run.color : void 0;
    const fontSize2 = "fontSize" in run ? run.fontSize : void 0;
    const fontFamily2 = "fontFamily" in run ? run.fontFamily : void 0;
    const highlight = "highlight" in run ? run.highlight : void 0;
    const marks = [
      bold ? "b" : "",
      italic ? "i" : "",
      color ?? "",
      fontSize2 !== void 0 ? `fs:${fontSize2}` : "",
      fontFamily2 ? `ff:${fontFamily2}` : "",
      highlight ? `hl:${highlight}` : ""
    ].join("");
    let trackedKey = "";
    if (hasTrackedChange(run)) {
      const tc = run.trackedChange;
      const beforeHash = tc.before ? JSON.stringify(tc.before) : "";
      const afterHash = tc.after ? JSON.stringify(tc.after) : "";
      trackedKey = `|tc:${tc.kind ?? ""}:${tc.id ?? ""}:${tc.author ?? ""}:${tc.date ?? ""}:${beforeHash}:${afterHash}`;
    }
    return `${text}:${marks}${trackedKey}`;
  }).join("|");
  let numberingKey = "";
  if (block.attrs) {
    const attrs = block.attrs;
    if (attrs.numberingProperties) {
      const np = attrs.numberingProperties;
      let markerTextKey;
      if (!attrs.wordLayout?.marker) {
        markerTextKey = "<NULL>";
      } else {
        const markerText = attrs.wordLayout.marker.markerText;
        markerTextKey = markerText === "" ? "<EMPTY>" : markerText ?? "<NULL>";
      }
      numberingKey = `|num:${np.numId ?? ""}:${np.ilvl ?? 0}:${markerTextKey}`;
    }
  }
  let paragraphAttrsKey = "";
  if (block.attrs) {
    const attrs = block.attrs;
    const parts = [];
    if (attrs.alignment) parts.push(`al:${attrs.alignment}`);
    if (attrs.spacing) {
      const s = attrs.spacing;
      if (s.before !== void 0) parts.push(`sb:${s.before}`);
      if (s.after !== void 0) parts.push(`sa:${s.after}`);
      if (s.line !== void 0) parts.push(`sl:${s.line}`);
      if (s.lineRule) parts.push(`sr:${s.lineRule}`);
    }
    if (attrs.indent) {
      const ind = attrs.indent;
      if (ind.left !== void 0) parts.push(`il:${ind.left}`);
      if (ind.right !== void 0) parts.push(`ir:${ind.right}`);
      if (ind.firstLine !== void 0) parts.push(`if:${ind.firstLine}`);
      if (ind.hanging !== void 0) parts.push(`ih:${ind.hanging}`);
    }
    if (attrs.borders) {
      parts.push(`br:${hashParagraphBorders(attrs.borders)}`);
    }
    if (attrs.shading) {
      const sh = attrs.shading;
      if (sh.fill) parts.push(`shf:${sh.fill}`);
      if (sh.color) parts.push(`shc:${sh.color}`);
    }
    if (attrs.tabs && attrs.tabs.length > 0) {
      const tabsHash = attrs.tabs.map((t) => `${t.val ?? ""}:${t.pos ?? ""}:${t.leader ?? ""}`).join(",");
      parts.push(`tb:${tabsHash}`);
    }
    if (attrs.direction) parts.push(`dir:${attrs.direction}`);
    if (attrs.rtl) parts.push("rtl");
    if (attrs.keepNext) parts.push("kn");
    if (attrs.keepLines) parts.push("kl");
    if (attrs.floatAlignment) parts.push(`fa:${attrs.floatAlignment}`);
    if (attrs.contextualSpacing) parts.push("cs");
    if (attrs.suppressFirstLineIndent) parts.push("sfi");
    if (attrs.dropCap) parts.push(`dc:${attrs.dropCap}`);
    if (attrs.dropCapDescriptor) {
      const dcd = attrs.dropCapDescriptor;
      parts.push(`dcd:${dcd.mode ?? ""}:${dcd.lines ?? ""}`);
    }
    if (attrs.frame) {
      parts.push(`fr:${hashParagraphFrame(attrs.frame)}`);
    }
    if (attrs.tabIntervalTwips !== void 0) parts.push(`ti:${attrs.tabIntervalTwips}`);
    if (attrs.decimalSeparator) parts.push(`ds:${attrs.decimalSeparator}`);
    if (parts.length > 0) {
      paragraphAttrsKey = `|pa:${parts.join(":")}`;
    }
  }
  return `${trackedMode}:${trackedEnabled ? "on" : "off"}|${runsHash}${numberingKey}${paragraphAttrsKey}`;
};
const createStats = () => ({
  hits: 0,
  misses: 0,
  sets: 0,
  invalidations: 0,
  clears: 0,
  evictions: 0,
  size: 0,
  memorySizeEstimate: 0
});
const MAX_DIMENSION = 1e6;
class MeasureCache {
  constructor() {
    this.cache = /* @__PURE__ */ new Map();
    this.stats = createStats();
  }
  /**
   * Retrieve a cached measure for the given block and dimensions.
   * Returns undefined if the block is null/undefined, lacks an ID, or if no cached value exists.
   *
   * @param block - The flow block to look up (may be null/undefined)
   * @param width - The width dimension for cache key
   * @param height - The height dimension for cache key
   * @returns The cached value or undefined
   */
  get(block, width, height) {
    if (!block || !block.id) {
      return void 0;
    }
    const key2 = this.composeKey(block, width, height);
    const value = this.cache.get(key2);
    if (value !== void 0) {
      this.stats.hits += 1;
      this.cache.delete(key2);
      this.cache.set(key2, value);
      return value;
    } else {
      this.stats.misses += 1;
      return void 0;
    }
  }
  /**
   * Store a measure in the cache for the given block and dimensions.
   * Silently returns if the block is null/undefined or lacks an ID.
   *
   * @param block - The flow block to cache (may be null/undefined)
   * @param width - The width dimension for cache key
   * @param height - The height dimension for cache key
   * @param value - The value to cache
   */
  set(block, width, height, value) {
    if (!block || !block.id) {
      return;
    }
    const key2 = this.composeKey(block, width, height);
    if (this.cache.has(key2)) {
      this.cache.delete(key2);
    }
    if (this.cache.size >= MAX_CACHE_SIZE$1) {
      const oldestKey = this.cache.keys().next().value;
      if (oldestKey !== void 0) {
        this.cache.delete(oldestKey);
        this.stats.evictions += 1;
      }
    }
    this.cache.set(key2, value);
    this.stats.sets += 1;
    this.updateSizeStats();
  }
  /**
   * Invalidates cached measurements for specific block IDs.
   * Removes all cache entries whose keys start with any of the provided block IDs.
   *
   * @param blockIds - Array of block IDs to invalidate from the cache
   *
   * @example
   * ```typescript
   * cache.invalidate(['block-123', 'block-456']);
   * ```
   */
  invalidate(blockIds) {
    let removed = 0;
    blockIds.forEach((id) => {
      for (const key2 of this.cache.keys()) {
        if (key2.startsWith(id + "@")) {
          this.cache.delete(key2);
          removed += 1;
        }
      }
    });
    this.stats.invalidations += removed;
    this.updateSizeStats();
  }
  /**
   * Clears all cached measurements and resets statistics.
   * Use when performing a full document re-layout.
   */
  clear() {
    this.cache.clear();
    this.stats.clears += 1;
    this.updateSizeStats();
  }
  /**
   * Resets cache statistics (hits, misses, sets) to zero.
   * Does not clear cached values.
   */
  resetStats() {
    const currentSize = this.cache.size;
    const currentMemory = currentSize * BYTES_PER_ENTRY_ESTIMATE;
    this.stats = createStats();
    this.stats.size = currentSize;
    this.stats.memorySizeEstimate = currentMemory;
  }
  /**
   * Returns current cache performance statistics.
   * Useful for monitoring cache effectiveness.
   *
   * @returns Object containing hits, misses, sets, and hit rate
   */
  getStats() {
    return { ...this.stats };
  }
  /**
   * Get current cache size (number of entries)
   */
  getSize() {
    return this.cache.size;
  }
  /**
   * Get maximum cache size
   */
  getMaxSize() {
    return MAX_CACHE_SIZE$1;
  }
  /**
   * Check if cache is near capacity
   */
  isNearCapacity(threshold = 0.9) {
    return this.cache.size >= MAX_CACHE_SIZE$1 * threshold;
  }
  /**
   * Update size statistics
   */
  updateSizeStats() {
    this.stats.size = this.cache.size;
    this.stats.memorySizeEstimate = this.cache.size * BYTES_PER_ENTRY_ESTIMATE;
  }
  /**
   * Composes a cache key from block properties and dimensions.
   * Validates and clamps dimensions to prevent memory exhaustion.
   *
   * @param block - The flow block to create a key for
   * @param width - Width dimension (will be clamped to [0, MAX_DIMENSION])
   * @param height - Height dimension (will be clamped to [0, MAX_DIMENSION])
   * @returns Cache key string
   */
  composeKey(block, width, height) {
    const safeWidth = Number.isFinite(width) ? Math.max(0, Math.min(Math.floor(width), MAX_DIMENSION)) : 0;
    const safeHeight = Number.isFinite(height) ? Math.max(0, Math.min(Math.floor(height), MAX_DIMENSION)) : 0;
    const hash2 = hashRuns(block);
    return `${block.id}@${safeWidth}x${safeHeight}:${hash2}`;
  }
}
function resolveHeaderFooterTokens(blocks, pageNumber, totalPages, pageNumberText) {
  if (!blocks || blocks.length === 0) {
    return;
  }
  if (!Number.isFinite(pageNumber) || pageNumber < 1) {
    console.warn("[resolveHeaderFooterTokens] Invalid pageNumber:", pageNumber, "- using 1 as fallback");
    pageNumber = 1;
  }
  if (!Number.isFinite(totalPages) || totalPages < 1) {
    console.warn("[resolveHeaderFooterTokens] Invalid totalPages:", totalPages, "- using 1 as fallback");
    totalPages = 1;
  }
  const pageNumberStr = pageNumberText ?? String(pageNumber);
  const totalPagesStr = String(totalPages);
  for (const block of blocks) {
    if (block.kind !== "paragraph") continue;
    const paraBlock = block;
    for (const run of paraBlock.runs) {
      if ("token" in run && run.token) {
        if (run.token === "pageNumber") {
          run.text = pageNumberStr;
        } else if (run.token === "totalPageCount") {
          run.text = totalPagesStr;
        }
      }
    }
  }
}
function cloneHeaderFooterBlocks(blocks) {
  if (!blocks || blocks.length === 0) {
    return [];
  }
  return blocks.map((block) => {
    if (block.kind === "paragraph") {
      const paraBlock = block;
      return {
        ...paraBlock,
        runs: paraBlock.runs.map((run) => ({ ...run })),
        attrs: paraBlock.attrs ? { ...paraBlock.attrs } : void 0
      };
    }
    return { ...block };
  });
}
function isEnabled(envVar, defaultValue) {
  if (typeof vue.process$1 === "undefined" || typeof vue.process$1.env === "undefined") {
    return defaultValue;
  }
  const value = vue.process$1.env[envVar];
  if (value === "true" || value === "1") {
    return true;
  }
  if (value === "false" || value === "0") {
    return false;
  }
  return defaultValue;
}
const FeatureFlags = {
  /**
   * Enable section-aware numbering with restarts and format changes.
   * When disabled, falls back to simple 1-N sequential numbering.
   */
  NUMBERING_SECTION_AWARE: isEnabled("SD_NUMBERING_SECTION_AWARE", true),
  /**
   * Enable body page token resolution (PAGE/NUMPAGES in document content).
   * When disabled, tokens remain as placeholders in body content.
   */
  BODY_PAGE_TOKENS: isEnabled("SD_BODY_PAGE_TOKENS", true),
  /**
   * Enable header/footer page token resolution.
   * When disabled, headers/footers use painter-time token rendering fallback.
   */
  HEADER_FOOTER_PAGE_TOKENS: isEnabled("SD_HEADER_FOOTER_PAGE_TOKENS", true),
  /**
   * Enable digit bucketing for header/footer caching in large documents.
   * When disabled, creates per-page layouts for all documents (no bucketing).
   * Recommended to keep enabled for documents with 100+ pages.
   */
  HF_DIGIT_BUCKETING: isEnabled("SD_HF_DIGIT_BUCKETING", true),
  /**
   * Enable debug logging for page token resolution.
   * Logs token resolution details, affected blocks, and convergence iteration info.
   * Should be disabled in production (only enabled for debugging).
   */
  DEBUG_PAGE_TOKENS: isEnabled("SD_DEBUG_PAGE_TOKENS", false),
  /**
   * Enable debug logging for header/footer cache operations.
   * Logs cache hits, misses, invalidations, and bucket selection.
   * Should be disabled in production (only enabled for debugging).
   */
  DEBUG_HF_CACHE: isEnabled("SD_DEBUG_HF_CACHE", false),
  /**
   * Enable debug logging for layout version tracking.
   * Logs stale layout reads, geometry fallbacks, PM transactions, and layout completions.
   * Should be disabled in production (only enabled for debugging).
   */
  DEBUG_LAYOUT_VERSION: isEnabled("SD_DEBUG_LAYOUT_VERSION", false)
};
const PageTokenLogger = {
  /**
   * Logs the start of token resolution.
   *
   * @param iteration - Current iteration number (0-based)
   * @param totalPages - Total number of pages in the document
   */
  logIterationStart(iteration, totalPages) {
    if (!FeatureFlags.DEBUG_PAGE_TOKENS) return;
    console.log(`[PageTokens] Iteration ${iteration}: Resolving tokens for ${totalPages} pages`);
  },
  /**
   * Logs affected blocks during token resolution.
   *
   * @param iteration - Current iteration number (0-based)
   * @param affectedBlockIds - Set of affected block IDs
   * @param blockSamples - Sample block IDs for debugging (first 5)
   */
  logAffectedBlocks(iteration, affectedBlockIds, blockSamples = []) {
    if (!FeatureFlags.DEBUG_PAGE_TOKENS) return;
    const count = affectedBlockIds.size;
    const samples = blockSamples.slice(0, 5).join(", ");
    console.log(
      `[PageTokens] Iteration ${iteration}: ${count} blocks affected`,
      samples ? `(samples: ${samples})` : ""
    );
  },
  /**
   * Logs convergence status.
   *
   * @param iteration - Final iteration number
   * @param converged - Whether convergence was achieved
   * @param totalTimeMs - Total time spent in token resolution
   */
  logConvergence(iteration, converged, totalTimeMs) {
    if (!FeatureFlags.DEBUG_PAGE_TOKENS) return;
    if (converged) {
      console.log(`[PageTokens] Converged after ${iteration} iterations in ${totalTimeMs.toFixed(2)}ms`);
    } else {
      console.warn(`[PageTokens] Did NOT converge after ${iteration} iterations (${totalTimeMs.toFixed(2)}ms)`);
    }
  },
  /**
   * Logs token resolution error.
   *
   * @param blockId - Block ID where error occurred
   * @param error - Error object
   */
  logError(blockId, error) {
    if (!FeatureFlags.DEBUG_PAGE_TOKENS) return;
    console.error(`[PageTokens] Error resolving tokens in block ${blockId}:`, error);
  },
  /**
   * Logs re-measurement details.
   *
   * @param blockCount - Number of blocks being re-measured
   * @param timeMs - Time spent re-measuring
   */
  logRemeasure(blockCount, timeMs) {
    if (!FeatureFlags.DEBUG_PAGE_TOKENS) return;
    console.log(`[PageTokens] Re-measured ${blockCount} blocks in ${timeMs.toFixed(2)}ms`);
  }
};
const HeaderFooterCacheLogger = {
  /**
   * Logs cache hit for a header/footer variant.
   *
   * @param variantType - Variant type (default, first, even, odd)
   * @param pageNumber - Page number being cached
   * @param bucket - Digit bucket (d1, d2, d3, d4) or 'exact'
   */
  logCacheHit(variantType, pageNumber, bucket) {
    if (!FeatureFlags.DEBUG_HF_CACHE) return;
    console.log(`[HF Cache] HIT: variant=${variantType}, page=${pageNumber}, bucket=${bucket}`);
  },
  /**
   * Logs cache miss for a header/footer variant.
   *
   * @param variantType - Variant type (default, first, even, odd)
   * @param pageNumber - Page number being cached
   * @param bucket - Digit bucket (d1, d2, d3, d4) or 'exact'
   */
  logCacheMiss(variantType, pageNumber, bucket) {
    if (!FeatureFlags.DEBUG_HF_CACHE) return;
    console.log(`[HF Cache] MISS: variant=${variantType}, page=${pageNumber}, bucket=${bucket}`);
  },
  /**
   * Logs cache invalidation.
   *
   * @param reason - Reason for invalidation
   * @param affectedBlockIds - Block IDs being invalidated
   */
  logInvalidation(reason, affectedBlockIds) {
    if (!FeatureFlags.DEBUG_HF_CACHE) return;
    console.log(`[HF Cache] INVALIDATE: reason=${reason}, blocks=${affectedBlockIds.length}`);
  },
  /**
   * Logs cache statistics.
   *
   * @param stats - Cache statistics object
   */
  logStats(stats) {
    if (!FeatureFlags.DEBUG_HF_CACHE) return;
    const hitRate = stats.hits + stats.misses > 0 ? (stats.hits / (stats.hits + stats.misses) * 100).toFixed(1) : "0.0";
    console.log(
      `[HF Cache] Stats: hits=${stats.hits}, misses=${stats.misses}, hitRate=${hitRate}%, size=${stats.size}, evictions=${stats.evictions}`
    );
  },
  /**
   * Logs bucketing decision for large documents.
   *
   * @param totalPages - Total number of pages
   * @param useBucketing - Whether bucketing is being used
   * @param buckets - Buckets needed (if bucketing enabled)
   */
  logBucketingDecision(totalPages, useBucketing, buckets) {
    if (!FeatureFlags.DEBUG_HF_CACHE) return;
    if (useBucketing && buckets) {
      console.log(`[HF Cache] Bucketing enabled: ${totalPages} pages, buckets=${buckets.join(", ")}`);
    } else {
      console.log(`[HF Cache] Bucketing disabled: ${totalPages} pages (per-page layouts)`);
    }
  }
};
class MetricsCollector {
  constructor() {
    this.pageTokenMetrics = null;
    this.headerFooterCacheMetrics = null;
    this.layoutMetrics = null;
  }
  /**
   * Records page token resolution metrics.
   *
   * @param metrics - Page token metrics
   */
  recordPageTokenMetrics(metrics) {
    this.pageTokenMetrics = { ...metrics };
    this.checkPageTokenRollbackTriggers(metrics);
  }
  /**
   * Records header/footer cache metrics.
   *
   * @param stats - Cache statistics
   */
  recordHeaderFooterCacheMetrics(stats) {
    const hitRate = stats.hits + stats.misses > 0 ? stats.hits / (stats.hits + stats.misses) * 100 : 0;
    this.headerFooterCacheMetrics = {
      hits: stats.hits,
      misses: stats.misses,
      hitRate,
      cacheSize: stats.size,
      memoryEstimate: stats.memorySizeEstimate,
      evictions: stats.evictions
    };
    this.checkCacheRollbackTriggers(this.headerFooterCacheMetrics);
  }
  /**
   * Records overall layout metrics.
   *
   * @param metrics - Layout metrics
   */
  recordLayoutMetrics(metrics) {
    this.layoutMetrics = { ...metrics };
  }
  /**
   * Gets all collected metrics.
   *
   * @returns Object with all metrics or null if not collected
   */
  getMetrics() {
    return {
      pageTokens: this.pageTokenMetrics,
      headerFooterCache: this.headerFooterCacheMetrics,
      layout: this.layoutMetrics
    };
  }
  /**
   * Resets all collected metrics.
   */
  reset() {
    this.pageTokenMetrics = null;
    this.headerFooterCacheMetrics = null;
    this.layoutMetrics = null;
  }
  /**
   * Checks for page token rollback triggers and logs warnings.
   *
   * Rollback triggers (from plan):
   * - Convergence > 2 iterations
   * - Token resolution time > 100ms per layout run
   *
   * @param metrics - Page token metrics
   */
  checkPageTokenRollbackTriggers(metrics) {
    if (metrics.iterations > 2 && !metrics.converged) {
      console.warn(
        `[Rollback Trigger] Page token resolution did not converge after ${metrics.iterations} iterations. Consider disabling SD_BODY_PAGE_TOKENS if this persists.`
      );
    }
    if (metrics.totalTimeMs > 100 && metrics.iterations > 0) {
      console.warn(
        `[Rollback Trigger] Page token resolution took ${metrics.totalTimeMs.toFixed(2)}ms (>100ms threshold). Consider disabling SD_BODY_PAGE_TOKENS if performance is unacceptable.`
      );
    }
  }
  /**
   * Checks for cache rollback triggers and logs warnings.
   *
   * Rollback triggers (from plan):
   * - Cache thrash (hit rate below 30%)
   * - Excessive memory usage (>1MB per 100 pages)
   *
   * @param metrics - Header/footer cache metrics
   */
  checkCacheRollbackTriggers(metrics) {
    const MIN_HIT_RATE = 30;
    const MAX_MEMORY_PER_100_PAGES = 1e6;
    if (metrics.hits + metrics.misses > 10 && metrics.hitRate < MIN_HIT_RATE) {
      console.warn(
        `[Rollback Trigger] Header/footer cache hit rate is low (${metrics.hitRate.toFixed(1)}% < ${MIN_HIT_RATE}%). Consider disabling SD_HF_DIGIT_BUCKETING if cache thrashing persists.`
      );
    }
    if (metrics.memoryEstimate > MAX_MEMORY_PER_100_PAGES) {
      console.warn(
        `[Rollback Trigger] Header/footer cache memory usage is high (${(metrics.memoryEstimate / 1e6).toFixed(2)}MB). Monitor for excessive growth.`
      );
    }
  }
}
const globalMetrics = new MetricsCollector();
const MIN_PAGES_FOR_BUCKETING = 100;
function getBucketForPageNumber(pageNumber) {
  if (pageNumber < 10) return "d1";
  if (pageNumber < 100) return "d2";
  if (pageNumber < 1e3) return "d3";
  return "d4";
}
function getBucketRepresentative(bucket) {
  switch (bucket) {
    case "d1":
      return 5;
    case "d2":
      return 50;
    case "d3":
      return 500;
    case "d4":
      return 5e3;
  }
}
function hasPageTokens(blocks) {
  for (const block of blocks) {
    if (block.kind !== "paragraph") continue;
    for (const run of block.runs) {
      if ("token" in run && (run.token === "pageNumber" || run.token === "totalPageCount")) {
        return true;
      }
    }
  }
  return false;
}
class HeaderFooterLayoutCache {
  constructor() {
    this.cache = new MeasureCache();
  }
  async measureBlocks(blocks, constraints, measureBlock2) {
    const measures = [];
    for (const block of blocks) {
      const cached = this.cache.get(block, constraints.width, constraints.height);
      if (cached) {
        measures.push(cached);
        continue;
      }
      const measurement = await measureBlock2(block, {
        maxWidth: constraints.width,
        maxHeight: constraints.height
      });
      this.cache.set(block, constraints.width, constraints.height, measurement);
      measures.push(measurement);
    }
    return measures;
  }
  invalidate(blockIds) {
    this.cache.invalidate(blockIds);
  }
  /**
   * Gets cache statistics for monitoring and debugging.
   *
   * @returns Cache statistics object
   */
  getStats() {
    return this.cache.getStats();
  }
}
const sharedHeaderFooterCache = new HeaderFooterLayoutCache();
async function layoutHeaderFooterWithCache(sections, constraints, measureBlock2, cache2 = sharedHeaderFooterCache, totalPages, pageResolver) {
  const result = {};
  if (!pageResolver) {
    const numPages = totalPages ?? 1;
    for (const [type, blocks] of Object.entries(sections)) {
      if (!blocks || blocks.length === 0) continue;
      const clonedBlocks = cloneHeaderFooterBlocks(blocks);
      resolveHeaderFooterTokens(clonedBlocks, 1, numPages);
      const measures = await cache2.measureBlocks(clonedBlocks, constraints, measureBlock2);
      const layout = layoutHeaderFooter(clonedBlocks, measures, constraints);
      result[type] = { blocks: clonedBlocks, measures, layout };
    }
    return result;
  }
  const { totalPages: docTotalPages } = pageResolver(1);
  const useBucketing = FeatureFlags.HF_DIGIT_BUCKETING && docTotalPages >= MIN_PAGES_FOR_BUCKETING;
  for (const [type, blocks] of Object.entries(sections)) {
    if (!blocks || blocks.length === 0) {
      continue;
    }
    const hasTokens = hasPageTokens(blocks);
    if (!hasTokens) {
      const measures = await cache2.measureBlocks(blocks, constraints, measureBlock2);
      const layout = layoutHeaderFooter(blocks, measures, constraints);
      result[type] = { blocks, measures, layout };
      continue;
    }
    let pagesToLayout;
    if (!useBucketing) {
      pagesToLayout = Array.from({ length: docTotalPages }, (_2, i) => i + 1);
      HeaderFooterCacheLogger.logBucketingDecision(docTotalPages, false);
    } else {
      const bucketsNeeded = /* @__PURE__ */ new Set();
      for (let p2 = 1; p2 <= docTotalPages; p2++) {
        bucketsNeeded.add(getBucketForPageNumber(p2));
      }
      pagesToLayout = Array.from(bucketsNeeded).map((bucket) => getBucketRepresentative(bucket));
      HeaderFooterCacheLogger.logBucketingDecision(docTotalPages, true, Array.from(bucketsNeeded));
    }
    const pages = [];
    for (const pageNum of pagesToLayout) {
      const clonedBlocks = cloneHeaderFooterBlocks(blocks);
      const { displayText, totalPages: totalPagesForPage } = pageResolver(pageNum);
      resolveHeaderFooterTokens(clonedBlocks, pageNum, totalPagesForPage, displayText);
      const measures = await cache2.measureBlocks(clonedBlocks, constraints, measureBlock2);
      const pageLayout = layoutHeaderFooter(clonedBlocks, measures, constraints);
      const measuresById = /* @__PURE__ */ new Map();
      for (let i = 0; i < clonedBlocks.length; i += 1) {
        measuresById.set(clonedBlocks[i].id, measures[i]);
      }
      const fragmentsWithLines = pageLayout.pages[0]?.fragments.map((fragment) => {
        if (fragment.kind !== "para") {
          return fragment;
        }
        const measure = measuresById.get(fragment.blockId);
        if (!measure || measure.kind !== "paragraph") {
          return fragment;
        }
        return {
          ...fragment,
          lines: measure.lines.slice(fragment.fromLine, fragment.toLine)
        };
      }) ?? [];
      pages.push({
        number: pageNum,
        blocks: clonedBlocks,
        measures,
        fragments: fragmentsWithLines
      });
    }
    const firstPageLayout = pages[0] ? layoutHeaderFooter(pages[0].blocks, pages[0].measures, constraints) : { height: 0 };
    const finalLayout = {
      height: firstPageLayout.height,
      minY: firstPageLayout.minY,
      maxY: firstPageLayout.maxY,
      pages: pages.map((p2) => ({
        number: p2.number,
        fragments: p2.fragments
      }))
    };
    result[type] = {
      blocks: pages[0]?.blocks ?? blocks,
      measures: pages[0]?.measures ?? [],
      layout: finalLayout
    };
  }
  return result;
}
function findWordBoundaries(blocks, pos) {
  const blockInfo = findBlockAtPosition(blocks, pos);
  if (!blockInfo) return null;
  const { block, localPos } = blockInfo;
  if (block.kind !== "paragraph") return null;
  const { text, pmStart } = extractBlockText(block);
  if (text.length === 0) return null;
  const clampedPos = Math.max(0, Math.min(localPos, text.length));
  let wordStart = clampedPos;
  while (wordStart > 0 && isWordChar$2(text[wordStart - 1])) {
    wordStart--;
  }
  let wordEnd = clampedPos;
  while (wordEnd < text.length && isWordChar$2(text[wordEnd])) {
    wordEnd++;
  }
  if (wordStart === wordEnd) {
    while (wordStart > 0 && isWhitespace(text[wordStart - 1])) {
      wordStart--;
    }
    while (wordEnd < text.length && isWhitespace(text[wordEnd])) {
      wordEnd++;
    }
    if (wordStart === wordEnd) {
      return null;
    }
  }
  return {
    from: pmStart + wordStart,
    to: pmStart + wordEnd
  };
}
function findParagraphBoundaries(blocks, pos) {
  const blockInfo = findBlockAtPosition(blocks, pos);
  if (!blockInfo) return null;
  const { block } = blockInfo;
  if (block.kind === "paragraph") {
    const { pmStart, pmEnd } = extractBlockText(block);
    return { from: pmStart, to: pmEnd };
  }
  if (block.kind === "image") {
    return { from: pos, to: pos + 1 };
  }
  return null;
}
function extractBlockText(block) {
  if (block.kind !== "paragraph") {
    return { text: "", pmStart: 0, pmEnd: 0 };
  }
  let text = "";
  let pmStart = Infinity;
  let pmEnd = 0;
  for (const run of block.runs) {
    text += "src" in run || run.kind === "lineBreak" || run.kind === "break" || run.kind === "fieldAnnotation" ? "" : run.text;
    if (run.pmStart !== void 0) {
      pmStart = Math.min(pmStart, run.pmStart);
    }
    if (run.pmEnd !== void 0) {
      pmEnd = Math.max(pmEnd, run.pmEnd);
    }
  }
  if (pmStart === Infinity) pmStart = 0;
  if (pmEnd === 0 && text.length > 0) pmEnd = pmStart + text.length;
  return { text, pmStart, pmEnd };
}
function findBlockAtPosition(blocks, pos) {
  for (const block of blocks) {
    if (block.kind === "paragraph") {
      const { pmStart, pmEnd } = extractBlockText(block);
      if (pos >= pmStart && pos <= pmEnd) {
        return { block, localPos: pos - pmStart };
      }
    }
  }
  return null;
}
function isWordChar$2(char) {
  return /[\p{L}\p{N}_]/u.test(char);
}
function isWhitespace(char) {
  return /\s/.test(char);
}
let canvas = null;
let ctx$1 = null;
function getCtx() {
  if (ctx$1) return ctx$1;
  if (typeof document === "undefined") return null;
  canvas = document.createElement("canvas");
  ctx$1 = canvas.getContext("2d");
  return ctx$1;
}
function isTextRun$1(run) {
  if (run.kind === "tab" || run.kind === "lineBreak" || run.kind === "break" || run.kind === "fieldAnnotation") {
    return false;
  }
  if ("src" in run) {
    return false;
  }
  return true;
}
function fontString(run) {
  const textRun = isTextRun$1(run) ? run : null;
  const size2 = textRun?.fontSize ?? 16;
  const family = textRun?.fontFamily ?? "Arial";
  const italic = textRun?.italic ? "italic " : "";
  const bold = textRun?.bold ? "bold " : "";
  return `${italic}${bold}${size2}px ${family}`.trim();
}
function runText(run) {
  return "src" in run || run.kind === "lineBreak" || run.kind === "break" || run.kind === "fieldAnnotation" ? "" : run.text ?? "";
}
const isWordChar$1 = (char) => {
  if (!char) return false;
  const code = char.charCodeAt(0);
  return code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || char === "'";
};
const capitalizeText$1 = (text, fullText, startOffset) => {
  if (!text) return text;
  const hasFullText = typeof startOffset === "number" && fullText != null;
  let result = "";
  for (let i = 0; i < text.length; i += 1) {
    const prevChar = hasFullText ? startOffset + i > 0 ? fullText[startOffset + i - 1] : "" : i > 0 ? text[i - 1] : "";
    const ch = text[i];
    result += isWordChar$1(ch) && !isWordChar$1(prevChar) ? ch.toUpperCase() : ch;
  }
  return result;
};
const applyTextTransform$1 = (text, transform, fullText, startOffset) => {
  if (!text || !transform || transform === "none") return text;
  if (transform === "uppercase") return text.toUpperCase();
  if (transform === "lowercase") return text.toLowerCase();
  if (transform === "capitalize") return capitalizeText$1(text, fullText, startOffset);
  return text;
};
const DEFAULT_TAB_INTERVAL_TWIPS$1 = 720;
const TWIPS_PER_INCH$1 = 1440;
const PX_PER_INCH$1 = 96;
const TWIPS_PER_PX$1 = TWIPS_PER_INCH$1 / PX_PER_INCH$1;
const TAB_EPSILON$1 = 0.1;
const WIDTH_FUDGE_PX = 0.5;
const twipsToPx$1 = (twips) => twips / TWIPS_PER_PX$1;
const pxToTwips$1 = (px) => Math.round(px * TWIPS_PER_PX$1);
const sanitizeIndent$1 = (value) => typeof value === "number" && Number.isFinite(value) ? Math.max(0, value) : 0;
const sanitizeDecimalSeparator$1 = (value) => value === "," ? "," : ".";
const getRunWidth = (run) => {
  const width = run.width;
  return typeof width === "number" ? width : 0;
};
const isLineBreakRun$1 = (run) => run.kind === "lineBreak" || run.kind === "break" && run.breakType === "line";
const markerFontString = (run) => {
  const size2 = run?.fontSize ?? 16;
  const family = run?.fontFamily ?? "Arial";
  const italic = run?.italic ? "italic " : "";
  const bold = run?.bold ? "bold " : "";
  return `${italic}${bold}${size2}px ${family}`.trim();
};
const buildTabStopsPx$1 = (indent, tabs, tabIntervalTwips) => {
  const paragraphIndentTwips = {
    left: pxToTwips$1(sanitizeIndent$1(indent?.left)),
    right: pxToTwips$1(sanitizeIndent$1(indent?.right)),
    firstLine: pxToTwips$1(sanitizeIndent$1(indent?.firstLine)),
    hanging: pxToTwips$1(sanitizeIndent$1(indent?.hanging))
  };
  const stops = computeTabStops$1({
    explicitStops: tabs ?? [],
    defaultTabInterval: tabIntervalTwips ?? DEFAULT_TAB_INTERVAL_TWIPS$1,
    paragraphIndent: paragraphIndentTwips
  });
  return stops.map((stop) => ({
    pos: twipsToPx$1(stop.pos),
    val: stop.val,
    leader: stop.leader
  }));
};
const getNextTabStopPx$1 = (currentX, tabStops, startIndex) => {
  let index2 = startIndex;
  while (index2 < tabStops.length && tabStops[index2].pos <= currentX + TAB_EPSILON$1) {
    index2 += 1;
  }
  if (index2 < tabStops.length) {
    return { target: tabStops[index2].pos, nextIndex: index2 + 1, stop: tabStops[index2] };
  }
  return { target: currentX + twipsToPx$1(DEFAULT_TAB_INTERVAL_TWIPS$1), nextIndex: index2 };
};
function measureRunSliceWidth(run, fromChar, toChar) {
  const context = getCtx();
  const fullText = runText(run);
  const transform = isTextRun$1(run) ? run.textTransform : void 0;
  const text = applyTextTransform$1(fullText.slice(fromChar, toChar), transform, fullText, fromChar);
  if (!context) {
    const textRun = isTextRun$1(run) ? run : null;
    const size2 = textRun?.fontSize ?? 16;
    return Math.max(1, text.length * (size2 * 0.6));
  }
  context.font = fontString(run);
  const metrics = context.measureText(text);
  return metrics.width;
}
const scanTabAlignmentGroup = (runs, startRunIndex, startChar, decimalSeparator) => {
  let totalWidth = 0;
  let beforeDecimalWidth;
  let foundDecimal = false;
  let endRun = startRunIndex;
  let endChar = startChar;
  for (let r2 = startRunIndex; r2 < runs.length; r2 += 1) {
    const run = runs[r2];
    if (!run) continue;
    if (run.kind === "tab") {
      return { totalWidth, beforeDecimalWidth, endRun, endChar, resumeRun: r2, resumeChar: 0 };
    }
    if (isLineBreakRun$1(run)) {
      return { totalWidth, beforeDecimalWidth, endRun, endChar, resumeRun: r2, resumeChar: 0 };
    }
    const text = runText(run);
    if (!text) {
      const runWidth = getRunWidth(run);
      if (runWidth > 0) {
        totalWidth += runWidth;
        endRun = r2;
        endChar = 1;
      }
      continue;
    }
    const sliceStart = r2 === startRunIndex ? startChar : 0;
    if (sliceStart >= text.length) continue;
    const tabIndex = text.indexOf("	", sliceStart);
    const effectiveEnd = tabIndex >= 0 ? tabIndex : text.length;
    if (effectiveEnd > sliceStart) {
      const sliceWidth = measureRunSliceWidth(run, sliceStart, effectiveEnd);
      if (!foundDecimal) {
        const decimalIndex = text.slice(sliceStart, effectiveEnd).indexOf(decimalSeparator);
        if (decimalIndex >= 0) {
          foundDecimal = true;
          const beforeWidth = decimalIndex > 0 ? measureRunSliceWidth(run, sliceStart, sliceStart + decimalIndex) : 0;
          beforeDecimalWidth = totalWidth + beforeWidth;
        }
      }
      totalWidth += sliceWidth;
      endRun = r2;
      endChar = effectiveEnd;
    }
    if (tabIndex >= 0) {
      return { totalWidth, beforeDecimalWidth, endRun, endChar, resumeRun: r2, resumeChar: tabIndex };
    }
  }
  return { totalWidth, beforeDecimalWidth, endRun, endChar, resumeRun: runs.length, resumeChar: 0 };
};
const measureTabAlignmentGroupInLine = (runs, line, startRunIndex, startChar, decimalSeparator) => {
  let totalWidth = 0;
  let beforeDecimalWidth;
  let foundDecimal = false;
  for (let r2 = startRunIndex; r2 <= line.toRun; r2 += 1) {
    const run = runs[r2];
    if (!run) continue;
    if (run.kind === "tab") break;
    if (isLineBreakRun$1(run)) break;
    const text = runText(run);
    if (!text) {
      totalWidth += getRunWidth(run);
      continue;
    }
    const sliceStart = r2 === startRunIndex ? startChar : 0;
    const sliceEnd = r2 === line.toRun ? line.toChar : text.length;
    if (sliceStart >= sliceEnd) continue;
    const slice2 = text.slice(sliceStart, sliceEnd);
    const tabIndex = slice2.indexOf("	");
    const effectiveSlice = tabIndex >= 0 ? slice2.slice(0, tabIndex) : slice2;
    const effectiveSliceEnd = tabIndex >= 0 ? sliceStart + tabIndex : sliceEnd;
    if (effectiveSlice.length > 0) {
      const sliceWidth = measureRunSliceWidth(run, sliceStart, effectiveSliceEnd);
      totalWidth += sliceWidth;
      if (!foundDecimal) {
        const decimalIndex = effectiveSlice.indexOf(decimalSeparator);
        if (decimalIndex >= 0) {
          foundDecimal = true;
          const beforeWidth = decimalIndex > 0 ? measureRunSliceWidth(run, sliceStart, sliceStart + decimalIndex) : 0;
          beforeDecimalWidth = totalWidth - sliceWidth + beforeWidth;
        }
      }
    }
    if (tabIndex >= 0) {
      break;
    }
  }
  return { totalWidth, beforeDecimalWidth };
};
const applyTabLayoutToLines = (lines, runs, tabStops, decimalSeparator, indentLeft, rawFirstLineOffset) => {
  lines.forEach((line, lineIndex) => {
    let cursorX = 0;
    let lineWidth = 0;
    let tabStopCursor = 0;
    let pendingTabAlignStartX = null;
    const segments = [];
    const leaders = [];
    const effectiveIndent = lineIndex === 0 ? indentLeft + rawFirstLineOffset : indentLeft;
    const maxAbsWidth = typeof line.maxWidth === "number" && Number.isFinite(line.maxWidth) ? line.maxWidth + effectiveIndent : Number.POSITIVE_INFINITY;
    const applyTab = (startRunIndex, startChar, run) => {
      const originX = cursorX;
      const absCurrentX = cursorX + effectiveIndent;
      const { target, nextIndex, stop } = getNextTabStopPx$1(absCurrentX, tabStops, tabStopCursor);
      tabStopCursor = nextIndex;
      const clampedTarget = Number.isFinite(maxAbsWidth) ? Math.min(target, maxAbsWidth) : target;
      const relativeTarget = clampedTarget - effectiveIndent;
      lineWidth = Math.max(lineWidth, relativeTarget);
      if (stop?.leader && stop.leader !== "none") {
        const from3 = Math.min(originX, relativeTarget);
        const to = Math.max(originX, relativeTarget);
        leaders.push({ from: from3, to, style: stop.leader });
      }
      const stopVal = stop?.val ?? "start";
      if (stopVal === "end" || stopVal === "center" || stopVal === "decimal") {
        const groupMeasure = measureTabAlignmentGroupInLine(runs, line, startRunIndex, startChar, decimalSeparator);
        if (groupMeasure.totalWidth > 0) {
          let groupStartX;
          if (stopVal === "end") {
            groupStartX = Math.max(0, relativeTarget - groupMeasure.totalWidth);
          } else if (stopVal === "center") {
            groupStartX = Math.max(0, relativeTarget - groupMeasure.totalWidth / 2);
          } else {
            const beforeDecimal = groupMeasure.beforeDecimalWidth ?? groupMeasure.totalWidth;
            groupStartX = Math.max(0, relativeTarget - beforeDecimal);
          }
          pendingTabAlignStartX = groupStartX;
        } else {
          cursorX = Math.max(cursorX, relativeTarget);
        }
      } else {
        cursorX = Math.max(cursorX, relativeTarget);
      }
      if (run && run.kind === "tab") {
        run.width = Math.max(0, relativeTarget - originX);
      }
    };
    for (let runIndex = line.fromRun; runIndex <= line.toRun; runIndex += 1) {
      const run = runs[runIndex];
      if (!run) continue;
      if (run.kind === "tab") {
        applyTab(runIndex + 1, 0, run);
        continue;
      }
      const text = runText(run);
      if (!text) {
        cursorX += getRunWidth(run);
        lineWidth = Math.max(lineWidth, cursorX);
        continue;
      }
      const sliceStart = runIndex === line.fromRun ? line.fromChar : 0;
      const sliceEnd = runIndex === line.toRun ? line.toChar : text.length;
      if (sliceStart >= sliceEnd) continue;
      let segmentStart = sliceStart;
      for (let i = sliceStart; i < sliceEnd; i += 1) {
        if (text[i] !== "	") continue;
        if (i > segmentStart) {
          const segmentWidth = measureRunSliceWidth(run, segmentStart, i);
          const segment = {
            runIndex,
            fromChar: segmentStart,
            toChar: i,
            width: segmentWidth
          };
          if (pendingTabAlignStartX != null) {
            segment.x = pendingTabAlignStartX;
            cursorX = pendingTabAlignStartX + segmentWidth;
            pendingTabAlignStartX = null;
          } else {
            cursorX += segmentWidth;
          }
          lineWidth = Math.max(lineWidth, cursorX);
          segments.push(segment);
        }
        applyTab(runIndex, i + 1);
        segmentStart = i + 1;
      }
      if (segmentStart < sliceEnd) {
        const segmentWidth = measureRunSliceWidth(run, segmentStart, sliceEnd);
        const segment = {
          runIndex,
          fromChar: segmentStart,
          toChar: sliceEnd,
          width: segmentWidth
        };
        if (pendingTabAlignStartX != null) {
          segment.x = pendingTabAlignStartX;
          cursorX = pendingTabAlignStartX + segmentWidth;
          pendingTabAlignStartX = null;
        } else {
          cursorX += segmentWidth;
        }
        lineWidth = Math.max(lineWidth, cursorX);
        segments.push(segment);
      }
    }
    if (segments.length > 0) {
      line.segments = segments;
    }
    if (leaders.length > 0) {
      line.leaders = leaders;
    }
    if (lineWidth > 0) {
      line.width = Math.max(line.width, lineWidth);
    }
  });
};
function lineHeightForRuns(runs, fromRun, toRun) {
  let maxSize2 = 0;
  for (let i = fromRun; i <= toRun; i += 1) {
    const run = runs[i];
    const textRun = run && isTextRun$1(run) ? run : null;
    const size2 = textRun?.fontSize ?? 16;
    if (size2 > maxSize2) maxSize2 = size2;
  }
  return maxSize2 * 1.2;
}
function remeasureParagraph(block, maxWidth, firstLineIndent = 0) {
  if (!Number.isFinite(maxWidth) || maxWidth <= 0) {
    throw new Error(`remeasureParagraph: maxWidth must be a positive number, got ${maxWidth}`);
  }
  if (!Number.isFinite(firstLineIndent)) {
    throw new Error(`remeasureParagraph: firstLineIndent must be a finite number, got ${firstLineIndent}`);
  }
  if (!block) {
    throw new Error("remeasureParagraph: block must be defined");
  }
  if (!Array.isArray(block.runs)) {
    throw new Error(`remeasureParagraph: block.runs must be an array, got ${typeof block.runs}`);
  }
  const runs = block.runs ?? [];
  const lines = [];
  const attrs = block.attrs;
  const indent = attrs?.indent;
  const wordLayout = attrs?.wordLayout;
  const rawIndentLeft = typeof indent?.left === "number" && Number.isFinite(indent.left) ? indent.left : 0;
  const rawIndentRight = typeof indent?.right === "number" && Number.isFinite(indent.right) ? indent.right : 0;
  const indentLeft = Math.max(0, rawIndentLeft);
  const indentRight = Math.max(0, rawIndentRight);
  const indentFirstLine = Math.max(0, indent?.firstLine ?? 0);
  const indentHanging = Math.max(0, indent?.hanging ?? 0);
  const baseFirstLineOffset = firstLineIndent || indentFirstLine - indentHanging;
  const rawFirstLineOffset = baseFirstLineOffset;
  const clampedFirstLineOffset = Math.max(0, baseFirstLineOffset);
  const hasNegativeIndent = rawIndentLeft < 0 || rawIndentRight < 0;
  const allowNegativeFirstLineOffset = !wordLayout?.marker && !hasNegativeIndent && baseFirstLineOffset < 0;
  const effectiveFirstLineOffset = allowNegativeFirstLineOffset ? baseFirstLineOffset : clampedFirstLineOffset;
  const contentWidth = Math.max(1, maxWidth - indentLeft - indentRight);
  const textStartPx = wordLayout?.textStartPx;
  let measuredMarkerTextWidth;
  const resolvedTextStartPx = resolveListTextStartPx(
    wordLayout,
    indentLeft,
    indentFirstLine,
    indentHanging,
    (markerText, marker2) => {
      const context = getCtx();
      if (!context) return 0;
      context.font = markerFontString(marker2.run);
      const width = context.measureText(markerText).width;
      measuredMarkerTextWidth = width;
      return width;
    }
  );
  const effectiveTextStartPx = resolvedTextStartPx ?? textStartPx;
  const treatAsHanging = !wordLayout?.marker && effectiveTextStartPx && indentLeft === 0 && indentHanging === 0;
  const firstLineWidth = typeof effectiveTextStartPx === "number" && effectiveTextStartPx > indentLeft && !treatAsHanging ? Math.max(1, maxWidth - effectiveTextStartPx - indentRight) : Math.max(1, contentWidth - effectiveFirstLineOffset);
  const tabStops = buildTabStopsPx$1(indent, attrs?.tabs, attrs?.tabIntervalTwips);
  const decimalSeparator = sanitizeDecimalSeparator$1(attrs?.decimalSeparator);
  let currentRun = 0;
  let currentChar = 0;
  while (currentRun < runs.length) {
    const isFirstLine = lines.length === 0;
    const effectiveMaxWidth = Math.max(1, isFirstLine ? firstLineWidth : contentWidth);
    const effectiveIndent = isFirstLine ? indentLeft + rawFirstLineOffset : indentLeft;
    const startRun = currentRun;
    const startChar = currentChar;
    let width = 0;
    let widthAtLastBreak = -1;
    let lastBreakRun = -1;
    let lastBreakChar = -1;
    let endRun = currentRun;
    let endChar = currentChar;
    let tabStopCursor = 0;
    let didBreakInThisLine = false;
    let resumeRun = -1;
    let resumeChar = 0;
    for (let r2 = currentRun; r2 < runs.length; r2 += 1) {
      const run = runs[r2];
      if (run.kind === "tab") {
        const absCurrentX = width + effectiveIndent;
        const { target, nextIndex, stop } = getNextTabStopPx$1(absCurrentX, tabStops, tabStopCursor);
        const maxAbsWidth = effectiveMaxWidth + effectiveIndent;
        const clampedTarget = Math.min(target, maxAbsWidth);
        const tabAdvance = Math.max(0, clampedTarget - absCurrentX);
        width += tabAdvance;
        tabStopCursor = nextIndex;
        if (stop && (stop.val === "end" || stop.val === "center" || stop.val === "decimal")) {
          const group = scanTabAlignmentGroup(runs, r2 + 1, 0, decimalSeparator);
          if (group.totalWidth > 0) {
            const relativeTarget = clampedTarget - effectiveIndent;
            let groupStartX;
            if (stop.val === "end") {
              groupStartX = Math.max(0, relativeTarget - group.totalWidth);
            } else if (stop.val === "center") {
              groupStartX = Math.max(0, relativeTarget - group.totalWidth / 2);
            } else {
              const beforeDecimal = group.beforeDecimalWidth ?? group.totalWidth;
              groupStartX = Math.max(0, relativeTarget - beforeDecimal);
            }
            const rightEdge = stop.val === "end" ? relativeTarget : groupStartX + group.totalWidth;
            width = Math.max(width, rightEdge);
            endRun = group.endRun;
            endChar = group.endChar;
            lastBreakRun = group.endRun;
            lastBreakChar = group.endChar;
            widthAtLastBreak = width;
            if (group.resumeRun >= runs.length) {
              didBreakInThisLine = true;
              break;
            }
            if (group.resumeRun > r2) {
              resumeRun = group.resumeRun;
              resumeChar = group.resumeChar;
              r2 = resumeRun - 1;
              continue;
            }
          }
        }
        endRun = r2;
        endChar = 1;
        lastBreakRun = r2;
        lastBreakChar = 1;
        widthAtLastBreak = width;
        continue;
      }
      const text = runText(run);
      const start2 = r2 === currentRun ? currentChar : r2 === resumeRun ? resumeChar : 0;
      if (r2 === resumeRun) {
        resumeRun = -1;
      }
      for (let c2 = start2; c2 < text.length; c2 += 1) {
        const ch = text[c2];
        if (ch === "	") {
          const absCurrentX = width + effectiveIndent;
          const { target, nextIndex, stop } = getNextTabStopPx$1(absCurrentX, tabStops, tabStopCursor);
          const maxAbsWidth = effectiveMaxWidth + effectiveIndent;
          const clampedTarget = Math.min(target, maxAbsWidth);
          const tabAdvance = Math.max(0, clampedTarget - absCurrentX);
          width += tabAdvance;
          tabStopCursor = nextIndex;
          if (stop && (stop.val === "end" || stop.val === "center" || stop.val === "decimal")) {
            const group = scanTabAlignmentGroup(runs, r2, c2 + 1, decimalSeparator);
            if (group.totalWidth > 0) {
              const relativeTarget = clampedTarget - effectiveIndent;
              let groupStartX;
              if (stop.val === "end") {
                groupStartX = Math.max(0, relativeTarget - group.totalWidth);
              } else if (stop.val === "center") {
                groupStartX = Math.max(0, relativeTarget - group.totalWidth / 2);
              } else {
                const beforeDecimal = group.beforeDecimalWidth ?? group.totalWidth;
                groupStartX = Math.max(0, relativeTarget - beforeDecimal);
              }
              const rightEdge = stop.val === "end" ? relativeTarget : groupStartX + group.totalWidth;
              width = Math.max(width, rightEdge);
              endRun = group.endRun;
              endChar = group.endChar;
              lastBreakRun = group.endRun;
              lastBreakChar = group.endChar;
              widthAtLastBreak = width;
              if (group.resumeRun >= runs.length) {
                didBreakInThisLine = true;
                break;
              }
              if (group.resumeRun > r2) {
                resumeRun = group.resumeRun;
                resumeChar = group.resumeChar;
                r2 = resumeRun - 1;
                break;
              }
              if (group.resumeRun === r2) {
                c2 = group.resumeChar - 1;
                continue;
              }
            }
          }
          endRun = r2;
          endChar = c2 + 1;
          lastBreakRun = r2;
          lastBreakChar = c2 + 1;
          widthAtLastBreak = width;
          continue;
        }
        const w = measureRunSliceWidth(run, c2, c2 + 1);
        if (width + w > effectiveMaxWidth - WIDTH_FUDGE_PX && width > 0) {
          if (lastBreakRun >= 0) {
            endRun = lastBreakRun;
            endChar = lastBreakChar;
            width = widthAtLastBreak >= 0 ? widthAtLastBreak : width;
          } else {
            endRun = r2;
            endChar = c2;
          }
          didBreakInThisLine = true;
          break;
        }
        width += w;
        endRun = r2;
        endChar = c2 + 1;
        if (ch === " " || ch === "	" || ch === "-") {
          lastBreakRun = r2;
          lastBreakChar = c2 + 1;
          widthAtLastBreak = width;
        }
      }
      if (didBreakInThisLine) break;
    }
    if (startRun === endRun && startChar === endChar) {
      endRun = startRun;
      endChar = startChar + 1;
    }
    const line = {
      fromRun: startRun,
      fromChar: startChar,
      toRun: endRun,
      toChar: endChar,
      width,
      ascent: 0,
      descent: 0,
      lineHeight: lineHeightForRuns(runs, startRun, endRun),
      maxWidth: effectiveMaxWidth
    };
    lines.push(line);
    currentRun = endRun;
    currentChar = endChar;
    if (currentRun >= runs.length) {
      break;
    }
    if (currentChar >= runText(runs[currentRun]).length) {
      currentRun += 1;
      currentChar = 0;
    }
  }
  const hasTabRun = runs.some((run) => run?.kind === "tab");
  const hasTextTab = runs.some(
    (run) => run?.kind === "text" && typeof run.text === "string" && run.text.includes("	")
  );
  if (hasTabRun || hasTextTab) {
    applyTabLayoutToLines(lines, runs, tabStops, decimalSeparator, indentLeft, rawFirstLineOffset);
  }
  const totalHeight = lines.reduce((s, l) => s + l.lineHeight, 0);
  const marker = wordLayout?.marker;
  const markerInfo = marker ? {
    markerWidth: indentHanging ?? 0,
    markerTextWidth: measuredMarkerTextWidth ?? 0,
    indentLeft,
    gutterWidth: marker.gutterWidthPx
  } : void 0;
  return { kind: "paragraph", lines, totalHeight, marker: markerInfo };
}
function hasComments(run) {
  return "comments" in run && Array.isArray(run.comments) && run.comments.length > 0;
}
const computeDirtyRegions = (previous, next) => {
  const prevMap = new Map(previous.map((block, index2) => [block.id, { block, index: index2 }]));
  const nextMap = new Map(next.map((block, index2) => [block.id, { block, index: index2 }]));
  let firstDirtyIndex = next.length;
  let lastStableIndex = -1;
  let prevPointer = 0;
  let nextPointer = 0;
  while (prevPointer < previous.length && nextPointer < next.length) {
    const prevBlock = previous[prevPointer];
    const nextBlock = next[nextPointer];
    if (prevBlock.id === nextBlock.id && shallowEqual(prevBlock, nextBlock)) {
      lastStableIndex = nextPointer;
      prevPointer += 1;
      nextPointer += 1;
      continue;
    }
    firstDirtyIndex = Math.min(firstDirtyIndex, nextPointer);
    if (!nextMap.has(prevBlock.id)) {
      prevPointer += 1;
    } else if (!prevMap.has(nextBlock.id)) {
      nextPointer += 1;
    } else {
      prevPointer += 1;
      nextPointer += 1;
    }
  }
  const insertedBlockIds = next.filter((block) => !prevMap.has(block.id)).map((block) => block.id);
  const deletedBlockIds = previous.filter((block) => !nextMap.has(block.id)).map((block) => block.id);
  if (firstDirtyIndex === next.length && previous.length !== next.length) {
    firstDirtyIndex = Math.min(prevPointer, nextPointer);
  }
  return {
    firstDirtyIndex: firstDirtyIndex === next.length ? next.length : firstDirtyIndex,
    lastStableIndex,
    insertedBlockIds,
    deletedBlockIds
  };
};
const shallowEqual = (a, b2) => {
  if (a.kind !== b2.kind) return false;
  if (a.kind === "image" && b2.kind === "image") {
    return imageBlocksEqual(a, b2);
  }
  if (a.kind === "paragraph" && b2.kind === "paragraph") {
    return paragraphBlocksEqual(a, b2);
  }
  if (a.kind === "drawing" && b2.kind === "drawing") {
    return drawingBlocksEqual(a, b2);
  }
  return false;
};
const getTrackedChangeKey = (run) => {
  if (hasTrackedChange(run)) {
    const tc = run.trackedChange;
    const beforeHash = tc.before ? JSON.stringify(tc.before) : "";
    const afterHash = tc.after ? JSON.stringify(tc.after) : "";
    return `${tc.kind ?? ""}:${tc.id ?? ""}:${tc.author ?? ""}:${tc.date ?? ""}:${beforeHash}:${afterHash}`;
  }
  return "";
};
const getCommentKey = (run) => {
  if (!hasComments(run)) return "";
  return run.comments.map((c2) => `${c2.commentId ?? ""}:${c2.internal ? "1" : "0"}`).join("|");
};
const paragraphSpacingEqual = (a, b2) => {
  if (a === b2) return true;
  if (!a || !b2) return !a && !b2;
  return a.before === b2.before && a.after === b2.after && a.line === b2.line && a.lineRule === b2.lineRule && a.beforeAutospacing === b2.beforeAutospacing && a.afterAutospacing === b2.afterAutospacing;
};
const paragraphIndentEqual = (a, b2) => {
  if (a === b2) return true;
  if (!a || !b2) return !a && !b2;
  return a.left === b2.left && a.right === b2.right && a.firstLine === b2.firstLine && a.hanging === b2.hanging;
};
const paragraphBorderEqual = (a, b2) => {
  if (a === b2) return true;
  if (!a || !b2) return !a && !b2;
  return a.style === b2.style && a.width === b2.width && a.color === b2.color && a.space === b2.space;
};
const paragraphBordersEqual = (a, b2) => {
  if (a === b2) return true;
  if (!a || !b2) return !a && !b2;
  return paragraphBorderEqual(a.top, b2.top) && paragraphBorderEqual(a.right, b2.right) && paragraphBorderEqual(a.bottom, b2.bottom) && paragraphBorderEqual(a.left, b2.left);
};
const paragraphShadingEqual = (a, b2) => {
  if (a === b2) return true;
  if (!a || !b2) return !a && !b2;
  return a.fill === b2.fill && a.color === b2.color && a.val === b2.val && a.themeColor === b2.themeColor && a.themeFill === b2.themeFill && a.themeFillShade === b2.themeFillShade && a.themeFillTint === b2.themeFillTint && a.themeShade === b2.themeShade && a.themeTint === b2.themeTint;
};
const tabStopEqual = (a, b2) => {
  return a.val === b2.val && a.pos === b2.pos && a.leader === b2.leader;
};
const tabStopsEqual = (a, b2) => {
  if (a === b2) return true;
  if (!a || !b2) return !a && !b2;
  if (a.length !== b2.length) return false;
  for (let i = 0; i < a.length; i += 1) {
    if (!tabStopEqual(a[i], b2[i])) return false;
  }
  return true;
};
const paragraphFrameEqual = (a, b2) => {
  if (a === b2) return true;
  if (!a || !b2) return !a && !b2;
  return a.wrap === b2.wrap && a.x === b2.x && a.y === b2.y && a.xAlign === b2.xAlign && a.yAlign === b2.yAlign && a.hAnchor === b2.hAnchor && a.vAnchor === b2.vAnchor;
};
const dropCapDescriptorEqual = (a, b2) => {
  if (a === b2) return true;
  if (!a || !b2) return !a && !b2;
  if (a.mode !== b2.mode || a.lines !== b2.lines) return false;
  const runA = a.run;
  const runB = b2.run;
  if (!runA || !runB) return !runA && !runB;
  if (runA.text !== runB.text || runA.fontFamily !== runB.fontFamily || runA.fontSize !== runB.fontSize || runA.bold !== runB.bold || runA.italic !== runB.italic || runA.color !== runB.color) {
    return false;
  }
  return true;
};
const paragraphAttrsEqual = (a, b2) => {
  if (a === b2) return true;
  if (!a || !b2) return !a && !b2;
  if (a.alignment !== b2.alignment || a.contextualSpacing !== b2.contextualSpacing || a.suppressFirstLineIndent !== b2.suppressFirstLineIndent || a.dropCap !== b2.dropCap || a.decimalSeparator !== b2.decimalSeparator || a.tabIntervalTwips !== b2.tabIntervalTwips || a.keepNext !== b2.keepNext || a.keepLines !== b2.keepLines || a.direction !== b2.direction || a.rtl !== b2.rtl || a.floatAlignment !== b2.floatAlignment) {
    return false;
  }
  if (!paragraphSpacingEqual(a.spacing, b2.spacing)) return false;
  if (!paragraphIndentEqual(a.indent, b2.indent)) return false;
  if (!paragraphBordersEqual(a.borders, b2.borders)) return false;
  if (!paragraphShadingEqual(a.shading, b2.shading)) return false;
  if (!tabStopsEqual(a.tabs, b2.tabs)) return false;
  if (!paragraphFrameEqual(a.frame, b2.frame)) return false;
  if (!dropCapDescriptorEqual(a.dropCapDescriptor, b2.dropCapDescriptor)) return false;
  return true;
};
const paragraphBlocksEqual = (a, b2) => {
  const aMode = a.attrs?.trackedChangesMode ?? "review";
  const bMode = b2.attrs?.trackedChangesMode ?? "review";
  if (aMode !== bMode) return false;
  const aEnabled = resolveTrackedChangesEnabled(a.attrs, true);
  const bEnabled = resolveTrackedChangesEnabled(b2.attrs, true);
  if (aEnabled !== bEnabled) return false;
  if (!paragraphAttrsEqual(a.attrs, b2.attrs)) return false;
  if (a.runs.length !== b2.runs.length) return false;
  for (let i = 0; i < a.runs.length; i += 1) {
    const runA = a.runs[i];
    const runB = b2.runs[i];
    if (("src" in runA || runA.kind === "lineBreak" || runA.kind === "break" || runA.kind === "fieldAnnotation" ? "" : runA.text) !== ("src" in runB || runB.kind === "lineBreak" || runB.kind === "break" || runB.kind === "fieldAnnotation" ? "" : runB.text) || fieldAnnotationKey(runA) !== fieldAnnotationKey(runB) || ("bold" in runA ? runA.bold : false) !== ("bold" in runB ? runB.bold : false) || ("italic" in runA ? runA.italic : false) !== ("italic" in runB ? runB.italic : false) || ("color" in runA ? runA.color : void 0) !== ("color" in runB ? runB.color : void 0) || ("fontSize" in runA ? runA.fontSize : void 0) !== ("fontSize" in runB ? runB.fontSize : void 0) || ("fontFamily" in runA ? runA.fontFamily : void 0) !== ("fontFamily" in runB ? runB.fontFamily : void 0) || ("highlight" in runA ? runA.highlight : void 0) !== ("highlight" in runB ? runB.highlight : void 0) || getTrackedChangeKey(runA) !== getTrackedChangeKey(runB) || getCommentKey(runA) !== getCommentKey(runB)) {
      return false;
    }
  }
  return true;
};
const imageBlocksEqual = (a, b2) => {
  return a.src === b2.src && a.width === b2.width && a.height === b2.height && a.alt === b2.alt && a.title === b2.title && a.objectFit === b2.objectFit && a.display === b2.display && boxSpacingEqual(a.margin, b2.margin) && boxSpacingEqual(a.padding, b2.padding) && imageAnchorEqual(a.anchor, b2.anchor) && imageWrapEqual(a.wrap, b2.wrap) && shallowRecordEqual(a.attrs, b2.attrs);
};
const drawingBlocksEqual = (a, b2) => {
  if (a.drawingKind !== b2.drawingKind) return false;
  if (!boxSpacingEqual(a.margin, b2.margin)) return false;
  if (!boxSpacingEqual(a.padding, b2.padding)) return false;
  if (!imageAnchorEqual(a.anchor, b2.anchor)) return false;
  if (!imageWrapEqual(a.wrap, b2.wrap)) return false;
  if (a.zIndex !== b2.zIndex) return false;
  if (a.drawingContentId !== b2.drawingContentId) return false;
  if (!jsonEqual(a.drawingContent, b2.drawingContent)) return false;
  if (!shallowRecordEqual(a.attrs, b2.attrs)) return false;
  if (a.drawingKind === "image" && b2.drawingKind === "image") {
    return imageBlocksEqual(a, b2);
  }
  if (a.drawingKind === "vectorShape" && b2.drawingKind === "vectorShape") {
    return drawingGeometryEqual(a.geometry, b2.geometry) && a.shapeKind === b2.shapeKind && a.fillColor === b2.fillColor && a.strokeColor === b2.strokeColor && a.strokeWidth === b2.strokeWidth;
  }
  if (a.drawingKind === "shapeGroup" && b2.drawingKind === "shapeGroup") {
    return drawingGeometryEqual(a.geometry, b2.geometry) && shapeGroupTransformEqual(a.groupTransform, b2.groupTransform) && shapeGroupSizeEqual(a.size, b2.size) && shapeGroupChildrenEqual(a.shapes, b2.shapes);
  }
  return true;
};
const boxSpacingEqual = (a, b2) => {
  if (a === b2) return true;
  if (!a || !b2) return !a && !b2;
  return a.top === b2.top && a.right === b2.right && a.bottom === b2.bottom && a.left === b2.left;
};
const imageAnchorEqual = (a, b2) => {
  if (a === b2) return true;
  if (!a || !b2) return !a && !b2;
  return a.isAnchored === b2.isAnchored && a.hRelativeFrom === b2.hRelativeFrom && a.vRelativeFrom === b2.vRelativeFrom && a.alignH === b2.alignH && a.alignV === b2.alignV && a.offsetH === b2.offsetH && a.offsetV === b2.offsetV && a.behindDoc === b2.behindDoc;
};
const imageWrapEqual = (a, b2) => {
  if (a === b2) return true;
  if (!a || !b2) return !a && !b2;
  return a.type === b2.type && a.wrapText === b2.wrapText && a.distTop === b2.distTop && a.distBottom === b2.distBottom && a.distLeft === b2.distLeft && a.distRight === b2.distRight && a.behindDoc === b2.behindDoc && polygonEqual(a.polygon, b2.polygon);
};
const polygonEqual = (a, b2) => {
  if (a === b2) return true;
  if (!a || !b2) return !a && !b2;
  if (a.length !== b2.length) return false;
  for (let i = 0; i < a.length; i += 1) {
    const rowA = a[i];
    const rowB = b2[i];
    if (!rowA || !rowB) return false;
    if (rowA.length !== rowB.length) return false;
    for (let j = 0; j < rowA.length; j += 1) {
      if (rowA[j] !== rowB[j]) {
        return false;
      }
    }
  }
  return true;
};
const drawingGeometryEqual = (a, b2) => {
  if (a === b2) return true;
  if (!a || !b2) return !a && !b2;
  return a.width === b2.width && a.height === b2.height && (a.rotation ?? 0) === (b2.rotation ?? 0) && Boolean(a.flipH) === Boolean(b2.flipH) && Boolean(a.flipV) === Boolean(b2.flipV);
};
const shapeGroupTransformEqual = (a, b2) => {
  if (a === b2) return true;
  if (!a || !b2) return !a && !b2;
  return a.x === b2.x && a.y === b2.y && a.width === b2.width && a.height === b2.height && a.childX === b2.childX && a.childY === b2.childY && a.childWidth === b2.childWidth && a.childHeight === b2.childHeight && a.childOriginXEmu === b2.childOriginXEmu && a.childOriginYEmu === b2.childOriginYEmu;
};
const shapeGroupSizeEqual = (a, b2) => {
  if (a === b2) return true;
  if (!a || !b2) return !a && !b2;
  return a.width === b2.width && a.height === b2.height;
};
const shapeGroupChildrenEqual = (a, b2) => {
  if (a === b2) return true;
  if (!a || !b2) return !a && !b2;
  if (a.length !== b2.length) return false;
  for (let i = 0; i < a.length; i += 1) {
    const childA = a[i];
    const childB = b2[i];
    if (!childA || !childB) return false;
    if (childA.shapeType !== childB.shapeType) return false;
    if (!jsonEqual(childA.attrs, childB.attrs)) return false;
  }
  return true;
};
const shallowRecordEqual = (a, b2) => {
  if (a === b2) return true;
  if (!a || !b2) return !a && !b2;
  const aKeys = Object.keys(a);
  const bKeys = Object.keys(b2);
  if (aKeys.length !== bKeys.length) return false;
  for (const key2 of aKeys) {
    if (!Object.prototype.hasOwnProperty.call(b2, key2)) return false;
    if (a[key2] !== b2[key2]) return false;
  }
  return true;
};
const jsonEqual = (a, b2) => {
  if (a === b2) return true;
  if (a == null || b2 == null) return a == null && b2 == null;
  try {
    return JSON.stringify(a) === JSON.stringify(b2);
  } catch {
    return false;
  }
};
function computeHeaderFooterContentHash(blocks) {
  if (!blocks || blocks.length === 0) {
    return "";
  }
  const parts = [];
  for (const block of blocks) {
    parts.push(block.id);
    if (block.kind === "paragraph") {
      for (const run of block.runs) {
        if (!("src" in run) && run.kind !== "lineBreak" && run.kind !== "break" && run.kind !== "fieldAnnotation") {
          parts.push(run.text ?? "");
        }
        if ("bold" in run && run.bold) parts.push("b");
        if ("italic" in run && run.italic) parts.push("i");
        if ("token" in run && run.token) parts.push(`token:${run.token}`);
      }
    }
  }
  return parts.join("|");
}
function computeSectionMetadataHash(sections) {
  if (!sections || sections.length === 0) {
    return "";
  }
  const parts = [];
  for (const section of sections) {
    parts.push(`section:${section.sectionIndex}`);
    if (section.numbering) {
      const num = section.numbering;
      parts.push(`num:${num.format ?? "decimal"}:${num.start ?? 1}`);
    }
    if (section.headerRefs) {
      const refs = section.headerRefs;
      if (refs.default) parts.push(`hdr-def:${refs.default}`);
      if (refs.first) parts.push(`hdr-first:${refs.first}`);
      if (refs.even) parts.push(`hdr-even:${refs.even}`);
      if (refs.odd) parts.push(`hdr-odd:${refs.odd}`);
    }
    if (section.footerRefs) {
      const refs = section.footerRefs;
      if (refs.default) parts.push(`ftr-def:${refs.default}`);
      if (refs.first) parts.push(`ftr-first:${refs.first}`);
      if (refs.even) parts.push(`ftr-even:${refs.even}`);
      if (refs.odd) parts.push(`ftr-odd:${refs.odd}`);
    }
  }
  return parts.join("|");
}
function computeConstraintsHash(constraints) {
  const { width, height, pageWidth, margins, overflowBaseHeight } = constraints;
  const parts = [`w:${width}`, `h:${height}`];
  if (pageWidth !== void 0) {
    parts.push(`pw:${pageWidth}`);
  }
  if (overflowBaseHeight !== void 0) {
    parts.push(`obh:${overflowBaseHeight}`);
  }
  if (margins) {
    parts.push(`ml:${margins.left}`, `mr:${margins.right}`);
  }
  return parts.join("|");
}
class HeaderFooterCacheState {
  constructor() {
    this.contentHashes = /* @__PURE__ */ new Map();
    this.constraintsHash = "";
    this.sectionMetadataHash = "";
  }
  /**
   * Checks if header/footer content has changed for a variant.
   *
   * @param variantKey - Unique key for the variant (e.g., 'header-default')
   * @param blocks - Current blocks for the variant
   * @returns True if content has changed
   */
  hasContentChanged(variantKey, blocks) {
    const currentHash = computeHeaderFooterContentHash(blocks);
    const previousHash = this.contentHashes.get(variantKey);
    if (previousHash === void 0) {
      this.contentHashes.set(variantKey, currentHash);
      return false;
    }
    const changed = currentHash !== previousHash;
    if (changed) {
      this.contentHashes.set(variantKey, currentHash);
    }
    return changed;
  }
  /**
   * Checks if constraints have changed.
   *
   * @param constraints - Current constraints
   * @returns True if constraints have changed
   */
  hasConstraintsChanged(constraints) {
    const currentHash = computeConstraintsHash(constraints);
    if (this.constraintsHash === "") {
      this.constraintsHash = currentHash;
      return false;
    }
    const changed = currentHash !== this.constraintsHash;
    if (changed) {
      this.constraintsHash = currentHash;
    }
    return changed;
  }
  /**
   * Checks if section metadata has changed.
   *
   * @param sections - Current section metadata
   * @returns True if metadata has changed
   */
  hasSectionMetadataChanged(sections) {
    const currentHash = computeSectionMetadataHash(sections);
    if (this.sectionMetadataHash === "") {
      this.sectionMetadataHash = currentHash;
      return false;
    }
    const changed = currentHash !== this.sectionMetadataHash;
    if (changed) {
      this.sectionMetadataHash = currentHash;
    }
    return changed;
  }
  /**
   * Resets all cached state.
   * Called when performing a full cache clear.
   */
  reset() {
    this.contentHashes.clear();
    this.constraintsHash = "";
    this.sectionMetadataHash = "";
  }
}
function invalidateHeaderFooterCache(cache2, cacheState, headerBlocks, footerBlocks, constraints, sections) {
  const invalidationReasons = [];
  const affectedBlockIds = [];
  if (constraints && cacheState.hasConstraintsChanged(constraints)) {
    invalidationReasons.push("constraints changed");
    if (headerBlocks) {
      Object.values(headerBlocks).forEach((blocks) => {
        if (blocks) affectedBlockIds.push(...blocks.map((b2) => b2.id));
      });
    }
    if (footerBlocks) {
      Object.values(footerBlocks).forEach((blocks) => {
        if (blocks) affectedBlockIds.push(...blocks.map((b2) => b2.id));
      });
    }
  }
  if (sections && cacheState.hasSectionMetadataChanged(sections)) {
    invalidationReasons.push("section metadata changed");
    if (headerBlocks) {
      Object.values(headerBlocks).forEach((blocks) => {
        if (blocks) affectedBlockIds.push(...blocks.map((b2) => b2.id));
      });
    }
    if (footerBlocks) {
      Object.values(footerBlocks).forEach((blocks) => {
        if (blocks) affectedBlockIds.push(...blocks.map((b2) => b2.id));
      });
    }
  }
  if (headerBlocks) {
    for (const [variant, blocks] of Object.entries(headerBlocks)) {
      if (!blocks) continue;
      const variantKey = `header-${variant}`;
      if (cacheState.hasContentChanged(variantKey, blocks)) {
        invalidationReasons.push(`header ${variant} content changed`);
        affectedBlockIds.push(...blocks.map((b2) => b2.id));
      }
    }
  }
  if (footerBlocks) {
    for (const [variant, blocks] of Object.entries(footerBlocks)) {
      if (!blocks) continue;
      const variantKey = `footer-${variant}`;
      if (cacheState.hasContentChanged(variantKey, blocks)) {
        invalidationReasons.push(`footer ${variant} content changed`);
        affectedBlockIds.push(...blocks.map((b2) => b2.id));
      }
    }
  }
  if (affectedBlockIds.length > 0) {
    const uniqueBlockIds = Array.from(new Set(affectedBlockIds));
    cache2.invalidate(uniqueBlockIds);
    HeaderFooterCacheLogger.logInvalidation(invalidationReasons.join(", "), uniqueBlockIds);
  }
}
const measureCache = new MeasureCache();
const headerMeasureCache = new HeaderFooterLayoutCache();
const headerFooterCacheState = new HeaderFooterCacheState();
const layoutDebugEnabled = typeof vue.process$1 !== "undefined" && typeof vue.process$1.env !== "undefined" && Boolean(vue.process$1.env.SD_DEBUG_LAYOUT);
const perfLog = (...args) => {
  if (!layoutDebugEnabled) return;
  console.log(...args);
};
const isFootnotesLayoutInput = (value) => {
  if (!value || typeof value !== "object") return false;
  const v = value;
  if (!Array.isArray(v.refs)) return false;
  if (!(v.blocksById instanceof Map)) return false;
  return true;
};
const findPageIndexForPos = (layout, pos) => {
  if (!Number.isFinite(pos)) return null;
  const fallbackRanges = [];
  for (let pageIndex = 0; pageIndex < layout.pages.length; pageIndex++) {
    const page = layout.pages[pageIndex];
    let minStart = null;
    let maxEnd = null;
    for (const fragment of page.fragments) {
      const pmStart = fragment.pmStart;
      const pmEnd = fragment.pmEnd;
      if (pmStart == null || pmEnd == null) continue;
      if (minStart == null || pmStart < minStart) minStart = pmStart;
      if (maxEnd == null || pmEnd > maxEnd) maxEnd = pmEnd;
      if (pos >= pmStart && pos <= pmEnd) {
        return pageIndex;
      }
    }
    fallbackRanges[pageIndex] = minStart != null && maxEnd != null ? { pageIndex, minStart, maxEnd } : null;
  }
  let best = null;
  for (const entry of fallbackRanges) {
    if (!entry) continue;
    const distance = pos < entry.minStart ? entry.minStart - pos : pos > entry.maxEnd ? pos - entry.maxEnd : 0;
    if (!best || distance < best.distance) {
      best = { pageIndex: entry.pageIndex, distance };
    }
  }
  if (best) return best.pageIndex;
  if (layout.pages.length > 0) return layout.pages.length - 1;
  return null;
};
const footnoteColumnKey = (pageIndex, columnIndex) => `${pageIndex}:${columnIndex}`;
const COLUMN_EPSILON = 0.01;
const normalizeColumnsForFootnotes = (input, contentWidth) => {
  const rawCount = Number.isFinite(input?.count) ? Math.floor(input.count) : 1;
  const count = Math.max(1, rawCount || 1);
  const gap = Math.max(0, input?.gap ?? 0);
  const totalGap = gap * (count - 1);
  const width = (contentWidth - totalGap) / count;
  if (!Number.isFinite(width) || width <= COLUMN_EPSILON) {
    return {
      count: 1,
      gap: 0,
      width: Math.max(0, contentWidth)
    };
  }
  return { count, gap, width };
};
const resolveSectionColumnsByIndex = (options, blocks) => {
  const result = /* @__PURE__ */ new Map();
  let activeColumns = options.columns ?? { count: 1, gap: 0 };
  if (blocks && blocks.length > 0) {
    for (const block of blocks) {
      if (block.kind !== "sectionBreak") continue;
      const sectionIndexRaw = block.attrs?.sectionIndex;
      const sectionIndex = typeof sectionIndexRaw === "number" && Number.isFinite(sectionIndexRaw) ? sectionIndexRaw : result.size;
      if (block.columns) {
        activeColumns = { count: block.columns.count, gap: block.columns.gap };
      }
      result.set(sectionIndex, { ...activeColumns });
    }
  }
  if (result.size === 0) {
    result.set(0, { ...activeColumns });
  }
  return result;
};
const resolvePageColumns = (layout, options, blocks) => {
  const sectionColumns = resolveSectionColumnsByIndex(options, blocks);
  const result = /* @__PURE__ */ new Map();
  for (let pageIndex = 0; pageIndex < layout.pages.length; pageIndex += 1) {
    const page = layout.pages[pageIndex];
    const pageSize = page.size ?? layout.pageSize ?? DEFAULT_PAGE_SIZE$1;
    const marginLeft = normalizeMargin(
      page.margins?.left,
      normalizeMargin(options.margins?.left, DEFAULT_MARGINS$1.left)
    );
    const marginRight = normalizeMargin(
      page.margins?.right,
      normalizeMargin(options.margins?.right, DEFAULT_MARGINS$1.right)
    );
    const contentWidth = pageSize.w - (marginLeft + marginRight);
    const sectionIndex = page.sectionIndex ?? 0;
    const columnsConfig = sectionColumns.get(sectionIndex) ?? options.columns ?? { count: 1, gap: 0 };
    const normalized = normalizeColumnsForFootnotes(columnsConfig, contentWidth);
    result.set(pageIndex, { ...normalized, left: marginLeft, contentWidth });
  }
  return result;
};
const findFragmentForPos = (page, pos) => {
  for (const fragment of page.fragments) {
    const pmStart = fragment.pmStart;
    const pmEnd = fragment.pmEnd;
    if (pmStart == null || pmEnd == null) continue;
    if (pos >= pmStart && pos <= pmEnd) {
      return fragment;
    }
  }
  return null;
};
const assignFootnotesToColumns = (layout, refs, pageColumns) => {
  const result = /* @__PURE__ */ new Map();
  const seenByColumn = /* @__PURE__ */ new Map();
  for (const ref of refs) {
    const pageIndex = findPageIndexForPos(layout, ref.pos);
    if (pageIndex == null) continue;
    const columns = pageColumns.get(pageIndex);
    const page = layout.pages[pageIndex];
    let columnIndex = 0;
    if (columns && columns.count > 1 && page) {
      const fragment = findFragmentForPos(page, ref.pos);
      if (fragment && typeof fragment.x === "number") {
        const columnStride = columns.width + columns.gap;
        const rawIndex = columnStride > 0 ? Math.floor((fragment.x - columns.left) / columnStride) : 0;
        columnIndex = Math.max(0, Math.min(columns.count - 1, rawIndex));
      }
    }
    const key2 = footnoteColumnKey(pageIndex, columnIndex);
    let seen = seenByColumn.get(key2);
    if (!seen) {
      seen = /* @__PURE__ */ new Set();
      seenByColumn.set(key2, seen);
    }
    if (seen.has(ref.id)) continue;
    seen.add(ref.id);
    const pageMap = result.get(pageIndex) ?? /* @__PURE__ */ new Map();
    const list = pageMap.get(columnIndex) ?? [];
    list.push(ref.id);
    pageMap.set(columnIndex, list);
    result.set(pageIndex, pageMap);
  }
  return result;
};
const resolveFootnoteMeasurementWidth = (options, blocks) => {
  const pageSize = options.pageSize ?? DEFAULT_PAGE_SIZE$1;
  const margins = {
    right: normalizeMargin(options.margins?.right, DEFAULT_MARGINS$1.right),
    left: normalizeMargin(options.margins?.left, DEFAULT_MARGINS$1.left)
  };
  let width = pageSize.w - (margins.left + margins.right);
  let activeColumns = options.columns ?? { count: 1, gap: 0 };
  let activePageSize = pageSize;
  let activeMargins = { ...margins };
  const resolveColumnWidth = () => {
    const contentWidth = activePageSize.w - (activeMargins.left + activeMargins.right);
    const normalized = normalizeColumnsForFootnotes(activeColumns, contentWidth);
    return normalized.width;
  };
  width = resolveColumnWidth();
  if (blocks && blocks.length > 0) {
    for (const block of blocks) {
      if (block.kind !== "sectionBreak") continue;
      activePageSize = block.pageSize ?? activePageSize;
      activeMargins = {
        right: normalizeMargin(block.margins?.right, activeMargins.right),
        left: normalizeMargin(block.margins?.left, activeMargins.left)
      };
      if (block.columns) {
        activeColumns = { count: block.columns.count, gap: block.columns.gap };
      }
      const w = resolveColumnWidth();
      if (w > 0 && w < width) width = w;
    }
  }
  if (!Number.isFinite(width) || width <= 0) return 0;
  return width;
};
const MIN_FOOTNOTE_BODY_HEIGHT = 1;
const DEFAULT_FOOTNOTE_SEPARATOR_SPACING_BEFORE = 12;
const computeMaxFootnoteReserve = (layoutForPages, pageIndex, baseReserve = 0) => {
  const page = layoutForPages.pages?.[pageIndex];
  if (!page) return 0;
  const pageSize = page.size ?? layoutForPages.pageSize ?? DEFAULT_PAGE_SIZE$1;
  const topMargin = normalizeMargin(page.margins?.top, DEFAULT_MARGINS$1.top);
  const bottomWithReserve = normalizeMargin(page.margins?.bottom, DEFAULT_MARGINS$1.bottom);
  const baseReserveSafe = Number.isFinite(baseReserve) ? Math.max(0, baseReserve) : 0;
  const bottomMargin = Math.max(0, bottomWithReserve - baseReserveSafe);
  const availableForBody = pageSize.h - topMargin - bottomMargin;
  if (!Number.isFinite(availableForBody)) return 0;
  return Math.max(0, availableForBody - MIN_FOOTNOTE_BODY_HEIGHT);
};
const sumLineHeights$1 = (lines, fromLine, toLine) => {
  if (!lines || fromLine >= toLine) return 0;
  let total = 0;
  for (let i = fromLine; i < toLine; i += 1) {
    total += lines[i]?.lineHeight ?? 0;
  }
  return total;
};
const getParagraphSpacingAfter = (block) => {
  const spacing = block.attrs?.spacing;
  const value = spacing?.after ?? spacing?.lineSpaceAfter;
  return typeof value === "number" && Number.isFinite(value) && value > 0 ? value : 0;
};
const resolveSeparatorSpacingBefore = (rangesByFootnoteId, measuresById, explicitValue, fallbackValue) => {
  if (typeof explicitValue === "number" && Number.isFinite(explicitValue)) {
    return Math.max(0, explicitValue);
  }
  for (const ranges of rangesByFootnoteId.values()) {
    for (const range of ranges) {
      if (range.kind === "paragraph") {
        const measure = measuresById.get(range.blockId);
        if (measure?.kind !== "paragraph") continue;
        const lineHeight2 = measure.lines?.[range.fromLine]?.lineHeight ?? measure.lines?.[0]?.lineHeight;
        if (typeof lineHeight2 === "number" && Number.isFinite(lineHeight2) && lineHeight2 > 0) {
          return lineHeight2;
        }
      }
      if (range.kind === "list-item") {
        const measure = measuresById.get(range.blockId);
        if (measure?.kind !== "list") continue;
        const itemMeasure = measure.items.find((item) => item.itemId === range.itemId);
        const lineHeight2 = itemMeasure?.paragraph?.lines?.[range.fromLine]?.lineHeight ?? itemMeasure?.paragraph?.lines?.[0]?.lineHeight;
        if (typeof lineHeight2 === "number" && Number.isFinite(lineHeight2) && lineHeight2 > 0) {
          return lineHeight2;
        }
      }
    }
  }
  return Math.max(0, fallbackValue);
};
const getRangeRenderHeight = (range) => {
  if (range.kind === "paragraph" || range.kind === "list-item") {
    const spacing = range.toLine >= range.totalLines ? range.spacingAfter : 0;
    return range.height + spacing;
  }
  return range.height;
};
const buildFootnoteRanges = (blocks, measuresById) => {
  const ranges = [];
  blocks.forEach((block) => {
    const measure = measuresById.get(block.id);
    if (!measure) return;
    if (block.kind === "paragraph") {
      if (measure.kind !== "paragraph") return;
      const lineCount = measure.lines?.length ?? 0;
      if (lineCount === 0) return;
      ranges.push({
        kind: "paragraph",
        blockId: block.id,
        fromLine: 0,
        toLine: lineCount,
        totalLines: lineCount,
        height: sumLineHeights$1(measure.lines, 0, lineCount),
        spacingAfter: getParagraphSpacingAfter(block)
      });
      return;
    }
    if (block.kind === "list") {
      if (measure.kind !== "list") return;
      block.items.forEach((item) => {
        const itemMeasure = measure.items.find((entry) => entry.itemId === item.id);
        if (!itemMeasure) return;
        const lineCount = itemMeasure.paragraph.lines?.length ?? 0;
        if (lineCount === 0) return;
        ranges.push({
          kind: "list-item",
          blockId: block.id,
          itemId: item.id,
          fromLine: 0,
          toLine: lineCount,
          totalLines: lineCount,
          height: sumLineHeights$1(itemMeasure.paragraph.lines, 0, lineCount),
          spacingAfter: getParagraphSpacingAfter(item.paragraph)
        });
      });
      return;
    }
    if (block.kind === "table" && measure.kind === "table") {
      const height = Math.max(0, measure.totalHeight ?? 0);
      if (height > 0) {
        ranges.push({ kind: "table", blockId: block.id, height });
      }
      return;
    }
    if (block.kind === "image" && measure.kind === "image") {
      const height = Math.max(0, measure.height ?? 0);
      if (height > 0) {
        ranges.push({ kind: "image", blockId: block.id, height });
      }
      return;
    }
    if (block.kind === "drawing" && measure.kind === "drawing") {
      const height = Math.max(0, measure.height ?? 0);
      if (height > 0) {
        ranges.push({ kind: "drawing", blockId: block.id, height });
      }
    }
  });
  return ranges;
};
const splitRangeAtHeight = (range, availableHeight, measuresById) => {
  if (availableHeight <= 0) return { fitted: null, remaining: range };
  if (range.kind !== "paragraph") {
    return getRangeRenderHeight(range) <= availableHeight ? { fitted: range, remaining: null } : { fitted: null, remaining: range };
  }
  const measure = measuresById.get(range.blockId);
  if (!measure || measure.kind !== "paragraph" || !measure.lines) {
    return getRangeRenderHeight(range) <= availableHeight ? { fitted: range, remaining: null } : { fitted: null, remaining: range };
  }
  let accumulatedHeight = 0;
  let splitLine = range.fromLine;
  for (let i = range.fromLine; i < range.toLine; i += 1) {
    const lineHeight2 = measure.lines[i]?.lineHeight ?? 0;
    if (accumulatedHeight + lineHeight2 > availableHeight) break;
    accumulatedHeight += lineHeight2;
    splitLine = i + 1;
  }
  if (splitLine === range.fromLine) {
    return { fitted: null, remaining: range };
  }
  const fitted = {
    ...range,
    toLine: splitLine,
    height: sumLineHeights$1(measure.lines, range.fromLine, splitLine)
  };
  if (splitLine >= range.toLine) {
    return getRangeRenderHeight(fitted) <= availableHeight ? { fitted, remaining: null } : { fitted: null, remaining: range };
  }
  const remaining = {
    ...range,
    fromLine: splitLine,
    height: sumLineHeights$1(measure.lines, splitLine, range.toLine)
  };
  return { fitted, remaining };
};
const forceFitFirstRange = (range, measuresById) => {
  if (range.kind !== "paragraph") {
    return { fitted: range, remaining: null };
  }
  const measure = measuresById.get(range.blockId);
  if (!measure || measure.kind !== "paragraph" || !measure.lines?.length) {
    return { fitted: range, remaining: null };
  }
  const nextLine = Math.min(range.fromLine + 1, range.toLine);
  const fitted = {
    ...range,
    toLine: nextLine,
    height: sumLineHeights$1(measure.lines, range.fromLine, nextLine)
  };
  if (nextLine >= range.toLine) {
    return { fitted, remaining: null };
  }
  const remaining = {
    ...range,
    fromLine: nextLine,
    height: sumLineHeights$1(measure.lines, nextLine, range.toLine)
  };
  return { fitted, remaining };
};
const fitFootnoteContent = (id, inputRanges, availableHeight, pageIndex, columnIndex, isContinuation, measuresById, forceFirstRange) => {
  const fittedRanges = [];
  let remainingRanges = [];
  let usedHeight = 0;
  const maxHeight = Math.max(0, availableHeight);
  for (let index2 = 0; index2 < inputRanges.length; index2 += 1) {
    const range = inputRanges[index2];
    const remainingSpace = maxHeight - usedHeight;
    const rangeHeight = getRangeRenderHeight(range);
    if (rangeHeight <= remainingSpace) {
      fittedRanges.push(range);
      usedHeight += rangeHeight;
      continue;
    }
    if (range.kind === "paragraph") {
      const split = splitRangeAtHeight(range, remainingSpace, measuresById);
      if (split.fitted && getRangeRenderHeight(split.fitted) <= remainingSpace) {
        fittedRanges.push(split.fitted);
        usedHeight += getRangeRenderHeight(split.fitted);
      }
      if (split.remaining) {
        remainingRanges = [split.remaining, ...inputRanges.slice(index2 + 1)];
      } else {
        remainingRanges = inputRanges.slice(index2 + 1);
      }
      break;
    }
    remainingRanges = [range, ...inputRanges.slice(index2 + 1)];
    break;
  }
  if (fittedRanges.length === 0 && forceFirstRange && inputRanges.length > 0) {
    const forced = forceFitFirstRange(inputRanges[0], measuresById);
    if (forced.fitted) {
      fittedRanges.push(forced.fitted);
      usedHeight = getRangeRenderHeight(forced.fitted);
      remainingRanges = [];
      if (forced.remaining) {
        remainingRanges.push(forced.remaining);
      }
      remainingRanges.push(...inputRanges.slice(1));
    }
  }
  return {
    slice: {
      id,
      pageIndex,
      columnIndex,
      isContinuation,
      ranges: fittedRanges,
      totalHeight: usedHeight
    },
    remainingRanges
  };
};
async function incrementalLayout(previousBlocks, _previousLayout, nextBlocks, options, measureBlock2, headerFooter) {
  performance.now();
  const dirty = computeDirtyRegions(previousBlocks, nextBlocks);
  if (dirty.deletedBlockIds.length > 0) {
    measureCache.invalidate(dirty.deletedBlockIds);
  }
  const { measurementWidth, measurementHeight } = resolveMeasurementConstraints(options, nextBlocks);
  if (measurementWidth <= 0 || measurementHeight <= 0) {
    throw new Error("incrementalLayout: invalid measurement constraints resolved from options");
  }
  const measureStart = performance.now();
  const constraints = { maxWidth: measurementWidth, maxHeight: measurementHeight };
  const measures = [];
  let cacheHits = 0;
  let cacheMisses = 0;
  for (const block of nextBlocks) {
    if (block.kind === "sectionBreak") {
      measures.push({ kind: "sectionBreak" });
      continue;
    }
    const cached = measureCache.get(block, measurementWidth, measurementHeight);
    if (cached) {
      measures.push(cached);
      cacheHits++;
      continue;
    }
    const measurement = await measureBlock2(block, constraints);
    measureCache.set(block, measurementWidth, measurementHeight, measurement);
    measures.push(measurement);
    cacheMisses++;
  }
  const measureEnd = performance.now();
  perfLog(
    `[Perf] 4.1 Measure all blocks: ${(measureEnd - measureStart).toFixed(2)}ms (${cacheMisses} measured, ${cacheHits} cached)`
  );
  let headerContentHeights;
  let headerContentHeightsByRId;
  const hasHeaderBlocks = headerFooter?.headerBlocks && Object.keys(headerFooter.headerBlocks).length > 0;
  const hasHeaderBlocksByRId = headerFooter?.headerBlocksByRId && headerFooter.headerBlocksByRId.size > 0;
  if (headerFooter?.constraints && (hasHeaderBlocks || hasHeaderBlocksByRId)) {
    const hfPreStart = performance.now();
    const measureFn = headerFooter.measure ?? measureBlock2;
    invalidateHeaderFooterCache(
      headerMeasureCache,
      headerFooterCacheState,
      headerFooter.headerBlocks,
      headerFooter.footerBlocks,
      headerFooter.constraints,
      options.sectionMetadata
    );
    const HEADER_PRELAYOUT_PLACEHOLDER_PAGE_COUNT = 1;
    const isValidHeaderType = (key2) => {
      return ["default", "first", "even", "odd"].includes(key2);
    };
    headerContentHeights = {};
    if (hasHeaderBlocks && headerFooter.headerBlocks) {
      const preHeaderLayouts = await layoutHeaderFooterWithCache(
        headerFooter.headerBlocks,
        headerFooter.constraints,
        measureFn,
        headerMeasureCache,
        HEADER_PRELAYOUT_PLACEHOLDER_PAGE_COUNT,
        void 0
        // No page resolver needed for height calculation
      );
      for (const [type, value] of Object.entries(preHeaderLayouts)) {
        if (!isValidHeaderType(type)) continue;
        if (value?.layout && typeof value.layout.height === "number") {
          const height = value.layout.height;
          if (Number.isFinite(height) && height >= 0) {
            headerContentHeights[type] = height;
          }
        }
      }
    }
    if (hasHeaderBlocksByRId && headerFooter.headerBlocksByRId) {
      headerContentHeightsByRId = /* @__PURE__ */ new Map();
      for (const [rId, blocks] of headerFooter.headerBlocksByRId) {
        if (!blocks || blocks.length === 0) continue;
        const measureConstraints = {
          maxWidth: headerFooter.constraints.width,
          maxHeight: headerFooter.constraints.height
        };
        const measures2 = await Promise.all(blocks.map((block) => measureFn(block, measureConstraints)));
        const layout2 = layoutHeaderFooter(blocks, measures2, {
          width: headerFooter.constraints.width,
          height: headerFooter.constraints.height
        });
        if (layout2.height > 0) {
          headerContentHeightsByRId.set(rId, layout2.height);
        }
      }
    }
    const hfPreEnd = performance.now();
    perfLog(`[Perf] 4.1.5 Pre-layout headers for height: ${(hfPreEnd - hfPreStart).toFixed(2)}ms`);
  }
  let footerContentHeights;
  let footerContentHeightsByRId;
  const hasFooterBlocks = headerFooter?.footerBlocks && Object.keys(headerFooter.footerBlocks).length > 0;
  const hasFooterBlocksByRId = headerFooter?.footerBlocksByRId && headerFooter.footerBlocksByRId.size > 0;
  if (headerFooter?.constraints && (hasFooterBlocks || hasFooterBlocksByRId)) {
    const footerPreStart = performance.now();
    const measureFn = headerFooter.measure ?? measureBlock2;
    if (!hasHeaderBlocks && !hasHeaderBlocksByRId) {
      invalidateHeaderFooterCache(
        headerMeasureCache,
        headerFooterCacheState,
        headerFooter.headerBlocks,
        headerFooter.footerBlocks,
        headerFooter.constraints,
        options.sectionMetadata
      );
    }
    const FOOTER_PRELAYOUT_PLACEHOLDER_PAGE_COUNT = 1;
    const isValidFooterType = (key2) => {
      return ["default", "first", "even", "odd"].includes(key2);
    };
    footerContentHeights = {};
    try {
      if (hasFooterBlocks && headerFooter.footerBlocks) {
        const preFooterLayouts = await layoutHeaderFooterWithCache(
          headerFooter.footerBlocks,
          headerFooter.constraints,
          measureFn,
          headerMeasureCache,
          FOOTER_PRELAYOUT_PLACEHOLDER_PAGE_COUNT,
          void 0
          // No page resolver needed for height calculation
        );
        for (const [type, value] of Object.entries(preFooterLayouts)) {
          if (!isValidFooterType(type)) continue;
          if (value?.layout && typeof value.layout.height === "number") {
            const height = value.layout.height;
            if (Number.isFinite(height) && height >= 0) {
              footerContentHeights[type] = height;
            }
          }
        }
      }
      if (hasFooterBlocksByRId && headerFooter.footerBlocksByRId) {
        footerContentHeightsByRId = /* @__PURE__ */ new Map();
        for (const [rId, blocks] of headerFooter.footerBlocksByRId) {
          if (!blocks || blocks.length === 0) continue;
          const measureConstraints = {
            maxWidth: headerFooter.constraints.width,
            maxHeight: headerFooter.constraints.height
          };
          const measures2 = await Promise.all(blocks.map((block) => measureFn(block, measureConstraints)));
          const layout2 = layoutHeaderFooter(blocks, measures2, {
            width: headerFooter.constraints.width,
            height: headerFooter.constraints.height
          });
          if (layout2.height > 0) {
            footerContentHeightsByRId.set(rId, layout2.height);
          }
        }
      }
    } catch (error) {
      console.error("[Layout] Footer pre-layout failed:", error);
      footerContentHeights = void 0;
    }
    const footerPreEnd = performance.now();
    perfLog(`[Perf] 4.1.6 Pre-layout footers for height: ${(footerPreEnd - footerPreStart).toFixed(2)}ms`);
  }
  const layoutStart = performance.now();
  let layout = layoutDocument(nextBlocks, measures, {
    ...options,
    headerContentHeights,
    // Pass header heights to prevent overlap (per-variant)
    footerContentHeights,
    // Pass footer heights to prevent overlap (per-variant)
    headerContentHeightsByRId,
    // Pass header heights by rId for per-page margin calculation
    footerContentHeightsByRId,
    // Pass footer heights by rId for per-page margin calculation
    remeasureParagraph: (block, maxWidth, firstLineIndent) => remeasureParagraph(block, maxWidth, firstLineIndent)
  });
  const layoutEnd = performance.now();
  perfLog(`[Perf] 4.2 Layout document (pagination): ${(layoutEnd - layoutStart).toFixed(2)}ms`);
  const maxIterations = 3;
  let currentBlocks = nextBlocks;
  let currentMeasures = measures;
  let iteration = 0;
  const pageTokenStart = performance.now();
  let totalAffectedBlocks = 0;
  let totalRemeasureTime = 0;
  let totalRelayoutTime = 0;
  let converged = true;
  if (FeatureFlags.BODY_PAGE_TOKENS) {
    while (iteration < maxIterations) {
      const sections = options.sectionMetadata ?? [];
      const numberingCtx = buildNumberingContext(layout, sections);
      PageTokenLogger.logIterationStart(iteration, layout.pages.length);
      const tokenResult = resolvePageNumberTokens(layout, currentBlocks, currentMeasures, numberingCtx);
      if (tokenResult.affectedBlockIds.size === 0) {
        perfLog(`[Perf] 4.3 Page token resolution converged after ${iteration} iterations`);
        break;
      }
      perfLog(`[Perf] 4.3.${iteration + 1} Page tokens resolved: ${tokenResult.affectedBlockIds.size} blocks affected`);
      const blockSamples = Array.from(tokenResult.affectedBlockIds).slice(0, 5);
      PageTokenLogger.logAffectedBlocks(iteration, tokenResult.affectedBlockIds, blockSamples);
      totalAffectedBlocks += tokenResult.affectedBlockIds.size;
      currentBlocks = currentBlocks.map((block) => tokenResult.updatedBlocks.get(block.id) ?? block);
      measureCache.invalidate(Array.from(tokenResult.affectedBlockIds));
      const remeasureStart = performance.now();
      currentMeasures = await remeasureAffectedBlocks(
        currentBlocks,
        currentMeasures,
        tokenResult.affectedBlockIds,
        constraints,
        measureBlock2
      );
      const remeasureEnd = performance.now();
      const remeasureTime = remeasureEnd - remeasureStart;
      totalRemeasureTime += remeasureTime;
      perfLog(`[Perf] 4.3.${iteration + 1}.1 Re-measure: ${remeasureTime.toFixed(2)}ms`);
      PageTokenLogger.logRemeasure(tokenResult.affectedBlockIds.size, remeasureTime);
      const oldPageCount = layout.pages.length;
      const relayoutStart = performance.now();
      layout = layoutDocument(currentBlocks, currentMeasures, {
        ...options,
        headerContentHeights,
        // Pass header heights to prevent overlap (per-variant)
        footerContentHeights,
        // Pass footer heights to prevent overlap (per-variant)
        headerContentHeightsByRId,
        // Pass header heights by rId for per-page margin calculation
        footerContentHeightsByRId,
        // Pass footer heights by rId for per-page margin calculation
        remeasureParagraph: (block, maxWidth, firstLineIndent) => remeasureParagraph(block, maxWidth, firstLineIndent)
      });
      const relayoutEnd = performance.now();
      const relayoutTime = relayoutEnd - relayoutStart;
      totalRelayoutTime += relayoutTime;
      perfLog(`[Perf] 4.3.${iteration + 1}.2 Re-layout: ${relayoutTime.toFixed(2)}ms`);
      const newPageCount = layout.pages.length;
      if (newPageCount === oldPageCount && iteration > 0) {
        perfLog(`[Perf] 4.3 Page count stable at ${newPageCount} - breaking convergence loop`);
        break;
      }
      iteration++;
    }
    if (iteration >= maxIterations) {
      converged = false;
      console.warn(
        `[incrementalLayout] Page token resolution did not converge after ${maxIterations} iterations - stopping`
      );
    }
  }
  const pageTokenEnd = performance.now();
  const totalTokenTime = pageTokenEnd - pageTokenStart;
  if (iteration > 0) {
    perfLog(`[Perf] 4.3 Total page token resolution time: ${totalTokenTime.toFixed(2)}ms`);
    PageTokenLogger.logConvergence(iteration, converged, totalTokenTime);
    globalMetrics.recordPageTokenMetrics({
      totalTimeMs: totalTokenTime,
      iterations: iteration,
      affectedBlocks: totalAffectedBlocks,
      remeasureTimeMs: totalRemeasureTime,
      relayoutTimeMs: totalRelayoutTime,
      converged
    });
  }
  let extraBlocks;
  let extraMeasures;
  const footnotesInput = isFootnotesLayoutInput(options.footnotes) ? options.footnotes : null;
  if (footnotesInput && footnotesInput.refs.length > 0 && footnotesInput.blocksById.size > 0) {
    const gap = typeof footnotesInput.gap === "number" && Number.isFinite(footnotesInput.gap) ? footnotesInput.gap : 2;
    const topPadding = typeof footnotesInput.topPadding === "number" && Number.isFinite(footnotesInput.topPadding) ? footnotesInput.topPadding : 6;
    const dividerHeight = typeof footnotesInput.dividerHeight === "number" && Number.isFinite(footnotesInput.dividerHeight) ? footnotesInput.dividerHeight : 6;
    const safeGap = Math.max(0, gap);
    const safeTopPadding = Math.max(0, topPadding);
    const safeDividerHeight = Math.max(0, dividerHeight);
    const continuationDividerHeight = safeDividerHeight;
    const continuationDividerWidthFactor = 0.3;
    const footnoteWidth = resolveFootnoteMeasurementWidth(options, currentBlocks);
    if (footnoteWidth > 0) {
      const footnoteConstraints = { maxWidth: footnoteWidth, maxHeight: measurementHeight };
      const collectFootnoteIdsByColumn = (idsByColumn2) => {
        const ids = /* @__PURE__ */ new Set();
        idsByColumn2.forEach((columns) => {
          columns.forEach((list) => {
            list.forEach((id) => ids.add(id));
          });
        });
        return ids;
      };
      const measureFootnoteBlocks = async (ids) => {
        const needed = /* @__PURE__ */ new Map();
        ids.forEach((id) => {
          const blocks2 = footnotesInput.blocksById.get(id) ?? [];
          blocks2.forEach((block) => {
            if (block?.id && !needed.has(block.id)) {
              needed.set(block.id, block);
            }
          });
        });
        const blocks = Array.from(needed.values());
        const measuresById2 = /* @__PURE__ */ new Map();
        await Promise.all(
          blocks.map(async (block) => {
            const cached = measureCache.get(block, footnoteConstraints.maxWidth, footnoteConstraints.maxHeight);
            if (cached) {
              measuresById2.set(block.id, cached);
              return;
            }
            const measurement = await measureBlock2(block, footnoteConstraints);
            measureCache.set(block, footnoteConstraints.maxWidth, footnoteConstraints.maxHeight, measurement);
            measuresById2.set(block.id, measurement);
          })
        );
        return { blocks, measuresById: measuresById2 };
      };
      const computeFootnoteLayoutPlan = (layoutForPages, idsByColumn2, measuresById2, baseReserves = [], pageColumns2) => {
        const pageCount = layoutForPages.pages.length;
        const slicesByPage = /* @__PURE__ */ new Map();
        const reserves2 = new Array(pageCount).fill(0);
        const hasContinuationByColumn = /* @__PURE__ */ new Map();
        const rangesByFootnoteId = /* @__PURE__ */ new Map();
        const cappedPages = /* @__PURE__ */ new Set();
        const allIds = collectFootnoteIdsByColumn(idsByColumn2);
        allIds.forEach((id) => {
          const blocks = footnotesInput.blocksById.get(id) ?? [];
          rangesByFootnoteId.set(id, buildFootnoteRanges(blocks, measuresById2));
        });
        const separatorSpacingBefore = resolveSeparatorSpacingBefore(
          rangesByFootnoteId,
          measuresById2,
          footnotesInput.separatorSpacingBefore,
          DEFAULT_FOOTNOTE_SEPARATOR_SPACING_BEFORE
        );
        const safeSeparatorSpacingBefore = Math.max(0, separatorSpacingBefore);
        let pendingByColumn = /* @__PURE__ */ new Map();
        for (let pageIndex = 0; pageIndex < pageCount; pageIndex += 1) {
          const baseReserve = Number.isFinite(baseReserves?.[pageIndex]) ? Math.max(0, baseReserves[pageIndex]) : 0;
          const maxReserve = computeMaxFootnoteReserve(layoutForPages, pageIndex, baseReserve);
          const columns = pageColumns2.get(pageIndex);
          const columnCount = Math.max(1, Math.floor(columns?.count ?? 1));
          const pendingForPage = /* @__PURE__ */ new Map();
          pendingByColumn.forEach((entries, columnIndex) => {
            const targetIndex = columnIndex < columnCount ? columnIndex : Math.max(0, columnCount - 1);
            const list = pendingForPage.get(targetIndex) ?? [];
            list.push(...entries);
            pendingForPage.set(targetIndex, list);
          });
          pendingByColumn = /* @__PURE__ */ new Map();
          const pageSlices = [];
          let pageReserve = 0;
          for (let columnIndex = 0; columnIndex < columnCount; columnIndex += 1) {
            let usedHeight = 0;
            const columnSlices = [];
            const nextPending = [];
            let stopPlacement = false;
            const columnKey = footnoteColumnKey(pageIndex, columnIndex);
            const placeFootnote = (id, ranges, isContinuation) => {
              if (!ranges || ranges.length === 0) {
                return { placed: false, remaining: [] };
              }
              const isFirstSlice = columnSlices.length === 0;
              const separatorBefore = isFirstSlice ? safeSeparatorSpacingBefore : 0;
              const separatorHeight = isFirstSlice ? isContinuation ? continuationDividerHeight : safeDividerHeight : 0;
              const overhead = isFirstSlice ? separatorBefore + separatorHeight + safeTopPadding : 0;
              const gapBefore = !isFirstSlice ? safeGap : 0;
              const availableHeight = Math.max(0, maxReserve - usedHeight - overhead - gapBefore);
              const { slice: slice2, remainingRanges } = fitFootnoteContent(
                id,
                ranges,
                availableHeight,
                pageIndex,
                columnIndex,
                isContinuation,
                measuresById2,
                isFirstSlice && maxReserve > 0
              );
              if (slice2.ranges.length === 0) {
                return { placed: false, remaining: ranges };
              }
              if (isFirstSlice) {
                usedHeight += overhead;
                if (isContinuation) {
                  hasContinuationByColumn.set(columnKey, true);
                }
              }
              if (gapBefore > 0) {
                usedHeight += gapBefore;
              }
              usedHeight += slice2.totalHeight;
              columnSlices.push(slice2);
              return { placed: true, remaining: remainingRanges };
            };
            const pending = pendingForPage.get(columnIndex) ?? [];
            for (const entry of pending) {
              if (stopPlacement) {
                nextPending.push(entry);
                continue;
              }
              if (!entry.ranges || entry.ranges.length === 0) continue;
              const result = placeFootnote(entry.id, entry.ranges, true);
              if (!result.placed) {
                nextPending.push(entry);
                stopPlacement = true;
                continue;
              }
              if (result.remaining.length > 0) {
                nextPending.push({ id: entry.id, ranges: result.remaining });
              }
            }
            if (!stopPlacement) {
              const ids = idsByColumn2.get(pageIndex)?.get(columnIndex) ?? [];
              for (let idIndex = 0; idIndex < ids.length; idIndex += 1) {
                const id = ids[idIndex];
                const ranges = rangesByFootnoteId.get(id) ?? [];
                if (ranges.length === 0) continue;
                const result = placeFootnote(id, ranges, false);
                if (!result.placed) {
                  nextPending.push({ id, ranges });
                  for (let remainingIndex = idIndex + 1; remainingIndex < ids.length; remainingIndex += 1) {
                    const remainingId = ids[remainingIndex];
                    const remainingRanges = rangesByFootnoteId.get(remainingId) ?? [];
                    nextPending.push({ id: remainingId, ranges: remainingRanges });
                  }
                  stopPlacement = true;
                  break;
                }
                if (result.remaining.length > 0) {
                  nextPending.push({ id, ranges: result.remaining });
                }
              }
            }
            if (columnSlices.length > 0) {
              const rawReserve = Math.max(0, Math.ceil(usedHeight));
              const cappedReserve = Math.min(rawReserve, maxReserve);
              if (cappedReserve < rawReserve) {
                cappedPages.add(pageIndex);
              }
              pageReserve = Math.max(pageReserve, cappedReserve);
              pageSlices.push(...columnSlices);
            }
            if (nextPending.length > 0) {
              pendingByColumn.set(columnIndex, nextPending);
            }
          }
          if (pageSlices.length > 0) {
            slicesByPage.set(pageIndex, pageSlices);
          }
          reserves2[pageIndex] = pageReserve;
        }
        if (cappedPages.size > 0) {
          console.warn("[layout] Footnote reserve capped to preserve body area", {
            pages: Array.from(cappedPages)
          });
        }
        if (pendingByColumn.size > 0) {
          const pendingIds = /* @__PURE__ */ new Set();
          pendingByColumn.forEach((entries) => entries.forEach((entry) => pendingIds.add(entry.id)));
          console.warn("[layout] Footnote content truncated: extends beyond document pages", {
            ids: Array.from(pendingIds)
          });
        }
        return { slicesByPage, reserves: reserves2, hasContinuationByColumn, separatorSpacingBefore: safeSeparatorSpacingBefore };
      };
      const injectFragments = (layoutForPages, plan2, measuresById2, reservesByPageIndex, blockById, pageColumns2) => {
        const decorativeBlocks = [];
        const decorativeMeasures = [];
        for (let pageIndex = 0; pageIndex < layoutForPages.pages.length; pageIndex++) {
          const page = layoutForPages.pages[pageIndex];
          page.footnoteReserved = Math.max(0, reservesByPageIndex[pageIndex] ?? plan2.reserves[pageIndex] ?? 0);
          const slices = plan2.slicesByPage.get(pageIndex) ?? [];
          if (slices.length === 0) continue;
          if (!page.margins) continue;
          const pageSize = page.size ?? layoutForPages.pageSize;
          const marginLeft = normalizeMargin(
            page.margins.left,
            normalizeMargin(options.margins?.left, DEFAULT_MARGINS$1.left)
          );
          const marginRight = normalizeMargin(
            page.margins.right,
            normalizeMargin(options.margins?.right, DEFAULT_MARGINS$1.right)
          );
          const pageContentWidth = pageSize.w - (marginLeft + marginRight);
          const fallbackColumns = normalizeColumnsForFootnotes(
            options.columns ?? { count: 1, gap: 0 },
            pageContentWidth
          );
          const columns = pageColumns2.get(pageIndex) ?? {
            ...fallbackColumns,
            left: marginLeft
          };
          const bandTopY = pageSize.h - (page.margins.bottom ?? 0);
          const slicesByColumn = /* @__PURE__ */ new Map();
          slices.forEach((slice2) => {
            const columnIndex = Number.isFinite(slice2.columnIndex) ? slice2.columnIndex : 0;
            const list = slicesByColumn.get(columnIndex) ?? [];
            list.push(slice2);
            slicesByColumn.set(columnIndex, list);
          });
          slicesByColumn.forEach((columnSlices, rawColumnIndex) => {
            if (columnSlices.length === 0) return;
            const columnIndex = Math.max(0, Math.min(columns.count - 1, rawColumnIndex));
            const columnStride = columns.width + columns.gap;
            const columnX = columns.left + columnIndex * columnStride;
            const contentWidth = Math.min(columns.width, footnoteWidth);
            if (!Number.isFinite(contentWidth) || contentWidth <= 0) return;
            const columnKey = footnoteColumnKey(pageIndex, columnIndex);
            const isContinuation = plan2.hasContinuationByColumn.get(columnKey) ?? false;
            let cursorY = bandTopY + Math.max(0, plan2.separatorSpacingBefore);
            const separatorHeight = isContinuation ? continuationDividerHeight : safeDividerHeight;
            const separatorWidth = isContinuation ? Math.max(0, contentWidth * continuationDividerWidthFactor) : contentWidth;
            if (separatorHeight > 0 && separatorWidth > 0) {
              const separatorId = isContinuation ? `footnote-continuation-separator-page-${page.number}-col-${columnIndex}` : `footnote-separator-page-${page.number}-col-${columnIndex}`;
              decorativeBlocks.push({
                kind: "drawing",
                id: separatorId,
                drawingKind: "vectorShape",
                geometry: { width: separatorWidth, height: separatorHeight },
                shapeKind: "rect",
                fillColor: "#000000",
                strokeColor: null,
                strokeWidth: 0
              });
              decorativeMeasures.push({
                kind: "drawing",
                drawingKind: "vectorShape",
                width: separatorWidth,
                height: separatorHeight,
                scale: 1,
                naturalWidth: separatorWidth,
                naturalHeight: separatorHeight,
                geometry: { width: separatorWidth, height: separatorHeight }
              });
              page.fragments.push({
                kind: "drawing",
                blockId: separatorId,
                drawingKind: "vectorShape",
                x: columnX,
                y: cursorY,
                width: separatorWidth,
                height: separatorHeight,
                geometry: { width: separatorWidth, height: separatorHeight },
                scale: 1
              });
              cursorY += separatorHeight;
            }
            cursorY += safeTopPadding;
            columnSlices.forEach((slice2, sliceIndex) => {
              slice2.ranges.forEach((range) => {
                if (range.kind === "paragraph") {
                  const measure = measuresById2.get(range.blockId);
                  if (!measure || measure.kind !== "paragraph") return;
                  const marker = measure.marker;
                  page.fragments.push({
                    kind: "para",
                    blockId: range.blockId,
                    fromLine: range.fromLine,
                    toLine: range.toLine,
                    x: columnX,
                    y: cursorY,
                    width: contentWidth,
                    continuesFromPrev: range.fromLine > 0,
                    continuesOnNext: range.toLine < range.totalLines,
                    ...marker?.markerWidth != null ? { markerWidth: marker.markerWidth } : {},
                    ...marker?.markerTextWidth != null ? { markerTextWidth: marker.markerTextWidth } : {},
                    ...marker?.gutterWidth != null ? { markerGutter: marker.gutterWidth } : {}
                  });
                  cursorY += getRangeRenderHeight(range);
                  return;
                }
                if (range.kind === "list-item") {
                  const measure = measuresById2.get(range.blockId);
                  const block = blockById.get(range.blockId);
                  if (!measure || measure.kind !== "list") return;
                  if (!block || block.kind !== "list") return;
                  const itemMeasure = measure.items.find((entry) => entry.itemId === range.itemId);
                  if (!itemMeasure) return;
                  const indentLeft = Number.isFinite(itemMeasure.indentLeft) ? itemMeasure.indentLeft : 0;
                  const markerWidth = Number.isFinite(itemMeasure.markerWidth) ? itemMeasure.markerWidth : 0;
                  const itemWidth = Math.max(0, contentWidth - indentLeft - markerWidth);
                  page.fragments.push({
                    kind: "list-item",
                    blockId: range.blockId,
                    itemId: range.itemId,
                    fromLine: range.fromLine,
                    toLine: range.toLine,
                    x: columnX + indentLeft + markerWidth,
                    y: cursorY,
                    width: itemWidth,
                    markerWidth,
                    continuesFromPrev: range.fromLine > 0,
                    continuesOnNext: range.toLine < range.totalLines
                  });
                  cursorY += getRangeRenderHeight(range);
                  return;
                }
                if (range.kind === "table") {
                  const measure = measuresById2.get(range.blockId);
                  const block = blockById.get(range.blockId);
                  if (!measure || measure.kind !== "table") return;
                  if (!block || block.kind !== "table") return;
                  const tableWidthRaw = Math.max(0, measure.totalWidth ?? 0);
                  let tableWidth = Math.min(contentWidth, tableWidthRaw);
                  let tableX = columnX;
                  const justification = typeof block.attrs?.justification === "string" ? block.attrs.justification : void 0;
                  if (justification === "center") {
                    tableX = columnX + Math.max(0, (contentWidth - tableWidth) / 2);
                  } else if (justification === "right" || justification === "end") {
                    tableX = columnX + Math.max(0, contentWidth - tableWidth);
                  } else {
                    const indentValue = block.attrs?.tableIndent?.width;
                    const indent = typeof indentValue === "number" && Number.isFinite(indentValue) ? indentValue : 0;
                    tableX += indent;
                    tableWidth = Math.max(0, tableWidth - indent);
                  }
                  page.fragments.push({
                    kind: "table",
                    blockId: range.blockId,
                    fromRow: 0,
                    toRow: block.rows.length,
                    x: tableX,
                    y: cursorY,
                    width: tableWidth,
                    height: Math.max(0, measure.totalHeight ?? 0)
                  });
                  cursorY += getRangeRenderHeight(range);
                  return;
                }
                if (range.kind === "image") {
                  const measure = measuresById2.get(range.blockId);
                  if (!measure || measure.kind !== "image") return;
                  page.fragments.push({
                    kind: "image",
                    blockId: range.blockId,
                    x: columnX,
                    y: cursorY,
                    width: Math.min(contentWidth, Math.max(0, measure.width ?? 0)),
                    height: Math.max(0, measure.height ?? 0)
                  });
                  cursorY += getRangeRenderHeight(range);
                  return;
                }
                if (range.kind === "drawing") {
                  const measure = measuresById2.get(range.blockId);
                  const block = blockById.get(range.blockId);
                  if (!measure || measure.kind !== "drawing") return;
                  if (!block || block.kind !== "drawing") return;
                  page.fragments.push({
                    kind: "drawing",
                    blockId: range.blockId,
                    drawingKind: block.drawingKind,
                    x: columnX,
                    y: cursorY,
                    width: Math.min(contentWidth, Math.max(0, measure.width ?? 0)),
                    height: Math.max(0, measure.height ?? 0),
                    geometry: measure.geometry,
                    scale: measure.scale
                  });
                  cursorY += getRangeRenderHeight(range);
                }
              });
              if (sliceIndex < columnSlices.length - 1) {
                cursorY += safeGap;
              }
            });
          });
        }
        return { decorativeBlocks, decorativeMeasures };
      };
      const resolveFootnoteAssignments = (layoutForPages) => {
        const columns = resolvePageColumns(layoutForPages, options, currentBlocks);
        const idsByColumn2 = assignFootnotesToColumns(layoutForPages, footnotesInput.refs, columns);
        return { columns, idsByColumn: idsByColumn2 };
      };
      let { columns: pageColumns, idsByColumn } = resolveFootnoteAssignments(layout);
      let { measuresById } = await measureFootnoteBlocks(collectFootnoteIdsByColumn(idsByColumn));
      let plan = computeFootnoteLayoutPlan(layout, idsByColumn, measuresById, [], pageColumns);
      let reserves = plan.reserves;
      if (reserves.some((h2) => h2 > 0)) {
        layout = layoutDocument(currentBlocks, currentMeasures, {
          ...options,
          footnoteReservedByPageIndex: reserves,
          headerContentHeights,
          footerContentHeights,
          remeasureParagraph: (block, maxWidth, firstLineIndent) => remeasureParagraph(block, maxWidth, firstLineIndent)
        });
        ({ columns: pageColumns, idsByColumn } = resolveFootnoteAssignments(layout));
        ({ measuresById } = await measureFootnoteBlocks(collectFootnoteIdsByColumn(idsByColumn)));
        plan = computeFootnoteLayoutPlan(layout, idsByColumn, measuresById, reserves, pageColumns);
        reserves = plan.reserves;
        layout = layoutDocument(currentBlocks, currentMeasures, {
          ...options,
          footnoteReservedByPageIndex: reserves,
          headerContentHeights,
          footerContentHeights,
          remeasureParagraph: (block, maxWidth, firstLineIndent) => remeasureParagraph(block, maxWidth, firstLineIndent)
        });
        let { columns: finalPageColumns, idsByColumn: finalIdsByColumn } = resolveFootnoteAssignments(layout);
        let { blocks: finalBlocks, measuresById: finalMeasuresById } = await measureFootnoteBlocks(
          collectFootnoteIdsByColumn(finalIdsByColumn)
        );
        let finalPlan = computeFootnoteLayoutPlan(
          layout,
          finalIdsByColumn,
          finalMeasuresById,
          reserves,
          finalPageColumns
        );
        const finalReserves = finalPlan.reserves;
        let reservesAppliedToLayout = reserves;
        const reservesDiffer = finalReserves.length !== reserves.length || finalReserves.some((h2, i) => (reserves[i] ?? 0) !== h2) || reserves.some((h2, i) => (finalReserves[i] ?? 0) !== h2);
        if (reservesDiffer) {
          layout = layoutDocument(currentBlocks, currentMeasures, {
            ...options,
            footnoteReservedByPageIndex: finalReserves,
            headerContentHeights,
            footerContentHeights,
            remeasureParagraph: (block, maxWidth, firstLineIndent) => remeasureParagraph(block, maxWidth, firstLineIndent)
          });
          reservesAppliedToLayout = finalReserves;
          ({ columns: finalPageColumns, idsByColumn: finalIdsByColumn } = resolveFootnoteAssignments(layout));
          ({ blocks: finalBlocks, measuresById: finalMeasuresById } = await measureFootnoteBlocks(
            collectFootnoteIdsByColumn(finalIdsByColumn)
          ));
          finalPlan = computeFootnoteLayoutPlan(
            layout,
            finalIdsByColumn,
            finalMeasuresById,
            reservesAppliedToLayout,
            finalPageColumns
          );
        }
        const blockById = /* @__PURE__ */ new Map();
        finalBlocks.forEach((block) => {
          blockById.set(block.id, block);
        });
        const injected = injectFragments(
          layout,
          finalPlan,
          finalMeasuresById,
          reservesAppliedToLayout,
          blockById,
          finalPageColumns
        );
        const alignedBlocks = [];
        const alignedMeasures = [];
        finalBlocks.forEach((block) => {
          const measure = finalMeasuresById.get(block.id);
          if (!measure) return;
          alignedBlocks.push(block);
          alignedMeasures.push(measure);
        });
        extraBlocks = injected ? alignedBlocks.concat(injected.decorativeBlocks) : alignedBlocks;
        extraMeasures = injected ? alignedMeasures.concat(injected.decorativeMeasures) : alignedMeasures;
      }
    }
  }
  let headers;
  let footers;
  if (headerFooter?.constraints && (headerFooter.headerBlocks || headerFooter.footerBlocks)) {
    const hfStart = performance.now();
    const measureFn = headerFooter.measure ?? measureBlock2;
    invalidateHeaderFooterCache(
      headerMeasureCache,
      headerFooterCacheState,
      headerFooter.headerBlocks,
      headerFooter.footerBlocks,
      headerFooter.constraints,
      options.sectionMetadata
    );
    const sections = options.sectionMetadata ?? [];
    const numberingCtx = buildNumberingContext(layout, sections);
    const pageResolver = FeatureFlags.HEADER_FOOTER_PAGE_TOKENS ? (pageNumber) => {
      const pageIndex = pageNumber - 1;
      const displayInfo = numberingCtx.displayPages[pageIndex];
      return {
        displayText: displayInfo?.displayText ?? String(pageNumber),
        totalPages: numberingCtx.totalPages
      };
    } : void 0;
    if (headerFooter.headerBlocks) {
      const headerLayouts = await layoutHeaderFooterWithCache(
        headerFooter.headerBlocks,
        headerFooter.constraints,
        measureFn,
        headerMeasureCache,
        FeatureFlags.HEADER_FOOTER_PAGE_TOKENS ? void 0 : numberingCtx.totalPages,
        // Fallback for backward compat
        pageResolver
        // Use page resolver for section-aware numbering
      );
      headers = serializeHeaderFooterResults("header", headerLayouts);
    }
    if (headerFooter.footerBlocks) {
      const footerLayouts = await layoutHeaderFooterWithCache(
        headerFooter.footerBlocks,
        headerFooter.constraints,
        measureFn,
        headerMeasureCache,
        FeatureFlags.HEADER_FOOTER_PAGE_TOKENS ? void 0 : numberingCtx.totalPages,
        // Fallback for backward compat
        pageResolver
        // Use page resolver for section-aware numbering
      );
      footers = serializeHeaderFooterResults("footer", footerLayouts);
    }
    const hfEnd = performance.now();
    perfLog(`[Perf] 4.4 Header/footer layout: ${(hfEnd - hfStart).toFixed(2)}ms`);
    const cacheStats = headerMeasureCache.getStats();
    globalMetrics.recordHeaderFooterCacheMetrics(cacheStats);
    HeaderFooterCacheLogger.logStats(cacheStats);
  }
  return {
    layout,
    measures: currentMeasures,
    dirty,
    headers,
    footers,
    extraBlocks,
    extraMeasures
  };
}
const DEFAULT_PAGE_SIZE$1 = { w: 612, h: 792 };
const DEFAULT_MARGINS$1 = { top: 72, right: 72, bottom: 72, left: 72 };
const normalizeMargin = (value, fallback) => Number.isFinite(value) ? value : fallback;
function resolveMeasurementConstraints(options, blocks) {
  const pageSize = options.pageSize ?? DEFAULT_PAGE_SIZE$1;
  const margins = {
    top: normalizeMargin(options.margins?.top, DEFAULT_MARGINS$1.top),
    right: normalizeMargin(options.margins?.right, DEFAULT_MARGINS$1.right),
    bottom: normalizeMargin(options.margins?.bottom, DEFAULT_MARGINS$1.bottom),
    left: normalizeMargin(options.margins?.left, DEFAULT_MARGINS$1.left)
  };
  const baseContentWidth = pageSize.w - (margins.left + margins.right);
  const baseContentHeight = pageSize.h - (margins.top + margins.bottom);
  const computeColumnWidth = (contentWidth, columns) => {
    if (!columns || columns.count <= 1) return contentWidth;
    const gap = Math.max(0, columns.gap ?? 0);
    const totalGap = gap * (columns.count - 1);
    return (contentWidth - totalGap) / columns.count;
  };
  let measurementWidth = computeColumnWidth(baseContentWidth, options.columns);
  let measurementHeight = baseContentHeight;
  if (blocks && blocks.length > 0) {
    for (const block of blocks) {
      if (block.kind !== "sectionBreak") continue;
      const sectionPageSize = block.pageSize ?? pageSize;
      const sectionMargins = {
        top: normalizeMargin(block.margins?.top, margins.top),
        right: normalizeMargin(block.margins?.right, margins.right),
        bottom: normalizeMargin(block.margins?.bottom, margins.bottom),
        left: normalizeMargin(block.margins?.left, margins.left)
      };
      const contentWidth = sectionPageSize.w - (sectionMargins.left + sectionMargins.right);
      const contentHeight = sectionPageSize.h - (sectionMargins.top + sectionMargins.bottom);
      if (contentWidth <= 0 || contentHeight <= 0) continue;
      const columnWidth = computeColumnWidth(contentWidth, block.columns ?? options.columns);
      if (columnWidth > measurementWidth) {
        measurementWidth = columnWidth;
      }
      if (contentHeight > measurementHeight) {
        measurementHeight = contentHeight;
      }
    }
  }
  return {
    measurementWidth,
    measurementHeight
  };
}
const serializeHeaderFooterResults = (kind, batch) => {
  const results = [];
  Object.entries(batch).forEach(([type, value]) => {
    if (!value) return;
    results.push({
      kind,
      type,
      layout: value.layout,
      blocks: value.blocks,
      measures: value.measures
    });
  });
  return results;
};
function buildNumberingContext(layout, sections) {
  const totalPages = layout.pages.length;
  const displayPages = computeDisplayPageNumber(layout.pages, sections);
  return {
    totalPages,
    displayPages
  };
}
async function remeasureAffectedBlocks(blocks, measures, affectedBlockIds, constraints, measureBlock2) {
  const updatedMeasures = [...measures];
  for (let i = 0; i < blocks.length; i++) {
    const block = blocks[i];
    if (!affectedBlockIds.has(block.id)) {
      continue;
    }
    try {
      const newMeasure = await measureBlock2(block, constraints);
      updatedMeasures[i] = newMeasure;
      measureCache.set(block, constraints.maxWidth, constraints.maxHeight, newMeasure);
    } catch (error) {
      console.warn(`[incrementalLayout] Failed to re-measure block ${block.id} after token resolution:`, error);
    }
  }
  return updatedMeasures;
}
class PageGeometryHelper {
  /**
   * Creates a new PageGeometryHelper instance.
   *
   * @param config - Page geometry configuration
   */
  constructor(config) {
    this.cache = null;
    this.config = config;
  }
  /**
   * Updates the layout and invalidates the cache.
   *
   * Call this whenever the layout changes (new pages, different heights, etc.)
   *
   * @param layout - New layout data
   * @param pageGap - Optional new page gap (if not provided, uses current gap)
   */
  updateLayout(layout, pageGap) {
    this.config.layout = layout;
    if (pageGap !== void 0) {
      this.config.pageGap = pageGap;
    }
    this.cache = null;
  }
  /**
   * Updates the page gap and invalidates the cache.
   *
   * @param pageGap - New gap between pages in pixels
   */
  updatePageGap(pageGap) {
    if (this.config.pageGap !== pageGap) {
      this.config.pageGap = pageGap;
      this.cache = null;
    }
  }
  /**
   * Gets the cumulative Y position (top edge) of a page in container space.
   *
   * The returned value is the distance from the top of the container to the
   * top of the specified page, accounting for all previous pages and gaps.
   *
   * @param pageIndex - Zero-based page index
   * @returns Y position in pixels, or 0 if page index is invalid
   *
   * @example
   * ```typescript
   * // Get Y position of page 0 (first page)
   * const y0 = helper.getPageTop(0); // Returns 0
   *
   * // Get Y position of page 2 (third page)
   * // Assumes page 0 height = 1000, page 1 height = 1200, gap = 24
   * const y2 = helper.getPageTop(2); // Returns 1000 + 24 + 1200 + 24 = 2248
   * ```
   */
  getPageTop(pageIndex) {
    this.ensureCache();
    if (pageIndex < 0 || pageIndex >= this.cache.cumulativeY.length) {
      return 0;
    }
    return this.cache.cumulativeY[pageIndex];
  }
  /**
   * Gets the height of a specific page.
   *
   * Uses per-page height if available (from layout.pages[i].size?.h),
   * otherwise falls back to layout.pageSize.h.
   *
   * @param pageIndex - Zero-based page index
   * @returns Page height in pixels, or 0 if page index is invalid
   *
   * @example
   * ```typescript
   * const height = helper.getPageHeight(0); // Returns page-specific height
   * ```
   */
  getPageHeight(pageIndex) {
    this.ensureCache();
    if (pageIndex < 0 || pageIndex >= this.cache.pageHeights.length) {
      return 0;
    }
    return this.cache.pageHeights[pageIndex];
  }
  /**
   * Gets the gap between pages.
   *
   * @returns Gap in pixels
   *
   * @example
   * ```typescript
   * const gap = helper.getPageGap(); // Returns 24
   * ```
   */
  getPageGap() {
    this.ensureCache();
    return this.cache.pageGap;
  }
  /**
   * Gets the total height of all pages including gaps.
   *
   * Total height = sum of all page heights + (pageCount - 1) * gap
   *
   * @returns Total height in pixels
   *
   * @example
   * ```typescript
   * // 3 pages: heights [1000, 1200, 1000], gap = 24
   * const total = helper.getTotalHeight();
   * // Returns 1000 + 24 + 1200 + 24 + 1000 = 3248
   * ```
   */
  getTotalHeight() {
    this.ensureCache();
    return this.cache.totalHeight;
  }
  /**
   * Gets the number of pages in the layout.
   *
   * @returns Page count
   */
  getPageCount() {
    return this.config.layout.pages.length;
  }
  /**
   * Finds the page index containing a given Y coordinate.
   *
   * This performs a linear search through cached cumulative positions.
   * For large documents, consider adding binary search optimization.
   *
   * @param containerY - Y coordinate in container space
   * @returns Page index, or null if Y is outside all pages
   *
   * @example
   * ```typescript
   * // Find which page contains Y = 1500
   * const pageIndex = helper.getPageIndexAtY(1500);
   * // Returns 1 (second page) if first page ends at Y=1024
   * ```
   */
  getPageIndexAtY(containerY) {
    this.ensureCache();
    const cache2 = this.cache;
    for (let i = 0; i < cache2.cumulativeY.length; i++) {
      const pageTop = cache2.cumulativeY[i];
      const pageBottom = pageTop + cache2.pageHeights[i];
      if (containerY >= pageTop && containerY < pageBottom) {
        return i;
      }
    }
    return null;
  }
  /**
   * Finds the nearest page index to a given Y coordinate (snap-to-nearest).
   *
   * Returns the page containing Y when inside a page; otherwise returns the
   * closest page based on distance to page center. Useful for dragging through
   * page gaps where getPageIndexAtY would return null.
   *
   * @param containerY - Y coordinate in container space
   * @returns Nearest page index, or null if there are no pages
   */
  getNearestPageIndex(containerY) {
    this.ensureCache();
    const cache2 = this.cache;
    const pageCount = cache2.pageHeights.length;
    if (pageCount === 0) return null;
    const direct = this.getPageIndexAtY(containerY);
    if (direct !== null) return direct;
    let nearestIndex = 0;
    let nearestDistance = Infinity;
    for (let i = 0; i < pageCount; i++) {
      const top2 = cache2.cumulativeY[i];
      const height = cache2.pageHeights[i];
      const center = top2 + height / 2;
      const distance = Math.abs(containerY - center);
      if (distance < nearestDistance) {
        nearestDistance = distance;
        nearestIndex = i;
      }
    }
    return nearestIndex;
  }
  /**
   * Ensures the cache is built and up-to-date.
   * Validates cache state and rebuilds if needed.
   * @private
   * @throws Never throws - handles errors gracefully with fallback values
   */
  ensureCache() {
    if (this.cache !== null) {
      if (!Array.isArray(this.cache.cumulativeY) || !Array.isArray(this.cache.pageHeights)) {
        console.warn("[PageGeometryHelper] Cache corruption detected, rebuilding cache");
        this.cache = null;
      } else {
        return;
      }
    }
    this.buildCache();
  }
  /**
   * Builds the geometry cache from current layout data.
   * Handles errors gracefully by providing fallback values.
   * @private
   * @throws Never throws - catches all errors and provides safe defaults
   */
  buildCache() {
    try {
      const layout = this.config.layout;
      if (!layout || !Array.isArray(layout.pages)) {
        throw new Error("Invalid layout: missing or invalid pages array");
      }
      const pageGap = this.config.pageGap ?? layout.pageGap ?? 0;
      const pageCount = layout.pages.length;
      if (!Number.isFinite(pageGap) || pageGap < 0) {
        throw new Error(`Invalid pageGap: ${pageGap} (must be non-negative finite number)`);
      }
      const cumulativeY = new Array(pageCount);
      const pageHeights = new Array(pageCount);
      let currentY = 0;
      for (let i = 0; i < pageCount; i++) {
        const page = layout.pages[i];
        if (!page) {
          throw new Error(`Invalid page at index ${i}: page is null or undefined`);
        }
        const pageHeight = page.size?.h ?? layout.pageSize.h;
        if (!Number.isFinite(pageHeight) || pageHeight < 0) {
          throw new Error(`Invalid page height at index ${i}: ${pageHeight} (must be non-negative finite number)`);
        }
        cumulativeY[i] = currentY;
        pageHeights[i] = pageHeight;
        currentY += pageHeight;
        if (i < pageCount - 1) {
          currentY += pageGap;
        }
      }
      const totalHeight = currentY;
      this.cache = {
        cumulativeY,
        pageHeights,
        pageGap,
        totalHeight,
        layoutVersion: 0
        // Placeholder for future version tracking
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(`[PageGeometryHelper] Cache build failed: ${errorMessage}. Using fallback empty cache.`);
      this.cache = {
        cumulativeY: [],
        pageHeights: [],
        pageGap: 0,
        totalHeight: 0,
        layoutVersion: 0
      };
    }
  }
  /**
   * Clears the cache, forcing recalculation on next access.
   * Useful for testing or manual cache invalidation.
   */
  clearCache() {
    this.cache = null;
  }
  /**
   * Gets debug information about the current cache state.
   * @internal
   */
  getDebugInfo() {
    this.ensureCache();
    return {
      isCached: this.cache !== null,
      pageCount: this.config.layout.pages.length,
      pageGap: this.cache.pageGap,
      totalHeight: this.cache.totalHeight,
      cumulativeY: [...this.cache.cumulativeY],
      pageHeights: [...this.cache.pageHeights]
    };
  }
}
var Priority = /* @__PURE__ */ ((Priority2) => {
  Priority2[Priority2["P0"] = 0] = "P0";
  Priority2[Priority2["P1"] = 1] = "P1";
  Priority2[Priority2["P2"] = 2] = "P2";
  Priority2[Priority2["P3"] = 3] = "P3";
  return Priority2;
})(Priority || {});
({
  /** P0: No debounce for synchronous cursor positioning */
  [Priority.P0]: 0,
  /** P1: One animation frame (~60fps) for viewport layout */
  [Priority.P1]: 16,
  /** P2: Typing burst threshold for adjacent pages layout */
  [Priority.P2]: 50,
  /** P3: Heavy debounce for full document layout */
  [Priority.P3]: 150
});
const isAtomicFragment = (fragment) => {
  return fragment.kind === "drawing" || fragment.kind === "image";
};
const logClickStage = (_level, _stage, _payload) => {
};
const logPositionDebug = (payload) => {
  return;
};
const logSelectionMapDebug = (payload) => {
  return;
};
const blockPmRangeFromAttrs = (block) => {
  const attrs = block?.attrs;
  const pmStart = typeof attrs?.pmStart === "number" ? attrs.pmStart : void 0;
  const pmEnd = typeof attrs?.pmEnd === "number" ? attrs.pmEnd : pmStart != null ? pmStart + 1 : void 0;
  return { pmStart, pmEnd };
};
const getAtomicPmRange = (fragment, block) => {
  const pmStart = typeof fragment.pmStart === "number" ? fragment.pmStart : blockPmRangeFromAttrs(block).pmStart;
  const pmEnd = typeof fragment.pmEnd === "number" ? fragment.pmEnd : blockPmRangeFromAttrs(block).pmEnd;
  return { pmStart, pmEnd };
};
const rangesOverlap = (startA, endA, startB, endB) => {
  if (startA == null) return false;
  const effectiveEndA = endA ?? startA + 1;
  return effectiveEndA > startB && startA < endB;
};
function hitTestPage(layout, point, geometryHelper) {
  if (geometryHelper) {
    const pageIndex = geometryHelper.getPageIndexAtY(point.y);
    if (pageIndex !== null) {
      return { pageIndex, page: layout.pages[pageIndex] };
    }
    const nearest = geometryHelper.getNearestPageIndex(point.y);
    if (nearest !== null) {
      return { pageIndex: nearest, page: layout.pages[nearest] };
    }
    return null;
  }
  const pageGap = layout.pageGap ?? 0;
  let cursorY = 0;
  let nearestIndex = null;
  let nearestDistance = Infinity;
  for (let pageIndex = 0; pageIndex < layout.pages.length; pageIndex += 1) {
    const page = layout.pages[pageIndex];
    const pageHeight = page.size?.h ?? layout.pageSize.h;
    const top2 = cursorY;
    const bottom2 = top2 + pageHeight;
    if (point.y >= top2 && point.y < bottom2) {
      return { pageIndex, page };
    }
    const center = top2 + pageHeight / 2;
    const distance = Math.abs(point.y - center);
    if (distance < nearestDistance) {
      nearestDistance = distance;
      nearestIndex = pageIndex;
    }
    cursorY = bottom2 + pageGap;
  }
  if (nearestIndex !== null) {
    return { pageIndex: nearestIndex, page: layout.pages[nearestIndex] };
  }
  return null;
}
function hitTestFragment(layout, pageHit, blocks, measures, point) {
  const fragments = [...pageHit.page.fragments].sort((a, b2) => {
    const ay = a.kind === "para" ? a.y : 0;
    const by = b2.kind === "para" ? b2.y : 0;
    if (Math.abs(ay - by) > 0.5) return ay - by;
    const ax = a.kind === "para" ? a.x : 0;
    const bx = b2.kind === "para" ? b2.x : 0;
    return ax - bx;
  });
  for (const fragment of fragments) {
    if (fragment.kind !== "para") continue;
    const blockIndex = findBlockIndexByFragmentId(blocks, fragment.blockId);
    if (blockIndex === -1) continue;
    const block = blocks[blockIndex];
    const measure = measures[blockIndex];
    if (!block || block.kind !== "paragraph" || measure?.kind !== "paragraph") continue;
    const fragmentHeight = measure.lines.slice(fragment.fromLine, fragment.toLine).reduce((sum, line) => sum + line.lineHeight, 0);
    const withinX = point.x >= fragment.x && point.x <= fragment.x + fragment.width;
    const withinY = point.y >= fragment.y && point.y <= fragment.y + fragmentHeight;
    if (!withinX || !withinY) {
      continue;
    }
    return {
      fragment,
      block,
      measure,
      pageIndex: pageHit.pageIndex,
      pageY: point.y - fragment.y
    };
  }
  return null;
}
const hitTestAtomicFragment = (pageHit, blocks, measures, point) => {
  for (const fragment of pageHit.page.fragments) {
    if (!isAtomicFragment(fragment)) continue;
    const withinX = point.x >= fragment.x && point.x <= fragment.x + fragment.width;
    const withinY = point.y >= fragment.y && point.y <= fragment.y + fragment.height;
    if (!withinX || !withinY) continue;
    const blockIndex = findBlockIndexByFragmentId(blocks, fragment.blockId);
    if (blockIndex === -1) continue;
    const block = blocks[blockIndex];
    const measure = measures[blockIndex];
    if (!block || !measure) continue;
    return {
      fragment,
      block,
      measure,
      pageIndex: pageHit.pageIndex,
      pageY: 0
    };
  }
  return null;
};
const hitTestTableFragment = (pageHit, blocks, measures, point) => {
  for (const fragment of pageHit.page.fragments) {
    if (fragment.kind !== "table") continue;
    const tableFragment = fragment;
    const withinX = point.x >= tableFragment.x && point.x <= tableFragment.x + tableFragment.width;
    const withinY = point.y >= tableFragment.y && point.y <= tableFragment.y + tableFragment.height;
    if (!withinX || !withinY) continue;
    const blockIndex = blocks.findIndex((block2) => block2.id === tableFragment.blockId);
    if (blockIndex === -1) continue;
    const block = blocks[blockIndex];
    const measure = measures[blockIndex];
    if (!block || block.kind !== "table" || !measure || measure.kind !== "table") continue;
    const tableBlock = block;
    const tableMeasure = measure;
    const localX = point.x - tableFragment.x;
    const localY = point.y - tableFragment.y;
    let rowY = 0;
    let rowIndex = -1;
    if (tableMeasure.rows.length === 0 || tableBlock.rows.length === 0) continue;
    for (let r2 = tableFragment.fromRow; r2 < tableFragment.toRow && r2 < tableMeasure.rows.length; r2++) {
      const rowMeasure2 = tableMeasure.rows[r2];
      if (localY >= rowY && localY < rowY + rowMeasure2.height) {
        rowIndex = r2;
        break;
      }
      rowY += rowMeasure2.height;
    }
    if (rowIndex === -1) {
      rowIndex = Math.min(tableFragment.toRow - 1, tableMeasure.rows.length - 1);
      if (rowIndex < tableFragment.fromRow) continue;
    }
    const rowMeasure = tableMeasure.rows[rowIndex];
    const row = tableBlock.rows[rowIndex];
    if (!rowMeasure || !row) continue;
    let colX = 0;
    let colIndex = -1;
    if (rowMeasure.cells.length === 0 || row.cells.length === 0) continue;
    for (let c2 = 0; c2 < rowMeasure.cells.length; c2++) {
      const cellMeasure2 = rowMeasure.cells[c2];
      if (localX >= colX && localX < colX + cellMeasure2.width) {
        colIndex = c2;
        break;
      }
      colX += cellMeasure2.width;
    }
    if (colIndex === -1) {
      colIndex = rowMeasure.cells.length - 1;
      if (colIndex < 0) continue;
    }
    const cellMeasure = rowMeasure.cells[colIndex];
    const cell = row.cells[colIndex];
    if (!cellMeasure || !cell) continue;
    const cellBlocks = cell.blocks ?? (cell.paragraph ? [cell.paragraph] : []);
    const rawMeasures = cellMeasure.blocks ?? (cellMeasure.paragraph ? [cellMeasure.paragraph] : []);
    const cellBlockMeasures = (Array.isArray(rawMeasures) ? rawMeasures : []).filter(
      (m2) => m2 != null && typeof m2 === "object" && "kind" in m2
    );
    let blockStartY = 0;
    const getBlockHeight = (m2) => {
      if (!m2) return 0;
      if ("totalHeight" in m2 && typeof m2.totalHeight === "number") {
        return m2.totalHeight;
      }
      if ("height" in m2 && typeof m2.height === "number") {
        return m2.height;
      }
      return 0;
    };
    for (let i = 0; i < cellBlocks.length && i < cellBlockMeasures.length; i++) {
      const cellBlock = cellBlocks[i];
      const cellBlockMeasure = cellBlockMeasures[i];
      if (cellBlock?.kind !== "paragraph" || cellBlockMeasure?.kind !== "paragraph") {
        blockStartY += getBlockHeight(cellBlockMeasure);
        continue;
      }
      const blockHeight = getBlockHeight(cellBlockMeasure);
      const blockEndY = blockStartY + blockHeight;
      const padding = cell.attrs?.padding ?? { top: 2, left: 4 };
      const cellLocalX = localX - colX - (padding.left ?? 4);
      const cellLocalY = localY - rowY - (padding.top ?? 2);
      const paragraphBlock = cellBlock;
      const paragraphMeasure = cellBlockMeasure;
      const isWithinBlock = cellLocalY >= blockStartY && cellLocalY < blockEndY;
      const isLastParagraph = i === Math.min(cellBlocks.length, cellBlockMeasures.length) - 1;
      if (isWithinBlock || isLastParagraph) {
        const unclampedLocalY = cellLocalY - blockStartY;
        const localYWithinBlock = Math.max(0, Math.min(unclampedLocalY, Math.max(blockHeight, 0)));
        return {
          fragment: tableFragment,
          block: tableBlock,
          measure: tableMeasure,
          pageIndex: pageHit.pageIndex,
          cellRowIndex: rowIndex,
          cellColIndex: colIndex,
          cellBlock: paragraphBlock,
          cellMeasure: paragraphMeasure,
          localX: Math.max(0, cellLocalX),
          localY: Math.max(0, localYWithinBlock)
        };
      }
      blockStartY = blockEndY;
    }
  }
  return null;
};
const readLayoutEpochFromDom = (domContainer, clientX, clientY) => {
  const doc2 = domContainer.ownerDocument ?? (typeof document !== "undefined" ? document : null);
  if (!doc2 || typeof doc2.elementsFromPoint !== "function") {
    return null;
  }
  let hitChain = [];
  try {
    hitChain = doc2.elementsFromPoint(clientX, clientY) ?? [];
  } catch {
    return null;
  }
  let latestEpoch = null;
  for (const el of hitChain) {
    if (!(el instanceof HTMLElement)) continue;
    if (!domContainer.contains(el)) continue;
    const raw = el.dataset.layoutEpoch;
    if (raw == null) continue;
    const epoch = Number(raw);
    if (!Number.isFinite(epoch)) continue;
    if (latestEpoch == null || epoch > latestEpoch) {
      latestEpoch = epoch;
    }
  }
  return latestEpoch;
};
function clickToPosition(layout, blocks, measures, containerPoint, domContainer, clientX, clientY, geometryHelper) {
  const layoutEpoch = layout.layoutEpoch ?? 0;
  logClickStage("log", "entry", {
    pages: layout.pages.length
  });
  if (domContainer != null && clientX != null && clientY != null) {
    const domPos = clickToPositionDom(domContainer, clientX, clientY);
    const domLayoutEpoch = readLayoutEpochFromDom(domContainer, clientX, clientY) ?? layoutEpoch;
    if (domPos != null) {
      let blockId = "";
      let pageIndex = 0;
      let column = 0;
      let lineIndex = -1;
      for (let pi = 0; pi < layout.pages.length; pi++) {
        const page = layout.pages[pi];
        for (const fragment of page.fragments) {
          if (fragment.kind === "para" && fragment.pmStart != null && fragment.pmEnd != null) {
            if (domPos >= fragment.pmStart && domPos <= fragment.pmEnd) {
              blockId = fragment.blockId;
              pageIndex = pi;
              column = determineColumn(layout, fragment.x);
              const blockIndex = findBlockIndexByFragmentId(blocks, fragment.blockId);
              if (blockIndex !== -1) {
                const measure = measures[blockIndex];
                if (measure && measure.kind === "paragraph") {
                  for (let li = fragment.fromLine; li < fragment.toLine; li++) {
                    const line = measure.lines[li];
                    const range = computeLinePmRange(blocks[blockIndex], line);
                    if (range.pmStart != null && range.pmEnd != null) {
                      if (domPos >= range.pmStart && domPos <= range.pmEnd) {
                        lineIndex = li;
                        break;
                      }
                    }
                  }
                }
              }
              return { pos: domPos, layoutEpoch: domLayoutEpoch, blockId, pageIndex, column, lineIndex };
            }
          }
        }
      }
      return { pos: domPos, layoutEpoch: domLayoutEpoch, blockId: "", pageIndex: 0, column: 0, lineIndex: -1 };
    }
  }
  const pageHit = hitTestPage(layout, containerPoint, geometryHelper);
  if (!pageHit) {
    return null;
  }
  const pageTopY = geometryHelper ? geometryHelper.getPageTop(pageHit.pageIndex) : calculatePageTopFallback(layout, pageHit.pageIndex);
  const pageRelativePoint = {
    x: containerPoint.x,
    y: containerPoint.y - pageTopY
  };
  logClickStage("log", "page-hit", {
    pageIndex: pageHit.pageIndex
  });
  let fragmentHit = hitTestFragment(layout, pageHit, blocks, measures, pageRelativePoint);
  if (!fragmentHit) {
    const page = pageHit.page;
    const fragments = page.fragments.filter(
      (f) => f != null && typeof f === "object"
    );
    let nearestHit = null;
    let nearestDist = Infinity;
    for (const frag of fragments) {
      const isPara = frag.kind === "para";
      const isAtomic = isAtomicFragment(frag);
      if (!isPara && !isAtomic) continue;
      const blockIndex = findBlockIndexByFragmentId(blocks, frag.blockId);
      if (blockIndex === -1) continue;
      const block = blocks[blockIndex];
      const measure = measures[blockIndex];
      if (!block || !measure) continue;
      let fragHeight = 0;
      if (isAtomic) {
        fragHeight = frag.height;
      } else if (isPara && block.kind === "paragraph" && measure.kind === "paragraph") {
        fragHeight = measure.lines.slice(frag.fromLine, frag.toLine).reduce((sum, line) => sum + line.lineHeight, 0);
      } else {
        continue;
      }
      const top2 = frag.y;
      const bottom2 = frag.y + fragHeight;
      let dist;
      if (pageRelativePoint.y < top2) {
        dist = top2 - pageRelativePoint.y;
      } else if (pageRelativePoint.y > bottom2) {
        dist = pageRelativePoint.y - bottom2;
      } else {
        dist = 0;
      }
      if (dist < nearestDist) {
        nearestDist = dist;
        const pageY = Math.max(0, Math.min(pageRelativePoint.y - top2, fragHeight));
        nearestHit = {
          fragment: frag,
          block,
          measure,
          pageIndex: pageHit.pageIndex,
          pageY
        };
      }
    }
    fragmentHit = nearestHit;
  }
  if (fragmentHit) {
    const { fragment, block, measure, pageIndex, pageY } = fragmentHit;
    if (fragment.kind === "para" && measure.kind === "paragraph" && block.kind === "paragraph") {
      const lineIndex = findLineIndexAtY(measure, pageY, fragment.fromLine, fragment.toLine);
      if (lineIndex == null) {
        logClickStage("warn", "no-line", {
          blockId: fragment.blockId
        });
        return null;
      }
      const line = measure.lines[lineIndex];
      const isRTL = isRtlBlock(block);
      const indentLeft = typeof block.attrs?.indent?.left === "number" ? block.attrs.indent.left : 0;
      const indentRight = typeof block.attrs?.indent?.right === "number" ? block.attrs.indent.right : 0;
      const paraIndentLeft = Number.isFinite(indentLeft) ? indentLeft : 0;
      const paraIndentRight = Number.isFinite(indentRight) ? indentRight : 0;
      const totalIndent = paraIndentLeft + paraIndentRight;
      const availableWidth = Math.max(0, fragment.width - totalIndent);
      if (totalIndent > fragment.width) {
        console.warn(
          `[clickToPosition] Paragraph indents (${totalIndent}px) exceed fragment width (${fragment.width}px) for block ${fragment.blockId}. This may indicate a layout miscalculation. Available width clamped to 0.`
        );
      }
      const markerWidth = fragment.markerWidth ?? measure.marker?.markerWidth ?? 0;
      const isListItem3 = markerWidth > 0;
      const paraAlignment = block.attrs?.alignment;
      const isJustified = paraAlignment === "justify";
      const alignmentOverride = isListItem3 && !isJustified ? "left" : void 0;
      const pos = mapPointToPm(block, line, pageRelativePoint.x - fragment.x, isRTL, availableWidth, alignmentOverride);
      if (pos == null) {
        logClickStage("warn", "no-position", {
          blockId: fragment.blockId
        });
        return null;
      }
      const column = determineColumn(layout, fragment.x);
      logPositionDebug({
        blockId: fragment.blockId,
        x: pageRelativePoint.x - fragment.x
      });
      logClickStage("log", "success", {
        blockId: fragment.blockId
      });
      return {
        pos,
        layoutEpoch,
        blockId: fragment.blockId,
        pageIndex,
        column,
        lineIndex
        // lineIndex is now already absolute (within measure.lines), no need to add fragment.fromLine
      };
    }
    if (isAtomicFragment(fragment)) {
      const pmRange = getAtomicPmRange(fragment, block);
      const pos = pmRange.pmStart ?? pmRange.pmEnd ?? null;
      if (pos == null) {
        logClickStage("warn", "atomic-without-range", {
          fragmentId: fragment.blockId
        });
        return null;
      }
      logClickStage("log", "success", {
        blockId: fragment.blockId,
        column: determineColumn(layout, fragment.x)
      });
      return {
        pos,
        layoutEpoch,
        blockId: fragment.blockId,
        pageIndex,
        column: determineColumn(layout, fragment.x),
        lineIndex: -1
      };
    }
  }
  const tableHit = hitTestTableFragment(pageHit, blocks, measures, pageRelativePoint);
  if (tableHit) {
    const { cellBlock, cellMeasure, localX, localY, pageIndex } = tableHit;
    const lineIndex = findLineIndexAtY(cellMeasure, localY, 0, cellMeasure.lines.length);
    if (lineIndex != null) {
      const line = cellMeasure.lines[lineIndex];
      const isRTL = isRtlBlock(cellBlock);
      const indentLeft = typeof cellBlock.attrs?.indent?.left === "number" ? cellBlock.attrs.indent.left : 0;
      const indentRight = typeof cellBlock.attrs?.indent?.right === "number" ? cellBlock.attrs.indent.right : 0;
      const paraIndentLeft = Number.isFinite(indentLeft) ? indentLeft : 0;
      const paraIndentRight = Number.isFinite(indentRight) ? indentRight : 0;
      const totalIndent = paraIndentLeft + paraIndentRight;
      const availableWidth = Math.max(0, tableHit.fragment.width - totalIndent);
      if (totalIndent > tableHit.fragment.width) {
        console.warn(
          `[clickToPosition:table] Paragraph indents (${totalIndent}px) exceed fragment width (${tableHit.fragment.width}px) for block ${tableHit.fragment.blockId}. This may indicate a layout miscalculation. Available width clamped to 0.`
        );
      }
      const cellMarkerWidth = cellMeasure.marker?.markerWidth ?? 0;
      const isListItem3 = cellMarkerWidth > 0;
      const cellAlignment = cellBlock.attrs?.alignment;
      const isJustified = cellAlignment === "justify";
      const alignmentOverride = isListItem3 && !isJustified ? "left" : void 0;
      const pos = mapPointToPm(cellBlock, line, localX, isRTL, availableWidth, alignmentOverride);
      if (pos != null) {
        logClickStage("log", "success", {
          blockId: tableHit.fragment.blockId,
          column: determineColumn(layout, tableHit.fragment.x)
        });
        return {
          pos,
          layoutEpoch,
          blockId: tableHit.fragment.blockId,
          pageIndex,
          column: determineColumn(layout, tableHit.fragment.x),
          lineIndex
        };
      }
    }
    const firstRun = cellBlock.runs?.[0];
    if (firstRun && firstRun.pmStart != null) {
      logClickStage("log", "success", {
        blockId: tableHit.fragment.blockId,
        pos: firstRun.pmStart,
        column: determineColumn(layout, tableHit.fragment.x)
      });
      return {
        pos: firstRun.pmStart,
        layoutEpoch,
        blockId: tableHit.fragment.blockId,
        pageIndex,
        column: determineColumn(layout, tableHit.fragment.x),
        lineIndex: 0
      };
    }
    logClickStage("warn", "table-cell-no-position", {
      blockId: tableHit.fragment.blockId,
      cellRow: tableHit.cellRowIndex,
      cellCol: tableHit.cellColIndex
    });
  }
  const atomicHit = hitTestAtomicFragment(pageHit, blocks, measures, pageRelativePoint);
  if (atomicHit && isAtomicFragment(atomicHit.fragment)) {
    const { fragment, block, pageIndex } = atomicHit;
    const pmRange = getAtomicPmRange(fragment, block);
    const pos = pmRange.pmStart ?? pmRange.pmEnd ?? null;
    if (pos == null) {
      logClickStage("warn", "atomic-without-range", {
        fragmentId: fragment.blockId
      });
      return null;
    }
    logClickStage("log", "success", {
      blockId: fragment.blockId,
      column: determineColumn(layout, fragment.x)
    });
    return {
      pos,
      layoutEpoch,
      blockId: fragment.blockId,
      pageIndex,
      column: determineColumn(layout, fragment.x),
      lineIndex: -1
    };
  }
  logClickStage("warn", "no-fragment", {
    pageIndex: pageHit.pageIndex
  });
  return null;
}
function findBlockIndexByFragmentId(blocks, fragmentBlockId, targetPmRange) {
  const index2 = blocks.findIndex(
    (block) => block.id === fragmentBlockId && block.kind !== "pageBreak" && block.kind !== "sectionBreak"
  );
  if (index2 !== -1) {
    return index2;
  }
  const baseBlockId = fragmentBlockId.replace(/-\d+$/, "");
  if (baseBlockId === fragmentBlockId) {
    return -1;
  }
  const matchingIndices = [];
  blocks.forEach((block, idx) => {
    if (block.id === baseBlockId && block.kind === "paragraph") {
      matchingIndices.push(idx);
    }
  });
  if (matchingIndices.length === 0) {
    return -1;
  }
  if (matchingIndices.length === 1) {
    return matchingIndices[0];
  }
  if (targetPmRange) {
    for (const idx of matchingIndices) {
      const block = blocks[idx];
      if (block.kind !== "paragraph") continue;
      const hasOverlap = block.runs.some((run) => {
        if (run.pmStart == null || run.pmEnd == null) return false;
        return run.pmEnd > targetPmRange.from && run.pmStart < targetPmRange.to;
      });
      if (hasOverlap) {
        return idx;
      }
    }
  }
  return matchingIndices[0];
}
const DEFAULT_CELL_PADDING = { top: 2, bottom: 2, left: 4, right: 4 };
const getCellPaddingFromRow = (cellIdx, row) => {
  const padding = row?.cells?.[cellIdx]?.attrs?.padding ?? {};
  return {
    top: padding.top ?? DEFAULT_CELL_PADDING.top,
    bottom: padding.bottom ?? DEFAULT_CELL_PADDING.bottom,
    left: padding.left ?? DEFAULT_CELL_PADDING.left,
    right: padding.right ?? DEFAULT_CELL_PADDING.right
  };
};
const getCellBlocks = (cell) => {
  if (!cell) return [];
  return cell.blocks ?? (cell.paragraph ? [cell.paragraph] : []);
};
const getCellMeasures = (cell) => {
  if (!cell) return [];
  return cell.blocks ?? (cell.paragraph ? [cell.paragraph] : []);
};
const sumLineHeights = (measure, fromLine, toLine) => {
  let height = 0;
  for (let i = fromLine; i < toLine && i < measure.lines.length; i += 1) {
    height += measure.lines[i]?.lineHeight ?? 0;
  }
  return height;
};
const calculatePageTopFallback = (layout, pageIndex) => {
  const pageGap = layout.pageGap ?? 0;
  let y2 = 0;
  for (let i = 0; i < pageIndex; i++) {
    const pageHeight = layout.pages[i]?.size?.h ?? layout.pageSize.h;
    y2 += pageHeight + pageGap;
  }
  return y2;
};
function selectionToRects(layout, blocks, measures, from3, to, geometryHelper) {
  if (from3 === to) {
    return [];
  }
  const rects = [];
  layout.pages.forEach((page, pageIndex) => {
    const pageTopY = geometryHelper ? geometryHelper.getPageTop(pageIndex) : calculatePageTopFallback(layout, pageIndex);
    page.fragments.forEach((fragment) => {
      if (fragment.kind === "para") {
        const blockIndex = findBlockIndexByFragmentId(blocks, fragment.blockId, { from: from3, to });
        if (blockIndex === -1) {
          return;
        }
        const block = blocks[blockIndex];
        const measure = measures[blockIndex];
        if (!block || block.kind !== "paragraph" || measure?.kind !== "paragraph") {
          return;
        }
        const intersectingLines = findLinesIntersectingRange(block, measure, from3, to);
        intersectingLines.forEach(({ line, index: index2 }) => {
          if (index2 < fragment.fromLine || index2 >= fragment.toLine) {
            return;
          }
          const range = computeLinePmRange(block, line);
          if (range.pmStart == null || range.pmEnd == null) return;
          const sliceFrom = Math.max(range.pmStart, from3);
          const sliceTo = Math.min(range.pmEnd, to);
          if (sliceFrom >= sliceTo) return;
          const charOffsetFrom = pmPosToCharOffset(block, line, sliceFrom);
          const charOffsetTo = pmPosToCharOffset(block, line, sliceTo);
          const markerWidth = fragment.markerWidth ?? measure.marker?.markerWidth ?? 0;
          const isListItemFlag = isListItem(markerWidth, block);
          const blockAlignment = block.attrs?.alignment;
          const isJustified = blockAlignment === "justify";
          const alignmentOverride = isListItemFlag && !isJustified ? "left" : void 0;
          const startX = mapPmToX(block, line, charOffsetFrom, fragment.width, alignmentOverride);
          const endX = mapPmToX(block, line, charOffsetTo, fragment.width, alignmentOverride);
          const indent = extractParagraphIndent(block.attrs?.indent);
          const wordLayout = getWordLayoutConfig(block);
          const isFirstLine = index2 === fragment.fromLine;
          const indentAdjust = calculateTextStartIndent({
            isFirstLine,
            isListItem: isListItemFlag,
            markerWidth,
            markerTextWidth: fragment.markerTextWidth ?? measure.marker?.markerTextWidth ?? void 0,
            paraIndentLeft: indent.left,
            firstLineIndent: indent.firstLine,
            hangingIndent: indent.hanging,
            wordLayout
          });
          const rectX = fragment.x + indentAdjust + Math.min(startX, endX);
          const rectWidth = Math.max(
            1,
            Math.min(Math.abs(endX - startX), line.width)
            // clamp to line width to prevent runaway widths
          );
          const lineOffset = lineHeightBeforeIndex$1(measure, index2) - lineHeightBeforeIndex$1(measure, fragment.fromLine);
          const rectY = fragment.y + lineOffset;
          rects.push({
            x: rectX,
            y: rectY + pageTopY,
            width: rectWidth,
            height: line.lineHeight,
            pageIndex
          });
        });
        return;
      }
      if (fragment.kind === "table") {
        const blockIndex = findBlockIndexByFragmentId(blocks, fragment.blockId, { from: from3, to });
        if (blockIndex === -1) return;
        const block = blocks[blockIndex];
        const measure = measures[blockIndex];
        if (!block || block.kind !== "table" || measure?.kind !== "table") {
          return;
        }
        const tableBlock = block;
        const tableMeasure = measure;
        const tableFragment = fragment;
        const rowHeights = tableMeasure.rows.map((rowMeasure, idx) => {
          if (tableFragment.partialRow && tableFragment.partialRow.rowIndex === idx) {
            return tableFragment.partialRow.partialHeight;
          }
          return rowMeasure?.height ?? 0;
        });
        const calculateCellX = (cellIdx, cellMeasure) => {
          const gridStart = cellMeasure.gridColumnStart ?? cellIdx;
          let x = 0;
          for (let i = 0; i < gridStart && i < tableMeasure.columnWidths.length; i += 1) {
            x += tableMeasure.columnWidths[i];
          }
          return x;
        };
        const processRow = (rowIndex, rowOffset) => {
          const rowMeasure = tableMeasure.rows[rowIndex];
          const row = tableBlock.rows[rowIndex];
          if (!rowMeasure || !row) return rowOffset;
          const rowHeight = rowHeights[rowIndex] ?? rowMeasure.height;
          const isPartialRow = tableFragment.partialRow?.rowIndex === rowIndex;
          const partialRowData = isPartialRow ? tableFragment.partialRow : null;
          const totalColumns = Math.min(rowMeasure.cells.length, row.cells.length);
          for (let cellIdx = 0; cellIdx < totalColumns; cellIdx += 1) {
            const cellMeasure = rowMeasure.cells[cellIdx];
            const cell = row.cells[cellIdx];
            if (!cellMeasure || !cell) continue;
            const padding = getCellPaddingFromRow(cellIdx, row);
            const cellX = calculateCellX(cellIdx, cellMeasure);
            const cellBlocks = getCellBlocks(cell);
            const cellBlockMeasures = getCellMeasures(cellMeasure);
            const renderedBlocks = [];
            let cumulativeLine = 0;
            for (let i = 0; i < Math.min(cellBlocks.length, cellBlockMeasures.length); i += 1) {
              const paraBlock = cellBlocks[i];
              const paraMeasure = cellBlockMeasures[i];
              if (!paraBlock || !paraMeasure || paraBlock.kind !== "paragraph" || paraMeasure.kind !== "paragraph") {
                continue;
              }
              const lineCount = paraMeasure.lines.length;
              const blockStart = cumulativeLine;
              const blockEnd = cumulativeLine + lineCount;
              cumulativeLine = blockEnd;
              const allowedStart = partialRowData?.fromLineByCell?.[cellIdx] ?? 0;
              const rawAllowedEnd = partialRowData?.toLineByCell?.[cellIdx];
              const allowedEnd = rawAllowedEnd == null || rawAllowedEnd === -1 ? cumulativeLine : rawAllowedEnd;
              const renderStartGlobal = Math.max(blockStart, allowedStart);
              const renderEndGlobal = Math.min(blockEnd, allowedEnd);
              if (renderStartGlobal >= renderEndGlobal) continue;
              const startLine = renderStartGlobal - blockStart;
              const endLine = renderEndGlobal - blockStart;
              let height = sumLineHeights(paraMeasure, startLine, endLine);
              const rendersWholeBlock = startLine === 0 && endLine >= lineCount;
              if (rendersWholeBlock) {
                const totalHeight = paraMeasure.totalHeight;
                if (typeof totalHeight === "number" && totalHeight > height) {
                  height = totalHeight;
                }
                const spacingAfter = paraBlock.attrs?.spacing?.after;
                if (typeof spacingAfter === "number" && spacingAfter > 0) {
                  height += spacingAfter;
                }
              }
              renderedBlocks.push({ block: paraBlock, measure: paraMeasure, startLine, endLine, height });
            }
            const contentHeight = renderedBlocks.reduce((acc, info) => acc + info.height, 0);
            const contentAreaHeight = Math.max(0, rowHeight - (padding.top + padding.bottom));
            const freeSpace = Math.max(0, contentAreaHeight - contentHeight);
            let verticalOffset = 0;
            const vAlign = cell.attrs?.verticalAlign;
            if (vAlign === "center" || vAlign === "middle") {
              verticalOffset = freeSpace / 2;
            } else if (vAlign === "bottom") {
              verticalOffset = freeSpace;
            }
            let blockTopCursor = padding.top + verticalOffset;
            renderedBlocks.forEach((info) => {
              const paragraphMarkerWidth = info.measure.marker?.markerWidth ?? 0;
              const cellIsListItem = isListItem(paragraphMarkerWidth, info.block);
              const alignmentOverride = cellIsListItem ? "left" : void 0;
              const cellIndent = extractParagraphIndent(
                info.block.kind === "paragraph" ? info.block.attrs?.indent : void 0
              );
              const cellWordLayout = getWordLayoutConfig(info.block);
              const intersectingLines = findLinesIntersectingRange(info.block, info.measure, from3, to);
              intersectingLines.forEach(({ line, index: index2 }) => {
                if (index2 < info.startLine || index2 >= info.endLine) {
                  return;
                }
                const range = computeLinePmRange(info.block, line);
                if (range.pmStart == null || range.pmEnd == null) return;
                const sliceFrom = Math.max(range.pmStart, from3);
                const sliceTo = Math.min(range.pmEnd, to);
                if (sliceFrom >= sliceTo) return;
                const charOffsetFrom = pmPosToCharOffset(info.block, line, sliceFrom);
                const charOffsetTo = pmPosToCharOffset(info.block, line, sliceTo);
                const availableWidth = Math.max(1, cellMeasure.width - padding.left - padding.right);
                const startX = mapPmToX(info.block, line, charOffsetFrom, availableWidth, alignmentOverride);
                const endX = mapPmToX(info.block, line, charOffsetTo, availableWidth, alignmentOverride);
                const isFirstLine = index2 === info.startLine;
                const textIndentAdjust = calculateTextStartIndent({
                  isFirstLine,
                  isListItem: cellIsListItem,
                  markerWidth: paragraphMarkerWidth,
                  markerTextWidth: info.measure?.marker?.markerTextWidth ?? void 0,
                  paraIndentLeft: cellIndent.left,
                  firstLineIndent: cellIndent.firstLine,
                  hangingIndent: cellIndent.hanging,
                  wordLayout: cellWordLayout
                });
                const rectX = fragment.x + cellX + padding.left + textIndentAdjust + Math.min(startX, endX);
                const rectWidth = Math.max(
                  1,
                  Math.min(Math.abs(endX - startX), line.width)
                  // clamp to line width to prevent runaway widths
                );
                const lineOffset = lineHeightBeforeIndex$1(info.measure, index2) - lineHeightBeforeIndex$1(info.measure, info.startLine);
                const rectY = fragment.y + rowOffset + blockTopCursor + lineOffset;
                rects.push({
                  x: rectX,
                  y: rectY + pageTopY,
                  width: rectWidth,
                  height: line.lineHeight,
                  pageIndex
                });
              });
              blockTopCursor += info.height;
            });
          }
          return rowOffset + rowHeight;
        };
        let rowCursor = 0;
        const repeatHeaderCount = tableFragment.repeatHeaderCount ?? 0;
        for (let r2 = 0; r2 < repeatHeaderCount && r2 < tableMeasure.rows.length; r2 += 1) {
          rowCursor = processRow(r2, rowCursor);
        }
        for (let r2 = tableFragment.fromRow; r2 < tableFragment.toRow && r2 < tableMeasure.rows.length; r2 += 1) {
          rowCursor = processRow(r2, rowCursor);
        }
        return;
      }
      if (isAtomicFragment(fragment)) {
        const blockIndex = findBlockIndexByFragmentId(blocks, fragment.blockId, { from: from3, to });
        if (blockIndex === -1) return;
        const block = blocks[blockIndex];
        const pmRange = getAtomicPmRange(fragment, block);
        if (!rangesOverlap(pmRange.pmStart, pmRange.pmEnd, from3, to)) return;
        rects.push({
          x: fragment.x,
          y: fragment.y + pageTopY,
          width: fragment.width,
          height: fragment.height,
          pageIndex
        });
      }
    });
  });
  return rects;
}
function getFragmentAtPosition(layout, blocks, measures, pos) {
  for (let pageIndex = 0; pageIndex < layout.pages.length; pageIndex += 1) {
    const page = layout.pages[pageIndex];
    for (const fragment of page.fragments) {
      const blockIndex = findBlockIndexByFragmentId(blocks, fragment.blockId);
      if (blockIndex === -1) {
        continue;
      }
      const block = blocks[blockIndex];
      const measure = measures[blockIndex];
      if (!block || !measure) continue;
      if (fragment.kind === "para") {
        if (block.kind !== "paragraph" || measure.kind !== "paragraph") continue;
        if (fragment.pmStart != null && fragment.pmEnd != null && pos >= fragment.pmStart && pos <= fragment.pmEnd) {
          return {
            fragment,
            block,
            measure,
            pageIndex,
            pageY: 0
          };
        }
        continue;
      }
      if (fragment.kind === "table") {
        if (block.kind !== "table" || measure.kind !== "table") continue;
        const tableBlock = block;
        const tableFragment = fragment;
        let tableMinPos = null;
        let tableMaxPos = null;
        for (let r2 = tableFragment.fromRow; r2 < tableFragment.toRow && r2 < tableBlock.rows.length; r2++) {
          const row = tableBlock.rows[r2];
          for (const cell of row.cells) {
            const cellBlocks = cell.blocks ?? (cell.paragraph ? [cell.paragraph] : []);
            for (const cellBlock of cellBlocks) {
              if (cellBlock?.kind === "paragraph") {
                const paraBlock = cellBlock;
                for (const run of paraBlock.runs ?? []) {
                  if (run.pmStart != null) {
                    if (tableMinPos === null || run.pmStart < tableMinPos) tableMinPos = run.pmStart;
                    if (tableMaxPos === null || run.pmStart > tableMaxPos) tableMaxPos = run.pmStart;
                  }
                  if (run.pmEnd != null) {
                    if (tableMinPos === null || run.pmEnd < tableMinPos) tableMinPos = run.pmEnd;
                    if (tableMaxPos === null || run.pmEnd > tableMaxPos) tableMaxPos = run.pmEnd;
                  }
                }
              }
            }
          }
        }
        if (tableMinPos != null && tableMaxPos != null && pos >= tableMinPos && pos <= tableMaxPos) {
          return {
            fragment,
            block,
            measure,
            pageIndex,
            pageY: 0
          };
        }
        continue;
      }
      if (isAtomicFragment(fragment)) {
        const { pmStart, pmEnd } = getAtomicPmRange(fragment, block);
        const start2 = pmStart ?? pmEnd;
        const end2 = pmEnd ?? pmStart;
        if (start2 == null || end2 == null) {
          continue;
        }
        const rangeStart = Math.min(start2, end2);
        const rangeEnd = Math.max(start2, end2);
        if (pos >= rangeStart && pos <= rangeEnd) {
          return {
            fragment,
            block,
            measure,
            pageIndex,
            pageY: 0
          };
        }
      }
    }
  }
  return null;
}
function findLinesIntersectingRange(block, measure, from3, to) {
  if (block.kind !== "paragraph" || measure.kind !== "paragraph") {
    return [];
  }
  const hits = [];
  measure.lines.forEach((line, idx) => {
    const range = computeLinePmRange(block, line);
    if (range.pmStart == null || range.pmEnd == null) {
      return;
    }
    const intersects = range.pmEnd > from3 && range.pmStart < to;
    if (intersects) {
      hits.push({ line, index: idx });
    }
  });
  return hits;
}
function computeLinePmRange(block, line) {
  return computeLinePmRange$1(block, line);
}
function pmPosToCharOffset(block, line, pmPos) {
  if (block.kind !== "paragraph") return 0;
  let charOffset = 0;
  for (let runIndex = line.fromRun; runIndex <= line.toRun; runIndex += 1) {
    const run = block.runs[runIndex];
    if (!run) continue;
    const text = "src" in run || run.kind === "lineBreak" || run.kind === "break" || run.kind === "fieldAnnotation" ? "" : run.text ?? "";
    const runTextLength = text.length;
    const runPmStart = run.pmStart ?? null;
    const runPmEnd = run.pmEnd ?? (runPmStart != null ? runPmStart + runTextLength : null);
    if (runPmStart == null || runPmEnd == null || runTextLength === 0) continue;
    const isFirstRun = runIndex === line.fromRun;
    const isLastRun = runIndex === line.toRun;
    const lineStartChar = isFirstRun ? line.fromChar : 0;
    const lineEndChar = isLastRun ? line.toChar : runTextLength;
    const runSliceCharCount = lineEndChar - lineStartChar;
    const runPmRange = runPmEnd - runPmStart;
    const runSlicePmStart = runPmStart + lineStartChar / runTextLength * runPmRange;
    const runSlicePmEnd = runPmStart + lineEndChar / runTextLength * runPmRange;
    if (pmPos >= runSlicePmStart && pmPos <= runSlicePmEnd) {
      const runSlicePmRange = runSlicePmEnd - runSlicePmStart;
      if (runSlicePmRange > 0) {
        const pmOffsetInSlice = pmPos - runSlicePmStart;
        const charOffsetInSlice = Math.round(pmOffsetInSlice / runSlicePmRange * runSliceCharCount);
        const result = charOffset + Math.min(charOffsetInSlice, runSliceCharCount);
        const runText2 = text;
        const offsetInRun = result - charOffset - (isFirstRun ? 0 : 0);
        logSelectionMapDebug({
          blockId: block.id,
          lineFromRun: line.fromRun,
          lineToRun: line.toRun,
          runTextPreview: runText2.slice(Math.max(0, offsetInRun - 10), Math.min(runText2.length, offsetInRun + 10))
        });
        return result;
      }
      logSelectionMapDebug({
        blockId: block.id
      });
      return charOffset;
    }
    if (pmPos > runSlicePmEnd) {
      charOffset += runSliceCharCount;
    }
  }
  logSelectionMapDebug({
    blockId: block.id,
    lineFromRun: line.fromRun,
    lineToRun: line.toRun
  });
  return charOffset;
}
const determineColumn = (layout, fragmentX) => {
  const columns = layout.columns;
  if (!columns || columns.count <= 1) return 0;
  const usableWidth = layout.pageSize.w - columns.gap * (columns.count - 1);
  const columnWidth = usableWidth / columns.count;
  const span = columnWidth + columns.gap;
  const relative = fragmentX;
  const raw = Math.floor(relative / Math.max(span, 1));
  return Math.max(0, Math.min(columns.count - 1, raw));
};
const findLineIndexAtY = (measure, offsetY, fromLine, toLine) => {
  if (measure.kind !== "paragraph") return null;
  const lineCount = measure.lines.length;
  if (fromLine < 0 || toLine > lineCount || fromLine >= toLine) {
    return null;
  }
  let cursor = 0;
  for (let i = fromLine; i < toLine; i += 1) {
    const line = measure.lines[i];
    if (!line) return null;
    const next = cursor + line.lineHeight;
    if (offsetY >= cursor && offsetY < next) {
      return i;
    }
    cursor = next;
  }
  return toLine - 1;
};
const lineHeightBeforeIndex$1 = (measure, absoluteLineIndex) => {
  if (measure.kind !== "paragraph") return 0;
  let height = 0;
  for (let i = 0; i < absoluteLineIndex; i += 1) {
    height += measure.lines[i]?.lineHeight ?? 0;
  }
  return height;
};
const mapPointToPm = (block, line, x, isRTL, availableWidthOverride, alignmentOverride) => {
  if (block.kind !== "paragraph") return null;
  const range = computeLinePmRange(block, line);
  if (range.pmStart == null || range.pmEnd == null) return null;
  const result = findCharacterAtX(block, line, x, range.pmStart, availableWidthOverride, alignmentOverride);
  let pmPosition = result.pmPosition;
  if (isRTL) {
    const charOffset = result.charOffset;
    const charsInLine = Math.max(1, line.toChar - line.fromChar);
    const reversedOffset = Math.max(0, Math.min(charsInLine, charsInLine - charOffset));
    pmPosition = charOffsetToPm(block, line, reversedOffset, range.pmStart);
  }
  return pmPosition;
};
const mapPmToX = (block, line, offset2, fragmentWidth, alignmentOverride) => {
  if (fragmentWidth <= 0 || line.width <= 0) return 0;
  let paraIndentLeft = 0;
  let paraIndentRight = 0;
  let effectiveLeft = 0;
  if (block.kind === "paragraph") {
    const indentLeft = typeof block.attrs?.indent?.left === "number" ? block.attrs.indent.left : 0;
    const indentRight = typeof block.attrs?.indent?.right === "number" ? block.attrs.indent.right : 0;
    paraIndentLeft = Number.isFinite(indentLeft) ? indentLeft : 0;
    paraIndentRight = Number.isFinite(indentRight) ? indentRight : 0;
    effectiveLeft = paraIndentLeft;
    const wl = getWordLayoutConfig(block);
    const isListParagraph = Boolean(block.attrs?.numberingProperties) || Boolean(wl?.marker);
    if (isListParagraph) {
      const explicitTextStart = typeof wl?.marker?.textStartX === "number" && Number.isFinite(wl.marker.textStartX) ? wl.marker.textStartX : typeof wl?.textStartPx === "number" && Number.isFinite(wl.textStartPx) ? wl.textStartPx : void 0;
      if (typeof explicitTextStart === "number" && explicitTextStart > paraIndentLeft) {
        effectiveLeft = explicitTextStart;
      }
    }
  }
  const totalIndent = effectiveLeft + paraIndentRight;
  const availableWidth = Math.max(0, fragmentWidth - totalIndent);
  if (totalIndent > fragmentWidth) {
    console.warn(
      `[mapPmToX] Paragraph indents (${totalIndent}px) exceed fragment width (${fragmentWidth}px) for block ${block.id}. This may indicate a layout miscalculation. Available width clamped to 0.`
    );
  }
  return measureCharacterX(block, line, offset2, availableWidth, alignmentOverride);
};
const isRtlBlock = (block) => {
  if (block.kind !== "paragraph") return false;
  const attrs = block.attrs;
  if (!attrs) return false;
  const directionAttr = attrs.direction ?? attrs.dir ?? attrs.textDirection;
  if (typeof directionAttr === "string" && directionAttr.toLowerCase() === "rtl") {
    return true;
  }
  if (typeof attrs.rtl === "boolean") {
    return attrs.rtl;
  }
  return false;
};
function renderRemoteCursors(options) {
  const layout = options.layout;
  const blocks = options.blocks;
  const measures = options.measures;
  const maxVisible = options.presence?.maxVisible ?? 20;
  const sortedCursors = Array.from(options.remoteCursorState.values()).sort((a, b2) => b2.updatedAt - a.updatedAt).slice(0, maxVisible);
  const visibleClientIds = /* @__PURE__ */ new Set();
  sortedCursors.forEach((cursor) => {
    visibleClientIds.add(cursor.clientId);
    const oldSelections = options.remoteCursorOverlay?.querySelectorAll(
      `.presentation-editor__remote-selection[data-client-id="${cursor.clientId}"]`
    );
    oldSelections?.forEach((el) => el.remove());
    if (cursor.anchor === cursor.head) {
      renderRemoteCaret({
        cursor,
        presence: options.presence,
        remoteCursorElements: options.remoteCursorElements,
        remoteCursorOverlay: options.remoteCursorOverlay,
        doc: options.doc,
        computeCaretLayoutRect: options.computeCaretLayoutRect,
        convertPageLocalToOverlayCoords: options.convertPageLocalToOverlayCoords,
        fallbackColors: options.fallbackColors,
        cursorStyles: options.cursorStyles
      });
    } else {
      renderRemoteSelection({
        cursor,
        layout,
        blocks,
        measures,
        pageGeometryHelper: options.pageGeometryHelper,
        presence: options.presence,
        remoteCursorOverlay: options.remoteCursorOverlay,
        doc: options.doc,
        convertPageLocalToOverlayCoords: options.convertPageLocalToOverlayCoords,
        fallbackColors: options.fallbackColors,
        cursorStyles: options.cursorStyles,
        maxSelectionRectsPerUser: options.maxSelectionRectsPerUser,
        defaultPageHeight: options.defaultPageHeight,
        fallbackPageHeight: options.fallbackPageHeight,
        renderCaret: () => renderRemoteCaret({
          cursor,
          presence: options.presence,
          remoteCursorElements: options.remoteCursorElements,
          remoteCursorOverlay: options.remoteCursorOverlay,
          doc: options.doc,
          computeCaretLayoutRect: options.computeCaretLayoutRect,
          convertPageLocalToOverlayCoords: options.convertPageLocalToOverlayCoords,
          fallbackColors: options.fallbackColors,
          cursorStyles: options.cursorStyles
        })
      });
    }
  });
  options.remoteCursorElements.forEach((element, clientId) => {
    if (!visibleClientIds.has(clientId)) {
      element.remove();
      options.remoteCursorElements.delete(clientId);
    }
  });
}
function renderRemoteCaret(options) {
  const caretLayout = options.computeCaretLayoutRect(options.cursor.head);
  const color = validateCursorColor(options.cursor.user.color, options.cursor.clientId, options.fallbackColors);
  let caretEl = options.remoteCursorElements.get(options.cursor.clientId);
  const isNewElement = !caretEl;
  if (isNewElement) {
    caretEl = options.doc.createElement("div");
    caretEl.className = "presentation-editor__remote-caret";
    caretEl.style.position = "absolute";
    caretEl.style.width = `${options.cursorStyles.CARET_WIDTH}px`;
    caretEl.style.borderLeft = `${options.cursorStyles.CARET_WIDTH}px solid ${color}`;
    caretEl.style.pointerEvents = "none";
    caretEl.style.transition = "transform 50ms ease-out, height 50ms ease-out, opacity 100ms ease-out";
    caretEl.style.willChange = "transform";
    caretEl.setAttribute("data-client-id", options.cursor.clientId.toString());
    caretEl.setAttribute("aria-hidden", "true");
    if (options.presence?.showLabels !== false) {
      renderRemoteCursorLabel({
        caretEl,
        cursor: options.cursor,
        presence: options.presence,
        doc: options.doc,
        fallbackColors: options.fallbackColors,
        cursorStyles: options.cursorStyles
      });
    }
    options.remoteCursorElements.set(options.cursor.clientId, caretEl);
    options.remoteCursorOverlay?.appendChild(caretEl);
  }
  if (!caretLayout) {
    caretEl.style.opacity = "0";
    return;
  }
  const coords = options.convertPageLocalToOverlayCoords(caretLayout.pageIndex, caretLayout.x, caretLayout.y);
  if (!coords) {
    caretEl.style.opacity = "0";
    return;
  }
  caretEl.style.opacity = "1";
  caretEl.style.transform = `translate(${coords.x}px, ${coords.y}px)`;
  caretEl.style.height = `${Math.max(1, caretLayout.height)}px`;
  caretEl.style.borderLeftColor = color;
  const labelEl = caretEl.querySelector(".presentation-editor__remote-label");
  if (labelEl) {
    labelEl.style.backgroundColor = color;
  }
}
function renderRemoteCursorLabel(options) {
  const labelFormatter = options.presence?.labelFormatter;
  let labelText = labelFormatter ? labelFormatter(options.cursor.user) : options.cursor.user.name || options.cursor.user.email || "Anonymous";
  if (labelText.length > options.cursorStyles.MAX_LABEL_LENGTH) {
    labelText = labelText.substring(0, options.cursorStyles.MAX_LABEL_LENGTH - 1) + "";
  }
  const color = validateCursorColor(options.cursor.user.color, options.cursor.clientId, options.fallbackColors);
  const labelEl = options.doc.createElement("div");
  labelEl.className = "presentation-editor__remote-label";
  labelEl.textContent = labelText;
  labelEl.style.position = "absolute";
  labelEl.style.top = options.cursorStyles.LABEL_OFFSET;
  labelEl.style.left = "-1px";
  labelEl.style.fontSize = `${options.cursorStyles.LABEL_FONT_SIZE}px`;
  labelEl.style.backgroundColor = color;
  labelEl.style.color = "white";
  labelEl.style.padding = options.cursorStyles.LABEL_PADDING;
  labelEl.style.borderRadius = "3px";
  labelEl.style.whiteSpace = "nowrap";
  labelEl.style.pointerEvents = "none";
  labelEl.title = `${options.cursor.user.name || options.cursor.user.email}  editing`;
  options.caretEl.appendChild(labelEl);
}
function renderRemoteSelection(options) {
  const start2 = Math.min(options.cursor.anchor, options.cursor.head);
  const end2 = Math.max(options.cursor.anchor, options.cursor.head);
  const rects = selectionToRects(
    options.layout,
    options.blocks,
    options.measures,
    start2,
    end2,
    options.pageGeometryHelper ?? void 0
  ) ?? [];
  const color = validateCursorColor(options.cursor.user.color, options.cursor.clientId, options.fallbackColors);
  const opacity = options.presence?.highlightOpacity ?? 0.35;
  const pageHeight = options.layout.pageSize?.h ?? options.fallbackPageHeight ?? options.defaultPageHeight;
  const pageGap = options.layout.pageGap ?? 0;
  const limitedRects = rects.slice(0, options.maxSelectionRectsPerUser);
  limitedRects.forEach((rect) => {
    const pageLocalY = rect.y - rect.pageIndex * (pageHeight + pageGap);
    const coords = options.convertPageLocalToOverlayCoords(rect.pageIndex, rect.x, pageLocalY);
    if (!coords) return;
    const selectionEl = options.doc.createElement("div");
    selectionEl.className = "presentation-editor__remote-selection";
    selectionEl.style.position = "absolute";
    selectionEl.style.left = `${coords.x}px`;
    selectionEl.style.top = `${coords.y}px`;
    selectionEl.style.width = `${Math.max(1, rect.width)}px`;
    selectionEl.style.height = `${Math.max(1, rect.height)}px`;
    selectionEl.style.backgroundColor = color;
    selectionEl.style.opacity = opacity.toString();
    selectionEl.style.borderRadius = options.cursorStyles.SELECTION_BORDER_RADIUS;
    selectionEl.style.pointerEvents = "none";
    selectionEl.setAttribute("data-client-id", options.cursor.clientId.toString());
    selectionEl.setAttribute("aria-hidden", "true");
    options.remoteCursorOverlay?.appendChild(selectionEl);
  });
  options.renderCaret();
}
const SCROLL_DEBOUNCE_MS = 32;
const DEFAULT_STALE_TIMEOUT_MS = 5 * 60 * 1e3;
const THROTTLE_MS = 16;
class RemoteCursorManager {
  #options;
  #remoteCursorState = /* @__PURE__ */ new Map();
  #remoteCursorElements = /* @__PURE__ */ new Map();
  #remoteCursorDirty = false;
  #remoteCursorUpdateScheduled = false;
  #lastRemoteCursorRenderTime = 0;
  #remoteCursorThrottleTimeout = null;
  #awarenessCleanup = null;
  #scrollCleanup = null;
  #scrollTimeout = void 0;
  #isSetup = false;
  /** Callback for telemetry emission */
  #onTelemetry = null;
  /** Callback for cursor updates (emits cursors to host) */
  #onCursorsUpdate = null;
  constructor(options) {
    this.#options = options;
  }
  /**
   * Get the current remote cursor state map.
   * Useful for emitting cursor data to host consumers.
   */
  get state() {
    return this.#remoteCursorState;
  }
  /**
   * Get the cursor elements map for testing/debugging.
   */
  get elements() {
    return this.#remoteCursorElements;
  }
  /**
   * Check if the manager is currently set up.
   */
  get isSetup() {
    return this.#isSetup;
  }
  /**
   * Set a telemetry callback to receive render metrics.
   */
  setTelemetryCallback(callback) {
    this.#onTelemetry = callback;
  }
  /**
   * Set a callback to receive cursor update events.
   */
  setCursorsUpdateCallback(callback) {
    this.#onCursorsUpdate = callback;
  }
  /**
   * Setup awareness event subscriptions for remote cursor tracking.
   * Includes scroll listener for virtualization updates.
   * Called after collaborationReady event when ySync plugin is initialized.
   * Prevents double-initialization by cleaning up existing subscriptions first.
   */
  setup() {
    const provider = this.#options.collaborationProvider;
    if (!provider?.awareness) return;
    this.#cleanupSubscriptions();
    const handleAwarenessChange = () => {
      this.#remoteCursorDirty = true;
      this.scheduleUpdate();
    };
    provider.awareness.on("change", handleAwarenessChange);
    provider.awareness.on("update", handleAwarenessChange);
    this.#awarenessCleanup = () => {
      provider.awareness?.off("change", handleAwarenessChange);
      provider.awareness?.off("update", handleAwarenessChange);
    };
    const handleScroll = () => {
      if (this.#remoteCursorState.size > 0) {
        this.#remoteCursorDirty = true;
        this.scheduleUpdate();
      }
    };
    const debouncedHandleScroll = () => {
      if (this.#scrollTimeout !== void 0) {
        clearTimeout(this.#scrollTimeout);
      }
      this.#scrollTimeout = window.setTimeout(handleScroll, SCROLL_DEBOUNCE_MS);
    };
    this.#options.visibleHost.addEventListener("scroll", debouncedHandleScroll, { passive: true });
    this.#scrollCleanup = () => {
      if (this.#scrollTimeout !== void 0) {
        clearTimeout(this.#scrollTimeout);
        this.#scrollTimeout = void 0;
      }
      this.#options.visibleHost.removeEventListener("scroll", debouncedHandleScroll);
    };
    this.#isSetup = true;
    handleAwarenessChange();
  }
  /**
   * Clean up awareness and scroll subscriptions.
   */
  #cleanupSubscriptions() {
    if (this.#awarenessCleanup) {
      this.#awarenessCleanup();
      this.#awarenessCleanup = null;
    }
    if (this.#scrollCleanup) {
      this.#scrollCleanup();
      this.#scrollCleanup = null;
    }
  }
  /**
   * Mark the cursor state as dirty, requiring a re-render.
   */
  markDirty() {
    this.#remoteCursorDirty = true;
  }
  /**
   * Schedule a remote cursor update using microtask + throttle-based rendering.
   *
   * Uses queueMicrotask to defer cursor normalization until after all
   * synchronous code completes. This fixes a race condition where awareness events
   * fire before the ProseMirror state is updated with Yjs document changes.
   */
  scheduleUpdate() {
    if (this.#options.presence?.enabled === false) return;
    if (this.#remoteCursorUpdateScheduled) return;
    this.#remoteCursorUpdateScheduled = true;
    queueMicrotask(() => {
      if (!this.#remoteCursorUpdateScheduled) return;
      const now = performance.now();
      const elapsed = now - this.#lastRemoteCursorRenderTime;
      if (elapsed >= THROTTLE_MS) {
        if (this.#remoteCursorThrottleTimeout !== null) {
          clearTimeout(this.#remoteCursorThrottleTimeout);
          this.#remoteCursorThrottleTimeout = null;
        }
        this.#remoteCursorUpdateScheduled = false;
        this.#lastRemoteCursorRenderTime = now;
        this.#pendingUpdateCallback?.();
        return;
      }
      const remaining = THROTTLE_MS - elapsed;
      this.#remoteCursorThrottleTimeout = window.setTimeout(() => {
        this.#remoteCursorUpdateScheduled = false;
        this.#remoteCursorThrottleTimeout = null;
        this.#lastRemoteCursorRenderTime = performance.now();
        this.#pendingUpdateCallback?.();
      }, remaining);
    });
  }
  /** Callback to invoke when scheduled update fires */
  #pendingUpdateCallback = null;
  /**
   * Set the callback to invoke when a scheduled update fires.
   * This allows PresentationEditor to provide the update logic with current state.
   */
  setUpdateCallback(callback) {
    this.#pendingUpdateCallback = callback;
  }
  /**
   * Schedule a remote cursor re-render without re-normalizing awareness states.
   * Performance optimization: avoids expensive Yjs position conversions on layout changes.
   * Used when layout geometry changes but cursor positions haven't (e.g., zoom, scroll, reflow).
   */
  scheduleReRender() {
    if (this.#options.presence?.enabled === false) return;
    if (this.#remoteCursorUpdateScheduled) return;
    this.#remoteCursorUpdateScheduled = true;
    const win = this.#options.visibleHost.ownerDocument?.defaultView ?? window;
    win.requestAnimationFrame(() => {
      this.#remoteCursorUpdateScheduled = false;
      this.#lastRemoteCursorRenderTime = performance.now();
      this.#pendingReRenderCallback?.();
    });
  }
  /** Callback to invoke when scheduled re-render fires */
  #pendingReRenderCallback = null;
  /**
   * Set the callback to invoke when a scheduled re-render fires.
   */
  setReRenderCallback(callback) {
    this.#pendingReRenderCallback = callback;
  }
  /**
   * Update remote cursor state by normalizing awareness states and rendering.
   * Call this when awareness state has changed.
   */
  update(editorState, deps) {
    if (this.#options.presence?.enabled === false) {
      this.#clearState();
      return;
    }
    if (!this.#remoteCursorDirty) return;
    this.#remoteCursorDirty = false;
    const startTime = performance.now();
    this.#remoteCursorState = normalizeAwarenessStates({
      provider: this.#options.collaborationProvider ?? null,
      editorState,
      previousState: this.#remoteCursorState,
      fallbackColors: this.#options.fallbackColors,
      staleTimeoutMs: this.#options.presence?.staleTimeout ?? DEFAULT_STALE_TIMEOUT_MS
    });
    this.render(deps);
    if (this.#onCursorsUpdate) {
      this.#onCursorsUpdate(Array.from(this.#remoteCursorState.values()));
    }
    if (this.#onTelemetry) {
      const renderTime = performance.now() - startTime;
      const maxVisible = this.#options.presence?.maxVisible ?? 20;
      const visibleCount = Math.min(this.#remoteCursorState.size, maxVisible);
      this.#onTelemetry({
        collaboratorCount: this.#remoteCursorState.size,
        visibleCount,
        renderTimeMs: renderTime
      });
    }
  }
  /**
   * Render remote cursors from existing state without normalization.
   * Use this when only layout geometry has changed, not cursor positions.
   */
  render(deps) {
    const { layout, blocks, measures } = deps;
    if (!layout || !blocks || !measures) {
      return;
    }
    const doc2 = this.#options.visibleHost.ownerDocument ?? document;
    renderRemoteCursors({
      layout,
      blocks,
      measures,
      pageGeometryHelper: deps.pageGeometryHelper,
      presence: this.#options.presence,
      remoteCursorState: this.#remoteCursorState,
      remoteCursorElements: this.#remoteCursorElements,
      remoteCursorOverlay: this.#options.remoteCursorOverlay,
      doc: doc2,
      computeCaretLayoutRect: deps.computeCaretLayoutRect,
      convertPageLocalToOverlayCoords: deps.convertPageLocalToOverlayCoords,
      fallbackColors: this.#options.fallbackColors,
      cursorStyles: this.#options.cursorStyles,
      maxSelectionRectsPerUser: this.#options.maxSelectionRectsPerUser,
      defaultPageHeight: this.#options.defaultPageHeight,
      fallbackPageHeight: deps.pageHeight
    });
  }
  /**
   * Update local cursor position in awareness.
   *
   * CRITICAL FIX: The y-prosemirror cursor plugin only updates awareness when
   * view.hasFocus() returns true. In PresentationEditor, the hidden PM EditorView
   * may not have DOM focus. This method bypasses the focus check and manually
   * updates awareness with the current selection position.
   */
  updateLocalCursor(editorState) {
    const provider = this.#options.collaborationProvider;
    if (!provider?.awareness) return;
    if (typeof provider.awareness.setLocalStateField !== "function") {
      return;
    }
    if (!editorState) return;
    const ystate = ySyncPluginKey.getState(editorState);
    if (!ystate?.binding?.mapping) return;
    const { selection } = editorState;
    const { anchor, head } = selection;
    try {
      const relAnchor = absolutePositionToRelativePosition(anchor, ystate.type, ystate.binding.mapping);
      const relHead = absolutePositionToRelativePosition(head, ystate.type, ystate.binding.mapping);
      if (relAnchor && relHead) {
        const cursorData = {
          anchor: relAnchor,
          head: relHead
        };
        provider.awareness.setLocalStateField("cursor", cursorData);
      }
    } catch {
    }
  }
  /**
   * Clear all cursor state and DOM elements.
   */
  #clearState() {
    this.#remoteCursorState.clear();
    this.#remoteCursorElements.clear();
    if (this.#options.remoteCursorOverlay) {
      this.#options.remoteCursorOverlay.innerHTML = "";
    }
  }
  /**
   * Update presence options at runtime.
   */
  updatePresenceOptions(presence) {
    this.#options.presence = presence;
  }
  /**
   * Check if there are any remote cursors to render.
   */
  hasRemoteCursors() {
    return this.#remoteCursorState.size > 0;
  }
  /**
   * Clean up all resources.
   * Call this when destroying the PresentationEditor.
   */
  destroy() {
    if (this.#remoteCursorThrottleTimeout !== null) {
      clearTimeout(this.#remoteCursorThrottleTimeout);
      this.#remoteCursorThrottleTimeout = null;
    }
    this.#cleanupSubscriptions();
    this.#remoteCursorState.clear();
    this.#remoteCursorElements.clear();
    this.#pendingUpdateCallback = null;
    this.#pendingReRenderCallback = null;
    this.#onTelemetry = null;
    this.#onCursorsUpdate = null;
    this.#isSetup = false;
  }
}
const WORD_CHARACTER_REGEX = /[\p{L}\p{N}'\u2018\u2019_~-]/u;
function isWordCharacter(char) {
  if (!char) {
    return false;
  }
  return WORD_CHARACTER_REGEX.test(char);
}
function calculateExtendedSelection(blocks, anchor, head, mode) {
  if (mode === "word") {
    const anchorBounds = findWordBoundaries(blocks, anchor);
    const headBounds = findWordBoundaries(blocks, head);
    if (anchorBounds && headBounds) {
      if (head >= anchor) {
        return { selAnchor: anchorBounds.from, selHead: headBounds.to };
      } else {
        return { selAnchor: anchorBounds.to, selHead: headBounds.from };
      }
    }
  } else if (mode === "para") {
    const anchorBounds = findParagraphBoundaries(blocks, anchor);
    const headBounds = findParagraphBoundaries(blocks, head);
    if (anchorBounds && headBounds) {
      if (head >= anchor) {
        return { selAnchor: anchorBounds.from, selHead: headBounds.to };
      } else {
        return { selAnchor: anchorBounds.to, selHead: headBounds.from };
      }
    }
  }
  return { selAnchor: anchor, selHead: head };
}
function registerPointerClick(event, previous, options) {
  const time2 = event.timeStamp ?? performance.now();
  const timeDelta = time2 - previous.lastClickTime;
  const withinTime = timeDelta <= options.timeThresholdMs;
  const distanceX = Math.abs(event.clientX - previous.lastClickPosition.x);
  const distanceY = Math.abs(event.clientY - previous.lastClickPosition.y);
  const withinDistance = distanceX <= options.distanceThresholdPx && distanceY <= options.distanceThresholdPx;
  const clickCount = withinTime && withinDistance ? Math.min(previous.clickCount + 1, options.maxClickCount) : 1;
  return {
    clickCount,
    lastClickTime: time2,
    lastClickPosition: { x: event.clientX, y: event.clientY }
  };
}
function getFirstTextPosition(doc2) {
  if (!doc2 || !doc2.content) {
    return 1;
  }
  let validPos = 1;
  doc2.nodesBetween(0, doc2.content.size, (node, pos) => {
    if (node.isTextblock) {
      validPos = pos + 1;
      return false;
    }
    return true;
  });
  return validPos;
}
function computeWordSelectionRangeAt(state, pos) {
  if (!state?.doc) {
    return null;
  }
  if (pos < 0 || pos > state.doc.content.size) {
    return null;
  }
  const textblockPos = findNearestTextblockResolvedPos(state.doc, pos);
  if (!textblockPos) {
    return null;
  }
  const parentStart = textblockPos.start();
  const parentEnd = textblockPos.end();
  const sampleEnd = Math.min(pos + 1, parentEnd);
  const charAtPos = state.doc.textBetween(pos, sampleEnd, "\0", "\0");
  if (!isWordCharacter(charAtPos)) {
    return null;
  }
  let startPos = pos;
  while (startPos > parentStart) {
    const prevChar = state.doc.textBetween(startPos - 1, startPos, "\0", "\0");
    if (!isWordCharacter(prevChar)) {
      break;
    }
    startPos -= 1;
  }
  let endPos = pos;
  while (endPos < parentEnd) {
    const nextChar = state.doc.textBetween(endPos, endPos + 1, "\0", "\0");
    if (!isWordCharacter(nextChar)) {
      break;
    }
    endPos += 1;
  }
  if (startPos === endPos) {
    return null;
  }
  return { from: startPos, to: endPos };
}
function computeParagraphSelectionRangeAt(state, pos) {
  if (!state?.doc) {
    return null;
  }
  const textblockPos = findNearestTextblockResolvedPos(state.doc, pos);
  if (!textblockPos) {
    return null;
  }
  return { from: textblockPos.start(), to: textblockPos.end() };
}
function findNearestTextblockResolvedPos(doc2, pos) {
  const $pos = doc2.resolve(pos);
  let textblockPos = $pos;
  while (textblockPos.depth > 0) {
    if (textblockPos.parent?.isTextblock) {
      break;
    }
    if (!textblockPos.parent || textblockPos.depth === 0) {
      break;
    }
    const beforePos = textblockPos.before();
    if (beforePos < 0 || beforePos > doc2.content.size) {
      return null;
    }
    textblockPos = doc2.resolve(beforePos);
  }
  if (!textblockPos.parent?.isTextblock) {
    return null;
  }
  return textblockPos;
}
function getCellPosFromTableHit(tableHit, doc2, blocks) {
  if (!tableHit || !tableHit.block || typeof tableHit.block.id !== "string") {
    console.warn("[getCellPosFromTableHit] Invalid tableHit input:", tableHit);
    return null;
  }
  if (typeof tableHit.cellRowIndex !== "number" || typeof tableHit.cellColIndex !== "number" || tableHit.cellRowIndex < 0 || tableHit.cellColIndex < 0) {
    console.warn("[getCellPosFromTableHit] Invalid cell indices:", {
      row: tableHit.cellRowIndex,
      col: tableHit.cellColIndex
    });
    return null;
  }
  if (!doc2) return null;
  const tableBlocks = blocks.filter((b2) => b2.kind === "table");
  const targetTableIndex = tableBlocks.findIndex((b2) => b2.id === tableHit.block.id);
  if (targetTableIndex === -1) return null;
  let tablePos = null;
  let currentTableIndex = 0;
  try {
    doc2.descendants((node, pos) => {
      if (node.type.name === "table") {
        if (currentTableIndex === targetTableIndex) {
          tablePos = pos;
          return false;
        }
        currentTableIndex++;
      }
      return true;
    });
  } catch (error) {
    console.error("[getCellPosFromTableHit] Error during document traversal:", error);
    return null;
  }
  if (tablePos === null) return null;
  const tableNode = doc2.nodeAt(tablePos);
  if (!tableNode || tableNode.type.name !== "table") return null;
  const targetRowIndex = tableHit.cellRowIndex;
  const targetColIndex = tableHit.cellColIndex;
  if (targetRowIndex >= tableNode.childCount) {
    console.warn("[getCellPosFromTableHit] Target row index out of bounds:", {
      targetRowIndex,
      tableChildCount: tableNode.childCount
    });
    return null;
  }
  let currentPos = tablePos + 1;
  for (let r2 = 0; r2 < tableNode.childCount && r2 <= targetRowIndex; r2++) {
    const row = tableNode.child(r2);
    if (r2 === targetRowIndex) {
      currentPos += 1;
      let logicalCol = 0;
      for (let cellIndex = 0; cellIndex < row.childCount; cellIndex++) {
        const cell = row.child(cellIndex);
        const rawColspan = cell.attrs?.colspan;
        const colspan = typeof rawColspan === "number" && Number.isFinite(rawColspan) && rawColspan > 0 ? rawColspan : 1;
        if (targetColIndex >= logicalCol && targetColIndex < logicalCol + colspan) {
          return currentPos;
        }
        currentPos += cell.nodeSize;
        logicalCol += colspan;
      }
      console.warn("[getCellPosFromTableHit] Target column not found in row:", {
        targetColIndex,
        logicalColReached: logicalCol,
        rowCellCount: row.childCount
      });
      return null;
    } else {
      currentPos += row.nodeSize;
    }
  }
  return null;
}
function getTablePosFromHit(tableHit, doc2, blocks) {
  if (!doc2) return null;
  const tableBlocks = blocks.filter((b2) => b2.kind === "table");
  const targetTableIndex = tableBlocks.findIndex((b2) => b2.id === tableHit.block.id);
  if (targetTableIndex === -1) return null;
  let tablePos = null;
  let currentTableIndex = 0;
  doc2.descendants((node, pos) => {
    if (node.type.name === "table") {
      if (currentTableIndex === targetTableIndex) {
        tablePos = pos;
        return false;
      }
      currentTableIndex++;
    }
    return true;
  });
  return tablePos;
}
function shouldUseCellSelection(currentTableHit, cellAnchor, cellDragMode) {
  if (!cellAnchor) return false;
  if (!currentTableHit) return cellDragMode === "active";
  if (currentTableHit.block.id !== cellAnchor.tableBlockId) {
    return cellDragMode === "active";
  }
  const sameCell = currentTableHit.cellRowIndex === cellAnchor.cellRowIndex && currentTableHit.cellColIndex === cellAnchor.cellColIndex;
  if (!sameCell) {
    return true;
  }
  return cellDragMode === "active";
}
function hitTestTable(layout, blocks, measures, normalizedX, normalizedY, configuredPageHeight, pageGapFallback, geometryHelper) {
  if (!layout) {
    return null;
  }
  let pageY = 0;
  let pageHit = null;
  if (geometryHelper) {
    const idx = geometryHelper.getPageIndexAtY(normalizedY) ?? geometryHelper.getNearestPageIndex(normalizedY);
    if (idx != null && layout.pages[idx]) {
      pageHit = { pageIndex: idx, page: layout.pages[idx] };
      pageY = geometryHelper.getPageTop(idx);
    }
  }
  if (!pageHit) {
    const gap = layout.pageGap ?? pageGapFallback;
    for (let i = 0; i < layout.pages.length; i++) {
      const page = layout.pages[i];
      const pageHeight = page.size?.h ?? configuredPageHeight;
      if (normalizedY >= pageY && normalizedY < pageY + pageHeight) {
        pageHit = { pageIndex: i, page };
        break;
      }
      pageY += pageHeight + gap;
    }
  }
  if (!pageHit) {
    return null;
  }
  const pageRelativeY = normalizedY - pageY;
  const point = { x: normalizedX, y: pageRelativeY };
  return hitTestTableFragment(pageHit, blocks, measures, point);
}
const MULTI_CLICK_TIME_THRESHOLD_MS = 400;
const MULTI_CLICK_DISTANCE_THRESHOLD_PX = 5;
class EditorInputManager {
  // Dependencies
  #deps = null;
  #callbacks = {};
  // Drag selection state
  #isDragging = false;
  #dragAnchor = null;
  #dragAnchorPageIndex = null;
  #dragExtensionMode = "char";
  #dragLastPointer = null;
  #dragLastRawHit = null;
  #dragUsedPageNotMountedFallback = false;
  // Click tracking for multi-click detection
  #clickCount = 0;
  #lastClickTime = 0;
  #lastClickPosition = null;
  // Cell selection state
  #cellAnchor = null;
  #cellDragMode = "none";
  // Margin click state
  #pendingMarginClick = null;
  // Image selection state
  #lastSelectedImageBlockId = null;
  // Focus suppression (for draggable annotations)
  #suppressFocusInFromDraggable = false;
  // Debug state
  #debugLastPointer = null;
  #debugLastHit = null;
  // Bound handlers for event listener cleanup
  #boundHandlePointerDown = null;
  #boundHandlePointerMove = null;
  #boundHandlePointerUp = null;
  #boundHandlePointerLeave = null;
  #boundHandleDoubleClick = null;
  #boundHandleClick = null;
  #boundHandleKeyDown = null;
  #boundHandleFocusIn = null;
  // ==========================================================================
  // Constructor
  // ==========================================================================
  constructor() {
  }
  // ==========================================================================
  // Setup Methods
  // ==========================================================================
  /**
   * Set dependencies from PresentationEditor.
   */
  setDependencies(deps) {
    this.#deps = deps;
  }
  /**
   * Set callbacks for events.
   */
  setCallbacks(callbacks2) {
    this.#callbacks = callbacks2;
  }
  /**
   * Bind event listeners to DOM elements.
   */
  bind() {
    if (!this.#deps) return;
    const viewportHost = this.#deps.getViewportHost();
    const visibleHost = this.#deps.getVisibleHost();
    viewportHost.ownerDocument ?? document;
    this.#boundHandlePointerDown = this.#handlePointerDown.bind(this);
    this.#boundHandlePointerMove = this.#handlePointerMove.bind(this);
    this.#boundHandlePointerUp = this.#handlePointerUp.bind(this);
    this.#boundHandlePointerLeave = this.#handlePointerLeave.bind(this);
    this.#boundHandleDoubleClick = this.#handleDoubleClick.bind(this);
    this.#boundHandleClick = this.#handleClick.bind(this);
    this.#boundHandleKeyDown = this.#handleKeyDown.bind(this);
    this.#boundHandleFocusIn = this.#handleFocusIn.bind(this);
    viewportHost.addEventListener("pointerdown", this.#boundHandlePointerDown);
    viewportHost.addEventListener("pointermove", this.#boundHandlePointerMove);
    viewportHost.addEventListener("pointerup", this.#boundHandlePointerUp);
    viewportHost.addEventListener("pointerleave", this.#boundHandlePointerLeave);
    viewportHost.addEventListener("dblclick", this.#boundHandleDoubleClick);
    viewportHost.addEventListener("click", this.#boundHandleClick);
    const container = viewportHost.closest(".presentation-editor");
    if (container) {
      container.addEventListener("keydown", this.#boundHandleKeyDown);
    }
    visibleHost.addEventListener("focusin", this.#boundHandleFocusIn);
  }
  /**
   * Unbind event listeners.
   */
  unbind() {
    if (!this.#deps) return;
    const viewportHost = this.#deps.getViewportHost();
    const visibleHost = this.#deps.getVisibleHost();
    if (this.#boundHandlePointerDown) {
      viewportHost.removeEventListener("pointerdown", this.#boundHandlePointerDown);
    }
    if (this.#boundHandlePointerMove) {
      viewportHost.removeEventListener("pointermove", this.#boundHandlePointerMove);
    }
    if (this.#boundHandlePointerUp) {
      viewportHost.removeEventListener("pointerup", this.#boundHandlePointerUp);
    }
    if (this.#boundHandlePointerLeave) {
      viewportHost.removeEventListener("pointerleave", this.#boundHandlePointerLeave);
    }
    if (this.#boundHandleDoubleClick) {
      viewportHost.removeEventListener("dblclick", this.#boundHandleDoubleClick);
    }
    if (this.#boundHandleClick) {
      viewportHost.removeEventListener("click", this.#boundHandleClick);
    }
    if (this.#boundHandleKeyDown) {
      const container = viewportHost.closest(".presentation-editor");
      if (container) {
        container.removeEventListener("keydown", this.#boundHandleKeyDown);
      }
    }
    if (this.#boundHandleFocusIn) {
      visibleHost.removeEventListener("focusin", this.#boundHandleFocusIn);
    }
    this.#boundHandlePointerDown = null;
    this.#boundHandlePointerMove = null;
    this.#boundHandlePointerUp = null;
    this.#boundHandlePointerLeave = null;
    this.#boundHandleDoubleClick = null;
    this.#boundHandleClick = null;
    this.#boundHandleKeyDown = null;
    this.#boundHandleFocusIn = null;
  }
  /**
   * Destroy the manager and clean up.
   */
  destroy() {
    this.unbind();
    this.#deps = null;
    this.#callbacks = {};
    this.#clearDragState();
    this.#clearCellAnchor();
  }
  // ==========================================================================
  // Public Getters
  // ==========================================================================
  /** Whether currently dragging */
  get isDragging() {
    return this.#isDragging;
  }
  /** Current drag anchor position */
  get dragAnchor() {
    return this.#dragAnchor;
  }
  /** Cell anchor state for table selection */
  get cellAnchor() {
    return this.#cellAnchor;
  }
  /** Debug last pointer position */
  get debugLastPointer() {
    return this.#debugLastPointer;
  }
  /** Debug last hit */
  get debugLastHit() {
    return this.#debugLastHit;
  }
  /** Last selected image block ID */
  get lastSelectedImageBlockId() {
    return this.#lastSelectedImageBlockId;
  }
  /** Drag anchor page index */
  get dragAnchorPageIndex() {
    return this.#dragAnchorPageIndex;
  }
  /** Get the page index from the last raw hit during drag */
  get dragLastHitPageIndex() {
    return this.#dragLastRawHit?.pageIndex ?? null;
  }
  /** Get the last raw hit during drag (for finalization) */
  get dragLastRawHit() {
    return this.#dragLastRawHit;
  }
  // ==========================================================================
  // Public Methods
  // ==========================================================================
  /**
   * Clear cell anchor (used when document changes).
   */
  clearCellAnchor() {
    this.#clearCellAnchor();
  }
  /**
   * Set suppress focus in flag (for draggable annotations).
   */
  setSuppressFocusInFromDraggable(value) {
    this.#suppressFocusInFromDraggable = value;
  }
  // ==========================================================================
  // Private Helper Methods
  // ==========================================================================
  #clearDragState() {
    this.#isDragging = false;
    this.#dragAnchor = null;
    this.#dragAnchorPageIndex = null;
    this.#dragExtensionMode = "char";
    this.#dragLastPointer = null;
    this.#dragLastRawHit = null;
    this.#dragUsedPageNotMountedFallback = false;
  }
  #clearCellAnchor() {
    this.#cellAnchor = null;
    this.#cellDragMode = "none";
  }
  #registerPointerClick(event) {
    const nextState = registerPointerClick(
      event,
      {
        clickCount: this.#clickCount,
        lastClickTime: this.#lastClickTime,
        lastClickPosition: this.#lastClickPosition ?? { x: 0, y: 0 }
      },
      {
        timeThresholdMs: MULTI_CLICK_TIME_THRESHOLD_MS,
        distanceThresholdPx: MULTI_CLICK_DISTANCE_THRESHOLD_PX,
        maxClickCount: 3
      }
    );
    this.#clickCount = nextState.clickCount;
    this.#lastClickTime = nextState.lastClickTime;
    this.#lastClickPosition = nextState.lastClickPosition;
    return nextState.clickCount;
  }
  #getFirstTextPosition() {
    const editor = this.#deps?.getEditor();
    return getFirstTextPosition(editor?.state?.doc ?? null);
  }
  #calculateExtendedSelection(anchor, head, mode) {
    const layoutState = this.#deps?.getLayoutState();
    return calculateExtendedSelection(layoutState?.blocks ?? [], anchor, head, mode);
  }
  #shouldUseCellSelection(currentTableHit) {
    return shouldUseCellSelection(currentTableHit, this.#cellAnchor, this.#cellDragMode);
  }
  #getCellPosFromTableHit(tableHit) {
    const editor = this.#deps?.getEditor();
    const layoutState = this.#deps?.getLayoutState();
    return getCellPosFromTableHit(tableHit, editor?.state?.doc ?? null, layoutState?.blocks ?? []);
  }
  #getTablePosFromHit(tableHit) {
    const editor = this.#deps?.getEditor();
    const layoutState = this.#deps?.getLayoutState();
    return getTablePosFromHit(tableHit, editor?.state?.doc ?? null, layoutState?.blocks ?? []);
  }
  #setCellAnchor(tableHit, tablePos) {
    const cellPos = this.#getCellPosFromTableHit(tableHit);
    if (cellPos === null) return;
    this.#cellAnchor = {
      tablePos,
      cellPos,
      cellRowIndex: tableHit.cellRowIndex,
      cellColIndex: tableHit.cellColIndex,
      tableBlockId: tableHit.block.id
    };
    this.#cellDragMode = "pending";
  }
  #hitTestTable(x, y2) {
    return this.#callbacks.hitTestTable?.(x, y2) ?? null;
  }
  // ==========================================================================
  // Event Handlers
  // ==========================================================================
  /**
   * Handle click events - specifically for link navigation prevention.
   *
   * Link handling is split between pointerdown and click:
   * - pointerdown: dispatches superdoc-link-click event (for popover/UI response)
   * - click: prevents default navigation (preventDefault only works on click, not pointerdown)
   *
   * This also handles keyboard activation (Enter/Space) which triggers click but not pointerdown.
   */
  #handleClick(event) {
    const target = event.target;
    const linkEl = target?.closest?.("a.superdoc-link");
    if (linkEl) {
      event.preventDefault();
      if (!event.pointerId && event.detail === 0) {
        this.#handleLinkClick(event, linkEl);
      }
    }
  }
  #handlePointerDown(event) {
    if (!this.#deps) return;
    if (event.button !== 0) return;
    if (event.ctrlKey && navigator.platform.includes("Mac")) return;
    this.#pendingMarginClick = null;
    const target = event.target;
    if (target?.closest?.(".superdoc-ruler-handle") != null) return;
    const linkEl = target?.closest?.("a.superdoc-link");
    if (linkEl) {
      this.#handleLinkClick(event, linkEl);
      return;
    }
    const annotationEl = target?.closest?.(".annotation[data-pm-start]");
    const isDraggableAnnotation = target?.closest?.('[data-draggable="true"]') != null;
    this.#suppressFocusInFromDraggable = isDraggableAnnotation;
    if (annotationEl) {
      this.#handleAnnotationClick(event, annotationEl);
      return;
    }
    const layoutState = this.#deps.getLayoutState();
    if (!layoutState.layout) {
      this.#handleClickWithoutLayout(event, isDraggableAnnotation);
      return;
    }
    const normalizedPoint = this.#callbacks.normalizeClientPoint?.(event.clientX, event.clientY);
    if (!normalizedPoint) return;
    const { x, y: y2 } = normalizedPoint;
    this.#debugLastPointer = { clientX: event.clientX, clientY: event.clientY, x, y: y2 };
    const sessionMode = this.#deps.getHeaderFooterSession()?.session?.mode ?? "body";
    if (sessionMode !== "body") {
      if (this.#handleClickInHeaderFooterMode(event, x, y2)) return;
    }
    const headerFooterRegion = this.#callbacks.hitTestHeaderFooterRegion?.(x, y2);
    if (headerFooterRegion) return;
    const viewportHost = this.#deps.getViewportHost();
    const pageGeometryHelper = this.#deps.getPageGeometryHelper();
    const rawHit = clickToPosition(
      layoutState.layout,
      layoutState.blocks,
      layoutState.measures,
      { x, y: y2 },
      viewportHost,
      event.clientX,
      event.clientY,
      pageGeometryHelper ?? void 0
    );
    const editor = this.#deps.getEditor();
    const doc2 = editor.state?.doc;
    const epochMapper = this.#deps.getEpochMapper();
    const mapped = rawHit && doc2 ? epochMapper.mapPosFromLayoutToCurrentDetailed(rawHit.pos, rawHit.layoutEpoch, 1) : null;
    if (mapped && !mapped.ok) {
      debugLog("warn", "pointerdown mapping failed", mapped);
    }
    const hit = rawHit && doc2 && mapped?.ok ? { ...rawHit, pos: Math.max(0, Math.min(mapped.pos, doc2.content.size)), layoutEpoch: mapped.toEpoch } : null;
    this.#debugLastHit = hit ? { source: "dom", pos: rawHit?.pos ?? null, layoutEpoch: rawHit?.layoutEpoch ?? null, mappedPos: hit.pos } : { source: "none", pos: rawHit?.pos ?? null, layoutEpoch: rawHit?.layoutEpoch ?? null, mappedPos: null };
    this.#callbacks.updateSelectionDebugHud?.();
    if (!isDraggableAnnotation) {
      event.preventDefault();
    }
    if (!rawHit) {
      this.#focusEditorAtFirstPosition();
      return;
    }
    if (!hit || !doc2) {
      this.#callbacks.setPendingDocChange?.();
      this.#callbacks.scheduleRerender?.();
      return;
    }
    const fragmentHit = getFragmentAtPosition(layoutState.layout, layoutState.blocks, layoutState.measures, rawHit.pos);
    const targetImg = event.target?.closest?.("img");
    if (this.#handleInlineImageClick(event, targetImg, rawHit, doc2, epochMapper)) return;
    if (this.#handleFragmentClick(event, fragmentHit, hit, doc2)) return;
    if (this.#lastSelectedImageBlockId) {
      this.#callbacks.emit?.("imageDeselected", { blockId: this.#lastSelectedImageBlockId });
      this.#lastSelectedImageBlockId = null;
    }
    if (event.shiftKey && editor.state.selection.$anchor) {
      this.#handleShiftClick(event, hit.pos);
      return;
    }
    const clickDepth = this.#registerPointerClick(event);
    if (clickDepth === 1) {
      this.#dragAnchor = hit.pos;
      this.#dragAnchorPageIndex = hit.pageIndex;
      this.#pendingMarginClick = this.#callbacks.computePendingMarginClick?.(event.pointerId, x, y2) ?? null;
      const tableHit = this.#hitTestTable(x, y2);
      if (tableHit) {
        const tablePos = this.#getTablePosFromHit(tableHit);
        if (tablePos !== null) {
          this.#setCellAnchor(tableHit, tablePos);
        }
      } else {
        this.#clearCellAnchor();
      }
    } else {
      this.#pendingMarginClick = null;
    }
    this.#dragLastPointer = { clientX: event.clientX, clientY: event.clientY, x, y: y2 };
    this.#dragLastRawHit = hit;
    this.#dragUsedPageNotMountedFallback = false;
    this.#isDragging = true;
    if (clickDepth >= 3) {
      this.#dragExtensionMode = "para";
    } else if (clickDepth === 2) {
      this.#dragExtensionMode = "word";
    } else {
      this.#dragExtensionMode = "char";
    }
    if (typeof viewportHost.setPointerCapture === "function") {
      viewportHost.setPointerCapture(event.pointerId);
    }
    let handledByDepth = false;
    const sessionModeForDepth = this.#deps.getHeaderFooterSession()?.session?.mode ?? "body";
    if (sessionModeForDepth === "body") {
      const selectionPos = clickDepth >= 2 && this.#dragAnchor !== null ? this.#dragAnchor : hit.pos;
      if (clickDepth >= 3) {
        handledByDepth = this.#callbacks.selectParagraphAt?.(selectionPos) ?? false;
      } else if (clickDepth === 2) {
        handledByDepth = this.#callbacks.selectWordAt?.(selectionPos) ?? false;
      }
    }
    if (!handledByDepth) {
      try {
        let nextSelection = superEditor_converter.TextSelection.create(doc2, hit.pos);
        if (!nextSelection.$from.parent.inlineContent) {
          nextSelection = superEditor_converter.Selection.near(doc2.resolve(hit.pos), 1);
        }
        const tr = editor.state.tr.setSelection(nextSelection);
        if (nextSelection instanceof superEditor_converter.TextSelection && nextSelection.empty && editor.state.storedMarks) {
          tr.setStoredMarks(editor.state.storedMarks);
        }
        editor.view?.dispatch(tr);
      } catch {
      }
    }
    this.#callbacks.scheduleSelectionUpdate?.();
    this.#focusEditor();
  }
  #handlePointerMove(event) {
    if (!this.#deps) return;
    const layoutState = this.#deps.getLayoutState();
    if (!layoutState.layout) return;
    const normalized = this.#callbacks.normalizeClientPoint?.(event.clientX, event.clientY);
    if (!normalized) return;
    if (this.#isDragging && this.#dragAnchor !== null && event.buttons & 1) {
      this.#handleDragSelection(event, normalized);
      return;
    }
    this.#handleHover(normalized);
  }
  #handlePointerUp(event) {
    if (!this.#deps) return;
    this.#suppressFocusInFromDraggable = false;
    if (!this.#isDragging) return;
    const viewportHost = this.#deps.getViewportHost();
    if (typeof viewportHost.hasPointerCapture === "function" && typeof viewportHost.releasePointerCapture === "function" && viewportHost.hasPointerCapture(event.pointerId)) {
      viewportHost.releasePointerCapture(event.pointerId);
    }
    const pendingMarginClick = this.#pendingMarginClick;
    this.#pendingMarginClick = null;
    const dragAnchor = this.#dragAnchor;
    const dragMode = this.#dragExtensionMode;
    const dragUsedFallback = this.#dragUsedPageNotMountedFallback;
    const dragPointer = this.#dragLastPointer;
    this.#isDragging = false;
    if (this.#cellDragMode !== "none") {
      this.#cellDragMode = "none";
    }
    if (!pendingMarginClick || pendingMarginClick.pointerId !== event.pointerId) {
      this.#callbacks.updateSelectionVirtualizationPins?.({ includeDragBuffer: false });
      if (dragUsedFallback && dragAnchor != null) {
        const pointer = dragPointer ?? { clientX: event.clientX, clientY: event.clientY };
        this.#callbacks.finalizeDragSelectionWithDom?.(pointer, dragAnchor, dragMode);
      }
      this.#callbacks.scheduleA11ySelectionAnnouncement?.({ immediate: true });
      this.#dragLastPointer = null;
      this.#dragLastRawHit = null;
      this.#dragUsedPageNotMountedFallback = false;
      return;
    }
    this.#handleMarginClickEnd(event, pendingMarginClick);
  }
  #handlePointerLeave() {
    this.#callbacks.clearHoverRegion?.();
  }
  #handleDoubleClick(event) {
    if (!this.#deps) return;
    if (event.button !== 0) return;
    const target = event.target;
    const annotationEl = target?.closest?.(".annotation[data-pm-start]");
    if (annotationEl) {
      event.preventDefault();
      event.stopPropagation();
      this.#handleAnnotationDoubleClick(event, annotationEl);
      return;
    }
    const layoutState = this.#deps.getLayoutState();
    if (!layoutState.layout) return;
    const viewportHost = this.#deps.getViewportHost();
    const visibleHost = this.#deps.getVisibleHost();
    const zoom = this.#deps.getZoom();
    const rect = viewportHost.getBoundingClientRect();
    const scrollLeft = visibleHost.scrollLeft ?? 0;
    const scrollTop = visibleHost.scrollTop ?? 0;
    const x = (event.clientX - rect.left + scrollLeft) / zoom;
    const y2 = (event.clientY - rect.top + scrollTop) / zoom;
    const region = this.#callbacks.hitTestHeaderFooterRegion?.(x, y2);
    if (region) {
      event.preventDefault();
      event.stopPropagation();
      const descriptor = this.#callbacks.resolveDescriptorForRegion?.(region);
      const hfManager = this.#deps.getHeaderFooterSession()?.manager;
      if (!descriptor && hfManager) {
        this.#callbacks.createDefaultHeaderFooter?.(region);
        hfManager.refresh();
      }
      this.#callbacks.activateHeaderFooterRegion?.(region);
    } else if ((this.#deps.getHeaderFooterSession()?.session?.mode ?? "body") !== "body") {
      this.#callbacks.exitHeaderFooterMode?.();
    }
  }
  #handleAnnotationDoubleClick(event, annotationEl) {
    const editor = this.#deps?.getEditor();
    if (!editor?.isEditable) return;
    const resolved = this.#callbacks.resolveFieldAnnotationSelectionFromElement?.(annotationEl);
    if (resolved) {
      try {
        const tr = editor.state.tr.setSelection(superEditor_converter.NodeSelection.create(editor.state.doc, resolved.pos));
        editor.view?.dispatch(tr);
      } catch {
      }
      editor.emit("fieldAnnotationDoubleClicked", {
        editor,
        node: resolved.node,
        nodePos: resolved.pos,
        event,
        currentTarget: annotationEl
      });
    }
  }
  #handleKeyDown(event) {
    if (!this.#deps) return;
    const sessionMode = this.#deps.getHeaderFooterSession()?.session?.mode ?? "body";
    if (event.key === "Escape" && sessionMode !== "body") {
      event.preventDefault();
      this.#callbacks.exitHeaderFooterMode?.();
      return;
    }
    if (event.ctrlKey && event.altKey && !event.shiftKey) {
      if (event.code === "KeyH") {
        event.preventDefault();
        this.#focusHeaderFooterShortcut("header");
      } else if (event.code === "KeyF") {
        event.preventDefault();
        this.#focusHeaderFooterShortcut("footer");
      }
    }
  }
  #handleFocusIn(event) {
    if (!this.#deps) return;
    if (this.#suppressFocusInFromDraggable) {
      this.#suppressFocusInFromDraggable = false;
      return;
    }
    try {
      this.#deps.getActiveEditor().view?.focus();
    } catch {
    }
  }
  // ==========================================================================
  // Handler Helpers
  // ==========================================================================
  #handleLinkClick(event, linkEl) {
    const href = linkEl.getAttribute("href") ?? "";
    const isAnchorLink = href.startsWith("#") && href.length > 1;
    const isTocLink = linkEl.closest(".superdoc-toc-entry") !== null;
    if (isAnchorLink && isTocLink) {
      event.preventDefault();
      event.stopPropagation();
      this.#callbacks.goToAnchor?.(href);
      return;
    }
    event.preventDefault();
    event.stopPropagation();
    const linkClickEvent = new CustomEvent("superdoc-link-click", {
      bubbles: true,
      composed: true,
      detail: {
        href,
        target: linkEl.getAttribute("target"),
        rel: linkEl.getAttribute("rel"),
        tooltip: linkEl.getAttribute("title"),
        element: linkEl,
        clientX: event.clientX,
        clientY: event.clientY
      }
    });
    linkEl.dispatchEvent(linkClickEvent);
  }
  #handleAnnotationClick(event, annotationEl) {
    const editor = this.#deps?.getEditor();
    if (!editor?.isEditable) return;
    const resolved = this.#callbacks.resolveFieldAnnotationSelectionFromElement?.(annotationEl);
    if (resolved) {
      try {
        const tr = editor.state.tr.setSelection(superEditor_converter.NodeSelection.create(editor.state.doc, resolved.pos));
        editor.view?.dispatch(tr);
      } catch {
      }
      editor.emit("fieldAnnotationClicked", {
        editor,
        node: resolved.node,
        nodePos: resolved.pos,
        event,
        currentTarget: annotationEl
      });
    }
  }
  #handleClickWithoutLayout(event, isDraggableAnnotation) {
    if (!isDraggableAnnotation) {
      event.preventDefault();
    }
    if (document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }
    this.#focusEditorAtFirstPosition();
  }
  #handleClickInHeaderFooterMode(event, x, y2) {
    const session = this.#deps?.getHeaderFooterSession();
    const activeEditorHost = session?.overlayManager?.getActiveEditorHost?.();
    const clickedInsideEditorHost = activeEditorHost && (activeEditorHost.contains(event.target) || activeEditorHost === event.target);
    if (clickedInsideEditorHost) {
      return true;
    }
    const headerFooterRegion = this.#callbacks.hitTestHeaderFooterRegion?.(x, y2);
    if (!headerFooterRegion) {
      this.#callbacks.exitHeaderFooterMode?.();
      return false;
    }
    return true;
  }
  #handleInlineImageClick(event, targetImg, rawHit, doc2, epochMapper) {
    if (!targetImg) return false;
    const imgPmStart = targetImg.dataset?.pmStart ? Number(targetImg.dataset.pmStart) : null;
    if (Number.isNaN(imgPmStart) || imgPmStart == null) return false;
    const imgLayoutEpochRaw = targetImg.dataset?.layoutEpoch;
    const imgLayoutEpoch = imgLayoutEpochRaw != null ? Number(imgLayoutEpochRaw) : NaN;
    const rawLayoutEpoch = Number.isFinite(rawHit.layoutEpoch) ? rawHit.layoutEpoch : NaN;
    const effectiveEpoch = Number.isFinite(imgLayoutEpoch) && Number.isFinite(rawLayoutEpoch) ? Math.max(imgLayoutEpoch, rawLayoutEpoch) : Number.isFinite(imgLayoutEpoch) ? imgLayoutEpoch : rawHit.layoutEpoch;
    const mappedImg = epochMapper.mapPosFromLayoutToCurrentDetailed(imgPmStart, effectiveEpoch, 1);
    if (!mappedImg.ok) {
      debugLog("warn", "inline image mapping failed", mappedImg);
      this.#callbacks.setPendingDocChange?.();
      this.#callbacks.scheduleRerender?.();
      return true;
    }
    const clampedImgPos = Math.max(0, Math.min(mappedImg.pos, doc2.content.size));
    if (clampedImgPos < 0 || clampedImgPos >= doc2.content.size) return true;
    const newSelectionId = `inline-${clampedImgPos}`;
    if (this.#lastSelectedImageBlockId && this.#lastSelectedImageBlockId !== newSelectionId) {
      this.#callbacks.emit?.("imageDeselected", { blockId: this.#lastSelectedImageBlockId });
    }
    const editor = this.#deps?.getEditor();
    try {
      const tr = editor.state.tr.setSelection(superEditor_converter.NodeSelection.create(doc2, clampedImgPos));
      editor.view?.dispatch(tr);
      const selector = `.superdoc-inline-image[data-pm-start="${imgPmStart}"]`;
      const viewportHost = this.#deps?.getViewportHost();
      const targetElement = viewportHost?.querySelector(selector);
      this.#callbacks.emit?.("imageSelected", {
        element: targetElement ?? targetImg,
        blockId: null,
        pmStart: clampedImgPos
      });
      this.#lastSelectedImageBlockId = newSelectionId;
    } catch (error) {
      if (vue.process$1.env.NODE_ENV === "development") {
        console.warn(`[EditorInputManager] Failed to create NodeSelection for inline image:`, error);
      }
    }
    this.#callbacks.focusEditorAfterImageSelection?.();
    return true;
  }
  #handleFragmentClick(event, fragmentHit, hit, doc2) {
    if (!fragmentHit) return false;
    if (fragmentHit.fragment.kind !== "image" && fragmentHit.fragment.kind !== "drawing") return false;
    const editor = this.#deps?.getEditor();
    try {
      const tr = editor.state.tr.setSelection(superEditor_converter.NodeSelection.create(doc2, hit.pos));
      editor.view?.dispatch(tr);
      if (this.#lastSelectedImageBlockId && this.#lastSelectedImageBlockId !== fragmentHit.fragment.blockId) {
        this.#callbacks.emit?.("imageDeselected", { blockId: this.#lastSelectedImageBlockId });
      }
      if (fragmentHit.fragment.kind === "image") {
        const viewportHost = this.#deps?.getViewportHost();
        const targetElement = viewportHost?.querySelector(
          `.superdoc-image-fragment[data-pm-start="${fragmentHit.fragment.pmStart}"]`
        );
        if (targetElement) {
          this.#callbacks.emit?.("imageSelected", {
            element: targetElement,
            blockId: fragmentHit.fragment.blockId,
            pmStart: fragmentHit.fragment.pmStart
          });
          this.#lastSelectedImageBlockId = fragmentHit.fragment.blockId;
        }
      }
    } catch (error) {
      if (vue.process$1.env.NODE_ENV === "development") {
        console.warn("[EditorInputManager] Failed to create NodeSelection for atomic fragment:", error);
      }
    }
    this.#callbacks.focusEditorAfterImageSelection?.();
    return true;
  }
  #handleShiftClick(event, headPos) {
    const editor = this.#deps?.getEditor();
    if (!editor) return;
    const anchor = editor.state.selection.anchor;
    const { selAnchor, selHead } = this.#calculateExtendedSelection(anchor, headPos, this.#dragExtensionMode);
    try {
      const tr = editor.state.tr.setSelection(superEditor_converter.TextSelection.create(editor.state.doc, selAnchor, selHead));
      editor.view?.dispatch(tr);
      this.#callbacks.scheduleSelectionUpdate?.();
    } catch (error) {
      console.warn("[SELECTION] Failed to extend selection on shift+click:", error);
    }
    this.#focusEditor();
  }
  #handleDragSelection(event, normalized) {
    if (!this.#deps) return;
    this.#pendingMarginClick = null;
    this.#dragLastPointer;
    this.#dragLastPointer = { clientX: event.clientX, clientY: event.clientY, x: normalized.x, y: normalized.y };
    const layoutState = this.#deps.getLayoutState();
    const viewportHost = this.#deps.getViewportHost();
    const pageGeometryHelper = this.#deps.getPageGeometryHelper();
    const rawHit = clickToPosition(
      layoutState.layout,
      layoutState.blocks,
      layoutState.measures,
      { x: normalized.x, y: normalized.y },
      viewportHost,
      event.clientX,
      event.clientY,
      pageGeometryHelper ?? void 0
    );
    if (!rawHit) return;
    const editor = this.#deps.getEditor();
    const doc2 = editor.state?.doc;
    if (!doc2) return;
    this.#dragLastRawHit = rawHit;
    const pageMounted = this.#deps.getPageElement(rawHit.pageIndex) != null;
    if (!pageMounted && this.#deps.isSelectionAwareVirtualizationEnabled()) {
      this.#dragUsedPageNotMountedFallback = true;
    }
    this.#callbacks.updateSelectionVirtualizationPins?.({ includeDragBuffer: true, extraPages: [rawHit.pageIndex] });
    const epochMapper = this.#deps.getEpochMapper();
    const mappedHead = epochMapper.mapPosFromLayoutToCurrentDetailed(rawHit.pos, rawHit.layoutEpoch, 1);
    if (!mappedHead.ok) {
      debugLog("warn", "drag mapping failed", mappedHead);
      return;
    }
    const hit = {
      ...rawHit,
      pos: Math.max(0, Math.min(mappedHead.pos, doc2.content.size)),
      layoutEpoch: mappedHead.toEpoch
    };
    this.#debugLastHit = {
      source: pageMounted ? "dom" : "geometry",
      pos: rawHit.pos,
      layoutEpoch: rawHit.layoutEpoch,
      mappedPos: hit.pos
    };
    this.#callbacks.updateSelectionDebugHud?.();
    const currentTableHit = this.#hitTestTable(normalized.x, normalized.y);
    const shouldUseCellSel = this.#shouldUseCellSelection(currentTableHit);
    if (shouldUseCellSel && this.#cellAnchor) {
      this.#handleCellDragSelection(currentTableHit, hit);
      return;
    }
    const anchor = this.#dragAnchor;
    const head = hit.pos;
    const { selAnchor, selHead } = this.#calculateExtendedSelection(anchor, head, this.#dragExtensionMode);
    try {
      const tr = editor.state.tr.setSelection(superEditor_converter.TextSelection.create(editor.state.doc, selAnchor, selHead));
      editor.view?.dispatch(tr);
      this.#callbacks.scheduleSelectionUpdate?.();
    } catch (error) {
      console.warn("[SELECTION] Failed to extend selection during drag:", error);
    }
  }
  #handleCellDragSelection(currentTableHit, hit) {
    const headCellPos = currentTableHit ? this.#getCellPosFromTableHit(currentTableHit) : null;
    if (headCellPos === null) return;
    if (this.#cellDragMode !== "active") {
      this.#cellDragMode = "active";
    }
    const editor = this.#deps?.getEditor();
    if (!editor) return;
    try {
      const doc2 = editor.state.doc;
      const anchorCellPos = this.#cellAnchor.cellPos;
      const clampedAnchor = Math.max(0, Math.min(anchorCellPos, doc2.content.size));
      const clampedHead = Math.max(0, Math.min(headCellPos, doc2.content.size));
      const cellSelection = CellSelection.create(doc2, clampedAnchor, clampedHead);
      const tr = editor.state.tr.setSelection(cellSelection);
      editor.view?.dispatch(tr);
      this.#callbacks.scheduleSelectionUpdate?.();
    } catch (error) {
      console.warn("[CELL-SELECTION] Failed to create CellSelection, falling back to TextSelection:", error);
      const anchor = this.#dragAnchor;
      const head = hit.pos;
      const { selAnchor, selHead } = this.#calculateExtendedSelection(anchor, head, this.#dragExtensionMode);
      try {
        const tr = editor.state.tr.setSelection(superEditor_converter.TextSelection.create(editor.state.doc, selAnchor, selHead));
        editor.view?.dispatch(tr);
        this.#callbacks.scheduleSelectionUpdate?.();
      } catch {
      }
    }
  }
  #handleHover(normalized) {
    if (!this.#deps) return;
    const sessionMode = this.#deps.getHeaderFooterSession()?.session?.mode ?? "body";
    if (sessionMode !== "body") {
      this.#callbacks.clearHoverRegion?.();
      return;
    }
    if (this.#deps.getDocumentMode() === "viewing") {
      this.#callbacks.clearHoverRegion?.();
      return;
    }
    const region = this.#callbacks.hitTestHeaderFooterRegion?.(normalized.x, normalized.y);
    if (!region) {
      this.#callbacks.clearHoverRegion?.();
      return;
    }
    const currentHover = this.#deps.getHeaderFooterSession()?.hoverRegion;
    if (currentHover && currentHover.kind === region.kind && currentHover.pageIndex === region.pageIndex && currentHover.sectionType === region.sectionType) {
      return;
    }
    this.#deps.getHeaderFooterSession()?.renderHover(region);
    this.#callbacks.renderHoverRegion?.(region);
  }
  #handleMarginClickEnd(event, pendingMarginClick) {
    const sessionMode = this.#deps?.getHeaderFooterSession()?.session?.mode ?? "body";
    if (sessionMode !== "body" || this.#deps?.isViewLocked()) {
      this.#clearDragPointerState();
      return;
    }
    const editor = this.#deps?.getEditor();
    const doc2 = editor?.state?.doc;
    if (!doc2) {
      this.#clearDragPointerState();
      return;
    }
    const epochMapper = this.#deps?.getEpochMapper();
    if (!epochMapper) {
      this.#clearDragPointerState();
      return;
    }
    if (pendingMarginClick.kind === "aboveFirstLine") {
      const pos = this.#getFirstTextPosition();
      try {
        const tr = editor.state.tr.setSelection(superEditor_converter.TextSelection.create(doc2, pos));
        editor.view?.dispatch(tr);
        this.#callbacks.scheduleSelectionUpdate?.();
      } catch {
      }
      this.#debugLastHit = { source: "margin", pos: null, layoutEpoch: null, mappedPos: pos };
      this.#callbacks.updateSelectionDebugHud?.();
      this.#clearDragPointerState();
      return;
    }
    if (pendingMarginClick.kind === "right") {
      const mappedEnd2 = epochMapper.mapPosFromLayoutToCurrentDetailed(
        pendingMarginClick.pmEnd,
        pendingMarginClick.layoutEpoch,
        1
      );
      if (!mappedEnd2.ok) {
        this.#callbacks.setPendingDocChange?.();
        this.#callbacks.scheduleRerender?.();
        this.#clearDragPointerState();
        return;
      }
      const caretPos = Math.max(0, Math.min(mappedEnd2.pos, doc2.content.size));
      try {
        const tr = editor.state.tr.setSelection(superEditor_converter.TextSelection.create(doc2, caretPos));
        editor.view?.dispatch(tr);
        this.#callbacks.scheduleSelectionUpdate?.();
      } catch {
      }
      this.#debugLastHit = {
        source: "margin",
        pos: pendingMarginClick.pmEnd,
        layoutEpoch: pendingMarginClick.layoutEpoch,
        mappedPos: caretPos
      };
      this.#callbacks.updateSelectionDebugHud?.();
      this.#clearDragPointerState();
      return;
    }
    const mappedStart = epochMapper.mapPosFromLayoutToCurrentDetailed(
      pendingMarginClick.pmStart,
      pendingMarginClick.layoutEpoch,
      1
    );
    const mappedEnd = epochMapper.mapPosFromLayoutToCurrentDetailed(
      pendingMarginClick.pmEnd,
      pendingMarginClick.layoutEpoch,
      -1
    );
    if (!mappedStart.ok || !mappedEnd.ok) {
      this.#callbacks.setPendingDocChange?.();
      this.#callbacks.scheduleRerender?.();
      this.#clearDragPointerState();
      return;
    }
    const selFrom = Math.max(0, Math.min(Math.min(mappedStart.pos, mappedEnd.pos), doc2.content.size));
    const selTo = Math.max(0, Math.min(Math.max(mappedStart.pos, mappedEnd.pos), doc2.content.size));
    try {
      const tr = editor.state.tr.setSelection(superEditor_converter.TextSelection.create(doc2, selFrom, selTo));
      editor.view?.dispatch(tr);
      this.#callbacks.scheduleSelectionUpdate?.();
    } catch {
    }
    this.#debugLastHit = {
      source: "margin",
      pos: pendingMarginClick.pmStart,
      layoutEpoch: pendingMarginClick.layoutEpoch,
      mappedPos: selFrom
    };
    this.#callbacks.updateSelectionDebugHud?.();
    this.#clearDragPointerState();
  }
  #clearDragPointerState() {
    this.#dragLastPointer = null;
    this.#dragLastRawHit = null;
    this.#dragUsedPageNotMountedFallback = false;
  }
  #focusHeaderFooterShortcut(kind) {
    const pageIndex = this.#callbacks.getCurrentPageIndex?.() ?? 0;
    const region = this.#callbacks.findRegionForPage?.(kind, pageIndex);
    if (!region) {
      this.#callbacks.emitHeaderFooterEditBlocked?.("missingRegion");
      return;
    }
    this.#callbacks.activateHeaderFooterRegion?.(region);
  }
  #focusEditorAtFirstPosition() {
    const editor = this.#deps?.getEditor();
    const editorDom = editor?.view?.dom;
    if (!editorDom) return;
    const validPos = this.#getFirstTextPosition();
    const doc2 = editor?.state?.doc;
    if (doc2) {
      try {
        const tr = editor.state.tr.setSelection(superEditor_converter.TextSelection.create(doc2, validPos));
        editor.view?.dispatch(tr);
      } catch {
      }
    }
    editorDom.focus();
    editor?.view?.focus();
    this.#callbacks.scheduleSelectionUpdate?.();
  }
  /**
   * Focuses the editor DOM element if it doesn't already have focus.
   *
   * This method performs a focus check before calling blur/focus to prevent
   * unnecessary focus cycles that can disrupt selection state during list
   * operations with tracked changes.
   */
  #focusEditor() {
    const editor = this.#deps?.getEditor();
    const view = editor?.view;
    const editorDom = view?.dom;
    if (!editorDom) return;
    const active = document.activeElement;
    const activeIsEditor = active === editorDom || !!active && editorDom.contains?.(active);
    const hasFocus = typeof view.hasFocus === "function" && view.hasFocus();
    if (activeIsEditor || hasFocus) {
      return;
    }
    if (active instanceof HTMLElement) {
      active.blur();
    }
    editorDom.focus();
    view?.focus();
  }
}
const createDefaultScheduler = () => {
  if (typeof window !== "undefined" && typeof window.requestAnimationFrame === "function") {
    return {
      requestAnimationFrame: (cb) => window.requestAnimationFrame(cb),
      cancelAnimationFrame: (handle) => window.cancelAnimationFrame(handle)
    };
  }
  const anyGlobal = globalThis;
  if (typeof anyGlobal.requestAnimationFrame === "function" && typeof anyGlobal.cancelAnimationFrame === "function") {
    return {
      requestAnimationFrame: (cb) => anyGlobal.requestAnimationFrame(cb),
      cancelAnimationFrame: (handle) => anyGlobal.cancelAnimationFrame(handle)
    };
  }
  return {
    requestAnimationFrame: (cb) => {
      const handle = anyGlobal.setTimeout?.(() => cb(Date.now()), 0);
      return handle;
    },
    cancelAnimationFrame: (handle) => {
      anyGlobal.clearTimeout?.(handle);
    }
  };
};
class SelectionSyncCoordinator extends EventEmitter {
  #docEpoch = 0;
  #layoutEpoch = 0;
  #layoutUpdating = false;
  #pending = false;
  #scheduled = false;
  #rafHandle = null;
  #scheduler;
  /**
   * Creates a new SelectionSyncCoordinator.
   *
   * @param options - Configuration options
   * @param options.scheduler - Custom scheduler for animation frames (useful for testing), defaults to platform scheduler
   */
  constructor(options) {
    super();
    this.#scheduler = options?.scheduler ?? createDefaultScheduler();
  }
  /**
   * Gets the current document epoch.
   *
   * @returns The document epoch (increments on each document-changing transaction)
   */
  getDocEpoch() {
    return this.#docEpoch;
  }
  /**
   * Gets the current layout epoch.
   *
   * @returns The epoch of the document version currently painted in the DOM
   */
  getLayoutEpoch() {
    return this.#layoutEpoch;
  }
  /**
   * Checks if a layout update is currently in progress.
   *
   * @returns True if between onLayoutStart() and onLayoutComplete(), false otherwise
   */
  isLayoutUpdating() {
    return this.#layoutUpdating;
  }
  /**
   * Updates the document epoch and triggers conditional rendering.
   *
   * @param epoch - The new document epoch (must be finite and non-negative)
   *
   * @remarks
   * When the document epoch changes:
   * 1. Any scheduled render is cancelled (layout will be out of sync)
   * 2. If layout has already caught up, rendering is rescheduled
   *
   * Calling with the same epoch as the current value is a no-op.
   * Invalid epoch values are silently ignored.
   */
  setDocEpoch(epoch) {
    if (!Number.isFinite(epoch) || epoch < 0) return;
    if (epoch === this.#docEpoch) return;
    this.#docEpoch = epoch;
    this.#cancelScheduledRender();
    this.#maybeSchedule();
  }
  /**
   * Notifies the coordinator that layout computation has started.
   *
   * @remarks
   * Marks the layout as updating and cancels any scheduled renders, since the DOM
   * is about to change and current position data will be stale.
   *
   * Safe to call multiple times (e.g., if layouts overlap) - subsequent calls are ignored
   * until onLayoutComplete() is called.
   */
  onLayoutStart() {
    if (this.#layoutUpdating) return;
    this.#layoutUpdating = true;
    this.#cancelScheduledRender();
  }
  /**
   * Notifies the coordinator that layout painting has completed.
   *
   * @param layoutEpoch - The document epoch that was just painted to the DOM
   *
   * @remarks
   * Marks the layout as no longer updating, records the new layout epoch, and attempts
   * to schedule rendering if conditions are now safe.
   *
   * If the layoutEpoch is invalid (not a finite non-negative number), it is ignored and
   * the previous layoutEpoch value is retained.
   *
   * This method is the primary trigger for selection rendering - if there's a pending
   * render request and layoutEpoch >= docEpoch, a render event will be scheduled.
   */
  onLayoutComplete(layoutEpoch) {
    this.#layoutUpdating = false;
    if (Number.isFinite(layoutEpoch) && layoutEpoch >= 0) {
      this.#layoutEpoch = layoutEpoch;
    }
    this.#maybeSchedule();
  }
  /**
   * Notifies the coordinator that layout was aborted without completing.
   *
   * @remarks
   * Marks the layout as no longer updating (without updating layoutEpoch) and attempts
   * to schedule rendering if conditions are safe.
   *
   * Use this when layout computation is cancelled or fails partway through.
   */
  onLayoutAbort() {
    this.#layoutUpdating = false;
    this.#maybeSchedule();
  }
  /**
   * Requests that selection rendering occur when conditions become safe.
   *
   * @param options - Rendering options
   * @param options.immediate - If true, attempts to render immediately (synchronously) if safe, defaults to false
   *
   * @remarks
   * Marks a render as pending and schedules it to occur on the next animation frame if
   * conditions are safe (layout not updating, layoutEpoch >= docEpoch).
   *
   * If options.immediate is true, also attempts a synchronous render before scheduling.
   * Use immediate rendering sparingly, as it can cause multiple renders per frame.
   *
   * Multiple calls are coalesced - only one render will occur per animation frame.
   */
  requestRender(options) {
    this.#pending = true;
    if (options?.immediate) {
      this.flushNow();
    }
    this.#maybeSchedule();
  }
  /**
   * Attempts to render selection immediately (synchronously) if conditions are safe.
   *
   * @remarks
   * If there's a pending render request and conditions are safe (layout not updating,
   * layoutEpoch >= docEpoch), this method:
   * 1. Cancels any scheduled asynchronous render
   * 2. Clears the pending flag
   * 3. Emits the 'render' event synchronously
   *
   * If no render is pending or conditions are not safe, this is a no-op.
   *
   * Use this for immediate selection updates in response to user actions (e.g., click
   * handlers) where waiting for the next animation frame would cause noticeable lag.
   */
  flushNow() {
    if (!this.#pending) return;
    if (!this.#isSafeToRender()) return;
    this.#cancelScheduledRender();
    this.#pending = false;
    this.emit("render", { docEpoch: this.#docEpoch, layoutEpoch: this.#layoutEpoch });
  }
  /**
   * Permanently tears down the coordinator, cancelling pending renders and removing all listeners.
   *
   * @remarks
   * After calling destroy(), this instance should not be used again. All scheduled renders
   * are cancelled and all event listeners are removed.
   *
   * Safe to call multiple times.
   */
  destroy() {
    this.#cancelScheduledRender();
    this.removeAllListeners();
  }
  #isSafeToRender() {
    return !this.#layoutUpdating && this.#layoutEpoch >= this.#docEpoch;
  }
  #maybeSchedule() {
    if (!this.#pending) return;
    if (!this.#isSafeToRender()) return;
    if (this.#scheduled) return;
    this.#scheduled = true;
    this.#rafHandle = this.#scheduler.requestAnimationFrame(() => {
      this.#scheduled = false;
      this.#rafHandle = null;
      if (!this.#pending) return;
      if (!this.#isSafeToRender()) return;
      this.#pending = false;
      this.emit("render", { docEpoch: this.#docEpoch, layoutEpoch: this.#layoutEpoch });
    });
  }
  #cancelScheduledRender() {
    if (this.#rafHandle != null) {
      try {
        this.#scheduler.cancelAnimationFrame(this.#rafHandle);
      } finally {
        this.#rafHandle = null;
      }
    }
    this.#scheduled = false;
  }
}
const uiSurfaces = /* @__PURE__ */ new WeakSet();
function isInRegisteredSurface(event) {
  const path = typeof event.composedPath === "function" ? event.composedPath() : [];
  if (path.length > 0) {
    for (const node2 of path) {
      if (uiSurfaces.has(node2)) return true;
      if (node2?.hasAttribute?.("data-editor-ui-surface")) return true;
    }
    return false;
  }
  let node = event.target;
  while (node) {
    if (uiSurfaces.has(node)) return true;
    if (node.hasAttribute?.("data-editor-ui-surface")) return true;
    node = node.parentElement;
  }
  return false;
}
const SLASH_MENU_HANDLED_FLAG = "__sdHandledBySlashMenu";
class PresentationInputBridge {
  #windowRoot;
  #layoutSurfaces;
  #getTargetDom;
  /** Callback that returns whether the editor is in an editable mode (editing/suggesting vs viewing) */
  #isEditable;
  #onTargetChanged;
  #listeners;
  #currentTarget = null;
  #destroyed = false;
  #useWindowFallback;
  /**
   * Creates a new PresentationInputBridge that forwards user input events from the visible layout
   * surface to the hidden editor DOM. This enables input handling when the actual editor is not
   * directly visible to the user.
   *
   * @param windowRoot - The window object containing the layout surface and editor target
   * @param layoutSurface - The visible HTML element that receives user input events (e.g., keyboard, mouse)
   * @param getTargetDom - Callback that returns the hidden editor's DOM element where events should be forwarded
   * @param isEditable - Callback that returns whether the editor is in an editable mode (editing/suggesting).
   *                     When this returns false (e.g., in viewing mode), keyboard, text, and composition
   *                     events will not be forwarded to prevent document modification.
   * @param onTargetChanged - Optional callback invoked when the target editor DOM element changes
   * @param options - Optional configuration including:
   *                  - useWindowFallback: Whether to attach window-level event listeners as fallback
   */
  constructor(windowRoot, layoutSurface, getTargetDom, isEditable, onTargetChanged, options) {
    this.#windowRoot = windowRoot;
    this.#layoutSurfaces = /* @__PURE__ */ new Set([layoutSurface]);
    this.#getTargetDom = getTargetDom;
    this.#isEditable = isEditable;
    this.#onTargetChanged = onTargetChanged;
    this.#listeners = [];
    this.#useWindowFallback = options?.useWindowFallback ?? false;
  }
  bind() {
    const keyboardTargets = this.#getListenerTargets();
    keyboardTargets.forEach((target) => {
      this.#addListener("keydown", this.#forwardKeyboardEvent, target);
      this.#addListener("keyup", this.#forwardKeyboardEvent, target);
    });
    const compositionTargets = this.#getListenerTargets();
    compositionTargets.forEach((target) => {
      this.#addListener("compositionstart", this.#forwardCompositionEvent, target);
      this.#addListener("compositionupdate", this.#forwardCompositionEvent, target);
      this.#addListener("compositionend", this.#forwardCompositionEvent, target);
    });
    const textTargets = this.#getListenerTargets();
    textTargets.forEach((target) => {
      this.#addListener("beforeinput", this.#forwardTextEvent, target);
      this.#addListener("input", this.#forwardTextEvent, target);
      this.#addListener("textInput", this.#forwardTextEvent, target);
    });
    const contextTargets = this.#getListenerTargets();
    contextTargets.forEach((target) => {
      this.#addListener("contextmenu", this.#forwardContextMenu, target);
    });
  }
  destroy() {
    this.#listeners.forEach(({ type, handler, target, useCapture }) => {
      target.removeEventListener(type, handler, useCapture);
    });
    this.#listeners = [];
    this.#currentTarget = null;
    this.#destroyed = true;
  }
  notifyTargetChanged() {
    if (this.#destroyed) {
      return;
    }
    const nextTarget = this.#getTargetDom();
    if (nextTarget === this.#currentTarget) {
      return;
    }
    if (this.#currentTarget) {
      let synthetic = null;
      if (typeof CompositionEvent !== "undefined") {
        synthetic = new CompositionEvent("compositionend", { data: "", bubbles: true, cancelable: true });
      } else {
        synthetic = new Event("compositionend", { bubbles: true, cancelable: true });
      }
      try {
        this.#currentTarget.dispatchEvent(synthetic);
      } catch (error) {
        if (vue.process$1.env.NODE_ENV === "development") {
          console.warn("[PresentationEditor] Failed to dispatch composition event:", error);
        }
      }
    }
    this.#currentTarget = nextTarget;
    this.#onTargetChanged?.(nextTarget ?? null);
  }
  #addListener(type, handler, target, useCapture = false) {
    const bound = handler.bind(this);
    this.#listeners.push({ type, handler: bound, target, useCapture });
    target.addEventListener(type, bound, useCapture);
  }
  #dispatchToTarget(originalEvent, synthetic) {
    if (this.#destroyed) return;
    const target = this.#getTargetDom();
    this.#currentTarget = target;
    if (!target) return;
    const isConnected = target.isConnected;
    if (isConnected === false) return;
    try {
      const canceled = !target.dispatchEvent(synthetic) || synthetic.defaultPrevented;
      if (canceled) {
        originalEvent.preventDefault();
      }
    } catch (error) {
      if (vue.process$1.env.NODE_ENV === "development") {
        console.warn("[PresentationEditor] Failed to dispatch event to target:", error);
      }
    }
  }
  /**
   * Forwards keyboard events to the hidden editor, skipping IME composition events
   * and plain character keys (which are handled by beforeinput instead).
   * Uses microtask deferral to allow other handlers to preventDefault first.
   *
   * @param event - The keyboard event from the layout surface
   */
  #forwardKeyboardEvent(event) {
    if (!this.#isEditable()) {
      return;
    }
    if (this.#shouldSkipSurface(event)) {
      return;
    }
    if (event.defaultPrevented) {
      return;
    }
    if (event.isComposing || event.keyCode === 229) {
      return;
    }
    if (this.#isPlainCharacterKey(event)) {
      return;
    }
    const synthetic = new KeyboardEvent(event.type, {
      key: event.key,
      code: event.code,
      location: event.location,
      repeat: event.repeat,
      ctrlKey: event.ctrlKey,
      shiftKey: event.shiftKey,
      altKey: event.altKey,
      metaKey: event.metaKey,
      bubbles: true,
      cancelable: true
    });
    this.#dispatchToTarget(event, synthetic);
  }
  /**
   * Forwards text input events (beforeinput) to the hidden editor.
   * Skips composition events and uses microtask deferral for cooperative handling.
   *
   * @param event - The input event from the layout surface
   */
  #forwardTextEvent(event) {
    if (!this.#isEditable()) {
      return;
    }
    if (this.#shouldSkipSurface(event)) {
      return;
    }
    if (event.defaultPrevented) {
      return;
    }
    if (event.isComposing) {
      return;
    }
    queueMicrotask(() => {
      if (event.defaultPrevented) {
        return;
      }
      let synthetic;
      if (typeof InputEvent !== "undefined") {
        synthetic = new InputEvent(event.type, {
          data: event.data ?? event.data ?? null,
          inputType: event.inputType ?? "insertText",
          dataTransfer: event.dataTransfer ?? null,
          isComposing: event.isComposing ?? false,
          bubbles: true,
          cancelable: true
        });
      } else {
        synthetic = new Event(event.type, { bubbles: true, cancelable: true });
      }
      this.#dispatchToTarget(event, synthetic);
    });
  }
  /**
   * Forwards composition events (compositionstart, compositionupdate, compositionend)
   * to the hidden editor for IME input handling.
   *
   * @param event - The composition event from the layout surface
   */
  #forwardCompositionEvent(event) {
    if (!this.#isEditable()) {
      return;
    }
    if (this.#shouldSkipSurface(event)) {
      return;
    }
    if (event.defaultPrevented) {
      return;
    }
    let synthetic;
    if (typeof CompositionEvent !== "undefined") {
      synthetic = new CompositionEvent(event.type, {
        data: event.data ?? "",
        bubbles: true,
        cancelable: true
      });
    } else {
      synthetic = new Event(event.type, { bubbles: true, cancelable: true });
    }
    this.#dispatchToTarget(event, synthetic);
  }
  /**
   * Forwards context menu events to the hidden editor.
   *
   * Checks if the SlashMenu component has already handled the event by inspecting
   * the SLASH_MENU_HANDLED_FLAG. If the flag is set, the event is not forwarded,
   * preventing duplicate context menu handling. This coordination allows SlashMenu
   * to intercept right-clicks in the capture phase and prevent the default editor
   * context menu from appearing.
   *
   * @param event - The context menu event from the layout surface
   */
  #forwardContextMenu(event) {
    const handledBySlashMenu = Boolean(event[SLASH_MENU_HANDLED_FLAG]);
    if (handledBySlashMenu) {
      return;
    }
    if (!this.#isEditable()) {
      return;
    }
    if (this.#shouldSkipSurface(event)) {
      return;
    }
    if (event.defaultPrevented) {
      return;
    }
    const synthetic = new MouseEvent("contextmenu", {
      bubbles: true,
      cancelable: true,
      clientX: event.clientX,
      clientY: event.clientY,
      screenX: event.screenX,
      screenY: event.screenY,
      button: event.button,
      buttons: event.buttons,
      ctrlKey: event.ctrlKey,
      shiftKey: event.shiftKey,
      altKey: event.altKey,
      metaKey: event.metaKey
    });
    this.#dispatchToTarget(event, synthetic);
  }
  #isEventOnActiveTarget(event) {
    const targetDom = this.#getTargetDom();
    if (!targetDom) return false;
    const origin = event.target;
    if (!origin) return false;
    const targetNode = targetDom;
    const containsFn = typeof targetNode.contains === "function" ? targetNode.contains : null;
    if (targetNode === origin) {
      return true;
    }
    if (containsFn) {
      return containsFn.call(targetNode, origin);
    }
    return false;
  }
  /**
   * Determines if an event originated from a UI surface that should be excluded
   * from keyboard forwarding (e.g., toolbars, dropdowns).
   *
   * Checks three conditions in order:
   * 1. Event is already on the active target (hidden editor) - skip to prevent loops
   * 2. Event is not in a layout surface - skip non-editor events
   * 3. Event is in a registered UI surface - skip toolbar/dropdown events
   *
   * @param event - The event to check
   * @returns true if the event should be skipped, false if it should be forwarded
   */
  #shouldSkipSurface(event) {
    if (this.#isEventOnActiveTarget(event)) {
      return true;
    }
    if (!this.#isInLayoutSurface(event)) {
      return true;
    }
    if (isInRegisteredSurface(event)) {
      return true;
    }
    return false;
  }
  /**
   * Checks if an event originated within a layout surface by walking the
   * event's composed path. Falls back to checking event.target directly
   * if composedPath is unavailable.
   *
   * @param event - The event to check
   * @returns true if event originated in a layout surface
   */
  #isInLayoutSurface(event) {
    const path = typeof event.composedPath === "function" ? event.composedPath() : [];
    if (path.length) {
      return path.some((node) => this.#layoutSurfaces.has(node));
    }
    const origin = event.target;
    return origin ? this.#layoutSurfaces.has(origin) : false;
  }
  /**
   * Returns the set of event targets to attach listeners to.
   * Includes registered layout surfaces and optionally the window for fallback.
   *
   * @returns Set of EventTargets for listener attachment
   */
  #getListenerTargets() {
    const targets = new Set(this.#layoutSurfaces);
    if (this.#useWindowFallback) {
      targets.add(this.#windowRoot);
    }
    return Array.from(targets);
  }
  /**
   * Determines if a keyboard event represents a plain character key without
   * modifiers. Plain character keys are filtered out because they should be
   * handled by the beforeinput event instead to avoid double-handling.
   *
   * Note: Shift is intentionally not considered a modifier here since
   * Shift+character produces a different character (e.g., uppercase) that
   * should still go through beforeinput.
   *
   * @param event - The keyboard event to check
   * @returns true if event is a single character without Ctrl/Meta/Alt modifiers
   */
  #isPlainCharacterKey(event) {
    return event.key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey;
  }
}
function getAtomNodeTypes(schema) {
  if (!schema) return [];
  const types = [];
  try {
    for (const name in schema.nodes) {
      if (name === "text") {
        continue;
      }
      const nodeType = schema.nodes[name];
      if (nodeType && (nodeType.isAtom || nodeType.isLeaf)) {
        types.push(name);
      }
    }
  } catch {
    return [];
  }
  return types;
}
const isObject$1 = (value) => typeof value === "object" && value !== null;
function buildPositionMapFromPmDoc(pmDoc, jsonDoc) {
  if (!pmDoc || !isObject$1(jsonDoc)) return null;
  const map3 = /* @__PURE__ */ new WeakMap();
  const walk = (pmNode, jsonNode, pos, isDoc) => {
    const jsonType = jsonNode.type;
    const expectedType = pmNode.isText ? "text" : pmNode.type?.name;
    if (!expectedType || jsonType !== expectedType) {
      return false;
    }
    const end2 = pos + (isDoc ? pmNode.content.size : pmNode.nodeSize);
    map3.set(jsonNode, { start: pos, end: end2 });
    if (pmNode.isLeaf) {
      return true;
    }
    const jsonContent = Array.isArray(jsonNode.content) ? jsonNode.content : [];
    if (pmNode.childCount !== jsonContent.length) {
      return false;
    }
    const base2 = pos + (isDoc ? 0 : 1);
    let ok2 = true;
    pmNode.forEach((child, offset2, index2) => {
      const jsonChild = jsonContent[index2];
      if (!isObject$1(jsonChild)) {
        ok2 = false;
        return;
      }
      if (!walk(child, jsonChild, base2 + offset2, false)) {
        ok2 = false;
      }
    });
    return ok2;
  };
  const ok = walk(pmDoc, jsonDoc, 0, true);
  if (!ok) return null;
  return map3;
}
function syncHiddenEditorA11yAttributes(pmDom, documentMode) {
  const element = pmDom;
  if (!(element instanceof HTMLElement)) return;
  if (!element.hasAttribute("tabindex")) {
    element.tabIndex = 0;
  }
  if (!element.hasAttribute("role")) {
    element.setAttribute("role", "textbox");
  }
  if (!element.hasAttribute("aria-multiline")) {
    element.setAttribute("aria-multiline", "true");
  }
  if (!element.hasAttribute("aria-label")) {
    element.setAttribute("aria-label", "Document content area");
  }
  element.setAttribute("aria-readonly", documentMode === "viewing" ? "true" : "false");
}
function scheduleA11ySelectionAnnouncement(deps, options) {
  if (!deps.ariaLiveRegion) return deps.currentTimeout;
  if (deps.sessionMode !== "body") return deps.currentTimeout;
  if (deps.isDragging && !options?.immediate) return deps.currentTimeout;
  if (deps.currentTimeout != null) {
    clearTimeout(deps.currentTimeout);
  }
  const win = deps.visibleHost?.ownerDocument?.defaultView ?? window;
  const testImmediate = Boolean(options?.immediate);
  const delayMs = testImmediate ? 0 : 150;
  return win.setTimeout(() => {
    deps.announceNow();
  }, delayMs);
}
function computeA11ySelectionAnnouncement(editorState) {
  const selection = editorState?.selection;
  if (!selection) return null;
  const fromRaw = selection.from;
  const toRaw = selection.to;
  if (typeof fromRaw !== "number" || typeof toRaw !== "number") {
    return null;
  }
  const from3 = fromRaw;
  const to = toRaw;
  let message;
  if (selection instanceof CellSelection) {
    message = "Table cells selected.";
  } else if (from3 === to) {
    message = "Cursor moved.";
  } else {
    const start2 = Math.max(0, Math.min(from3, to));
    const end2 = Math.max(0, Math.max(from3, to));
    const doc2 = editorState?.doc;
    let snippet = "";
    if (doc2 && typeof doc2.textBetween === "function") {
      try {
        const sampleEnd = Math.min(end2, start2 + 256);
        snippet = doc2.textBetween(start2, sampleEnd, " ", " ").replace(/\s+/g, " ").trim();
        if (sampleEnd < end2 && snippet.length > 0) {
          snippet = `${snippet}`;
        }
      } catch {
      }
    }
    message = snippet.length > 0 ? `Selected: ${snippet}` : "Selection updated.";
  }
  const key2 = `${from3}:${to}:${message}`;
  return { from: from3, to, message, key: key2 };
}
function computeSelectionVirtualizationPins(options) {
  const pageCount = options.layout.pages.length;
  if (pageCount <= 0) {
    return [];
  }
  const pinned = /* @__PURE__ */ new Set();
  const add = (pageIndex) => {
    if (!Number.isFinite(pageIndex)) return;
    const idx = Math.floor(pageIndex);
    if (idx < 0 || idx >= pageCount) return;
    pinned.add(idx);
    if (!options.includeDragBuffer) return;
    if (idx - 1 >= 0) pinned.add(idx - 1);
    if (idx + 1 < pageCount) pinned.add(idx + 1);
  };
  if (options.isDragging && options.dragAnchorPageIndex != null && options.dragLastHitPageIndex != null) {
    add(options.dragAnchorPageIndex);
    add(options.dragLastHitPageIndex);
  } else if (options.selection) {
    const anchorPos = options.selection.anchor ?? options.selection.from;
    const headPos = options.selection.head ?? options.selection.to;
    const anchorFrag = getFragmentAtPosition(options.layout, options.blocks, options.measures, anchorPos);
    const headFrag = getFragmentAtPosition(options.layout, options.blocks, options.measures, headPos);
    if (anchorFrag) add(anchorFrag.pageIndex);
    if (headFrag) add(headFrag.pageIndex);
    if (options.docSize != null) {
      if (!anchorFrag && anchorPos <= 1) add(0);
      if (!headFrag && headPos >= options.docSize) add(pageCount - 1);
    }
  }
  for (const extra of options.extraPages ?? []) {
    add(extra);
  }
  return Array.from(pinned).sort((a, b2) => a - b2);
}
function renderCellSelectionOverlay({
  selection,
  layout,
  localSelectionLayer,
  blocks,
  measures,
  cellAnchorTableBlockId,
  convertPageLocalToOverlayCoords: convertPageLocalToOverlayCoords2
}) {
  if (!selection || !layout || !layout.pages) {
    console.warn("[renderCellSelectionOverlay] Invalid input parameters");
    return;
  }
  const $anchorCell = selection.$anchorCell;
  if (!$anchorCell) {
    console.warn("[renderCellSelectionOverlay] No anchor cell in selection");
    return;
  }
  let tableDepth = $anchorCell.depth;
  while (tableDepth > 0 && $anchorCell.node(tableDepth).type.name !== "table") {
    tableDepth--;
  }
  if (tableDepth === 0 && $anchorCell.node(0).type.name !== "table") {
    console.warn("[renderCellSelectionOverlay] Could not find table node in selection hierarchy");
    return;
  }
  const tableNode = $anchorCell.node(tableDepth);
  const tableStart = $anchorCell.start(tableDepth) - 1;
  let tableBlock;
  if (cellAnchorTableBlockId) {
    tableBlock = blocks.find((block) => block.kind === "table" && block.id === cellAnchorTableBlockId);
  }
  if (!tableBlock) {
    const expectedBlockId = `${tableStart}-table`;
    tableBlock = blocks.find((block) => block.kind === "table" && block.id === expectedBlockId);
  }
  if (!tableBlock) {
    const tableBlocks = blocks.filter((block) => block.kind === "table");
    if (tableBlocks.length === 1) {
      tableBlock = tableBlocks[0];
    }
  }
  if (!tableBlock) {
    return;
  }
  const tableFragments = [];
  layout.pages.forEach((page, pageIndex) => {
    page.fragments.forEach((fragment) => {
      if (fragment.kind === "table" && fragment.blockId === tableBlock.id) {
        tableFragments.push({ fragment, pageIndex });
      }
    });
  });
  if (tableFragments.length === 0) {
    return;
  }
  let tableMap;
  try {
    tableMap = TableMap.get(tableNode);
  } catch (error) {
    console.error("[renderCellSelectionOverlay] TableMap.get failed:", error);
    return;
  }
  const selectedCells = [];
  selection.forEachCell((cellNode, cellPos) => {
    const cellOffset = cellPos - tableStart - 1;
    const mapIndex = tableMap.map.indexOf(cellOffset);
    if (mapIndex === -1) {
      return;
    }
    const row = Math.floor(mapIndex / tableMap.width);
    const col = mapIndex % tableMap.width;
    const rawColspan = cellNode.attrs?.colspan;
    const rawRowspan = cellNode.attrs?.rowspan;
    const colspan = typeof rawColspan === "number" && Number.isFinite(rawColspan) && rawColspan > 0 ? rawColspan : 1;
    const rowspan = typeof rawRowspan === "number" && Number.isFinite(rawRowspan) && rawRowspan > 0 ? rawRowspan : 1;
    selectedCells.push({ row, col, colspan, rowspan });
  });
  const tableBlockIndex = blocks.indexOf(tableBlock);
  const measureAtIndex = tableBlockIndex !== -1 ? measures[tableBlockIndex] : void 0;
  const tableMeasure = measureAtIndex?.kind === "table" ? measureAtIndex : void 0;
  const rowPositions = [];
  if (tableMeasure?.rows) {
    let currentY = 0;
    for (const rowMeasure of tableMeasure.rows) {
      rowPositions.push({ y: currentY, height: rowMeasure.height });
      currentY += rowMeasure.height;
    }
  }
  for (const { fragment, pageIndex } of tableFragments) {
    const { columnBoundaries } = fragment.metadata ?? {};
    if (!columnBoundaries) {
      continue;
    }
    for (const { row, col, colspan, rowspan } of selectedCells) {
      if (row < fragment.fromRow || row >= fragment.toRow) {
        continue;
      }
      const colBoundary = columnBoundaries.find((cb) => cb.index === col);
      if (!colBoundary) {
        continue;
      }
      let cellWidth = colBoundary.width;
      if (colspan > 1) {
        for (let c2 = 1; c2 < colspan; c2++) {
          const nextColBoundary = columnBoundaries.find((cb) => cb.index === col + c2);
          if (nextColBoundary) {
            cellWidth += nextColBoundary.width;
          }
        }
      }
      let rowY;
      let rowHeight;
      if (row >= 0 && row < rowPositions.length && rowPositions[row]) {
        const fragmentStartY = fragment.fromRow > 0 && fragment.fromRow < rowPositions.length && rowPositions[fragment.fromRow] ? rowPositions[fragment.fromRow].y : 0;
        rowY = rowPositions[row].y - fragmentStartY;
        rowHeight = rowPositions[row].height;
        if (rowspan > 1) {
          for (let r2 = 1; r2 < rowspan && row + r2 < rowPositions.length && rowPositions[row + r2]; r2++) {
            rowHeight += rowPositions[row + r2].height;
          }
        }
      } else {
        const rowCount = fragment.toRow - fragment.fromRow;
        const estimatedRowHeight = rowCount > 0 ? fragment.height / rowCount : 20;
        const fragmentRelativeRow = row - fragment.fromRow;
        rowY = fragmentRelativeRow * estimatedRowHeight;
        rowHeight = estimatedRowHeight * rowspan;
      }
      const cellX = fragment.x + colBoundary.x;
      const cellY = fragment.y + rowY;
      const coords = convertPageLocalToOverlayCoords2(pageIndex, cellX, cellY);
      if (!coords) {
        continue;
      }
      const highlight = localSelectionLayer.ownerDocument?.createElement("div");
      if (!highlight) {
        continue;
      }
      highlight.className = "presentation-editor__cell-selection-rect";
      highlight.style.position = "absolute";
      highlight.style.left = `${coords.x}px`;
      highlight.style.top = `${coords.y}px`;
      highlight.style.width = `${Math.max(1, cellWidth)}px`;
      highlight.style.height = `${Math.max(1, rowHeight)}px`;
      highlight.style.backgroundColor = "rgba(51, 132, 255, 0.35)";
      highlight.style.pointerEvents = "none";
      localSelectionLayer.appendChild(highlight);
    }
  }
}
function renderSelectionRects({
  localSelectionLayer,
  rects,
  pageHeight,
  pageGap,
  convertPageLocalToOverlayCoords: convertPageLocalToOverlayCoords2
}) {
  rects.forEach((rect) => {
    const pageLocalY = rect.y - rect.pageIndex * (pageHeight + pageGap);
    const coords = convertPageLocalToOverlayCoords2(rect.pageIndex, rect.x, pageLocalY);
    if (!coords) {
      return;
    }
    const highlight = localSelectionLayer.ownerDocument?.createElement("div");
    if (!highlight) {
      return;
    }
    highlight.className = "presentation-editor__selection-rect";
    highlight.style.position = "absolute";
    highlight.style.left = `${coords.x}px`;
    highlight.style.top = `${coords.y}px`;
    highlight.style.width = `${Math.max(1, rect.width)}px`;
    highlight.style.height = `${Math.max(1, rect.height)}px`;
    highlight.style.backgroundColor = "rgba(51, 132, 255, 0.35)";
    highlight.style.borderRadius = "2px";
    highlight.style.pointerEvents = "none";
    localSelectionLayer.appendChild(highlight);
  });
}
function renderCaretOverlay({
  localSelectionLayer,
  caretLayout,
  convertPageLocalToOverlayCoords: convertPageLocalToOverlayCoords2
}) {
  const coords = convertPageLocalToOverlayCoords2(caretLayout.pageIndex, caretLayout.x, caretLayout.y);
  if (!coords) {
    return;
  }
  const finalHeight = Math.max(1, caretLayout.height);
  const caretEl = localSelectionLayer.ownerDocument?.createElement("div");
  if (!caretEl) {
    return;
  }
  caretEl.className = "presentation-editor__selection-caret";
  caretEl.style.position = "absolute";
  caretEl.style.left = `${coords.x}px`;
  caretEl.style.top = `${coords.y}px`;
  caretEl.style.width = "2px";
  caretEl.style.height = `${finalHeight}px`;
  caretEl.style.backgroundColor = "#000000";
  caretEl.style.borderRadius = "1px";
  caretEl.style.pointerEvents = "none";
  localSelectionLayer.appendChild(caretEl);
}
function computeTableCaretLayoutRectFromDom({ viewportHost, visibleHost, zoom }, pos, _fragment, _tableBlock, _tableMeasure, pageIndex) {
  const lineEls = Array.from(viewportHost.querySelectorAll(".superdoc-line"));
  if (lineEls.length === 0) return null;
  for (const lineEl of lineEls) {
    const pmStart = Number(lineEl.dataset.pmStart ?? "NaN");
    const pmEnd = Number(lineEl.dataset.pmEnd ?? "NaN");
    if (!Number.isFinite(pmStart) || !Number.isFinite(pmEnd)) continue;
    if (pos < pmStart || pos > pmEnd) continue;
    const spanEls = Array.from(lineEl.querySelectorAll("span[data-pm-start]"));
    for (const spanEl of spanEls) {
      const spanStart = Number(spanEl.dataset.pmStart ?? "NaN");
      const spanEnd = Number(spanEl.dataset.pmEnd ?? "NaN");
      if (!Number.isFinite(spanStart) || !Number.isFinite(spanEnd)) continue;
      if (pos < spanStart || pos > spanEnd) continue;
      const textNode = spanEl.firstChild;
      if (!textNode || textNode.nodeType !== Node.TEXT_NODE) {
        const spanRect = spanEl.getBoundingClientRect();
        const viewportRect3 = viewportHost.getBoundingClientRect();
        return {
          pageIndex,
          x: (spanRect.left - viewportRect3.left + visibleHost.scrollLeft) / zoom,
          y: (spanRect.top - viewportRect3.top + visibleHost.scrollTop) / zoom,
          height: spanRect.height / zoom
        };
      }
      const text = textNode.textContent ?? "";
      const charOffset = Math.max(0, Math.min(text.length, pos - spanStart));
      const range = document.createRange();
      range.setStart(textNode, charOffset);
      range.setEnd(textNode, charOffset);
      const rangeRect = range.getBoundingClientRect();
      const viewportRect2 = viewportHost.getBoundingClientRect();
      const lineRect2 = lineEl.getBoundingClientRect();
      return {
        pageIndex,
        x: (rangeRect.left - viewportRect2.left + visibleHost.scrollLeft) / zoom,
        y: (lineRect2.top - viewportRect2.top + visibleHost.scrollTop) / zoom,
        height: lineRect2.height / zoom
      };
    }
    const lineRect = lineEl.getBoundingClientRect();
    const viewportRect = viewportHost.getBoundingClientRect();
    return {
      pageIndex,
      x: (lineRect.left - viewportRect.left + visibleHost.scrollLeft) / zoom,
      y: (lineRect.top - viewportRect.top + visibleHost.scrollTop) / zoom,
      height: lineRect.height / zoom
    };
  }
  return null;
}
function findLineContainingPos(block, measure, fromLine, toLine, pos) {
  if (measure.kind !== "paragraph" || block.kind !== "paragraph") return null;
  for (let lineIndex = fromLine; lineIndex < toLine; lineIndex += 1) {
    const line = measure.lines[lineIndex];
    if (!line) continue;
    const range = computeLinePmRange(block, line);
    if (range.pmStart == null || range.pmEnd == null) continue;
    if (pos >= range.pmStart && pos <= range.pmEnd) {
      return { line, index: lineIndex };
    }
  }
  return null;
}
function lineHeightBeforeIndex(lines, fromLine, targetIndex) {
  let offset2 = 0;
  for (let i = fromLine; i < targetIndex; i += 1) {
    offset2 += lines[i]?.lineHeight ?? 0;
  }
  return offset2;
}
function computeCaretLayoutRectGeometry({ layout, blocks, measures, painterHost, viewportHost, visibleHost, zoom }, pos, includeDomFallback = true) {
  if (!layout) return null;
  let effectivePos = pos;
  let hit = getFragmentAtPosition(layout, blocks, measures, pos);
  if (!hit) {
    const fallbackCandidates = [pos - 1, pos + 1, pos - 2, pos + 2].filter((candidate) => candidate >= 0);
    for (const candidate of fallbackCandidates) {
      const fallbackHit = getFragmentAtPosition(layout, blocks, measures, candidate);
      if (fallbackHit) {
        hit = fallbackHit;
        effectivePos = candidate;
        break;
      }
    }
    if (!hit) return null;
  }
  const block = hit.block;
  const measure = hit.measure;
  if (hit.fragment.kind === "table" && block?.kind === "table" && measure?.kind === "table") {
    return computeTableCaretLayoutRectFromDom(
      { viewportHost, visibleHost, zoom },
      effectivePos,
      hit.fragment,
      block,
      measure,
      hit.pageIndex
    );
  }
  if (!block || block.kind !== "paragraph" || measure?.kind !== "paragraph") return null;
  if (hit.fragment.kind !== "para") return null;
  const fragment = hit.fragment;
  const lineInfo = findLineContainingPos(block, measure, fragment.fromLine, fragment.toLine, effectivePos);
  if (!lineInfo) return null;
  const { line, index: index2 } = lineInfo;
  const range = computeLinePmRange(block, line);
  if (range.pmStart == null || range.pmEnd == null) return null;
  const pmOffset = pmPosToCharOffset(block, line, effectivePos);
  const markerWidth = fragment.markerWidth ?? measure.marker?.markerWidth ?? 0;
  const markerTextWidth = fragment.markerTextWidth ?? measure.marker?.markerTextWidth ?? void 0;
  const isFirstLine = index2 === fragment.fromLine;
  const isListItemFlag = isListItem(markerWidth, block);
  const wordLayout = getWordLayoutConfig(block);
  const indent = extractParagraphIndent(block.attrs?.indent);
  const indentAdjust = calculateTextStartIndent({
    isFirstLine,
    isListItem: isListItemFlag,
    markerWidth,
    markerTextWidth,
    paraIndentLeft: indent.left,
    firstLineIndent: indent.firstLine,
    hangingIndent: indent.hanging,
    wordLayout
  });
  const availableWidth = Math.max(0, fragment.width - (indentAdjust + indent.right));
  const charX = measureCharacterX(block, line, pmOffset, availableWidth);
  const localX = fragment.x + indentAdjust + charX;
  const lineOffset = lineHeightBeforeIndex(measure.lines, fragment.fromLine, index2);
  const localY = fragment.y + lineOffset;
  const result = {
    pageIndex: hit.pageIndex,
    x: localX,
    y: localY,
    height: line.lineHeight
  };
  const pageEl = painterHost?.querySelector(`.superdoc-page[data-page-index="${hit.pageIndex}"]`);
  const pageRect = pageEl?.getBoundingClientRect();
  let domCaretX = null;
  let domCaretY = null;
  const spanEls = pageEl?.querySelectorAll("span[data-pm-start][data-pm-end]");
  for (const spanEl of Array.from(spanEls ?? [])) {
    const pmStart = Number(spanEl.dataset.pmStart);
    const pmEnd = Number(spanEl.dataset.pmEnd);
    if (effectivePos >= pmStart && effectivePos <= pmEnd && spanEl.firstChild?.nodeType === Node.TEXT_NODE) {
      const textNode = spanEl.firstChild;
      const charIndex = Math.min(effectivePos - pmStart, textNode.length);
      const rangeObj = document.createRange();
      rangeObj.setStart(textNode, charIndex);
      rangeObj.setEnd(textNode, charIndex);
      if (typeof rangeObj.getBoundingClientRect !== "function") {
        break;
      }
      const rangeRect = rangeObj.getBoundingClientRect();
      if (pageRect) {
        domCaretX = (rangeRect.left - pageRect.left) / zoom;
        domCaretY = (rangeRect.top - pageRect.top) / zoom;
      }
      break;
    }
  }
  if (includeDomFallback && domCaretX != null && domCaretY != null) {
    return {
      pageIndex: hit.pageIndex,
      x: domCaretX,
      y: domCaretY,
      height: line.lineHeight
    };
  }
  return result;
}
function collectCommentPositions(doc2, options) {
  if (!doc2) {
    return {};
  }
  const pmPositions = {};
  doc2.descendants((node, pos) => {
    const marks = node.marks || [];
    for (const mark of marks) {
      const threadId = getThreadIdFromMark(mark, options);
      if (!threadId) continue;
      const nodeEnd = pos + node.nodeSize;
      if (!pmPositions[threadId]) {
        pmPositions[threadId] = { threadId, start: pos, end: nodeEnd };
      } else {
        pmPositions[threadId].start = Math.min(pmPositions[threadId].start, pos);
        pmPositions[threadId].end = Math.max(pmPositions[threadId].end, nodeEnd);
      }
    }
  });
  return pmPositions;
}
function getThreadIdFromMark(mark, options) {
  if (mark.type.name === options.commentMarkName) {
    return mark.attrs.commentId || mark.attrs.importedId;
  }
  if (options.trackChangeMarkNames.includes(mark.type.name)) {
    return mark.attrs.id;
  }
  return void 0;
}
function getCurrentSectionPageStyles(layout, pageIndex, converterPageStyles) {
  const PPI2 = 96;
  const page = layout?.pages?.[pageIndex];
  const converterStyles = converterPageStyles ?? {};
  const defaultMargins = converterStyles.pageMargins ?? { left: 1, right: 1, top: 1, bottom: 1 };
  const safeMargins = {
    left: typeof defaultMargins.left === "number" ? defaultMargins.left : 1,
    right: typeof defaultMargins.right === "number" ? defaultMargins.right : 1,
    top: typeof defaultMargins.top === "number" ? defaultMargins.top : 1,
    bottom: typeof defaultMargins.bottom === "number" ? defaultMargins.bottom : 1
  };
  if (!page) {
    return {
      pageSize: { width: 8.5, height: 11 },
      pageMargins: safeMargins,
      sectionIndex: 0,
      orientation: "portrait"
    };
  }
  const pageOrientation = page.orientation === "landscape" || page.orientation === "portrait" ? page.orientation : "portrait";
  const standardPortrait = { w: 8.5 * PPI2, h: 11 * PPI2 };
  const standardLandscape = { w: 11 * PPI2, h: 8.5 * PPI2 };
  const orientationDefault = pageOrientation === "landscape" ? standardLandscape : standardPortrait;
  const pageWidthPx = page.size?.w ?? orientationDefault.w;
  const pageHeightPx = page.size?.h ?? orientationDefault.h;
  const marginLeftPx = page.margins?.left ?? safeMargins.left * PPI2;
  const marginRightPx = page.margins?.right ?? safeMargins.right * PPI2;
  const marginTopPx = page.margins?.top ?? safeMargins.top * PPI2;
  const marginBottomPx = page.margins?.bottom ?? safeMargins.bottom * PPI2;
  return {
    pageSize: {
      width: pageWidthPx / PPI2,
      height: pageHeightPx / PPI2
    },
    pageMargins: {
      left: marginLeftPx / PPI2,
      right: marginRightPx / PPI2,
      top: marginTopPx / PPI2,
      bottom: marginBottomPx / PPI2
    },
    sectionIndex: page.sectionIndex ?? 0,
    orientation: pageOrientation
  };
}
function computeAnchorMap(bookmarks, layout, blocks) {
  const anchorMap = /* @__PURE__ */ new Map();
  const blockPmRanges = /* @__PURE__ */ new Map();
  const computeBlockRange = (blockId) => {
    if (blockPmRanges.has(blockId)) {
      const cached = blockPmRanges.get(blockId);
      return { pmStart: cached.pmStart, pmEnd: cached.pmEnd };
    }
    const block = blocks.find((b2) => b2.id === blockId);
    if (!block || block.kind !== "paragraph") {
      blockPmRanges.set(blockId, { pmStart: null, pmEnd: null, hasFragmentPositions: false });
      return { pmStart: null, pmEnd: null };
    }
    let pmStart = null;
    let pmEnd = null;
    for (const run of block.runs) {
      if (run.pmStart != null) {
        pmStart = pmStart == null ? run.pmStart : Math.min(pmStart, run.pmStart);
      }
      if (run.pmEnd != null) {
        pmEnd = pmEnd == null ? run.pmEnd : Math.max(pmEnd, run.pmEnd);
      }
    }
    blockPmRanges.set(blockId, { pmStart, pmEnd, hasFragmentPositions: false });
    return { pmStart, pmEnd };
  };
  bookmarks.forEach((pmPosition, bookmarkName) => {
    for (const page of layout.pages) {
      for (const fragment of page.fragments) {
        if (fragment.kind !== "para") continue;
        let fragStart = fragment.pmStart;
        let fragEnd = fragment.pmEnd;
        if (fragStart == null || fragEnd == null) {
          const range = computeBlockRange(fragment.blockId);
          if (range.pmStart != null && range.pmEnd != null) {
            fragStart = range.pmStart;
            fragEnd = range.pmEnd;
          }
        } else {
          const cached = blockPmRanges.get(fragment.blockId);
          blockPmRanges.set(fragment.blockId, {
            pmStart: cached?.pmStart ?? fragStart,
            pmEnd: cached?.pmEnd ?? fragEnd,
            hasFragmentPositions: true
          });
        }
        if (fragStart == null || fragEnd == null) continue;
        if (pmPosition >= fragStart && pmPosition < fragEnd) {
          anchorMap.set(bookmarkName, page.number);
          return;
        }
      }
    }
  });
  return anchorMap;
}
async function goToAnchor({
  anchor,
  layout,
  blocks,
  measures,
  bookmarks,
  pageGeometryHelper,
  painterHost,
  scrollPageIntoView,
  waitForPageMount,
  getActiveEditor,
  timeoutMs
}) {
  if (!anchor) return false;
  if (!layout) return false;
  const normalized = anchor.startsWith("#") ? anchor.slice(1) : anchor;
  if (!normalized) return false;
  const pmPos = bookmarks.get(normalized);
  if (pmPos == null) return false;
  const rects = selectionToRects(layout, blocks, measures, pmPos, pmPos + 1, pageGeometryHelper) ?? [];
  const rect = rects[0];
  let pageIndex = rect?.pageIndex ?? null;
  if (pageIndex == null) {
    let nextFragmentPage = null;
    let nextFragmentStart = null;
    for (const page of layout.pages) {
      for (const fragment of page.fragments) {
        if (fragment.kind !== "para") continue;
        const fragStart = fragment.pmStart;
        const fragEnd = fragment.pmEnd;
        if (fragStart == null || fragEnd == null) continue;
        if (pmPos >= fragStart && pmPos < fragEnd) {
          pageIndex = page.number - 1;
          break;
        }
        if (fragStart > pmPos && (nextFragmentStart === null || fragStart < nextFragmentStart)) {
          nextFragmentPage = page.number - 1;
          nextFragmentStart = fragStart;
        }
      }
      if (pageIndex != null) break;
    }
    if (pageIndex == null && nextFragmentPage != null) {
      pageIndex = nextFragmentPage;
    }
  }
  if (pageIndex == null) return false;
  scrollPageIntoView(pageIndex);
  await waitForPageMount(pageIndex, timeoutMs);
  const pageEl = painterHost.querySelector(`[data-page-index="${pageIndex}"]`);
  if (pageEl) {
    pageEl.scrollIntoView({ behavior: "instant", block: "start" });
  }
  const activeEditor = getActiveEditor();
  if (activeEditor?.commands?.setTextSelection) {
    activeEditor.commands.setTextSelection({ from: pmPos, to: pmPos });
  } else {
    console.warn(
      "[PresentationEditor] goToAnchor: Navigation succeeded but could not move caret (editor commands unavailable)"
    );
  }
  return true;
}
const INTERNAL_MIME_TYPE = "application/x-field-annotation";
const FIELD_ANNOTATION_DATA_TYPE = "fieldAnnotation";
function isValidFieldAnnotationAttributes(attrs) {
  if (!attrs || typeof attrs !== "object") return false;
  const a = attrs;
  return typeof a.fieldId === "string" && typeof a.fieldType === "string" && typeof a.displayLabel === "string" && typeof a.type === "string";
}
function parseIntSafe(value) {
  if (!value) return void 0;
  const parsed = parseInt(value, 10);
  return Number.isFinite(parsed) ? parsed : void 0;
}
function extractFieldAnnotationData(element) {
  const dataset = element.dataset;
  const attributes = {};
  for (const key2 in dataset) {
    const value = dataset[key2];
    if (value !== void 0) {
      attributes[key2] = value;
    }
  }
  return {
    fieldId: dataset.fieldId,
    fieldType: dataset.fieldType,
    variant: dataset.variant ?? dataset.type,
    displayLabel: dataset.displayLabel,
    pmStart: parseIntSafe(dataset.pmStart),
    pmEnd: parseIntSafe(dataset.pmEnd),
    attributes
  };
}
function hasFieldAnnotationData(event) {
  if (!event.dataTransfer) return false;
  const types = Array.from(event.dataTransfer.types ?? []);
  const lowerTypes = types.map((type) => type.toLowerCase());
  const hasFieldAnnotationType = lowerTypes.includes(INTERNAL_MIME_TYPE.toLowerCase()) || lowerTypes.includes(FIELD_ANNOTATION_DATA_TYPE.toLowerCase());
  if (hasFieldAnnotationType) return true;
  return Boolean(
    event.dataTransfer.getData(INTERNAL_MIME_TYPE) || event.dataTransfer.getData(FIELD_ANNOTATION_DATA_TYPE)
  );
}
function isInternalDrag(event) {
  return event.dataTransfer?.types?.includes(INTERNAL_MIME_TYPE) ?? false;
}
function extractDragData(event) {
  if (!event.dataTransfer) return null;
  let jsonData = event.dataTransfer.getData(INTERNAL_MIME_TYPE);
  if (!jsonData) {
    jsonData = event.dataTransfer.getData(FIELD_ANNOTATION_DATA_TYPE);
  }
  if (!jsonData) return null;
  try {
    const parsed = JSON.parse(jsonData);
    return parsed.sourceField ?? parsed.attributes ?? parsed;
  } catch {
    return null;
  }
}
class DragDropManager {
  #deps = null;
  #dragOverRaf = null;
  #pendingDragOver = null;
  // Bound handlers for cleanup
  #boundHandleDragStart = null;
  #boundHandleDragOver = null;
  #boundHandleDrop = null;
  #boundHandleDragEnd = null;
  #boundHandleDragLeave = null;
  #boundHandleWindowDragOver = null;
  #boundHandleWindowDrop = null;
  // ==========================================================================
  // Setup
  // ==========================================================================
  setDependencies(deps) {
    this.#deps = deps;
  }
  bind() {
    if (!this.#deps) return;
    const viewportHost = this.#deps.getViewportHost();
    const painterHost = this.#deps.getPainterHost();
    this.#boundHandleDragStart = this.#handleDragStart.bind(this);
    this.#boundHandleDragOver = this.#handleDragOver.bind(this);
    this.#boundHandleDrop = this.#handleDrop.bind(this);
    this.#boundHandleDragEnd = this.#handleDragEnd.bind(this);
    this.#boundHandleDragLeave = this.#handleDragLeave.bind(this);
    this.#boundHandleWindowDragOver = this.#handleWindowDragOver.bind(this);
    this.#boundHandleWindowDrop = this.#handleWindowDrop.bind(this);
    painterHost.addEventListener("dragstart", this.#boundHandleDragStart);
    painterHost.addEventListener("dragend", this.#boundHandleDragEnd);
    painterHost.addEventListener("dragleave", this.#boundHandleDragLeave);
    viewportHost.addEventListener("dragover", this.#boundHandleDragOver);
    viewportHost.addEventListener("drop", this.#boundHandleDrop);
    window.addEventListener("dragover", this.#boundHandleWindowDragOver, false);
    window.addEventListener("drop", this.#boundHandleWindowDrop, false);
  }
  unbind() {
    if (!this.#deps) return;
    const viewportHost = this.#deps.getViewportHost();
    const painterHost = this.#deps.getPainterHost();
    if (this.#boundHandleDragStart) {
      painterHost.removeEventListener("dragstart", this.#boundHandleDragStart);
    }
    if (this.#boundHandleDragEnd) {
      painterHost.removeEventListener("dragend", this.#boundHandleDragEnd);
    }
    if (this.#boundHandleDragLeave) {
      painterHost.removeEventListener("dragleave", this.#boundHandleDragLeave);
    }
    if (this.#boundHandleDragOver) {
      viewportHost.removeEventListener("dragover", this.#boundHandleDragOver);
    }
    if (this.#boundHandleDrop) {
      viewportHost.removeEventListener("drop", this.#boundHandleDrop);
    }
    if (this.#boundHandleWindowDragOver) {
      window.removeEventListener("dragover", this.#boundHandleWindowDragOver, false);
    }
    if (this.#boundHandleWindowDrop) {
      window.removeEventListener("drop", this.#boundHandleWindowDrop, false);
    }
    this.#boundHandleDragStart = null;
    this.#boundHandleDragOver = null;
    this.#boundHandleDrop = null;
    this.#boundHandleDragEnd = null;
    this.#boundHandleDragLeave = null;
    this.#boundHandleWindowDragOver = null;
    this.#boundHandleWindowDrop = null;
  }
  destroy() {
    this.#cancelPendingDragOverSelection();
    this.unbind();
    this.#deps = null;
  }
  // ==========================================================================
  // Event Handlers
  // ==========================================================================
  /**
   * Handle dragstart for internal field annotations.
   */
  #handleDragStart(event) {
    const target = event.target;
    if (!target?.dataset?.draggable || target.dataset.draggable !== "true") {
      return;
    }
    const data = extractFieldAnnotationData(target);
    if (event.dataTransfer) {
      const jsonData = JSON.stringify({
        attributes: data.attributes,
        sourceField: data
      });
      event.dataTransfer.setData(INTERNAL_MIME_TYPE, jsonData);
      event.dataTransfer.setData(FIELD_ANNOTATION_DATA_TYPE, jsonData);
      event.dataTransfer.setData("text/plain", data.displayLabel ?? "Field Annotation");
      event.dataTransfer.setDragImage(target, 0, 0);
      event.dataTransfer.effectAllowed = "move";
    }
  }
  /**
   * Handle dragover - update cursor position to show drop location.
   */
  #handleDragOver(event) {
    if (!this.#deps) return;
    if (!hasFieldAnnotationData(event)) return;
    const activeEditor = this.#deps.getActiveEditor();
    if (!activeEditor?.isEditable) return;
    event.preventDefault();
    if (event.dataTransfer) {
      event.dataTransfer.dropEffect = isInternalDrag(event) ? "move" : "copy";
    }
    this.#scheduleDragOverSelection(event.clientX, event.clientY);
  }
  #scheduleDragOverSelection(clientX, clientY) {
    if (!this.#deps) return;
    this.#pendingDragOver = { x: clientX, y: clientY };
    if (this.#dragOverRaf !== null) return;
    const win = this.#deps.getViewportHost()?.ownerDocument?.defaultView ?? window;
    this.#dragOverRaf = win.requestAnimationFrame(() => {
      this.#dragOverRaf = null;
      const pending = this.#pendingDragOver;
      this.#pendingDragOver = null;
      if (!pending || !this.#deps) return;
      this.#applyDragOverSelection(pending.x, pending.y);
    });
  }
  #cancelPendingDragOverSelection() {
    if (this.#dragOverRaf !== null) {
      const win = this.#deps?.getViewportHost()?.ownerDocument?.defaultView ?? window;
      win.cancelAnimationFrame(this.#dragOverRaf);
      this.#dragOverRaf = null;
    }
    this.#pendingDragOver = null;
  }
  #applyDragOverSelection(clientX, clientY) {
    if (!this.#deps) return;
    const activeEditor = this.#deps.getActiveEditor();
    if (!activeEditor?.isEditable) return;
    const hit = this.#deps.hitTest(clientX, clientY);
    const doc2 = activeEditor.state?.doc;
    if (!hit || !doc2) return;
    const pos = Math.min(Math.max(hit.pos, 1), doc2.content.size);
    const currentSelection = activeEditor.state.selection;
    if (currentSelection instanceof superEditor_converter.TextSelection && currentSelection.from === pos && currentSelection.to === pos) {
      return;
    }
    try {
      const tr = activeEditor.state.tr.setSelection(superEditor_converter.TextSelection.create(doc2, pos)).setMeta("addToHistory", false);
      activeEditor.view?.dispatch(tr);
      this.#deps.scheduleSelectionUpdate();
    } catch {
    }
  }
  /**
   * Handle drop - either move internal annotation or insert external one.
   */
  #handleDrop(event) {
    if (!this.#deps) return;
    if (!hasFieldAnnotationData(event)) return;
    event.preventDefault();
    event.stopPropagation();
    this.#cancelPendingDragOverSelection();
    const activeEditor = this.#deps.getActiveEditor();
    if (!activeEditor?.isEditable) return;
    const { state, view } = activeEditor;
    if (!state || !view) return;
    const hit = this.#deps.hitTest(event.clientX, event.clientY);
    const fallbackPos = state.selection?.from ?? state.doc?.content.size ?? null;
    const dropPos = hit?.pos ?? fallbackPos;
    if (dropPos == null) return;
    if (isInternalDrag(event)) {
      this.#handleInternalDrop(event, dropPos);
      return;
    }
    this.#handleExternalDrop(event, dropPos);
  }
  /**
   * Handle internal drop - move field annotation within document.
   */
  #handleInternalDrop(event, targetPos) {
    if (!this.#deps) return;
    const activeEditor = this.#deps.getActiveEditor();
    const { state, view } = activeEditor;
    if (!state || !view) return;
    const data = extractDragData(event);
    if (!data?.fieldId) return;
    const pmStart = data.pmStart;
    let sourceStart = null;
    let sourceEnd = null;
    let sourceNode = null;
    if (pmStart != null) {
      const nodeAt = state.doc.nodeAt(pmStart);
      if (nodeAt?.type?.name === "fieldAnnotation") {
        sourceStart = pmStart;
        sourceEnd = pmStart + nodeAt.nodeSize;
        sourceNode = nodeAt;
      }
    }
    if (sourceStart == null || sourceEnd == null || !sourceNode) {
      state.doc.descendants((node, pos) => {
        if (node.type.name === "fieldAnnotation" && node.attrs.fieldId === data.fieldId) {
          sourceStart = pos;
          sourceEnd = pos + node.nodeSize;
          sourceNode = node;
          return false;
        }
        return true;
      });
    }
    if (sourceStart === null || sourceEnd === null || !sourceNode) return;
    if (targetPos >= sourceStart && targetPos <= sourceEnd) return;
    const tr = state.tr;
    tr.delete(sourceStart, sourceEnd);
    const mappedTarget = tr.mapping.map(targetPos);
    if (mappedTarget < 0 || mappedTarget > tr.doc.content.size) return;
    tr.insert(mappedTarget, sourceNode);
    tr.setMeta("uiEvent", "drop");
    view.dispatch(tr);
  }
  /**
   * Handle external drop - insert new field annotation.
   */
  #handleExternalDrop(event, pos) {
    if (!this.#deps) return;
    const activeEditor = this.#deps.getActiveEditor();
    const fieldAnnotationData = event.dataTransfer?.getData(FIELD_ANNOTATION_DATA_TYPE);
    if (!fieldAnnotationData) return;
    let parsedData = null;
    try {
      parsedData = JSON.parse(fieldAnnotationData);
    } catch {
      return;
    }
    const { attributes, sourceField } = parsedData ?? {};
    activeEditor.emit?.("fieldAnnotationDropped", {
      sourceField,
      editor: activeEditor,
      coordinates: this.#deps.hitTest(event.clientX, event.clientY),
      pos
    });
    if (attributes && isValidFieldAnnotationAttributes(attributes)) {
      activeEditor.commands?.addFieldAnnotation?.(pos, attributes, true);
      const posAfter = Math.min(pos + 1, activeEditor.state?.doc?.content.size ?? pos + 1);
      const tr = activeEditor.state?.tr.setSelection(superEditor_converter.TextSelection.create(activeEditor.state.doc, posAfter));
      if (tr) {
        activeEditor.view?.dispatch(tr);
      }
      this.#deps.scheduleSelectionUpdate();
    }
    const editorDom = activeEditor.view?.dom;
    if (editorDom) {
      editorDom.focus();
      activeEditor.view?.focus();
    }
  }
  #handleDragEnd(_event) {
    this.#cancelPendingDragOverSelection();
    this.#deps?.getPainterHost()?.classList.remove("drag-over");
  }
  #handleDragLeave(event) {
    const painterHost = this.#deps?.getPainterHost();
    if (!painterHost) return;
    const relatedTarget = event.relatedTarget;
    if (!relatedTarget || !painterHost.contains(relatedTarget)) {
      painterHost.classList.remove("drag-over");
    }
  }
  /**
   * Window-level dragover to allow drops on overlay elements.
   */
  #handleWindowDragOver(event) {
    if (!hasFieldAnnotationData(event)) return;
    const viewportHost = this.#deps?.getViewportHost();
    const target = event.target;
    if (viewportHost?.contains(target)) return;
    event.preventDefault();
    if (event.dataTransfer) {
      event.dataTransfer.dropEffect = isInternalDrag(event) ? "move" : "copy";
    }
    this.#handleDragOver(event);
  }
  /**
   * Window-level drop to catch drops on overlay elements.
   */
  #handleWindowDrop(event) {
    if (!hasFieldAnnotationData(event)) return;
    const viewportHost = this.#deps?.getViewportHost();
    const target = event.target;
    if (viewportHost?.contains(target)) return;
    this.#handleDrop(event);
  }
}
new superEditor_converter.PluginKey("paginationPlugin");
const createHeaderFooterEditor = ({
  editor,
  data,
  editorContainer,
  editorHost,
  sectionId,
  type,
  availableWidth,
  availableHeight,
  currentPageNumber,
  totalPageCount
}) => {
  if (!editor) {
    throw new TypeError("editor parameter is required");
  }
  if (!data) {
    throw new TypeError("data parameter is required");
  }
  if (!editorContainer) {
    throw new TypeError("editorContainer parameter is required");
  }
  if (!(editorContainer instanceof HTMLElement)) {
    throw new TypeError("editorContainer must be an HTMLElement");
  }
  if (editorHost !== void 0 && !(editorHost instanceof HTMLElement)) {
    throw new TypeError("editorHost must be an HTMLElement or undefined");
  }
  if (availableWidth !== void 0) {
    if (typeof availableWidth !== "number" || !Number.isFinite(availableWidth) || availableWidth <= 0) {
      throw new RangeError("availableWidth must be a positive number");
    }
  }
  if (availableHeight !== void 0) {
    if (typeof availableHeight !== "number" || !Number.isFinite(availableHeight) || availableHeight <= 0) {
      throw new RangeError("availableHeight must be a positive number");
    }
  }
  if (currentPageNumber !== void 0) {
    if (typeof currentPageNumber !== "number" || !Number.isInteger(currentPageNumber) || currentPageNumber < 1) {
      throw new RangeError("currentPageNumber must be a positive integer");
    }
  }
  if (totalPageCount !== void 0) {
    if (typeof totalPageCount !== "number" || !Number.isInteger(totalPageCount) || totalPageCount < 1) {
      throw new RangeError("totalPageCount must be a positive integer");
    }
  }
  const parentStyles = editor.converter.getDocumentDefaultStyles();
  const { fontSizePt, typeface, fontFamilyCss } = parentStyles;
  const fontSizeInPixles = fontSizePt * 1.3333;
  const lineHeight2 = fontSizeInPixles * 1.2;
  applyStyleIsolationClass(editorContainer);
  const isFooter = type === "footer";
  Object.assign(editorContainer.style, {
    padding: "0",
    margin: "0",
    border: "none",
    boxSizing: "border-box",
    position: "absolute",
    top: "0",
    left: "0",
    width: availableWidth ? `${availableWidth}px` : "100%",
    height: availableHeight ? `${availableHeight}px` : "auto",
    maxWidth: "none",
    fontFamily: fontFamilyCss || typeface,
    fontSize: `${fontSizeInPixles}px`,
    lineHeight: `${lineHeight2}px`,
    overflow: isFooter ? "visible" : "hidden",
    pointerEvents: "auto",
    // Critical: enables click interaction
    backgroundColor: "white"
    // Ensure editor has white background
  });
  if (editorHost) {
    editorHost.appendChild(editorContainer);
  } else {
    console.warn("[createHeaderFooterEditor] No editorHost provided, falling back to document.body");
    document.body.appendChild(editorContainer);
  }
  const headerFooterEditor = new Editor({
    role: editor.options.role,
    loadFromSchema: true,
    mode: "docx",
    element: editorContainer,
    content: data,
    extensions: getStarterExtensions(),
    documentId: sectionId || "sectionId",
    media: editor.storage.image.media,
    mediaFiles: editor.storage.image.media,
    fonts: editor.options.fonts,
    isHeaderOrFooter: true,
    // This flag prevents pagination from being enabled
    isHeadless: editor.options.isHeadless,
    pagination: false,
    // Explicitly disable pagination
    annotations: true,
    currentPageNumber: currentPageNumber ?? 1,
    totalPageCount: totalPageCount ?? 1,
    // Don't set parentEditor to avoid circular reference issues
    // parentEditor: editor,
    // IMPORTANT: Start with editable: false to prevent triggering update cascades during creation.
    // PresentationEditor#enterHeaderFooterMode will call setEditable(true) when entering edit mode.
    editable: false,
    documentMode: "viewing",
    onCreate: (evt) => setEditorToolbar(evt, editor),
    onBlur: (evt) => onHeaderFooterDataUpdate(evt, editor, sectionId, type)
  });
  Object.defineProperty(headerFooterEditor.options, "parentEditor", {
    enumerable: false,
    // Don't include in serialization
    configurable: true,
    get() {
      return editor;
    }
  });
  headerFooterEditor.setEditable(false, false);
  const pm = editorContainer.querySelector(".ProseMirror");
  if (pm) {
    pm.style.maxHeight = "100%";
    pm.style.minHeight = "100%";
    pm.style.outline = "none";
    pm.style.border = "none";
    pm.setAttribute("role", "textbox");
    pm.setAttribute("aria-multiline", true);
    pm.setAttribute("aria-label", `${type} content area. Double click to start typing.`);
  }
  return headerFooterEditor;
};
const onHeaderFooterDataUpdate = async ({ editor, transaction }, mainEditor, sectionId, type) => {
  if (!type || !sectionId) return;
  if (isApplyingRemoteHeaderFooterChanges()) {
    return;
  }
  const updatedData = editor.getUpdatedJson();
  const editorsList = mainEditor.converter[`${type}Editors`];
  if (Array.isArray(editorsList)) {
    editorsList.forEach((item) => {
      if (item.id === sectionId) {
        item.editor.setOptions({
          media: editor.options.media,
          mediaFiles: editor.options.mediaFiles
        });
        if (item.editor !== editor) {
          item.editor.replaceContent(updatedData);
        }
      }
      item.editor.setOptions({
        lastSelection: transaction?.selection
      });
    });
  }
  mainEditor.converter[`${type}s`][sectionId] = updatedData;
  mainEditor.setOptions({ isHeaderFooterChanged: editor.docChanged });
  if (editor.docChanged && mainEditor.converter) {
    mainEditor.converter.headerFooterModified = true;
  }
  pushHeaderFooterToYjs(mainEditor, type, sectionId, updatedData);
  await updateYdocDocxData(mainEditor);
};
const setEditorToolbar = ({ editor }, mainEditor) => {
  editor.setToolbar(mainEditor.toolbar);
};
const HEADER_FOOTER_VARIANTS = ["default", "first", "even", "odd"];
const DEFAULT_HEADER_FOOTER_HEIGHT = 100;
const EDITOR_READY_TIMEOUT_MS = 5e3;
const MAX_CACHED_EDITORS_LIMIT = 100;
class HeaderFooterEditorManager extends EventEmitter {
  #editor;
  #descriptors = /* @__PURE__ */ new Map();
  #collections = null;
  #editorEntries = /* @__PURE__ */ new Map();
  #maxCachedEditors = 10;
  #editorAccessOrder = [];
  #pendingCreations = /* @__PURE__ */ new Map();
  #cacheHits = 0;
  #cacheMisses = 0;
  #evictions = 0;
  /**
   * Creates a new HeaderFooterEditorManager for managing header and footer editors.
   *
   * Note: This constructor has a side effect - it calls refresh() to immediately
   * scan the root editor's converter for header/footer data and build the initial
   * descriptor registry.
   *
   * @param editor - The root editor instance containing the converter with header/footer data
   */
  constructor(editor) {
    super();
    this.#editor = editor;
    this.refresh();
  }
  /**
   * Type guard to check if an editor has a converter property.
   *
   * @param editor - The editor instance to check
   * @returns True if the editor has a converter property
   */
  #hasConverter(editor) {
    return "converter" in editor && editor.converter !== void 0 && editor.converter !== null;
  }
  /**
   * Refreshes the internal header/footer descriptor registry by re-scanning
   * the root editor's converter data.
   *
   * This method should be called when the document structure changes in a way
   * that adds or removes header/footer sections (e.g., after document conversion,
   * section additions/deletions, or page setup changes).
   *
   * Side effects:
   * - Re-extracts collections from the converter
   * - Rebuilds the descriptor map
   * - Tears down editors for sections that no longer exist
   *
   * @throws Never throws - errors during editor teardown are caught and logged
   */
  refresh() {
    this.#collections = this.#extractCollections();
    const nextDescriptors = this.#collectDescriptors(this.#collections);
    this.#teardownMissingEditors(nextDescriptors);
    this.#descriptors = nextDescriptors;
  }
  /**
   * Destroys all managed header/footer editors and cleans up resources.
   * After calling destroy(), the manager should not be used.
   *
   * @throws May throw if individual editor cleanup fails, but continues cleanup
   */
  destroy() {
    this.#descriptors.clear();
    this.#collections = null;
    this.#teardownEditors();
    this.removeAllListeners();
  }
  /**
   * Ensures an editor instance exists for the given descriptor.
   *
   * If an editor already exists, it will be marked as recently used and returned.
   * Otherwise, a new editor is created, cached, and tracked in the LRU access order.
   * When the cache exceeds its size limit, the least recently used editor is evicted.
   *
   * Handles concurrent calls for the same descriptor by tracking pending creations
   * and returning the same promise to all callers.
   *
   * @param descriptor - The header or footer descriptor. Must have a valid id property.
   * @param options - Optional configuration for editor creation
   * @param options.editorHost - The HTMLElement to mount the editor in. If provided, must be a valid HTMLElement.
   * @param options.availableWidth - The width of the editing region in pixels. Must be a positive number if provided.
   * @param options.availableHeight - The height of the editing region in pixels. Must be a positive number if provided.
   * @param options.currentPageNumber - The current page number for PAGE field resolution. Must be a positive integer if provided.
   * @param options.totalPageCount - The total page count for NUMPAGES field resolution. Must be a positive integer if provided.
   * @returns The editor instance, or null if creation failed
   *
   * @throws Never throws - errors are logged and emitted as events. Invalid parameters return null with error logged.
   */
  async ensureEditor(descriptor, options) {
    if (!descriptor?.id) return null;
    if (options) {
      if (options.editorHost !== void 0 && !(options.editorHost instanceof HTMLElement)) {
        console.error("[HeaderFooterEditorManager] editorHost must be an HTMLElement");
        this.emit("error", {
          descriptor,
          error: new TypeError("editorHost must be an HTMLElement")
        });
        return null;
      }
      if (options.availableWidth !== void 0) {
        if (typeof options.availableWidth !== "number" || !Number.isFinite(options.availableWidth) || options.availableWidth <= 0) {
          console.error("[HeaderFooterEditorManager] availableWidth must be a positive number");
          this.emit("error", {
            descriptor,
            error: new TypeError("availableWidth must be a positive number")
          });
          return null;
        }
      }
      if (options.availableHeight !== void 0) {
        if (typeof options.availableHeight !== "number" || !Number.isFinite(options.availableHeight) || options.availableHeight <= 0) {
          console.error("[HeaderFooterEditorManager] availableHeight must be a positive number");
          this.emit("error", {
            descriptor,
            error: new TypeError("availableHeight must be a positive number")
          });
          return null;
        }
      }
      if (options.currentPageNumber !== void 0) {
        if (typeof options.currentPageNumber !== "number" || !Number.isInteger(options.currentPageNumber) || options.currentPageNumber < 1) {
          console.error("[HeaderFooterEditorManager] currentPageNumber must be a positive integer");
          this.emit("error", {
            descriptor,
            error: new TypeError("currentPageNumber must be a positive integer")
          });
          return null;
        }
      }
      if (options.totalPageCount !== void 0) {
        if (typeof options.totalPageCount !== "number" || !Number.isInteger(options.totalPageCount) || options.totalPageCount < 1) {
          console.error("[HeaderFooterEditorManager] totalPageCount must be a positive integer");
          this.emit("error", {
            descriptor,
            error: new TypeError("totalPageCount must be a positive integer")
          });
          return null;
        }
      }
    }
    const existing = this.#editorEntries.get(descriptor.id);
    if (existing) {
      this.#cacheHits += 1;
      this.#updateAccessOrder(descriptor.id);
      await existing.ready.catch((error) => {
        console.error("[HeaderFooterEditorManager] Editor initialization failed:", error);
        this.emit("error", { descriptor, error });
      });
      if (existing.container && options?.editorHost) {
        if (existing.container.parentElement !== options.editorHost) {
          options.editorHost.appendChild(existing.container);
        }
      }
      if (existing.editor && options) {
        const updateOptions = {};
        if (options.currentPageNumber !== void 0) {
          updateOptions.currentPageNumber = options.currentPageNumber;
        }
        if (options.totalPageCount !== void 0) {
          updateOptions.totalPageCount = options.totalPageCount;
        }
        if (options.availableWidth !== void 0) {
          updateOptions.availableWidth = options.availableWidth;
        }
        if (options.availableHeight !== void 0) {
          updateOptions.availableHeight = options.availableHeight;
        }
        if (Object.keys(updateOptions).length > 0) {
          existing.editor.setOptions(updateOptions);
        }
      }
      return existing.editor;
    }
    const pending = this.#pendingCreations.get(descriptor.id);
    if (pending) {
      return pending;
    }
    this.#cacheMisses += 1;
    const creationPromise = (async () => {
      try {
        const entry = await this.#createEditor(descriptor, options);
        if (!entry) return null;
        this.#editorEntries.set(descriptor.id, entry);
        this.#updateAccessOrder(descriptor.id);
        this.#enforceCacheSizeLimit();
        await entry.ready.catch((error) => {
          console.error("[HeaderFooterEditorManager] Editor initialization failed:", error);
          this.emit("error", { descriptor, error });
        });
        return entry.editor;
      } finally {
        this.#pendingCreations.delete(descriptor.id);
      }
    })();
    this.#pendingCreations.set(descriptor.id, creationPromise);
    return creationPromise;
  }
  /**
   * Retrieves the editor instance for a given header/footer descriptor,
   * if one has been created.
   *
   * This method only returns already-created editors. To ensure an editor
   * exists (creating it if necessary), use ensureEditor() instead.
   *
   * @param descriptor - The header or footer descriptor
   * @returns The editor instance if it exists, null otherwise
   *
   * @example
   * ```typescript
   * const descriptor = manager.getDescriptorById('rId-header-default');
   * const editor = manager.getEditor(descriptor);
   * if (editor) {
   *   // Editor exists, can be used immediately
   * }
   * ```
   */
  getEditor(descriptor) {
    if (!descriptor?.id) return null;
    return this.#editorEntries.get(descriptor.id)?.editor ?? null;
  }
  /**
   * Returns all header/footer descriptors, optionally filtered by kind.
   *
   * @param kind - Optional filter: 'header' or 'footer'. If omitted, returns all descriptors.
   * @returns Array of descriptors matching the filter criteria
   *
   * @example
   * ```typescript
   * // Get all descriptors
   * const all = manager.getDescriptors();
   *
   * // Get only headers
   * const headers = manager.getDescriptors('header');
   *
   * // Get only footers
   * const footers = manager.getDescriptors('footer');
   * ```
   */
  getDescriptors(kind) {
    const entries = Array.from(this.#descriptors.values());
    if (!kind) return entries;
    return entries.filter((descriptor) => descriptor.kind === kind);
  }
  /**
   * Retrieves a header/footer descriptor by its relationship ID.
   *
   * @param id - The relationship ID (e.g., 'rId-header-default')
   * @returns The descriptor if found, undefined otherwise
   *
   * @example
   * ```typescript
   * const descriptor = manager.getDescriptorById('rId-header-default');
   * if (descriptor) {
   *   console.log(`Found ${descriptor.kind} with variant ${descriptor.variant}`);
   * }
   * ```
   */
  getDescriptorById(id) {
    return this.#descriptors.get(id);
  }
  /**
   * Retrieves the ProseMirror document JSON for a header/footer section.
   *
   * This method first attempts to get the live document from an active editor
   * (if one exists). If that fails or no editor exists, it falls back to the
   * converter's snapshot of the document.
   *
   * @param descriptor - The header or footer descriptor
   * @returns The document JSON structure, or null if not found
   *
   * @example
   * ```typescript
   * const descriptor = manager.getDescriptorById('rId-header-default');
   * const json = manager.getDocumentJson(descriptor);
   * if (json) {
   *   // Process the ProseMirror document structure
   * }
   * ```
   */
  getDocumentJson(descriptor) {
    if (!descriptor?.id) {
      return null;
    }
    const liveEntry = this.#editorEntries.get(descriptor.id);
    if (liveEntry) {
      try {
        return liveEntry.editor.getJSON?.();
      } catch {
      }
    }
    const collections = this.#collections;
    if (!collections) {
      return null;
    }
    if (descriptor.kind === "header") {
      return collections.headers?.[descriptor.id] ?? null;
    }
    return collections.footers?.[descriptor.id] ?? null;
  }
  /**
   * Returns the root editor instance that this manager was created with.
   *
   * @returns The root editor containing the main document
   */
  get rootEditor() {
    return this.#editor;
  }
  /**
   * Returns the relationship ID associated with the requested Word header/footer variant.
   *
   * @param kind - The header or footer kind
   * @param variant - The page variant (default, first, even, or odd)
   * @returns The relationship ID if found, null otherwise
   */
  getVariantId(kind, variant) {
    const collections = this.#collections;
    if (!collections) return null;
    const source = kind === "header" ? collections.headerIds : collections.footerIds;
    const value = source?.[variant];
    if (typeof value === "string") return value;
    return null;
  }
  /**
   * Extracts header/footer collections from the root editor's converter.
   * Uses type guard for safe access to converter property.
   *
   * @returns The collections object, or null if no converter exists
   */
  #extractCollections() {
    if (!this.#hasConverter(this.#editor)) {
      return null;
    }
    const converter = this.#editor.converter;
    if (!converter) return null;
    return {
      headers: converter.headers,
      footers: converter.footers,
      headerIds: converter.headerIds,
      footerIds: converter.footerIds
    };
  }
  /**
   * Collects all unique header/footer descriptors from the collections data.
   * Uses proper type guards to safely handle variant IDs and array IDs.
   *
   * @param collections - The header/footer collections data
   * @returns Map of relationship ID to descriptor
   */
  #collectDescriptors(collections) {
    const descriptors = /* @__PURE__ */ new Map();
    if (!collections) return descriptors;
    const register = (kind, rId, variant) => {
      if (typeof rId !== "string" || rId.length === 0) return;
      const existing = descriptors.get(rId);
      if (existing) {
        if (variant && !existing.variant) {
          existing.variant = variant;
        }
        return;
      }
      descriptors.set(rId, { id: rId, kind, variant });
    };
    HEADER_FOOTER_VARIANTS.forEach((variant) => {
      const headerId = collections.headerIds?.[variant];
      const footerId = collections.footerIds?.[variant];
      if (typeof headerId === "string") {
        register("header", headerId, variant);
      }
      if (typeof footerId === "string") {
        register("footer", footerId, variant);
      }
    });
    const headerIdsArray = collections.headerIds?.ids;
    if (Array.isArray(headerIdsArray)) {
      headerIdsArray.forEach((rId) => {
        if (typeof rId === "string" && !descriptors.has(rId)) {
          register("header", rId);
        }
      });
    }
    const footerIdsArray = collections.footerIds?.ids;
    if (Array.isArray(footerIdsArray)) {
      footerIdsArray.forEach((rId) => {
        if (typeof rId === "string" && !descriptors.has(rId)) {
          register("footer", rId);
        }
      });
    }
    return descriptors;
  }
  #teardownMissingEditors(nextDescriptors) {
    const toRemove = [];
    this.#editorEntries.forEach((entry, key2) => {
      if (!nextDescriptors.has(key2)) {
        try {
          entry.disposer();
        } catch (error) {
          console.warn("[HeaderFooterEditorManager] Cleanup failed for editor:", key2, error);
        }
        toRemove.push(key2);
      }
    });
    toRemove.forEach((key2) => this.#editorEntries.delete(key2));
  }
  #teardownEditors() {
    this.#editorEntries.forEach((entry) => {
      try {
        entry.disposer();
      } catch (error) {
        console.warn("[HeaderFooterEditorManager] Cleanup failed:", error);
      }
    });
    this.#editorEntries.clear();
  }
  async #createEditor(descriptor, options) {
    const json = this.getDocumentJson(descriptor);
    if (!json) return null;
    let editor;
    let container;
    try {
      container = this.#createEditorContainer();
      editor = createHeaderFooterEditor({
        editor: this.#editor,
        data: json,
        editorContainer: container,
        editorHost: options?.editorHost,
        sectionId: descriptor.id,
        type: descriptor.kind,
        availableWidth: options?.availableWidth,
        availableHeight: options?.availableHeight ?? DEFAULT_HEADER_FOOTER_HEIGHT,
        currentPageNumber: options?.currentPageNumber ?? 1,
        totalPageCount: options?.totalPageCount ?? 1
      });
    } catch (error) {
      console.error("[HeaderFooterEditorManager] Editor creation failed:", error);
      return null;
    }
    const handleUpdate = async ({ transaction }) => {
      this.emit("contentChanged", { descriptor });
      try {
        onHeaderFooterDataUpdate({ editor, transaction }, this.#editor, descriptor.id, descriptor.kind);
        await updateYdocDocxData(this.#editor, void 0);
      } catch (error) {
        console.error("[HeaderFooterEditorManager] Failed to sync header/footer update", { descriptor, error });
        this.emit("syncError", { descriptor, error });
      }
    };
    editor.on("update", handleUpdate);
    this.#registerConverterEditor(descriptor, editor);
    const disposer = () => {
      try {
        editor.off?.("update", handleUpdate);
      } catch (error) {
        console.warn("[HeaderFooterEditorManager] Failed to remove update listener:", error);
      }
      try {
        editor.destroy?.();
      } catch (error) {
        console.warn("[HeaderFooterEditorManager] Failed to destroy editor:", error);
      }
      try {
        if (container.parentNode) {
          container.parentNode.removeChild(container);
        }
      } catch (error) {
        console.warn("[HeaderFooterEditorManager] Failed to remove container from DOM:", error);
      }
      try {
        this.#unregisterConverterEditor(descriptor);
      } catch (error) {
        console.warn("[HeaderFooterEditorManager] Failed to unregister converter editor:", error);
      }
    };
    const ready = new Promise((resolve, reject) => {
      let isResolved = false;
      const timeoutId = setTimeout(() => {
        if (!isResolved) {
          isResolved = true;
          const error = new Error(
            `Editor initialization timed out after ${EDITOR_READY_TIMEOUT_MS}ms for ${descriptor.kind} ${descriptor.id}`
          );
          reject(error);
        }
      }, EDITOR_READY_TIMEOUT_MS);
      editor.once?.("create", () => {
        if (!isResolved) {
          isResolved = true;
          clearTimeout(timeoutId);
          resolve();
        }
      });
      editor.once?.("error", (error) => {
        if (!isResolved) {
          isResolved = true;
          clearTimeout(timeoutId);
          reject(error instanceof Error ? error : new Error(String(error)));
        }
      });
    });
    return {
      descriptor,
      editor,
      container,
      disposer,
      ready
    };
  }
  #createEditorContainer() {
    const doc2 = this.#editor.options?.element?.ownerDocument ?? globalThis.document ?? void 0;
    const container = doc2?.createElement("div") ?? document.createElement("div");
    return container;
  }
  /**
   * Registers an editor instance with the converter's editor tracking arrays.
   * Uses type guard for safe access to converter property.
   *
   * @param descriptor - The header/footer descriptor
   * @param editor - The editor instance to register
   */
  #registerConverterEditor(descriptor, editor) {
    if (!this.#hasConverter(this.#editor)) {
      return;
    }
    const converter = this.#editor.converter;
    if (!converter) return;
    const targetKey = descriptor.kind === "header" ? "headerEditors" : "footerEditors";
    if (!Array.isArray(converter[targetKey])) {
      converter[targetKey] = [];
    }
    const converterEditors = converter[targetKey];
    if (!Array.isArray(converterEditors)) return;
    const exists2 = converterEditors.some((entry) => {
      return entry && typeof entry === "object" && "id" in entry && entry.id === descriptor.id;
    });
    if (!exists2) {
      converterEditors.push({ id: descriptor.id, editor });
    }
  }
  /**
   * Unregisters an editor instance from the converter's editor tracking arrays.
   * Uses type guard for safe access to converter property.
   *
   * @param descriptor - The header/footer descriptor to unregister
   */
  #unregisterConverterEditor(descriptor) {
    if (!this.#hasConverter(this.#editor)) {
      return;
    }
    const converter = this.#editor.converter;
    if (!converter) return;
    const targetKey = descriptor.kind === "header" ? "headerEditors" : "footerEditors";
    const converterEditors = converter[targetKey];
    if (!Array.isArray(converterEditors)) {
      return;
    }
    converter[targetKey] = converterEditors.filter((entry) => {
      return !(entry && typeof entry === "object" && "id" in entry && entry.id === descriptor.id);
    });
  }
  /**
   * Updates the LRU access order by moving the given ID to the end (most recently used).
   *
   * This method maintains the access order array by removing any existing occurrence
   * of the ID and appending it to the end, marking it as the most recently used.
   *
   * @param id - The descriptor ID to mark as recently accessed
   */
  #updateAccessOrder(id) {
    this.#editorAccessOrder = this.#editorAccessOrder.filter((existingId) => existingId !== id);
    this.#editorAccessOrder.push(id);
  }
  /**
   * Enforces the cache size limit by evicting least recently used editors.
   *
   * When the number of cached editors exceeds `#maxCachedEditors`, this method
   * removes the oldest editors (from the front of the access order array) until
   * the cache size is within the limit. Each evicted editor is properly disposed.
   */
  #enforceCacheSizeLimit() {
    while (this.#editorAccessOrder.length > this.#maxCachedEditors) {
      const oldestId = this.#editorAccessOrder.shift();
      if (!oldestId) break;
      const oldEntry = this.#editorEntries.get(oldestId);
      if (oldEntry) {
        try {
          oldEntry.disposer();
          this.#evictions += 1;
        } catch (error) {
          console.warn("[HeaderFooterEditorManager] LRU eviction cleanup failed:", error);
        }
        this.#editorEntries.delete(oldestId);
      }
    }
  }
  /**
   * Sets the maximum number of cached header/footer editors.
   *
   * Least recently used editors will be disposed when this limit is exceeded.
   * If the new limit is lower than the current number of cached editors,
   * excess editors are immediately evicted.
   *
   * @param max - Maximum number of editors to keep in memory (must be between 1 and 100, and an integer)
   * @throws Error if max is less than 1, greater than 100, or not an integer
   *
   * @example
   * ```typescript
   * manager.setMaxCachedEditors(5); // Limit to 5 cached editors
   * ```
   */
  setMaxCachedEditors(max2) {
    if (max2 < 1) {
      throw new Error("Max cached editors must be at least 1");
    }
    if (max2 > MAX_CACHED_EDITORS_LIMIT) {
      throw new Error(`Max cached editors must not exceed ${MAX_CACHED_EDITORS_LIMIT}`);
    }
    if (!Number.isInteger(max2)) {
      throw new Error("Max cached editors must be an integer");
    }
    this.#maxCachedEditors = max2;
    this.#enforceCacheSizeLimit();
  }
  /**
   * Returns cache performance statistics for monitoring and debugging.
   *
   * Provides metrics about cache effectiveness, including hit rate, number of
   * cached editors, and eviction counts. Useful for tuning cache size and
   * understanding access patterns in production.
   *
   * @returns Object containing cache statistics
   *
   * @example
   * ```typescript
   * const stats = manager.getCacheStats();
   * console.log(`Cache hit rate: ${(stats.hitRate * 100).toFixed(1)}%`);
   * console.log(`Evictions: ${stats.evictions}`);
   * ```
   */
  getCacheStats() {
    const totalAccesses = this.#cacheHits + this.#cacheMisses;
    const hitRate = totalAccesses > 0 ? this.#cacheHits / totalAccesses : 0;
    return {
      cachedEditors: this.#editorEntries.size,
      maxCachedEditors: this.#maxCachedEditors,
      cacheHits: this.#cacheHits,
      cacheMisses: this.#cacheMisses,
      evictions: this.#evictions,
      hitRate
    };
  }
  /**
   * Resets cache statistics (hits, misses, evictions) to zero.
   * Does not clear cached editors or affect cache behavior.
   *
   * Useful for starting fresh measurements after configuration changes
   * or for periodic monitoring resets.
   *
   * @example
   * ```typescript
   * manager.resetCacheStats();
   * // ... perform operations ...
   * const stats = manager.getCacheStats(); // Fresh stats from reset point
   * ```
   */
  resetCacheStats() {
    this.#cacheHits = 0;
    this.#cacheMisses = 0;
    this.#evictions = 0;
  }
}
class HeaderFooterLayoutAdapter {
  #manager;
  #mediaFiles;
  #blockCache = /* @__PURE__ */ new Map();
  /**
   * Creates a new HeaderFooterLayoutAdapter.
   *
   * @param manager - The HeaderFooterEditorManager instance to source content from
   * @param mediaFiles - Optional mapping of media IDs to URLs for image resolution
   */
  constructor(manager, mediaFiles) {
    this.#manager = manager;
    this.#mediaFiles = mediaFiles;
  }
  /**
   * Retrieves FlowBlock batches for all variants of a given header/footer kind.
   *
   * This method converts the ProseMirror documents for all available variants
   * (default, first, even, odd) into FlowBlock arrays suitable for the layout engine.
   * Results are cached based on document identity to avoid redundant conversions.
   *
   * @param kind - The type of section to retrieve: 'header' or 'footer'
   * @returns An object mapping variant names to FlowBlock arrays, or undefined if no content exists
   *
   * @example
   * ```typescript
   * const headerBatch = adapter.getBatch('header');
   * if (headerBatch) {
   *   // headerBatch.default contains blocks for default pages
   *   // headerBatch.first contains blocks for first page (if exists)
   * }
   * ```
   */
  getBatch(kind) {
    const descriptors = this.#manager.getDescriptors(kind);
    if (!descriptors.length) {
      return void 0;
    }
    const batch = {};
    let hasBlocks = false;
    descriptors.forEach((descriptor) => {
      if (!descriptor.variant) {
        return;
      }
      const blocks = this.#getBlocks(descriptor);
      if (blocks && blocks.length > 0) {
        batch[descriptor.variant] = blocks;
        hasBlocks = true;
      }
    });
    return hasBlocks ? batch : void 0;
  }
  /**
   * Retrieves FlowBlocks for ALL header/footer content, keyed by relationship ID.
   *
   * Unlike getBatch() which only returns content for variant-associated IDs,
   * this method returns content for ALL registered header/footer IDs. This is
   * essential for multi-section documents where different sections may use
   * different content for the same variant type.
   *
   * @param kind - The type of section to retrieve: 'header' or 'footer'
   * @returns A Map of rId to FlowBlock arrays, or undefined if no content exists
   *
   * @example
   * ```typescript
   * const footersByRId = adapter.getBlocksByRId('footer');
   * if (footersByRId) {
   *   // footersByRId.get('rId14') - blocks for footer with rId14
   *   // footersByRId.get('rId18') - blocks for footer with rId18 (different section)
   * }
   * ```
   */
  getBlocksByRId(kind) {
    const descriptors = this.#manager.getDescriptors(kind);
    if (!descriptors.length) return void 0;
    const blocksMap = /* @__PURE__ */ new Map();
    descriptors.forEach((descriptor) => {
      const blocks = this.#getBlocks(descriptor);
      if (blocks && blocks.length > 0) {
        blocksMap.set(descriptor.id, blocks);
      }
    });
    return blocksMap.size > 0 ? blocksMap : void 0;
  }
  /**
   * Retrieves FlowBlocks for a specific header/footer by its relationship ID.
   *
   * @param rId - The relationship ID (e.g., 'rId14')
   * @returns FlowBlock array for the specified rId, or undefined if not found
   */
  getBlocksForRId(rId) {
    const descriptor = this.#manager.getDescriptorById(rId);
    if (!descriptor) return void 0;
    return this.#getBlocks(descriptor);
  }
  /**
   * Invalidates the cached FlowBlocks for a specific header/footer section.
   *
   * Call this method when the content of a specific section changes to force
   * re-conversion on the next getBatch() call.
   *
   * @param rId - The relationship ID of the section to invalidate
   *
   * @example
   * ```typescript
   * // After editing a header
   * manager.on('contentChanged', ({ descriptor }) => {
   *   adapter.invalidate(descriptor.id);
   * });
   * ```
   */
  invalidate(rId) {
    this.#blockCache.delete(rId);
  }
  /**
   * Invalidates all cached FlowBlocks.
   *
   * Should be called when mediaFiles are updated globally, as image references
   * in blocks may need to be regenerated with new media URLs. Also useful when
   * the converter context changes (styles, numbering, etc.).
   *
   * @example
   * ```typescript
   * // After updating media files
   * adapter.invalidateAll();
   * const freshBatch = adapter.getBatch('header'); // Will re-convert all sections
   * ```
   */
  invalidateAll() {
    this.#blockCache.clear();
  }
  /**
   * Clears all cached FlowBlocks.
   *
   * Alias for invalidateAll(). Useful for cleanup operations.
   */
  clear() {
    this.#blockCache.clear();
  }
  #getBlocks(descriptor) {
    const doc2 = this.#manager.getDocumentJson(descriptor);
    if (!doc2) return void 0;
    const cacheEntry = this.#blockCache.get(descriptor.id);
    if (cacheEntry?.docRef === doc2) {
      return cacheEntry.blocks;
    }
    const blockIdPrefix = `hf-${descriptor.kind}-${descriptor.id}-`;
    const converterContext = this.#getConverterContext();
    const rootConverter = this.#manager.rootEditor?.converter;
    const providedMedia = this.#mediaFiles;
    const fallbackMedia = rootConverter?.media;
    const mediaFiles = providedMedia && Object.keys(providedMedia).length > 0 ? providedMedia : fallbackMedia;
    const atomNodeTypes = getAtomNodeTypes(this.#manager.rootEditor?.schema ?? null);
    const docDefaults = rootConverter?.getDocumentDefaultStyles?.();
    const defaultFont = docDefaults?.typeface;
    const defaultSize = docDefaults?.fontSizePt != null ? docDefaults.fontSizePt * (96 / 72) : void 0;
    const result = toFlowBlocks(doc2, {
      mediaFiles,
      blockIdPrefix,
      converterContext,
      defaultFont,
      defaultSize,
      ...atomNodeTypes.length > 0 ? { atomNodeTypes } : {}
    });
    const blocks = result.blocks;
    this.#blockCache.set(descriptor.id, { docRef: doc2, blocks });
    return blocks;
  }
  /**
   * Extracts converter context needed for FlowBlock conversion.
   * Uses type guard for safe access to converter property.
   *
   * @returns The converter context containing document metadata, or undefined if not available
   */
  #getConverterContext() {
    const rootEditor = this.#manager.rootEditor;
    if (!("converter" in rootEditor)) {
      return void 0;
    }
    const converter = rootEditor.converter;
    if (!converter) return void 0;
    const context = {
      docx: converter.convertedXml,
      numbering: converter.numbering,
      translatedLinkedStyles: converter.translatedLinkedStyles,
      translatedNumbering: converter.translatedNumbering
    };
    return context;
  }
}
const EDITOR_HOST_Z_INDEX = "10";
const BORDER_LINE_Z_INDEX = "15";
const BORDER_LINE_COLOR = "#4472c4";
const BORDER_LINE_HEIGHT = "1px";
class EditorOverlayManager {
  /** Selection overlay element (for hiding during editing) */
  #selectionOverlay;
  /** Currently active editor host element */
  #activeEditorHost = null;
  /** Currently active static decoration container */
  #activeDecorationContainer = null;
  /** Current editing region */
  #activeRegion = null;
  /** Full-width border line element (MS Word style) */
  #borderLine = null;
  /**
   * Creates a new EditorOverlayManager instance.
   *
   * @param painterHost - The host element containing painted pages. Must be an HTMLElement connected to the DOM.
   * @param visibleHost - The visible host element for overlay positioning. Must be an HTMLElement connected to the DOM.
   * @param selectionOverlay - The selection overlay element (optional). If provided, must be an HTMLElement.
   *
   * @throws {TypeError} If painterHost is not an HTMLElement
   * @throws {TypeError} If visibleHost is not an HTMLElement
   * @throws {TypeError} If selectionOverlay is provided but is not an HTMLElement
   * @throws {Error} If painterHost is not connected to the DOM
   * @throws {Error} If visibleHost is not connected to the DOM
   */
  constructor(_painterHost, _visibleHost, selectionOverlay = null) {
    if (!(_painterHost instanceof HTMLElement)) {
      throw new TypeError("painterHost must be an HTMLElement");
    }
    if (!(_visibleHost instanceof HTMLElement)) {
      throw new TypeError("visibleHost must be an HTMLElement");
    }
    if (selectionOverlay !== null && !(selectionOverlay instanceof HTMLElement)) {
      throw new TypeError("selectionOverlay must be an HTMLElement or null");
    }
    if (!_painterHost.isConnected) {
      throw new Error("painterHost must be connected to the DOM");
    }
    if (!_visibleHost.isConnected) {
      throw new Error("visibleHost must be connected to the DOM");
    }
    this.#selectionOverlay = selectionOverlay;
  }
  /**
   * Sets the callback to be invoked when the dimming overlay is clicked.
   * This allows PresentationEditor to exit header/footer mode when the user
   * clicks outside the editing region.
   *
   * @param callback - Function to call when dimming overlay is clicked
   */
  setOnDimmingClick(_callback) {
  }
  /**
   * Gets the currently active editor host element.
   * This is useful for checking if a click target is inside the active editing area.
   *
   * @returns The active editor host element, or null if not in editing mode
   */
  getActiveEditorHost() {
    return this.#activeEditorHost;
  }
  /**
   * Shows the editing overlay for a header/footer region.
   *
   * This method:
   * 1. Creates or retrieves the editor host element as a sibling to the decoration container
   * 2. Positions the editor host to match the decoration container bounds
   * 3. Hides the static decoration content
   * 4. Shows the dimming overlay over body content
   * 5. Returns the editor host element for mounting the ProseMirror editor
   *
   * @param pageElement - The page DOM element containing the region
   * @param region - The header/footer region to edit
   * @param zoom - Current zoom level (for positioning calculations)
   * @returns Result object with success status and editor host element
   *
   * @example
   * ```typescript
   * const result = overlayManager.showEditingOverlay(pageElement, region, 1.0);
   * if (result.success && result.editorHost) {
   *   // Mount ProseMirror editor in result.editorHost
   * }
   * ```
   */
  showEditingOverlay(pageElement, region, zoom) {
    try {
      const decorationContainer = this.#findDecorationContainer(pageElement, region.kind);
      const editorHost = this.#ensureEditorHost(pageElement, region.kind, decorationContainer);
      if (!editorHost) {
        return {
          success: false,
          reason: `Failed to create editor host for ${region.kind}`
        };
      }
      this.#positionEditorHost(editorHost, region, decorationContainer, zoom);
      if (decorationContainer) {
        decorationContainer.style.visibility = "hidden";
      }
      editorHost.style.visibility = "visible";
      editorHost.style.zIndex = EDITOR_HOST_Z_INDEX;
      if (region.kind === "footer") {
        const contentOffset = editorHost.dataset.contentOffset;
        if (contentOffset) {
          const editorContainer = editorHost.querySelector(".super-editor");
          if (editorContainer instanceof HTMLElement) {
            editorContainer.style.top = `${contentOffset}px`;
          }
        }
      }
      this.#showHeaderFooterBorder(pageElement, region, decorationContainer, zoom);
      this.#activeEditorHost = editorHost;
      this.#activeDecorationContainer = decorationContainer;
      this.#activeRegion = region;
      return {
        success: true,
        editorHost
      };
    } catch (error) {
      if (this.#activeDecorationContainer) {
        this.#activeDecorationContainer.style.visibility = "visible";
      }
      if (this.#activeEditorHost) {
        this.#activeEditorHost.style.visibility = "hidden";
      }
      this.#hideHeaderFooterBorder();
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error("[EditorOverlayManager] Failed to show editing overlay:", error);
      return {
        success: false,
        reason: `DOM manipulation error: ${errorMessage}`
      };
    }
  }
  /**
   * Hides the editing overlay and restores normal view.
   *
   * This method:
   * 1. Shows the static decoration content
   * 2. Hides the editor host (but doesn't destroy it for reuse)
   * 3. Removes the dimming overlay
   *
   * @example
   * ```typescript
   * overlayManager.hideEditingOverlay();
   * // Static decoration is now visible, editor is hidden
   * ```
   */
  hideEditingOverlay() {
    if (this.#activeDecorationContainer) {
      this.#activeDecorationContainer.style.visibility = "visible";
    }
    if (this.#activeEditorHost) {
      this.#activeEditorHost.style.visibility = "hidden";
      this.#activeEditorHost.style.zIndex = "";
      if (this.#activeRegion?.kind === "footer") {
        const editorContainer = this.#activeEditorHost.querySelector(".super-editor");
        if (editorContainer instanceof HTMLElement) {
          editorContainer.style.top = "0";
          editorContainer.style.transform = "";
        }
      }
    }
    this.#hideHeaderFooterBorder();
    this.#activeEditorHost = null;
    this.#activeDecorationContainer = null;
    this.#activeRegion = null;
  }
  /**
   * Hides the layout selection overlay to prevent double caret rendering.
   *
   * Called when entering header/footer editing mode to ensure only the
   * ProseMirror editor's caret is visible, not both the PM caret and the
   * layout engine's selection overlay.
   *
   * @example
   * ```typescript
   * overlayManager.hideSelectionOverlay();
   * // Selection overlay is now hidden
   * ```
   */
  hideSelectionOverlay() {
    if (this.#selectionOverlay) {
      this.#selectionOverlay.style.visibility = "hidden";
    }
  }
  /**
   * Shows the layout selection overlay.
   *
   * Called when exiting header/footer editing mode to restore the
   * normal selection overlay rendering for body content.
   *
   * @example
   * ```typescript
   * overlayManager.showSelectionOverlay();
   * // Selection overlay is now visible
   * ```
   */
  showSelectionOverlay() {
    if (this.#selectionOverlay) {
      this.#selectionOverlay.style.visibility = "visible";
    }
  }
  /**
   * Destroys the overlay manager and cleans up all resources.
   *
   * Clears all references.
   * Editor host elements are left in the DOM as they're children of page elements
   * that will be cleaned up by the virtualization system.
   */
  destroy() {
    this.#hideHeaderFooterBorder();
    this.#activeEditorHost = null;
    this.#activeDecorationContainer = null;
    this.#activeRegion = null;
    this.#selectionOverlay = null;
  }
  /**
   * Finds the decoration container element for a given region kind.
   *
   * Decoration containers are created by the layout engine renderer with
   * class names 'superdoc-page-header' or 'superdoc-page-footer'.
   *
   * @param pageElement - The page element to search within
   * @param kind - The region kind (header or footer)
   * @returns The decoration container element, or null if not found
   */
  #findDecorationContainer(pageElement, kind) {
    const className = kind === "header" ? "superdoc-page-header" : "superdoc-page-footer";
    return pageElement.querySelector(`.${className}`);
  }
  /**
   * Ensures an editor host element exists for editing.
   *
   * If the editor host doesn't exist, creates it. Otherwise, returns the existing one.
   * When a decoration container exists, the editor host is positioned as a sibling.
   * When no decoration container exists (empty header/footer), it's appended to the page.
   *
   * @param pageElement - The page element to create the host within
   * @param kind - The region kind (header or footer)
   * @param decorationContainer - The decoration container (optional, may not exist for empty regions)
   * @returns The editor host element
   */
  #ensureEditorHost(pageElement, kind, decorationContainer) {
    const className = kind === "header" ? "superdoc-header-editor-host" : "superdoc-footer-editor-host";
    let editorHost = pageElement.querySelector(`.${className}`);
    if (!editorHost) {
      editorHost = document.createElement("div");
      editorHost.className = className;
      Object.assign(editorHost.style, {
        position: "absolute",
        pointerEvents: "auto",
        // Critical: enables click interaction
        visibility: "hidden",
        // Hidden by default, shown during editing
        overflow: "hidden",
        boxSizing: "border-box"
      });
      if (decorationContainer) {
        decorationContainer.parentNode?.insertBefore(editorHost, decorationContainer.nextSibling);
      } else {
        pageElement.appendChild(editorHost);
      }
    }
    return editorHost;
  }
  /**
   * Positions the editor host for header/footer editing using pure layout coordinates.
   *
   * This method uses ONLY layout-based coordinates from the region data, never
   * getBoundingClientRect(). This ensures overlays stay aligned with content even
   * when the editor is embedded in containers with CSS transforms, filters, or
   * complex positioning contexts.
   *
   * The transform: scale() on #viewportHost handles zoom, so we don't multiply
   * by zoom here - we use the raw layout coordinates directly.
   *
   * @param editorHost - The editor host element to position
   * @param region - The header/footer region with dimension data from layout engine
   * @param decorationContainer - The decoration container (optional, may not exist for empty regions)
   * @param _zoom - Current zoom level (unused - zoom is handled by transform: scale())
   */
  #positionEditorHost(editorHost, region, decorationContainer, _zoom) {
    const pageElement = editorHost.parentElement;
    if (!pageElement) {
      console.error("[EditorOverlayManager] Editor host has no parent element");
      return;
    }
    const top2 = decorationContainer?.offsetTop ?? region.localY;
    const left2 = decorationContainer?.offsetLeft ?? region.localX;
    const width = decorationContainer?.offsetWidth ?? region.width;
    const height = decorationContainer?.offsetHeight ?? region.height;
    Object.assign(editorHost.style, {
      top: `${top2}px`,
      left: `${left2}px`,
      width: `${width}px`,
      height: `${height}px`
    });
    if (region.kind === "footer" && decorationContainer) {
      const fragment = decorationContainer.querySelector(".superdoc-fragment");
      if (fragment instanceof HTMLElement) {
        const fragmentTop = parseFloat(fragment.style.top) || 0;
        editorHost.dataset.contentOffset = String(fragmentTop);
      }
    }
  }
  /**
   * Shows a full-width border line at the bottom of the header or top of the footer.
   * This creates the MS Word style visual indicator spanning edge-to-edge of the page.
   *
   * Uses pure layout coordinates from region data to avoid coordinate system mixing.
   */
  #showHeaderFooterBorder(pageElement, region, decorationContainer, _zoom) {
    this.#hideHeaderFooterBorder();
    this.#borderLine = document.createElement("div");
    this.#borderLine.className = "superdoc-header-footer-border";
    const isHeader = region.kind === "header";
    const decorationTop = decorationContainer?.offsetTop;
    const decorationHeight = decorationContainer?.offsetHeight;
    const topPosition = isHeader ? decorationTop != null && decorationHeight != null ? decorationTop + decorationHeight : region.localY + region.height : decorationTop ?? region.localY;
    Object.assign(this.#borderLine.style, {
      position: "absolute",
      left: "0",
      right: "0",
      top: `${topPosition}px`,
      height: BORDER_LINE_HEIGHT,
      backgroundColor: BORDER_LINE_COLOR,
      // MS Word blue
      zIndex: BORDER_LINE_Z_INDEX,
      pointerEvents: "none"
    });
    pageElement.appendChild(this.#borderLine);
  }
  /**
   * Hides and removes the header/footer border line.
   */
  #hideHeaderFooterBorder() {
    if (this.#borderLine) {
      this.#borderLine.remove();
      this.#borderLine = null;
    }
  }
}
function initHeaderFooterRegistry({
  painterHost,
  visibleHost,
  selectionOverlay,
  editor,
  converter,
  mediaFiles,
  isDebug,
  initBudgetMs,
  resetSession,
  requestRerender,
  exitHeaderFooterMode,
  previousCleanups,
  previousAdapter,
  previousManager,
  previousOverlayManager
}) {
  const startTime = performance.now();
  previousCleanups.forEach((fn2) => {
    try {
      fn2();
    } catch (error) {
      console.warn("[PresentationEditor] Header/footer cleanup failed:", error);
    }
  });
  previousAdapter?.clear();
  previousManager?.destroy();
  previousOverlayManager?.destroy();
  resetSession();
  const overlayManager = new EditorOverlayManager(painterHost, visibleHost, selectionOverlay);
  overlayManager.setOnDimmingClick(exitHeaderFooterMode);
  const headerFooterIdentifier = extractIdentifierFromConverter(converter);
  const headerFooterManager = new HeaderFooterEditorManager(editor);
  const headerFooterAdapter = new HeaderFooterLayoutAdapter(
    headerFooterManager,
    mediaFiles
  );
  const cleanups = [];
  const handleContentChange = ({ descriptor }) => {
    headerFooterAdapter.invalidate(descriptor.id);
    requestRerender();
  };
  headerFooterManager.on("contentChanged", handleContentChange);
  cleanups.push(() => {
    headerFooterManager.off("contentChanged", handleContentChange);
  });
  const duration = performance.now() - startTime;
  if (isDebug && duration > initBudgetMs) {
    console.warn(
      `[PresentationEditor] Header/footer initialization took ${duration.toFixed(2)}ms (budget: ${initBudgetMs}ms)`
    );
  }
  return {
    overlayManager,
    headerFooterIdentifier,
    headerFooterManager,
    headerFooterAdapter,
    cleanups
  };
}
function calculateRotatedBounds(input) {
  const width = Math.max(0, input.width);
  const height = Math.max(0, input.height);
  const theta = degToRad(input.rotation ?? 0);
  const cos = Math.cos(theta);
  const sin = Math.sin(theta);
  const rotatedWidth = Math.abs(width * cos) + Math.abs(height * sin);
  const rotatedHeight = Math.abs(width * sin) + Math.abs(height * cos);
  return {
    width: rotatedWidth,
    height: rotatedHeight
  };
}
function normalizeRotation(rotation) {
  if (!Number.isFinite(rotation)) {
    return 0;
  }
  let normalized = rotation % 360;
  if (normalized < 0) {
    normalized += 360;
  }
  return normalized;
}
function degToRad(degrees) {
  return degrees * Math.PI / 180;
}
const defaultMaxSize = 5e3;
let maxSize = defaultMaxSize;
const cache$2 = /* @__PURE__ */ new Map();
const makeKey = (text, font, letterSpacing) => {
  return `${text}|${font}|${letterSpacing || 0}`;
};
function getMeasuredTextWidth(text, font, letterSpacing, ctx2) {
  if (text.length > 32e3) {
    text = text.substring(0, 32e3);
  }
  const key2 = makeKey(text, font, letterSpacing);
  const hit = cache$2.get(key2);
  if (hit !== void 0) {
    cache$2.delete(key2);
    cache$2.set(key2, hit);
    return hit.width;
  }
  try {
    ctx2.font = font;
    const metrics = ctx2.measureText(text);
    const baseWidth = metrics.width;
    const extra = letterSpacing ? Math.max(0, text.length - 1) * letterSpacing : 0;
    const width = baseWidth + extra;
    cache$2.set(key2, { width });
    evictIfNeeded();
    return width;
  } catch {
    return 0;
  }
}
function evictIfNeeded() {
  while (cache$2.size > maxSize) {
    const oldestKey = cache$2.keys().next().value;
    if (oldestKey === void 0) break;
    cache$2.delete(oldestKey);
  }
}
const fontMetricsCache = /* @__PURE__ */ new Map();
const MAX_CACHE_SIZE = 1e3;
const METRICS_TEST_STRING = "MHgypbdl";
function getFontKey(fontInfo) {
  return `${fontInfo.fontFamily}|${fontInfo.fontSize}|${fontInfo.bold ?? false}|${fontInfo.italic ?? false}`;
}
function buildFontStringForMetrics(fontInfo, mode, fonts) {
  const parts = [];
  if (fontInfo.italic) parts.push("italic");
  if (fontInfo.bold) parts.push("bold");
  parts.push(`${fontInfo.fontSize}px`);
  {
    parts.push(fontInfo.fontFamily);
  }
  return parts.join(" ");
}
function getFontMetrics(ctx2, fontInfo, mode, fonts) {
  if (!ctx2 || typeof ctx2 !== "object") {
    throw new TypeError("Canvas context must be a valid CanvasRenderingContext2D object");
  }
  if (typeof fontInfo.fontSize !== "number" || !Number.isFinite(fontInfo.fontSize) || fontInfo.fontSize <= 0) {
    throw new TypeError(
      `Font size must be a positive finite number, got: ${typeof fontInfo.fontSize === "number" ? fontInfo.fontSize : typeof fontInfo.fontSize}`
    );
  }
  if (typeof fontInfo.fontFamily !== "string" || fontInfo.fontFamily.trim().length === 0) {
    throw new TypeError("Font family must be a non-empty string");
  }
  const key2 = getFontKey(fontInfo);
  const cached = fontMetricsCache.get(key2);
  if (cached) {
    return cached;
  }
  const font = buildFontStringForMetrics(fontInfo);
  ctx2.font = font;
  const textMetrics = ctx2.measureText(METRICS_TEST_STRING);
  let ascent;
  let descent;
  if (typeof textMetrics.actualBoundingBoxAscent === "number" && typeof textMetrics.actualBoundingBoxDescent === "number" && textMetrics.actualBoundingBoxAscent > 0) {
    ascent = textMetrics.actualBoundingBoxAscent;
    descent = textMetrics.actualBoundingBoxDescent;
  } else {
    ascent = fontInfo.fontSize * 0.8;
    descent = fontInfo.fontSize * 0.2;
  }
  const result = { ascent, descent };
  if (fontMetricsCache.size >= MAX_CACHE_SIZE) {
    const firstKey = fontMetricsCache.keys().next().value;
    if (firstKey) {
      fontMetricsCache.delete(firstKey);
    }
  }
  fontMetricsCache.set(key2, result);
  return result;
}
const { computeTabStops } = Engines;
let canvasContext = null;
const DEFAULT_TAB_INTERVAL_TWIPS = 720;
const TWIPS_PER_INCH = 1440;
const PX_PER_INCH = 96;
const TWIPS_PER_PX = TWIPS_PER_INCH / PX_PER_INCH;
const twipsToPx = (twips) => twips / TWIPS_PER_PX;
const pxToTwips = (px) => Math.round(px * TWIPS_PER_PX);
const DEFAULT_TAB_INTERVAL_PX = twipsToPx(DEFAULT_TAB_INTERVAL_TWIPS);
const TAB_EPSILON = 0.1;
const DEFAULT_DECIMAL_SEPARATOR = ".";
const ALLOWED_TAB_VALS = /* @__PURE__ */ new Set(["start", "center", "end", "decimal", "bar", "clear"]);
const FIELD_ANNOTATION_PILL_PADDING = 8;
const FIELD_ANNOTATION_LINE_HEIGHT_MULTIPLIER = 1.2;
const FIELD_ANNOTATION_VERTICAL_PADDING = 6;
const DEFAULT_FIELD_ANNOTATION_FONT_SIZE = 16;
const DEFAULT_PARAGRAPH_FONT_SIZE = 12;
const DEFAULT_PARAGRAPH_FONT_FAMILY = "Arial";
const isValidFontSize = (value) => typeof value === "number" && Number.isFinite(value) && value > 0;
const normalizeFontSize = (value, fallback = DEFAULT_PARAGRAPH_FONT_SIZE) => {
  if (isValidFontSize(value)) return value;
  if (typeof value === "string") {
    const parsed = parseFloat(value);
    if (isValidFontSize(parsed)) return parsed;
  }
  return fallback;
};
const normalizeFontFamily = (value, fallback = DEFAULT_PARAGRAPH_FONT_FAMILY) => typeof value === "string" && value.trim().length > 0 ? value : fallback;
const roundValue = (value) => value;
function getCanvasContext() {
  if (!canvasContext) {
    const canvas2 = typeof document !== "undefined" ? document.createElement("canvas") : null;
    if (!canvas2) {
      throw new Error("Canvas not available. Ensure this runs in a DOM environment (browser or jsdom).");
    }
    canvasContext = canvas2.getContext("2d");
    if (!canvasContext) {
      throw new Error("Failed to get 2D context from canvas");
    }
  }
  return canvasContext;
}
function buildFontString(run) {
  const parts = [];
  if (run.italic) parts.push("italic");
  if (run.bold) parts.push("bold");
  parts.push(`${run.fontSize}px`);
  {
    parts.push(run.fontFamily);
  }
  return {
    font: parts.join(" "),
    fontFamily: run.fontFamily
  };
}
function measureText(text, font, ctx2, _fontFamily, _letterSpacing) {
  ctx2.font = font;
  const metrics = ctx2.measureText(text);
  const advanceWidth = metrics.width;
  const paintedWidth = (metrics.actualBoundingBoxLeft || 0) + (metrics.actualBoundingBoxRight || 0);
  return Math.max(advanceWidth, paintedWidth);
}
const WORD_SINGLE_LINE_SPACING_MULTIPLIER = 1.15;
function calculateTypographyMetrics(fontSize2, spacing, fontInfo) {
  const resolvedFontSize = normalizeFontSize(fontSize2);
  let ascent;
  let descent;
  if (fontInfo && isValidFontSize(fontInfo.fontSize) && typeof fontInfo.fontFamily === "string" && fontInfo.fontFamily.trim().length > 0) {
    const ctx2 = getCanvasContext();
    const metrics = getFontMetrics(ctx2, fontInfo);
    ascent = roundValue(metrics.ascent);
    descent = roundValue(metrics.descent);
  } else {
    ascent = roundValue(resolvedFontSize * 0.8);
    descent = roundValue(resolvedFontSize * 0.2);
  }
  const baseLineHeight = Math.max(resolvedFontSize * WORD_SINGLE_LINE_SPACING_MULTIPLIER, ascent + descent);
  const lineHeight2 = roundValue(resolveLineHeight(spacing, baseLineHeight));
  return {
    ascent,
    descent,
    lineHeight: lineHeight2
  };
}
function calculateEmptyParagraphMetrics(fontSize2, spacing, fontInfo) {
  const resolvedFontSize = normalizeFontSize(fontSize2);
  let ascent;
  let descent;
  if (fontInfo && isValidFontSize(fontInfo.fontSize) && typeof fontInfo.fontFamily === "string" && fontInfo.fontFamily.trim().length > 0) {
    const ctx2 = getCanvasContext();
    const metrics = getFontMetrics(ctx2, fontInfo);
    ascent = roundValue(metrics.ascent);
    descent = roundValue(metrics.descent);
  } else {
    ascent = roundValue(resolvedFontSize * 0.8);
    descent = roundValue(resolvedFontSize * 0.2);
  }
  const baseLineHeight = Math.max(resolvedFontSize, ascent + descent);
  const lineHeight2 = roundValue(resolveLineHeight(spacing, baseLineHeight));
  return {
    ascent,
    descent,
    lineHeight: lineHeight2
  };
}
function getFontInfoFromRun(run) {
  return {
    fontFamily: normalizeFontFamily(run.fontFamily),
    fontSize: normalizeFontSize(run.fontSize),
    bold: run.bold,
    italic: run.italic
  };
}
function updateMaxFontInfo(currentMaxSize, currentMaxInfo, newRun) {
  if (newRun.fontSize >= currentMaxSize) {
    return getFontInfoFromRun(newRun);
  }
  return currentMaxInfo;
}
function isTextRun(run) {
  return run.kind === "text" || run.kind === void 0;
}
function isTabRun(run) {
  return run.kind === "tab";
}
function isImageRun(run) {
  return run.kind === "image";
}
function isLineBreakRun(run) {
  return run.kind === "lineBreak";
}
const isEmptyTextRun = (run) => {
  if (run.kind && run.kind !== "text") return false;
  return typeof run.text === "string" && run.text.length === 0;
};
function isFieldAnnotationRun(run) {
  return run.kind === "fieldAnnotation";
}
const normalizeRunsForMeasurement = (runs, fallbackFontSize, fallbackFontFamily) => runs.map((run) => {
  if (run.kind && run.kind !== "text") return run;
  if (!("text" in run)) return run;
  const textRun = run;
  const fontSize2 = normalizeFontSize(textRun.fontSize, fallbackFontSize);
  const fontFamily2 = normalizeFontFamily(textRun.fontFamily, fallbackFontFamily);
  if (fontSize2 === textRun.fontSize && fontFamily2 === textRun.fontFamily) return run;
  return { ...textRun, fontSize: fontSize2, fontFamily: fontFamily2 };
});
function measureTabAlignmentGroup(startRunIndex, runs, ctx2, decimalSeparator = ".") {
  const result = {
    totalWidth: 0,
    runs: [],
    endRunIndex: runs.length
  };
  let foundDecimal = false;
  for (let i = startRunIndex; i < runs.length; i++) {
    const run = runs[i];
    if (isTabRun(run)) {
      result.endRunIndex = i;
      break;
    }
    if (isLineBreakRun(run) || run.kind === "break" && run.breakType === "line") {
      result.endRunIndex = i;
      break;
    }
    if (run.kind === "text" || run.kind === void 0) {
      const textRun = run;
      const text = textRun.text || "";
      if (text.length > 0) {
        const { font } = buildFontString(textRun);
        const width = measureRunWidth(text, font, ctx2, textRun, 0);
        let beforeDecimalWidth;
        if (!foundDecimal) {
          const decimalIdx = text.indexOf(decimalSeparator);
          if (decimalIdx >= 0) {
            foundDecimal = true;
            const beforeText = text.slice(0, decimalIdx);
            beforeDecimalWidth = beforeText.length > 0 ? measureRunWidth(beforeText, font, ctx2, textRun, 0) : 0;
            result.beforeDecimalWidth = result.totalWidth + beforeDecimalWidth;
          }
        }
        result.runs.push({
          runIndex: i,
          width,
          text,
          beforeDecimalWidth
        });
        result.totalWidth += width;
      } else {
        result.runs.push({ runIndex: i, width: 0, text: "" });
      }
      continue;
    }
    if (isImageRun(run)) {
      const leftSpace = run.distLeft ?? 0;
      const rightSpace = run.distRight ?? 0;
      const imageWidth = run.width + leftSpace + rightSpace;
      result.runs.push({ runIndex: i, width: imageWidth });
      result.totalWidth += imageWidth;
      continue;
    }
    if (isFieldAnnotationRun(run)) {
      const fontSize2 = run.fontSize ?? DEFAULT_FIELD_ANNOTATION_FONT_SIZE;
      const { font } = buildFontString({
        fontFamily: run.fontFamily ?? "Arial",
        fontSize: fontSize2,
        bold: run.bold,
        italic: run.italic
      });
      const textWidth = run.displayLabel ? measureRunWidth(run.displayLabel, font, ctx2, run, 0) : 0;
      const pillWidth = textWidth + FIELD_ANNOTATION_PILL_PADDING;
      result.runs.push({ runIndex: i, width: pillWidth });
      result.totalWidth += pillWidth;
      continue;
    }
    result.runs.push({ runIndex: i, width: 0 });
  }
  return result;
}
async function measureBlock(block, constraints) {
  const normalized = normalizeConstraints(constraints);
  if (block.kind === "drawing") {
    return measureDrawingBlock(block, normalized);
  }
  if (block.kind === "image") {
    return measureImageBlock(block, normalized);
  }
  if (block.kind === "list") {
    return measureListBlock(block, normalized);
  }
  if (block.kind === "table") {
    return measureTableBlock(block, normalized);
  }
  if (block.kind === "sectionBreak") {
    return { kind: "sectionBreak" };
  }
  if (block.kind === "pageBreak") {
    return { kind: "pageBreak" };
  }
  if (block.kind === "columnBreak") {
    return { kind: "columnBreak" };
  }
  return measureParagraphBlock(block, normalized.maxWidth);
}
async function measureParagraphBlock(block, maxWidth) {
  const ctx2 = getCanvasContext();
  const wordLayout = block.attrs?.wordLayout;
  const firstTextRunWithSize = block.runs.find(
    (run) => isTextRun(run) && "fontSize" in run && run.fontSize != null
  );
  const fallbackFontSize = normalizeFontSize(firstTextRunWithSize?.fontSize, DEFAULT_PARAGRAPH_FONT_SIZE);
  const firstTextRunWithFont = block.runs.find(
    (run) => isTextRun(run) && typeof run.fontFamily === "string" && run.fontFamily.trim().length > 0
  );
  const fallbackFontFamily = firstTextRunWithFont?.fontFamily ?? DEFAULT_PARAGRAPH_FONT_FAMILY;
  const normalizedRuns = normalizeRunsForMeasurement(block.runs, fallbackFontSize, fallbackFontFamily);
  const markerInfo = wordLayout?.marker ? (() => {
    const markerRun = {
      fontFamily: toCssFontFamily(wordLayout.marker.run.fontFamily) ?? wordLayout.marker.run.fontFamily,
      fontSize: wordLayout.marker.run.fontSize ?? fallbackFontSize,
      bold: wordLayout.marker.run.bold,
      italic: wordLayout.marker.run.italic
    };
    const { font: markerFont } = buildFontString(markerRun);
    const markerText = wordLayout.marker.markerText ?? "";
    const glyphWidth = markerText ? measureText(markerText, markerFont, ctx2) : 0;
    const gutter = typeof wordLayout.marker.gutterWidthPx === "number" && isFinite(wordLayout.marker.gutterWidthPx) && wordLayout.marker.gutterWidthPx >= 0 ? wordLayout.marker.gutterWidthPx : LIST_MARKER_GAP;
    const markerBoxWidth = Math.max(0, glyphWidth + LIST_MARKER_GAP);
    return {
      markerWidth: markerBoxWidth,
      markerTextWidth: glyphWidth,
      indentLeft: wordLayout.indentLeftPx ?? 0,
      // For tab sizing in the renderer: expose gutter for word-layout lists
      gutterWidth: gutter
    };
  })() : void 0;
  const WIDTH_FUDGE_PX2 = 0.5;
  const lines = [];
  const indent = block.attrs?.indent;
  const spacing = block.attrs?.spacing;
  const indentLeft = sanitizeIndent(indent?.left);
  const indentRight = sanitizeIndent(indent?.right);
  const firstLine = indent?.firstLine ?? 0;
  const hanging = indent?.hanging ?? 0;
  const isWordLayoutList = Boolean(wordLayout?.marker);
  const suppressFirstLine = block.attrs?.suppressFirstLineIndent === true;
  const rawFirstLineOffset = suppressFirstLine ? 0 : firstLine - hanging;
  const clampedFirstLineOffset = Math.max(0, rawFirstLineOffset);
  const hasNegativeIndent = indentLeft < 0 || indentRight < 0;
  const allowNegativeFirstLineOffset = !isWordLayoutList && !hasNegativeIndent && rawFirstLineOffset < 0;
  const firstLineOffset = isWordLayoutList ? 0 : allowNegativeFirstLineOffset ? rawFirstLineOffset : clampedFirstLineOffset;
  const contentWidth = Math.max(1, maxWidth - indentLeft - indentRight);
  const bodyContentWidth = contentWidth;
  let initialAvailableWidth;
  const rawTextStartPx = wordLayout?.textStartPx;
  const markerTextStartX = wordLayout?.marker?.textStartX;
  const textStartPx = typeof markerTextStartX === "number" && Number.isFinite(markerTextStartX) ? markerTextStartX : typeof rawTextStartPx === "number" && Number.isFinite(rawTextStartPx) ? rawTextStartPx : void 0;
  const resolvedTextStartPx = resolveListTextStartPx(
    wordLayout,
    indentLeft,
    firstLine,
    hanging,
    (markerText, marker) => {
      const markerRun = {
        fontFamily: toCssFontFamily(marker.run?.fontFamily) ?? marker.run?.fontFamily ?? "Arial",
        fontSize: marker.run?.fontSize ?? fallbackFontSize,
        bold: marker.run?.bold ?? false,
        italic: marker.run?.italic ?? false
      };
      const { font: markerFont } = buildFontString(markerRun);
      return measureText(markerText, markerFont, ctx2);
    }
  );
  const effectiveTextStartPx = resolvedTextStartPx ?? textStartPx;
  if (typeof effectiveTextStartPx === "number" && effectiveTextStartPx > indentLeft) {
    initialAvailableWidth = Math.max(1, maxWidth - effectiveTextStartPx - indentRight);
  } else {
    initialAvailableWidth = Math.max(1, contentWidth - firstLineOffset);
  }
  const tabStops = buildTabStopsPx(
    indent,
    block.attrs?.tabs,
    block.attrs?.tabIntervalTwips
  );
  const decimalSeparator = sanitizeDecimalSeparator(block.attrs?.decimalSeparator);
  const barTabStops = tabStops.filter((stop) => stop.val === "bar");
  const addBarTabsToLine = (line) => {
    if (barTabStops.length > 0) {
      line.bars = barTabStops.map((stop) => ({ x: stop.pos }));
    }
  };
  const dropCapDescriptor = block.attrs?.dropCapDescriptor;
  let dropCapMeasure = null;
  if (dropCapDescriptor) {
    if (!dropCapDescriptor.run || !dropCapDescriptor.run.text || !dropCapDescriptor.lines) {
      console.warn("Invalid drop cap descriptor - missing required fields:", dropCapDescriptor);
    } else {
      const dropCapMeasured = measureDropCap(ctx2, dropCapDescriptor, spacing);
      dropCapMeasure = dropCapMeasured;
      dropCapDescriptor.measuredWidth = dropCapMeasured.width;
      dropCapDescriptor.measuredHeight = dropCapMeasured.height;
    }
  }
  const emptyParagraphRun = normalizedRuns.length === 1 && isEmptyTextRun(normalizedRuns[0]) ? normalizedRuns[0] : null;
  if (emptyParagraphRun) {
    const fontSize2 = emptyParagraphRun.fontSize ?? DEFAULT_PARAGRAPH_FONT_SIZE;
    const metrics = calculateEmptyParagraphMetrics(fontSize2, spacing, getFontInfoFromRun(emptyParagraphRun));
    const emptyLine = {
      fromRun: 0,
      fromChar: 0,
      toRun: 0,
      toChar: 0,
      width: 0,
      ...metrics
    };
    addBarTabsToLine(emptyLine);
    lines.push(emptyLine);
    return {
      kind: "paragraph",
      lines,
      totalHeight: metrics.lineHeight,
      ...markerInfo ? { marker: markerInfo } : {}
    };
  }
  if (normalizedRuns.length === 0) {
    const metrics = calculateEmptyParagraphMetrics(DEFAULT_PARAGRAPH_FONT_SIZE, spacing);
    const emptyLine = {
      fromRun: 0,
      fromChar: 0,
      toRun: 0,
      toChar: 0,
      width: 0,
      ...metrics
    };
    addBarTabsToLine(emptyLine);
    lines.push(emptyLine);
    return {
      kind: "paragraph",
      lines,
      totalHeight: metrics.lineHeight,
      ...markerInfo ? { marker: markerInfo } : {}
    };
  }
  const fallbackFontInfo = firstTextRunWithSize ? getFontInfoFromRun(firstTextRunWithSize) : void 0;
  let currentLine = null;
  const getEffectiveWidth = (baseWidth) => {
    if (dropCapMeasure && lines.length < dropCapMeasure.lines && dropCapMeasure.mode === "drop") {
      return Math.max(1, baseWidth - dropCapMeasure.width);
    }
    return baseWidth;
  };
  let lastFontSize = fallbackFontSize;
  let hasSeenTextRun = false;
  let tabStopCursor = 0;
  let pendingTabAlignment = null;
  let pendingRunSpacing = 0;
  let lastAppliedTabAlign = null;
  const warnedTabVals = /* @__PURE__ */ new Set();
  let activeTabGroup = null;
  const validateTabStopVal = (stop) => {
    if (!ALLOWED_TAB_VALS.has(stop.val) && !warnedTabVals.has(stop.val)) {
      warnedTabVals.add(stop.val);
      return false;
    }
    return true;
  };
  const resolveBoundarySpacing = (lineWidth, isRunStart, run) => {
    if (lineWidth <= 0) return 0;
    return isRunStart ? pendingRunSpacing : run.letterSpacing ?? 0;
  };
  const alignPendingTabForWidth = (segmentWidth, beforeDecimalWidth) => {
    if (!pendingTabAlignment || !currentLine) return void 0;
    if (segmentWidth < 0) {
      segmentWidth = 0;
    }
    const { target, val } = pendingTabAlignment;
    let startX = currentLine.width;
    if (val === "decimal") {
      const beforeWidth = beforeDecimalWidth ?? 0;
      startX = Math.max(0, target - beforeWidth);
    } else if (val === "end") {
      startX = Math.max(0, target - segmentWidth);
    } else if (val === "center") {
      startX = Math.max(0, target - segmentWidth / 2);
    } else {
      startX = Math.max(0, target);
    }
    currentLine.width = roundValue(startX);
    lastAppliedTabAlign = { target, val };
    pendingTabAlignment = null;
    return startX;
  };
  const alignSegmentAtTab = (segmentText, font, runContext, segmentStartChar) => {
    if (!pendingTabAlignment || !currentLine) return void 0;
    const { val } = pendingTabAlignment;
    let segmentWidth = 0;
    let beforeDecimalWidth;
    if (val === "decimal") {
      const idx = segmentText.indexOf(decimalSeparator);
      if (idx >= 0) {
        const beforeText = segmentText.slice(0, idx);
        beforeDecimalWidth = beforeText.length > 0 ? measureRunWidth(beforeText, font, ctx2, runContext, segmentStartChar) : 0;
      }
      segmentWidth = segmentText.length > 0 ? measureRunWidth(segmentText, font, ctx2, runContext, segmentStartChar) : 0;
    } else if (val === "end" || val === "center") {
      segmentWidth = segmentText.length > 0 ? measureRunWidth(segmentText, font, ctx2, runContext, segmentStartChar) : 0;
    }
    return alignPendingTabForWidth(segmentWidth, beforeDecimalWidth);
  };
  const runsToProcess = [];
  for (const run of normalizedRuns) {
    if (run.text && typeof run.text === "string" && run.text.includes("\n")) {
      const textRun = run;
      const segments = textRun.text.split("\n");
      let cursor = textRun.pmStart ?? 0;
      segments.forEach((seg, idx) => {
        runsToProcess.push({
          ...textRun,
          text: seg,
          pmStart: cursor,
          pmEnd: cursor + seg.length
        });
        cursor += seg.length;
        if (idx !== segments.length - 1) {
          runsToProcess.push({
            kind: "break",
            breakType: "line",
            pmStart: cursor,
            pmEnd: cursor + 1,
            sdt: run.sdt
          });
          cursor += 1;
        }
      });
    } else {
      runsToProcess.push(run);
    }
  }
  const trimTrailingWrapSpaces = (lineToTrim) => {
    const lastRun = runsToProcess[lineToTrim.toRun];
    if (!lastRun || !("text" in lastRun) || typeof lastRun.text !== "string") return;
    const sliceStart = lineToTrim.toRun === lineToTrim.fromRun ? lineToTrim.fromChar : 0;
    const sliceEnd = lineToTrim.toChar;
    if (sliceEnd <= sliceStart) return;
    const sliceText = lastRun.text.slice(sliceStart, sliceEnd);
    let trimCount = 0;
    for (let i = sliceText.length - 1; i >= 0 && sliceText[i] === " "; i -= 1) {
      trimCount += 1;
    }
    if (trimCount === 0) return;
    if (lineToTrim.fromRun === lineToTrim.toRun && sliceText.trim().length === 0) {
      return;
    }
    const keptText = sliceText.slice(0, Math.max(0, sliceText.length - trimCount));
    const { font } = buildFontString(
      lastRun
    );
    const fullWidth = measureRunWidth(sliceText, font, ctx2, lastRun, sliceStart);
    const keptWidth = keptText.length > 0 ? measureRunWidth(keptText, font, ctx2, lastRun, sliceStart) : 0;
    const delta = Math.max(0, fullWidth - keptWidth);
    lineToTrim.width = roundValue(Math.max(0, lineToTrim.width - delta));
    lineToTrim.spaceCount = Math.max(0, lineToTrim.spaceCount - trimCount);
    if (lineToTrim.naturalWidth != null && typeof lineToTrim.naturalWidth === "number") {
      lineToTrim.naturalWidth = roundValue(Math.max(0, lineToTrim.naturalWidth - delta));
    }
  };
  for (let runIndex = 0; runIndex < runsToProcess.length; runIndex++) {
    const run = runsToProcess[runIndex];
    if (run.kind === "break") {
      if (currentLine) {
        const metrics = calculateTypographyMetrics(currentLine.maxFontSize, spacing, currentLine.maxFontInfo);
        const lineBase = currentLine;
        const completedLine = { ...lineBase, ...metrics };
        addBarTabsToLine(completedLine);
        lines.push(completedLine);
        currentLine = null;
      } else {
        const metrics = calculateTypographyMetrics(fallbackFontSize, spacing, fallbackFontInfo);
        const emptyLine = {
          fromRun: runIndex,
          fromChar: 0,
          toRun: runIndex,
          toChar: 0,
          width: 0,
          segments: [],
          ...metrics
        };
        addBarTabsToLine(emptyLine);
        lines.push(emptyLine);
      }
      tabStopCursor = 0;
      pendingTabAlignment = null;
      lastAppliedTabAlign = null;
      pendingRunSpacing = 0;
      continue;
    }
    if (isLineBreakRun(run)) {
      const lineBreakFontInfo = hasSeenTextRun ? void 0 : fallbackFontInfo;
      if (currentLine) {
        const metrics = calculateTypographyMetrics(currentLine.maxFontSize, spacing, currentLine.maxFontInfo);
        const completedLine = {
          ...currentLine,
          ...metrics
        };
        addBarTabsToLine(completedLine);
        lines.push(completedLine);
      } else {
        const metrics = calculateTypographyMetrics(lastFontSize, spacing, lineBreakFontInfo);
        const emptyLine = {
          fromRun: runIndex,
          fromChar: 0,
          toRun: runIndex,
          toChar: 0,
          width: 0,
          maxWidth: getEffectiveWidth(lines.length === 0 ? initialAvailableWidth : bodyContentWidth),
          segments: [],
          ...metrics
        };
        addBarTabsToLine(emptyLine);
        lines.push(emptyLine);
      }
      const hadPreviousLine = lines.length > 0;
      const nextLineMaxWidth = hadPreviousLine ? getEffectiveWidth(bodyContentWidth) : getEffectiveWidth(initialAvailableWidth);
      currentLine = {
        fromRun: runIndex,
        fromChar: 0,
        toRun: runIndex,
        toChar: 0,
        width: 0,
        maxFontSize: lastFontSize,
        maxFontInfo: lineBreakFontInfo,
        maxWidth: nextLineMaxWidth,
        segments: [],
        spaceCount: 0
      };
      tabStopCursor = 0;
      pendingTabAlignment = null;
      lastAppliedTabAlign = null;
      pendingRunSpacing = 0;
      continue;
    }
    if (isTabRun(run)) {
      activeTabGroup = null;
      if (!currentLine) {
        currentLine = {
          fromRun: runIndex,
          fromChar: 0,
          toRun: runIndex,
          toChar: 1,
          width: 0,
          maxFontSize: 12,
          // Default font size for tabs
          maxWidth: getEffectiveWidth(lines.length === 0 ? initialAvailableWidth : bodyContentWidth),
          segments: [],
          spaceCount: 0
        };
      }
      const originX = currentLine.width;
      const effectiveIndent = lines.length === 0 ? indentLeft + rawFirstLineOffset : indentLeft;
      const absCurrentX = currentLine.width + effectiveIndent;
      const { target, nextIndex, stop } = getNextTabStopPx(absCurrentX, tabStops, tabStopCursor);
      tabStopCursor = nextIndex;
      const maxAbsWidth = currentLine.maxWidth + effectiveIndent;
      const clampedTarget = Math.min(target, maxAbsWidth);
      const tabAdvance = Math.max(0, clampedTarget - absCurrentX);
      currentLine.width = roundValue(currentLine.width + tabAdvance);
      run.width = tabAdvance;
      currentLine.maxFontSize = Math.max(currentLine.maxFontSize, 12);
      currentLine.toRun = runIndex;
      currentLine.toChar = 1;
      if (stop && stop.leader && stop.leader !== "none") {
        const leaderStyle = stop.leader;
        const relativeTarget = clampedTarget - effectiveIndent;
        const from3 = Math.min(originX, relativeTarget);
        const to = Math.max(originX, relativeTarget);
        if (!currentLine.leaders) currentLine.leaders = [];
        currentLine.leaders.push({ from: from3, to, style: leaderStyle });
      }
      if (stop) {
        validateTabStopVal(stop);
        if (stop.val === "end" || stop.val === "center" || stop.val === "decimal") {
          const groupMeasure = measureTabAlignmentGroup(runIndex + 1, runsToProcess, ctx2, decimalSeparator);
          if (groupMeasure.totalWidth > 0) {
            const relativeTarget = clampedTarget - effectiveIndent;
            let groupStartX;
            if (stop.val === "end") {
              groupStartX = Math.max(0, relativeTarget - groupMeasure.totalWidth);
            } else if (stop.val === "center") {
              groupStartX = Math.max(0, relativeTarget - groupMeasure.totalWidth / 2);
            } else {
              const beforeDecimal = groupMeasure.beforeDecimalWidth ?? groupMeasure.totalWidth;
              groupStartX = Math.max(0, relativeTarget - beforeDecimal);
            }
            activeTabGroup = {
              measure: groupMeasure,
              startX: groupStartX,
              currentX: groupStartX,
              target: relativeTarget,
              val: stop.val
            };
            currentLine.width = roundValue(groupStartX);
          }
          pendingTabAlignment = null;
        } else {
          pendingTabAlignment = { target: clampedTarget - effectiveIndent, val: stop.val };
        }
      } else {
        pendingTabAlignment = null;
      }
      pendingRunSpacing = 0;
      continue;
    }
    if (isImageRun(run)) {
      const leftSpace = run.distLeft ?? 0;
      const rightSpace = run.distRight ?? 0;
      const imageWidth = run.width + leftSpace + rightSpace;
      const topSpace = run.distTop ?? 0;
      const bottomSpace = run.distBottom ?? 0;
      const imageHeight = run.height + topSpace + bottomSpace;
      let imageStartX;
      if (activeTabGroup && currentLine) {
        imageStartX = activeTabGroup.currentX;
        activeTabGroup.currentX = roundValue(activeTabGroup.currentX + imageWidth);
      } else if (pendingTabAlignment && currentLine) {
        imageStartX = alignPendingTabForWidth(imageWidth);
      }
      if (!currentLine) {
        currentLine = {
          fromRun: runIndex,
          fromChar: 0,
          toRun: runIndex,
          toChar: 1,
          // Images are treated as single atomic units
          width: imageWidth,
          maxFontSize: imageHeight,
          // Use image height for line height calculation
          maxWidth: getEffectiveWidth(lines.length === 0 ? initialAvailableWidth : bodyContentWidth),
          spaceCount: 0,
          segments: [
            {
              runIndex,
              fromChar: 0,
              toChar: 1,
              width: imageWidth,
              ...imageStartX !== void 0 ? { x: imageStartX } : {}
            }
          ]
        };
        pendingRunSpacing = 0;
        if (activeTabGroup && runIndex + 1 >= activeTabGroup.measure.endRunIndex) {
          activeTabGroup = null;
        }
        continue;
      }
      const appliedTabAlign = lastAppliedTabAlign;
      const skipFitCheck = activeTabGroup !== null;
      if (!skipFitCheck && currentLine.width + imageWidth > currentLine.maxWidth && currentLine.width > 0) {
        trimTrailingWrapSpaces(currentLine);
        const metrics = calculateTypographyMetrics(currentLine.maxFontSize, spacing, currentLine.maxFontInfo);
        const lineBase = currentLine;
        const completedLine = {
          ...lineBase,
          ...metrics
        };
        addBarTabsToLine(completedLine);
        lines.push(completedLine);
        tabStopCursor = 0;
        pendingTabAlignment = null;
        lastAppliedTabAlign = null;
        activeTabGroup = null;
        currentLine = {
          fromRun: runIndex,
          fromChar: 0,
          toRun: runIndex,
          toChar: 1,
          width: imageWidth,
          maxFontSize: imageHeight,
          maxWidth: getEffectiveWidth(bodyContentWidth),
          spaceCount: 0,
          segments: [
            {
              runIndex,
              fromChar: 0,
              toChar: 1,
              width: imageWidth
            }
          ]
        };
      } else {
        currentLine.toRun = runIndex;
        currentLine.toChar = 1;
        currentLine.width = roundValue(currentLine.width + imageWidth);
        currentLine.maxFontSize = Math.max(currentLine.maxFontSize, imageHeight);
        if (!currentLine.segments) currentLine.segments = [];
        currentLine.segments.push({
          runIndex,
          fromChar: 0,
          toChar: 1,
          width: imageWidth,
          ...imageStartX !== void 0 ? { x: imageStartX } : {}
        });
      }
      if (activeTabGroup && runIndex + 1 >= activeTabGroup.measure.endRunIndex) {
        activeTabGroup = null;
      }
      const tabAlign = appliedTabAlign;
      if (tabAlign && currentLine && tabAlign.val === "end") {
        currentLine.width = roundValue(tabAlign.target);
      }
      lastAppliedTabAlign = null;
      pendingRunSpacing = 0;
      continue;
    }
    if (isFieldAnnotationRun(run)) {
      const rawDisplayText = run.displayLabel || "";
      const displayText = applyTextTransform(rawDisplayText, run);
      const annotationFontSize = typeof run.fontSize === "number" ? run.fontSize : typeof run.fontSize === "string" ? parseFloat(run.fontSize) || DEFAULT_FIELD_ANNOTATION_FONT_SIZE : DEFAULT_FIELD_ANNOTATION_FONT_SIZE;
      const annotationFontFamily = run.fontFamily || "Arial, sans-serif";
      const fontWeight = run.bold ? "bold" : "normal";
      const fontStyle = run.italic ? "italic" : "normal";
      const annotationFont = `${fontStyle} ${fontWeight} ${annotationFontSize}px ${annotationFontFamily}`;
      ctx2.font = annotationFont;
      const textWidth = displayText ? ctx2.measureText(displayText).width : 0;
      const annotationHorizontalPadding = run.highlighted === false ? 0 : FIELD_ANNOTATION_PILL_PADDING;
      const annotationVerticalPadding = run.highlighted === false ? 0 : FIELD_ANNOTATION_VERTICAL_PADDING;
      const annotationWidth = textWidth + annotationHorizontalPadding;
      let annotationHeight = annotationFontSize * FIELD_ANNOTATION_LINE_HEIGHT_MULTIPLIER + annotationVerticalPadding;
      if (run.variant === "signature" && run.imageSrc) {
        const signatureHeight = 28 + annotationVerticalPadding;
        annotationHeight = Math.max(annotationHeight, signatureHeight);
      }
      if (run.variant === "image" && run.imageSrc && run.size?.height) {
        const imageHeight = run.size.height + annotationVerticalPadding;
        annotationHeight = Math.max(annotationHeight, imageHeight);
      }
      if (run.variant === "html" && run.size?.height) {
        annotationHeight = Math.max(annotationHeight, run.size.height);
      }
      let annotationStartX;
      if (pendingTabAlignment && currentLine) {
        annotationStartX = alignPendingTabForWidth(annotationWidth);
      }
      if (!currentLine) {
        currentLine = {
          fromRun: runIndex,
          fromChar: 0,
          toRun: runIndex,
          toChar: 1,
          // Field annotations are atomic units
          width: annotationWidth,
          maxFontSize: annotationHeight,
          maxWidth: getEffectiveWidth(lines.length === 0 ? initialAvailableWidth : bodyContentWidth),
          spaceCount: 0,
          segments: [
            {
              runIndex,
              fromChar: 0,
              toChar: 1,
              width: annotationWidth,
              ...annotationStartX !== void 0 ? { x: annotationStartX } : {}
            }
          ]
        };
        pendingRunSpacing = 0;
        continue;
      }
      if (currentLine.width + annotationWidth > currentLine.maxWidth && currentLine.width > 0) {
        trimTrailingWrapSpaces(currentLine);
        const metrics = calculateTypographyMetrics(currentLine.maxFontSize, spacing, currentLine.maxFontInfo);
        const lineBase = currentLine;
        const completedLine = {
          ...lineBase,
          ...metrics
        };
        addBarTabsToLine(completedLine);
        lines.push(completedLine);
        tabStopCursor = 0;
        pendingTabAlignment = null;
        lastAppliedTabAlign = null;
        currentLine = {
          fromRun: runIndex,
          fromChar: 0,
          toRun: runIndex,
          toChar: 1,
          width: annotationWidth,
          maxFontSize: annotationHeight,
          maxWidth: getEffectiveWidth(bodyContentWidth),
          spaceCount: 0,
          segments: [
            {
              runIndex,
              fromChar: 0,
              toChar: 1,
              width: annotationWidth
            }
          ]
        };
      } else {
        currentLine.toRun = runIndex;
        currentLine.toChar = 1;
        currentLine.width = roundValue(currentLine.width + annotationWidth);
        currentLine.maxFontSize = Math.max(currentLine.maxFontSize, annotationHeight);
        if (!currentLine.segments) currentLine.segments = [];
        currentLine.segments.push({
          runIndex,
          fromChar: 0,
          toChar: 1,
          width: annotationWidth,
          ...annotationStartX !== void 0 ? { x: annotationStartX } : {}
        });
      }
      const tabAlign = lastAppliedTabAlign;
      if (tabAlign && currentLine && tabAlign.val === "end") {
        currentLine.width = roundValue(tabAlign.target);
      }
      lastAppliedTabAlign = null;
      pendingRunSpacing = 0;
      continue;
    }
    if (!("text" in run) || !("fontSize" in run)) {
      pendingRunSpacing = 0;
      continue;
    }
    lastFontSize = run.fontSize;
    hasSeenTextRun = true;
    const { font } = buildFontString(run);
    const tabSegments = run.text.split("	");
    let charPosInRun = 0;
    for (let segmentIndex = 0; segmentIndex < tabSegments.length; segmentIndex++) {
      const segment = tabSegments[segmentIndex];
      const isLastSegment = segmentIndex === tabSegments.length - 1;
      if (/^[ ]+$/.test(segment)) {
        const isRunStart = charPosInRun === 0 && segmentIndex === 0;
        const spacesLength = segment.length;
        const spacesStartChar = charPosInRun;
        const spacesEndChar = charPosInRun + spacesLength;
        const spacesWidth = measureRunWidth(segment, font, ctx2, run, spacesStartChar);
        if (!currentLine) {
          currentLine = {
            fromRun: runIndex,
            fromChar: spacesStartChar,
            toRun: runIndex,
            toChar: spacesEndChar,
            width: spacesWidth,
            maxFontSize: run.fontSize,
            maxFontInfo: getFontInfoFromRun(run),
            maxWidth: getEffectiveWidth(lines.length === 0 ? initialAvailableWidth : bodyContentWidth),
            segments: [{ runIndex, fromChar: spacesStartChar, toChar: spacesEndChar, width: spacesWidth }],
            spaceCount: spacesLength
          };
        } else {
          const boundarySpacing = resolveBoundarySpacing(currentLine.width, isRunStart, run);
          if (currentLine.width + boundarySpacing + spacesWidth > currentLine.maxWidth - WIDTH_FUDGE_PX2 && currentLine.width > 0) {
            trimTrailingWrapSpaces(currentLine);
            const metrics = calculateTypographyMetrics(currentLine.maxFontSize, spacing, currentLine.maxFontInfo);
            const lineBase = currentLine;
            const completedLine = {
              ...lineBase,
              ...metrics
            };
            addBarTabsToLine(completedLine);
            lines.push(completedLine);
            tabStopCursor = 0;
            pendingTabAlignment = null;
            lastAppliedTabAlign = null;
            currentLine = {
              fromRun: runIndex,
              fromChar: spacesStartChar,
              toRun: runIndex,
              toChar: spacesEndChar,
              width: spacesWidth,
              maxFontSize: run.fontSize,
              maxFontInfo: getFontInfoFromRun(run),
              maxWidth: getEffectiveWidth(bodyContentWidth),
              segments: [{ runIndex, fromChar: spacesStartChar, toChar: spacesEndChar, width: spacesWidth }],
              spaceCount: spacesLength
            };
          } else {
            currentLine.toRun = runIndex;
            currentLine.toChar = spacesEndChar;
            currentLine.width = roundValue(currentLine.width + boundarySpacing + spacesWidth);
            currentLine.maxFontInfo = updateMaxFontInfo(currentLine.maxFontSize, currentLine.maxFontInfo, run);
            currentLine.maxFontSize = Math.max(currentLine.maxFontSize, run.fontSize);
            appendSegment(currentLine.segments, runIndex, spacesStartChar, spacesEndChar, spacesWidth);
            currentLine.spaceCount += spacesLength;
          }
        }
        charPosInRun = spacesEndChar;
        continue;
      }
      const words = segment.split(" ");
      let lastNonEmptyWordIndex = -1;
      for (let i = words.length - 1; i >= 0; i -= 1) {
        if (words[i] !== "") {
          lastNonEmptyWordIndex = i;
          break;
        }
      }
      let segmentStartX;
      let inActiveTabGroup = false;
      if (activeTabGroup && currentLine) {
        segmentStartX = activeTabGroup.currentX;
        inActiveTabGroup = true;
      } else if (currentLine && pendingTabAlignment) {
        segmentStartX = alignSegmentAtTab(segment, font, run, charPosInRun);
        if (segmentStartX == null) {
          segmentStartX = currentLine.width;
        }
      }
      for (let wordIndex = 0; wordIndex < words.length; wordIndex++) {
        const word = words[wordIndex];
        if (word === "") {
          const spaceStartChar = charPosInRun;
          const spaceEndChar = charPosInRun + 1;
          const singleSpaceWidth = measureRunWidth(" ", font, ctx2, run, spaceStartChar);
          const isRunStart2 = charPosInRun === 0 && segmentIndex === 0 && wordIndex === 0;
          if (!currentLine) {
            currentLine = {
              fromRun: runIndex,
              fromChar: spaceStartChar,
              toRun: runIndex,
              toChar: spaceEndChar,
              width: singleSpaceWidth,
              maxFontSize: run.fontSize,
              maxFontInfo: getFontInfoFromRun(run),
              maxWidth: getEffectiveWidth(lines.length === 0 ? initialAvailableWidth : bodyContentWidth),
              segments: [{ runIndex, fromChar: spaceStartChar, toChar: spaceEndChar, width: singleSpaceWidth }],
              spaceCount: 1
            };
          } else {
            const boundarySpacing2 = resolveBoundarySpacing(currentLine.width, isRunStart2, run);
            if (currentLine.width + boundarySpacing2 + singleSpaceWidth > currentLine.maxWidth - WIDTH_FUDGE_PX2 && currentLine.width > 0) {
              trimTrailingWrapSpaces(currentLine);
              const metrics = calculateTypographyMetrics(currentLine.maxFontSize, spacing, currentLine.maxFontInfo);
              const lineBase = currentLine;
              const completedLine = {
                ...lineBase,
                ...metrics
              };
              addBarTabsToLine(completedLine);
              lines.push(completedLine);
              tabStopCursor = 0;
              pendingTabAlignment = null;
              lastAppliedTabAlign = null;
              activeTabGroup = null;
              currentLine = {
                fromRun: runIndex,
                fromChar: spaceStartChar,
                toRun: runIndex,
                toChar: spaceEndChar,
                width: singleSpaceWidth,
                maxFontSize: run.fontSize,
                maxFontInfo: getFontInfoFromRun(run),
                maxWidth: getEffectiveWidth(bodyContentWidth),
                segments: [{ runIndex, fromChar: spaceStartChar, toChar: spaceEndChar, width: singleSpaceWidth }],
                spaceCount: 1
              };
            } else {
              currentLine.toRun = runIndex;
              currentLine.toChar = spaceEndChar;
              currentLine.width = roundValue(currentLine.width + boundarySpacing2 + singleSpaceWidth);
              currentLine.maxFontInfo = updateMaxFontInfo(currentLine.maxFontSize, currentLine.maxFontInfo, run);
              currentLine.maxFontSize = Math.max(currentLine.maxFontSize, run.fontSize);
              let spaceExplicitX;
              if (inActiveTabGroup && activeTabGroup) {
                spaceExplicitX = activeTabGroup.currentX;
                activeTabGroup.currentX = roundValue(activeTabGroup.currentX + singleSpaceWidth);
              }
              appendSegment(
                currentLine.segments,
                runIndex,
                spaceStartChar,
                spaceEndChar,
                singleSpaceWidth,
                spaceExplicitX
              );
              currentLine.spaceCount += 1;
            }
          }
          charPosInRun = spaceEndChar;
          continue;
        }
        const wordStartChar = charPosInRun;
        const wordOnlyWidth = measureRunWidth(word, font, ctx2, run, wordStartChar);
        const shouldIncludeDelimiterSpace = wordIndex < lastNonEmptyWordIndex;
        const wordEndNoSpace = charPosInRun + word.length;
        const spaceWidth = shouldIncludeDelimiterSpace ? measureRunWidth(" ", font, ctx2, run, wordEndNoSpace) : 0;
        const wordCommitWidth = wordOnlyWidth + spaceWidth;
        const wordEndWithSpace = wordEndNoSpace + (shouldIncludeDelimiterSpace ? 1 : 0);
        const effectiveMaxWidth = currentLine ? currentLine.maxWidth : getEffectiveWidth(lines.length === 0 ? initialAvailableWidth : contentWidth);
        if (wordOnlyWidth > effectiveMaxWidth && word.length > 1) {
          if (currentLine && currentLine.width > 0 && currentLine.segments && currentLine.segments.length > 0) {
            trimTrailingWrapSpaces(currentLine);
            const metrics = calculateTypographyMetrics(currentLine.maxFontSize, spacing, currentLine.maxFontInfo);
            const lineBase = currentLine;
            const completedLine = {
              ...lineBase,
              ...metrics
            };
            addBarTabsToLine(completedLine);
            lines.push(completedLine);
            tabStopCursor = 0;
            pendingTabAlignment = null;
            currentLine = null;
          }
          const lineMaxWidth = getEffectiveWidth(lines.length === 0 ? initialAvailableWidth : contentWidth);
          const hasTabOnlyLine = currentLine && currentLine.segments && currentLine.segments.length === 0 && currentLine.width > 0;
          const remainingWidthAfterTab = hasTabOnlyLine ? currentLine.maxWidth - currentLine.width : lineMaxWidth;
          const chunkWidth = hasTabOnlyLine ? Math.max(remainingWidthAfterTab, lineMaxWidth * 0.25) : lineMaxWidth;
          const chunks = breakWordIntoChunks(word, chunkWidth - WIDTH_FUDGE_PX2, font, ctx2, run, wordStartChar);
          let chunkCharOffset = wordStartChar;
          for (let chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
            const chunk = chunks[chunkIndex];
            const chunkStartChar = chunkCharOffset;
            const chunkEndChar = chunkCharOffset + chunk.text.length;
            const isLastChunk = chunkIndex === chunks.length - 1;
            const isFirstChunk = chunkIndex === 0;
            if (isFirstChunk && hasTabOnlyLine && currentLine && currentLine.segments) {
              currentLine.toRun = runIndex;
              currentLine.toChar = chunkEndChar;
              currentLine.width = roundValue(currentLine.width + chunk.width);
              currentLine.maxFontSize = Math.max(currentLine.maxFontSize, run.fontSize);
              currentLine.maxFontInfo = getFontInfoFromRun(run);
              currentLine.segments.push({
                runIndex,
                fromChar: chunkStartChar,
                toChar: chunkEndChar,
                width: chunk.width
              });
              if (isLastChunk) {
                const ls = run.letterSpacing ?? 0;
                if (shouldIncludeDelimiterSpace && currentLine.width + spaceWidth <= currentLine.maxWidth - WIDTH_FUDGE_PX2) {
                  currentLine.toChar = wordEndWithSpace;
                  currentLine.width = roundValue(currentLine.width + spaceWidth + ls);
                  charPosInRun = wordEndWithSpace;
                  currentLine.spaceCount += 1;
                } else {
                  charPosInRun = wordEndWithSpace;
                }
              } else {
                trimTrailingWrapSpaces(currentLine);
                const metrics = calculateTypographyMetrics(currentLine.maxFontSize, spacing, currentLine.maxFontInfo);
                const lineBase = currentLine;
                const completedLine = {
                  ...lineBase,
                  ...metrics
                };
                addBarTabsToLine(completedLine);
                lines.push(completedLine);
                tabStopCursor = 0;
                pendingTabAlignment = null;
                currentLine = null;
              }
            } else if (isLastChunk) {
              currentLine = {
                fromRun: runIndex,
                fromChar: chunkStartChar,
                toRun: runIndex,
                toChar: chunkEndChar,
                width: chunk.width,
                maxFontSize: run.fontSize,
                maxFontInfo: getFontInfoFromRun(run),
                maxWidth: getEffectiveWidth(contentWidth),
                segments: [{ runIndex, fromChar: chunkStartChar, toChar: chunkEndChar, width: chunk.width }],
                spaceCount: 0
              };
              const ls = run.letterSpacing ?? 0;
              if (shouldIncludeDelimiterSpace && currentLine.width + spaceWidth <= currentLine.maxWidth - WIDTH_FUDGE_PX2) {
                currentLine.toChar = wordEndWithSpace;
                currentLine.width = roundValue(currentLine.width + spaceWidth + ls);
                charPosInRun = wordEndWithSpace;
                currentLine.spaceCount += 1;
              } else {
                charPosInRun = wordEndWithSpace;
              }
            } else {
              const chunkLineMaxWidth = getEffectiveWidth(lines.length === 0 ? initialAvailableWidth : contentWidth);
              const metrics = calculateTypographyMetrics(run.fontSize, spacing, getFontInfoFromRun(run));
              const chunkLine = {
                fromRun: runIndex,
                fromChar: chunkStartChar,
                toRun: runIndex,
                toChar: chunkEndChar,
                width: chunk.width,
                maxWidth: chunkLineMaxWidth,
                segments: [{ runIndex, fromChar: chunkStartChar, toChar: chunkEndChar, width: chunk.width }],
                ...metrics
              };
              addBarTabsToLine(chunkLine);
              lines.push(chunkLine);
            }
            chunkCharOffset = chunkEndChar;
          }
          continue;
        }
        if (!currentLine) {
          currentLine = {
            fromRun: runIndex,
            fromChar: wordStartChar,
            toRun: runIndex,
            toChar: wordEndNoSpace,
            width: wordOnlyWidth,
            maxFontSize: run.fontSize,
            maxFontInfo: getFontInfoFromRun(run),
            maxWidth: getEffectiveWidth(lines.length === 0 ? initialAvailableWidth : bodyContentWidth),
            segments: [{ runIndex, fromChar: wordStartChar, toChar: wordEndNoSpace, width: wordOnlyWidth }],
            spaceCount: 0
          };
          const ls = run.letterSpacing ?? 0;
          if (shouldIncludeDelimiterSpace && currentLine.width + spaceWidth <= currentLine.maxWidth - WIDTH_FUDGE_PX2) {
            currentLine.toChar = wordEndWithSpace;
            currentLine.width = roundValue(currentLine.width + spaceWidth + ls);
            charPosInRun = wordEndWithSpace;
            currentLine.spaceCount += 1;
            if (currentLine.segments?.[0]) {
              currentLine.segments[0].toChar = wordEndWithSpace;
              currentLine.segments[0].width += spaceWidth;
            }
          } else {
            charPosInRun = wordEndWithSpace;
          }
          continue;
        }
        const isTocEntry = block.attrs?.isTocEntry;
        const isRunStart = charPosInRun === 0 && segmentIndex === 0 && wordIndex === 0;
        const boundarySpacing = resolveBoundarySpacing(currentLine.width, isRunStart, run);
        const justifyAlignment = block.attrs?.alignment === "justify";
        const totalWidthWithWord = currentLine.width + boundarySpacing + wordCommitWidth + // Safe cast: only TextRuns produce word segments from split(), other run types are handled earlier
        (shouldIncludeDelimiterSpace ? run.letterSpacing ?? 0 : 0);
        const availableWidth = currentLine.maxWidth - WIDTH_FUDGE_PX2;
        let shouldBreak = !inActiveTabGroup && currentLine.width + boundarySpacing + wordOnlyWidth > availableWidth && currentLine.width > 0 && !isTocEntry;
        let compressedWidth = null;
        if (shouldBreak && justifyAlignment) {
          const isLastNonEmptyWordInSegment = wordIndex === lastNonEmptyWordIndex;
          const isParagraphLastWord = isLastSegment && isLastNonEmptyWordInSegment && runIndex === runsToProcess.length - 1;
          if (!isParagraphLastWord) {
            const existingSpaces = currentLine.spaceCount ?? 0;
            const candidateSpaces = existingSpaces + (shouldIncludeDelimiterSpace ? 1 : 0);
            if (candidateSpaces > 0) {
              const overflow = totalWidthWithWord - availableWidth;
              if (overflow > 0) {
                const baseSpaceWidth = spaceWidth || measureRunWidth(" ", font, ctx2, run, wordEndNoSpace) || Math.max(1, boundarySpacing);
                const perSpaceCompression = overflow / candidateSpaces;
                const maxPerSpaceCompression = baseSpaceWidth * 0.25;
                if (perSpaceCompression <= maxPerSpaceCompression) {
                  shouldBreak = false;
                  compressedWidth = availableWidth;
                }
              }
            }
          }
        }
        if (shouldBreak) {
          trimTrailingWrapSpaces(currentLine);
          const metrics = calculateTypographyMetrics(currentLine.maxFontSize, spacing, currentLine.maxFontInfo);
          const lineBase = currentLine;
          const completedLine = {
            ...lineBase,
            ...metrics
          };
          addBarTabsToLine(completedLine);
          lines.push(completedLine);
          tabStopCursor = 0;
          pendingTabAlignment = null;
          currentLine = {
            fromRun: runIndex,
            fromChar: wordStartChar,
            toRun: runIndex,
            toChar: wordEndNoSpace,
            width: wordOnlyWidth,
            maxFontSize: run.fontSize,
            maxFontInfo: getFontInfoFromRun(run),
            maxWidth: getEffectiveWidth(bodyContentWidth),
            segments: [{ runIndex, fromChar: wordStartChar, toChar: wordEndNoSpace, width: wordOnlyWidth }],
            spaceCount: 0
          };
          if (shouldIncludeDelimiterSpace && currentLine.width + spaceWidth <= currentLine.maxWidth - WIDTH_FUDGE_PX2) {
            currentLine.toChar = wordEndWithSpace;
            currentLine.width = roundValue(currentLine.width + spaceWidth + (run.letterSpacing ?? 0));
            charPosInRun = wordEndWithSpace;
            currentLine.spaceCount += 1;
            if (currentLine.segments?.[0]) {
              currentLine.segments[0].toChar = wordEndWithSpace;
              currentLine.segments[0].width += spaceWidth;
            }
          } else {
            charPosInRun = wordEndWithSpace;
          }
        } else {
          currentLine.toRun = runIndex;
          if (shouldIncludeDelimiterSpace && currentLine.width + boundarySpacing + wordOnlyWidth + spaceWidth > currentLine.maxWidth - WIDTH_FUDGE_PX2) {
            currentLine.toChar = wordEndNoSpace;
            currentLine.width = roundValue(currentLine.width + boundarySpacing + wordOnlyWidth);
            currentLine.maxFontInfo = updateMaxFontInfo(currentLine.maxFontSize, currentLine.maxFontInfo, run);
            currentLine.maxFontSize = Math.max(currentLine.maxFontSize, run.fontSize);
            let explicitXHere;
            if (inActiveTabGroup && activeTabGroup) {
              explicitXHere = activeTabGroup.currentX;
              activeTabGroup.currentX = roundValue(activeTabGroup.currentX + wordOnlyWidth);
            } else if (wordIndex === 0 && segmentStartX !== void 0) {
              explicitXHere = segmentStartX;
            }
            appendSegment(currentLine.segments, runIndex, wordStartChar, wordEndNoSpace, wordOnlyWidth, explicitXHere);
            trimTrailingWrapSpaces(currentLine);
            const metrics = calculateTypographyMetrics(currentLine.maxFontSize, spacing, currentLine.maxFontInfo);
            const lineBase = currentLine;
            const completedLine = { ...lineBase, ...metrics };
            addBarTabsToLine(completedLine);
            lines.push(completedLine);
            tabStopCursor = 0;
            pendingTabAlignment = null;
            currentLine = null;
            charPosInRun = wordEndNoSpace + 1;
            continue;
          }
          const newToChar = shouldIncludeDelimiterSpace ? wordEndWithSpace : wordEndNoSpace;
          currentLine.toChar = newToChar;
          let explicitX;
          if (inActiveTabGroup && activeTabGroup) {
            explicitX = activeTabGroup.currentX;
            activeTabGroup.currentX = roundValue(activeTabGroup.currentX + wordCommitWidth);
          } else if (wordIndex === 0 && segmentStartX !== void 0) {
            explicitX = segmentStartX;
          }
          const targetWidth = compressedWidth != null ? compressedWidth : currentLine.width + boundarySpacing + wordCommitWidth + (shouldIncludeDelimiterSpace ? run.letterSpacing ?? 0 : 0);
          if (compressedWidth != null) {
            currentLine.naturalWidth = roundValue(totalWidthWithWord);
          }
          currentLine.width = roundValue(targetWidth);
          currentLine.maxFontInfo = updateMaxFontInfo(currentLine.maxFontSize, currentLine.maxFontInfo, run);
          currentLine.maxFontSize = Math.max(currentLine.maxFontSize, run.fontSize);
          appendSegment(currentLine.segments, runIndex, wordStartChar, newToChar, wordCommitWidth, explicitX);
          if (shouldIncludeDelimiterSpace) {
            currentLine.spaceCount += 1;
          }
        }
        charPosInRun = shouldIncludeDelimiterSpace ? wordEndWithSpace : wordEndNoSpace;
      }
      if (lastAppliedTabAlign && currentLine) {
        const appliedTab = lastAppliedTabAlign;
        if (appliedTab.val === "end") {
          currentLine.width = roundValue(appliedTab.target);
        }
      }
      lastAppliedTabAlign = null;
      if (activeTabGroup && runIndex + 1 >= activeTabGroup.measure.endRunIndex) {
        if (currentLine && activeTabGroup.val === "end") {
          currentLine.width = roundValue(activeTabGroup.target);
        }
        activeTabGroup = null;
      }
      if (!isLastSegment) {
        pendingTabAlignment = null;
        if (!currentLine) {
          currentLine = {
            fromRun: runIndex,
            fromChar: charPosInRun,
            toRun: runIndex,
            toChar: charPosInRun,
            width: 0,
            maxFontSize: run.fontSize,
            maxFontInfo: getFontInfoFromRun(run),
            maxWidth: getEffectiveWidth(lines.length === 0 ? initialAvailableWidth : bodyContentWidth),
            segments: [],
            spaceCount: 0
          };
        }
        const originX = currentLine.width;
        const effectiveIndent = lines.length === 0 ? indentLeft + rawFirstLineOffset : indentLeft;
        const absCurrentX = currentLine.width + effectiveIndent;
        const { target, nextIndex, stop } = getNextTabStopPx(absCurrentX, tabStops, tabStopCursor);
        tabStopCursor = nextIndex;
        const maxAbsWidth = currentLine.maxWidth + effectiveIndent;
        const clampedTarget = Math.min(target, maxAbsWidth);
        const tabAdvance = Math.max(0, clampedTarget - absCurrentX);
        currentLine.width = roundValue(currentLine.width + tabAdvance);
        currentLine.maxFontInfo = updateMaxFontInfo(currentLine.maxFontSize, currentLine.maxFontInfo, run);
        currentLine.maxFontSize = Math.max(currentLine.maxFontSize, run.fontSize);
        currentLine.toRun = runIndex;
        currentLine.toChar = charPosInRun;
        charPosInRun += 1;
        if (stop) {
          validateTabStopVal(stop);
          pendingTabAlignment = { target: clampedTarget - effectiveIndent, val: stop.val };
        } else {
          pendingTabAlignment = null;
        }
        if (stop && stop.leader && stop.leader !== "none" && stop.leader !== "middleDot") {
          const leaderStyle = stop.leader;
          const relativeTarget = clampedTarget - effectiveIndent;
          const from3 = Math.min(originX, relativeTarget);
          const to = Math.max(originX, relativeTarget);
          if (!currentLine.leaders) currentLine.leaders = [];
          currentLine.leaders.push({ from: from3, to, style: leaderStyle });
        }
      }
    }
    pendingRunSpacing = run.letterSpacing ?? 0;
  }
  if (!currentLine && lines.length === 0) {
    const uiDisplayFallbackFontSize = (normalizedRuns[0]?.kind === "text" ? normalizedRuns[0].fontSize : void 0) ?? DEFAULT_PARAGRAPH_FONT_SIZE;
    const metrics = calculateTypographyMetrics(uiDisplayFallbackFontSize, spacing);
    const fallbackLine = {
      fromRun: 0,
      fromChar: 0,
      toRun: 0,
      toChar: 0,
      width: 0,
      segments: [],
      ...metrics
    };
    addBarTabsToLine(fallbackLine);
    lines.push(fallbackLine);
  }
  if (currentLine) {
    const metrics = calculateTypographyMetrics(currentLine.maxFontSize, spacing, currentLine.maxFontInfo);
    const lineBase = currentLine;
    const finalLine = {
      ...lineBase,
      ...metrics
    };
    addBarTabsToLine(finalLine);
    lines.push(finalLine);
  }
  const totalHeight = lines.reduce((sum, line) => sum + line.lineHeight, 0);
  return {
    kind: "paragraph",
    lines,
    totalHeight,
    ...markerInfo ? { marker: markerInfo } : {},
    ...dropCapMeasure ? { dropCap: dropCapMeasure } : {}
  };
}
function validateTableWidthValue(attr) {
  const value = attr.width ?? attr.value;
  if (typeof value === "number" && Number.isFinite(value) && value > 0) {
    return value;
  }
  return void 0;
}
function resolveTableWidth(attrs, maxWidth) {
  const tableWidthAttr = attrs?.tableWidth;
  if (!tableWidthAttr || typeof tableWidthAttr !== "object") {
    return void 0;
  }
  const typedAttr = tableWidthAttr;
  const validValue = validateTableWidthValue(typedAttr);
  if (validValue === void 0) {
    return void 0;
  }
  if (typedAttr.type === "pct") {
    return Math.round(maxWidth * (validValue / OOXML_PCT_DIVISOR));
  } else if (typedAttr.type === "px" || typedAttr.type === "pixel") {
    return validValue;
  }
  return void 0;
}
async function measureTableBlock(block, constraints) {
  const maxWidth = typeof constraints === "number" ? constraints : constraints.maxWidth;
  const resolvedTableWidth = resolveTableWidth(block.attrs, maxWidth);
  let columnWidths;
  const scaleColumnWidths = (widths, targetWidth) => {
    const totalWidth2 = widths.reduce((a, b2) => a + b2, 0);
    if (totalWidth2 <= targetWidth || widths.length === 0) return widths;
    const scale = targetWidth / totalWidth2;
    const scaled = widths.map((w) => Math.max(1, Math.round(w * scale)));
    const sum = scaled.reduce((a, b2) => a + b2, 0);
    if (sum !== targetWidth) {
      const adjust = (delta) => {
        let idx = 0;
        const direction = delta > 0 ? 1 : -1;
        delta = Math.abs(delta);
        while (delta > 0 && scaled.length > 0) {
          const i = idx % scaled.length;
          if (direction > 0) {
            scaled[i] += 1;
            delta -= 1;
          } else if (scaled[i] > 1) {
            scaled[i] -= 1;
            delta -= 1;
          }
          idx += 1;
          if (idx > scaled.length * 2 && delta > 0) break;
        }
      };
      adjust(targetWidth - sum);
    }
    return scaled;
  };
  const maxCellCount = Math.max(1, Math.max(...block.rows.map((r2) => r2.cells.length)));
  const effectiveTargetWidth = resolvedTableWidth != null ? Math.min(resolvedTableWidth, maxWidth) : maxWidth;
  if (block.columnWidths && block.columnWidths.length > 0) {
    columnWidths = [...block.columnWidths];
    const hasExplicitWidth = resolvedTableWidth != null;
    const hasFixedLayout = block.attrs?.tableLayout === "fixed";
    if (hasExplicitWidth || hasFixedLayout) {
      const totalWidth2 = columnWidths.reduce((a, b2) => a + b2, 0);
      const tableWidthType = block.attrs?.tableWidth?.type;
      const shouldScaleDown = totalWidth2 > effectiveTargetWidth;
      const shouldScaleUp = totalWidth2 < effectiveTargetWidth && effectiveTargetWidth > 0 && (tableWidthType === "pct" || hasExplicitWidth && !hasFixedLayout);
      if ((shouldScaleDown || shouldScaleUp) && effectiveTargetWidth > 0 && totalWidth2 > 0) {
        const scale = effectiveTargetWidth / totalWidth2;
        columnWidths = columnWidths.map((w) => Math.max(1, Math.round(w * scale)));
        const scaledSum = columnWidths.reduce((a, b2) => a + b2, 0);
        if (scaledSum !== effectiveTargetWidth && columnWidths.length > 0) {
          const diff = effectiveTargetWidth - scaledSum;
          columnWidths[columnWidths.length - 1] = Math.max(1, columnWidths[columnWidths.length - 1] + diff);
        }
      }
    } else {
      if (columnWidths.length < maxCellCount) {
        const usedWidth = columnWidths.reduce((a, b2) => a + b2, 0);
        const remainingWidth = Math.max(0, effectiveTargetWidth - usedWidth);
        const missingColumns = maxCellCount - columnWidths.length;
        const paddingWidth = Math.max(1, Math.floor(remainingWidth / missingColumns));
        columnWidths.push(...Array.from({ length: missingColumns }, () => paddingWidth));
      } else if (columnWidths.length > maxCellCount) {
        columnWidths = columnWidths.slice(0, maxCellCount);
      }
      const totalWidth2 = columnWidths.reduce((a, b2) => a + b2, 0);
      if (totalWidth2 > effectiveTargetWidth) {
        columnWidths = scaleColumnWidths(columnWidths, effectiveTargetWidth);
      }
    }
  } else {
    const columnWidth = Math.max(1, Math.floor(effectiveTargetWidth / maxCellCount));
    columnWidths = Array.from({ length: maxCellCount }, () => columnWidth);
  }
  const gridColumnCount = columnWidths.length;
  const calculateCellWidth = (startCol, colspan) => {
    let width = 0;
    for (let i = 0; i < colspan && startCol + i < columnWidths.length; i++) {
      width += columnWidths[startCol + i];
    }
    return Math.max(1, width);
  };
  const rowspanTracker = new Array(gridColumnCount).fill(0);
  const rows = [];
  const rowBaseHeights = new Array(block.rows.length).fill(0);
  const spanConstraints = [];
  for (let rowIndex = 0; rowIndex < block.rows.length; rowIndex++) {
    const row = block.rows[rowIndex];
    const cellMeasures = [];
    let gridColIndex = 0;
    for (const cell of row.cells) {
      const colspan = cell.colSpan ?? 1;
      const rowspan = cell.rowSpan ?? 1;
      while (gridColIndex < gridColumnCount && rowspanTracker[gridColIndex] > 0) {
        rowspanTracker[gridColIndex]--;
        gridColIndex++;
      }
      if (gridColIndex >= gridColumnCount) {
        break;
      }
      const cellWidth = calculateCellWidth(gridColIndex, colspan);
      if (rowspan > 1) {
        for (let c2 = 0; c2 < colspan && gridColIndex + c2 < gridColumnCount; c2++) {
          rowspanTracker[gridColIndex + c2] = rowspan - 1;
        }
      }
      const cellPadding = cell.attrs?.padding ?? { top: 2, left: 4, right: 4, bottom: 2 };
      const paddingTop = cellPadding.top ?? 2;
      const paddingBottom = cellPadding.bottom ?? 2;
      const paddingLeft = cellPadding.left ?? 4;
      const paddingRight = cellPadding.right ?? 4;
      const contentWidth = Math.max(1, cellWidth - paddingLeft - paddingRight);
      const blockMeasures = [];
      let contentHeight = 0;
      const cellBlocks = cell.blocks ?? (cell.paragraph ? [cell.paragraph] : []);
      for (let blockIndex = 0; blockIndex < cellBlocks.length; blockIndex++) {
        const block2 = cellBlocks[blockIndex];
        const measure = await measureBlock(block2, { maxWidth: contentWidth, maxHeight: Infinity });
        blockMeasures.push(measure);
        const blockHeight = "totalHeight" in measure ? measure.totalHeight : "height" in measure ? measure.height : 0;
        const isAnchoredOutOfFlow = (block2.kind === "image" || block2.kind === "drawing") && block2.anchor?.isAnchored === true && (block2.wrap?.type ?? "Inline") !== "Inline";
        if (isAnchoredOutOfFlow) {
          continue;
        }
        contentHeight += blockHeight;
        if (block2.kind === "paragraph") {
          const spacingAfter = block2.attrs?.spacing?.after;
          if (typeof spacingAfter === "number" && spacingAfter > 0) {
            contentHeight += spacingAfter;
          }
        }
      }
      const totalCellHeight = contentHeight + paddingTop + paddingBottom;
      cellMeasures.push({
        blocks: blockMeasures,
        // Backward compatibility
        paragraph: blockMeasures[0]?.kind === "paragraph" ? blockMeasures[0] : void 0,
        width: cellWidth,
        height: totalCellHeight,
        gridColumnStart: gridColIndex,
        colSpan: colspan,
        rowSpan: rowspan
      });
      if (rowspan === 1) {
        rowBaseHeights[rowIndex] = Math.max(rowBaseHeights[rowIndex], totalCellHeight);
      } else {
        spanConstraints.push({ startRow: rowIndex, rowSpan: rowspan, requiredHeight: totalCellHeight });
      }
      gridColIndex += colspan;
    }
    for (let col = gridColIndex; col < gridColumnCount; col++) {
      if (rowspanTracker[col] > 0) {
        rowspanTracker[col]--;
      }
    }
    rows.push({ cells: cellMeasures, height: 0 });
  }
  const rowHeights = [...rowBaseHeights];
  for (const constraint of spanConstraints) {
    const { startRow, rowSpan, requiredHeight } = constraint;
    if (rowSpan <= 0) continue;
    let currentHeight = 0;
    for (let i = 0; i < rowSpan && startRow + i < rowHeights.length; i++) {
      currentHeight += rowHeights[startRow + i];
    }
    if (currentHeight < requiredHeight) {
      const spanLength = Math.min(rowSpan, rowHeights.length - startRow);
      const increment = spanLength > 0 ? (requiredHeight - currentHeight) / spanLength : 0;
      for (let i = 0; i < spanLength; i++) {
        rowHeights[startRow + i] += increment;
      }
    }
  }
  block.rows.forEach((row, index2) => {
    const spec = row.attrs?.rowHeight;
    if (spec?.value != null && Number.isFinite(spec.value)) {
      const rule = spec.rule ?? "atLeast";
      if (rule === "exact") {
        rowHeights[index2] = spec.value;
      } else {
        rowHeights[index2] = Math.max(rowHeights[index2], spec.value);
      }
    }
  });
  for (let i = 0; i < rows.length; i++) {
    rows[i].height = Math.max(0, rowHeights[i]);
  }
  const totalHeight = rowHeights.reduce((sum, h2) => sum + h2, 0);
  const totalWidth = columnWidths.reduce((a, b2) => a + b2, 0);
  return {
    kind: "table",
    rows,
    columnWidths,
    totalWidth,
    totalHeight
  };
}
async function measureImageBlock(block, constraints) {
  const intrinsic = getIntrinsicImageSize(block, constraints.maxWidth);
  const isBlockBehindDoc = block.anchor?.behindDoc;
  const isBlockWrapBehindDoc = block.wrap?.type === "None" && block.wrap?.behindDoc;
  const isPageRelativeAnchor2 = block.anchor?.isAnchored && (block.anchor?.hRelativeFrom === "page" || block.anchor?.hRelativeFrom === "margin");
  const bypassWidthConstraint = isBlockBehindDoc || isBlockWrapBehindDoc || isPageRelativeAnchor2;
  const isWidthConstraintBypassed = bypassWidthConstraint || constraints.maxWidth <= 0;
  const maxWidth = isWidthConstraintBypassed ? intrinsic.width : constraints.maxWidth;
  const hasNegativeVerticalPosition = block.anchor?.isAnchored && (typeof block.anchor?.offsetV === "number" && block.anchor.offsetV < 0 || typeof block.margin?.top === "number" && block.margin.top < 0);
  const shouldBypassHeightConstraint = hasNegativeVerticalPosition || block.objectFit === "cover";
  const maxHeight = shouldBypassHeightConstraint || !constraints.maxHeight || constraints.maxHeight <= 0 ? Infinity : constraints.maxHeight;
  const widthScale = maxWidth / intrinsic.width;
  const heightScale = maxHeight / intrinsic.height;
  const scale = Math.min(1, widthScale, heightScale);
  const width = Number.isFinite(scale) ? intrinsic.width * scale : intrinsic.width;
  const height = Number.isFinite(scale) ? intrinsic.height * scale : intrinsic.height;
  return {
    kind: "image",
    width,
    height
  };
}
async function measureDrawingBlock(block, constraints) {
  if (block.drawingKind === "image") {
    const intrinsic = getIntrinsicSizeFromDims(block.width, block.height, constraints.maxWidth);
    const maxWidth2 = constraints.maxWidth > 0 ? constraints.maxWidth : intrinsic.width;
    const maxHeight2 = constraints.maxHeight && constraints.maxHeight > 0 ? constraints.maxHeight : Infinity;
    const widthScale2 = maxWidth2 / intrinsic.width;
    const heightScale2 = maxHeight2 / intrinsic.height;
    const scale2 = Math.min(1, widthScale2, heightScale2);
    const width2 = Number.isFinite(scale2) ? intrinsic.width * scale2 : intrinsic.width;
    const height2 = Number.isFinite(scale2) ? intrinsic.height * scale2 : intrinsic.height;
    return {
      kind: "drawing",
      drawingKind: "image",
      width: width2,
      height: height2,
      scale: Number.isFinite(scale2) ? scale2 : 1,
      naturalWidth: intrinsic.width,
      naturalHeight: intrinsic.height,
      geometry: {
        width: intrinsic.width,
        height: intrinsic.height,
        rotation: 0,
        flipH: false,
        flipV: false
      }
    };
  }
  const geometry = ensureDrawingGeometry(block.geometry);
  const attrs = block.attrs;
  const indentLeft = typeof attrs?.hrIndentLeft === "number" ? attrs.hrIndentLeft : 0;
  const indentRight = typeof attrs?.hrIndentRight === "number" ? attrs.hrIndentRight : 0;
  const hasFullWidth = attrs?.isFullWidth === true && constraints.maxWidth > 0;
  const fullWidthMax = hasFullWidth ? Math.max(1, constraints.maxWidth - indentLeft - indentRight) : void 0;
  if (fullWidthMax != null) {
    geometry.width = fullWidthMax;
  }
  const rotatedBounds = calculateRotatedBounds(geometry);
  const naturalWidth = Math.max(1, rotatedBounds.width);
  const naturalHeight = Math.max(1, rotatedBounds.height);
  const maxWidth = fullWidthMax ?? (constraints.maxWidth > 0 ? constraints.maxWidth : naturalWidth);
  const hasNegativeVerticalPosition = block.anchor?.isAnchored && (typeof block.anchor?.offsetV === "number" && block.anchor.offsetV < 0 || typeof block.margin?.top === "number" && block.margin.top < 0);
  const maxHeight = hasNegativeVerticalPosition || !constraints.maxHeight || constraints.maxHeight <= 0 ? Infinity : constraints.maxHeight;
  const widthScale = maxWidth / naturalWidth;
  const heightScale = maxHeight / naturalHeight;
  const normalizedScale = Math.min(1, widthScale, heightScale);
  const scale = Number.isFinite(normalizedScale) ? normalizedScale : 1;
  const width = naturalWidth * scale;
  const height = naturalHeight * scale;
  return {
    kind: "drawing",
    drawingKind: block.drawingKind,
    width,
    height,
    scale,
    naturalWidth,
    naturalHeight,
    geometry: { ...geometry },
    ...block.drawingKind === "shapeGroup" && block.groupTransform ? { groupTransform: { ...block.groupTransform } } : {}
  };
}
function getIntrinsicImageSize(block, fallback) {
  const safeFallback = fallback > 0 ? fallback : 1;
  const suggestedWidth = typeof block.width === "number" && block.width > 0 ? block.width : safeFallback;
  const suggestedHeight = typeof block.height === "number" && block.height > 0 ? block.height : safeFallback * 0.75;
  return {
    width: suggestedWidth,
    height: suggestedHeight
  };
}
function getIntrinsicSizeFromDims(width, height, fallback = 1) {
  const safeFallback = fallback > 0 ? fallback : 1;
  const intrinsicWidth = typeof width === "number" && width > 0 ? width : safeFallback;
  const intrinsicHeight = typeof height === "number" && height > 0 ? height : safeFallback * 0.75;
  return {
    width: intrinsicWidth,
    height: intrinsicHeight
  };
}
function ensureDrawingGeometry(geometry) {
  if (geometry) {
    return {
      width: Math.max(1, geometry.width),
      height: Math.max(1, geometry.height),
      rotation: normalizeRotation(geometry.rotation ?? 0),
      flipH: Boolean(geometry.flipH),
      flipV: Boolean(geometry.flipV)
    };
  }
  return {
    width: 1,
    height: 1,
    rotation: 0,
    flipH: false,
    flipV: false
  };
}
function normalizeConstraints(constraints) {
  if (typeof constraints === "number") {
    return { maxWidth: constraints };
  }
  return constraints;
}
async function measureListBlock(block, constraints) {
  const ctx2 = getCanvasContext();
  const items = [];
  let totalHeight = 0;
  for (const item of block.items) {
    const wordLayout = item.paragraph.attrs?.wordLayout;
    let markerTextWidth;
    let markerWidth;
    let indentLeft;
    if (wordLayout?.marker) {
      const marker = wordLayout.marker;
      const paragraphFallbackFontSize = getPrimaryRun(item.paragraph).fontSize ?? DEFAULT_PARAGRAPH_FONT_SIZE;
      const markerFontRun = {
        text: marker.markerText,
        fontFamily: toCssFontFamily(marker.run.fontFamily) ?? marker.run.fontFamily,
        fontSize: marker.run.fontSize ?? paragraphFallbackFontSize,
        bold: marker.run.bold,
        italic: marker.run.italic,
        letterSpacing: marker.run.letterSpacing
      };
      const { font: markerFont } = buildFontString(markerFontRun);
      markerTextWidth = marker.markerText ? measureText(marker.markerText, markerFont, ctx2) : 0;
      markerWidth = 0;
      indentLeft = wordLayout.indentLeftPx ?? 0;
    } else {
      const markerFontRun = getPrimaryRun(item.paragraph);
      const { font: markerFont } = buildFontString(markerFontRun);
      const markerText = item.marker.text ?? "";
      markerTextWidth = markerText ? measureText(markerText, markerFont, ctx2) : 0;
      indentLeft = resolveIndentLeft(item);
      const indentHanging = resolveIndentHanging(item);
      markerWidth = Math.max(MIN_MARKER_GUTTER, markerTextWidth + LIST_MARKER_GAP, indentHanging);
    }
    const paragraphWidth = Math.max(1, constraints.maxWidth - indentLeft - markerWidth);
    const paragraphMeasure = await measureParagraphBlock(item.paragraph, paragraphWidth);
    totalHeight += paragraphMeasure.totalHeight;
    items.push({
      itemId: item.id,
      markerWidth,
      markerTextWidth,
      indentLeft,
      paragraph: paragraphMeasure
    });
  }
  return {
    kind: "list",
    items,
    totalHeight
  };
}
const getPrimaryRun = (paragraph) => {
  return paragraph.runs.find((run) => run.kind === "text" && Boolean(run.fontFamily && run.fontSize)) || {
    text: "",
    fontFamily: "Arial",
    fontSize: 16
  };
};
const isWordChar = (char) => {
  if (!char) return false;
  const code = char.charCodeAt(0);
  return code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122 || char === "'";
};
const capitalizeText = (text, fullText, startOffset) => {
  if (!text) return text;
  const hasFullText = typeof startOffset === "number" && fullText != null;
  let result = "";
  for (let i = 0; i < text.length; i += 1) {
    const prevChar = hasFullText ? startOffset + i > 0 ? fullText[startOffset + i - 1] : "" : i > 0 ? text[i - 1] : "";
    const ch = text[i];
    result += isWordChar(ch) && !isWordChar(prevChar) ? ch.toUpperCase() : ch;
  }
  return result;
};
const applyTextTransform = (text, run, startOffset) => {
  const transform = "textTransform" in run ? run.textTransform : void 0;
  if (!text || !transform || transform === "none") return text;
  if (transform === "uppercase") return text.toUpperCase();
  if (transform === "lowercase") return text.toLowerCase();
  if (transform === "capitalize") {
    const fullText = "text" in run && typeof run.text === "string" ? run.text : text;
    return capitalizeText(text, fullText, startOffset);
  }
  return text;
};
const measureRunWidth = (text, font, ctx2, run, startOffset) => {
  const letterSpacing = run.kind === "text" || run.kind === void 0 ? run.letterSpacing || 0 : 0;
  const displayText = applyTextTransform(text, run, startOffset);
  const width = getMeasuredTextWidth(displayText, font, letterSpacing, ctx2);
  return roundValue(width);
};
const breakWordIntoChunks = (word, maxWidth, font, ctx2, run, startOffset) => {
  const chunks = [];
  const baseOffset = typeof startOffset === "number" ? startOffset : 0;
  if (maxWidth <= 0) {
    for (let i = 0; i < word.length; i++) {
      const char = word[i];
      const charWidth = measureRunWidth(char, font, ctx2, run, baseOffset + i);
      chunks.push({ text: char, width: charWidth });
    }
    return chunks;
  }
  let currentChunk = "";
  let currentWidth = 0;
  for (let i = 0; i < word.length; i++) {
    const char = word[i];
    const testChunk = currentChunk + char;
    const testWidth = measureRunWidth(testChunk, font, ctx2, run, baseOffset);
    if (testWidth > maxWidth && currentChunk.length > 0) {
      chunks.push({ text: currentChunk, width: currentWidth });
      currentChunk = char;
      currentWidth = measureRunWidth(char, font, ctx2, run, baseOffset + i);
    } else {
      currentChunk = testChunk;
      currentWidth = testWidth;
    }
  }
  if (currentChunk.length > 0) {
    chunks.push({ text: currentChunk, width: currentWidth });
  }
  return chunks;
};
const appendSegment = (segments, runIndex, fromChar, toChar, width, x) => {
  if (!segments) return;
  const last = segments[segments.length - 1];
  if (last && last.runIndex === runIndex && last.toChar === fromChar && x === void 0) {
    last.toChar = toChar;
    last.width += width;
    return;
  }
  segments.push({ runIndex, fromChar, toChar, width, x });
};
const resolveLineHeight = (spacing, baseLineHeight) => {
  if (!spacing || spacing.line == null || spacing.line <= 0) {
    return baseLineHeight;
  }
  const raw = spacing.line;
  const isAuto = spacing.lineRule === "auto";
  const treatAsMultiplier = (isAuto || spacing.lineRule == null) && raw > 0 && (isAuto || raw <= 10);
  if (treatAsMultiplier) {
    return raw * baseLineHeight;
  }
  if (spacing.lineRule === "exact") {
    return raw;
  }
  if (spacing.lineRule === "atLeast") {
    return Math.max(baseLineHeight, raw);
  }
  return Math.max(baseLineHeight, raw);
};
const sanitizePositive = (value) => typeof value === "number" && Number.isFinite(value) ? Math.max(0, value) : 0;
const sanitizeIndent = (value) => typeof value === "number" && Number.isFinite(value) ? value : 0;
const sanitizeDecimalSeparator = (value) => {
  if (value === ",") return ",";
  return DEFAULT_DECIMAL_SEPARATOR;
};
const DROP_CAP_PADDING_PX = 4;
const measureDropCap = (ctx2, descriptor, spacing) => {
  const { run, lines, mode } = descriptor;
  const { font } = buildFontString({
    fontFamily: run.fontFamily,
    fontSize: run.fontSize,
    bold: run.bold,
    italic: run.italic
  });
  ctx2.font = font;
  const displayText = applyTextTransform(run.text, run);
  const metrics = ctx2.measureText(displayText);
  const advanceWidth = metrics.width;
  const paintedWidth = (metrics.actualBoundingBoxLeft || 0) + (metrics.actualBoundingBoxRight || 0);
  const textWidth = Math.max(advanceWidth, paintedWidth);
  const width = roundValue(textWidth + DROP_CAP_PADDING_PX);
  const baseLineHeight = resolveLineHeight(spacing, run.fontSize * WORD_SINGLE_LINE_SPACING_MULTIPLIER);
  const height = roundValue(baseLineHeight * lines);
  return {
    width,
    height,
    lines,
    mode
  };
};
const resolveIndentLeft = (item) => {
  const indentLeft = sanitizePositive(item.paragraph.attrs?.indent?.left);
  if (indentLeft > 0) {
    return indentLeft;
  }
  return DEFAULT_LIST_INDENT_BASE_PX + item.marker.level * DEFAULT_LIST_INDENT_STEP_PX;
};
const resolveIndentHanging = (item) => {
  const indentHanging = sanitizePositive(item.paragraph.attrs?.indent?.hanging);
  if (indentHanging > 0) {
    return indentHanging;
  }
  return DEFAULT_LIST_HANGING_PX;
};
const buildTabStopsPx = (indent, tabs, tabIntervalTwips) => {
  const paragraphIndentTwips = {
    left: pxToTwips(sanitizePositive(indent?.left)),
    right: pxToTwips(sanitizePositive(indent?.right)),
    firstLine: pxToTwips(sanitizePositive(indent?.firstLine)),
    hanging: pxToTwips(sanitizePositive(indent?.hanging))
  };
  const stops = computeTabStops({
    explicitStops: tabs ?? [],
    defaultTabInterval: tabIntervalTwips ?? DEFAULT_TAB_INTERVAL_TWIPS,
    paragraphIndent: paragraphIndentTwips
  });
  return stops.map((stop) => ({
    pos: twipsToPx(stop.pos),
    val: stop.val,
    leader: stop.leader
  }));
};
const getNextTabStopPx = (currentX, tabStops, startIndex) => {
  let index2 = startIndex;
  while (index2 < tabStops.length && tabStops[index2].pos <= currentX + TAB_EPSILON) {
    index2++;
  }
  if (index2 < tabStops.length) {
    return { target: tabStops[index2].pos, nextIndex: index2 + 1, stop: tabStops[index2] };
  }
  return { target: currentX + DEFAULT_TAB_INTERVAL_PX, nextIndex: index2 };
};
async function layoutPerRIdHeaderFooters(headerFooterInput, layout, sectionMetadata, deps) {
  deps.headerLayoutsByRId.clear();
  deps.footerLayoutsByRId.clear();
  if (!headerFooterInput) return;
  const { headerBlocksByRId, footerBlocksByRId, constraints } = headerFooterInput;
  const displayPages = computeDisplayPageNumber(layout.pages, sectionMetadata);
  const totalPages = layout.pages.length;
  const pageResolver = (pageNumber) => {
    const pageIndex = pageNumber - 1;
    const displayInfo = displayPages[pageIndex];
    return {
      displayText: displayInfo?.displayText ?? String(pageNumber),
      totalPages
    };
  };
  if (headerBlocksByRId) {
    for (const [rId, blocks] of headerBlocksByRId) {
      if (!blocks || blocks.length === 0) continue;
      try {
        const batchResult = await layoutHeaderFooterWithCache(
          { default: blocks },
          constraints,
          (block, c2) => measureBlock(block, c2),
          void 0,
          void 0,
          pageResolver
        );
        if (batchResult.default) {
          deps.headerLayoutsByRId.set(rId, {
            kind: "header",
            type: "default",
            layout: batchResult.default.layout,
            blocks: batchResult.default.blocks,
            measures: batchResult.default.measures
          });
        }
      } catch (error) {
        console.warn(`[PresentationEditor] Failed to layout header rId=${rId}:`, error);
      }
    }
  }
  if (footerBlocksByRId) {
    for (const [rId, blocks] of footerBlocksByRId) {
      if (!blocks || blocks.length === 0) continue;
      try {
        const batchResult = await layoutHeaderFooterWithCache(
          { default: blocks },
          constraints,
          (block, c2) => measureBlock(block, c2),
          void 0,
          void 0,
          pageResolver
        );
        if (batchResult.default) {
          deps.footerLayoutsByRId.set(rId, {
            kind: "footer",
            type: "default",
            layout: batchResult.default.layout,
            blocks: batchResult.default.blocks,
            measures: batchResult.default.measures
          });
        }
      } catch (error) {
        console.warn(`[PresentationEditor] Failed to layout footer rId=${rId}:`, error);
      }
    }
  }
}
class HeaderFooterSessionManager {
  // Options and dependencies
  #options;
  #deps = null;
  #callbacks = {};
  // Registry and managers
  #headerFooterManager = null;
  #headerFooterAdapter = null;
  #headerFooterIdentifier = null;
  #multiSectionIdentifier = null;
  #overlayManager = null;
  #managerCleanups = [];
  // Layout results
  #headerLayoutResults = null;
  #footerLayoutResults = null;
  #headerLayoutsByRId = /* @__PURE__ */ new Map();
  #footerLayoutsByRId = /* @__PURE__ */ new Map();
  // Decoration providers
  #headerDecorationProvider;
  #footerDecorationProvider;
  // Region tracking
  #headerRegions = /* @__PURE__ */ new Map();
  #footerRegions = /* @__PURE__ */ new Map();
  // Session state
  #session = { mode: "body" };
  #activeEditor = null;
  // Hover UI elements (passed in, not owned)
  #hoverOverlay = null;
  #hoverTooltip = null;
  #modeBanner = null;
  #hoverRegion = null;
  // Document mode
  #documentMode = "editing";
  constructor(options) {
    this.#options = options;
  }
  // ===========================================================================
  // Public Getters
  // ===========================================================================
  /** Current session mode */
  get mode() {
    return this.#session.mode;
  }
  /** Full session state */
  get session() {
    return this.#session;
  }
  /** Whether currently editing a header/footer */
  get isEditing() {
    return this.#session.mode !== "body";
  }
  /** The active header/footer editor (null if in body mode) */
  get activeEditor() {
    return this.#activeEditor;
  }
  /** Set the editor reference (used when editor is created after session manager) */
  setEditor(editor) {
    this.#options.editor = editor;
  }
  /** Header decoration provider */
  get headerDecorationProvider() {
    return this.#headerDecorationProvider;
  }
  /** Set header decoration provider */
  set headerDecorationProvider(provider) {
    this.#headerDecorationProvider = provider;
  }
  /** Footer decoration provider */
  get footerDecorationProvider() {
    return this.#footerDecorationProvider;
  }
  /** Set footer decoration provider */
  set footerDecorationProvider(provider) {
    this.#footerDecorationProvider = provider;
  }
  /** Header/footer adapter for layout */
  get adapter() {
    return this.#headerFooterAdapter;
  }
  /** Header/footer manager */
  get manager() {
    return this.#headerFooterManager;
  }
  /** Editor overlay manager */
  get overlayManager() {
    return this.#overlayManager;
  }
  /** Header layout results */
  get headerLayoutResults() {
    return this.#headerLayoutResults;
  }
  /** Set header layout results */
  set headerLayoutResults(results) {
    this.#headerLayoutResults = results;
  }
  /** Footer layout results */
  get footerLayoutResults() {
    return this.#footerLayoutResults;
  }
  /** Set footer layout results */
  set footerLayoutResults(results) {
    this.#footerLayoutResults = results;
  }
  /** Header layouts by rId */
  get headerLayoutsByRId() {
    return this.#headerLayoutsByRId;
  }
  /** Footer layouts by rId */
  get footerLayoutsByRId() {
    return this.#footerLayoutsByRId;
  }
  /** Multi-section identifier */
  get multiSectionIdentifier() {
    return this.#multiSectionIdentifier;
  }
  /** Set multi-section identifier */
  set multiSectionIdentifier(identifier) {
    this.#multiSectionIdentifier = identifier;
  }
  /** Legacy header/footer identifier */
  get headerFooterIdentifier() {
    return this.#headerFooterIdentifier;
  }
  /** Set legacy header/footer identifier */
  set headerFooterIdentifier(identifier) {
    this.#headerFooterIdentifier = identifier;
  }
  /** Header regions map (pageIndex -> region) */
  get headerRegions() {
    return this.#headerRegions;
  }
  /** Footer regions map (pageIndex -> region) */
  get footerRegions() {
    return this.#footerRegions;
  }
  // ===========================================================================
  // Setup
  // ===========================================================================
  /**
   * Set dependencies from PresentationEditor.
   * Must be called before using the manager.
   */
  setDependencies(deps) {
    this.#deps = deps;
  }
  /**
   * Set callbacks for event emission.
   */
  setCallbacks(callbacks2) {
    this.#callbacks = callbacks2;
  }
  /**
   * Set hover UI elements.
   */
  setHoverElements(elements) {
    this.#hoverOverlay = elements.hoverOverlay;
    this.#hoverTooltip = elements.hoverTooltip;
    this.#modeBanner = elements.modeBanner;
  }
  /**
   * Update document mode.
   */
  setDocumentMode(mode) {
    this.#documentMode = mode;
  }
  /**
   * Set layout results from external layout computation.
   */
  setLayoutResults(headerResults, footerResults) {
    this.#headerLayoutResults = headerResults;
    this.#footerLayoutResults = footerResults;
  }
  /**
   * Initialize the header/footer registry.
   * Called after the editor is ready.
   */
  initialize() {
    if (!this.#options.editor) {
      return;
    }
    const optionsMedia = this.#options?.mediaFiles;
    const storageMedia = this.#options.editor.storage?.image?.media;
    const converter = this.#options.editor.converter;
    const mediaFiles = optionsMedia ?? storageMedia;
    const result = initHeaderFooterRegistry({
      painterHost: this.#options.painterHost,
      visibleHost: this.#options.visibleHost,
      selectionOverlay: this.#options.selectionOverlay,
      editor: this.#options.editor,
      converter,
      mediaFiles,
      isDebug: Boolean(this.#options.isDebug),
      initBudgetMs: this.#options.initBudgetMs ?? 200,
      resetSession: () => {
        this.#managerCleanups = [];
        this.#session = { mode: "body" };
        this.#activeEditor = null;
        this.#deps?.notifyInputBridgeTargetChanged();
      },
      requestRerender: () => {
        this.#deps?.setPendingDocChange();
        this.#deps?.scheduleRerender();
      },
      exitHeaderFooterMode: () => {
        this.exitMode();
      },
      previousCleanups: this.#managerCleanups,
      previousAdapter: this.#headerFooterAdapter,
      previousManager: this.#headerFooterManager,
      previousOverlayManager: this.#overlayManager
    });
    this.#overlayManager = result.overlayManager;
    this.#headerFooterIdentifier = result.headerFooterIdentifier;
    this.#headerFooterManager = result.headerFooterManager;
    this.#headerFooterAdapter = result.headerFooterAdapter;
    this.#managerCleanups = result.cleanups;
  }
  // ===========================================================================
  // Region Management
  // ===========================================================================
  /**
   * Rebuild header/footer regions from layout.
   */
  rebuildRegions(layout) {
    this.#headerRegions.clear();
    this.#footerRegions.clear();
    const layoutOptions = this.#deps?.getLayoutOptions() ?? {};
    const pageHeight = layout.pageSize?.h ?? layoutOptions.pageSize?.h ?? this.#options.defaultPageSize.h;
    if (pageHeight <= 0) return;
    const sectionFirstPageNumbers = /* @__PURE__ */ new Map();
    for (const p2 of layout.pages) {
      const idx = p2.sectionIndex ?? 0;
      if (!sectionFirstPageNumbers.has(idx)) {
        sectionFirstPageNumbers.set(idx, p2.number);
      }
    }
    const defaultMargins = this.#options.defaultMargins;
    layout.pages.forEach((page, pageIndex) => {
      const margins = page.margins ?? layoutOptions.margins ?? defaultMargins;
      const actualPageHeight = page.size?.h ?? pageHeight;
      const headerPayload = this.#headerDecorationProvider?.(page.number, margins, page);
      const headerBox = this.#computeDecorationBox("header", margins, actualPageHeight);
      this.#headerRegions.set(pageIndex, {
        kind: "header",
        headerId: headerPayload?.headerId,
        sectionType: headerPayload?.sectionType ?? this.#computeExpectedSectionType("header", page, sectionFirstPageNumbers),
        pageIndex,
        pageNumber: page.number,
        localX: headerPayload?.hitRegion?.x ?? headerBox.x,
        localY: headerPayload?.hitRegion?.y ?? headerBox.offset,
        width: headerPayload?.hitRegion?.width ?? headerBox.width,
        height: headerPayload?.hitRegion?.height ?? headerBox.height
      });
      const footerPayload = this.#footerDecorationProvider?.(page.number, margins, page);
      const footerBoxMargins = this.#stripFootnoteReserveFromBottomMargin(margins, page);
      const footerBox = this.#computeDecorationBox("footer", footerBoxMargins, actualPageHeight);
      this.#footerRegions.set(pageIndex, {
        kind: "footer",
        headerId: footerPayload?.headerId,
        sectionType: footerPayload?.sectionType ?? this.#computeExpectedSectionType("footer", page, sectionFirstPageNumbers),
        pageIndex,
        pageNumber: page.number,
        localX: footerPayload?.hitRegion?.x ?? footerBox.x,
        localY: footerPayload?.hitRegion?.y ?? footerBox.offset,
        width: footerPayload?.hitRegion?.width ?? footerBox.width,
        height: footerPayload?.hitRegion?.height ?? footerBox.height,
        contentHeight: footerPayload?.contentHeight,
        minY: footerPayload?.minY
      });
    });
  }
  /**
   * Hit test for header/footer regions.
   */
  hitTestRegion(x, y2, layout) {
    if (!layout) return null;
    const layoutOptions = this.#deps?.getLayoutOptions() ?? {};
    const pageHeight = layout.pageSize?.h ?? layoutOptions.pageSize?.h ?? this.#options.defaultPageSize.h;
    const pageGap = layout.pageGap ?? 0;
    if (pageHeight <= 0) return null;
    const pageIndex = Math.max(0, Math.floor(y2 / (pageHeight + pageGap)));
    const pageLocalY = y2 - pageIndex * (pageHeight + pageGap);
    const headerRegion = this.#headerRegions.get(pageIndex);
    if (headerRegion && this.#pointInRegion(headerRegion, x, pageLocalY)) {
      return headerRegion;
    }
    const footerRegion = this.#footerRegions.get(pageIndex);
    if (footerRegion && this.#pointInRegion(footerRegion, x, pageLocalY)) {
      return footerRegion;
    }
    return null;
  }
  /**
   * Get region for a specific page.
   */
  getRegionForPage(kind, pageIndex) {
    const regionMap = kind === "header" ? this.#headerRegions : this.#footerRegions;
    return regionMap.get(pageIndex) ?? null;
  }
  /**
   * Find a region for a page, with fallback to first available region.
   * Used when we need any region of the given kind, even if not for the specific page.
   */
  findRegionForPage(kind, pageIndex) {
    const regionMap = kind === "header" ? this.#headerRegions : this.#footerRegions;
    if (!regionMap) return null;
    return regionMap.get(pageIndex) ?? regionMap.values().next().value ?? null;
  }
  /**
   * Resolve the header/footer descriptor for a given region.
   * Looks up by headerId first, then by sectionType, then falls back to first descriptor.
   */
  resolveDescriptorForRegion(region) {
    const manager = this.#headerFooterManager;
    if (!manager) return null;
    if (region.headerId) {
      const descriptor = manager.getDescriptorById(region.headerId);
      if (descriptor) return descriptor;
    }
    if (region.sectionType) {
      const descriptors2 = manager.getDescriptors(region.kind);
      const match = descriptors2.find((entry) => entry.variant === region.sectionType);
      if (match) return match;
    }
    const descriptors = manager.getDescriptors(region.kind);
    if (!descriptors.length) {
      console.warn("[HeaderFooterSessionManager] No descriptor found for region:", region);
      return null;
    }
    return descriptors[0];
  }
  #pointInRegion(region, x, localY) {
    const withinX = x >= region.localX && x <= region.localX + region.width;
    const withinY = localY >= region.localY && localY <= region.localY + region.height;
    return withinX && withinY;
  }
  // ===========================================================================
  // Mode Transitions
  // ===========================================================================
  /**
   * Activate a header/footer region for editing.
   */
  activateRegion(region) {
    const permission = this.#validateEditPermission();
    if (!permission.allowed) {
      this.#callbacks.onEditBlocked?.(permission.reason ?? "restricted");
      return;
    }
    void this.#enterMode(region);
  }
  /**
   * Exit header/footer editing mode.
   */
  exitMode() {
    if (this.#session.mode === "body") return;
    const editedHeaderId = this.#session.headerId;
    if (this.#activeEditor) {
      this.#activeEditor.setEditable(false);
      this.#activeEditor.setOptions({ documentMode: "viewing" });
    }
    this.#overlayManager?.hideEditingOverlay();
    this.#overlayManager?.showSelectionOverlay();
    this.#activeEditor = null;
    this.#session = { mode: "body" };
    this.#emitModeChanged();
    this.#emitEditingContext(this.#options.editor);
    this.#deps?.notifyInputBridgeTargetChanged();
    if (editedHeaderId) {
      this.#headerFooterAdapter?.invalidate(editedHeaderId);
    }
    this.#headerFooterManager?.refresh();
    this.#deps?.setPendingDocChange();
    this.#deps?.scheduleRerender();
    this.#options.editor?.view?.focus();
  }
  /**
   * Focus header/footer via keyboard shortcut.
   */
  focusShortcut(kind) {
    const region = this.getRegionForPage(kind, 0);
    if (!region) {
      this.#callbacks.onEditBlocked?.("missingRegion");
      return;
    }
    this.activateRegion(region);
  }
  async #enterMode(region) {
    try {
      if (!this.#headerFooterManager || !this.#overlayManager) {
        this.clearHover();
        return;
      }
      const descriptor = this.#resolveDescriptorForRegion(region);
      if (!descriptor) {
        console.warn("[HeaderFooterSessionManager] No descriptor found for region:", region);
        this.clearHover();
        return;
      }
      if (!descriptor.id) {
        console.warn("[HeaderFooterSessionManager] Descriptor missing id:", descriptor);
        this.clearHover();
        return;
      }
      let pageElement = this.#deps?.getPageElement(region.pageIndex) ?? null;
      if (!pageElement) {
        try {
          this.#deps?.scrollPageIntoView(region.pageIndex);
          const mounted = await this.#deps?.waitForPageMount(region.pageIndex, { timeout: 2e3 });
          if (!mounted) {
            console.error("[HeaderFooterSessionManager] Failed to mount page for header/footer editing");
            this.clearHover();
            this.#callbacks.onError?.({
              error: new Error("Failed to mount page for editing"),
              context: "enterMode"
            });
            return;
          }
          pageElement = this.#deps?.getPageElement(region.pageIndex) ?? null;
        } catch (scrollError) {
          console.error("[HeaderFooterSessionManager] Error mounting page:", scrollError);
          this.clearHover();
          this.#callbacks.onError?.({
            error: scrollError,
            context: "enterMode.pageMount"
          });
          return;
        }
      }
      if (!pageElement) {
        console.error("[HeaderFooterSessionManager] Page element not found after mount attempt");
        this.clearHover();
        this.#callbacks.onError?.({
          error: new Error("Page element not found after mount"),
          context: "enterMode"
        });
        return;
      }
      const layoutOptions = this.#deps?.getLayoutOptions() ?? {};
      const { success, editorHost, reason } = this.#overlayManager.showEditingOverlay(
        pageElement,
        region,
        layoutOptions.zoom ?? 1
      );
      if (!success || !editorHost) {
        console.error("[HeaderFooterSessionManager] Failed to create editor host:", reason);
        this.clearHover();
        this.#callbacks.onError?.({
          error: new Error(`Failed to create editor host: ${reason}`),
          context: "enterMode.showOverlay"
        });
        return;
      }
      const layout = this.#headerLayoutResults?.[0]?.layout;
      let editor;
      try {
        editor = await this.#headerFooterManager.ensureEditor(descriptor, {
          editorHost,
          availableWidth: region.width,
          availableHeight: region.height,
          currentPageNumber: region.pageNumber,
          totalPageCount: layout?.pages?.length ?? 1
        });
      } catch (editorError) {
        console.error("[HeaderFooterSessionManager] Error creating editor:", editorError);
        this.#overlayManager.hideEditingOverlay();
        this.clearHover();
        this.#callbacks.onError?.({
          error: editorError,
          context: "enterMode.ensureEditor"
        });
        return;
      }
      if (!editor) {
        console.warn("[HeaderFooterSessionManager] Failed to ensure editor for descriptor:", descriptor);
        this.#overlayManager.hideEditingOverlay();
        this.clearHover();
        this.#callbacks.onError?.({
          error: new Error("Failed to create editor instance"),
          context: "enterMode.ensureEditor"
        });
        return;
      }
      if (region.kind === "footer") {
        const editorContainer = editorHost.firstElementChild;
        if (editorContainer instanceof HTMLElement) {
          editorContainer.style.overflow = "visible";
          if (region.minY != null && region.minY < 0) {
            const shiftDown = Math.abs(region.minY);
            editorContainer.style.transform = `translateY(${shiftDown}px)`;
          } else {
            editorContainer.style.transform = "";
          }
        }
      }
      try {
        editor.setEditable(true);
        editor.setOptions({ documentMode: "editing" });
        try {
          const doc2 = editor.state?.doc;
          if (doc2) {
            const endPos = doc2.content.size - 1;
            const pos = Math.max(1, endPos);
            editor.commands?.setTextSelection?.({ from: pos, to: pos });
          }
        } catch (cursorError) {
          console.warn("[HeaderFooterSessionManager] Could not set cursor to end:", cursorError);
        }
      } catch (editableError) {
        console.error("[HeaderFooterSessionManager] Error setting editor editable:", editableError);
        this.#overlayManager.hideEditingOverlay();
        this.clearHover();
        this.#callbacks.onError?.({
          error: editableError,
          context: "enterMode.setEditable"
        });
        return;
      }
      this.#overlayManager.hideSelectionOverlay();
      this.#activeEditor = editor;
      this.#session = {
        mode: region.kind,
        kind: region.kind,
        headerId: descriptor.id,
        sectionType: descriptor.variant ?? region.sectionType ?? null,
        pageIndex: region.pageIndex,
        pageNumber: region.pageNumber
      };
      this.clearHover();
      try {
        editor.view?.focus();
      } catch (focusError) {
        console.warn("[HeaderFooterSessionManager] Could not focus editor:", focusError);
      }
      this.#emitModeChanged();
      this.#emitEditingContext(editor);
      this.#deps?.notifyInputBridgeTargetChanged();
    } catch (error) {
      console.error("[HeaderFooterSessionManager] Unexpected error in enterMode:", error);
      try {
        this.#overlayManager?.hideEditingOverlay();
        this.#overlayManager?.showSelectionOverlay();
        this.clearHover();
        this.#activeEditor = null;
        this.#session = { mode: "body" };
      } catch (cleanupError) {
        console.error("[HeaderFooterSessionManager] Error during cleanup:", cleanupError);
      }
      this.#callbacks.onError?.({
        error,
        context: "enterMode"
      });
    }
  }
  #validateEditPermission() {
    if (this.#deps?.isViewLocked()) {
      return { allowed: false, reason: "documentMode" };
    }
    if (!this.#options.editor?.isEditable) {
      return { allowed: false, reason: "readOnly" };
    }
    return { allowed: true };
  }
  #resolveDescriptorForRegion(region) {
    if (!this.#headerFooterManager) return null;
    if (region.headerId) {
      const descriptor = this.#headerFooterManager.getDescriptorById(region.headerId);
      if (descriptor) return descriptor;
    }
    if (region.sectionType) {
      const descriptors2 = this.#headerFooterManager.getDescriptors(region.kind);
      const match = descriptors2.find((entry) => entry.variant === region.sectionType);
      if (match) return match;
    }
    const descriptors = this.#headerFooterManager.getDescriptors(region.kind);
    if (!descriptors.length) {
      console.warn("[HeaderFooterSessionManager] No descriptor found for region:", region);
      return null;
    }
    return descriptors[0];
  }
  // ===========================================================================
  // Event Emission
  // ===========================================================================
  #emitModeChanged() {
    this.#callbacks.onModeChanged?.(this.#session);
    this.#callbacks.onUpdateAwarenessSession?.(this.#session);
    this.#updateModeBanner();
  }
  #emitEditingContext(editor) {
    this.#callbacks.onEditingContext?.({
      kind: this.#session.mode,
      editor,
      headerId: this.#session.headerId,
      sectionType: this.#session.sectionType
    });
    const message = this.#session.mode === "body" ? "Exited header/footer edit mode." : `Editing ${this.#session.kind === "header" ? "Header" : "Footer"} (${this.#session.sectionType ?? "default"})`;
    this.#callbacks.onAnnounce?.(message);
  }
  #updateModeBanner() {
    if (!this.#modeBanner) return;
    if (this.#session.mode === "body") {
      this.#modeBanner.style.display = "none";
      this.#modeBanner.textContent = "";
      return;
    }
    const title = this.#session.kind === "header" ? "Header" : "Footer";
    const variant = this.#session.sectionType ?? "default";
    const page = this.#session.pageNumber != null ? `Page ${this.#session.pageNumber}` : "";
    this.#modeBanner.textContent = `Editing ${title} (${variant}) ${page}  Press Esc to return`;
    this.#modeBanner.style.display = "block";
  }
  // ===========================================================================
  // Hover UI
  // ===========================================================================
  /**
   * Render hover highlight for a region.
   */
  renderHover(region) {
    if (this.#documentMode === "viewing") {
      this.clearHover();
      return;
    }
    if (!this.#hoverOverlay || !this.#hoverTooltip) return;
    this.#hoverRegion = region;
    const coords = this.#deps?.convertPageLocalToOverlayCoords(region.pageIndex, region.localX, region.localY);
    if (!coords) {
      this.clearHover();
      return;
    }
    this.#hoverOverlay.style.display = "block";
    this.#hoverOverlay.style.left = `${coords.x}px`;
    this.#hoverOverlay.style.top = `${coords.y}px`;
    this.#hoverOverlay.style.width = `${region.width}px`;
    this.#hoverOverlay.style.height = `${region.height}px`;
    const tooltipText = `Double-click to edit ${region.kind === "header" ? "header" : "footer"}`;
    this.#hoverTooltip.textContent = tooltipText;
    this.#hoverTooltip.style.display = "block";
    this.#hoverTooltip.style.left = `${coords.x}px`;
    const tooltipHeight = 24;
    const spaceAbove = coords.y;
    const regionHeight = region.height;
    const tooltipY = spaceAbove < tooltipHeight + 4 ? coords.y + regionHeight + 4 : coords.y - tooltipHeight;
    this.#hoverTooltip.style.top = `${Math.max(0, tooltipY)}px`;
  }
  /**
   * Clear hover highlight.
   */
  clearHover() {
    this.#hoverRegion = null;
    if (this.#hoverOverlay) {
      this.#hoverOverlay.style.display = "none";
    }
    if (this.#hoverTooltip) {
      this.#hoverTooltip.style.display = "none";
    }
  }
  /** Get current hover region */
  get hoverRegion() {
    return this.#hoverRegion;
  }
  // ===========================================================================
  // Layout
  // ===========================================================================
  /**
   * Build input for header/footer layout computation.
   */
  buildLayoutInput() {
    if (!this.#headerFooterAdapter) {
      return null;
    }
    const headerBlocks = this.#headerFooterAdapter.getBatch("header");
    const footerBlocks = this.#headerFooterAdapter.getBatch("footer");
    const headerBlocksByRId = this.#headerFooterAdapter.getBlocksByRId("header");
    const footerBlocksByRId = this.#headerFooterAdapter.getBlocksByRId("footer");
    if (!headerBlocks && !footerBlocks && !headerBlocksByRId && !footerBlocksByRId) {
      return null;
    }
    const constraints = this.#computeConstraints();
    if (!constraints) {
      return null;
    }
    return {
      headerBlocks,
      footerBlocks,
      headerBlocksByRId,
      footerBlocksByRId,
      constraints
    };
  }
  /**
   * Compute layout constraints for header/footer content.
   */
  #computeConstraints() {
    const layoutOptions = this.#deps?.getLayoutOptions() ?? {};
    const pageSize = layoutOptions.pageSize ?? this.#options.defaultPageSize;
    const margins = layoutOptions.margins ?? this.#options.defaultMargins;
    const marginLeft = margins.left ?? this.#options.defaultMargins.left ?? 0;
    const marginRight = margins.right ?? this.#options.defaultMargins.right ?? 0;
    const bodyContentWidth = pageSize.w - (marginLeft + marginRight);
    if (!Number.isFinite(bodyContentWidth) || bodyContentWidth <= 0) {
      return null;
    }
    const measurementWidth = bodyContentWidth;
    const marginTop = margins.top ?? this.#options.defaultMargins.top ?? 0;
    const marginBottom = margins.bottom ?? this.#options.defaultMargins.bottom ?? 0;
    if (!Number.isFinite(marginTop) || !Number.isFinite(marginBottom)) {
      console.warn("[HeaderFooterSessionManager] Invalid top or bottom margin: not a finite number");
      return null;
    }
    const totalVerticalMargins = marginTop + marginBottom;
    if (totalVerticalMargins >= pageSize.h) {
      console.warn(
        `[HeaderFooterSessionManager] Invalid margins: top (${marginTop}) + bottom (${marginBottom}) = ${totalVerticalMargins} >= page height (${pageSize.h})`
      );
      return null;
    }
    const MIN_HEADER_FOOTER_HEIGHT = 1;
    const height = Math.max(MIN_HEADER_FOOTER_HEIGHT, pageSize.h - totalVerticalMargins);
    const headerMargin = margins.header ?? 0;
    const footerMargin = margins.footer ?? 0;
    const headerBand = Math.max(MIN_HEADER_FOOTER_HEIGHT, marginTop - headerMargin);
    const footerBand = Math.max(MIN_HEADER_FOOTER_HEIGHT, marginBottom - footerMargin);
    const overflowBaseHeight = Math.max(headerBand, footerBand);
    return {
      width: measurementWidth,
      height,
      pageWidth: pageSize.w,
      margins: { left: marginLeft, right: marginRight },
      overflowBaseHeight
    };
  }
  /**
   * Layout per-rId header/footers for multi-section documents.
   */
  async layoutPerRId(headerFooterInput, layout, sectionMetadata) {
    return await layoutPerRIdHeaderFooters(headerFooterInput, layout, sectionMetadata, {
      headerLayoutsByRId: this.#headerLayoutsByRId,
      footerLayoutsByRId: this.#footerLayoutsByRId
    });
  }
  #computeMetrics(kind, layoutHeight, box, pageHeight, footerMargin) {
    const validatedLayoutHeight = Number.isFinite(layoutHeight) && layoutHeight >= 0 ? layoutHeight : 0;
    const containerHeight = Math.max(box.height, validatedLayoutHeight);
    const offset2 = kind === "header" ? box.offset : Math.max(0, pageHeight - footerMargin - containerHeight);
    return {
      layoutHeight: validatedLayoutHeight,
      containerHeight,
      offset: offset2
    };
  }
  #computeDecorationBox(kind, margins, pageHeight) {
    const layoutOptions = this.#deps?.getLayoutOptions() ?? {};
    const pageSize = layoutOptions.pageSize ?? this.#options.defaultPageSize;
    const defaultMargins = this.#options.defaultMargins;
    const marginLeft = margins?.left ?? defaultMargins.left ?? 0;
    const marginRight = margins?.right ?? defaultMargins.right ?? 0;
    const marginTop = margins?.top ?? defaultMargins.top ?? 0;
    const marginBottom = margins?.bottom ?? defaultMargins.bottom ?? 0;
    const headerMargin = margins?.header ?? defaultMargins.header ?? 0;
    const footerMargin = margins?.footer ?? defaultMargins.footer ?? 0;
    const width = pageSize.w - marginLeft - marginRight;
    if (kind === "header") {
      const height = Math.max(1, marginTop - headerMargin);
      return { x: marginLeft, width, height, offset: headerMargin };
    } else {
      const height = Math.max(1, marginBottom - footerMargin);
      const offset2 = pageHeight - marginBottom;
      return { x: marginLeft, width, height, offset: offset2 };
    }
  }
  #computeExpectedSectionType(kind, page, sectionFirstPageNumbers) {
    const pageNumber = page.number;
    const sectionIndex = page.sectionIndex ?? 0;
    const firstPageInSection = sectionFirstPageNumbers.get(sectionIndex);
    const isFirstPageOfSection = firstPageInSection === pageNumber;
    const converter = this.#options.editor.converter;
    const hasAlternateHeaders = converter?.pageStyles?.alternateHeaders === true;
    const headerIds = converter?.headerIds;
    const footerIds = converter?.footerIds;
    const titlePgEnabled = headerIds?.titlePg === true || footerIds?.titlePg === true;
    if (isFirstPageOfSection && titlePgEnabled) {
      return "first";
    }
    if (hasAlternateHeaders) {
      return page.number % 2 === 0 ? "even" : "odd";
    }
    return "default";
  }
  #stripFootnoteReserveFromBottomMargin(margins, page) {
    const footnoteReserved = page.footnoteReserved ?? 0;
    if (footnoteReserved <= 0) return margins;
    const currentBottom = margins?.bottom ?? this.#options.defaultMargins.bottom ?? 0;
    return {
      ...margins,
      bottom: Math.max(0, currentBottom - footnoteReserved)
    };
  }
  // ===========================================================================
  // Selection (for H/F editing mode)
  // ===========================================================================
  /**
   * Compute selection rectangles in header/footer mode.
   */
  computeSelectionRects(from3, to) {
    const context = this.getContext();
    if (!context) {
      console.warn("[HeaderFooterSessionManager] Header/footer context unavailable for selection rects", {
        mode: this.#session.mode,
        pageIndex: this.#session.pageIndex
      });
      return [];
    }
    const bodyPageHeight = this.#deps?.getBodyPageHeight() ?? this.#options.defaultPageSize.h;
    const rects = selectionToRects(context.layout, context.blocks, context.measures, from3, to, void 0) ?? [];
    const headerPageHeight = context.layout.pageSize?.h ?? context.region.height ?? 1;
    return rects.map((rect) => {
      const headerLocalY = rect.y - rect.pageIndex * headerPageHeight;
      return {
        pageIndex: context.region.pageIndex,
        x: rect.x + context.region.localX,
        y: context.region.pageIndex * bodyPageHeight + context.region.localY + headerLocalY,
        width: rect.width,
        height: rect.height
      };
    });
  }
  /**
   * Get the current header/footer layout context.
   */
  getContext() {
    if (this.#session.mode === "body") return null;
    if (!this.#headerFooterManager) return null;
    const pageIndex = this.#session.pageIndex;
    if (pageIndex == null) return null;
    const regionMap = this.#session.mode === "header" ? this.#headerRegions : this.#footerRegions;
    const region = regionMap.get(pageIndex);
    if (!region) {
      console.warn("[HeaderFooterSessionManager] Header/footer region not found for pageIndex:", pageIndex);
      return null;
    }
    const results = this.#session.mode === "header" ? this.#headerLayoutResults : this.#footerLayoutResults;
    if (!results || results.length === 0) {
      console.warn("[HeaderFooterSessionManager] Header/footer layout results not available");
      return null;
    }
    const variant = results.find((entry) => entry.type === this.#session.sectionType) ?? results[0] ?? null;
    if (!variant) {
      console.warn(
        "[HeaderFooterSessionManager] Header/footer variant not found for sectionType:",
        this.#session.sectionType
      );
      return null;
    }
    const pageWidth = Math.max(1, region.width);
    const pageHeight = Math.max(1, variant.layout.height ?? region.height ?? 1);
    const layoutLike = {
      pageSize: { w: pageWidth, h: pageHeight },
      pages: variant.layout.pages.map((page) => ({
        number: page.number,
        numberText: page.numberText,
        fragments: page.fragments
      }))
    };
    return {
      layout: layoutLike,
      blocks: variant.blocks,
      measures: variant.measures,
      region
    };
  }
  /**
   * Get the page height for header/footer mode.
   */
  getPageHeight() {
    const context = this.getContext();
    if (!context) {
      console.warn("[HeaderFooterSessionManager] Header/footer context missing when computing page height");
      return 1;
    }
    return context.layout.pageSize?.h ?? context.region.height ?? 1;
  }
  // ===========================================================================
  // Default Creation
  // ===========================================================================
  /**
   * Create a default header/footer when none exists.
   */
  createDefault(region) {
    const converter = this.#options.editor.converter;
    if (!converter) {
      return;
    }
    const variant = region.sectionType ?? "default";
    if (region.kind === "header" && typeof converter.createDefaultHeader === "function") {
      converter.createDefaultHeader(variant);
    } else if (region.kind === "footer" && typeof converter.createDefaultFooter === "function") {
      converter.createDefaultFooter(variant);
    }
    this.#headerFooterIdentifier = extractIdentifierFromConverter(converter);
  }
  /**
   * Update the header/footer identifier from converter.
   */
  updateIdentifierFromConverter() {
    const converter = this.#options.editor.converter;
    this.#headerFooterIdentifier = extractIdentifierFromConverter(converter);
  }
  /**
   * Set the multi-section identifier.
   */
  setMultiSectionIdentifier(identifier) {
    this.#multiSectionIdentifier = identifier;
  }
  // ===========================================================================
  // Decoration Provider Creation
  // ===========================================================================
  /**
   * Update decoration providers for header and footer.
   * Creates new providers based on layout results and sets them on this manager.
   */
  updateDecorationProviders(layout) {
    this.#headerDecorationProvider = this.createDecorationProvider("header", layout);
    this.#footerDecorationProvider = this.createDecorationProvider("footer", layout);
    this.rebuildRegions(layout);
  }
  /**
   * Create a decoration provider for header or footer rendering.
   */
  createDecorationProvider(kind, layout) {
    const results = kind === "header" ? this.#headerLayoutResults : this.#footerLayoutResults;
    const layoutsByRId = kind === "header" ? this.#headerLayoutsByRId : this.#footerLayoutsByRId;
    if ((!results || results.length === 0) && (!layoutsByRId || layoutsByRId.size === 0)) {
      return void 0;
    }
    const multiSectionId = this.#multiSectionIdentifier;
    const legacyIdentifier = this.#headerFooterIdentifier ?? extractIdentifierFromConverter(this.#options.editor.converter);
    const layoutOptions = this.#deps?.getLayoutOptions() ?? {};
    const defaultPageSize = this.#options.defaultPageSize;
    const defaultMargins = this.#options.defaultMargins;
    const sectionFirstPageNumbers = /* @__PURE__ */ new Map();
    for (const p2 of layout.pages) {
      const idx = p2.sectionIndex ?? 0;
      if (!sectionFirstPageNumbers.has(idx)) {
        sectionFirstPageNumbers.set(idx, p2.number);
      }
    }
    return (pageNumber, pageMargins, page) => {
      const sectionIndex = page?.sectionIndex ?? 0;
      const firstPageInSection = sectionFirstPageNumbers.get(sectionIndex);
      const sectionPageNumber = typeof firstPageInSection === "number" ? pageNumber - firstPageInSection + 1 : pageNumber;
      const headerFooterType = multiSectionId ? getHeaderFooterTypeForSection(pageNumber, sectionIndex, multiSectionId, { kind, sectionPageNumber }) : getHeaderFooterType(pageNumber, legacyIdentifier, { kind });
      let sectionRId;
      if (page?.sectionRefs && kind === "header") {
        sectionRId = page.sectionRefs.headerRefs?.[headerFooterType];
        if (!sectionRId && headerFooterType && headerFooterType !== "default" && sectionIndex > 0 && multiSectionId) {
          const prevSectionIds = multiSectionId.sectionHeaderIds.get(sectionIndex - 1);
          sectionRId = prevSectionIds?.[headerFooterType] ?? void 0;
        }
        if (!sectionRId && headerFooterType !== "default") {
          sectionRId = page.sectionRefs.headerRefs?.default;
        }
      } else if (page?.sectionRefs && kind === "footer") {
        sectionRId = page.sectionRefs.footerRefs?.[headerFooterType];
        if (!sectionRId && headerFooterType && headerFooterType !== "default" && sectionIndex > 0 && multiSectionId) {
          const prevSectionIds = multiSectionId.sectionFooterIds.get(sectionIndex - 1);
          sectionRId = prevSectionIds?.[headerFooterType] ?? void 0;
        }
        if (!sectionRId && headerFooterType !== "default") {
          sectionRId = page.sectionRefs.footerRefs?.default;
        }
      }
      if (!headerFooterType) {
        return null;
      }
      if (sectionRId && layoutsByRId.has(sectionRId)) {
        const rIdLayout = layoutsByRId.get(sectionRId);
        if (!rIdLayout) {
          console.warn(
            `[HeaderFooterSessionManager] Inconsistent state: layoutsByRId.has('${sectionRId}') returned true but get() returned undefined`
          );
        } else {
          const slotPage2 = this.#findPageForNumber(rIdLayout.layout.pages, pageNumber);
          if (slotPage2) {
            const fragments2 = slotPage2.fragments ?? [];
            const pageHeight2 = page?.size?.h ?? layout.pageSize?.h ?? layoutOptions.pageSize?.h ?? defaultPageSize.h;
            const margins2 = pageMargins ?? layout.pages[0]?.margins ?? layoutOptions.margins ?? defaultMargins;
            const decorationMargins2 = kind === "footer" ? this.#stripFootnoteReserveFromBottomMargin(margins2, page ?? null) : margins2;
            const box2 = this.#computeDecorationBox(kind, decorationMargins2, pageHeight2);
            const rawLayoutHeight2 = rIdLayout.layout.height ?? 0;
            const metrics2 = this.#computeMetrics(kind, rawLayoutHeight2, box2, pageHeight2, margins2?.footer ?? 0);
            const layoutMinY2 = rIdLayout.layout.minY ?? 0;
            const normalizedFragments2 = layoutMinY2 < 0 ? fragments2.map((f) => ({ ...f, y: f.y - layoutMinY2 })) : fragments2;
            return {
              fragments: normalizedFragments2,
              height: metrics2.containerHeight,
              contentHeight: metrics2.layoutHeight > 0 ? metrics2.layoutHeight : metrics2.containerHeight,
              offset: metrics2.offset,
              marginLeft: box2.x,
              contentWidth: box2.width,
              headerId: sectionRId,
              sectionType: headerFooterType,
              minY: layoutMinY2,
              box: { x: box2.x, y: metrics2.offset, width: box2.width, height: metrics2.containerHeight },
              hitRegion: { x: box2.x, y: metrics2.offset, width: box2.width, height: metrics2.containerHeight }
            };
          }
        }
      }
      if (!results || results.length === 0) {
        return null;
      }
      const variant = results.find((entry) => entry.type === headerFooterType);
      if (!variant || !variant.layout?.pages?.length) {
        return null;
      }
      const slotPage = this.#findPageForNumber(variant.layout.pages, pageNumber);
      if (!slotPage) {
        return null;
      }
      const fragments = slotPage.fragments ?? [];
      const pageHeight = page?.size?.h ?? layout.pageSize?.h ?? layoutOptions.pageSize?.h ?? defaultPageSize.h;
      const margins = pageMargins ?? layout.pages[0]?.margins ?? layoutOptions.margins ?? defaultMargins;
      const decorationMargins = kind === "footer" ? this.#stripFootnoteReserveFromBottomMargin(margins, page ?? null) : margins;
      const box = this.#computeDecorationBox(kind, decorationMargins, pageHeight);
      const rawLayoutHeight = variant.layout.height ?? 0;
      const metrics = this.#computeMetrics(kind, rawLayoutHeight, box, pageHeight, margins?.footer ?? 0);
      const fallbackId = this.#headerFooterManager?.getVariantId(kind, headerFooterType);
      const finalHeaderId = sectionRId ?? fallbackId ?? void 0;
      const layoutMinY = variant.layout.minY ?? 0;
      const normalizedFragments = layoutMinY < 0 ? fragments.map((f) => ({ ...f, y: f.y - layoutMinY })) : fragments;
      return {
        fragments: normalizedFragments,
        height: metrics.containerHeight,
        contentHeight: metrics.layoutHeight > 0 ? metrics.layoutHeight : metrics.containerHeight,
        offset: metrics.offset,
        marginLeft: box.x,
        contentWidth: box.width,
        headerId: finalHeaderId,
        sectionType: headerFooterType,
        minY: layoutMinY,
        box: { x: box.x, y: metrics.offset, width: box.width, height: metrics.containerHeight },
        hitRegion: { x: box.x, y: metrics.offset, width: box.width, height: metrics.containerHeight }
      };
    };
  }
  /**
   * Find header/footer page layout for a given page number with bucket fallback.
   */
  #findPageForNumber(pages, pageNumber) {
    if (!pages || pages.length === 0) {
      return void 0;
    }
    const exactMatch = pages.find((p2) => p2.number === pageNumber);
    if (exactMatch) {
      return exactMatch;
    }
    const bucket = getBucketForPageNumber(pageNumber);
    const representative = getBucketRepresentative(bucket);
    const bucketMatch = pages.find((p2) => p2.number === representative);
    if (bucketMatch) {
      return bucketMatch;
    }
    return pages[0];
  }
  // ===========================================================================
  // Cleanup
  // ===========================================================================
  /**
   * Clean up all resources.
   */
  destroy() {
    this.#managerCleanups.forEach((fn2) => {
      try {
        fn2();
      } catch (e) {
        console.error("[HeaderFooterSessionManager] Cleanup error:", e);
      }
    });
    this.#managerCleanups = [];
    this.#headerFooterAdapter?.clear();
    this.#headerFooterAdapter = null;
    this.#headerFooterManager?.destroy();
    this.#headerFooterManager = null;
    this.#headerFooterIdentifier = null;
    this.#multiSectionIdentifier = null;
    this.#headerLayoutResults = null;
    this.#footerLayoutResults = null;
    this.#headerLayoutsByRId.clear();
    this.#footerLayoutsByRId.clear();
    this.#headerDecorationProvider = void 0;
    this.#footerDecorationProvider = void 0;
    this.#headerRegions.clear();
    this.#footerRegions.clear();
    this.#session = { mode: "body" };
    this.#activeEditor = null;
    this.#hoverOverlay = null;
    this.#hoverTooltip = null;
    this.#modeBanner = null;
    this.#hoverRegion = null;
    this.#overlayManager = null;
  }
}
const SUBSCRIPT_SUPERSCRIPT_SCALE = 0.65;
const DEFAULT_PAGE_SIZE = { w: 612, h: 792 };
const DEFAULT_MARGINS = { top: 72, right: 72, bottom: 72, left: 72 };
const DEFAULT_VIRTUALIZED_PAGE_GAP = 72;
const DEFAULT_PAGE_GAP = 24;
const DEFAULT_HORIZONTAL_PAGE_GAP = 20;
const HEADER_FOOTER_INIT_BUDGET_MS = 200;
const MAX_ZOOM_WARNING_THRESHOLD = 10;
const MAX_SELECTION_RECTS_PER_USER = 100;
const GLOBAL_PERFORMANCE = typeof performance !== "undefined" ? performance : void 0;
class PresentationEditor extends EventEmitter {
  // Static registry for managing instances globally
  static #instances = /* @__PURE__ */ new Map();
  static {
    this.FALLBACK_COLORS = [
      "#FF6B6B",
      "#4ECDC4",
      "#45B7D1",
      "#FFA07A",
      "#98D8C8",
      "#F7DC6F",
      "#BB8FCE",
      "#85C1E2"
    ];
  }
  static {
    this.CURSOR_STYLES = {
      CARET_WIDTH: 2,
      LABEL_FONT_SIZE: 13,
      LABEL_PADDING: "2px 6px",
      LABEL_OFFSET: "-1.05em",
      SELECTION_BORDER_RADIUS: "2px",
      MAX_LABEL_LENGTH: 30
    };
  }
  /**
   * Get a PresentationEditor instance by document ID.
   */
  static getInstance(documentId) {
    return PresentationEditor.#instances.get(documentId);
  }
  /**
   * Set zoom globally across all PresentationEditor instances.
   */
  static setGlobalZoom(zoom) {
    PresentationEditor.#instances.forEach((instance) => {
      instance.setZoom(zoom);
    });
  }
  #options;
  #editor;
  #visibleHost;
  #viewportHost;
  #painterHost;
  #selectionOverlay;
  #permissionOverlay = null;
  #hiddenHost;
  #layoutOptions;
  #layoutState = { blocks: [], measures: [], layout: null, bookmarks: /* @__PURE__ */ new Map() };
  #domPainter = null;
  #pageGeometryHelper = null;
  #dragDropManager = null;
  #layoutError = null;
  #layoutErrorState = "healthy";
  #errorBanner = null;
  #errorBannerMessage = null;
  #renderScheduled = false;
  #pendingDocChange = false;
  #pendingMapping = null;
  #isRerendering = false;
  #selectionSync = new SelectionSyncCoordinator();
  #epochMapper = new EpochPositionMapper();
  #layoutEpoch = 0;
  #htmlAnnotationHeights = /* @__PURE__ */ new Map();
  #htmlAnnotationMeasureEpoch = -1;
  #htmlAnnotationMeasureAttempts = 0;
  #domPositionIndex = new DomPositionIndex();
  #domIndexObserverManager = null;
  #rafHandle = null;
  #editorListeners = [];
  #sectionMetadata = [];
  #documentMode = "editing";
  #inputBridge = null;
  #trackedChangesMode = "review";
  #trackedChangesEnabled = true;
  #trackedChangesOverrides;
  // Header/footer session management
  #headerFooterSession = null;
  #hoverOverlay = null;
  #hoverTooltip = null;
  #modeBanner = null;
  #ariaLiveRegion = null;
  #a11ySelectionAnnounceTimeout = null;
  #a11yLastAnnouncedSelectionKey = null;
  #lastSelectedFieldAnnotation = null;
  // Remote cursor/presence state management
  /** Manager for remote cursor rendering and awareness subscriptions */
  #remoteCursorManager = null;
  /** DOM element for rendering remote cursor overlays */
  #remoteCursorOverlay = null;
  /** DOM element for rendering local selection/caret (dual-layer overlay architecture) */
  #localSelectionLayer = null;
  // Editor input management
  /** Manager for pointer events, focus, drag selection, and click handling */
  #editorInputManager = null;
  constructor(options) {
    super();
    if (!options?.element) {
      throw new Error("PresentationEditor requires an `element` to mount into.");
    }
    this.#options = options;
    this.#documentMode = options.documentMode ?? "editing";
    this.#visibleHost = options.element;
    this.#visibleHost.innerHTML = "";
    this.#visibleHost.classList.add("presentation-editor");
    this.#syncDocumentModeClass();
    if (!this.#visibleHost.hasAttribute("tabindex")) {
      this.#visibleHost.tabIndex = 0;
    }
    const viewForPosition = this.#visibleHost.ownerDocument?.defaultView ?? window;
    if (viewForPosition.getComputedStyle(this.#visibleHost).position === "static") {
      this.#visibleHost.style.position = "relative";
    }
    const doc2 = this.#visibleHost.ownerDocument ?? document;
    const rawPresence = options.layoutEngineOptions?.presence;
    const validatedPresence = rawPresence ? {
      ...rawPresence,
      // Clamp maxVisible to reasonable range [1, 100]
      maxVisible: rawPresence.maxVisible !== void 0 ? Math.max(1, Math.min(rawPresence.maxVisible, 100)) : rawPresence.maxVisible,
      // Clamp highlightOpacity to [0, 1]
      highlightOpacity: rawPresence.highlightOpacity !== void 0 ? Math.max(0, Math.min(rawPresence.highlightOpacity, 1)) : rawPresence.highlightOpacity
    } : void 0;
    this.#layoutOptions = {
      pageSize: options.layoutEngineOptions?.pageSize ?? DEFAULT_PAGE_SIZE,
      margins: options.layoutEngineOptions?.margins ?? DEFAULT_MARGINS,
      virtualization: options.layoutEngineOptions?.virtualization,
      zoom: options.layoutEngineOptions?.zoom ?? 1,
      pageStyles: options.layoutEngineOptions?.pageStyles,
      debugLabel: options.layoutEngineOptions?.debugLabel,
      layoutMode: options.layoutEngineOptions?.layoutMode ?? "vertical",
      trackedChanges: options.layoutEngineOptions?.trackedChanges,
      emitCommentPositionsInViewing: options.layoutEngineOptions?.emitCommentPositionsInViewing,
      enableCommentsInViewing: options.layoutEngineOptions?.enableCommentsInViewing,
      presence: validatedPresence
    };
    this.#trackedChangesOverrides = options.layoutEngineOptions?.trackedChanges;
    this.#viewportHost = doc2.createElement("div");
    this.#viewportHost.className = "presentation-editor__viewport";
    this.#viewportHost.setAttribute("aria-hidden", "true");
    this.#viewportHost.style.position = "relative";
    this.#viewportHost.style.width = "100%";
    const pageHeight = this.#layoutOptions.pageSize?.h ?? DEFAULT_PAGE_SIZE.h;
    this.#viewportHost.style.minHeight = `${pageHeight}px`;
    this.#visibleHost.appendChild(this.#viewportHost);
    this.#painterHost = doc2.createElement("div");
    this.#painterHost.className = "presentation-editor__pages";
    this.#painterHost.style.transformOrigin = "top left";
    this.#viewportHost.appendChild(this.#painterHost);
    const win = this.#visibleHost?.ownerDocument?.defaultView ?? window;
    this.#domIndexObserverManager = new DomPositionIndexObserverManager({
      windowRoot: win,
      getPainterHost: () => this.#painterHost,
      onRebuild: () => {
        this.#rebuildDomPositionIndex();
        this.#selectionSync.requestRender({ immediate: true });
      }
    });
    this.#domIndexObserverManager.setup();
    this.#selectionSync.on("render", () => this.#updateSelection());
    this.#selectionSync.on("render", () => this.#updatePermissionOverlay());
    this.#permissionOverlay = doc2.createElement("div");
    this.#permissionOverlay.className = "presentation-editor__permission-overlay";
    Object.assign(this.#permissionOverlay.style, {
      position: "absolute",
      inset: "0",
      pointerEvents: "none",
      zIndex: "5"
    });
    this.#viewportHost.appendChild(this.#permissionOverlay);
    this.#selectionOverlay = doc2.createElement("div");
    this.#selectionOverlay.className = "presentation-editor__selection-overlay";
    this.#selectionOverlay.id = `presentation-overlay-${options.documentId || "default"}`;
    this.#selectionOverlay.style.position = "absolute";
    this.#selectionOverlay.style.inset = "0";
    this.#selectionOverlay.style.pointerEvents = "none";
    this.#selectionOverlay.style.zIndex = "10";
    this.#remoteCursorOverlay = doc2.createElement("div");
    this.#remoteCursorOverlay.className = "presentation-editor__selection-layer--remote";
    this.#remoteCursorOverlay.style.position = "absolute";
    this.#remoteCursorOverlay.style.inset = "0";
    this.#remoteCursorOverlay.style.pointerEvents = "none";
    this.#localSelectionLayer = doc2.createElement("div");
    this.#localSelectionLayer.className = "presentation-editor__selection-layer--local";
    this.#localSelectionLayer.style.position = "absolute";
    this.#localSelectionLayer.style.inset = "0";
    this.#localSelectionLayer.style.pointerEvents = "none";
    this.#selectionOverlay.appendChild(this.#remoteCursorOverlay);
    this.#selectionOverlay.appendChild(this.#localSelectionLayer);
    this.#viewportHost.appendChild(this.#selectionOverlay);
    this.#remoteCursorManager = new RemoteCursorManager({
      visibleHost: this.#visibleHost,
      remoteCursorOverlay: this.#remoteCursorOverlay,
      presence: validatedPresence,
      collaborationProvider: options.collaborationProvider,
      fallbackColors: PresentationEditor.FALLBACK_COLORS,
      cursorStyles: PresentationEditor.CURSOR_STYLES,
      maxSelectionRectsPerUser: MAX_SELECTION_RECTS_PER_USER,
      defaultPageHeight: DEFAULT_PAGE_SIZE.h
    });
    this.#remoteCursorManager.setUpdateCallback(() => this.#updateRemoteCursors());
    this.#remoteCursorManager.setReRenderCallback(() => this.#renderRemoteCursors());
    this.#hoverOverlay = doc2.createElement("div");
    this.#hoverOverlay.className = "presentation-editor__hover-overlay";
    Object.assign(this.#hoverOverlay.style, {
      position: "absolute",
      border: "1px dashed rgba(51, 102, 255, 0.8)",
      borderRadius: "2px",
      pointerEvents: "none",
      display: "none",
      zIndex: "11"
    });
    this.#selectionOverlay.appendChild(this.#hoverOverlay);
    this.#hoverTooltip = doc2.createElement("div");
    this.#hoverTooltip.className = "presentation-editor__hover-tooltip";
    Object.assign(this.#hoverTooltip.style, {
      position: "absolute",
      background: "rgba(18, 22, 33, 0.85)",
      color: "#fff",
      padding: "2px 6px",
      fontSize: "12px",
      borderRadius: "2px",
      pointerEvents: "none",
      display: "none",
      zIndex: "12",
      whiteSpace: "nowrap"
    });
    this.#selectionOverlay.appendChild(this.#hoverTooltip);
    this.#modeBanner = doc2.createElement("div");
    this.#modeBanner.className = "presentation-editor__mode-banner";
    Object.assign(this.#modeBanner.style, {
      position: "absolute",
      top: "0",
      left: "50%",
      transform: "translate(-50%, -100%)",
      background: "#1b3fbf",
      color: "#fff",
      padding: "4px 12px",
      borderRadius: "6px",
      fontSize: "13px",
      display: "none",
      zIndex: "15"
    });
    this.#visibleHost.appendChild(this.#modeBanner);
    this.#headerFooterSession = new HeaderFooterSessionManager({
      painterHost: this.#painterHost,
      visibleHost: this.#visibleHost,
      selectionOverlay: this.#selectionOverlay,
      editor: null,
      // Set after editor is created
      isDebug: this.#options.isDebug,
      initBudgetMs: HEADER_FOOTER_INIT_BUDGET_MS,
      defaultPageSize: DEFAULT_PAGE_SIZE,
      defaultMargins: DEFAULT_MARGINS
    });
    this.#headerFooterSession.setHoverElements({
      hoverOverlay: this.#hoverOverlay,
      hoverTooltip: this.#hoverTooltip,
      modeBanner: this.#modeBanner
    });
    this.#headerFooterSession.setDocumentMode(this.#documentMode);
    this.#ariaLiveRegion = doc2.createElement("div");
    this.#ariaLiveRegion.className = "presentation-editor__aria-live";
    this.#ariaLiveRegion.setAttribute("role", "status");
    this.#ariaLiveRegion.setAttribute("aria-live", "polite");
    this.#ariaLiveRegion.setAttribute("aria-atomic", "true");
    Object.assign(this.#ariaLiveRegion.style, {
      position: "absolute",
      width: "1px",
      height: "1px",
      overflow: "hidden",
      clip: "rect(1px, 1px, 1px, 1px)"
    });
    this.#visibleHost.appendChild(this.#ariaLiveRegion);
    this.#hiddenHost = createHiddenHost(doc2, this.#layoutOptions.pageSize?.w ?? DEFAULT_PAGE_SIZE.w);
    if (doc2.body) {
      doc2.body.appendChild(this.#hiddenHost);
    } else {
      this.#visibleHost.appendChild(this.#hiddenHost);
    }
    const { layoutEngineOptions: _layoutEngineOptions, element: _element, ...editorOptions } = options;
    const normalizedEditorProps = {
      ...editorOptions.editorProps ?? {},
      editable: () => {
        return !this.#isViewLocked();
      }
    };
    try {
      this.#editor = new Editor({
        ...editorOptions,
        element: this.#hiddenHost,
        editorProps: normalizedEditorProps,
        documentMode: this.#documentMode
      });
      this.#wrapHiddenEditorFocus();
      this.#editor.presentationEditor = this;
      this.#editor._presentationEditor = this;
      this.#syncHiddenEditorA11yAttributes();
      if (typeof this.#options.disableContextMenu === "boolean") {
        this.setContextMenuDisabled(this.#options.disableContextMenu);
      }
      this.#setupHeaderFooterSession();
      this.#applyZoom();
      this.#setupEditorListeners();
      this.#initializeEditorInputManager();
      this.#setupPointerHandlers();
      this.#setupDragHandlers();
      this.#setupInputBridge();
      this.#syncTrackedChangesPreferences();
      if (options.documentId) {
        PresentationEditor.#instances.set(options.documentId, this);
      }
      this.#pendingDocChange = true;
      this.#scheduleRerender();
      if (this.#options.collaborationProvider?.awareness) {
        const ystate = ySyncPluginKey.getState(this.#editor.state);
        if (ystate && this.#layoutOptions.presence?.enabled !== false) {
          this.#setupCollaborationCursors();
        }
      }
    } catch (error) {
      this.destroy();
      throw error;
    }
  }
  /**
   * Wraps the hidden editor's focus method to prevent unwanted scrolling when it receives focus.
   *
   * The hidden ProseMirror editor is positioned off-screen but must remain focusable for
   * accessibility. When it receives focus, browsers may attempt to scroll it into view,
   * disrupting the user's viewport position. This method wraps the view's focus function
   * to prevent that scroll behavior using multiple fallback strategies.
   *
   * @remarks
   * **Why this exists:**
   * - The hidden editor provides semantic document structure for screen readers
   * - It must be focusable, but is positioned off-screen with `left: -9999px`
   * - Some browsers scroll to bring focused elements into view, breaking the user experience
   * - This wrapper prevents that scroll while maintaining focus behavior
   *
   * **Fallback strategies (in order):**
   * 1. Try `view.dom.focus({ preventScroll: true })` - the standard approach
   * 2. If that fails, try `view.dom.focus()` without options and restore scroll position
   * 3. If both fail, call the original ProseMirror focus method as last resort
   * 4. Always restore scroll position if it changed during any focus attempt
   *
   * **Idempotency:**
   * - Safe to call multiple times - checks `__sdPreventScrollFocus` flag to avoid re-wrapping
   * - The flag is set on the view object after first successful wrap
   *
   * **Test awareness:**
   * - Skips wrapping if the focus function has a `mock` property (Vitest/Jest mocks)
   * - Prevents interference with test assertions and mock function tracking
   */
  #wrapHiddenEditorFocus() {
    const view = this.#editor?.view;
    if (!view || !view.dom || typeof view.focus !== "function") {
      return;
    }
    const viewWithFlag = view;
    if (viewWithFlag.__sdPreventScrollFocus) {
      return;
    }
    const focusFn = view.focus;
    if (focusFn.mock) {
      return;
    }
    viewWithFlag.__sdPreventScrollFocus = true;
    const originalFocus = view.focus.bind(view);
    view.focus = () => {
      const win = this.#visibleHost.ownerDocument?.defaultView;
      if (!win) {
        originalFocus();
        return;
      }
      const beforeX = win.scrollX;
      const beforeY = win.scrollY;
      let focused = false;
      try {
        view.dom.focus({ preventScroll: true });
        focused = true;
      } catch (error) {
        debugLog("warn", "Hidden editor focus: preventScroll failed", {
          error: String(error),
          strategy: "preventScroll"
        });
      }
      if (!focused) {
        try {
          view.dom.focus();
          focused = true;
        } catch (error) {
          debugLog("warn", "Hidden editor focus: standard focus failed", {
            error: String(error),
            strategy: "standard"
          });
        }
      }
      if (!focused) {
        try {
          originalFocus();
        } catch (error) {
          debugLog("error", "Hidden editor focus: all strategies failed", {
            error: String(error),
            strategy: "original"
          });
        }
      }
      if (win.scrollX !== beforeX || win.scrollY !== beforeY) {
        win.scrollTo(beforeX, beforeY);
      }
    };
  }
  /**
   * Accessor for the underlying Editor so SuperDoc can reuse existing APIs.
   */
  get editor() {
    return this.#editor;
  }
  /**
   * Expose the visible host element for renderer-agnostic consumers.
   */
  get element() {
    return this.#visibleHost;
  }
  /**
   * Get the commands interface for the currently active editor (header/footer-aware).
   *
   * This property dynamically routes command execution to the appropriate editor instance:
   * - In body mode, returns the main editor's commands
   * - In header/footer mode, returns the active header/footer editor's commands
   *
   * This ensures that formatting commands (bold, italic, etc.) and other operations
   * execute in the correct editing context.
   *
   * @returns The CommandService instance for the active editor
   *
   * @example
   * ```typescript
   * // This will bold text in the active editor (body or header/footer)
   * presentationEditor.commands.bold();
   * ```
   */
  get commands() {
    const activeEditor = this.getActiveEditor();
    return activeEditor.commands;
  }
  /**
   * Get the ProseMirror editor state for the currently active editor (header/footer-aware).
   *
   * This property dynamically returns the state from the appropriate editor instance:
   * - In body mode, returns the main editor's state
   * - In header/footer mode, returns the active header/footer editor's state
   *
   * This enables components like SlashMenu and context menus to access document
   * state, selection, and schema information in the correct editing context.
   *
   * @returns The EditorState for the active editor
   *
   * @example
   * ```typescript
   * const { selection, doc } = presentationEditor.state;
   * const selectedText = doc.textBetween(selection.from, selection.to);
   * ```
   */
  get state() {
    return this.getActiveEditor().state;
  }
  /**
   * Check if the editor is currently editable (header/footer-aware).
   *
   * This property checks the editable state of the currently active editor:
   * - In body mode, returns whether the main editor is editable
   * - In header/footer mode, returns whether the header/footer editor is editable
   *
   * The editor may be non-editable due to:
   * - Document mode set to 'viewing'
   * - Explicit `editable: false` option
   * - Editor not fully initialized
   *
   * @returns true if the active editor accepts input, false otherwise
   *
   * @example
   * ```typescript
   * if (presentationEditor.isEditable) {
   *   presentationEditor.commands.insertText('Hello');
   * }
   * ```
   */
  get isEditable() {
    return this.getActiveEditor().isEditable;
  }
  /**
   * Get the editor options for the currently active editor (header/footer-aware).
   *
   * This property returns the options object from the appropriate editor instance,
   * providing access to configuration like document mode, AI settings, and custom
   * slash menu configuration.
   *
   * @returns The options object for the active editor
   *
   * @example
   * ```typescript
   * const { documentMode, isAiEnabled } = presentationEditor.options;
   * ```
   */
  get options() {
    return this.getActiveEditor().options;
  }
  /**
   * Dispatch a ProseMirror transaction to the currently active editor (header/footer-aware).
   *
   * This method routes transactions to the appropriate editor instance:
   * - In body mode, dispatches to the main editor
   * - In header/footer mode, dispatches to the active header/footer editor
   *
   * Use this for direct state manipulation when commands are insufficient.
   * For most use cases, prefer using `commands` or `dispatchInActiveEditor`.
   *
   * @param tr - The ProseMirror transaction to dispatch
   *
   * @example
   * ```typescript
   * const { state } = presentationEditor;
   * const tr = state.tr.insertText('Hello', state.selection.from);
   * presentationEditor.dispatch(tr);
   * ```
   */
  dispatch(tr) {
    const activeEditor = this.getActiveEditor();
    activeEditor.view?.dispatch(tr);
  }
  /**
   * Focus the editor, routing focus to the appropriate editing surface.
   *
   * In PresentationEditor, the actual ProseMirror EditorView is hidden and input
   * is bridged from the visible layout surface. This method focuses the hidden
   * editor view to enable keyboard input while the visual focus remains on the
   * rendered presentation.
   *
   * @example
   * ```typescript
   * // After closing a modal, restore focus to the editor
   * presentationEditor.focus();
   * ```
   */
  focus() {
    const activeEditor = this.getActiveEditor();
    activeEditor.view?.focus();
  }
  /**
   * Returns the currently active editor (body or header/footer session).
   *
   * When editing headers or footers, this returns the header/footer editor instance.
   * Otherwise, returns the main document body editor.
   *
   * @returns The active Editor instance
   *
   * @example
   * ```typescript
   * const editor = presentation.getActiveEditor();
   * const selection = editor.state.selection;
   * ```
   */
  getActiveEditor() {
    const session = this.#headerFooterSession?.session;
    const activeHfEditor = this.#headerFooterSession?.activeEditor;
    if (!session || session.mode === "body" || !activeHfEditor) {
      return this.#editor;
    }
    return activeHfEditor;
  }
  /**
   * Undo the last action in the active editor.
   */
  undo() {
    const editor = this.getActiveEditor();
    if (editor?.commands?.undo) {
      return Boolean(editor.commands.undo());
    }
    return false;
  }
  /**
   * Redo the last undone action in the active editor.
   */
  redo() {
    const editor = this.getActiveEditor();
    if (editor?.commands?.redo) {
      return Boolean(editor.commands.redo());
    }
    return false;
  }
  /**
   * Runs a callback against the active editor (body or header/footer session).
   *
   * Use this method when you need to run commands or access state in the currently
   * active editing context (which may be the body or a header/footer region).
   *
   * @param callback - Function that receives the active editor instance
   *
   * @example
   * ```typescript
   * presentation.dispatchInActiveEditor((editor) => {
   *   editor.commands.insertText('Hello world');
   * });
   * ```
   */
  dispatchInActiveEditor(callback) {
    const editor = this.getActiveEditor();
    callback(editor);
  }
  /**
   * Alias for the visible host container so callers can attach listeners explicitly.
   *
   * This is the main scrollable container that hosts the rendered pages.
   * Use this element to attach scroll listeners, measure viewport bounds, or
   * position floating UI elements relative to the editor.
   *
   * @returns The visible host HTMLElement
   *
   * @example
   * ```typescript
   * const host = presentation.visibleHost;
   * host.addEventListener('scroll', () => console.log('Scrolled!'));
   * ```
   */
  get visibleHost() {
    return this.#visibleHost;
  }
  /**
   * Selection overlay element used for caret + highlight rendering.
   *
   * This overlay is positioned absolutely over the rendered pages and contains
   * the visual selection indicators (caret, selection highlights, remote cursors).
   *
   * @returns The selection overlay element, or null if not yet initialized
   *
   * @example
   * ```typescript
   * const overlay = presentation.overlayElement;
   * if (overlay) {
   *   console.log('Overlay dimensions:', overlay.getBoundingClientRect());
   * }
   * ```
   */
  get overlayElement() {
    return this.#selectionOverlay ?? null;
  }
  /**
   * Get the current zoom level.
   *
   * The zoom level is a multiplier that controls the visual scale of the document.
   * Zoom is applied via CSS transform: scale() on the content elements (#painterHost
   * and #selectionOverlay), with the viewport dimensions (#viewportHost) set to the
   * scaled size to ensure proper scroll behavior.
   *
   * Relationship to Centralized Zoom Architecture:
   * - PresentationEditor is the SINGLE SOURCE OF TRUTH for zoom state
   * - Zoom is applied internally via transform: scale() on #painterHost and #selectionOverlay
   * - The #viewportHost dimensions are set to scaled values for proper scroll container behavior
   * - External components (toolbar, UI controls) should use setZoom() to modify zoom
   * - The zoom value is used throughout the system for coordinate transformations
   *
   * Coordinate Space Implications:
   * - Layout coordinates: Unscaled logical pixels used by the layout engine
   * - Screen coordinates: Physical pixels affected by CSS transform: scale()
   * - Conversion: screenCoord = layoutCoord * zoom
   *
   * Zoom Scale:
   * - 1 = 100% (default, no scaling)
   * - 0.5 = 50% (zoomed out, content appears smaller)
   * - 2 = 200% (zoomed in, content appears larger)
   *
   * @returns The current zoom level multiplier (default: 1 if not configured)
   *
   * @example
   * ```typescript
   * const zoom = presentation.zoom;
   * // Convert layout coordinates to screen coordinates
   * const screenX = layoutX * zoom;
   * const screenY = layoutY * zoom;
   *
   * // Convert screen coordinates back to layout coordinates
   * const layoutX = screenX / zoom;
   * const layoutY = screenY / zoom;
   * ```
   */
  get zoom() {
    return this.#layoutOptions.zoom ?? 1;
  }
  /**
   * Set the document mode and update editor editability.
   *
   * This method updates both the PresentationEditor's internal mode state and the
   * underlying Editor's document mode. The hidden editor's editable state will
   * reflect the mode for plugin compatibility (editable in 'editing' and 'suggesting'
   * modes, non-editable in 'viewing' mode), while the presentation layer remains
   * visually inert (handled by hidden container CSS).
   *
   * @param mode - The document mode to set. Valid values:
   *   - 'editing': Full editing capabilities, no tracked changes
   *   - 'suggesting': Editing with tracked changes enabled
   *   - 'viewing': Read-only mode, shows original content without changes
   * @throws {TypeError} If mode is not a string or is not one of the valid modes
   *
   * @example
   * ```typescript
   * const presentation = PresentationEditor.getInstance('doc-123');
   * presentation.setDocumentMode('viewing'); // Switch to read-only
   * ```
   */
  setDocumentMode(mode) {
    if (typeof mode !== "string") {
      throw new TypeError(`[PresentationEditor] setDocumentMode expects a string, received ${typeof mode}`);
    }
    const validModes = ["editing", "viewing", "suggesting"];
    if (!validModes.includes(mode)) {
      throw new TypeError(`[PresentationEditor] Invalid mode "${mode}". Must be one of: ${validModes.join(", ")}`);
    }
    const modeChanged = this.#documentMode !== mode;
    this.#documentMode = mode;
    this.#editor.setDocumentMode(mode);
    this.#headerFooterSession?.setDocumentMode(mode);
    this.#syncDocumentModeClass();
    this.#syncHiddenEditorA11yAttributes();
    const trackedChangesChanged = this.#syncTrackedChangesPreferences();
    if (modeChanged || trackedChangesChanged) {
      this.#pendingDocChange = true;
      this.#scheduleRerender();
    }
    this.#updatePermissionOverlay();
  }
  #syncDocumentModeClass() {
    if (!this.#visibleHost) return;
    this.#visibleHost.classList.toggle("presentation-editor--viewing", this.#documentMode === "viewing");
  }
  /**
   * Override tracked-changes rendering preferencesfor hosts without plugin state
   * or when forcing a specific viewing mode (e.g., PDF preview).
   *
   * @param overrides - Tracked changes overrides object with optional 'mode' and 'enabled' fields
   * @throws {TypeError} If overrides is provided but is not a plain object
   */
  setTrackedChangesOverrides(overrides) {
    if (overrides !== void 0 && (typeof overrides !== "object" || overrides === null || Array.isArray(overrides))) {
      throw new TypeError("[PresentationEditor] setTrackedChangesOverrides expects an object or undefined");
    }
    if (overrides !== void 0) {
      const validModes = ["review", "original", "final", "off"];
      if (overrides.mode !== void 0 && !validModes.includes(overrides.mode)) {
        throw new TypeError(
          `[PresentationEditor] Invalid tracked changes mode "${overrides.mode}". Must be one of: ${validModes.join(", ")}`
        );
      }
      if (overrides.enabled !== void 0 && typeof overrides.enabled !== "boolean") {
        throw new TypeError('[PresentationEditor] tracked changes "enabled" must be a boolean');
      }
    }
    this.#trackedChangesOverrides = overrides;
    this.#layoutOptions.trackedChanges = overrides;
    const trackedChangesChanged = this.#syncTrackedChangesPreferences();
    if (trackedChangesChanged) {
      this.#pendingDocChange = true;
      this.#scheduleRerender();
    }
  }
  /**
   * Update viewing-mode comment rendering behavior and re-render if needed.
   *
   * @param options - Viewing mode comment options.
   */
  setViewingCommentOptions(options = {}) {
    if (options !== void 0 && (typeof options !== "object" || options === null || Array.isArray(options))) {
      throw new TypeError("[PresentationEditor] setViewingCommentOptions expects an object or undefined");
    }
    let hasChanges = false;
    if (typeof options.emitCommentPositionsInViewing === "boolean") {
      if (this.#layoutOptions.emitCommentPositionsInViewing !== options.emitCommentPositionsInViewing) {
        this.#layoutOptions.emitCommentPositionsInViewing = options.emitCommentPositionsInViewing;
        hasChanges = true;
      }
    }
    if (typeof options.enableCommentsInViewing === "boolean") {
      if (this.#layoutOptions.enableCommentsInViewing !== options.enableCommentsInViewing) {
        this.#layoutOptions.enableCommentsInViewing = options.enableCommentsInViewing;
        hasChanges = true;
      }
    }
    if (hasChanges) {
      this.#pendingDocChange = true;
      this.#scheduleRerender();
    }
  }
  /**
   * Toggle the custom context menu at runtime to respect host-level guardrails.
   */
  setContextMenuDisabled(disabled) {
    this.#editor.setOptions({ disableContextMenu: Boolean(disabled) });
  }
  /**
   * Subscribe to layout update events. Returns an unsubscribe function.
   */
  onLayoutUpdated(handler) {
    this.on("layoutUpdated", handler);
    return () => this.off("layoutUpdated", handler);
  }
  /**
   * Subscribe to layout error events. Returns an unsubscribe function.
   */
  onLayoutError(handler) {
    this.on("layoutError", handler);
    return () => this.off("layoutError", handler);
  }
  /**
   * Surface pages for pagination UI consumers.
   */
  getPages() {
    return this.#layoutState.layout?.pages ?? [];
  }
  /**
   * Surface the most recent layout error (if any).
   */
  getLayoutError() {
    return this.#layoutError;
  }
  /**
   * Returns the current health status of the layout engine.
   *
   * @returns Layout health status:
   *   - 'healthy': No errors, layout is functioning normally
   *   - 'degraded': Recovered from errors but may have stale state
   *   - 'failed': Critical error, layout cannot render
   *
   * @example
   * ```typescript
   * const editor = PresentationEditor.getInstance('doc-123');
   * if (!editor.isLayoutHealthy()) {
   *   console.error('Layout is unhealthy:', editor.getLayoutError());
   * }
   * ```
   */
  isLayoutHealthy() {
    return this.#layoutErrorState === "healthy";
  }
  /**
   * Returns the detailed layout health state.
   *
   * @returns One of: 'healthy', 'degraded', 'failed'
   */
  getLayoutHealthState() {
    return this.#layoutErrorState;
  }
  /**
   * Return layout-relative rects for the current document selection.
   */
  getSelectionRects(relativeTo) {
    const selection = this.#editor.state?.selection;
    if (!selection || selection.empty) return [];
    return this.getRangeRects(selection.from, selection.to, relativeTo);
  }
  /**
   * Convert an arbitrary document range into layout-based bounding rects.
   *
   * @param from - Start position in the ProseMirror document
   * @param to - End position in the ProseMirror document
   * @param relativeTo - Optional HTMLElement for coordinate reference. If provided, returns coordinates
   *                     relative to this element's bounding rect. If omitted, returns absolute viewport
   *                     coordinates relative to the selection overlay.
   * @returns Array of rects, each containing pageIndex and position data (left, top, right, bottom, width, height)
   */
  getRangeRects(from3, to, relativeTo) {
    if (!this.#selectionOverlay) return [];
    if (!Number.isFinite(from3) || !Number.isFinite(to)) return [];
    const start2 = Math.min(from3, to);
    const end2 = Math.max(from3, to);
    const zoom = this.#layoutOptions.zoom ?? 1;
    const relativeRect = relativeTo?.getBoundingClientRect() ?? null;
    const containerRect = this.#visibleHost.getBoundingClientRect();
    const scrollLeft = this.#visibleHost.scrollLeft ?? 0;
    const scrollTop = this.#visibleHost.scrollTop ?? 0;
    let usedDomRects = false;
    const sessionMode = this.#headerFooterSession?.session?.mode ?? "body";
    const layoutRectSource = () => {
      if (sessionMode !== "body") {
        return this.#computeHeaderFooterSelectionRects(start2, end2);
      }
      const domRects = this.#computeSelectionRectsFromDom(start2, end2);
      if (domRects != null) {
        usedDomRects = true;
        return domRects;
      }
      if (!this.#layoutState.layout) return [];
      const rects = selectionToRects(
        this.#layoutState.layout,
        this.#layoutState.blocks,
        this.#layoutState.measures,
        start2,
        end2,
        this.#pageGeometryHelper ?? void 0
      ) ?? [];
      return rects;
    };
    const rawRects = layoutRectSource();
    if (!rawRects.length) return [];
    let domCaretStart = null;
    let domCaretEnd = null;
    const pageDelta = {};
    if (!usedDomRects) {
      try {
        domCaretStart = this.#computeDomCaretPageLocal(start2);
        domCaretEnd = this.#computeDomCaretPageLocal(end2);
      } catch (error) {
        if (vue.process$1.env.NODE_ENV === "development") {
          console.warn("[PresentationEditor] DOM caret computation failed in getRectsForRange:", error);
        }
      }
      const layoutCaretStart = this.#computeCaretLayoutRectGeometry(start2, false);
      if (domCaretStart && layoutCaretStart && domCaretStart.pageIndex === layoutCaretStart.pageIndex) {
        pageDelta[domCaretStart.pageIndex] = {
          dx: domCaretStart.x - layoutCaretStart.x,
          dy: domCaretStart.y - layoutCaretStart.y
        };
      }
    }
    const pageHeight = sessionMode === "body" ? this.#getBodyPageHeight() : this.#getHeaderFooterPageHeight();
    const pageGap = this.#layoutState.layout?.pageGap ?? 0;
    const finalRects = rawRects.map((rect, idx, allRects) => {
      let adjustedX = rect.x;
      let adjustedY = rect.y;
      if (!usedDomRects) {
        const delta = pageDelta[rect.pageIndex];
        adjustedX = delta ? rect.x + delta.dx : rect.x;
        adjustedY = delta ? rect.y + delta.dy : rect.y;
        const isFirstRect = idx === 0;
        const isLastRect = idx === allRects.length - 1;
        if (isFirstRect && domCaretStart && rect.pageIndex === domCaretStart.pageIndex) {
          adjustedX = domCaretStart.x;
        }
        if (isLastRect && domCaretEnd && rect.pageIndex === domCaretEnd.pageIndex) {
          const endX = domCaretEnd.x;
          const newWidth = Math.max(1, endX - adjustedX);
          rect = { ...rect, width: newWidth };
        }
      }
      const pageLocalY = adjustedY - rect.pageIndex * (pageHeight + pageGap);
      const coords = this.#convertPageLocalToOverlayCoords(rect.pageIndex, adjustedX, pageLocalY);
      if (!coords) return null;
      const absLeft = coords.x * zoom - scrollLeft + containerRect.left;
      const absTop = coords.y * zoom - scrollTop + containerRect.top;
      const left2 = relativeRect ? absLeft - relativeRect.left : absLeft;
      const top2 = relativeRect ? absTop - relativeRect.top : absTop;
      const width = Math.max(1, rect.width * zoom);
      const height = Math.max(1, rect.height * zoom);
      return {
        pageIndex: rect.pageIndex,
        left: left2,
        top: top2,
        right: left2 + width,
        bottom: top2 + height,
        width,
        height
      };
    }).filter((rect) => Boolean(rect));
    return finalRects;
  }
  /**
   * Get selection bounds for a document range with aggregated bounding box.
   * Returns null if layout is unavailable or the range is invalid.
   *
   * @param from - Start position in the ProseMirror document
   * @param to - End position in the ProseMirror document
   * @param relativeTo - Optional HTMLElement to use as coordinate reference. If provided, returns coordinates
   *                     relative to this element's bounding rect (client coordinates). If omitted, returns
   *                     absolute viewport coordinates (relative to the selection overlay).
   * @returns Object containing aggregated bounds, individual rects, and pageIndex, or null if unavailable
   */
  getSelectionBounds(from3, to, relativeTo) {
    if (!this.#layoutState.layout) return null;
    const rects = this.getRangeRects(from3, to, relativeTo);
    if (!rects.length) return null;
    const bounds = this.#aggregateLayoutBounds(rects);
    if (!bounds) return null;
    return {
      rects,
      bounds,
      pageIndex: rects[0]?.pageIndex ?? 0
    };
  }
  /**
   * Remap comment positions to layout coordinates with bounds and rects.
   * Takes a positions object with threadIds as keys and position data as values.
   * Returns the same structure with added bounds, rects, and pageIndex for each comment.
   *
   * PERFORMANCE NOTE: This iterates all comment positions on every call. For documents with many comments
   * (>100), consider caching layout bounds per comment and invalidating on layout updates.
   *
   * @param positions - Map of threadId -> { start?, end?, pos?, ...otherFields }
   * @param relativeTo - Optional HTMLElement for coordinate reference
   * @returns Updated positions map with bounds, rects, and pageIndex added to each comment
   */
  getCommentBounds(positions, relativeTo) {
    if (!positions || typeof positions !== "object") return positions;
    if (!this.#layoutState.layout) return positions;
    const entries = Object.entries(positions);
    if (!entries.length) return positions;
    let hasUpdates = false;
    const remapped = {};
    entries.forEach(([threadId, data]) => {
      if (!data) {
        remapped[threadId] = data;
        return;
      }
      const start2 = data.start ?? data.pos;
      const end2 = data.end ?? start2;
      if (!Number.isFinite(start2) || !Number.isFinite(end2)) {
        remapped[threadId] = data;
        return;
      }
      const layoutRange = this.getSelectionBounds(start2, end2, relativeTo);
      if (!layoutRange) {
        remapped[threadId] = data;
        return;
      }
      hasUpdates = true;
      remapped[threadId] = {
        ...data,
        bounds: layoutRange.bounds,
        rects: layoutRange.rects,
        pageIndex: layoutRange.pageIndex
      };
    });
    return hasUpdates ? remapped : positions;
  }
  /**
   * Collect all comment and tracked change positions from the PM document.
   *
   * This is the authoritative source for PM positions - called after every
   * layout update to ensure positions are always fresh from the current document.
   *
   * The returned positions contain PM offsets (start, end) which can be passed
   * to getCommentBounds() to compute visual layout coordinates.
   *
   * @returns Map of threadId -> { threadId, start, end }
   */
  #collectCommentPositions() {
    return collectCommentPositions(this.#editor?.state?.doc ?? null, {
      commentMarkName: CommentMarkName,
      trackChangeMarkNames: [superEditor_converter.TrackInsertMarkName, superEditor_converter.TrackDeleteMarkName, superEditor_converter.TrackFormatMarkName]
    });
  }
  /**
   * Return a snapshot of the latest layout state.
   */
  getLayoutSnapshot() {
    return {
      layout: this.#layoutState.layout,
      blocks: this.#layoutState.blocks,
      measures: this.#layoutState.measures,
      sectionMetadata: this.#sectionMetadata
    };
  }
  /**
   * Expose the current layout engine options.
   */
  getLayoutOptions() {
    return { ...this.#layoutOptions };
  }
  /**
   * Get the page styles for the section containing the current caret position.
   *
   * In multi-section documents, different sections can have different page sizes,
   * margins, and orientations. This method returns the styles for the section
   * where the caret is currently located, enabling section-aware UI components
   * like rulers to display accurate information.
   *
   * @returns Object containing:
   *   - pageSize: { width, height } in inches
   *   - pageMargins: { left, right, top, bottom } in inches
   *   - sectionIndex: The current section index (0-based)
   *   - orientation: 'portrait' or 'landscape'
   *
   * Falls back to document-level defaults if section info is unavailable.
   *
   * @example
   * ```typescript
   * const sectionStyles = presentation.getCurrentSectionPageStyles();
   * console.log(`Section ${sectionStyles.sectionIndex}: ${sectionStyles.pageSize.width}" x ${sectionStyles.pageSize.height}"`);
   * ```
   */
  getCurrentSectionPageStyles() {
    return getCurrentSectionPageStyles(
      this.#layoutState.layout,
      this.#getCurrentPageIndex(),
      this.#editor.converter?.pageStyles ?? null
    );
  }
  /**
   * Get current remote cursor states (normalized to absolute PM positions).
   * Returns an array of cursor states for all remote collaborators, excluding the local user.
   *
   * Exposes normalized awareness states for host consumption.
   * Hosts can use this to build custom presence UI (e.g., presence pills, sidebar lists).
   *
   * @returns Array of remote cursor states with PM positions and user metadata
   *
   * @example
   * ```typescript
   * const presentation = PresentationEditor.getInstance('doc-123');
   * const cursors = presentation.getRemoteCursors();
   * cursors.forEach(cursor => {
   *   console.log(`${cursor.user.name} at position ${cursor.head}`);
   * });
   * ```
   */
  getRemoteCursors() {
    return Array.from(this.#remoteCursorManager?.state.values() ?? []);
  }
  /**
   * Adjust layout mode (vertical/book/horizontal) and rerender.
   *
   * Changes how pages are arranged visually:
   * - 'vertical': Pages stacked vertically (default)
   * - 'book': Two-page spread side-by-side
   * - 'horizontal': Pages arranged horizontally
   *
   * Note: Virtualization is automatically disabled for non-vertical modes.
   *
   * @param mode - The layout mode to set
   *
   * @example
   * ```typescript
   * presentation.setLayoutMode('book'); // Two-page spread
   * presentation.setLayoutMode('vertical'); // Back to single column
   * ```
   */
  setLayoutMode(mode) {
    if (!mode || this.#layoutOptions.layoutMode === mode) {
      return;
    }
    this.#layoutOptions.layoutMode = mode;
    if (mode !== "vertical" && this.#layoutOptions.virtualization?.enabled) {
      this.#layoutOptions.virtualization = {
        ...this.#layoutOptions.virtualization,
        enabled: false
      };
    }
    this.#domPainter = null;
    this.#pageGeometryHelper = null;
    this.#pendingDocChange = true;
    this.#scheduleRerender();
  }
  /**
   * Convert a viewport coordinate into a document hit using the current layout.
   */
  hitTest(clientX, clientY) {
    const normalized = this.#normalizeClientPoint(clientX, clientY);
    if (!normalized) {
      return null;
    }
    const sessionMode = this.#headerFooterSession?.session?.mode ?? "body";
    if (sessionMode !== "body") {
      const context = this.#getHeaderFooterContext();
      if (!context) {
        return null;
      }
      const headerPageHeight = context.layout.pageSize?.h ?? context.region.height ?? 1;
      const bodyPageHeight = this.#getBodyPageHeight();
      const pageIndex = Math.max(0, Math.floor(normalized.y / bodyPageHeight));
      if (pageIndex !== context.region.pageIndex) {
        return null;
      }
      const localX = normalized.x - context.region.localX;
      const localY = normalized.y - context.region.pageIndex * bodyPageHeight - context.region.localY;
      if (localX < 0 || localY < 0 || localX > context.region.width || localY > context.region.height) {
        return null;
      }
      const headerPageIndex = Math.floor(localY / headerPageHeight);
      const headerPoint = {
        x: localX,
        y: headerPageIndex * headerPageHeight + (localY - headerPageIndex * headerPageHeight)
      };
      const hit = clickToPosition(
        context.layout,
        context.blocks,
        context.measures,
        headerPoint,
        void 0,
        void 0,
        void 0,
        void 0
      ) ?? null;
      return hit;
    }
    if (!this.#layoutState.layout) {
      return null;
    }
    const rawHit = clickToPosition(
      this.#layoutState.layout,
      this.#layoutState.blocks,
      this.#layoutState.measures,
      normalized,
      this.#viewportHost,
      clientX,
      clientY,
      this.#pageGeometryHelper ?? void 0
    ) ?? null;
    if (!rawHit) {
      return null;
    }
    const doc2 = this.#editor.state?.doc;
    if (!doc2) {
      return rawHit;
    }
    const mapped = this.#epochMapper.mapPosFromLayoutToCurrentDetailed(rawHit.pos, rawHit.layoutEpoch, 1);
    if (!mapped.ok) {
      debugLog("warn", "hitTest mapping failed", mapped);
      return null;
    }
    const clamped = Math.max(0, Math.min(mapped.pos, doc2.content.size));
    return { ...rawHit, pos: clamped, layoutEpoch: mapped.toEpoch };
  }
  #updateSelectionDebugHud() {
    try {
      const activeEditor = this.getActiveEditor();
      const selection = activeEditor?.state?.selection ? { from: activeEditor.state.selection.from, to: activeEditor.state.selection.to } : null;
      updateSelectionDebugHud(this.#viewportHost, {
        docEpoch: this.#epochMapper.getCurrentEpoch(),
        layoutEpoch: this.#layoutEpoch,
        selection,
        lastPointer: this.#editorInputManager?.debugLastPointer ?? null,
        lastHit: this.#editorInputManager?.debugLastHit ?? null
      });
    } catch {
    }
  }
  #computePendingMarginClick(pointerId, x, y2) {
    const layout = this.#layoutState.layout;
    const geometryHelper = this.#pageGeometryHelper;
    if (!layout || !geometryHelper) {
      return null;
    }
    const pageIndex = geometryHelper.getPageIndexAtY(y2);
    if (pageIndex == null) {
      return null;
    }
    const page = layout.pages[pageIndex];
    if (!page) {
      return null;
    }
    const pageWidth = page.size?.w ?? layout.pageSize.w;
    if (!Number.isFinite(pageWidth) || pageWidth <= 0) {
      return null;
    }
    if (!Number.isFinite(x) || x < 0 || x > pageWidth) {
      return null;
    }
    const margins = page.margins ?? this.#layoutOptions.margins ?? DEFAULT_MARGINS;
    const marginLeft = Number.isFinite(margins.left) ? margins.left : DEFAULT_MARGINS.left ?? 0;
    const marginRight = Number.isFinite(margins.right) ? margins.right : DEFAULT_MARGINS.right ?? 0;
    const isLeftMargin = marginLeft > 0 && x < marginLeft;
    const isRightMargin = marginRight > 0 && x > pageWidth - marginRight;
    const pageEl = this.#viewportHost.querySelector(
      `.superdoc-page[data-page-index="${pageIndex}"]`
    );
    if (!pageEl) {
      return null;
    }
    const pageTop = geometryHelper.getPageTop(pageIndex);
    const localY = y2 - pageTop;
    if (!Number.isFinite(localY)) {
      return null;
    }
    const zoom = this.#layoutOptions.zoom ?? 1;
    const pageRect = pageEl.getBoundingClientRect();
    const candidates = [];
    const lineEls = Array.from(pageEl.querySelectorAll(".superdoc-line"));
    for (const lineEl of lineEls) {
      if (lineEl.closest(".superdoc-page-header, .superdoc-page-footer")) {
        continue;
      }
      const pmStart = Number(lineEl.dataset.pmStart ?? "NaN");
      const pmEnd = Number(lineEl.dataset.pmEnd ?? "NaN");
      if (!Number.isFinite(pmStart) || !Number.isFinite(pmEnd)) {
        continue;
      }
      const rect = lineEl.getBoundingClientRect();
      const top2 = (rect.top - pageRect.top) / zoom;
      const bottom2 = (rect.bottom - pageRect.top) / zoom;
      if (!Number.isFinite(top2) || !Number.isFinite(bottom2)) {
        continue;
      }
      const lineEpochRaw = lineEl.dataset.layoutEpoch;
      const pageEpochRaw = pageEl.dataset.layoutEpoch;
      const lineEpoch = lineEpochRaw != null ? Number(lineEpochRaw) : NaN;
      const pageEpoch = pageEpochRaw != null ? Number(pageEpochRaw) : NaN;
      const layoutEpoch = Number.isFinite(lineEpoch) && Number.isFinite(pageEpoch) ? Math.max(lineEpoch, pageEpoch) : Number.isFinite(lineEpoch) ? lineEpoch : Number.isFinite(pageEpoch) ? pageEpoch : 0;
      candidates.push({
        pmStart,
        pmEnd,
        layoutEpoch: Number.isFinite(layoutEpoch) ? layoutEpoch : 0,
        top: top2,
        bottom: bottom2
      });
    }
    if (candidates.length === 0) {
      return null;
    }
    const firstBodyLineTop = Math.min(...candidates.map((c2) => c2.top));
    if (pageIndex === 0 && Number.isFinite(firstBodyLineTop) && localY < firstBodyLineTop) {
      return { pointerId, kind: "aboveFirstLine" };
    }
    if (!isLeftMargin && !isRightMargin) {
      return null;
    }
    let best = null;
    for (const c2 of candidates) {
      if (localY >= c2.top && localY <= c2.bottom) {
        best = c2;
        break;
      }
    }
    if (!best) {
      let bestDistance = Infinity;
      for (const c2 of candidates) {
        const center = (c2.top + c2.bottom) / 2;
        const distance = Math.abs(localY - center);
        if (distance < bestDistance) {
          bestDistance = distance;
          best = c2;
        }
      }
    }
    if (!best) {
      return null;
    }
    return {
      pointerId,
      kind: isLeftMargin ? "left" : "right",
      layoutEpoch: best.layoutEpoch,
      pmStart: best.pmStart,
      pmEnd: best.pmEnd
    };
  }
  /**
   * Normalize viewport coordinates (clientX/clientY) into layout space while respecting zoom + scroll.
   */
  normalizeClientPoint(clientX, clientY) {
    return this.#normalizeClientPoint(clientX, clientY);
  }
  /**
   * Get viewport coordinates for a document position (header/footer-aware).
   *
   * This method provides coordinate mapping that respects the current editing mode:
   * - In body mode, uses the main document layout
   * - In header/footer mode, maps positions within the header/footer layout and transforms
   *   coordinates to viewport space
   *
   * @param pos - Document position in the active editor
   * @returns Coordinate rectangle with top, bottom, left, right, width, height in viewport pixels,
   *          or null if the position cannot be mapped
   *
   * @example
   * ```typescript
   * const coords = presentationEditor.coordsAtPos(42);
   * if (coords) {
   *   console.log(`Position 42 is at viewport coordinates (${coords.left}, ${coords.top})`);
   * }
   * ```
   */
  coordsAtPos(pos) {
    if (!Number.isFinite(pos)) {
      console.warn("[PresentationEditor] coordsAtPos called with invalid position:", pos);
      return null;
    }
    const sessionMode = this.#headerFooterSession?.session?.mode ?? "body";
    if (sessionMode !== "body") {
      const context = this.#getHeaderFooterContext();
      if (!context) {
        console.warn("[PresentationEditor] Header/footer context not available for coordsAtPos");
        return null;
      }
      const rects2 = this.#computeHeaderFooterSelectionRects(pos, pos);
      if (!rects2 || rects2.length === 0) {
        return null;
      }
      const rect2 = rects2[0];
      const zoom = this.#layoutOptions.zoom ?? 1;
      const containerRect = this.#visibleHost.getBoundingClientRect();
      const scrollLeft = this.#visibleHost.scrollLeft ?? 0;
      const scrollTop = this.#visibleHost.scrollTop ?? 0;
      const pageHeight = this.#getBodyPageHeight();
      const pageGap = this.#layoutState.layout?.pageGap ?? 0;
      const pageLocalY = rect2.y - rect2.pageIndex * (pageHeight + pageGap);
      const coords = this.#convertPageLocalToOverlayCoords(rect2.pageIndex, rect2.x, pageLocalY);
      if (!coords) return null;
      return {
        top: coords.y * zoom - scrollTop + containerRect.top,
        bottom: coords.y * zoom - scrollTop + containerRect.top + rect2.height * zoom,
        left: coords.x * zoom - scrollLeft + containerRect.left,
        right: coords.x * zoom - scrollLeft + containerRect.left + rect2.width * zoom,
        width: rect2.width * zoom,
        height: rect2.height * zoom
      };
    }
    const rects = this.getRangeRects(pos, pos);
    if (!rects || rects.length === 0) {
      return null;
    }
    const rect = rects[0];
    return {
      top: rect.top,
      bottom: rect.bottom,
      left: rect.left,
      right: rect.right,
      width: rect.width,
      height: rect.height
    };
  }
  /**
   * Get the painted DOM element that contains a document position (body only).
   *
   * Uses the DomPositionIndex which maps data-pm-start/end attributes to rendered
   * elements. Returns null when the position is not currently mounted (virtualization)
   * or when in header/footer mode.
   *
   * @param pos - Document position in the active editor
   * @param options.forceRebuild - Rebuild the index before lookup
   * @param options.fallbackToCoords - Use elementFromPoint with layout rects if index lookup fails
   * @returns The nearest painted DOM element for the position, or null if unavailable
   */
  getElementAtPos(pos, options = {}) {
    if (!Number.isFinite(pos)) return null;
    if (!this.#painterHost) return null;
    const sessionMode = this.#headerFooterSession?.session?.mode ?? "body";
    if (sessionMode !== "body") return null;
    if (options.forceRebuild || this.#domPositionIndex.size === 0) {
      this.#rebuildDomPositionIndex();
    }
    const indexed = this.#domPositionIndex.findElementAtPosition(pos);
    if (indexed) return indexed;
    if (!options.fallbackToCoords) return null;
    const rects = this.getRangeRects(pos, pos);
    if (!rects.length) return null;
    const doc2 = this.#visibleHost.ownerDocument ?? document;
    for (const rect of rects) {
      const el = doc2.elementFromPoint(rect.left + rect.width / 2, rect.top + rect.height / 2);
      if (el instanceof HTMLElement && this.#painterHost.contains(el)) {
        return el.closest("[data-pm-start][data-pm-end]") ?? el;
      }
    }
    return null;
  }
  /**
   * Scroll the visible host so a given document position is brought into view.
   *
   * This is primarily used by commands like search navigation when running in
   * PresentationEditor mode, where ProseMirror's `scrollIntoView()` operates on the
   * hidden editor and does not affect the rendered viewport.
   *
   * @param pos - Document position in the active editor to scroll to
   * @param options - Scrolling options
   * @param options.block - Alignment within the viewport ('start' | 'center' | 'end' | 'nearest')
   * @param options.behavior - Scroll behavior ('auto' | 'smooth')
   * @returns True if the position could be mapped and scrolling was applied
   */
  scrollToPosition(pos, options = {}) {
    const activeEditor = this.getActiveEditor();
    const doc2 = activeEditor?.state?.doc;
    if (!doc2) return false;
    if (!Number.isFinite(pos)) return false;
    const clampedPos = Math.max(0, Math.min(pos, doc2.content.size));
    const behavior = options.behavior ?? "auto";
    const block = options.block ?? "center";
    const layout = this.#layoutState.layout;
    const sessionMode = this.#headerFooterSession?.session?.mode ?? "body";
    if (layout && sessionMode === "body") {
      let pageIndex = null;
      for (let idx = 0; idx < layout.pages.length; idx++) {
        const page = layout.pages[idx];
        for (const fragment of page.fragments) {
          const frag = fragment;
          if (frag.pmStart != null && frag.pmEnd != null && clampedPos >= frag.pmStart && clampedPos <= frag.pmEnd) {
            pageIndex = idx;
            break;
          }
        }
        if (pageIndex != null) break;
      }
      if (pageIndex != null) {
        const pageEl = getPageElementByIndex(this.#viewportHost, pageIndex);
        if (pageEl) {
          pageEl.scrollIntoView({ block, inline: "nearest", behavior });
          return true;
        }
      }
      return false;
    } else {
      return false;
    }
  }
  /**
   * Get document position from viewport coordinates (header/footer-aware).
   *
   * This method maps viewport coordinates to document positions while respecting
   * the current editing mode:
   * - In body mode, performs hit testing on the main document layout
   * - In header/footer mode, hit tests within the active header/footer region
   * - Returns null if coordinates are outside the editable area
   *
   * @param coords - Viewport coordinates (clientX/clientY)
   * @returns Position result with pos and inside properties, or null if no match
   *
   * @example
   * ```typescript
   * const result = presentationEditor.posAtCoords({ clientX: 100, clientY: 200 });
   * if (result) {
   *   console.log(`Clicked at document position ${result.pos}`);
   * }
   * ```
   */
  posAtCoords(coords) {
    const clientX = coords?.clientX ?? coords?.left ?? null;
    const clientY = coords?.clientY ?? coords?.top ?? null;
    if (!Number.isFinite(clientX) || !Number.isFinite(clientY)) {
      console.warn("[PresentationEditor] posAtCoords called with invalid coordinates:", coords);
      return null;
    }
    const hit = this.hitTest(clientX, clientY);
    if (!hit) {
      return null;
    }
    return {
      pos: hit.pos,
      inside: -1
    };
  }
  /**
   * Aggregate an array of rects into a single bounding box.
   */
  #aggregateLayoutBounds(rects) {
    if (!rects.length) return null;
    const top2 = Math.min(...rects.map((rect) => rect.top));
    const left2 = Math.min(...rects.map((rect) => rect.left));
    const bottom2 = Math.max(...rects.map((rect) => rect.bottom));
    const right2 = Math.max(...rects.map((rect) => rect.right));
    if (!Number.isFinite(top2) || !Number.isFinite(left2) || !Number.isFinite(bottom2) || !Number.isFinite(right2)) {
      return null;
    }
    return {
      top: top2,
      left: left2,
      bottom: bottom2,
      right: right2,
      width: right2 - left2,
      height: bottom2 - top2
    };
  }
  /**
   * Update zoom level and re-render.
   *
   * @param zoom - Zoom level multiplier (1.0 = 100%). Must be a positive finite number.
   * @throws {TypeError} If zoom is not a number
   * @throws {RangeError} If zoom is not finite, is <= 0, or is NaN
   *
   * @example
   * ```typescript
   * editor.setZoom(1.5); // 150% zoom
   * editor.setZoom(0.75); // 75% zoom
   * ```
   */
  setZoom(zoom) {
    if (typeof zoom !== "number") {
      throw new TypeError(`[PresentationEditor] setZoom expects a number, received ${typeof zoom}`);
    }
    if (Number.isNaN(zoom)) {
      throw new RangeError("[PresentationEditor] setZoom expects a valid number (not NaN)");
    }
    if (!Number.isFinite(zoom)) {
      throw new RangeError("[PresentationEditor] setZoom expects a finite number");
    }
    if (zoom <= 0) {
      throw new RangeError("[PresentationEditor] setZoom expects a positive number greater than 0");
    }
    if (zoom > MAX_ZOOM_WARNING_THRESHOLD) {
      console.warn(
        `[PresentationEditor] Zoom level ${zoom} exceeds recommended maximum of ${MAX_ZOOM_WARNING_THRESHOLD}. Performance may degrade.`
      );
    }
    this.#layoutOptions.zoom = zoom;
    this.#applyZoom();
    this.emit("zoomChange", { zoom });
    this.#scheduleSelectionUpdate();
    if (this.#remoteCursorManager?.hasRemoteCursors()) {
      this.#remoteCursorManager.markDirty();
      this.#remoteCursorManager.scheduleUpdate();
    }
    this.#pendingDocChange = true;
    this.#scheduleRerender();
  }
  /**
   * Clean up editor + DOM nodes.
   * Safe to call during partial initialization.
   */
  destroy() {
    if (this.#rafHandle != null) {
      safeCleanup(() => {
        const win = this.#visibleHost?.ownerDocument?.defaultView ?? window;
        win.cancelAnimationFrame(this.#rafHandle);
        this.#rafHandle = null;
      }, "Layout RAF");
    }
    if (this.#remoteCursorManager) {
      safeCleanup(() => {
        this.#remoteCursorManager?.destroy();
        this.#remoteCursorManager = null;
      }, "Remote cursor manager");
    }
    this.#remoteCursorOverlay = null;
    this.#selectionSync.destroy();
    this.#editorListeners.forEach(({ event, handler }) => this.#editor?.off(event, handler));
    this.#editorListeners = [];
    this.#domIndexObserverManager?.destroy();
    this.#domIndexObserverManager = null;
    if (this.#editorInputManager) {
      safeCleanup(() => {
        this.#editorInputManager?.destroy();
        this.#editorInputManager = null;
      }, "Editor input manager");
    }
    this.#inputBridge?.notifyTargetChanged();
    this.#inputBridge?.destroy();
    this.#inputBridge = null;
    if (this.#a11ySelectionAnnounceTimeout != null) {
      clearTimeout(this.#a11ySelectionAnnounceTimeout);
      this.#a11ySelectionAnnounceTimeout = null;
    }
    if (this.#options?.documentId) {
      PresentationEditor.#instances.delete(this.#options.documentId);
    }
    safeCleanup(() => {
      this.#headerFooterSession?.destroy();
      this.#headerFooterSession = null;
    }, "Header/footer session manager");
    this.#domPainter = null;
    this.#pageGeometryHelper = null;
    this.#dragDropManager?.destroy();
    this.#dragDropManager = null;
    this.#selectionOverlay?.remove();
    this.#painterHost?.remove();
    this.#hiddenHost?.remove();
    this.#hoverOverlay = null;
    this.#hoverTooltip = null;
    this.#modeBanner?.remove();
    this.#modeBanner = null;
    this.#ariaLiveRegion?.remove();
    this.#ariaLiveRegion = null;
    this.#errorBanner?.remove();
    if (this.#editor) {
      this.#editor.presentationEditor = null;
      this.#editor.destroy();
    }
  }
  #rebuildDomPositionIndex() {
    if (!this.#painterHost) return;
    try {
      this.#domPositionIndex.rebuild(this.#painterHost);
    } catch (error) {
      debugLog("warn", "DomPositionIndex rebuild failed", { error: String(error) });
    }
  }
  #setupEditorListeners() {
    const handleUpdate = ({ transaction }) => {
      const trackedChangesChanged = this.#syncTrackedChangesPreferences();
      if (transaction) {
        this.#epochMapper.recordTransaction(transaction);
        this.#selectionSync.setDocEpoch(this.#epochMapper.getCurrentEpoch());
      }
      if (trackedChangesChanged || transaction?.docChanged) {
        this.#pendingDocChange = true;
        if (transaction?.docChanged) {
          if (this.#pendingMapping !== null) {
            const combined = this.#pendingMapping.slice();
            combined.appendMapping(transaction.mapping);
            this.#pendingMapping = combined;
          } else {
            this.#pendingMapping = transaction.mapping;
          }
        }
        this.#selectionSync.onLayoutStart();
        this.#scheduleRerender();
      }
      if (transaction?.docChanged) {
        this.#updateLocalAwarenessCursor();
        this.#editorInputManager?.clearCellAnchor();
      }
    };
    const handleSelection = () => {
      this.#scheduleSelectionUpdate();
      this.#updateLocalAwarenessCursor();
      this.#scheduleA11ySelectionAnnouncement();
    };
    this.#editor.on("update", handleUpdate);
    this.#editor.on("selectionUpdate", handleSelection);
    this.#editorListeners.push({ event: "update", handler: handleUpdate });
    this.#editorListeners.push({ event: "selectionUpdate", handler: handleSelection });
    const handlePageStyleUpdate = () => {
      this.#pendingDocChange = true;
      this.#selectionSync.onLayoutStart();
      this.#scheduleRerender();
    };
    this.#editor.on("pageStyleUpdate", handlePageStyleUpdate);
    this.#editorListeners.push({
      event: "pageStyleUpdate",
      handler: handlePageStyleUpdate
    });
    const handleCollaborationReady = (payload) => {
      this.emit("collaborationReady", payload);
      if (this.#options.collaborationProvider?.awareness && this.#layoutOptions.presence?.enabled !== false) {
        this.#setupCollaborationCursors();
      }
    };
    this.#editor.on("collaborationReady", handleCollaborationReady);
    this.#editorListeners.push({
      event: "collaborationReady",
      handler: handleCollaborationReady
    });
    const handleRemoteHeaderFooterChanged = (payload) => {
      this.#headerFooterSession?.adapter?.invalidate(payload.sectionId);
      this.#headerFooterSession?.manager?.refresh();
      this.#pendingDocChange = true;
      this.#scheduleRerender();
    };
    this.#editor.on("remoteHeaderFooterChanged", handleRemoteHeaderFooterChanged);
    this.#editorListeners.push({
      event: "remoteHeaderFooterChanged",
      handler: handleRemoteHeaderFooterChanged
    });
    const handleCommentsUpdate = (payload) => {
      if (this.#domPainter?.setActiveComment) {
        if ("activeCommentId" in payload) {
          const activeId = payload.activeCommentId ?? null;
          this.#domPainter.setActiveComment(activeId);
          this.#pendingDocChange = true;
          this.#scheduleRerender();
        }
      }
    };
    this.#editor.on("commentsUpdate", handleCommentsUpdate);
    this.#editorListeners.push({
      event: "commentsUpdate",
      handler: handleCommentsUpdate
    });
  }
  /**
   * Setup awareness event subscriptions for remote cursor tracking.
   * Delegates to RemoteCursorManager.
   * @private
   */
  #setupCollaborationCursors() {
    this.#remoteCursorManager?.setup();
  }
  /**
   * Update local cursor position in awareness.
   * Delegates to RemoteCursorManager.
   * @private
   */
  #updateLocalAwarenessCursor() {
    this.#remoteCursorManager?.updateLocalCursor(this.#editor?.state ?? null);
  }
  /**
   * Schedule a remote cursor re-render without re-normalizing awareness states.
   * Delegates to RemoteCursorManager.
   * @private
   */
  #scheduleRemoteCursorReRender() {
    this.#remoteCursorManager?.scheduleReRender();
  }
  /**
   * Get render dependencies for the RemoteCursorManager.
   * @private
   */
  #getRemoteCursorRenderDeps() {
    return {
      layout: this.#layoutState?.layout ?? null,
      blocks: this.#layoutState?.blocks ?? [],
      measures: this.#layoutState?.measures ?? [],
      pageGeometryHelper: this.#pageGeometryHelper,
      pageHeight: this.#layoutOptions.pageSize?.h ?? DEFAULT_PAGE_SIZE.h,
      computeCaretLayoutRect: (pos) => this.#computeCaretLayoutRect(pos),
      convertPageLocalToOverlayCoords: (pageIndex, x, y2) => this.#convertPageLocalToOverlayCoords(pageIndex, x, y2)
    };
  }
  /**
   * Update remote cursor state, render overlays, and emit event for host consumption.
   * Delegates to RemoteCursorManager.
   * @private
   */
  #updateRemoteCursors() {
    if (!this.#remoteCursorManager) return;
    this.#remoteCursorManager.update(this.#editor?.state ?? null, this.#getRemoteCursorRenderDeps());
    this.emit("remoteCursorsUpdate", {
      cursors: Array.from(this.#remoteCursorManager.state.values())
    });
  }
  /**
   * Render remote cursors from existing state without normalization.
   * Delegates to RemoteCursorManager.
   * @private
   */
  #renderRemoteCursors() {
    this.#remoteCursorManager?.render(this.#getRemoteCursorRenderDeps());
  }
  /**
   * Initialize the EditorInputManager with dependencies and callbacks.
   * @private
   */
  #initializeEditorInputManager() {
    this.#editorInputManager = new EditorInputManager();
    this.#editorInputManager.setDependencies({
      getActiveEditor: () => this.getActiveEditor(),
      getEditor: () => this.#editor,
      getLayoutState: () => this.#layoutState,
      getEpochMapper: () => this.#epochMapper,
      getViewportHost: () => this.#viewportHost,
      getVisibleHost: () => this.#visibleHost,
      getHeaderFooterSession: () => this.#headerFooterSession,
      getPageGeometryHelper: () => this.#pageGeometryHelper,
      getZoom: () => this.#layoutOptions.zoom ?? 1,
      isViewLocked: () => this.#isViewLocked(),
      getDocumentMode: () => this.#documentMode,
      getPageElement: (pageIndex) => this.#getPageElement(pageIndex),
      isSelectionAwareVirtualizationEnabled: () => this.#isSelectionAwareVirtualizationEnabled()
    });
    this.#editorInputManager.setCallbacks({
      scheduleSelectionUpdate: () => this.#scheduleSelectionUpdate(),
      scheduleRerender: () => this.#scheduleRerender(),
      setPendingDocChange: () => {
        this.#pendingDocChange = true;
      },
      updateSelectionVirtualizationPins: (options) => this.#updateSelectionVirtualizationPins(options),
      scheduleA11ySelectionAnnouncement: (options) => this.#scheduleA11ySelectionAnnouncement(options),
      goToAnchor: (href) => this.goToAnchor(href),
      emit: (event, payload) => this.emit(event, payload),
      normalizeClientPoint: (clientX, clientY) => this.#normalizeClientPoint(clientX, clientY),
      hitTestHeaderFooterRegion: (x, y2) => this.#hitTestHeaderFooterRegion(x, y2),
      exitHeaderFooterMode: () => this.#exitHeaderFooterMode(),
      activateHeaderFooterRegion: (region) => this.#activateHeaderFooterRegion(region),
      createDefaultHeaderFooter: (region) => this.#createDefaultHeaderFooter(region),
      emitHeaderFooterEditBlocked: (reason) => this.#emitHeaderFooterEditBlocked(reason),
      findRegionForPage: (kind, pageIndex) => this.#findRegionForPage(kind, pageIndex),
      getCurrentPageIndex: () => this.#getCurrentPageIndex(),
      resolveDescriptorForRegion: (region) => this.#resolveDescriptorForRegion(region),
      updateSelectionDebugHud: () => this.#updateSelectionDebugHud(),
      clearHoverRegion: () => this.#clearHoverRegion(),
      renderHoverRegion: (region) => this.#renderHoverRegion(region),
      focusEditorAfterImageSelection: () => this.#focusEditorAfterImageSelection(),
      resolveFieldAnnotationSelectionFromElement: (el) => this.#resolveFieldAnnotationSelectionFromElement(el),
      computePendingMarginClick: (pointerId, x, y2) => this.#computePendingMarginClick(pointerId, x, y2),
      selectWordAt: (pos) => this.#selectWordAt(pos),
      selectParagraphAt: (pos) => this.#selectParagraphAt(pos),
      finalizeDragSelectionWithDom: (pointer, dragAnchor, dragMode) => this.#finalizeDragSelectionWithDom(pointer, dragAnchor, dragMode),
      hitTestTable: (x, y2) => this.#hitTestTable(x, y2)
    });
  }
  #setupPointerHandlers() {
    this.#editorInputManager?.bind();
  }
  /**
   * Sets up drag and drop handlers for field annotations.
   */
  #setupDragHandlers() {
    this.#dragDropManager?.destroy();
    this.#dragDropManager = new DragDropManager();
    this.#dragDropManager.setDependencies({
      getActiveEditor: () => this.getActiveEditor(),
      hitTest: (clientX, clientY) => this.hitTest(clientX, clientY),
      scheduleSelectionUpdate: () => this.#scheduleSelectionUpdate(),
      getViewportHost: () => this.#viewportHost,
      getPainterHost: () => this.#painterHost
    });
    this.#dragDropManager.bind();
  }
  /**
   * Focus the editor after image selection and schedule selection update.
   * This method encapsulates the common focus and blur logic used when
   * selecting both inline and block images.
   * @private
   * @returns {void}
   */
  #focusEditorAfterImageSelection() {
    this.#scheduleSelectionUpdate();
    if (document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }
    const editorDom = this.#editor.view?.dom;
    if (editorDom) {
      editorDom.focus();
      this.#editor.view?.focus();
    }
  }
  #resolveFieldAnnotationSelectionFromElement(annotationEl) {
    const pmStartRaw = annotationEl.dataset?.pmStart;
    if (pmStartRaw == null) {
      return null;
    }
    const pmStart = Number(pmStartRaw);
    if (!Number.isFinite(pmStart)) {
      return null;
    }
    const doc2 = this.#editor.state?.doc;
    if (!doc2) {
      return null;
    }
    const layoutEpochRaw = annotationEl.dataset?.layoutEpoch;
    const layoutEpoch = layoutEpochRaw != null ? Number(layoutEpochRaw) : NaN;
    const effectiveEpoch = Number.isFinite(layoutEpoch) ? layoutEpoch : this.#epochMapper.getCurrentEpoch();
    const mapped = this.#epochMapper.mapPosFromLayoutToCurrentDetailed(pmStart, effectiveEpoch, 1);
    if (!mapped.ok) {
      const fallbackPos = Math.max(0, Math.min(pmStart, doc2.content.size));
      const fallbackNode = doc2.nodeAt(fallbackPos);
      if (fallbackNode?.type?.name === "fieldAnnotation") {
        return { node: fallbackNode, pos: fallbackPos };
      }
      this.#pendingDocChange = true;
      this.#scheduleRerender();
      return null;
    }
    const clampedPos = Math.max(0, Math.min(mapped.pos, doc2.content.size));
    const node = doc2.nodeAt(clampedPos);
    if (!node || node.type.name !== "fieldAnnotation") {
      return null;
    }
    return { node, pos: clampedPos };
  }
  #setupInputBridge() {
    this.#inputBridge?.destroy();
    const win = this.#visibleHost.ownerDocument?.defaultView ?? window;
    this.#inputBridge = new PresentationInputBridge(
      win,
      this.#visibleHost,
      () => this.#getActiveDomTarget(),
      () => !this.#isViewLocked()
    );
    this.#inputBridge.bind();
  }
  /**
   * Set up the header/footer session manager with dependencies and callbacks.
   */
  #setupHeaderFooterSession() {
    if (!this.#headerFooterSession) return;
    this.#headerFooterSession.setEditor(this.#editor);
    this.#headerFooterSession.setDependencies({
      getLayoutOptions: () => this.#layoutOptions,
      getPageElement: (pageIndex) => this.#getPageElement(pageIndex),
      scrollPageIntoView: (pageIndex) => this.#scrollPageIntoView(pageIndex),
      waitForPageMount: (pageIndex, options) => this.#waitForPageMount(pageIndex, options),
      convertPageLocalToOverlayCoords: (pageIndex, x, y2) => this.#convertPageLocalToOverlayCoords(pageIndex, x, y2),
      isViewLocked: () => this.#isViewLocked(),
      getBodyPageHeight: () => this.#getBodyPageHeight(),
      notifyInputBridgeTargetChanged: () => this.#inputBridge?.notifyTargetChanged(),
      scheduleRerender: () => this.#scheduleRerender(),
      setPendingDocChange: () => {
        this.#pendingDocChange = true;
      }
    });
    this.#headerFooterSession.setCallbacks({
      onModeChanged: (session) => {
        this.emit("headerFooterModeChanged", {
          mode: session.mode,
          kind: session.kind,
          headerId: session.headerId,
          sectionType: session.sectionType,
          pageIndex: session.pageIndex,
          pageNumber: session.pageNumber
        });
        this.#updateAwarenessSession();
      },
      onEditingContext: (data) => {
        this.emit("headerFooterEditingContext", data);
        this.#announce(
          data.kind === "body" ? "Exited header/footer edit mode." : `Editing ${data.kind === "header" ? "Header" : "Footer"} (${data.sectionType ?? "default"})`
        );
      },
      onEditBlocked: (reason) => {
        this.emit("headerFooterEditBlocked", { reason });
      },
      onError: (data) => {
        this.emit("error", data);
      },
      onAnnounce: (message) => {
        this.#announce(message);
      },
      onUpdateAwarenessSession: () => {
        this.#updateAwarenessSession();
      }
    });
    this.#headerFooterSession.initialize();
  }
  /**
   * Attempts to perform a table hit test for the given normalized coordinates.
   *
   * @param normalizedX - X coordinate in layout space
   * @param normalizedY - Y coordinate in layout space
   * @returns TableHitResult if the point is inside a table cell, null otherwise
   * @private
   */
  #hitTestTable(normalizedX, normalizedY) {
    const configuredPageHeight = (this.#layoutOptions.pageSize ?? DEFAULT_PAGE_SIZE).h;
    return hitTestTable(
      this.#layoutState.layout,
      this.#layoutState.blocks,
      this.#layoutState.measures,
      normalizedX,
      normalizedY,
      configuredPageHeight,
      this.#getEffectivePageGap(),
      this.#pageGeometryHelper
    );
  }
  /**
   * Selects the word at the given document position.
   *
   * This method traverses up the document tree to find the nearest textblock ancestor,
   * then expands the selection to word boundaries using Unicode-aware word character
   * detection. This handles cases where the position is within nested structures like
   * list items or table cells.
   *
   * Algorithm:
   * 1. Traverse ancestors until a textblock is found (paragraphs, headings, list items)
   * 2. From the click position, expand backward while characters match word regex
   * 3. Expand forward while characters match word regex
   * 4. Create a text selection spanning the word boundaries
   *
   * @param pos - The absolute document position where the double-click occurred
   * @returns true if a word was selected successfully, false otherwise
   * @private
   */
  #selectWordAt(pos) {
    const state = this.#editor.state;
    if (!state?.doc) {
      return false;
    }
    const range = computeWordSelectionRangeAt(state, pos);
    if (!range) {
      return false;
    }
    const tr = state.tr.setSelection(superEditor_converter.TextSelection.create(state.doc, range.from, range.to));
    try {
      this.#editor.view?.dispatch(tr);
      return true;
    } catch (error) {
      if (vue.process$1.env.NODE_ENV === "development") {
        console.warn("[PresentationEditor] Failed to select word:", error);
      }
      return false;
    }
  }
  /**
   * Selects the entire paragraph (textblock) at the given document position.
   *
   * This method traverses up the document tree to find the nearest textblock ancestor,
   * then selects from its start to end position. This handles cases where the position
   * is within nested structures like list items or table cells.
   *
   * Algorithm:
   * 1. Traverse ancestors until a textblock is found (paragraphs, headings, list items)
   * 2. Select from textblock.start() to textblock.end()
   *
   * @param pos - The absolute document position where the triple-click occurred
   * @returns true if a paragraph was selected successfully, false otherwise
   * @private
   */
  #selectParagraphAt(pos) {
    const state = this.#editor.state;
    if (!state?.doc) {
      return false;
    }
    const range = computeParagraphSelectionRangeAt(state, pos);
    if (!range) {
      return false;
    }
    const tr = state.tr.setSelection(superEditor_converter.TextSelection.create(state.doc, range.from, range.to));
    try {
      this.#editor.view?.dispatch(tr);
      return true;
    } catch (error) {
      if (vue.process$1.env.NODE_ENV === "development") {
        console.warn("[PresentationEditor] Failed to select paragraph:", error);
      }
      return false;
    }
  }
  /**
   * Calculates extended selection boundaries based on the current extension mode.
   *
   * This helper method consolidates the logic for extending selections to word or paragraph
   * boundaries, used by both shift+click and drag selection handlers. It preserves selection
   * directionality by placing the head on the side where the user is clicking/dragging.
   *
   * @param anchor - The anchor position of the selection (fixed point)
   * @param head - The head position of the selection (moving point)
   * @param mode - The extension mode: 'char' (no extension), 'word', or 'para'
   * @returns Object with selAnchor and selHead positions after applying extension
   * @private
   */
  #calculateExtendedSelection(anchor, head, mode) {
    return calculateExtendedSelection(this.#layoutState.blocks, anchor, head, mode);
  }
  #scheduleRerender() {
    if (this.#renderScheduled) {
      return;
    }
    this.#renderScheduled = true;
    const win = this.#visibleHost.ownerDocument?.defaultView ?? window;
    this.#rafHandle = win.requestAnimationFrame(() => {
      this.#renderScheduled = false;
      this.#flushRerenderQueue().catch((error) => {
        this.#handleLayoutError("render", error instanceof Error ? error : new Error(String(error)));
      });
    });
  }
  async #flushRerenderQueue() {
    if (this.#isRerendering) {
      this.#pendingDocChange = true;
      return;
    }
    if (!this.#pendingDocChange) {
      return;
    }
    this.#pendingDocChange = false;
    this.#isRerendering = true;
    try {
      await this.#rerender();
    } finally {
      this.#isRerendering = false;
      if (this.#pendingDocChange) {
        this.#scheduleRerender();
      }
    }
  }
  async #rerender() {
    this.#selectionSync.onLayoutStart();
    let layoutCompleted = false;
    try {
      let docJson;
      const viewWindow = this.#visibleHost.ownerDocument?.defaultView ?? window;
      const perf = viewWindow?.performance ?? GLOBAL_PERFORMANCE;
      const startMark = perf?.now?.();
      try {
        docJson = this.#editor.getJSON();
      } catch (error) {
        this.#handleLayoutError("render", this.#decorateError(error, "getJSON"));
        return;
      }
      const layoutEpoch = this.#epochMapper.getCurrentEpoch();
      const sectionMetadata = [];
      let blocks;
      let bookmarks = /* @__PURE__ */ new Map();
      let converterContext = void 0;
      try {
        const converter2 = this.#editor.converter;
        const footnoteNumberById = {};
        try {
          const seen = /* @__PURE__ */ new Set();
          let counter = 1;
          this.#editor?.state?.doc?.descendants?.((node) => {
            if (node?.type?.name !== "footnoteReference") return;
            const rawId = node?.attrs?.id;
            if (rawId == null) return;
            const key2 = String(rawId);
            if (!key2 || seen.has(key2)) return;
            seen.add(key2);
            footnoteNumberById[key2] = counter;
            counter += 1;
          });
        } catch {
        }
        try {
          if (converter2 && typeof converter2 === "object") {
            converter2["footnoteNumberById"] = footnoteNumberById;
          }
        } catch {
        }
        converterContext = converter2 ? {
          docx: converter2.convertedXml,
          numbering: converter2.numbering,
          linkedStyles: converter2.linkedStyles,
          ...Object.keys(footnoteNumberById).length ? { footnoteNumberById } : {},
          translatedLinkedStyles: converter2.translatedLinkedStyles,
          translatedNumbering: converter2.translatedNumbering
        } : void 0;
        const atomNodeTypes = getAtomNodeTypes(this.#editor?.schema ?? null);
        const positionMap = this.#editor?.state?.doc && docJson ? buildPositionMapFromPmDoc(this.#editor.state.doc, docJson) : null;
        const commentsEnabled = this.#documentMode !== "viewing" || this.#layoutOptions.enableCommentsInViewing === true;
        const result = toFlowBlocks(docJson, {
          mediaFiles: this.#editor?.storage?.image?.media,
          emitSectionBreaks: true,
          sectionMetadata,
          trackedChangesMode: this.#trackedChangesMode,
          enableTrackedChanges: this.#trackedChangesEnabled,
          enableComments: commentsEnabled,
          enableRichHyperlinks: true,
          themeColors: this.#editor?.converter?.themeColors ?? void 0,
          converterContext,
          ...positionMap ? { positions: positionMap } : {},
          ...atomNodeTypes.length > 0 ? { atomNodeTypes } : {}
        });
        blocks = result.blocks;
        bookmarks = result.bookmarks ?? /* @__PURE__ */ new Map();
      } catch (error) {
        this.#handleLayoutError("render", this.#decorateError(error, "toFlowBlocks"));
        return;
      }
      if (!blocks) {
        this.#handleLayoutError("render", new Error("toFlowBlocks returned undefined blocks"));
        return;
      }
      this.#applyHtmlAnnotationMeasurements(blocks);
      const baseLayoutOptions = this.#resolveLayoutOptions(blocks, sectionMetadata);
      const footnotesLayoutInput = buildFootnotesInput(
        this.#editor?.state,
        this.#editor?.converter,
        converterContext,
        this.#editor?.converter?.themeColors ?? void 0
      );
      const layoutOptions = footnotesLayoutInput ? { ...baseLayoutOptions, footnotes: footnotesLayoutInput } : baseLayoutOptions;
      const previousBlocks = this.#layoutState.blocks;
      const previousLayout = this.#layoutState.layout;
      let layout;
      let measures;
      let headerLayouts;
      let footerLayouts;
      let extraBlocks;
      let extraMeasures;
      const headerFooterInput = this.#buildHeaderFooterInput();
      try {
        const result = await incrementalLayout(
          previousBlocks,
          previousLayout,
          blocks,
          layoutOptions,
          (block, constraints) => measureBlock(block, constraints),
          headerFooterInput ?? void 0
        );
        if (!result || typeof result !== "object") {
          this.#handleLayoutError("render", new Error("incrementalLayout returned invalid result"));
          return;
        }
        if (!result.layout || typeof result.layout !== "object") {
          this.#handleLayoutError("render", new Error("incrementalLayout returned invalid layout"));
          return;
        }
        if (!Array.isArray(result.measures)) {
          this.#handleLayoutError("render", new Error("incrementalLayout returned invalid measures"));
          return;
        }
        ({ layout, measures } = result);
        extraBlocks = Array.isArray(result.extraBlocks) ? result.extraBlocks : void 0;
        extraMeasures = Array.isArray(result.extraMeasures) ? result.extraMeasures : void 0;
        layout.pageGap = this.#getEffectivePageGap();
        layout.layoutEpoch = layoutEpoch;
        headerLayouts = result.headers;
        footerLayouts = result.footers;
      } catch (error) {
        this.#handleLayoutError("render", this.#decorateError(error, "incrementalLayout"));
        return;
      }
      this.#sectionMetadata = sectionMetadata;
      const converter = this.#editor.converter;
      const multiSectionId = buildMultiSectionIdentifier(sectionMetadata, converter?.pageStyles, {
        headerIds: converter?.headerIds,
        footerIds: converter?.footerIds
      });
      if (this.#headerFooterSession) {
        this.#headerFooterSession.multiSectionIdentifier = multiSectionId;
      }
      const anchorMap = computeAnchorMap(bookmarks, layout, blocks);
      this.#layoutState = { blocks, measures, layout, bookmarks, anchorMap };
      if (this.#headerFooterSession) {
        this.#headerFooterSession.headerLayoutResults = headerLayouts ?? null;
        this.#headerFooterSession.footerLayoutResults = footerLayouts ?? null;
      }
      if (this.#layoutState.layout) {
        const pageGap = this.#layoutState.layout.pageGap ?? this.#getEffectivePageGap();
        if (!this.#pageGeometryHelper) {
          this.#pageGeometryHelper = new PageGeometryHelper({
            layout: this.#layoutState.layout,
            pageGap
          });
        } else {
          this.#pageGeometryHelper.updateLayout(this.#layoutState.layout, pageGap);
        }
      }
      await this.#layoutPerRIdHeaderFooters(headerFooterInput, layout, sectionMetadata);
      this.#updateDecorationProviders(layout);
      const painter = this.#ensurePainter(blocks, measures);
      if (typeof painter.setProviders === "function") {
        painter.setProviders(
          this.#headerFooterSession?.headerDecorationProvider,
          this.#headerFooterSession?.footerDecorationProvider
        );
      }
      const headerBlocks = [];
      const headerMeasures = [];
      if (headerLayouts) {
        for (const headerResult of headerLayouts) {
          headerBlocks.push(...headerResult.blocks);
          headerMeasures.push(...headerResult.measures);
        }
      }
      const headerLayoutsByRId = this.#headerFooterSession?.headerLayoutsByRId;
      if (headerLayoutsByRId) {
        for (const rIdResult of headerLayoutsByRId.values()) {
          headerBlocks.push(...rIdResult.blocks);
          headerMeasures.push(...rIdResult.measures);
        }
      }
      const footerBlocks = [];
      const footerMeasures = [];
      if (footerLayouts) {
        for (const footerResult of footerLayouts) {
          footerBlocks.push(...footerResult.blocks);
          footerMeasures.push(...footerResult.measures);
        }
      }
      const footerLayoutsByRId = this.#headerFooterSession?.footerLayoutsByRId;
      if (footerLayoutsByRId) {
        for (const rIdResult of footerLayoutsByRId.values()) {
          footerBlocks.push(...rIdResult.blocks);
          footerMeasures.push(...rIdResult.measures);
        }
      }
      if (extraBlocks && extraMeasures && extraBlocks.length === extraMeasures.length && extraBlocks.length > 0) {
        footerBlocks.push(...extraBlocks);
        footerMeasures.push(...extraMeasures);
      }
      painter.setData?.(
        blocks,
        measures,
        headerBlocks.length > 0 ? headerBlocks : void 0,
        headerMeasures.length > 0 ? headerMeasures : void 0,
        footerBlocks.length > 0 ? footerBlocks : void 0,
        footerMeasures.length > 0 ? footerMeasures : void 0
      );
      this.#domIndexObserverManager?.pause();
      const mapping = this.#pendingMapping;
      this.#pendingMapping = null;
      painter.paint(layout, this.#painterHost, mapping ?? void 0);
      this.#applyVertAlignToLayout();
      this.#rebuildDomPositionIndex();
      this.#domIndexObserverManager?.resume();
      this.#layoutEpoch = layoutEpoch;
      if (this.#updateHtmlAnnotationMeasurements(layoutEpoch)) {
        this.#pendingDocChange = true;
        this.#scheduleRerender();
      }
      this.#epochMapper.onLayoutComplete(layoutEpoch);
      this.#selectionSync.onLayoutComplete(layoutEpoch);
      layoutCompleted = true;
      this.#updatePermissionOverlay();
      this.#layoutError = null;
      this.#layoutErrorState = "healthy";
      this.#dismissErrorBanner();
      this.#applyZoom();
      const metrics = createLayoutMetrics(perf, startMark, layout, blocks);
      const payload = { layout, blocks, measures, metrics };
      this.emit("layoutUpdated", payload);
      this.emit("paginationUpdate", payload);
      const allowViewingCommentPositions = this.#layoutOptions.emitCommentPositionsInViewing === true;
      if (this.#documentMode !== "viewing" || allowViewingCommentPositions) {
        const commentPositions = this.#collectCommentPositions();
        const positionKeys = Object.keys(commentPositions);
        if (positionKeys.length > 0) {
          this.emit("commentPositions", { positions: commentPositions });
        }
      }
      this.#selectionSync.requestRender({ immediate: true });
      if (this.#remoteCursorManager?.hasRemoteCursors()) {
        this.#scheduleRemoteCursorReRender();
      }
    } finally {
      if (!layoutCompleted) {
        this.#selectionSync.onLayoutAbort();
      }
    }
  }
  #ensurePainter(blocks, measures) {
    if (!this.#domPainter) {
      this.#domPainter = createDomPainter({
        blocks,
        measures,
        layoutMode: this.#layoutOptions.layoutMode ?? "vertical",
        virtualization: this.#layoutOptions.virtualization,
        pageStyles: this.#layoutOptions.pageStyles,
        headerProvider: this.#headerFooterSession?.headerDecorationProvider,
        footerProvider: this.#headerFooterSession?.footerDecorationProvider,
        ruler: this.#layoutOptions.ruler,
        pageGap: this.#layoutState.layout?.pageGap ?? this.#getEffectivePageGap()
      });
    }
    return this.#domPainter;
  }
  #applyHtmlAnnotationMeasurements(blocks) {
    if (this.#htmlAnnotationHeights.size === 0) return;
    blocks.forEach((block) => {
      if (block.kind !== "paragraph") return;
      block.runs.forEach((run) => {
        if (run.kind !== "fieldAnnotation" || run.variant !== "html") {
          return;
        }
        if (run.pmStart == null || run.pmEnd == null) {
          return;
        }
        const key2 = `${run.pmStart}-${run.pmEnd}`;
        const height = this.#htmlAnnotationHeights.get(key2);
        if (!height || height <= 0) {
          return;
        }
        const currentSize = run.size ?? {};
        if (currentSize.height === height) {
          return;
        }
        run.size = { ...currentSize, height };
      });
    });
  }
  #updateHtmlAnnotationMeasurements(layoutEpoch) {
    const nextHeights = new Map(this.#htmlAnnotationHeights);
    const annotations = this.#painterHost.querySelectorAll('.annotation[data-type="html"]');
    const threshold = 1;
    let changed = false;
    annotations.forEach((annotation) => {
      const element = annotation;
      const pmStart = element.dataset.pmStart;
      const pmEnd = element.dataset.pmEnd;
      if (!pmStart || !pmEnd) {
        return;
      }
      const height = element.offsetHeight;
      if (height <= 0) {
        return;
      }
      const key2 = `${pmStart}-${pmEnd}`;
      const prev = nextHeights.get(key2);
      if (prev != null && Math.abs(prev - height) <= threshold) {
        return;
      }
      nextHeights.set(key2, height);
      changed = true;
    });
    if (layoutEpoch !== this.#htmlAnnotationMeasureEpoch) {
      this.#htmlAnnotationMeasureEpoch = layoutEpoch;
      this.#htmlAnnotationMeasureAttempts = 0;
    }
    this.#htmlAnnotationHeights = nextHeights;
    if (!changed) {
      return false;
    }
    if (this.#htmlAnnotationMeasureAttempts >= 2) {
      return false;
    }
    this.#htmlAnnotationMeasureAttempts += 1;
    return true;
  }
  /**
   * Requests a local selection overlay update.
   *
   * Selection rendering is coordinated by `SelectionSyncCoordinator` so we never
   * render against a layout that's mid-update (pagination/virtualization), and so
   * we only update when `layoutEpoch` has caught up to the current `docEpoch`.
   */
  #scheduleSelectionUpdate(options) {
    this.#selectionSync.requestRender(options);
  }
  #clearSelectedFieldAnnotationClass() {
    if (this.#lastSelectedFieldAnnotation?.element?.classList?.contains("ProseMirror-selectednode")) {
      this.#lastSelectedFieldAnnotation.element.classList.remove("ProseMirror-selectednode");
    }
    this.#lastSelectedFieldAnnotation = null;
  }
  #setSelectedFieldAnnotationClass(element, pmStart) {
    if (this.#lastSelectedFieldAnnotation?.element && this.#lastSelectedFieldAnnotation.element !== element) {
      this.#lastSelectedFieldAnnotation.element.classList.remove("ProseMirror-selectednode");
    }
    element.classList.add("ProseMirror-selectednode");
    this.#lastSelectedFieldAnnotation = { element, pmStart };
  }
  #syncSelectedFieldAnnotationClass(selection) {
    if (!selection || !(selection instanceof superEditor_converter.NodeSelection)) {
      this.#clearSelectedFieldAnnotationClass();
      return;
    }
    const node = selection.node;
    if (!node || node.type?.name !== "fieldAnnotation") {
      this.#clearSelectedFieldAnnotationClass();
      return;
    }
    if (!this.#painterHost) {
      this.#clearSelectedFieldAnnotationClass();
      return;
    }
    const pmStart = selection.from;
    if (this.#lastSelectedFieldAnnotation?.pmStart === pmStart && this.#lastSelectedFieldAnnotation.element) {
      return;
    }
    const selector = `.annotation[data-pm-start="${pmStart}"]`;
    const element = this.#painterHost.querySelector(selector);
    if (!element) {
      this.#clearSelectedFieldAnnotationClass();
      return;
    }
    this.#setSelectedFieldAnnotationClass(element, pmStart);
  }
  /**
   * Updates the visual cursor/selection overlay to match the current editor selection.
   *
   * Handles several edge cases:
   * - Defers cursor clearing until new position is successfully computed
   * - Preserves existing cursor visibility when position cannot be computed
   * - Skips rendering in header/footer mode and viewing mode
   * - Skips rendering when the painted layout is stale (epoch mismatch)
   *
   * This method is called after layout completes to ensure cursor positioning
   * is based on stable layout data.
   *
   * @returns {void}
   *
   * @remarks
   * Edge cases handled:
   * - Position lookup failure: When #computeCaretLayoutRect(from) returns null, keep the existing caret visible.
   * - Layout staleness: When #layoutEpoch doesn't match the current doc epoch, keep the last known-good overlay.
   *
   * Side effects:
   * - Mutates #localSelectionLayer.innerHTML (clears or sets cursor/selection HTML)
   * - Calls #renderCaretOverlay() or #renderSelectionRects() which mutate DOM
   * - DOM manipulation is wrapped in try/catch to prevent errors from breaking editor state
   *
   * @private
   */
  #updateSelection() {
    const sessionMode = this.#headerFooterSession?.session?.mode ?? "body";
    if (sessionMode !== "body") {
      this.#clearSelectedFieldAnnotationClass();
      return;
    }
    if (!this.#localSelectionLayer) {
      return;
    }
    if (this.#isViewLocked()) {
      try {
        this.#clearSelectedFieldAnnotationClass();
        this.#localSelectionLayer.innerHTML = "";
      } catch (error) {
        if (vue.process$1.env.NODE_ENV === "development") {
          console.warn("[PresentationEditor] Failed to clear selection layer in viewing mode:", error);
        }
      }
      return;
    }
    const layout = this.#layoutState.layout;
    const editorState = this.getActiveEditor().state;
    const selection = editorState?.selection;
    if (!selection) {
      try {
        this.#clearSelectedFieldAnnotationClass();
        this.#localSelectionLayer.innerHTML = "";
      } catch (error) {
        if (vue.process$1.env.NODE_ENV === "development") {
          console.warn("[PresentationEditor] Failed to clear selection layer (no selection):", error);
        }
      }
      return;
    }
    if (!layout) {
      return;
    }
    const { from: from3, to } = selection;
    const docEpoch = this.#epochMapper.getCurrentEpoch();
    if (this.#layoutEpoch < docEpoch) {
      return;
    }
    this.#syncSelectedFieldAnnotationClass(selection);
    this.#updateSelectionVirtualizationPins({ includeDragBuffer: this.#editorInputManager?.isDragging ?? false });
    if (selection instanceof CellSelection) {
      try {
        this.#localSelectionLayer.innerHTML = "";
        this.#renderCellSelectionOverlay(selection, layout);
      } catch (error) {
        console.warn("[PresentationEditor] Failed to render cell selection overlay:", error);
      }
      return;
    }
    if (from3 === to) {
      const caretLayout = this.#computeCaretLayoutRect(from3);
      if (!caretLayout) {
        return;
      }
      try {
        this.#localSelectionLayer.innerHTML = "";
        renderCaretOverlay({
          localSelectionLayer: this.#localSelectionLayer,
          caretLayout,
          convertPageLocalToOverlayCoords: (pageIndex, x, y2) => this.#convertPageLocalToOverlayCoords(pageIndex, x, y2)
        });
      } catch (error) {
        if (vue.process$1.env.NODE_ENV === "development") {
          console.warn("[PresentationEditor] Failed to render caret overlay:", error);
        }
      }
      return;
    }
    const domRects = this.#computeSelectionRectsFromDom(from3, to);
    if (domRects == null) {
      debugLog("warn", "Local selection: DOM rect computation failed", { from: from3, to });
      return;
    }
    try {
      this.#localSelectionLayer.innerHTML = "";
      const isFieldAnnotationSelection = selection instanceof superEditor_converter.NodeSelection && selection.node?.type?.name === "fieldAnnotation";
      if (domRects.length > 0 && !isFieldAnnotationSelection) {
        renderSelectionRects({
          localSelectionLayer: this.#localSelectionLayer,
          rects: domRects,
          pageHeight: this.#getBodyPageHeight(),
          pageGap: this.#layoutState.layout?.pageGap ?? 0,
          convertPageLocalToOverlayCoords: (pageIndex, x, y2) => this.#convertPageLocalToOverlayCoords(pageIndex, x, y2)
        });
      }
    } catch (error) {
      if (vue.process$1.env.NODE_ENV === "development") {
        console.warn("[PresentationEditor] Failed to render selection rects:", error);
      }
    }
  }
  /**
   * Updates the permission overlay (w:permStart/w:permEnd) to match the current editor permission ranges.
   *
   * This method is called after layout completes to ensure permission overlay
   * is based on stable permission ranges data.
   */
  #updatePermissionOverlay() {
    const overlay2 = this.#permissionOverlay;
    if (!overlay2) {
      return;
    }
    const sessionModeForPerm = this.#headerFooterSession?.session?.mode ?? "body";
    if (sessionModeForPerm !== "body") {
      overlay2.innerHTML = "";
      return;
    }
    const permissionStorage = this.#editor?.storage?.permissionRanges;
    const ranges = permissionStorage?.ranges ?? [];
    const shouldRender = ranges.length > 0;
    if (!shouldRender) {
      overlay2.innerHTML = "";
      return;
    }
    const layout = this.#layoutState.layout;
    if (!layout) {
      overlay2.innerHTML = "";
      return;
    }
    const docEpoch = this.#epochMapper.getCurrentEpoch();
    if (this.#layoutEpoch < docEpoch) {
      return;
    }
    const pageHeight = this.#getBodyPageHeight();
    const pageGap = layout.pageGap ?? this.#getEffectivePageGap();
    const fragment = overlay2.ownerDocument?.createDocumentFragment();
    if (!fragment) {
      overlay2.innerHTML = "";
      return;
    }
    ranges.forEach(({ from: from3, to }) => {
      const rects = this.#computeSelectionRectsFromDom(from3, to);
      if (!rects?.length) {
        return;
      }
      rects.forEach((rect) => {
        const pageLocalY = rect.y - rect.pageIndex * (pageHeight + pageGap);
        const coords = this.#convertPageLocalToOverlayCoords(rect.pageIndex, rect.x, pageLocalY);
        if (!coords) {
          return;
        }
        const highlight = overlay2.ownerDocument?.createElement("div");
        if (!highlight) {
          return;
        }
        highlight.className = "presentation-editor__permission-highlight";
        Object.assign(highlight.style, {
          position: "absolute",
          left: `${coords.x}px`,
          top: `${coords.y}px`,
          width: `${Math.max(1, rect.width)}px`,
          height: `${Math.max(1, rect.height)}px`,
          borderRadius: "2px",
          pointerEvents: "none",
          zIndex: 1
        });
        fragment.appendChild(highlight);
      });
    });
    overlay2.innerHTML = "";
    overlay2.appendChild(fragment);
  }
  #resolveLayoutOptions(blocks, sectionMetadata) {
    const defaults = this.#computeDefaultLayoutDefaults();
    const firstSection = blocks?.find(
      (block) => block.kind === "sectionBreak" && block?.attrs?.isFirstSection
    );
    const pageSize = firstSection?.pageSize ?? defaults.pageSize;
    const margins = {
      ...defaults.margins,
      ...firstSection?.margins?.top != null ? { top: firstSection.margins.top } : {},
      ...firstSection?.margins?.right != null ? { right: firstSection.margins.right } : {},
      ...firstSection?.margins?.bottom != null ? { bottom: firstSection.margins.bottom } : {},
      ...firstSection?.margins?.left != null ? { left: firstSection.margins.left } : {},
      ...firstSection?.margins?.header != null ? { header: firstSection.margins.header } : {},
      ...firstSection?.margins?.footer != null ? { footer: firstSection.margins.footer } : {}
    };
    const columns = firstSection?.columns ?? defaults.columns;
    this.#layoutOptions.pageSize = pageSize;
    this.#layoutOptions.margins = margins;
    this.#hiddenHost.style.width = `${pageSize.w}px`;
    return {
      pageSize,
      margins,
      ...columns ? { columns } : {},
      sectionMetadata
    };
  }
  #buildHeaderFooterInput() {
    const adapter = this.#headerFooterSession?.adapter;
    if (!adapter) {
      return null;
    }
    const headerBlocks = adapter.getBatch("header");
    const footerBlocks = adapter.getBatch("footer");
    const headerBlocksByRId = adapter.getBlocksByRId("header");
    const footerBlocksByRId = adapter.getBlocksByRId("footer");
    if (!headerBlocks && !footerBlocks && !headerBlocksByRId && !footerBlocksByRId) {
      return null;
    }
    const constraints = this.#computeHeaderFooterConstraints();
    if (!constraints) {
      return null;
    }
    return {
      headerBlocks,
      footerBlocks,
      headerBlocksByRId,
      footerBlocksByRId,
      constraints
    };
  }
  /**
   * Computes layout constraints for header and footer content.
   *
   * This method calculates the available width and height for laying out header/footer
   * content, following Microsoft Word's layout model:
   * - Headers/footers use the same left/right margins as the body content
   * - Content renders at its natural height and can extend beyond the nominal space
   * - Body text boundaries are adjusted (effectiveTopMargin/effectiveBottomMargin) to prevent overlap
   *
   * The width is constrained to the body content width (page width minus left/right margins).
   * The height represents the maximum available vertical space between top and bottom margins,
   * allowing header/footer content to grow naturally and push body text as needed.
   *
   * @returns Constraint object containing width, height, pageWidth, and margins,
   *          or null if the constraints cannot be computed (e.g., invalid margins that
   *          exceed page dimensions or produce non-positive content width/height).
   */
  #computeHeaderFooterConstraints() {
    const pageSize = this.#layoutOptions.pageSize ?? DEFAULT_PAGE_SIZE;
    const margins = this.#layoutOptions.margins ?? DEFAULT_MARGINS;
    const marginLeft = margins.left ?? DEFAULT_MARGINS.left;
    const marginRight = margins.right ?? DEFAULT_MARGINS.right;
    const bodyContentWidth = pageSize.w - (marginLeft + marginRight);
    if (!Number.isFinite(bodyContentWidth) || bodyContentWidth <= 0) {
      return null;
    }
    const measurementWidth = bodyContentWidth;
    const marginTop = margins.top ?? DEFAULT_MARGINS.top;
    const marginBottom = margins.bottom ?? DEFAULT_MARGINS.bottom;
    if (!Number.isFinite(marginTop) || !Number.isFinite(marginBottom)) {
      console.warn("[PresentationEditor] Invalid top or bottom margin: not a finite number");
      return null;
    }
    const totalVerticalMargins = marginTop + marginBottom;
    if (totalVerticalMargins >= pageSize.h) {
      console.warn(
        `[PresentationEditor] Invalid margins: top (${marginTop}) + bottom (${marginBottom}) = ${totalVerticalMargins} >= page height (${pageSize.h})`
      );
      return null;
    }
    const MIN_HEADER_FOOTER_HEIGHT = 1;
    const height = Math.max(MIN_HEADER_FOOTER_HEIGHT, pageSize.h - totalVerticalMargins);
    const headerMargin = margins.header ?? 0;
    const footerMargin = margins.footer ?? 0;
    const headerBand = Math.max(MIN_HEADER_FOOTER_HEIGHT, marginTop - headerMargin);
    const footerBand = Math.max(MIN_HEADER_FOOTER_HEIGHT, marginBottom - footerMargin);
    const overflowBaseHeight = Math.max(headerBand, footerBand);
    return {
      width: measurementWidth,
      height,
      // Pass actual page dimensions for page-relative anchor positioning in headers/footers
      pageWidth: pageSize.w,
      margins: { left: marginLeft, right: marginRight },
      overflowBaseHeight
    };
  }
  /**
   * Lays out per-rId header/footer content for multi-section documents.
   *
   * This method processes header/footer content for each unique rId, enabling
   * different sections to have different header/footer content. The layouts
   * are stored in #headerLayoutsByRId and #footerLayoutsByRId for use by
   * the decoration provider.
   */
  async #layoutPerRIdHeaderFooters(headerFooterInput, layout, sectionMetadata) {
    if (this.#headerFooterSession) {
      await this.#headerFooterSession.layoutPerRId(headerFooterInput, layout, sectionMetadata);
    }
  }
  /**
   * Update decoration providers for header/footer.
   * Delegates to HeaderFooterSessionManager which handles provider creation.
   */
  #updateDecorationProviders(layout) {
    this.#headerFooterSession?.updateDecorationProviders(layout);
  }
  /**
   * Hit test for header/footer regions at a given point.
   * Delegates to HeaderFooterSessionManager which manages region tracking.
   */
  #hitTestHeaderFooterRegion(x, y2) {
    return this.#headerFooterSession?.hitTestRegion(x, y2, this.#layoutState.layout) ?? null;
  }
  #activateHeaderFooterRegion(region) {
    this.#headerFooterSession?.activateRegion(region);
  }
  #exitHeaderFooterMode() {
    this.#headerFooterSession?.exitMode();
    this.#pendingDocChange = true;
    this.#scheduleRerender();
    this.#editor.view?.focus();
  }
  #getActiveDomTarget() {
    const session = this.#headerFooterSession?.session;
    if (session && session.mode !== "body") {
      const activeEditor = this.#headerFooterSession?.activeEditor;
      return activeEditor?.view?.dom ?? this.#editor.view?.dom ?? null;
    }
    return this.#editor.view?.dom ?? null;
  }
  #updateAwarenessSession() {
    const provider = this.#options.collaborationProvider;
    const awareness = provider?.awareness;
    if (!awareness || typeof awareness.setLocalStateField !== "function") {
      return;
    }
    const session = this.#headerFooterSession?.session;
    if (!session || session.mode === "body") {
      awareness.setLocalStateField("layoutSession", null);
      return;
    }
    awareness.setLocalStateField("layoutSession", {
      kind: session.kind,
      headerId: session.headerId ?? null,
      pageNumber: session.pageNumber ?? null
    });
  }
  #announce(message) {
    if (!this.#ariaLiveRegion) return;
    this.#ariaLiveRegion.textContent = message;
  }
  #syncHiddenEditorA11yAttributes() {
    syncHiddenEditorA11yAttributes(this.#editor?.view?.dom, this.#documentMode);
  }
  #scheduleA11ySelectionAnnouncement(options) {
    const sessionMode = this.#headerFooterSession?.session?.mode ?? "body";
    this.#a11ySelectionAnnounceTimeout = scheduleA11ySelectionAnnouncement(
      {
        ariaLiveRegion: this.#ariaLiveRegion,
        sessionMode,
        isDragging: this.#editorInputManager?.isDragging ?? false,
        visibleHost: this.#visibleHost,
        currentTimeout: this.#a11ySelectionAnnounceTimeout,
        announceNow: () => {
          this.#a11ySelectionAnnounceTimeout = null;
          this.#announceSelectionNow();
        }
      },
      options
    );
  }
  #announceSelectionNow() {
    if (!this.#ariaLiveRegion) return;
    const sessionMode = this.#headerFooterSession?.session?.mode ?? "body";
    if (sessionMode !== "body") return;
    const announcement = computeA11ySelectionAnnouncement(this.getActiveEditor().state);
    if (!announcement) return;
    if (announcement.key === this.#a11yLastAnnouncedSelectionKey) {
      return;
    }
    this.#a11yLastAnnouncedSelectionKey = announcement.key;
    this.#announce(announcement.message);
  }
  #emitHeaderFooterEditBlocked(reason) {
    this.emit("headerFooterEditBlocked", { reason });
  }
  #resolveDescriptorForRegion(region) {
    return this.#headerFooterSession?.resolveDescriptorForRegion(region) ?? null;
  }
  /**
   * Creates a default header or footer when none exists.
   * Delegates to HeaderFooterSessionManager which handles converter API calls.
   */
  #createDefaultHeaderFooter(region) {
    this.#headerFooterSession?.createDefault(region);
  }
  /**
   * Gets the DOM element for a specific page index.
   *
   * @param pageIndex - Zero-based page index
   * @returns The page element or null if not mounted
   */
  #getPageElement(pageIndex) {
    return getPageElementByIndex(this.#painterHost, pageIndex);
  }
  #isSelectionAwareVirtualizationEnabled() {
    return Boolean(this.#layoutOptions.virtualization?.enabled && this.#layoutOptions.layoutMode === "vertical");
  }
  #updateSelectionVirtualizationPins(options) {
    if (!this.#isSelectionAwareVirtualizationEnabled()) {
      return;
    }
    const painter = this.#domPainter;
    if (!painter || typeof painter.setVirtualizationPins !== "function") {
      return;
    }
    const layout = this.#layoutState.layout;
    if (!layout) {
      return;
    }
    const state = this.getActiveEditor().state;
    const selection = state?.selection ?? null;
    const docSize = state?.doc?.content.size ?? null;
    const pins = computeSelectionVirtualizationPins({
      layout,
      blocks: this.#layoutState.blocks,
      measures: this.#layoutState.measures,
      selection: selection ? {
        from: selection.from,
        to: selection.to,
        anchor: selection.anchor,
        head: selection.head
      } : null,
      docSize,
      includeDragBuffer: Boolean(options?.includeDragBuffer),
      isDragging: this.#editorInputManager?.isDragging ?? false,
      dragAnchorPageIndex: this.#editorInputManager?.dragAnchorPageIndex ?? null,
      dragLastHitPageIndex: this.#editorInputManager?.dragLastHitPageIndex ?? null,
      extraPages: options?.extraPages
    });
    painter.setVirtualizationPins(pins);
  }
  #finalizeDragSelectionWithDom(pointer, anchor, mode) {
    const layout = this.#layoutState.layout;
    if (!layout) return;
    const selection = this.getActiveEditor().state?.selection;
    if (selection instanceof CellSelection) {
      return;
    }
    const normalized = this.#normalizeClientPoint(pointer.clientX, pointer.clientY);
    if (!normalized) return;
    const dragLastRawHit = this.#editorInputManager?.dragLastRawHit;
    this.#updateSelectionVirtualizationPins({
      includeDragBuffer: false,
      extraPages: dragLastRawHit ? [dragLastRawHit.pageIndex] : void 0
    });
    const refined = clickToPosition(
      layout,
      this.#layoutState.blocks,
      this.#layoutState.measures,
      { x: normalized.x, y: normalized.y },
      this.#viewportHost,
      pointer.clientX,
      pointer.clientY,
      this.#pageGeometryHelper ?? void 0
    );
    if (!refined) return;
    if (this.#isSelectionAwareVirtualizationEnabled() && this.#getPageElement(refined.pageIndex) == null) {
      debugLog("warn", "Drag finalize: endpoint page still not mounted", { pageIndex: refined.pageIndex });
      return;
    }
    const prior = dragLastRawHit;
    if (prior && (prior.pos !== refined.pos || prior.pageIndex !== refined.pageIndex)) {
      debugLog("info", "Drag finalize refined hit", {
        fromPos: prior.pos,
        toPos: refined.pos,
        fromPageIndex: prior.pageIndex,
        toPageIndex: refined.pageIndex
      });
    }
    const doc2 = this.#editor.state?.doc;
    if (!doc2) return;
    const mappedHead = this.#epochMapper.mapPosFromLayoutToCurrentDetailed(refined.pos, refined.layoutEpoch, 1);
    if (!mappedHead.ok) {
      debugLog("warn", "drag finalize mapping failed", mappedHead);
      return;
    }
    const head = Math.max(0, Math.min(mappedHead.pos, doc2.content.size));
    const { selAnchor, selHead } = this.#calculateExtendedSelection(anchor, head, mode);
    const current = this.#editor.state.selection;
    const desiredFrom = Math.min(selAnchor, selHead);
    const desiredTo = Math.max(selAnchor, selHead);
    if (current.from === desiredFrom && current.to === desiredTo) {
      return;
    }
    try {
      const tr = this.#editor.state.tr.setSelection(superEditor_converter.TextSelection.create(this.#editor.state.doc, selAnchor, selHead));
      this.#editor.view?.dispatch(tr);
      this.#scheduleSelectionUpdate();
    } catch {
    }
  }
  /**
   * Scrolls a page into view, triggering virtualization to mount it if needed.
   *
   * @param pageIndex - Zero-based page index to scroll to
   */
  #scrollPageIntoView(pageIndex) {
    const layout = this.#layoutState.layout;
    if (!layout) return;
    const pageHeight = layout.pageSize?.h ?? DEFAULT_PAGE_SIZE.h;
    const virtualGap = this.#layoutOptions.virtualization?.gap ?? 0;
    const yPosition = pageIndex * (pageHeight + virtualGap);
    if (this.#visibleHost) {
      this.#visibleHost.scrollTop = yPosition;
    }
  }
  static {
    this.ANCHOR_NAV_TIMEOUT_MS = 2e3;
  }
  /**
   * Navigate to a bookmark/anchor in the current document (e.g., TOC links).
   *
   * This method performs asynchronous navigation to support virtualized page rendering:
   * 1. Normalizes the anchor by removing leading '#' if present
   * 2. Looks up the bookmark in the document's bookmark registry
   * 3. Determines which page contains the target position
   * 4. Scrolls the page into view (may be virtualized)
   * 5. Waits up to 2000ms for the page to mount in the DOM
   * 6. Moves the editor caret to the bookmark position
   *
   * @param anchor - Bookmark name or fragment identifier (with or without leading '#')
   * @returns Promise resolving to true if navigation succeeded, false otherwise
   *
   * @remarks
   * Navigation fails and returns false if:
   * - The anchor parameter is empty or becomes empty after normalization
   * - No layout has been computed yet
   * - The bookmark does not exist in the document
   * - The bookmark's page cannot be determined
   * - The page fails to mount within the timeout period (2000ms)
   *
   * Note: This method does not throw errors. All failures are logged and result in
   * a false return value. An 'error' event is emitted for unhandled exceptions.
   *
   * @throws Never throws directly - errors are caught, logged, and emitted as events
   */
  async goToAnchor(anchor) {
    try {
      return await goToAnchor({
        anchor,
        layout: this.#layoutState.layout,
        blocks: this.#layoutState.blocks,
        measures: this.#layoutState.measures,
        bookmarks: this.#layoutState.bookmarks,
        pageGeometryHelper: this.#pageGeometryHelper ?? void 0,
        painterHost: this.#painterHost,
        scrollPageIntoView: (pageIndex) => this.#scrollPageIntoView(pageIndex),
        waitForPageMount: (pageIndex, timeoutMs) => this.#waitForPageMount(pageIndex, { timeout: timeoutMs }),
        getActiveEditor: () => this.getActiveEditor(),
        timeoutMs: PresentationEditor.ANCHOR_NAV_TIMEOUT_MS
      });
    } catch (error) {
      console.error("[PresentationEditor] goToAnchor failed:", error);
      this.emit("error", {
        error,
        context: "goToAnchor"
      });
      return false;
    }
  }
  /**
   * Waits for a page to be mounted in the DOM after scrolling.
   *
   * Polls for the page element using requestAnimationFrame until it appears
   * or the timeout is exceeded.
   *
   * @param pageIndex - Zero-based page index to wait for
   * @param options - Configuration options
   * @param options.timeout - Maximum time to wait in milliseconds (default: 2000)
   * @returns Promise that resolves to true if page was mounted, false if timeout
   */
  async #waitForPageMount(pageIndex, options = {}) {
    const timeout2 = options.timeout ?? 2e3;
    const startTime = performance.now();
    return new Promise((resolve) => {
      const checkPage = () => {
        const pageElement = this.#getPageElement(pageIndex);
        if (pageElement) {
          resolve(true);
          return;
        }
        const elapsed = performance.now() - startTime;
        if (elapsed >= timeout2) {
          resolve(false);
          return;
        }
        requestAnimationFrame(checkPage);
      };
      checkPage();
    });
  }
  /**
   * Get effective page gap based on layout mode and virtualization settings.
   * Keeps painter, layout, and geometry in sync.
   */
  #getEffectivePageGap() {
    if (this.#layoutOptions.virtualization?.enabled) {
      return Math.max(0, this.#layoutOptions.virtualization.gap ?? DEFAULT_VIRTUALIZED_PAGE_GAP);
    }
    if (this.#layoutOptions.layoutMode === "horizontal") {
      return DEFAULT_HORIZONTAL_PAGE_GAP;
    }
    return DEFAULT_PAGE_GAP;
  }
  #getBodyPageHeight() {
    return this.#layoutState.layout?.pageSize?.h ?? this.#layoutOptions.pageSize?.h ?? DEFAULT_PAGE_SIZE.h;
  }
  /**
   * Get the page height for the current header/footer context.
   * Delegates to HeaderFooterSessionManager which handles context lookup and fallbacks.
   */
  #getHeaderFooterPageHeight() {
    return this.#headerFooterSession?.getPageHeight() ?? 1;
  }
  /**
   * Renders visual highlighting for CellSelection (multiple table cells selected).
   *
   * This method creates blue overlay rectangles for each selected cell in a table,
   * accounting for merged cells (colspan/rowspan), multi-page tables, and accurate
   * row/column positioning from layout measurements.
   *
   * Algorithm:
   * 1. Locate the table node by walking up the selection hierarchy
   * 2. Find the corresponding table block in layout state
   * 3. Collect all table fragments (tables can span multiple pages)
   * 4. Use TableMap to convert cell positions to row/column indices
   * 5. For each selected cell:
   *    - Find the fragment containing this cell's row
   *    - Look up column boundary information from fragment metadata
   *    - Calculate cell width (sum widths for colspan > 1)
   *    - Calculate cell height from row measurements (sum heights for rowspan > 1)
   *    - Convert page-local coordinates to overlay coordinates
   *    - Create and append highlight DOM element
   *
   * Edge cases handled:
   * - Tables spanning multiple pages (iterate all fragments)
   * - Merged cells (colspan and rowspan attributes)
   * - Missing measure data (fallback to estimated row heights)
   * - Invalid table structures (TableMap.get wrapped in try-catch)
   * - Cells outside fragment boundaries (skipped)
   *
   * @param selection - The CellSelection from ProseMirror tables plugin
   * @param layout - The current layout containing table fragments and measurements
   * @returns void - Renders directly to this.#localSelectionLayer
   * @private
   *
   * @throws Never throws - all errors are caught and logged, rendering gracefully degrades
   */
  #renderCellSelectionOverlay(selection, layout) {
    const localSelectionLayer = this.#localSelectionLayer;
    if (!localSelectionLayer) return;
    renderCellSelectionOverlay({
      selection,
      layout,
      localSelectionLayer,
      blocks: this.#layoutState.blocks,
      measures: this.#layoutState.measures,
      cellAnchorTableBlockId: this.#editorInputManager?.cellAnchor?.tableBlockId ?? null,
      convertPageLocalToOverlayCoords: (pageIndex, x, y2) => this.#convertPageLocalToOverlayCoords(pageIndex, x, y2)
    });
  }
  /**
   * Render header/footer hover highlight for a region.
   * Delegates to HeaderFooterSessionManager which manages the hover UI elements.
   */
  #renderHoverRegion(region) {
    this.#headerFooterSession?.renderHover(region);
  }
  /**
   * Clear header/footer hover highlight.
   * Delegates to HeaderFooterSessionManager which manages the hover UI elements.
   */
  #clearHoverRegion() {
    this.#headerFooterSession?.clearHover();
  }
  #getHeaderFooterContext() {
    return this.#headerFooterSession?.getContext() ?? null;
  }
  /**
   * Compute selection rectangles in header/footer mode.
   * Delegates to HeaderFooterSessionManager which handles context lookup and coordinate transformation.
   */
  #computeHeaderFooterSelectionRects(from3, to) {
    return this.#headerFooterSession?.computeSelectionRects(from3, to) ?? [];
  }
  #syncTrackedChangesPreferences() {
    const mode = this.#deriveTrackedChangesMode();
    const enabled = this.#deriveTrackedChangesEnabled();
    const hasChanged = mode !== this.#trackedChangesMode || enabled !== this.#trackedChangesEnabled;
    if (hasChanged) {
      this.#trackedChangesMode = mode;
      this.#trackedChangesEnabled = enabled;
    }
    return hasChanged;
  }
  #deriveTrackedChangesMode() {
    const overrideMode = this.#trackedChangesOverrides?.mode;
    if (overrideMode) {
      return overrideMode;
    }
    const pluginState = this.#getTrackChangesPluginState();
    if (pluginState?.onlyOriginalShown) {
      return "original";
    }
    if (pluginState?.onlyModifiedShown) {
      return "final";
    }
    if (this.#documentMode === "viewing") {
      return "final";
    }
    return "review";
  }
  #deriveTrackedChangesEnabled() {
    if (typeof this.#trackedChangesOverrides?.enabled === "boolean") {
      return this.#trackedChangesOverrides.enabled;
    }
    return true;
  }
  #getTrackChangesPluginState() {
    const state = this.#editor?.state;
    if (!state) return null;
    try {
      const pluginState = TrackChangesBasePluginKey.getState(state);
      return pluginState ?? null;
    } catch (error) {
      if (vue.process$1.env.NODE_ENV === "development") {
        console.warn("[PresentationEditor] Failed to get track changes plugin state:", error);
      }
      return null;
    }
  }
  #computeDefaultLayoutDefaults() {
    const converter = this.#editor?.converter;
    const pageStyles2 = converter?.pageStyles ?? {};
    const size2 = pageStyles2.pageSize ?? {};
    const pageMargins = pageStyles2.pageMargins ?? {};
    const pageSize = {
      w: inchesToPx(size2.width) ?? DEFAULT_PAGE_SIZE.w,
      h: inchesToPx(size2.height) ?? DEFAULT_PAGE_SIZE.h
    };
    const margins = {
      top: inchesToPx(pageMargins.top) ?? DEFAULT_MARGINS.top,
      right: inchesToPx(pageMargins.right) ?? DEFAULT_MARGINS.right,
      bottom: inchesToPx(pageMargins.bottom) ?? DEFAULT_MARGINS.bottom,
      left: inchesToPx(pageMargins.left) ?? DEFAULT_MARGINS.left,
      ...inchesToPx(pageMargins.header) != null ? { header: inchesToPx(pageMargins.header) } : {},
      ...inchesToPx(pageMargins.footer) != null ? { footer: inchesToPx(pageMargins.footer) } : {}
    };
    const columns = parseColumns(pageStyles2.columns);
    return { pageSize, margins, columns };
  }
  /**
   * Applies zoom transformation to the document viewport and painter hosts.
   *
   * Handles documents with varying page sizes (multi-section docs with landscape pages)
   * by calculating actual dimensions from per-page sizes rather than assuming uniform pages.
   *
   * The implementation uses two key concepts:
   * - **maxWidth/maxHeight**: Maximum dimension across all pages (for viewport sizing)
   * - **totalWidth/totalHeight**: Sum of all page dimensions + gaps (for full document extent)
   *
   * Layout modes:
   * - Vertical: Uses maxWidth for viewport width, totalHeight for scroll height
   * - Horizontal: Uses totalWidth for viewport width, maxHeight for scroll height
   */
  #applyZoom() {
    const zoom = this.#layoutOptions.zoom ?? 1;
    const layoutMode = this.#layoutOptions.layoutMode ?? "vertical";
    const pages = this.#layoutState.layout?.pages;
    const pageGap = this.#getEffectivePageGap();
    const defaultWidth = this.#layoutOptions.pageSize?.w ?? DEFAULT_PAGE_SIZE.w;
    const defaultHeight = this.#layoutOptions.pageSize?.h ?? DEFAULT_PAGE_SIZE.h;
    let maxWidth = defaultWidth;
    let maxHeight = defaultHeight;
    let totalWidth = 0;
    let totalHeight = 0;
    if (Array.isArray(pages) && pages.length > 0) {
      pages.forEach((page, index2) => {
        const pageWidth = page.size && typeof page.size.w === "number" && page.size.w > 0 ? page.size.w : defaultWidth;
        const pageHeight = page.size && typeof page.size.h === "number" && page.size.h > 0 ? page.size.h : defaultHeight;
        maxWidth = Math.max(maxWidth, pageWidth);
        maxHeight = Math.max(maxHeight, pageHeight);
        totalWidth += pageWidth;
        totalHeight += pageHeight;
        if (index2 < pages.length - 1) {
          totalWidth += pageGap;
          totalHeight += pageGap;
        }
      });
    } else {
      totalWidth = defaultWidth;
      totalHeight = defaultHeight;
    }
    if (layoutMode === "horizontal") {
      const scaledWidth2 = totalWidth * zoom;
      const scaledHeight2 = maxHeight * zoom;
      this.#viewportHost.style.width = `${scaledWidth2}px`;
      this.#viewportHost.style.minWidth = `${scaledWidth2}px`;
      this.#viewportHost.style.minHeight = `${scaledHeight2}px`;
      this.#viewportHost.style.transform = "";
      this.#painterHost.style.width = `${totalWidth}px`;
      this.#painterHost.style.minHeight = `${maxHeight}px`;
      this.#painterHost.style.transformOrigin = "top left";
      this.#painterHost.style.transform = zoom === 1 ? "" : `scale(${zoom})`;
      this.#selectionOverlay.style.width = `${totalWidth}px`;
      this.#selectionOverlay.style.height = `${maxHeight}px`;
      this.#selectionOverlay.style.transformOrigin = "top left";
      this.#selectionOverlay.style.transform = zoom === 1 ? "" : `scale(${zoom})`;
      return;
    }
    const scaledWidth = maxWidth * zoom;
    const scaledHeight = totalHeight * zoom;
    this.#viewportHost.style.width = `${scaledWidth}px`;
    this.#viewportHost.style.minWidth = `${scaledWidth}px`;
    this.#viewportHost.style.minHeight = `${scaledHeight}px`;
    this.#viewportHost.style.transform = "";
    this.#painterHost.style.width = `${maxWidth}px`;
    this.#painterHost.style.minHeight = `${totalHeight}px`;
    this.#painterHost.style.transformOrigin = "top left";
    this.#painterHost.style.transform = zoom === 1 ? "" : `scale(${zoom})`;
    this.#selectionOverlay.style.width = `${maxWidth}px`;
    this.#selectionOverlay.style.height = `${totalHeight}px`;
    this.#selectionOverlay.style.transformOrigin = "top left";
    this.#selectionOverlay.style.transform = zoom === 1 ? "" : `scale(${zoom})`;
  }
  /**
   * Convert page-local coordinates to overlay-space coordinates.
   *
   * Transforms coordinates from page-local space (x, y relative to a specific page)
   * to overlay-space coordinates (absolute position within the stacked page layout).
   * The returned coordinates are in layout space (unscaled logical pixels), not screen
   * space - the CSS transform: scale() on #painterHost and #selectionOverlay handles zoom scaling.
   *
   * Pages are rendered vertically stacked at y = pageIndex * pageHeight, so the
   * conversion involves:
   * 1. X coordinate passes through unchanged (pages are horizontally aligned)
   * 2. Y coordinate is offset by (pageIndex * pageHeight) to account for stacking
   *
   * @param pageIndex - Zero-based page index (must be finite and non-negative)
   * @param pageLocalX - X coordinate relative to page origin (must be finite)
   * @param pageLocalY - Y coordinate relative to page origin (must be finite)
   * @returns Overlay coordinates {x, y} in layout space, or null if inputs are invalid
   *
   * @example
   * ```typescript
   * // Position at (50, 100) on page 2
   * const coords = this.#convertPageLocalToOverlayCoords(2, 50, 100);
   * // Returns: { x: 50, y: 2 * 792 + 100 } = { x: 50, y: 1684 }
   * ```
   *
   * @private
   */
  #getPageOffsetX(pageIndex) {
    return getPageOffsetX({
      painterHost: this.#painterHost,
      viewportHost: this.#viewportHost,
      zoom: this.#layoutOptions.zoom ?? 1,
      pageIndex
    });
  }
  #convertPageLocalToOverlayCoords(pageIndex, pageLocalX, pageLocalY) {
    const pageHeight = this.#layoutOptions.pageSize?.h ?? DEFAULT_PAGE_SIZE.h;
    const pageGap = this.#layoutState.layout?.pageGap ?? 0;
    return convertPageLocalToOverlayCoords({
      painterHost: this.#painterHost,
      viewportHost: this.#viewportHost,
      zoom: this.#layoutOptions.zoom ?? 1,
      pageIndex,
      pageLocalX,
      pageLocalY,
      pageHeight,
      pageGap
    });
  }
  /**
   * Computes DOM-derived selection rects for mounted pages using Range.getClientRects().
   *
   * This is the pixel-perfect path: it uses the browser's layout engine as the
   * source of truth for selection geometry when content is mounted.
   *
   * Returns null on failure so callers can keep the last known-good overlay rather
   * than rendering a potentially incorrect geometry-based fallback.
   */
  #computeSelectionRectsFromDom(from3, to) {
    const layout = this.#layoutState.layout;
    if (!layout) return null;
    return computeSelectionRectsFromDom(
      {
        painterHost: this.#painterHost,
        layout,
        domPositionIndex: this.#domPositionIndex,
        rebuildDomPositionIndex: () => this.#rebuildDomPositionIndex(),
        zoom: this.#layoutOptions.zoom ?? 1,
        pageHeight: this.#getBodyPageHeight(),
        pageGap: layout.pageGap ?? this.#getEffectivePageGap()
      },
      from3,
      to
    );
  }
  #computeDomCaretPageLocal(pos) {
    return computeDomCaretPageLocal(
      {
        painterHost: this.#painterHost,
        domPositionIndex: this.#domPositionIndex,
        rebuildDomPositionIndex: () => this.#rebuildDomPositionIndex(),
        zoom: this.#layoutOptions.zoom ?? 1
      },
      pos
    );
  }
  #normalizeClientPoint(clientX, clientY) {
    return normalizeClientPoint(
      {
        viewportHost: this.#viewportHost,
        visibleHost: this.#visibleHost,
        zoom: this.#layoutOptions.zoom ?? 1,
        getPageOffsetX: (pageIndex) => this.#getPageOffsetX(pageIndex)
      },
      clientX,
      clientY
    );
  }
  /**
   * Computes caret layout rectangle using geometry-based calculations.
   *
   * This method calculates the caret position and height from layout engine data
   * (fragments, blocks, measures) without querying the DOM. It's used as a fallback
   * when DOM-based measurements are unavailable or as a primary source in non-interactive
   * scenarios (e.g., headless rendering, PDF export).
   *
   * The geometry-based calculation accounts for:
   * - List markers (offset caret by marker width)
   * - Paragraph indents (left, right, first-line, hanging)
   * - Justified text alignment (extra space distributed across spaces)
   * - Multi-column layouts
   * - Table cell content
   *
   * Algorithm:
   * 1. Find the fragment containing the PM position
   * 2. Handle table fragments separately (delegate to #computeTableCaretLayoutRect)
   * 3. For paragraph fragments:
   *    a. Find the line containing the position
   *    b. Convert PM position to character offset
   *    c. Measure X coordinate using Canvas-based text measurement
   *    d. Apply marker width and indent adjustments
   *    e. Calculate Y offset from line heights
   *    f. Return page-local coordinates with line height
   *
   * @param pos - ProseMirror position to compute caret for
   * @param includeDomFallback - Whether to compare with DOM measurements for debugging (default: true).
   *   When true, logs geometry vs DOM deltas for analysis. Has no effect on return value.
   * @returns Object with {pageIndex, x, y, height} in page-local coordinates, or null if position not found
   *
   * @example
   * ```typescript
   * const caretGeometry = this.#computeCaretLayoutRectGeometry(42, false);
   * if (caretGeometry) {
   *   // Render caret at caretGeometry.x, caretGeometry.y with height caretGeometry.height
   * }
   * ```
   */
  #computeCaretLayoutRectGeometry(pos, includeDomFallback = true) {
    return computeCaretLayoutRectGeometry(
      {
        layout: this.#layoutState.layout,
        blocks: this.#layoutState.blocks,
        measures: this.#layoutState.measures,
        painterHost: this.#painterHost,
        viewportHost: this.#viewportHost,
        visibleHost: this.#visibleHost,
        zoom: this.#layoutOptions.zoom ?? 1
      },
      pos,
      includeDomFallback
    );
  }
  /**
   * Compute caret position, preferring DOM when available, falling back to geometry.
   */
  #computeCaretLayoutRect(pos) {
    const geometry = this.#computeCaretLayoutRectGeometry(pos, true);
    let dom = null;
    try {
      dom = this.#computeDomCaretPageLocal(pos);
    } catch (error) {
      if (vue.process$1.env.NODE_ENV === "development") {
        console.warn("[PresentationEditor] DOM caret computation failed in #computeCaretLayoutRect:", error);
      }
    }
    if (dom && geometry) {
      return {
        pageIndex: dom.pageIndex,
        x: dom.x,
        y: dom.y,
        height: geometry.height
      };
    }
    return geometry;
  }
  #getCurrentPageIndex() {
    const session = this.#headerFooterSession?.session;
    if (session && session.mode !== "body") {
      return session.pageIndex ?? 0;
    }
    const layout = this.#layoutState.layout;
    const selection = this.#editor.state?.selection;
    if (!layout || !selection) {
      return 0;
    }
    const rects = selectionToRects(
      layout,
      this.#layoutState.blocks,
      this.#layoutState.measures,
      selection.from,
      selection.to,
      this.#pageGeometryHelper ?? void 0
    ) ?? [];
    if (rects.length > 0) {
      return rects[0]?.pageIndex ?? 0;
    }
    const pos = selection.from;
    for (let pageIdx = 0; pageIdx < layout.pages.length; pageIdx++) {
      const page = layout.pages[pageIdx];
      for (const fragment of page.fragments) {
        const frag = fragment;
        if (frag.pmStart != null && frag.pmEnd != null) {
          if (pos >= frag.pmStart && pos <= frag.pmEnd) {
            return pageIdx;
          }
        }
      }
    }
    return 0;
  }
  #findRegionForPage(kind, pageIndex) {
    return this.#headerFooterSession?.findRegionForPage(kind, pageIndex) ?? null;
  }
  #handleLayoutError(phase, error) {
    console.error("[PresentationEditor] Layout error", error);
    this.#layoutError = { phase, error, timestamp: Date.now() };
    if (phase === "initialization") {
      this.#layoutErrorState = "failed";
    } else {
      this.#layoutErrorState = this.#layoutState.layout ? "degraded" : "failed";
    }
    this.emit("layoutError", this.#layoutError);
    this.#showLayoutErrorBanner(error);
  }
  #decorateError(error, stage) {
    if (error instanceof Error) {
      error.message = `[${stage}] ${error.message}`;
      return error;
    }
    return new Error(`[${stage}] ${String(error)}`);
  }
  #showLayoutErrorBanner(error) {
    const doc2 = this.#visibleHost.ownerDocument ?? document;
    if (!this.#errorBanner) {
      const banner = doc2.createElement("div");
      banner.className = "presentation-editor__layout-error";
      banner.style.display = "flex";
      banner.style.alignItems = "center";
      banner.style.justifyContent = "space-between";
      banner.style.gap = "8px";
      banner.style.padding = "8px 12px";
      banner.style.background = "#FFF6E5";
      banner.style.border = "1px solid #F5B971";
      banner.style.borderRadius = "6px";
      banner.style.marginBottom = "8px";
      const message = doc2.createElement("span");
      banner.appendChild(message);
      const retry = doc2.createElement("button");
      retry.type = "button";
      retry.textContent = "Reload layout";
      retry.style.border = "none";
      retry.style.borderRadius = "4px";
      retry.style.background = "#F5B971";
      retry.style.color = "#3F2D00";
      retry.style.padding = "6px 10px";
      retry.style.cursor = "pointer";
      retry.addEventListener("click", () => {
        this.#layoutError = null;
        this.#dismissErrorBanner();
        this.#pendingDocChange = true;
        this.#scheduleRerender();
      });
      banner.appendChild(retry);
      this.#visibleHost.prepend(banner);
      this.#errorBanner = banner;
      this.#errorBannerMessage = message;
    }
    if (this.#errorBannerMessage) {
      this.#errorBannerMessage.textContent = "Layout engine hit an error. Your document is safe  try reloading layout.";
      if (this.#layoutOptions.debugLabel) {
        this.#errorBannerMessage.textContent += ` (${this.#layoutOptions.debugLabel}: ${error.message})`;
      }
    }
  }
  #dismissErrorBanner() {
    this.#errorBanner?.remove();
    this.#errorBanner = null;
    this.#errorBannerMessage = null;
  }
  /**
   * Determines whether the current viewing mode should block edits.
   * When documentMode is viewing but the active editor has been toggled
   * back to editable (e.g. permission ranges), we treat the view as editable.
   */
  #isViewLocked() {
    if (this.#documentMode !== "viewing") return false;
    const hasPermissionOverride = !!this.#editor?.storage?.permissionRanges?.hasAllowedRanges;
    if (hasPermissionOverride) return false;
    return this.#documentMode === "viewing";
  }
  /**
   * Applies vertical alignment and font scaling to layout DOM elements for subscript/superscript rendering.
   *
   * This method post-processes the painted DOM layout to apply vertical alignment styles
   * (super, sub, baseline, or custom position) based on run properties and text style marks.
   * It handles both DOCX-style vertAlign ('superscript', 'subscript', 'baseline') and
   * custom position offsets (in half-points).
   *
   * Processing logic:
   * 1. Queries all text spans with ProseMirror position markers
   * 2. For each span, resolves the ProseMirror position to find the containing run node
   * 3. Extracts vertAlign and position from run properties and/or text style marks
   * 4. Applies CSS vertical-align and font-size styles based on the extracted properties
   * 5. Position takes precedence over vertAlign when both are present
   *
   * @throws Does not throw - DOM manipulation errors are silently caught to prevent layout corruption
   * @private
   */
  #applyVertAlignToLayout() {
    const doc2 = this.#editor?.state?.doc;
    if (!doc2 || !this.#painterHost) return;
    try {
      const spans = this.#painterHost.querySelectorAll(".superdoc-line span[data-pm-start]");
      spans.forEach((span) => {
        try {
          if (span.closest(".superdoc-page-header, .superdoc-page-footer")) return;
          const pmStart = Number(span.dataset.pmStart ?? "NaN");
          if (!Number.isFinite(pmStart)) return;
          const pos = Math.max(0, Math.min(pmStart, doc2.content.size));
          const $pos = doc2.resolve(pos);
          let runNode = null;
          for (let depth = $pos.depth; depth >= 0; depth--) {
            const node = $pos.node(depth);
            if (node.type.name === "run") {
              runNode = node;
              break;
            }
          }
          let vertAlign = runNode?.attrs?.runProperties?.vertAlign ?? null;
          let position = runNode?.attrs?.runProperties?.position ?? null;
          let fontSizeHalfPts = runNode?.attrs?.runProperties?.fontSize ?? null;
          if (!vertAlign && position == null && runNode) {
            runNode.forEach((child) => {
              if (!child.isText || !child.marks?.length) return;
              const rpr = superEditor_converter.decodeRPrFromMarks(child.marks);
              if (rpr.vertAlign && !vertAlign) vertAlign = rpr.vertAlign;
              if (rpr.position != null && position == null) position = rpr.position;
              if (rpr.fontSize != null && fontSizeHalfPts == null) fontSizeHalfPts = rpr.fontSize;
            });
          }
          if (vertAlign == null && position == null) return;
          const styleEntries = [];
          if (position != null && Number.isFinite(position)) {
            const pts = helpers$1.halfPointToPoints(position);
            if (Number.isFinite(pts)) {
              styleEntries.push(`vertical-align: ${pts}pt`);
            }
          } else if (vertAlign === "superscript" || vertAlign === "subscript") {
            styleEntries.push(`vertical-align: ${vertAlign === "superscript" ? "super" : "sub"}`);
            if (fontSizeHalfPts != null && Number.isFinite(fontSizeHalfPts)) {
              const scaledPts = helpers$1.halfPointToPoints(fontSizeHalfPts * SUBSCRIPT_SUPERSCRIPT_SCALE);
              if (Number.isFinite(scaledPts)) {
                styleEntries.push(`font-size: ${scaledPts}pt`);
              } else {
                styleEntries.push(`font-size: ${SUBSCRIPT_SUPERSCRIPT_SCALE * 100}%`);
              }
            } else {
              styleEntries.push(`font-size: ${SUBSCRIPT_SUPERSCRIPT_SCALE * 100}%`);
            }
          } else if (vertAlign === "baseline") {
            styleEntries.push("vertical-align: baseline");
          }
          if (!styleEntries.length) return;
          const existing = span.getAttribute("style");
          const merged = existing ? `${existing}; ${styleEntries.join("; ")}` : styleEntries.join("; ");
          span.setAttribute("style", merged);
        } catch (error) {
          console.error("Failed to apply vertical alignment to span:", error);
        }
      });
    } catch (error) {
      console.error("Failed to apply vertical alignment to layout:", error);
    }
  }
}
const Color = Extension.create({
  name: "color",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          color: {
            default: null,
            parseDOM: (el) => el.style.color?.replace(/['"]+/g, ""),
            renderDOM: (attrs) => {
              if (!attrs.color) return {};
              return { style: `color: ${attrs.color}` };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      /**
       * Set text color
       * @category Command
       * @param {ColorValue} color - Color value to apply
       * @example
       * // Set to red using hex
       * editor.commands.setColor('#ff0000')
       *
       * @example
       * // Set using rgb
       * editor.commands.setColor('rgb(255, 0, 0)')
       *
       * @example
       * // Set using named color
       * editor.commands.setColor('blue')
       * @note Preserves other text styling attributes
       */
      setColor: (color) => ({ chain }) => {
        return chain().setMark("textStyle", { color }).run();
      },
      /**
       * Remove text color
       * @category Command
       * @example
       * editor.commands.unsetColor()
       * @note Removes color while preserving other text styles
       */
      unsetColor: () => ({ chain }) => {
        return chain().setMark("textStyle", { color: null }).removeEmptyTextStyle().run();
      }
    };
  }
});
const FontFamily = Extension.create({
  name: "fontFamily",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontFamily: {
            default: null,
            parseDOM: (el) => el.style.fontFamily?.replace(/['"]+/g, ""),
            renderDOM: (attrs) => {
              if (!attrs.fontFamily) return {};
              return { style: `font-family: ${attrs.fontFamily}` };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      /**
       * Set font family
       * @category Command
       * @param {FontFamilyValue} fontFamily - Font family to apply
       * @example
       * // Set to Arial
       * editor.commands.setFontFamily('Arial')
       *
       * @example
       * // Set to serif font
       * editor.commands.setFontFamily('Georgia, serif')
       * @note Preserves other text styling attributes
       */
      setFontFamily: (fontFamily2) => ({ chain }) => {
        return chain().setMark("textStyle", { fontFamily: fontFamily2 }).run();
      },
      /**
       * Remove font family
       * @category Command
       * @example
       * editor.commands.unsetFontFamily()
       * @note Reverts to default document font
       */
      unsetFontFamily: () => ({ chain }) => {
        return chain().setMark("textStyle", { fontFamily: null }).removeEmptyTextStyle().run();
      }
    };
  }
});
const FontSize = Extension.create({
  name: "fontSize",
  addOptions() {
    return {
      types: ["textStyle", "tableCell"],
      defaults: {
        value: 12,
        unit: "pt",
        min: 8,
        max: 96
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          fontSize: {
            default: null,
            parseDOM: (el) => el.style.fontSize,
            renderDOM: (attrs) => {
              if (!attrs.fontSize) return {};
              let [value, unit] = parseSizeUnit(attrs.fontSize);
              if (Number.isNaN(value)) return {};
              unit = unit ? unit : this.options.defaults.unit;
              return { style: `font-size: ${value}${unit}` };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      /**
       * Set font size
       * @category Command
       * @param {FontSizeValue} fontSize - Size to apply (with optional unit)
       * @example
       * editor.commands.setFontSize('14pt')
       * editor.commands.setFontSize('18px')
       * editor.commands.setFontSize(16)
       * @note Automatically clamps to min/max values
       */
      setFontSize: (fontSize2) => ({ chain }) => {
        let value, unit;
        if (typeof fontSize2 === "number") {
          value = fontSize2;
          unit = null;
        } else {
          [value, unit] = parseSizeUnit(fontSize2);
        }
        if (Number.isNaN(value)) {
          return false;
        }
        let { min: min2, max: max2, unit: defaultUnit } = this.options.defaults;
        value = minMax(Number(value), min2, max2);
        unit = unit ? unit : defaultUnit;
        return chain().setMark("textStyle", { fontSize: `${value}${unit}` }).run();
      },
      /**
       * Remove font size
       * @category Command
       * @example
       * editor.commands.unsetFontSize()
       * @note Reverts to default document size
       */
      unsetFontSize: () => ({ chain }) => {
        return chain().setMark("textStyle", { fontSize: null }).removeEmptyTextStyle().run();
      }
    };
  }
});
const TextAlign = Extension.create({
  name: "textAlign",
  addOptions() {
    return {
      alignments: ["left", "center", "right", "justify"]
    };
  },
  addCommands() {
    return {
      /**
       * Set text alignment
       * @category Command
       * @param {string} alignment - Alignment value (left, center, right, justify)
       * @example
       * editor.commands.setTextAlign('center')
       * editor.commands.setTextAlign('justify')
       */
      setTextAlign: (alignment2) => ({ commands: commands2 }) => {
        const containsAlignment = this.options.alignments.includes(alignment2);
        if (!containsAlignment) return false;
        return commands2.updateAttributes("paragraph", { "paragraphProperties.justification": alignment2 });
      },
      /**
       * Remove text alignment (reset to default)
       * @category Command
       * @example
       * editor.commands.unsetTextAlign()
       * @note Resets alignment to the default value
       */
      unsetTextAlign: () => ({ commands: commands2 }) => commands2.resetAttributes("paragraph", "paragraphProperties.justification")
    };
  },
  addShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
});
const FormatCommands = Extension.create({
  name: "formatCommands",
  addOptions() {
    return {};
  },
  addStorage() {
    return {
      /**
       * @private
       * @type {StoredStyle[]|null}
       */
      storedStyle: null
    };
  },
  addCommands() {
    return {
      toggleMarkCascade,
      /**
       * Clear all formatting (nodes and marks)
       * @category Command
       * @example
       * editor.commands.clearFormat()
       * @note Removes all marks and resets nodes to default paragraph
       */
      clearFormat: () => ({ chain }) => {
        return chain().clearNodes().unsetAllMarks().run();
      },
      /**
       * Clear only mark formatting
       * @category Command
       * @example
       * editor.commands.clearMarksFormat()
       * @note Removes bold, italic, underline, colors, etc. but preserves block structure
       */
      clearMarksFormat: () => ({ chain }) => {
        return chain().unsetAllMarks().run();
      },
      /**
       * Clear only node formatting
       * @category Command
       * @example
       * editor.commands.clearNodesFormat()
       * @note Converts headings, lists, etc. to paragraphs but preserves text marks
       */
      clearNodesFormat: () => ({ chain }) => {
        return chain().clearNodes().run();
      },
      /**
       * Copy format from selection or apply copied format
       * @category Command
       * @example
       * editor.commands.copyFormat()
       * @note Works like format painter - first click copies, second click applies
       */
      copyFormat: () => ({ chain }) => {
        if (!this.storage.storedStyle) {
          const marks = getMarksFromSelection(this.editor.state);
          this.storage.storedStyle = marks;
          return true;
        }
        if (!this.storage.storedStyle.length) {
          this.storage.storedStyle = null;
          return chain().clearFormat().run();
        }
        const storedMarks = this.storage.storedStyle;
        const processedMarks = [];
        storedMarks.forEach((mark) => {
          const { type, attrs } = mark;
          const { name } = type;
          if (name === "textStyle") {
            Object.keys(attrs).forEach((key2) => {
              if (!attrs[key2]) return;
              const attributes = {};
              attributes[key2] = attrs[key2];
              processedMarks.push({ name: key2, attrs: attributes });
            });
          } else {
            processedMarks.push({ name, attrs });
          }
        });
        const marksToCommands = {
          bold: ["setBold", "unsetBold"],
          italic: ["setItalic", "unsetItalic"],
          underline: ["setUnderline", "unsetUnderline"],
          color: ["setColor", "setColor", null],
          fontSize: ["setFontSize", "unsetFontSize"],
          fontFamily: ["setFontFamily", "unsetFontFamily"]
        };
        let result = chain();
        Object.keys(marksToCommands).forEach((key2) => {
          const [setCommand, unsetCommand, defaultParam] = marksToCommands[key2];
          const markToApply = processedMarks.find((mark) => mark.name === key2);
          const hasEmptyAttrs = markToApply?.attrs && markToApply?.attrs[key2];
          let cmd = {};
          if (!markToApply && !hasEmptyAttrs) cmd = { command: unsetCommand, argument: defaultParam };
          else cmd = { command: setCommand, argument: markToApply.attrs[key2] || defaultParam };
          result = result[cmd.command](cmd.argument);
        });
        this.storage.storedStyle = null;
        return result;
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.clearFormat()
    };
  }
});
function dropCursor(options = {}) {
  return new superEditor_converter.Plugin({
    view(editorView) {
      return new DropCursorView(editorView, options);
    }
  });
}
class DropCursorView {
  constructor(editorView, options) {
    var _a;
    this.editorView = editorView;
    this.cursorPos = null;
    this.element = null;
    this.timeout = -1;
    this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;
    this.color = options.color === false ? void 0 : options.color || "black";
    this.class = options.class;
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
      let handler = (e) => {
        this[name](e);
      };
      editorView.dom.addEventListener(name, handler);
      return { name, handler };
    });
  }
  destroy() {
    this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
  }
  update(editorView, prevState) {
    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
      if (this.cursorPos > editorView.state.doc.content.size)
        this.setCursor(null);
      else
        this.updateOverlay();
    }
  }
  setCursor(pos) {
    if (pos == this.cursorPos)
      return;
    this.cursorPos = pos;
    if (pos == null) {
      this.element.parentNode.removeChild(this.element);
      this.element = null;
    } else {
      this.updateOverlay();
    }
  }
  updateOverlay() {
    let $pos = this.editorView.state.doc.resolve(this.cursorPos);
    let isBlock = !$pos.parent.inlineContent, rect;
    let editorDOM = this.editorView.dom, editorRect = editorDOM.getBoundingClientRect();
    let scaleX = editorRect.width / editorDOM.offsetWidth, scaleY = editorRect.height / editorDOM.offsetHeight;
    if (isBlock) {
      let before = $pos.nodeBefore, after = $pos.nodeAfter;
      if (before || after) {
        let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
        if (node) {
          let nodeRect = node.getBoundingClientRect();
          let top2 = before ? nodeRect.bottom : nodeRect.top;
          if (before && after)
            top2 = (top2 + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
          let halfWidth = this.width / 2 * scaleY;
          rect = { left: nodeRect.left, right: nodeRect.right, top: top2 - halfWidth, bottom: top2 + halfWidth };
        }
      }
    }
    if (!rect) {
      let coords = this.editorView.coordsAtPos(this.cursorPos);
      let halfWidth = this.width / 2 * scaleX;
      rect = { left: coords.left - halfWidth, right: coords.left + halfWidth, top: coords.top, bottom: coords.bottom };
    }
    let parent = this.editorView.dom.offsetParent;
    if (!this.element) {
      this.element = parent.appendChild(document.createElement("div"));
      if (this.class)
        this.element.className = this.class;
      this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
      if (this.color) {
        this.element.style.backgroundColor = this.color;
      }
    }
    this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
    this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
    let parentLeft, parentTop;
    if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
      parentLeft = -pageXOffset;
      parentTop = -pageYOffset;
    } else {
      let rect2 = parent.getBoundingClientRect();
      let parentScaleX = rect2.width / parent.offsetWidth, parentScaleY = rect2.height / parent.offsetHeight;
      parentLeft = rect2.left - parent.scrollLeft * parentScaleX;
      parentTop = rect2.top - parent.scrollTop * parentScaleY;
    }
    this.element.style.left = (rect.left - parentLeft) / scaleX + "px";
    this.element.style.top = (rect.top - parentTop) / scaleY + "px";
    this.element.style.width = (rect.right - rect.left) / scaleX + "px";
    this.element.style.height = (rect.bottom - rect.top) / scaleY + "px";
  }
  scheduleRemoval(timeout2) {
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => this.setCursor(null), timeout2);
  }
  dragover(event) {
    if (!this.editorView.editable)
      return;
    let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
    let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
    let disableDropCursor = node && node.type.spec.disableDropCursor;
    let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
    if (pos && !disabled) {
      let target = pos.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let point = superEditor_converter.dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
        if (point != null)
          target = point;
      }
      this.setCursor(target);
      this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(event) {
    if (!this.editorView.dom.contains(event.relatedTarget))
      this.setCursor(null);
  }
}
const DropCursor = Extension.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 2,
      class: void 0
    };
  },
  addPmPlugins() {
    return [dropCursor(this.options)];
  }
});
class GapCursor extends superEditor_converter.Selection {
  /**
  Create a gap cursor.
  */
  constructor($pos) {
    super($pos, $pos);
  }
  map(doc2, mapping) {
    let $pos = doc2.resolve(mapping.map(this.head));
    return GapCursor.valid($pos) ? new GapCursor($pos) : superEditor_converter.Selection.near($pos);
  }
  content() {
    return superEditor_converter.Slice.empty;
  }
  eq(other) {
    return other instanceof GapCursor && other.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc2, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new GapCursor(doc2.resolve(json.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new GapBookmark(this.anchor);
  }
  /**
  @internal
  */
  static valid($pos) {
    let parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
      return false;
    let override = parent.type.spec.allowGapCursor;
    if (override != null)
      return override;
    let deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom($pos, dir, mustMove = false) {
    search: for (; ; ) {
      if (!mustMove && GapCursor.valid($pos))
        return $pos;
      let pos = $pos.pos, next = null;
      for (let d = $pos.depth; ; d--) {
        let parent = $pos.node(d);
        if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
          next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
          break;
        } else if (d == 0) {
          return null;
        }
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (GapCursor.valid($cur))
          return $cur;
      }
      for (; ; ) {
        let inside = dir > 0 ? next.firstChild : next.lastChild;
        if (!inside) {
          if (next.isAtom && !next.isText && !superEditor_converter.NodeSelection.isSelectable(next)) {
            $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
            mustMove = false;
            continue search;
          }
          break;
        }
        next = inside;
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (GapCursor.valid($cur))
          return $cur;
      }
      return null;
    }
  }
}
GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
superEditor_converter.Selection.jsonID("gapcursor", GapCursor);
class GapBookmark {
  constructor(pos) {
    this.pos = pos;
  }
  map(mapping) {
    return new GapBookmark(mapping.map(this.pos));
  }
  resolve(doc2) {
    let $pos = doc2.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : superEditor_converter.Selection.near($pos);
  }
}
function needsGap(type) {
  return type.isAtom || type.spec.isolating || type.spec.createGapCursor;
}
function closedBefore($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index2 = $pos.index(d), parent = $pos.node(d);
    if (index2 == 0) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let before = parent.child(index2 - 1); ; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || needsGap(before.type))
        return true;
      if (before.inlineContent)
        return false;
    }
  }
  return true;
}
function closedAfter($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index2 = $pos.indexAfter(d), parent = $pos.node(d);
    if (index2 == parent.childCount) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let after = parent.child(index2); ; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || needsGap(after.type))
        return true;
      if (after.inlineContent)
        return false;
    }
  }
  return true;
}
function gapCursor() {
  return new superEditor_converter.Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick,
      handleKeyDown,
      handleDOMEvents: { beforeinput }
    }
  });
}
const handleKeyDown = keydownHandler({
  "ArrowLeft": arrow$2("horiz", -1),
  "ArrowRight": arrow$2("horiz", 1),
  "ArrowUp": arrow$2("vert", -1),
  "ArrowDown": arrow$2("vert", 1)
});
function arrow$2(axis, dir) {
  const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state, dispatch, view) {
    let sel = state.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof superEditor_converter.TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0)
        return false;
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable)
    return false;
  let $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos))
    return false;
  let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (clickPos && clickPos.inside > -1 && superEditor_converter.NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
    return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
    return false;
  let { $from } = view.state.selection;
  let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert)
    return false;
  let frag = superEditor_converter.Fragment.empty;
  for (let i = insert.length - 1; i >= 0; i--)
    frag = superEditor_converter.Fragment.from(insert[i].createAndFill(null, frag));
  let tr = view.state.tr.replace($from.pos, $from.pos, new superEditor_converter.Slice(frag, 0, 0));
  tr.setSelection(superEditor_converter.TextSelection.near(tr.doc.resolve($from.pos + 1)));
  view.dispatch(tr);
  return false;
}
function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor))
    return null;
  let node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
}
const Gapcursor = Extension.create({
  name: "gapCursor",
  addOptions() {
    return {};
  },
  addPmPlugins() {
    return [gapCursor()];
  },
  /**
   * Extend node schema to allow gap cursor positioning
   * @returns {Object} Schema extension with allowGapCursor property
   */
  extendNodeSchema(extension) {
    return {
      /**
       * Whether to allow gap cursor before/after this node
       * Set to false on nodes where gap cursor shouldn't appear
       * @type {boolean|null}
       */
      allowGapCursor: callOrGet(
        getExtensionConfigField(extension, "allowGapCursor", {
          name: extension.name,
          options: extension.options,
          storage: extension.storage
        })
      ) ?? null
    };
  }
});
const CollaborationCursor = Extension.create({
  name: "collaborationCursor",
  priority: 999,
  addOptions() {
    return {
      provider: null,
      user: {
        name: null,
        color: null
      }
    };
  },
  addStorage() {
    return {
      users: []
    };
  },
  addPmPlugins() {
    const { collaborationProvider: provider = null } = this.editor.options;
    if (!provider) return [];
    return [yCursorPlugin(provider.awareness, { cursorBuilder: customCursors })];
  }
});
const customCursors = (user) => {
  const cursor = document.createElement("span");
  cursor.classList.add("ProseMirror-yjs-cursor");
  cursor.setAttribute("style", `border-color: ${user.color}`);
  const userDiv = document.createElement("div");
  userDiv.setAttribute("style", `background-color: ${user.color}`);
  userDiv.insertBefore(document.createTextNode(user.name || user.email), null);
  cursor.insertBefore(userDiv, null);
  return cursor;
};
const AiMarkName = "aiMark";
const AiAnimationMarkName = "aiAnimationMark";
const AiLoaderNodeName = "aiLoaderNode";
const AiMark = Mark.create({
  name: AiMarkName,
  group: "ai",
  inclusive: false,
  excludeFromSummaryJSON: true,
  addOptions() {
    return {
      htmlAttributes: { class: "sd-ai-highlight" }
    };
  },
  addAttributes() {
    return {
      id: {
        default: null,
        rendered: false
      }
    };
  },
  parseDOM() {
    return [{ tag: AiMarkName }];
  },
  renderDOM({ htmlAttributes }) {
    return [AiMarkName, Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  }
});
const AiAnimationMark = Mark.create({
  name: AiAnimationMarkName,
  group: "ai",
  inclusive: false,
  spanning: false,
  excludes: AiAnimationMarkName,
  excludeFromSummaryJSON: true,
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  addAttributes() {
    return {
      id: {
        default: null,
        rendered: false
      },
      class: {
        default: null,
        rendered: true
      },
      dataMarkId: {
        default: null,
        rendered: true
      }
    };
  },
  parseDOM() {
    return [{ tag: AiAnimationMarkName }];
  },
  renderDOM({ htmlAttributes }) {
    return [AiAnimationMarkName, Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  }
});
const dotsLoader = "data:image/svg+xml,%3csvg%20fill='hsla(278,%2077.40%25,%2020.80%25,%200.65)'%20viewBox='0%200%2024%2024'%20xmlns='http://www.w3.org/2000/svg'%3e%3ccircle%20cx='4'%20cy='12'%20r='0'%3e%3canimate%20begin='0;spinner_z0Or.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='0;3'%20fill='freeze'/%3e%3canimate%20begin='spinner_OLMs.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='4;12'%20fill='freeze'/%3e%3canimate%20begin='spinner_UHR2.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='12;20'%20fill='freeze'/%3e%3canimate%20id='spinner_lo66'%20begin='spinner_Aguh.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='3;0'%20fill='freeze'/%3e%3canimate%20id='spinner_z0Or'%20begin='spinner_lo66.end'%20attributeName='cx'%20dur='0.001s'%20values='20;4'%20fill='freeze'/%3e%3c/circle%3e%3ccircle%20cx='4'%20cy='12'%20r='3'%3e%3canimate%20begin='0;spinner_z0Or.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='4;12'%20fill='freeze'/%3e%3canimate%20begin='spinner_OLMs.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='12;20'%20fill='freeze'/%3e%3canimate%20id='spinner_JsnR'%20begin='spinner_UHR2.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='3;0'%20fill='freeze'/%3e%3canimate%20id='spinner_Aguh'%20begin='spinner_JsnR.end'%20attributeName='cx'%20dur='0.001s'%20values='20;4'%20fill='freeze'/%3e%3canimate%20begin='spinner_Aguh.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='0;3'%20fill='freeze'/%3e%3c/circle%3e%3ccircle%20cx='12'%20cy='12'%20r='3'%3e%3canimate%20begin='0;spinner_z0Or.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='12;20'%20fill='freeze'/%3e%3canimate%20id='spinner_hSjk'%20begin='spinner_OLMs.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='3;0'%20fill='freeze'/%3e%3canimate%20id='spinner_UHR2'%20begin='spinner_hSjk.end'%20attributeName='cx'%20dur='0.001s'%20values='20;4'%20fill='freeze'/%3e%3canimate%20begin='spinner_UHR2.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='0;3'%20fill='freeze'/%3e%3canimate%20begin='spinner_Aguh.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='4;12'%20fill='freeze'/%3e%3c/circle%3e%3ccircle%20cx='20'%20cy='12'%20r='3'%3e%3canimate%20id='spinner_4v5M'%20begin='0;spinner_z0Or.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='3;0'%20fill='freeze'/%3e%3canimate%20id='spinner_OLMs'%20begin='spinner_4v5M.end'%20attributeName='cx'%20dur='0.001s'%20values='20;4'%20fill='freeze'/%3e%3canimate%20begin='spinner_OLMs.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='0;3'%20fill='freeze'/%3e%3canimate%20begin='spinner_UHR2.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='4;12'%20fill='freeze'/%3e%3canimate%20begin='spinner_Aguh.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='12;20'%20fill='freeze'/%3e%3c/circle%3e%3c/svg%3e";
const AiLoaderNode = Node$1.create({
  name: AiLoaderNodeName,
  excludeFromSummaryJSON: true,
  group: "inline",
  inline: true,
  atom: true,
  selectable: false,
  draggable: false,
  addOptions() {
    return {
      htmlAttributes: {
        class: "sd-ai-loader",
        contentEditable: "false",
        "aria-label": "AI loader node"
      }
    };
  },
  parseDOM() {
    return [{ tag: "span.sd-ai-loader" }];
  },
  renderDOM({ htmlAttributes }) {
    const span = document.createElement("span");
    Object.entries(Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)).forEach(
      ([k2, v]) => span.setAttribute(k2, v)
    );
    const img = document.createElement("img");
    img.src = dotsLoader;
    img.alt = "loading...";
    img.width = 100;
    img.height = 50;
    span.appendChild(img);
    return span;
  }
});
const AiPluginKey = new superEditor_converter.PluginKey("ai");
const AiPlugin = Extension.create({
  name: "ai",
  addCommands() {
    return {
      insertAiMark: () => ({ tr, dispatch }) => {
        const { selection } = tr;
        const { $from, $to } = selection;
        if ($from.pos === $to.pos) return false;
        tr.addMark(
          $from.pos,
          $to.pos,
          this.editor.schema.marks[AiMarkName].create({
            id: "ai-highlight"
          })
        );
        if (dispatch) dispatch(tr);
        return true;
      },
      /**
       * Remove selection before ai pulse styles
       */
      removeSelectionAfterAiPulse: () => ({ tr, dispatch, state }) => {
        const { selection } = tr;
        const { $to } = selection;
        tr.setSelection(state.selection.constructor.create(tr.doc, $to.pos, $to.pos));
        if (dispatch) dispatch(tr);
        return true;
      },
      /**
       * Update the AI highlights with custom styling
       * @remarks This is to avoid manipulating the DOM directly - use Prosemirror state. Avoids re-rendering the entire document
       * @param {String} className - The CSS class to add to the AI highlights
       * @returns {Boolean} - True if the highlight style was updated
       */
      updateAiHighlightStyle: (className) => ({ tr, dispatch }) => {
        tr.setMeta(AiPluginKey, { type: "updateStyle", className });
        if (dispatch) dispatch(tr);
        return true;
      },
      /**
       * Clear any custom styling from AI highlights
       * @returns {Boolean} - True if the highlight style was cleared
       */
      clearAiHighlightStyle: () => ({ tr, dispatch }) => {
        tr.setMeta(AiPluginKey, { type: "updateStyle", className: null });
        if (dispatch) dispatch(tr);
        return true;
      },
      /**
       * Remove all AI marks from the document
       * @param {String} markName - The name of the mark to remove - defaults to AiMarkName
       * Can also be used to remove the ai animation mark after streams are complete
       * @returns {Boolean} - True if the mark was removed, false otherwise
       */
      removeAiMark: (markName = AiMarkName) => ({ tr, dispatch, state }) => {
        const { doc: doc2 } = state;
        let markFound = false;
        doc2.descendants((node, pos) => {
          const { marks = [] } = node;
          const aiMark = marks.find((mark) => mark.type.name === markName);
          if (aiMark) {
            markFound = true;
            tr.removeMark(pos, pos + node.nodeSize, state.schema.marks[markName]);
          }
        });
        if (markFound) {
          if (dispatch) dispatch(tr);
          return true;
        }
        return false;
      },
      /**
       * Remove all AI nodes of a specific type from the document
       * @param {String} nodeName - The name of the node to remove
       * @returns {Boolean} - True if any nodes were removed, false otherwise
       */
      removeAiNode: (nodeName = AiLoaderNodeName) => ({ tr, dispatch, state }) => {
        const { doc: doc2 } = state;
        const positions = [];
        doc2.descendants((node, pos) => {
          if (node.type.name === nodeName) {
            positions.push(pos);
          }
        });
        if (positions.length === 0) {
          return false;
        }
        positions.sort((a, b2) => b2 - a);
        positions.forEach((pos) => {
          const node = doc2.nodeAt(pos);
          if (node) {
            tr.delete(pos, pos + node.nodeSize);
          }
        });
        if (dispatch) dispatch(tr);
        return true;
      }
    };
  },
  addPmPlugins() {
    const editor = this.editor;
    const aiPlugin = new superEditor_converter.Plugin({
      key: AiPluginKey,
      state: {
        init() {
          return {
            decorations: DecorationSet.empty,
            highlightColor: "#6366f1",
            // Indigo color, matches AiLayer
            customClass: null
            // Pulse animation class spot (later)
          };
        },
        apply(tr, oldState, _2, newEditorState) {
          const meta = tr.getMeta(AiPluginKey);
          let customClass = oldState.customClass;
          if (meta && meta.type === "updateStyle") {
            customClass = meta.className;
          }
          if (tr.docChanged && customClass === "sd-ai-highlight-pulse") {
            let hasTextChanges = false;
            tr.steps.forEach((step) => {
              if (step.slice && step.slice.content.size > 0) {
                hasTextChanges = true;
              }
            });
            if (hasTextChanges) {
              customClass = null;
            }
          }
          if (!tr.docChanged && !meta) return oldState;
          const { decorations } = processAiHighlights(editor, newEditorState.doc, oldState.highlightColor, customClass) || {};
          const decorationSet = DecorationSet.create(newEditorState.doc, decorations);
          return {
            ...oldState,
            decorations: decorationSet,
            customClass
          };
        }
      },
      props: {
        decorations(state) {
          return this.getState(state).decorations;
        }
      }
    });
    return [aiPlugin];
  }
});
const processAiHighlights = (editor, doc2, highlightColor, customClass = null) => {
  const decorations = [];
  doc2.descendants((node, pos) => {
    const { marks = [] } = node;
    const aiMark = marks.find((mark) => mark.type.name === AiMarkName);
    if (aiMark) {
      const attrs = {
        style: `background-color: ${highlightColor}33; border-radius: 4px; transition: background-color 250ms ease;`,
        // 33 is 20% opacity in hex
        class: "sd-ai-highlight-element"
      };
      if (customClass) {
        attrs.class += ` ${customClass}`;
      }
      const deco = Decoration.inline(pos, pos + node.nodeSize, attrs);
      decorations.push(deco);
    }
  });
  return { decorations };
};
function getEditorSurfaceElement(editor) {
  if (!editor) return null;
  if (typeof editor.hitTest === "function" && editor.element instanceof HTMLElement) {
    return editor.element;
  }
  return editor.presentationEditor?.element ?? editor.view?.dom ?? editor.options?.element ?? null;
}
function getSurfaceRelativePoint(editor, eventLocation = {}) {
  const surface = getEditorSurfaceElement(editor);
  if (!surface) return null;
  const rect = surface.getBoundingClientRect();
  let left2;
  let top2;
  if (typeof eventLocation.clientX === "number" && typeof eventLocation.clientY === "number") {
    left2 = eventLocation.clientX - rect.left;
    top2 = eventLocation.clientY - rect.top;
  } else if (editor?.state?.selection) {
    const selectionFrom = editor.state.selection.from;
    const coords = editor.coordsAtPos?.(selectionFrom);
    if (coords) {
      left2 = coords.left - rect.left;
      top2 = coords.top - rect.top;
    }
  }
  if (!Number.isFinite(left2) || !Number.isFinite(top2)) {
    return null;
  }
  return { left: left2, top: top2 };
}
function findContainingBlockAncestor(element) {
  if (!element) return null;
  let current = element.parentElement;
  while (current && current !== document.body && current !== document.documentElement) {
    try {
      const style2 = window.getComputedStyle(current);
      const transform = style2.transform;
      const filter = style2.filter;
      const backdropFilter = style2.backdropFilter || style2.webkitBackdropFilter;
      const perspective = style2.perspective;
      const willChange = style2.willChange;
      const contain = style2.contain;
      if (transform && transform !== "none") {
        return current;
      }
      if (filter && filter !== "none") {
        return current;
      }
      if (backdropFilter && backdropFilter !== "none") {
        return current;
      }
      if (perspective && perspective !== "none") {
        return current;
      }
      if (willChange && willChange !== "auto") {
        const values = willChange.split(",").map((v) => v.trim());
        if (values.includes("transform") || values.includes("perspective")) {
          return current;
        }
      }
      if (contain && /paint|layout|strict|content/.test(contain)) {
        return current;
      }
    } catch (error) {
      console.warn("SlashMenu: Failed to get computed style for element", current, error);
    }
    current = current.parentElement;
  }
  return null;
}
const SlashMenuPluginKey = new superEditor_converter.PluginKey("slashMenu");
const MENU_OFFSET_X = 100;
const MENU_OFFSET_Y = 28;
const CONTEXT_MENU_OFFSET_X = 10;
const CONTEXT_MENU_OFFSET_Y = 10;
const SLASH_COOLDOWN_MS = 5e3;
const SlashMenu = Extension.create({
  name: "slashMenu",
  /**
   * Initialize default options for the SlashMenu extension
   * @returns {SlashMenuOptions} Empty options object (configuration is inherited from editor options)
   */
  addOptions() {
    return {};
  },
  addPmPlugins() {
    const editor = this.editor;
    if (editor.options?.isHeadless) {
      return [];
    }
    let slashCooldown = false;
    let slashCooldownTimeout = null;
    const isMenuDisabled = () => Boolean(editor.options?.disableContextMenu);
    const ensureStateShape = (value = {}) => ({
      open: false,
      selected: null,
      anchorPos: null,
      menuPosition: null,
      disabled: isMenuDisabled(),
      ...value
    });
    const slashMenuPlugin = new superEditor_converter.Plugin({
      key: SlashMenuPluginKey,
      state: {
        init: () => ensureStateShape(),
        /**
         * Apply transaction to update plugin state
         * Handles state transitions based on transaction metadata:
         * - 'open': Opens menu at specified position or cursor location
         * - 'select': Updates the selected menu item
         * - 'close': Closes the menu and clears anchor position
         * - 'updatePosition': Triggers menu position recalculation (no-op in apply)
         *
         * @param {import('prosemirror-state').Transaction} tr - The transaction
         * @param {SlashMenuState} value - Previous plugin state
         * @returns {SlashMenuState} New plugin state
         */
        apply(tr, value) {
          const meta = tr.getMeta(SlashMenuPluginKey);
          const disabled = isMenuDisabled();
          if (disabled) {
            if (value.open) {
              editor.emit("slashMenu:close");
            }
            return ensureStateShape({ disabled: true });
          }
          if (!meta) {
            if (value.disabled !== disabled) {
              return ensureStateShape({ ...value, disabled });
            }
            return value;
          }
          switch (meta.type) {
            case "open": {
              if (typeof meta.pos !== "number" || meta.pos < 0 || meta.pos > tr.doc.content.size) {
                console.warn("SlashMenu: Invalid position", meta.pos);
                return ensureStateShape(value);
              }
              let left2 = 0;
              let top2 = 0;
              let isContextMenu = false;
              if (typeof meta.clientX === "number" && typeof meta.clientY === "number") {
                left2 = meta.clientX;
                top2 = meta.clientY;
                isContextMenu = true;
              } else {
                const relativePoint = getSurfaceRelativePoint(editor, meta);
                if (relativePoint) {
                  const surface = editor.presentationEditor?.element ?? editor.view?.dom ?? editor.options?.element;
                  if (surface) {
                    try {
                      const rect = surface.getBoundingClientRect();
                      left2 = rect.left + relativePoint.left;
                      top2 = rect.top + relativePoint.top;
                    } catch (error) {
                      console.warn("SlashMenu: Failed to get surface bounds", error);
                      return ensureStateShape(value);
                    }
                  }
                }
              }
              const menuSurface = editor.presentationEditor?.element ?? editor.view?.dom ?? editor.options?.element;
              const containingBlock = findContainingBlockAncestor(menuSurface);
              if (containingBlock) {
                try {
                  const cbRect = containingBlock.getBoundingClientRect();
                  left2 -= cbRect.left;
                  top2 -= cbRect.top;
                  left2 += containingBlock.scrollLeft || 0;
                  top2 += containingBlock.scrollTop || 0;
                } catch (error) {
                  console.warn("SlashMenu: Failed to adjust for containing block", error);
                }
              }
              const offsetX = isContextMenu ? CONTEXT_MENU_OFFSET_X : MENU_OFFSET_X;
              const offsetY = isContextMenu ? CONTEXT_MENU_OFFSET_Y : MENU_OFFSET_Y;
              const menuPosition = {
                left: `${left2 + offsetX}px`,
                top: `${top2 + offsetY}px`
              };
              const newState = {
                ...value,
                open: true,
                anchorPos: meta.pos,
                menuPosition
              };
              editor.emit("slashMenu:open", { menuPosition });
              return ensureStateShape(newState);
            }
            case "select": {
              return ensureStateShape({ ...value, selected: meta.id });
            }
            case "close": {
              editor.emit("slashMenu:close");
              return ensureStateShape({ ...value, open: false, anchorPos: null });
            }
            default:
              return ensureStateShape({ ...value, disabled });
          }
        }
      },
      /**
       * Create view plugin to handle window event listeners
       * @param {import('prosemirror-view').EditorView} editorView - The ProseMirror editor view
       * @returns {Object} View plugin with destroy method
       */
      view(editorView) {
        const updatePosition2 = () => {
          if (isMenuDisabled()) return;
          const state = SlashMenuPluginKey.getState(editorView.state);
          if (state.open) {
            editorView.dispatch(
              editorView.state.tr.setMeta(SlashMenuPluginKey, {
                type: "updatePosition"
              })
            );
          }
        };
        window.addEventListener("scroll", updatePosition2, true);
        window.addEventListener("resize", updatePosition2);
        return {
          destroy() {
            window.removeEventListener("scroll", updatePosition2, true);
            window.removeEventListener("resize", updatePosition2);
            if (slashCooldownTimeout) {
              clearTimeout(slashCooldownTimeout);
              slashCooldownTimeout = null;
            }
          }
        };
      },
      props: {
        /**
         * Handle keyboard events to open/close the slash menu
         * - '/': Opens menu at cursor if conditions are met (in paragraph, after space/start)
         * - 'Escape' or 'ArrowLeft': Closes menu and restores cursor position
         *
         * @param {import('prosemirror-view').EditorView} view - The ProseMirror editor view
         * @param {KeyboardEvent} event - The keyboard event
         * @returns {boolean} True if the event was handled, false otherwise
         */
        handleKeyDown(view, event) {
          if (isMenuDisabled()) {
            return false;
          }
          const pluginState = this.getState(view.state);
          if (event.key === "/" && slashCooldown) {
            return false;
          }
          if (event.key === "/" && !pluginState.open) {
            const { $cursor } = view.state.selection;
            if (!$cursor) return false;
            const isParagraph = $cursor.parent.type.name === "paragraph";
            if (!isParagraph) return false;
            const textBefore = $cursor.parent.textContent.slice(0, $cursor.parentOffset);
            const isEmptyOrAfterSpace = !textBefore || textBefore.endsWith(" ");
            if (!isEmptyOrAfterSpace) return false;
            event.preventDefault();
            slashCooldown = true;
            if (slashCooldownTimeout) clearTimeout(slashCooldownTimeout);
            slashCooldownTimeout = setTimeout(() => {
              slashCooldown = false;
              slashCooldownTimeout = null;
            }, SLASH_COOLDOWN_MS);
            view.dispatch(
              view.state.tr.setMeta(SlashMenuPluginKey, {
                type: "open",
                pos: $cursor.pos
              })
            );
            return true;
          }
          if (pluginState.open && (event.key === "Escape" || event.key === "ArrowLeft")) {
            const { anchorPos } = pluginState;
            view.dispatch(
              view.state.tr.setMeta(SlashMenuPluginKey, {
                type: "close"
              })
            );
            if (anchorPos !== null) {
              const tr = view.state.tr.setSelection(
                view.state.selection.constructor.near(view.state.doc.resolve(anchorPos))
              );
              view.dispatch(tr);
              view.focus();
            }
            return true;
          }
          return false;
        }
      }
    });
    return [slashMenuPlugin];
  }
});
class StructuredContentViewBase {
  node;
  view;
  getPos;
  decorations;
  innerDecorations;
  editor;
  extension;
  htmlAttributes;
  root;
  isDragging = false;
  constructor(props) {
    this.node = props.node;
    this.view = props.editor.view;
    this.getPos = props.getPos;
    this.decorations = props.decorations;
    this.innerDecorations = props.innerDecorations;
    this.editor = props.editor;
    this.extension = props.extension;
    this.htmlAttributes = props.htmlAttributes;
    this.mount(props);
  }
  mount() {
    return;
  }
  get dom() {
    return this.root;
  }
  get contentDOM() {
    return null;
  }
  update(node, decorations, innerDecorations) {
    if (node.type !== this.node.type) {
      return false;
    }
    this.node = node;
    this.decorations = decorations;
    this.innerDecorations = innerDecorations;
    this.updateHTMLAttributes();
    return true;
  }
  stopEvent(event) {
    if (!this.dom) return false;
    const target = event.target;
    const isInElement = this.dom.contains(target) && !this.contentDOM?.contains(target);
    if (!isInElement) return false;
    const isDragEvent = event.type.startsWith("drag");
    const isDropEvent = event.type === "drop";
    const isInput = ["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(target.tagName) || target.isContentEditable;
    if (isInput && !isDropEvent && !isDragEvent) return true;
    const { isEditable } = this.editor;
    const { isDragging } = this;
    const isDraggable = !!this.node.type.spec.draggable;
    const isSelectable = superEditor_converter.NodeSelection.isSelectable(this.node);
    const isCopyEvent = event.type === "copy";
    const isPasteEvent = event.type === "paste";
    const isCutEvent = event.type === "cut";
    const isClickEvent = event.type === "mousedown";
    if (!isDraggable && isSelectable && isDragEvent && event.target === this.dom) {
      event.preventDefault();
    }
    if (isDraggable && isDragEvent && !isDragging && event.target === this.dom) {
      event.preventDefault();
      return false;
    }
    if (isDraggable && isEditable && !isDragging && isClickEvent) {
      const dragHandle = target.closest("[data-drag-handle]");
      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));
      if (isValidDragHandle) {
        this.isDragging = true;
        document.addEventListener(
          "dragend",
          () => {
            this.isDragging = false;
          },
          { once: true }
        );
        document.addEventListener(
          "drop",
          () => {
            this.isDragging = false;
          },
          { once: true }
        );
        document.addEventListener(
          "mouseup",
          () => {
            this.isDragging = false;
          },
          { once: true }
        );
      }
    }
    if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {
      return false;
    }
    return true;
  }
  ignoreMutation(mutation) {
    if (!this.dom || !this.contentDOM) return true;
    if (this.node.isLeaf || this.node.isAtom) return true;
    if (mutation.type === "selection") return false;
    if (this.contentDOM === mutation.target && mutation.type === "attributes") return true;
    if (this.contentDOM.contains(mutation.target)) return false;
    return true;
  }
  destroy() {
    this.dom.remove();
    this.contentDOM?.remove();
  }
  updateAttributes(attrs) {
    const pos = this.getPos();
    if (typeof pos !== "number") {
      return;
    }
    return this.view.dispatch(
      this.view.state.tr.setNodeMarkup(pos, void 0, {
        ...this.node.attrs,
        ...attrs
      })
    );
  }
  updateHTMLAttributes() {
    const { extensionService } = this.editor;
    const { attributes } = extensionService;
    const extensionAttrs = attributes.filter((i) => i.type === this.node.type.name);
    this.htmlAttributes = Attribute.getAttributesToRender(this.node, extensionAttrs);
  }
  createDragHandle() {
    const dragHandle = document.createElement("span");
    dragHandle.classList.add("sd-structured-content-draggable");
    dragHandle.draggable = true;
    dragHandle.contentEditable = "false";
    dragHandle.dataset.dragHandle = "";
    const textElement = document.createElement("span");
    textElement.textContent = this.node.attrs.alias || "Structured content";
    dragHandle.append(textElement);
    return dragHandle;
  }
  onDragStart(event) {
    const { view } = this.editor;
    const target = event.target;
    const dragHandle = target.nodeType === 3 ? target.parentElement?.closest("[data-drag-handle]") : target.closest("[data-drag-handle]");
    if (!this.dom || this.contentDOM?.contains(target) || !dragHandle) {
      return;
    }
    let x = 0;
    let y2 = 0;
    if (this.dom !== dragHandle) {
      const domBox = this.dom.getBoundingClientRect();
      const handleBox = dragHandle.getBoundingClientRect();
      const offsetX = event.offsetX ?? event.nativeEvent?.offsetX;
      const offsetY = event.offsetY ?? event.nativeEvent?.offsetY;
      x = handleBox.x - domBox.x + offsetX;
      y2 = handleBox.y - domBox.y + offsetY;
    }
    event.dataTransfer?.setDragImage(this.dom, x, y2);
    const pos = this.getPos();
    if (typeof pos !== "number") {
      return;
    }
    const selection = superEditor_converter.NodeSelection.create(view.state.doc, pos);
    const transaction = view.state.tr.setSelection(selection);
    view.dispatch(transaction);
  }
}
class StructuredContentInlineView extends StructuredContentViewBase {
  constructor(props) {
    super(props);
  }
  mount() {
    this.buildView();
  }
  get contentDOM() {
    const contentElement = this.dom?.querySelector(`.${structuredContentInnerClass}`);
    return contentElement || null;
  }
  createElement() {
    const element = document.createElement("span");
    element.classList.add(structuredContentClass);
    element.setAttribute("data-structured-content", "");
    const contentElement = document.createElement("span");
    contentElement.classList.add(structuredContentInnerClass);
    element.append(contentElement);
    const domAttrs = Attribute.mergeAttributes(this.htmlAttributes);
    updateDOMAttributes(element, { ...domAttrs });
    return { element, contentElement };
  }
  buildView() {
    const { element } = this.createElement();
    const dragHandle = this.createDragHandle();
    element.prepend(dragHandle);
    element.addEventListener("dragstart", (e) => this.onDragStart(e));
    this.root = element;
  }
  updateView() {
    const domAttrs = Attribute.mergeAttributes(this.htmlAttributes);
    updateDOMAttributes(this.dom, { ...domAttrs });
  }
  update(node, decorations, innerDecorations) {
    const result = super.update(node, decorations, innerDecorations);
    if (!result) return false;
    this.updateView();
    return true;
  }
}
const structuredContentClass = "sd-structured-content";
const structuredContentInnerClass = "sd-structured-content__content";
const StructuredContent = Node$1.create({
  name: "structuredContent",
  group: "inline structuredContent",
  inline: true,
  content: "inline*",
  isolating: true,
  atom: false,
  // false - has editable content.
  draggable: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: structuredContentClass,
        "aria-label": "Structured content node"
      }
    };
  },
  addAttributes() {
    return {
      id: {
        default: null,
        parseDOM: (elem) => elem.getAttribute("data-id"),
        renderDOM: (attrs) => {
          if (!attrs.id) return {};
          return { "data-id": attrs.id };
        }
      },
      tag: {
        default: null,
        parseDOM: (elem) => elem.getAttribute("data-tag"),
        renderDOM: (attrs) => {
          if (!attrs.tag) return {};
          return { "data-tag": attrs.tag };
        }
      },
      alias: {
        default: null,
        parseDOM: (elem) => elem.getAttribute("data-alias"),
        renderDOM: (attrs) => {
          if (!attrs.alias) return {};
          return { "data-alias": attrs.alias };
        }
      },
      sdtPr: {
        rendered: false
      }
    };
  },
  parseDOM() {
    return [{ tag: "span[data-structured-content]" }];
  },
  renderDOM({ htmlAttributes }) {
    return [
      "span",
      Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes, {
        "data-structured-content": ""
      }),
      0
    ];
  },
  addNodeView() {
    return (props) => {
      return new StructuredContentInlineView({ ...props });
    };
  }
});
class StructuredContentBlockView extends StructuredContentViewBase {
  constructor(props) {
    super(props);
  }
  mount() {
    this.buildView();
  }
  get contentDOM() {
    const contentElement = this.dom?.querySelector(`.${structuredContentBlockInnerClass}`);
    return contentElement || null;
  }
  createElement() {
    const element = document.createElement("div");
    element.classList.add(structuredContentBlockClass);
    element.setAttribute("data-structured-content-block", "");
    const contentElement = document.createElement("div");
    contentElement.classList.add(structuredContentBlockInnerClass);
    element.append(contentElement);
    const domAttrs = Attribute.mergeAttributes(this.htmlAttributes);
    updateDOMAttributes(element, { ...domAttrs });
    return { element, contentElement };
  }
  buildView() {
    const { element } = this.createElement();
    const dragHandle = this.createDragHandle();
    element.prepend(dragHandle);
    element.addEventListener("dragstart", (e) => this.onDragStart(e));
    this.root = element;
  }
  updateView() {
    const domAttrs = Attribute.mergeAttributes(this.htmlAttributes);
    updateDOMAttributes(this.dom, { ...domAttrs });
  }
  update(node, decorations, innerDecorations) {
    const result = super.update(node, decorations, innerDecorations);
    if (!result) return false;
    this.updateView();
    return true;
  }
}
const structuredContentBlockClass = "sd-structured-content-block";
const structuredContentBlockInnerClass = "sd-structured-content-block__content";
const StructuredContentBlock = Node$1.create({
  name: "structuredContentBlock",
  group: "block structuredContent",
  content: "block*",
  isolating: true,
  atom: false,
  // false - has editable content.
  draggable: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: structuredContentBlockClass,
        "aria-label": "Structured content block node"
      }
    };
  },
  addAttributes() {
    return {
      id: {
        default: null,
        parseDOM: (elem) => elem.getAttribute("data-id"),
        renderDOM: (attrs) => {
          if (!attrs.id) return {};
          return { "data-id": attrs.id };
        }
      },
      tag: {
        default: null,
        parseDOM: (elem) => elem.getAttribute("data-tag"),
        renderDOM: (attrs) => {
          if (!attrs.tag) return {};
          return { "data-tag": attrs.tag };
        }
      },
      alias: {
        default: null,
        parseDOM: (elem) => elem.getAttribute("data-alias"),
        renderDOM: (attrs) => {
          if (!attrs.alias) return {};
          return { "data-alias": attrs.alias };
        }
      },
      sdtPr: {
        rendered: false
      }
    };
  },
  parseDOM() {
    return [{ tag: "div[data-structured-content-block]" }];
  },
  renderDOM({ htmlAttributes }) {
    return [
      "div",
      Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes, {
        "data-structured-content-block": ""
      }),
      0
    ];
  },
  addNodeView() {
    return (props) => {
      return new StructuredContentBlockView({ ...props });
    };
  }
});
function getStructuredContentTagsById(idOrIds, state) {
  const result = findChildren$5(state.doc, (node) => {
    const isStructuredContent = ["structuredContent", "structuredContentBlock"].includes(node.type.name);
    if (Array.isArray(idOrIds)) {
      return isStructuredContent && idOrIds.includes(node.attrs.id);
    } else {
      return isStructuredContent && node.attrs.id === idOrIds;
    }
  });
  return result;
}
function createTagObject(tagData) {
  if (!tagData || typeof tagData !== "object") {
    return null;
  }
  return JSON.stringify(tagData);
}
function parseTagObject(tag) {
  if (typeof tag !== "string" || !tag.startsWith("{")) {
    return null;
  }
  try {
    const parsed = JSON.parse(tag);
    return parsed && typeof parsed === "object" ? parsed : null;
  } catch {
    return null;
  }
}
function hasGroup(tag) {
  const parsed = parseTagObject(tag);
  return parsed !== null && typeof parsed.group === "string";
}
function getGroup(tag) {
  const parsed = parseTagObject(tag);
  return parsed && typeof parsed.group === "string" ? parsed.group : null;
}
function getStructuredContentByGroup(groupOrGroups, state) {
  const searchGroups = Array.isArray(groupOrGroups) ? groupOrGroups : [groupOrGroups];
  const result = findChildren$5(state.doc, (node) => {
    const isStructuredContent = ["structuredContent", "structuredContentBlock"].includes(node.type.name);
    if (!isStructuredContent) {
      return false;
    }
    const nodeGroup = getGroup(node.attrs.tag);
    if (!nodeGroup) {
      return false;
    }
    return searchGroups.includes(nodeGroup);
  });
  return result;
}
function getStructuredContentTags(state) {
  const result = findChildren$5(state.doc, (node) => {
    return node.type.name === "structuredContent" || node.type.name === "structuredContentBlock";
  });
  return result;
}
function getStructuredContentInlineTags(state) {
  const result = findChildren$5(state.doc, (node) => node.type.name === "structuredContent");
  return result;
}
function getStructuredContentBlockTags(state) {
  const result = findChildren$5(state.doc, (node) => node.type.name === "structuredContentBlock");
  return result;
}
function getStructuredContentTablesById(id, state) {
  if (!id || !state) return [];
  const blocks = getStructuredContentTagsById(id, state).filter(
    ({ node }) => node.type.name === "structuredContentBlock"
  );
  if (!blocks.length) return [];
  const { pos: blockPos, node: blockNode } = blocks[0];
  const tablesInBlock = [];
  blockNode.descendants((child, relPos) => {
    if (child.type.name === "table") {
      const absPos = blockPos + 1 + relPos;
      tablesInBlock.push({ node: child, pos: absPos });
    }
  });
  return tablesInBlock;
}
const structuredContentHelpers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createTagObject,
  getGroup,
  getStructuredContentBlockTags,
  getStructuredContentByGroup,
  getStructuredContentInlineTags,
  getStructuredContentTablesById,
  getStructuredContentTags,
  getStructuredContentTagsById,
  hasGroup,
  parseTagObject
}, Symbol.toStringTag, { value: "Module" }));
const STRUCTURED_CONTENT_NAMES = ["structuredContent", "structuredContentBlock"];
function isValidIntegerId(id) {
  if (id === null || id === void 0) return true;
  const str = String(id);
  return /^-?\d+$/.test(str);
}
const findFirstTextNode = (node) => {
  let firstTextNode = null;
  node.descendants((child) => {
    if (child.isText) {
      firstTextNode = child;
      return false;
    }
    return true;
  });
  return firstTextNode;
};
const StructuredContentCommands = Extension.create({
  name: "structuredContentCommands",
  addCommands() {
    return {
      /**
       * Inserts a structured content inline at selection.
       * @category Command
       * @param {StructuredContentInlineInsert} options
       * @example
       * // With group for linking multiple fields
       * editor.commands.insertStructuredContentInline({
       *  attrs: {
       *   group: 'customer-info',
       *   alias: 'Customer Name',
       *  },
       *  text: 'John Doe',
       * });
       *
       * // No group
       * editor.commands.insertStructuredContentInline({
       *  attrs: {
       *   id: '123',
       *   alias: 'Customer Name',
       *  },
       *  text: 'John Doe',
       *  // or
       *  json: { type: 'text', text: 'John Doe' },
       * });
       */
      insertStructuredContentInline: (options = {}) => ({ editor, dispatch, state, tr }) => {
        if (options.attrs?.id !== void 0 && !isValidIntegerId(options.attrs.id)) {
          throw new Error("Invalid structured content id - must be an integer, got: " + options.attrs.id);
        }
        const { schema } = editor;
        let { from: from3, to } = state.selection;
        if (dispatch) {
          const selectionText = state.doc.textBetween(from3, to);
          let content = null;
          if (selectionText) {
            content = schema.text(selectionText);
          }
          if (options.text) {
            content = schema.text(options.text);
          }
          if (options.json) {
            content = schema.nodeFromJSON(options.json);
          }
          if (!content) {
            content = schema.text(" ");
          }
          let tag = options.attrs?.tag || "inline_text_sdt";
          if (options.attrs?.group) {
            tag = createTagObject({ group: options.attrs.group });
          }
          const attrs = {
            id: options.attrs?.id || superEditor_converter.generateRandomSigned32BitIntStrId(),
            tag,
            alias: options.attrs?.alias || "Structured content",
            ...options.attrs
          };
          delete attrs.group;
          const node = schema.nodes.structuredContent.create(attrs, content, null);
          const parent = superEditor_converter.findParentNode((node2) => node2.type.name === "structuredContent")(state.selection);
          if (parent) {
            const insertPos = parent.pos + parent.node.nodeSize;
            from3 = to = insertPos;
          }
          tr.replaceWith(from3, to, node);
        }
        return true;
      },
      /**
       * Inserts a structured content block at selection.
       * @category Command
       * @param {StructuredContentBlockInsert} options
       * @example
       * // With group for linking multiple fields
       * editor.commands.insertStructuredContentBlock({
       *  attrs: {
       *    group: 'terms-section',
       *    alias: 'Terms & Conditions',
       *  },
       *  html: '<p>Legal content...</p>',
       * });
       *
       * // No group
       * editor.commands.insertStructuredContentBlock({
       *  attrs: {
       *    id: '456',
       *    alias: 'Terms & Conditions',
       *  },
       *  json: { type: 'paragraph', content: [{ type: 'text', text: 'Legal content...' }] }
       * });
       */
      insertStructuredContentBlock: (options = {}) => ({ editor, dispatch, state, tr }) => {
        if (options.attrs?.id !== void 0 && !isValidIntegerId(options.attrs.id)) {
          throw new Error("Invalid structured content id - must be an integer, got: " + options.attrs.id);
        }
        const { schema } = editor;
        let { from: from3, to } = state.selection;
        if (dispatch) {
          const selectionContent = state.selection.content();
          let content = null;
          if (selectionContent.size) {
            content = selectionContent.content;
          }
          if (options.html) {
            const html = superEditor_converter.htmlHandler(options.html, editor);
            const doc2 = superEditor_converter.DOMParser.fromSchema(schema).parse(html);
            content = doc2.content;
          }
          if (options.json) {
            content = schema.nodeFromJSON(options.json);
          }
          if (!content) {
            content = schema.nodeFromJSON({ type: "paragraph", content: [] });
          }
          let tag = options.attrs?.tag || "block_table_sdt";
          if (options.attrs?.group) {
            tag = createTagObject({ group: options.attrs.group });
          }
          const attrs = {
            id: options.attrs?.id || superEditor_converter.generateRandomSigned32BitIntStrId(),
            tag,
            alias: options.attrs?.alias || "Structured content",
            ...options.attrs
          };
          delete attrs.group;
          const node = schema.nodes.structuredContentBlock.create(attrs, content, null);
          const parent = superEditor_converter.findParentNode((node2) => node2.type.name === "structuredContentBlock")(state.selection);
          if (parent) {
            const insertPos = parent.pos + parent.node.nodeSize;
            from3 = to = insertPos;
          }
          tr.replaceRangeWith(from3, to, node);
        }
        return true;
      },
      /**
       * Updates a single structured content field by its unique ID.
       * IDs are unique identifiers, so this will update at most one field.
       * If the updated node does not match the schema, it will not be updated.
       * @category Command
       * @param {string} id - Unique identifier of the field
       * @param {StructuredContentUpdate} options
       * @example
       * editor.commands.updateStructuredContentById('123', { text: 'Jane Doe', keepTextNodeStyles: true });
       * editor.commands.updateStructuredContentById('123', {
       *  json: { type: 'text', text: 'Jane Doe' },
       * });
       * editor.commands.updateStructuredContentById('456', {
       *  html: '<p>Updated legal content...</p>'
       * });
       */
      updateStructuredContentById: (id, options = {}) => ({ editor, dispatch, state, tr }) => {
        if (options.attrs?.id !== void 0 && !isValidIntegerId(options.attrs.id)) {
          throw new Error("Invalid structured content id - must be an integer, got: " + options.attrs.id);
        }
        const structuredContentTags = getStructuredContentTagsById(id, state);
        if (!structuredContentTags.length) {
          return true;
        }
        const { schema } = editor;
        if (dispatch) {
          const structuredContent = structuredContentTags[0];
          const { pos, node } = structuredContent;
          const posFrom = pos;
          const posTo = pos + node.nodeSize;
          let content = null;
          if (options.text) {
            const firstTextNode = options.keepTextNodeStyles === true ? findFirstTextNode(node) : null;
            const textMarks = firstTextNode ? firstTextNode.marks : [];
            content = schema.text(options.text, textMarks);
          }
          if (options.html) {
            const html = superEditor_converter.htmlHandler(options.html, editor);
            const doc2 = superEditor_converter.DOMParser.fromSchema(schema).parse(html);
            content = doc2.content;
          }
          if (options.json) {
            content = schema.nodeFromJSON(options.json);
          }
          if (!content) {
            content = node.content;
          }
          const updatedNode = node.type.create({ ...node.attrs, ...options.attrs }, content, node.marks);
          try {
            const nodeForValidation = editor.validateJSON(updatedNode.toJSON());
            nodeForValidation.check();
          } catch (error) {
            console.error("Invalid content.", "Passed value:", content, "Error:", error);
            return false;
          }
          tr.replaceWith(posFrom, posTo, updatedNode);
        }
        return true;
      },
      /**
       * Removes a structured content.
       * @category Command
       * @param {Array<{ node: Node, pos: number }>} structuredContentTags
       * @example
       * const fields = editor.helpers.structuredContentCommands.getStructuredContentTagsById(['123'], editor.state);
       * editor.commands.deleteStructuredContent(fields);
       */
      deleteStructuredContent: (structuredContentTags) => ({ dispatch, tr }) => {
        if (!structuredContentTags.length) {
          return true;
        }
        if (dispatch) {
          structuredContentTags.forEach((structuredContent) => {
            const { pos, node } = structuredContent;
            const posFrom = tr.mapping.map(pos);
            const posTo = tr.mapping.map(pos + node.nodeSize);
            const currentNode = tr.doc.nodeAt(posFrom);
            if (currentNode && node.eq(currentNode)) {
              tr.delete(posFrom, posTo);
            }
          });
        }
        return true;
      },
      /**
       * Removes a structured content by ID.
       * @category Command
       * @param {string | string[]} idOrIds
       * @example
       * editor.commands.deleteStructuredContentById('123');
       * editor.commands.deleteStructuredContentById(['123', '456']);
       */
      deleteStructuredContentById: (idOrIds) => ({ dispatch, state, tr }) => {
        const structuredContentTags = getStructuredContentTagsById(idOrIds, state);
        if (!structuredContentTags.length) {
          return true;
        }
        if (dispatch) {
          structuredContentTags.forEach((structuredContent) => {
            const { pos, node } = structuredContent;
            const posFrom = tr.mapping.map(pos);
            const posTo = tr.mapping.map(pos + node.nodeSize);
            const currentNode = tr.doc.nodeAt(posFrom);
            if (currentNode && node.eq(currentNode)) {
              tr.delete(posFrom, posTo);
            }
          });
        }
        return true;
      },
      /**
       * Removes a structured content at cursor, preserving its content.
       * @category Command
       * @example
       * editor.commands.deleteStructuredContentAtSelection();
       */
      deleteStructuredContentAtSelection: () => ({ dispatch, state, tr }) => {
        const predicate = (node) => STRUCTURED_CONTENT_NAMES.includes(node.type.name);
        const structuredContent = superEditor_converter.findParentNode(predicate)(state.selection);
        if (!structuredContent) {
          return true;
        }
        if (dispatch) {
          const { node, pos } = structuredContent;
          const posFrom = pos;
          const posTo = posFrom + node.nodeSize;
          const content = node.content;
          tr.replaceWith(posFrom, posTo, content);
        }
        return true;
      },
      /**
       * Updates all structured content fields that share the same group identifier.
       * Groups allow linking multiple fields together for batch operations.
       * @category Command
       * @param {string} group - Group identifier shared by multiple fields
       * @param {StructuredContentUpdate} options
       * @example
       * // Update all fields in the customer-info group
       * editor.commands.updateStructuredContentByGroup('customer-info', { text: 'Jane Doe', keepTextNodeStyles: true });
       *
       * // Update block content in a group
       * editor.commands.updateStructuredContentByGroup('terms-section', {
       *  html: '<p>Updated terms...</p>'
       * });
       */
      updateStructuredContentByGroup: (group, options = {}) => ({ editor, dispatch, state, tr }) => {
        if (options.attrs?.id !== void 0 && !isValidIntegerId(options.attrs.id)) {
          throw new Error("Invalid structured content id - must be an integer, got: " + options.attrs.id);
        }
        const structuredContentTags = getStructuredContentByGroup(group, state);
        if (!structuredContentTags.length) {
          return true;
        }
        const { schema } = editor;
        if (dispatch) {
          const updates = [];
          for (const structuredContent of structuredContentTags) {
            const { pos, node } = structuredContent;
            let content = null;
            if (options.text) {
              const firstTextNode = options.keepTextNodeStyles === true ? findFirstTextNode(node) : null;
              const textMarks = firstTextNode ? firstTextNode.marks : [];
              content = schema.text(options.text, textMarks);
            }
            if (options.html) {
              const html = superEditor_converter.htmlHandler(options.html, editor);
              const doc2 = superEditor_converter.DOMParser.fromSchema(schema).parse(html);
              content = doc2.content;
            }
            if (options.json) {
              content = schema.nodeFromJSON(options.json);
            }
            if (!content) {
              content = node.content;
            }
            const updatedNode = node.type.create({ ...node.attrs, ...options.attrs }, content, node.marks);
            try {
              const nodeForValidation = editor.validateJSON(updatedNode.toJSON());
              nodeForValidation.check();
            } catch (error) {
              console.error("Invalid content.", "Passed value:", content, "Error:", error);
              return false;
            }
            updates.push({ pos, node, updatedNode });
          }
          for (const { pos, node, updatedNode } of updates) {
            const posFrom = tr.mapping.map(pos);
            const posTo = tr.mapping.map(pos + node.nodeSize);
            const currentNode = tr.doc.nodeAt(posFrom);
            if (currentNode && node.eq(currentNode)) {
              tr.replaceWith(posFrom, posTo, updatedNode);
            }
          }
        }
        return true;
      },
      /**
       * Removes all structured content fields that share the same group identifier.
       * @category Command
       * @param {string | string[]} groupOrGroups - Single group or array of groups
       * @example
       * // Delete all fields in a group
       * editor.commands.deleteStructuredContentByGroup('customer-info');
       *
       * // Delete multiple groups
       * editor.commands.deleteStructuredContentByGroup(['header', 'footer']);
       */
      deleteStructuredContentByGroup: (groupOrGroups) => ({ dispatch, state, tr }) => {
        const structuredContentTags = getStructuredContentByGroup(groupOrGroups, state);
        if (!structuredContentTags.length) {
          return true;
        }
        if (dispatch) {
          structuredContentTags.forEach((structuredContent) => {
            const { pos, node } = structuredContent;
            const posFrom = tr.mapping.map(pos);
            const posTo = tr.mapping.map(pos + node.nodeSize);
            const currentNode = tr.doc.nodeAt(posFrom);
            if (currentNode && node.eq(currentNode)) {
              tr.delete(posFrom, posTo);
            }
          });
        }
        return true;
      },
      /**
       * Append multiple rows to the end of a table inside a structured content block.
       * Each inner array represents the cell values for one new row.
       * @category Command
       * @param {StructuredContentTableAppendRowsOptions} options - Append configuration
       * @example
       * editor.commands.appendRowsToStructuredContentTable({
       *   id: 'block-123',
       *   tableIndex: 0,
       *   rows: [['A', 'B'], ['C', 'D']],
       *   copyRowStyle: true,
       * });
       */
      appendRowsToStructuredContentTable: ({ id, tableIndex = 0, rows = [], copyRowStyle = false }) => ({ state, commands: commands2, dispatch }) => {
        const normalized = normalizeRowsInput(rows);
        if (!normalized.length) return true;
        const tables = getStructuredContentTablesById(id, state);
        if (!tables.length || tableIndex < 0 || tableIndex >= tables.length) return true;
        const { node: tableNode, pos: tablePos } = tables[tableIndex];
        if (dispatch) {
          return commands2.appendRowsWithContent({ tablePos, tableNode, valueRows: normalized, copyRowStyle });
        }
        return commands2.appendRowsWithContent({
          tablePos,
          tableNode,
          valueRows: normalized,
          copyRowStyle,
          dispatch: false
        });
      }
    };
  },
  addHelpers() {
    return {
      ...structuredContentHelpers
    };
  }
});
const normalizeRowsInput = (rowsOrValues) => {
  if (!Array.isArray(rowsOrValues) || !rowsOrValues.length) {
    return [];
  }
  if (Array.isArray(rowsOrValues[0])) {
    return rowsOrValues;
  }
  return [rowsOrValues];
};
class DocumentSectionView {
  constructor(node, getPos, decorations, editor) {
    this.node = node;
    this.editor = editor;
    this.decorations = decorations;
    this.view = editor.view;
    this.getPos = getPos;
    this.#init();
  }
  #init() {
    const { attrs } = this.node;
    const { id, title, description } = attrs;
    this.dom = document.createElement("div");
    this.dom.className = "sd-document-section-block";
    this.dom.setAttribute("data-id", id);
    this.dom.setAttribute("data-title", title);
    this.dom.setAttribute("data-description", description);
    this.dom.setAttribute("aria-label", "Document section");
    this.#addToolTip();
    this.contentDOM = document.createElement("div");
    this.contentDOM.className = "sd-document-section-block-content";
    this.contentDOM.setAttribute("contenteditable", "true");
    this.dom.appendChild(this.contentDOM);
  }
  #addToolTip() {
    const { title } = this.node.attrs;
    this.infoDiv = document.createElement("div");
    this.infoDiv.className = "sd-document-section-block-info";
    const textSpan = document.createElement("span");
    textSpan.textContent = title || "Document section";
    this.infoDiv.appendChild(textSpan);
    this.infoDiv.setAttribute("contenteditable", "false");
    this.dom.appendChild(this.infoDiv);
  }
}
const getAllSections = (editor) => {
  if (!editor) return [];
  const type = editor.schema.nodes.documentSection;
  if (!type) return [];
  const sections = [];
  const { state } = editor;
  state.doc.descendants((node, pos) => {
    if (node.type.name === type.name) {
      sections.push({ node, pos });
    }
  });
  return sections;
};
const exportSectionsToHTML = (editor) => {
  const sections = getAllSections(editor);
  const processedSections = /* @__PURE__ */ new Set();
  const result = [];
  sections.forEach(({ node }) => {
    const { attrs } = node;
    const { id, title, description } = attrs;
    if (processedSections.has(id)) return;
    processedSections.add(id);
    const html = getHTMLFromNode(node, editor);
    result.push({
      id,
      title,
      description,
      html
    });
  });
  return result;
};
const getHTMLFromNode = (node, editor) => {
  const tempDocument = document.implementation.createHTMLDocument();
  const container = tempDocument.createElement("div");
  const fragment = superEditor_converter.DOMSerializer.fromSchema(editor.schema).serializeFragment(node.content);
  container.appendChild(fragment);
  let html = container.innerHTML;
  return html;
};
const exportSectionsToJSON = (editor) => {
  const sections = getAllSections(editor);
  const processedSections = /* @__PURE__ */ new Set();
  const result = [];
  sections.forEach(({ node }) => {
    const { attrs } = node;
    const { id, title, description } = attrs;
    if (processedSections.has(id)) return;
    processedSections.add(id);
    result.push({
      id,
      title,
      description,
      content: node.toJSON()
    });
  });
  return result;
};
const getLinkedSectionEditor = (id, options, editor) => {
  const sections = getAllSections(editor);
  const section = sections.find((s) => s.node.attrs.id === id);
  if (!section) return null;
  const child = editor.createChildEditor({
    ...options,
    onUpdate: ({ editor: childEditor, transaction }) => {
      const isFromtLinkedParent = transaction.getMeta("fromLinkedParent");
      if (isFromtLinkedParent) return;
      const updatedContent = childEditor.state.doc.content;
      const sectionNode = getAllSections(editor)?.find((s) => s.node.attrs.id === id);
      if (!sectionNode) return;
      const { pos, node } = sectionNode;
      const newNode = node.type.create(node.attrs, updatedContent, node.marks);
      const tr = editor.state.tr.replaceWith(pos, pos + node.nodeSize, newNode);
      tr.setMeta("fromLinkedChild", true);
      const dispatch = typeof editor.view?.dispatch === "function" ? editor.view.dispatch.bind(editor.view) : editor.dispatch.bind(editor);
      dispatch(tr);
    }
  });
  editor.on("update", ({ transaction }) => {
    const isFromLinkedChild = transaction.getMeta("fromLinkedChild");
    if (isFromLinkedChild) return;
    const sectionNode = getAllSections(editor)?.find((s) => s.node.attrs.id === id);
    if (!sectionNode) return;
    const sectionContent = sectionNode.node.content;
    const json = {
      type: "doc",
      content: sectionContent.content.map((node) => node.toJSON())
    };
    const childTr = child.state.tr;
    childTr.setMeta("fromLinkedParent", true);
    childTr.replaceWith(0, child.state.doc.content.size, child.schema.nodeFromJSON(json));
    const dispatch = typeof child.view?.dispatch === "function" ? child.view.dispatch.bind(child.view) : child.dispatch.bind(child);
    dispatch(childTr);
  });
  return child;
};
const SectionHelpers = {
  getAllSections,
  exportSectionsToHTML,
  exportSectionsToJSON,
  getLinkedSectionEditor
};
const DocumentSection = Node$1.create({
  name: "documentSection",
  group: "block",
  content: "block*",
  atom: true,
  isolating: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: "sd-document-section-block",
        "aria-label": "Structured content block"
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: "div.sd-document-section-block",
        priority: 60
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["div", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      id: {},
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      },
      title: {},
      description: {},
      sectionType: {},
      isLocked: { default: false }
    };
  },
  addNodeView() {
    return ({ node, editor, getPos, decorations }) => {
      return new DocumentSectionView(node, getPos, decorations, editor);
    };
  },
  // @ts-expect-error - Command signatures will be fixed in TS migration
  addCommands() {
    return {
      /**
       * Create a lockable content section
       * @category Command
       * @param {SectionCreate} [options={}] - Section configuration
       * @example
       * editor.commands.createDocumentSection({
       *   id: 1,
       *   title: 'Terms & Conditions',
       *   isLocked: true,
       *   html: '<p>Legal content...</p>'
       * })
       */
      createDocumentSection: (options = {}) => ({ tr, state, dispatch, editor }) => {
        const { selection } = state;
        let { from: from3, to } = selection;
        let content = selection.content().content;
        const { html: optionsHTML, json: optionsJSON } = options;
        if (optionsHTML) {
          const html = superEditor_converter.htmlHandler(optionsHTML, this.editor);
          const doc2 = superEditor_converter.DOMParser.fromSchema(this.editor.schema).parse(html);
          content = doc2.content;
        }
        if (optionsJSON) {
          content = this.editor.schema.nodeFromJSON(optionsJSON);
        }
        if (!content?.content?.length) {
          content = this.editor.schema.nodeFromJSON({ type: "paragraph", content: [] });
        }
        if (!options.id) {
          const allSections = SectionHelpers.getAllSections(editor);
          options.id = allSections.length + 1;
        }
        if (!options.title) {
          options.title = "Document section";
        }
        const node = this.type.createAndFill(options, content);
        if (!node) return false;
        const isAlreadyInSdtBlock = superEditor_converter.findParentNode((node2) => node2.type.name === "documentSection")(selection);
        if (isAlreadyInSdtBlock && isAlreadyInSdtBlock.node) {
          const insertPos2 = isAlreadyInSdtBlock.pos + isAlreadyInSdtBlock.node.nodeSize;
          from3 = insertPos2;
          to = insertPos2;
        }
        tr.replaceRangeWith(from3, to, node);
        const nodeEnd = from3 + node.nodeSize;
        let shouldInsertParagraph = true;
        let insertPos = nodeEnd;
        if (nodeEnd >= tr.doc.content.size) {
          insertPos = tr.doc.content.size;
          if (insertPos > 0) {
            const $endPos = tr.doc.resolve(insertPos);
            if ($endPos.nodeBefore && $endPos.nodeBefore.type.name === "paragraph") {
              shouldInsertParagraph = false;
            }
          }
        }
        if (shouldInsertParagraph) {
          const emptyParagraph = tr.doc.type.schema.nodes.paragraph.create();
          tr.insert(insertPos, emptyParagraph);
        }
        if (dispatch) {
          tr.setMeta("documentSection", { action: "create" });
          dispatch(tr);
          setTimeout(() => {
            try {
              const currentState = editor.state;
              const docSize = currentState.doc.content.size;
              let targetPos = from3 + node.nodeSize;
              if (shouldInsertParagraph) {
                targetPos += 1;
              }
              targetPos = Math.min(targetPos, docSize);
              if (targetPos < docSize && targetPos > 0) {
                const newSelection = superEditor_converter.Selection.near(currentState.doc.resolve(targetPos));
                const newTr = currentState.tr.setSelection(newSelection);
                editor.view.dispatch(newTr);
              }
            } catch (e) {
              console.warn("Could not set delayed selection:", e);
            }
          }, 0);
        }
        return true;
      },
      /**
       * Remove section wrapper at cursor, preserving its content
       * @category Command
       * @example
       * editor.commands.removeSectionAtSelection()
       * @note Content stays in document, only section wrapper is removed
       */
      removeSectionAtSelection: () => ({ tr, dispatch }) => {
        const sdtNode = superEditor_converter.findParentNode((node2) => node2.type.name === "documentSection")(tr.selection);
        if (!sdtNode) return false;
        const { node, pos } = sdtNode;
        const nodeStart = pos;
        const nodeEnd = nodeStart + node.nodeSize;
        const contentToPreserve = node.content;
        tr.delete(nodeStart, nodeEnd);
        if (contentToPreserve.size > 0) {
          tr.insert(nodeStart, contentToPreserve);
        }
        const newPos = Math.min(nodeStart, tr.doc.content.size);
        tr.setSelection(superEditor_converter.Selection.near(tr.doc.resolve(newPos)));
        if (dispatch) {
          tr.setMeta("documentSection", { action: "delete" });
          dispatch(tr);
        }
        return true;
      },
      /**
       * Delete section and all its content
       * @category Command
       * @param {number} id - Section to delete
       * @example
       * editor.commands.removeSectionById(123)
       */
      removeSectionById: (id) => ({ tr, dispatch }) => {
        const sections = SectionHelpers.getAllSections(this.editor);
        const sectionToRemove = sections.find(({ node: node2 }) => node2.attrs.id === id);
        if (!sectionToRemove) return false;
        const { pos, node } = sectionToRemove;
        const nodeStart = pos;
        const nodeEnd = nodeStart + node.nodeSize;
        tr.delete(nodeStart, nodeEnd);
        if (dispatch) {
          tr.setMeta("documentSection", { action: "delete", id });
          dispatch(tr);
        }
        return true;
      },
      /**
       * Lock section against edits
       * @category Command
       * @param {number} id - Section to lock
       * @example
       * editor.commands.lockSectionById(123)
       */
      lockSectionById: (id) => ({ tr, dispatch }) => {
        const sections = SectionHelpers.getAllSections(this.editor);
        const sectionToLock = sections.find(({ node }) => node.attrs.id === id);
        if (!sectionToLock) return false;
        tr.setNodeMarkup(sectionToLock.pos, null, { ...sectionToLock.node.attrs, isLocked: true });
        if (dispatch) {
          tr.setMeta("documentSection", { action: "lock", id });
          dispatch(tr);
        }
        return true;
      },
      /**
       * Modify section attributes or content
       * @category Command
       * @param {SectionUpdate} options - Changes to apply
       * @example
       * editor.commands.updateSectionById({ id: 123, attrs: { isLocked: false } })
       * editor.commands.updateSectionById({ id: 123, html: '<p>New content</p>' })
       * editor.commands.updateSectionById({
       *   id: 123,
       *   html: '<p>Updated</p>',
       *   attrs: { title: 'New Title' }
       * })
       */
      updateSectionById: ({ id, html, json, attrs }) => ({ tr, dispatch, editor }) => {
        const sections = SectionHelpers.getAllSections(editor || this.editor);
        const sectionToUpdate = sections.find(({ node: node2 }) => node2.attrs.id === id);
        if (!sectionToUpdate) return false;
        const { pos, node } = sectionToUpdate;
        let newContent = null;
        if (html) {
          const htmlDoc = superEditor_converter.htmlHandler(html, editor || this.editor);
          const doc2 = superEditor_converter.DOMParser.fromSchema((editor || this.editor).schema).parse(htmlDoc);
          newContent = doc2.content;
        }
        if (json) {
          newContent = (editor || this.editor).schema.nodeFromJSON(json);
        }
        if (!newContent) {
          newContent = node.content;
        }
        const updatedNode = node.type.create({ ...node.attrs, ...attrs }, newContent, node.marks);
        tr.replaceWith(pos, pos + node.nodeSize, updatedNode);
        if (dispatch) {
          tr.setMeta("documentSection", { action: "update", id, attrs });
          dispatch(tr);
        }
        return true;
      }
    };
  },
  addHelpers() {
    return {
      ...SectionHelpers
    };
  }
});
const DocumentPartObject = Node$1.create({
  name: "documentPartObject",
  group: "block",
  content: "block*",
  isolating: true,
  excludeFromSummaryJSON: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: "sd-document-part-object-block",
        "aria-label": "Structured document part block"
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: "div.sd-document-part-object-block",
        priority: 60
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["div", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      },
      id: {},
      docPartGallery: {},
      docPartUnique: {
        default: true
      }
    };
  }
});
const Document = Node$1.create({
  name: "doc",
  topNode: true,
  content: "block+",
  parseDOM() {
    return [{ tag: "doc" }];
  },
  renderDOM() {
    return ["doc", 0];
  },
  addAttributes() {
    return {
      attributes: {
        rendered: false,
        "aria-label": "Document node"
      },
      bodySectPr: {
        rendered: false,
        default: null
        /**
         * Body-level section properties (raw w:sectPr JSON) extracted from DOCX.
         * Used by the layout engine to compute the final section range (end-tagged semantics),
         * ensuring that the last sections page size/orientation/margins are applied correctly.
         */
      }
    };
  },
  // @ts-expect-error - Command signatures will be fixed in TS migration
  addCommands() {
    return {
      /**
       * Get document statistics
       * @category Command
       * @example
       * // Get word and character count
       * const stats = editor.commands.getDocumentStats()
       * console.log(`${stats.words} words, ${stats.characters} characters`)
       * @note Returns word count, character count, and paragraph count
       */
      getDocumentStats: () => ({ editor }) => {
        const text = editor.getText();
        const words = text.split(/\s+/).filter((word) => word.length > 0).length;
        const characters = text.length;
        const paragraphs = editor.state.doc.content.childCount;
        return {
          words,
          characters,
          paragraphs
        };
      },
      /**
       * Clear entire document
       * @category Command
       * @example
       * editor.commands.clearDocument()
       * @note Replaces all content with an empty paragraph
       */
      clearDocument: () => ({ commands: commands2 }) => {
        return commands2.setContent("<p></p>");
      },
      /**
       * Set section page margins (top/right/bottom/left) for the section at the current selection.
       */
      setSectionPageMarginsAtSelection
    };
  }
});
const Text = Node$1.create({
  name: "text",
  group: "inline",
  inline: true,
  addOptions() {
    return {};
  }
});
const cleanupEmptyRunsPlugin = new superEditor_converter.Plugin({
  appendTransaction(trs, oldState, newState) {
    if (!trs.some((tr2) => tr2.docChanged)) return null;
    const { run, paragraph } = newState.schema.nodes;
    if (!run) return null;
    const ranges = [];
    trs.forEach((tr2) => {
      tr2.mapping.maps.forEach((map3) => {
        map3.forEach((oldStart, oldEnd, newStart, newEnd) => {
          if (newStart !== oldStart || oldEnd !== newEnd) ranges.push({ from: newStart, to: newEnd });
        });
      });
    });
    if (!ranges.length) return null;
    ranges.sort((a, b2) => a.from - b2.from);
    const merged = [];
    for (const r2 of ranges) {
      const from3 = Math.max(0, r2.from - 1);
      const to = Math.min(newState.doc.content.size, r2.to + 1);
      const last = merged[merged.length - 1];
      if (last && from3 <= last.to) last.to = Math.max(last.to, to);
      else merged.push({ from: from3, to });
    }
    const toDelete = [];
    merged.forEach(({ from: from3, to }) => {
      newState.doc.nodesBetween(from3, to, (node, pos, parent) => {
        if (node.type === run && node.content.size === 0 && parent?.type === paragraph) {
          toDelete.push({ from: pos, to: pos + node.nodeSize });
        }
      });
    });
    if (!toDelete.length) return null;
    const tr = newState.tr;
    toDelete.sort((a, b2) => b2.from - a.from).forEach(({ from: from3, to }) => tr.deleteRange(from3, to));
    return tr.docChanged ? tr : null;
  }
});
const mergeRanges$2 = (ranges, docSize) => {
  if (!ranges.length) return [];
  const sorted = ranges.map(({ from: from3, to }) => ({
    from: Math.max(0, from3),
    to: Math.min(docSize, to)
  })).filter(({ from: from3, to }) => from3 < to).sort((a, b2) => a.from - b2.from);
  const merged = [];
  for (const range of sorted) {
    const last = merged[merged.length - 1];
    if (last && range.from <= last.to) {
      last.to = Math.max(last.to, range.to);
    } else {
      merged.push({ ...range });
    }
  }
  return merged;
};
const collectChangedRanges$1 = (trs, docSize) => {
  const ranges = [];
  trs.forEach((tr) => {
    if (!tr.docChanged) return;
    tr.mapping.maps.forEach((map3) => {
      map3.forEach((oldStart, oldEnd, newStart, newEnd) => {
        if (newStart !== oldStart || oldEnd !== newEnd) {
          ranges.push({ from: newStart, to: newEnd });
        }
      });
    });
  });
  return mergeRanges$2(ranges, docSize);
};
const mapRangesThroughTransactions = (ranges, transactions, docSize) => {
  let mapped = ranges;
  transactions.forEach((tr) => {
    mapped = mapped.map(({ from: from3, to }) => {
      const mappedFrom = tr.mapping.map(from3, -1);
      const mappedTo = tr.mapping.map(to, 1);
      if (mappedFrom >= mappedTo) return null;
      return { from: mappedFrom, to: mappedTo };
    }).filter(Boolean);
  });
  return mergeRanges$2(mapped, docSize);
};
const getParagraphAtPos = (doc2, pos) => {
  try {
    const $pos = doc2.resolve(pos);
    for (let depth = $pos.depth; depth >= 0; depth--) {
      const node = $pos.node(depth);
      if (node.type.name === "paragraph") {
        return node;
      }
    }
  } catch (_e) {
  }
  return null;
};
const resolveRunPropertiesFromParagraphStyle = (paragraphNode, editor) => {
  if (!paragraphNode || !editor?.converter) return { runProperties: {}, markDefs: [] };
  const styleId = paragraphNode.attrs?.paragraphProperties?.styleId;
  if (!styleId) return { runProperties: {}, markDefs: [] };
  try {
    const params2 = {
      translatedNumbering: editor.converter.translatedNumbering,
      translatedLinkedStyles: editor.converter.translatedLinkedStyles
    };
    const resolvedPpr = { styleId };
    const runProperties = superEditor_converter.resolveRunProperties(params2, {}, resolvedPpr, null, false, false);
    const markDefs = superEditor_converter.encodeMarksFromRPr(runProperties, editor.converter.convertedXml);
    return { runProperties, markDefs: Array.isArray(markDefs) ? markDefs : [] };
  } catch (_e) {
    return { runProperties: {}, markDefs: [] };
  }
};
const createMarksFromDefs = (schema, markDefs = []) => markDefs.map((def) => {
  const markType = schema.marks[def.type];
  return markType ? markType.create(def.attrs) : null;
}).filter(Boolean);
const normalizeSelectionIntoRun = (tr, runType) => {
  const selection = tr.selection;
  if (!(selection instanceof superEditor_converter.TextSelection)) return;
  if (selection.from !== selection.to) return;
  const $pos = tr.doc.resolve(selection.from);
  if ($pos.parent.type === runType) return;
  const nodeAfter = $pos.nodeAfter;
  if (nodeAfter?.type === runType && nodeAfter.content.size > 0) {
    const nextPos = selection.from + 1;
    if (nextPos <= tr.doc.content.size) {
      tr.setSelection(superEditor_converter.TextSelection.create(tr.doc, nextPos));
    }
    return;
  }
  const nodeBefore = $pos.nodeBefore;
  if (nodeBefore?.type === runType && nodeBefore.content.size > 0) {
    const prevPos = selection.from - 1;
    if (prevPos >= 0) {
      tr.setSelection(superEditor_converter.TextSelection.create(tr.doc, prevPos));
    }
  }
};
const buildWrapTransaction = (state, ranges, runType, editor, markDefsFromMeta = []) => {
  if (!ranges.length) return null;
  const replacements = [];
  const metaStyleMarks = createMarksFromDefs(state.schema, markDefsFromMeta);
  ranges.forEach(({ from: from3, to }) => {
    state.doc.nodesBetween(from3, to, (node, pos, parent, index2) => {
      if (!node.isText || !parent || parent.type === runType) return;
      const match = parent.contentMatchAt ? parent.contentMatchAt(index2) : null;
      if (match && !match.matchType(runType)) return;
      if (!match && !parent.type.contentMatch.matchType(runType)) return;
      let runProperties = superEditor_converter.decodeRPrFromMarks(node.marks);
      if ((!node.marks || node.marks.length === 0) && editor?.converter) {
        const paragraphNode = getParagraphAtPos(state.doc, pos);
        const { runProperties: styleRunProps, markDefs: styleMarkDefs } = resolveRunPropertiesFromParagraphStyle(
          paragraphNode,
          editor
        );
        if (Object.keys(styleRunProps).length > 0) {
          runProperties = styleRunProps;
          const markDefs = metaStyleMarks.length ? markDefsFromMeta : styleMarkDefs;
          const styleMarks = metaStyleMarks.length ? metaStyleMarks : createMarksFromDefs(state.schema, markDefs);
          if (styleMarks.length && typeof state.schema.text === "function") {
            const textNode = state.schema.text(node.text || "", styleMarks);
            if (textNode) {
              node = textNode;
            }
          }
        }
      }
      const runNode = runType.create({ runProperties }, node);
      replacements.push({ from: pos, to: pos + node.nodeSize, runNode });
    });
  });
  if (!replacements.length) return null;
  const tr = state.tr;
  replacements.sort((a, b2) => b2.from - a.from).forEach(({ from: from3, to, runNode }) => tr.replaceWith(from3, to, runNode));
  normalizeSelectionIntoRun(tr, runType);
  return tr.docChanged ? tr : null;
};
const wrapTextInRunsPlugin = (editor) => {
  let view = null;
  let pendingRanges = [];
  let lastStyleMarksMeta = [];
  const flush = () => {
    if (!view) return;
    const runType = view.state.schema.nodes.run;
    if (!runType) {
      pendingRanges = [];
      return;
    }
    const tr = buildWrapTransaction(view.state, pendingRanges, runType, editor, lastStyleMarksMeta);
    pendingRanges = [];
    if (tr) {
      view.dispatch(tr);
    }
  };
  const onCompositionEnd = () => {
    if (typeof globalThis === "undefined") return;
    globalThis.queueMicrotask(flush);
  };
  return new superEditor_converter.Plugin({
    view(editorView) {
      view = editorView;
      editorView.dom.addEventListener("compositionend", onCompositionEnd);
      return {
        destroy() {
          editorView.dom.removeEventListener("compositionend", onCompositionEnd);
          view = null;
          pendingRanges = [];
          lastStyleMarksMeta = [];
        }
      };
    },
    appendTransaction(transactions, _oldState, newState) {
      const docSize = newState.doc.content.size;
      const runType = newState.schema.nodes.run;
      if (!runType) return null;
      pendingRanges = mapRangesThroughTransactions(pendingRanges, transactions, docSize);
      const changedRanges = collectChangedRanges$1(transactions, docSize);
      pendingRanges = mergeRanges$2([...pendingRanges, ...changedRanges], docSize);
      if (view?.composing) {
        return null;
      }
      const latestStyleMarksMeta = [...transactions].reverse().find((tr2) => tr2.getMeta && tr2.getMeta("sdStyleMarks"))?.getMeta("sdStyleMarks") || lastStyleMarksMeta;
      if (latestStyleMarksMeta && latestStyleMarksMeta.length) {
        lastStyleMarksMeta = latestStyleMarksMeta;
      }
      const tr = buildWrapTransaction(newState, pendingRanges, runType, editor, latestStyleMarksMeta);
      pendingRanges = [];
      return tr;
    }
  });
};
const splitRunsAfterMarkPlugin = new superEditor_converter.Plugin({
  appendTransaction(transactions, _old, newState) {
    const markRanges = [];
    let mappingToFinal = new superEditor_converter.Mapping();
    for (let ti = transactions.length - 1; ti >= 0; ti--) {
      const tr2 = transactions[ti];
      tr2.steps.forEach((step) => {
        if (!(step instanceof superEditor_converter.AddMarkStep || step instanceof superEditor_converter.RemoveMarkStep)) return;
        const fromAfterTr = tr2.mapping.map(step.from, 1);
        const toAfterTr = tr2.mapping.map(step.to, -1);
        markRanges.push({
          from: mappingToFinal.map(fromAfterTr, 1),
          to: mappingToFinal.map(toAfterTr, -1)
        });
      });
      const composed = new superEditor_converter.Mapping();
      composed.appendMapping(tr2.mapping);
      composed.appendMapping(mappingToFinal);
      mappingToFinal = composed;
    }
    if (!markRanges.length) return null;
    const runType = newState.schema.nodes["run"];
    if (!runType) return null;
    const runPositions = /* @__PURE__ */ new Set();
    const docSize = newState.doc.content.size;
    markRanges.forEach(({ from: from3, to }) => {
      if (from3 < 0 || to < 0 || from3 > docSize || to > docSize || from3 > to) {
        return;
      }
      newState.doc.nodesBetween(from3, to, (node, pos) => {
        if (node.type === runType) runPositions.add(pos);
      });
    });
    if (!runPositions.size) return null;
    const tr = newState.tr;
    const originalSelection = newState.selection;
    const isTextSelection2 = originalSelection instanceof superEditor_converter.TextSelection;
    let preservedAnchor = isTextSelection2 ? originalSelection.anchor : null;
    let preservedHead = isTextSelection2 ? originalSelection.head : null;
    const anchorAssoc = preservedAnchor != null && preservedHead != null && preservedAnchor <= preservedHead ? -1 : 1;
    const headAssoc = preservedAnchor != null && preservedHead != null && preservedHead >= preservedAnchor ? 1 : -1;
    const mapOffsetThroughReplacement = (startPos, replacement, offset2) => {
      let currentPos = startPos;
      let remaining = offset2;
      let mapped = null;
      replacement.forEach((node) => {
        if (mapped != null) return;
        const contentSize = node.content.size;
        if (remaining <= contentSize) {
          mapped = currentPos + 1 + remaining;
          return;
        }
        remaining -= contentSize;
        currentPos += node.nodeSize;
      });
      return mapped ?? currentPos;
    };
    Array.from(runPositions).sort((a, b2) => b2 - a).forEach((pos) => {
      const mappedPos = tr.mapping.map(pos);
      const runNode = tr.doc.nodeAt(mappedPos);
      if (!runNode) return;
      const groups = [];
      let current = [];
      let currentMarks = null;
      runNode.forEach((child) => {
        if (child.isText) {
          if (currentMarks && superEditor_converter.Mark.sameSet(currentMarks, child.marks)) {
            current.push(child);
          } else {
            if (current.length) groups.push(superEditor_converter.Fragment.from(current));
            current = [child];
            currentMarks = child.marks;
          }
        } else {
          if (current.length) groups.push(superEditor_converter.Fragment.from(current));
          groups.push(superEditor_converter.Fragment.from(child));
          current = [];
          currentMarks = null;
        }
      });
      if (current.length) groups.push(superEditor_converter.Fragment.from(current));
      if (groups.length <= 1) return;
      const replacement = superEditor_converter.Fragment.from(
        groups.map((content) => runType.create(runNode.attrs, content, runNode.marks))
      );
      tr.replaceWith(mappedPos, mappedPos + runNode.nodeSize, replacement);
      const stepMap = tr.mapping.maps[tr.mapping.maps.length - 1];
      const mapSelectionPos = (pos2, assoc) => {
        if (pos2 == null) return null;
        if (pos2 < mappedPos || pos2 > mappedPos + runNode.nodeSize) {
          return stepMap.map(pos2, assoc);
        }
        const offsetInRun = pos2 - (mappedPos + 1);
        return mapOffsetThroughReplacement(mappedPos, replacement, offsetInRun);
      };
      preservedAnchor = mapSelectionPos(preservedAnchor, anchorAssoc);
      preservedHead = mapSelectionPos(preservedHead, headAssoc);
    });
    if (tr.docChanged && originalSelection) {
      if (originalSelection instanceof superEditor_converter.TextSelection && preservedAnchor != null && preservedHead != null) {
        tr.setSelection(superEditor_converter.TextSelection.create(tr.doc, preservedAnchor, preservedHead));
      } else {
        tr.setSelection(originalSelection.map(tr.doc, tr.mapping));
      }
    }
    return tr.docChanged ? tr : null;
  }
});
const calculateInlineRunPropertiesPlugin = (editor) => new superEditor_converter.Plugin({
  appendTransaction(transactions, _oldState, newState) {
    const tr = newState.tr;
    if (!transactions.some((t) => t.docChanged)) return null;
    if (!transactions.some(
      (tr2) => tr2.steps.some((step) => step instanceof superEditor_converter.AddMarkStep || step instanceof superEditor_converter.RemoveMarkStep)
    )) {
      return null;
    }
    const runType = newState.schema.nodes.run;
    if (!runType) return null;
    const changedRanges = [];
    transactions.forEach((tr2) => {
      tr2.steps.forEach((step) => {
        const from3 = tr2.mapping.map(step.from, 1);
        const to = tr2.mapping.map(step.to, -1);
        changedRanges.push({ from: from3, to });
      });
    });
    const runPositions = /* @__PURE__ */ new Set();
    mergeRanges$1(changedRanges, newState.doc.content.size).forEach(({ from: from3, to }) => {
      newState.doc.nodesBetween(from3, to, (node, pos) => {
        if (node.type === runType) runPositions.add(pos);
      });
    });
    if (!runPositions.size) return null;
    runPositions.forEach((pos) => {
      const runNode = tr.doc.nodeAt(pos);
      if (!runNode) return;
      const $pos = tr.doc.resolve(pos);
      let paragraphNode = null;
      for (let depth = $pos.depth; depth >= 0; depth--) {
        const node = $pos.node(depth);
        if (node.type.name === "paragraph") {
          paragraphNode = node;
          break;
        }
      }
      if (!paragraphNode) return;
      const marks = getMarksFromRun(runNode);
      const runPropertiesFromMarks = superEditor_converter.decodeRPrFromMarks(marks);
      const paragraphProperties = superEditor_converter.getResolvedParagraphProperties(paragraphNode) || superEditor_converter.calculateResolvedParagraphProperties(editor, paragraphNode, $pos);
      const runPropertiesFromStyles = superEditor_converter.resolveRunProperties(
        {
          translatedNumbering: editor.converter?.translatedNumbering ?? {},
          translatedLinkedStyles: editor.converter?.translatedLinkedStyles ?? {}
        },
        {},
        paragraphProperties,
        false,
        Boolean(paragraphNode.attrs.paragraphProperties?.numberingProperties)
      );
      const inlineRunProperties = getInlineRunProperties(runPropertiesFromMarks, runPropertiesFromStyles);
      const runProperties = Object.keys(inlineRunProperties).length ? inlineRunProperties : null;
      if (JSON.stringify(runProperties) === JSON.stringify(runNode.attrs.runProperties)) return;
      tr.setNodeMarkup(pos, runNode.type, { ...runNode.attrs, runProperties }, runNode.marks);
    });
    return tr.docChanged ? tr : null;
  }
});
function getMarksFromRun(runNode) {
  let marks = [];
  runNode.forEach((child) => {
    if (!marks.length && child.isText) {
      marks = child.marks;
    }
  });
  return marks;
}
function getInlineRunProperties(runPropertiesFromMarks, runPropertiesFromStyles) {
  const inlineRunProperties = {};
  for (const key2 in runPropertiesFromMarks) {
    const valueFromMarks = runPropertiesFromMarks[key2];
    const valueFromStyles = runPropertiesFromStyles[key2];
    if (JSON.stringify(valueFromMarks) !== JSON.stringify(valueFromStyles)) {
      inlineRunProperties[key2] = valueFromMarks;
    }
  }
  return inlineRunProperties;
}
function mergeRanges$1(ranges, docSize) {
  if (!ranges.length) return [];
  const sorted = ranges.map(({ from: from3, to }) => ({
    from: Math.max(0, from3),
    to: Math.min(docSize, to)
  })).filter(({ from: from3, to }) => from3 < to).sort((a, b2) => a.from - b2.from);
  const merged = [];
  for (const range of sorted) {
    const last = merged[merged.length - 1];
    if (last && range.from <= last.to) {
      last.to = Math.max(last.to, range.to);
    } else {
      merged.push({ ...range });
    }
  }
  return merged;
}
const Run = OxmlNode.create({
  name: "run",
  oXmlName: "w:r",
  group: "inline",
  inline: true,
  content: "inline*",
  selectable: false,
  childToAttributes: ["runProperties"],
  addOptions() {
    return {
      htmlAttributes: {
        "data-run": "1"
      }
    };
  },
  addAttributes() {
    return {
      runProperties: {
        default: null,
        rendered: false,
        keepOnSplit: true
      },
      rsidR: {
        default: null,
        rendered: false,
        keepOnSplit: true
      },
      rsidRPr: {
        default: null,
        rendered: false,
        keepOnSplit: true
      },
      rsidDel: {
        default: null,
        rendered: false,
        keepOnSplit: true
      }
    };
  },
  // @ts-expect-error - Command signatures will be fixed in TS migration
  addCommands() {
    return {
      splitRunToParagraph,
      splitRunAtCursor
    };
  },
  parseDOM() {
    return [{ tag: "span[data-run]" }];
  },
  renderDOM({ htmlAttributes }) {
    const base2 = Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes);
    return ["span", base2, 0];
  },
  addPmPlugins() {
    return [
      wrapTextInRunsPlugin(this.editor),
      splitRunsAfterMarkPlugin,
      calculateInlineRunPropertiesPlugin(this.editor),
      cleanupEmptyRunsPlugin
    ];
  }
});
const restartNumbering = ({ editor, tr, state, dispatch }) => {
  const { node: paragraph, pos } = superEditor_converter.findParentNode(superEditor_converter.isList)(state.selection) || {};
  if (!paragraph) return false;
  const allParagraphs = [{ node: paragraph, pos }];
  const startPos = pos + paragraph.nodeSize;
  const myNumId = superEditor_converter.getResolvedParagraphProperties(paragraph).numberingProperties.numId;
  let stop = false;
  state.doc.nodesBetween(startPos, state.doc.content.size, (node, nodePos) => {
    if (node.type.name === "paragraph") {
      const paraProps = superEditor_converter.getResolvedParagraphProperties(node);
      if (superEditor_converter.isList(node) && paraProps.numberingProperties?.numId === myNumId) {
        allParagraphs.push({ node, pos: nodePos });
      } else {
        stop = true;
      }
      return false;
    }
    return !stop;
  });
  const { numberingType } = paragraph.attrs.listRendering || {};
  const listType = numberingType === "bullet" ? "bulletList" : "orderedList";
  const numId = superEditor_converter.ListHelpers.getNewListId(editor);
  superEditor_converter.ListHelpers.generateNewListDefinition({ numId: Number(numId), listType, editor });
  allParagraphs.forEach(({ node, pos: pos2 }) => {
    const paragraphProps = superEditor_converter.getResolvedParagraphProperties(node);
    superEditor_converter.updateNumberingProperties(
      {
        ...paragraphProps.numberingProperties || {},
        numId: Number(numId)
      },
      node,
      pos2,
      editor,
      tr
    );
  });
  if (dispatch) dispatch(tr);
  return true;
};
const defaultTabDistance = 48;
const defaultLineLength = 816;
function calculateTabStyle(nodeSize2, view, pos, blockParent2, paragraphContext, coordCache = null, domPosCache = null) {
  let extraStyles = "";
  try {
    const { tabStops, flattened, positionMap, startPos } = paragraphContext;
    if (paragraphContext.indentWidth === void 0) {
      paragraphContext.indentWidth = getIndentWidth(view, startPos, paragraphContext.indent, coordCache, domPosCache);
    }
    if (paragraphContext.tabHeight === void 0) {
      paragraphContext.tabHeight = calcTabHeight(blockParent2);
    }
    if (paragraphContext.paragraphWidth === void 0) {
      paragraphContext.paragraphWidth = getBlockNodeWidth(view, startPos);
    }
    const indentWidth = paragraphContext.indentWidth;
    const hanging = twipsToPixels(Number(paragraphContext.indent.hanging) || 0);
    if (hanging > 0) {
      tabStops.unshift({ val: "start", pos: indentWidth + hanging });
    }
    const accumulatedTabWidth = paragraphContext.accumulatedTabWidth || 0;
    const currentWidth = indentWidth + measureRangeWidth(view, startPos + 1, pos, coordCache, domPosCache) + accumulatedTabWidth;
    let tabWidth;
    if (tabStops.length) {
      const tabStop = tabStops.find((stop) => stop.pos > currentWidth && stop.val !== "clear");
      if (tabStop) {
        tabWidth = Math.min(tabStop.pos, paragraphContext.paragraphWidth) - currentWidth;
        let val = tabStop.val;
        const aliases = { left: "start", right: "end" };
        if (aliases[val]) val = aliases[val];
        if (val === "center" || val === "end" || val === "right") {
          const entryIndex = positionMap.get(pos);
          if (entryIndex === void 0) return;
          const nextTabIndex = findNextTabIndex(flattened, entryIndex + 1);
          const segmentStartPos = pos + nodeSize2;
          const segmentEndPos = nextTabIndex === -1 ? startPos + paragraphContext.paragraph.nodeSize - 1 : flattened[nextTabIndex].pos;
          const segmentWidth = measureRangeWidth(view, segmentStartPos, segmentEndPos, coordCache, domPosCache);
          tabWidth -= val === "center" ? segmentWidth / 2 : segmentWidth;
        } else if (val === "decimal" || val === "num") {
          const entryIndex = positionMap.get(pos);
          if (entryIndex === void 0) return;
          const breakChar = tabStop.decimalChar || ".";
          const decimalPos = findDecimalBreakPos(flattened, entryIndex + 1, breakChar);
          const integralWidth = decimalPos ? measureRangeWidth(view, pos + nodeSize2, decimalPos, coordCache, domPosCache) : measureRangeWidth(
            view,
            pos + nodeSize2,
            startPos + paragraphContext.paragraph.nodeSize - 1,
            coordCache,
            domPosCache
          );
          tabWidth -= integralWidth;
        }
        if (tabStop.leader) {
          const leaderStyles2 = {
            dot: "border-bottom: 1px dotted black;",
            heavy: "border-bottom: 2px solid black;",
            hyphen: "border-bottom: 1px solid black;",
            middleDot: "border-bottom: 1px dotted black; margin-bottom: 2px;",
            underscore: "border-bottom: 1px solid black;"
          };
          extraStyles += leaderStyles2[tabStop.leader] || "";
        }
      }
    }
    if (!tabWidth || tabWidth < 1) {
      tabWidth = defaultTabDistance - currentWidth % defaultLineLength % defaultTabDistance;
      if (tabWidth === 0) tabWidth = defaultTabDistance;
    }
    const tabHeight = paragraphContext.tabHeight;
    paragraphContext.accumulatedTabWidth = accumulatedTabWidth + tabWidth;
    return `width: ${tabWidth}px; height: ${tabHeight}; ${extraStyles}`;
  } catch {
    return null;
  }
}
function findParagraphContext($pos, cache2, helpers2) {
  for (let depth = $pos.depth; depth >= 0; depth--) {
    const node = $pos.node(depth);
    if (node?.type?.name === "paragraph") {
      const startPos = $pos.start(depth);
      if (!cache2.has(startPos)) {
        const paragraphContext = extractParagraphContext(node, startPos, helpers2, depth);
        cache2.set(startPos, paragraphContext);
      }
      return cache2.get(startPos);
    }
  }
  return null;
}
function extractParagraphContext(node, startPos, helpers2, depth = 0) {
  const paragraphProperties = superEditor_converter.getResolvedParagraphProperties(node) ?? node.attrs?.paragraphProperties ?? {};
  const alignmentAliases = { left: "start", right: "end" };
  let tabStops = [];
  if (Array.isArray(paragraphProperties.tabStops)) {
    tabStops = paragraphProperties.tabStops.map((stop) => {
      const ref = stop?.tab;
      if (!ref && stop?.pos != null) {
        return {
          ...stop,
          pos: twipsToPixels(Number(stop.pos) || 0)
        };
      }
      if (!ref) return stop || null;
      const rawType = ref.tabType || "start";
      const mappedVal = alignmentAliases[rawType] || rawType;
      return {
        val: mappedVal,
        pos: twipsToPixels(Number(ref.pos) || 0),
        leader: ref.leader
      };
    }).filter(Boolean);
  }
  const { entries, positionMap } = flattenParagraph(node, startPos);
  return {
    paragraph: node,
    paragraphDepth: depth,
    startPos,
    indent: paragraphProperties.indent || {},
    tabStops,
    flattened: entries,
    positionMap,
    // Store position map for O(1) lookups
    accumulatedTabWidth: 0
  };
}
function flattenParagraph(paragraph, paragraphStartPos) {
  const entries = [];
  const positionMap = /* @__PURE__ */ new Map();
  const walk = (node, basePos) => {
    if (!node) return;
    if (node.type?.name === "run") {
      node.forEach((child, offset2) => {
        const childPos = basePos + offset2 + 1;
        walk(child, childPos);
      });
      return;
    }
    const pos = basePos - 1;
    const index2 = entries.length;
    entries.push({ node, pos });
    positionMap.set(pos, index2);
  };
  paragraph.forEach((child, offset2) => {
    const childPos = paragraphStartPos + offset2 + 1;
    walk(child, childPos);
  });
  return { entries, positionMap };
}
function findNextTabIndex(flattened, fromIndex) {
  for (let i = fromIndex; i < flattened.length; i++) {
    if (flattened[i]?.node?.type?.name === "tab") {
      return i;
    }
  }
  return -1;
}
function findDecimalBreakPos(flattened, startIndex, breakChar) {
  for (let i = startIndex; i < flattened.length; i++) {
    const entry = flattened[i];
    if (!entry) break;
    if (entry.node.type?.name === "tab") break;
    if (entry.node.type?.name === "text") {
      const index2 = entry.node.text?.indexOf(breakChar);
      if (index2 !== void 0 && index2 !== -1) {
        return entry.pos + index2 + 1;
      }
    }
  }
  return null;
}
function measureRangeWidth(view, from3, to, coordCache = null, domPosCache = null) {
  if (!Number.isFinite(from3) || !Number.isFinite(to) || to <= from3) return 0;
  try {
    const range = document.createRange();
    const fromRef = getCachedDomAtPos(view, from3, domPosCache);
    const toRef = getCachedDomAtPos(view, to, domPosCache);
    range.setStart(fromRef.node, fromRef.offset);
    range.setEnd(toRef.node, toRef.offset);
    const rect = range.getBoundingClientRect();
    range.detach?.();
    if (rect.width > 0) {
      return rect.width;
    }
  } catch {
  }
  const startLeft = getLeftCoord(view, from3, coordCache, domPosCache);
  const endLeft = getLeftCoord(view, to, coordCache, domPosCache);
  if (startLeft == null || endLeft == null) return 0;
  return Math.max(0, endLeft - startLeft);
}
function getIndentWidth(view, paragraphStartPos, indentAttrs = {}, coordCache = null, domPosCache = null) {
  const marginLeft = getLeftCoord(view, paragraphStartPos, coordCache, domPosCache);
  const lineLeft = getLeftCoord(view, paragraphStartPos + 1, coordCache, domPosCache);
  if (marginLeft != null && lineLeft != null) {
    const diff = lineLeft - marginLeft;
    if (!Number.isNaN(diff) && Math.abs(diff) > 0.5) {
      return diff;
    }
  }
  return calculateIndentFallback(indentAttrs);
}
function getBlockNodeWidth(view, blockStartPos) {
  const blockDom = view.nodeDOM(blockStartPos - 1);
  if (blockDom instanceof HTMLElement) {
    const styles = window.getComputedStyle(blockDom);
    const width = blockDom.clientWidth + parseFloat(styles.marginLeft || "0") + parseFloat(styles.marginRight || "0") + parseFloat(styles.borderLeftWidth || "0") + parseFloat(styles.borderRightWidth || "0") + parseFloat(styles.paddingLeft || "0") + parseFloat(styles.paddingRight || "0");
    return width;
  }
  return defaultLineLength;
}
function calculateIndentFallback(indentAttrs = {}) {
  if (!indentAttrs) return 0;
  const left2 = twipsToPixels(Number(indentAttrs.left) || 0);
  const firstLine = twipsToPixels(Number(indentAttrs.firstLine) || 0);
  const hanging = twipsToPixels(Number(indentAttrs.hanging) || 0);
  let textIndent = 0;
  if (firstLine && hanging) {
    textIndent = firstLine - hanging;
  } else if (firstLine) {
    textIndent = firstLine;
  } else if (hanging) {
    textIndent = -hanging;
  }
  if (textIndent) return left2 + textIndent;
  if (left2) return left2;
  return 0;
}
function getLeftCoord(view, pos, coordCache = null, domPosCache = null) {
  if (!Number.isFinite(pos)) return null;
  if (coordCache && coordCache.has(pos)) {
    return coordCache.get(pos);
  }
  let result = null;
  try {
    result = view.coordsAtPos(pos).left;
  } catch {
    try {
      const ref = getCachedDomAtPos(view, pos, domPosCache);
      const range = document.createRange();
      range.setStart(ref.node, ref.offset);
      range.setEnd(ref.node, ref.offset);
      const rect = range.getBoundingClientRect();
      range.detach?.();
      result = rect.left;
    } catch {
      result = null;
    }
  }
  if (coordCache) {
    coordCache.set(pos, result);
  }
  return result;
}
function getCachedDomAtPos(view, pos, domPosCache = null) {
  if (domPosCache && domPosCache.has(pos)) {
    return domPosCache.get(pos);
  }
  const result = view.domAtPos(pos);
  if (domPosCache) {
    domPosCache.set(pos, result);
  }
  return result;
}
function calcTabHeight(blockParent2) {
  const ptToPxRatio = 1.333;
  const defaultFontSize = 16;
  const defaultLineHeight = 1.1;
  const parentTextStyleMark = blockParent2.firstChild?.marks?.find((mark) => mark.type.name === "textStyle");
  const fontSize2 = parseInt(parentTextStyleMark?.attrs.fontSize) * ptToPxRatio || defaultFontSize;
  return `${fontSize2 * defaultLineHeight}px`;
}
const nodeViewMap = /* @__PURE__ */ new WeakMap();
class ParagraphNodeView {
  /**
   * @param {import('prosemirror-model').Node} node Current paragraph node.
   * @param {import('../../core/Editor').Editor} editor Editor instance providing schema/helpers.
   * @param {() => number} getPos Position getter provided by ProseMirror.
   * @param {import('prosemirror-view').Decoration[]} decorations Decorations applied to this node.
   * @param {Record<string, unknown>} extensionAttrs Extra attributes declared by the paragraph extension.
   */
  constructor(node, editor, getPos, decorations, extensionAttrs) {
    this.node = node;
    this.editor = editor;
    this.getPos = getPos;
    this.decorations = decorations;
    this.extensionAttrs = extensionAttrs;
    this._animationFrameRequest = null;
    this.surroundingContext = {};
    nodeViewMap.set(this.node, this);
    superEditor_converter.calculateResolvedParagraphProperties(this.editor, this.node, this.editor.state.doc.resolve(this.getPos()));
    this.dom = document.createElement("p");
    this.contentDOM = document.createElement("span");
    this.dom.appendChild(this.contentDOM);
    if (this.#checkIsList()) {
      this.#initList(node.attrs.listRendering);
      this.#scheduleAnimation(() => {
        if (!this.#checkIsList()) {
          return;
        }
        this.#updateListStyles();
      });
    }
    this.#updateHTMLAttributes();
    this.#updateDOMStyles();
  }
  /**
   * @param {import('prosemirror-model').Node} node
   * @param {import('prosemirror-view').Decoration[]} decorations
   * @param {import('prosemirror-view').Decoration[]} innerDecorations
   * @param {boolean} [forceUpdate=false]
   * @returns {boolean}
   */
  update(node, decorations, innerDecorations, forceUpdate = false) {
    if (nodeViewMap.get(this.node) === this) {
      nodeViewMap.delete(this.node);
    }
    const oldProps = superEditor_converter.getResolvedParagraphProperties(this.node);
    const oldAttrs = this.node.attrs;
    this.node = node;
    this.decorations = decorations;
    this.innerDecorations = innerDecorations;
    nodeViewMap.set(this.node, this);
    if (!forceUpdate && !this.#checkShouldUpdate(oldProps, oldAttrs, this.surroundingContext)) {
      return true;
    }
    superEditor_converter.calculateResolvedParagraphProperties(this.editor, this.node, this.editor.state.doc.resolve(this.getPos()));
    this.#updateHTMLAttributes();
    this.#updateDOMStyles(oldProps);
    if (!this.#checkIsList()) {
      this.#removeList();
      return true;
    }
    this.#initList(node.attrs.listRendering);
    this.#scheduleAnimation(() => {
      this.#initList(node.attrs.listRendering);
      this.#updateListStyles();
    });
    return true;
  }
  /**
   * Checks whether the node view should update based on changes to props, attrs, or surrounding context.
   * @param {Record<string, unknown>} oldProps
   * @param {Record<string, unknown>} oldAttrs
   * @param {Record<string, unknown>} oldSurroundingContext
   * @returns {boolean}
   */
  #checkShouldUpdate(oldProps, oldAttrs, oldSurroundingContext) {
    this.#resolveNeighborParagraphProperties();
    return JSON.stringify(oldAttrs) !== JSON.stringify(this.node.attrs) || JSON.stringify(oldProps) !== JSON.stringify(superEditor_converter.getResolvedParagraphProperties(this.node)) || JSON.stringify(oldSurroundingContext) !== JSON.stringify(this.surroundingContext);
  }
  /**
   * Updates the HTML attributes of the paragraph DOM element based on node attributes and properties.
   */
  #updateHTMLAttributes() {
    const htmlAttributes = Attribute.getAttributesToRender(this.node, this.extensionAttrs);
    htmlAttributes.style = htmlAttributes.style || "";
    for (const [key2, value] of Object.entries(htmlAttributes || {})) {
      if (value == null) {
        this.dom.removeAttribute(key2);
        continue;
      }
      this.dom.setAttribute(key2, value);
    }
    const paragraphProperties = superEditor_converter.getResolvedParagraphProperties(this.node);
    if (this.#checkIsList()) {
      this.dom.setAttribute("data-num-id", paragraphProperties.numberingProperties.numId);
      this.dom.setAttribute("data-level", paragraphProperties.numberingProperties.ilvl);
    } else {
      this.dom.removeAttribute("data-num-id");
      this.dom.removeAttribute("data-level");
    }
    if (paragraphProperties.framePr?.dropCap) {
      this.dom.classList.add("sd-editor-dropcap");
    } else {
      this.dom.classList.remove("sd-editor-dropcap");
    }
    if (paragraphProperties.styleId) {
      this.dom.setAttribute("styleid", paragraphProperties.styleId);
    }
  }
  /**
   * Updates the CSS styles of the paragraph DOM element based on resolved paragraph properties.
   * @param {Record<string, unknown> | null} oldParagraphProperties
   */
  #updateDOMStyles(oldParagraphProperties = null) {
    this.dom.style.cssText = "";
    const paragraphProperties = superEditor_converter.getResolvedParagraphProperties(this.node);
    this.#resolveNeighborParagraphProperties();
    const style2 = superEditor_converter.encodeCSSFromPPr(
      paragraphProperties,
      this.surroundingContext.hasPreviousParagraph,
      this.surroundingContext.nextParagraphProps
    );
    Object.entries(style2).forEach(([k2, v]) => {
      this.dom.style[k2] = v;
    });
    if (JSON.stringify(paragraphProperties.spacing) !== JSON.stringify(oldParagraphProperties?.spacing) || paragraphProperties.styleId !== oldParagraphProperties?.styleId || paragraphProperties.contextualSpacing !== oldParagraphProperties?.contextualSpacing) {
      const previousNodeView = this.surroundingContext.previousParagraph ? nodeViewMap.get(this.surroundingContext.previousParagraph) : null;
      if (previousNodeView) {
        try {
          previousNodeView.getPos();
        } catch {
          return;
        }
        previousNodeView.update(
          previousNodeView.node,
          previousNodeView.decorations,
          previousNodeView.innerDecorations,
          true
        );
      }
    }
  }
  /**
   * Resolves properties of neighboring paragraphs to determine surrounding context.
   */
  #resolveNeighborParagraphProperties() {
    const $pos = this.editor.state.doc.resolve(this.getPos());
    const parent = $pos.parent;
    const index2 = $pos.index();
    let hasPreviousParagraph = false;
    let previousParagraph = null;
    let nextParagraphProps = null;
    if (index2 > 0) {
      const previousNode = parent.child(index2 - 1);
      hasPreviousParagraph = previousNode.type.name === "paragraph" && !superEditor_converter.getResolvedParagraphProperties(previousNode)?.framePr?.dropCap;
      if (hasPreviousParagraph) {
        previousParagraph = previousNode;
      }
    }
    if (parent) {
      if (index2 < parent.childCount - 1) {
        const nextNode = parent.child(index2 + 1);
        if (nextNode.type.name === "paragraph") {
          nextParagraphProps = superEditor_converter.getResolvedParagraphProperties(nextNode);
        }
      }
    }
    this.surroundingContext = {
      hasPreviousParagraph,
      previousParagraph,
      nextParagraphProps
    };
  }
  /**
   * Updates the styles of the list marker and separator based on current node attributes.
   * @returns {boolean}
   */
  #updateListStyles() {
    let { suffix: suffix2, justification } = this.node.attrs.listRendering;
    suffix2 = suffix2 ?? "tab";
    this.#calculateMarkerStyle(justification);
    if (suffix2 === "tab") {
      const paragraphProperties = superEditor_converter.getResolvedParagraphProperties(this.node);
      this.#calculateTabSeparatorStyle(justification, paragraphProperties.indent);
    } else {
      this.separator.textContent = suffix2 === "space" ? "" : "";
    }
    return true;
  }
  /**
   * @param {MutationRecord} mutation
   */
  ignoreMutation(mutation) {
    if (this.marker && (mutation.target === this.marker || this.marker.contains(mutation.target))) {
      return true;
    }
    if (this.separator && (mutation.target === this.separator || this.separator.contains(mutation.target))) {
      return true;
    }
    if (mutation.type === "attributes" && mutation.target === this.dom && mutation.attributeName === "style") {
      return true;
    }
    if (mutation.type === "childList") {
      if (this.marker && Array.from(mutation.removedNodes).includes(this.marker)) {
        return true;
      }
      if (this.marker && Array.from(mutation.addedNodes).includes(this.marker)) {
        return true;
      }
      if (this.separator && Array.from(mutation.removedNodes).includes(this.separator)) {
        return true;
      }
      if (this.separator && Array.from(mutation.addedNodes).includes(this.separator)) {
        return true;
      }
    }
    return false;
  }
  /**
   * @param {{ markerText: string, suffix?: string }} listRendering
   */
  #initList(listRendering) {
    this.#createMarker(listRendering.markerText);
    this.#createSeparator(listRendering.suffix);
  }
  #checkIsList() {
    return superEditor_converter.isList(this.node);
  }
  /**
   * @param {string} markerText
   */
  #createMarker(markerText) {
    if (!this.marker) {
      this.marker = document.createElement("span");
      this.dom.insertBefore(this.marker, this.contentDOM);
    }
    this.marker.contentEditable = "false";
    this.marker.className = "list-marker";
    this.marker.textContent = markerText;
  }
  /**
   * @param {'tab' | 'space' | 'nothing'} [suffix]
   */
  #createSeparator(suffix2) {
    if (suffix2 === "tab" || suffix2 == null) {
      if (this.separator == null || this.separator.tagName?.toLowerCase() !== "span") {
        this.separator?.parentNode?.removeChild(this.separator);
        this.separator = document.createElement("span");
        this.marker.after(this.separator);
      }
      this.separator.className = "sd-editor-tab";
      this.separator.contentEditable = "false";
    } else if (suffix2 === "space") {
      if (this.separator == null || this.separator.nodeType !== Node.TEXT_NODE) {
        this.separator?.parentNode?.removeChild(this.separator);
        this.separator = document.createTextNode("");
        this.marker.after(this.separator);
      }
      this.separator.textContent = "";
    } else if (suffix2 === "nothing") {
      if (this.separator == null || this.separator.nodeType !== Node.TEXT_NODE) {
        this.separator?.parentNode?.removeChild(this.separator);
        this.separator = document.createTextNode("");
        this.marker.after(this.separator);
      }
      this.separator.textContent = "";
    }
  }
  /**
   * This is the logic behind the calculation:
   *
   * For left alignment:
   *   - The tab character extends to the next tab stop
   *
   * For right alignment:
   *   When: hanging is defined OR hanging is not defined and neither is firstLine
   *     - The tab character extends to the hanging position only and never goes beyond it.
   *
   *   When: firstLine is defined
   *       - The tab character extends to the next tab stop
   *
   * For center alignment:
   *   - The tab character extends to the next tab stop
   */
  /**
   * @param {'left' | 'right' | 'center'} justification
   * @param {{ hanging?: number, firstLine?: number } | null} indent
   */
  #calculateTabSeparatorStyle(justification, indent) {
    const markerWidth = this.marker.getBoundingClientRect().width;
    let tabStyle;
    let { paragraphContext, start: start2 } = this.#getParagraphContext();
    if (justification === "right") {
      if (indent?.hanging || !indent?.hanging && !indent?.firstLine) {
        const hanging = indent?.hanging ? helpers$1.twipsToPixels(indent.hanging) : 0;
        tabStyle = `width: ${hanging}px;`;
      } else {
        const tabNode = this.editor.schema.nodes.tab.create(null);
        tabStyle = calculateTabStyle(tabNode.nodeSize, this.editor.view, start2, this.node, paragraphContext);
      }
    } else if (justification === "center") {
      paragraphContext.accumulatedTabWidth = markerWidth / 2;
      const tabNode = this.editor.schema.nodes.tab.create(null);
      tabStyle = calculateTabStyle(tabNode.nodeSize, this.editor.view, start2, this.node, paragraphContext);
      tabStyle += `margin-left: ${markerWidth / 2}px;`;
    } else {
      paragraphContext.accumulatedTabWidth = markerWidth;
      const tabNode = this.editor.schema.nodes.tab.create(null);
      tabStyle = calculateTabStyle(tabNode.nodeSize, this.editor.view, start2, this.node, paragraphContext);
    }
    this.separator.style.cssText = tabStyle;
  }
  /**
   * This is the logic behind the calculation:
   *  For left alignment:
   *    - The marker text STARTS at the left indent
   *
   *  For right alignment:
   *    - The marker text ENDS at the left indent
   *
   * For center alignment:
   *   - The marker text is centered around the left indent (pulled back by half its width)
   *
   * The left/center/right alignment positioning uses the left indent (+ firstLine if present) as the anchor point.
   */
  /**
   * @param {'left' | 'right' | 'center'} justification
   */
  #calculateMarkerStyle(justification) {
    const paragraphProperties = superEditor_converter.getResolvedParagraphProperties(this.node);
    const runProperties = superEditor_converter.resolveRunProperties(
      {
        translatedNumbering: this.editor.converter.translatedNumbering,
        translatedLinkedStyles: this.editor.converter.translatedLinkedStyles
      },
      paragraphProperties.runProperties || {},
      paragraphProperties,
      true,
      Boolean(this.node.attrs.paragraphProperties.numberingProperties)
    );
    const style2 = superEditor_converter.encodeCSSFromRPr(runProperties, this.editor.converter.convertedXml);
    this.marker.style.cssText = Object.entries(style2).map(([k2, v]) => `${k2}: ${v};`).join(" ");
    let markerStyle = {
      position: "",
      left: "",
      bottom: ""
    };
    let domStyle = {
      position: ""
    };
    const calculateTop = () => {
      let top2 = "0";
      if (globalThis) {
        const computedStyle = globalThis.getComputedStyle(this.dom);
        const markerComputedStyle = globalThis.getComputedStyle(this.marker);
        const lineHeight2 = parseFloat(computedStyle.lineHeight);
        const markerLineHeight = parseFloat(markerComputedStyle.lineHeight);
        top2 = `${lineHeight2 - markerLineHeight}px`;
      }
      return top2;
    };
    const rect = this.marker.getBoundingClientRect();
    const markerWidth = rect.width;
    if (justification === "right") {
      markerStyle.position = "absolute";
      markerStyle.left = `${-markerWidth}px`;
      markerStyle.top = calculateTop();
      domStyle.position = "relative";
    } else if (justification === "center") {
      markerStyle.position = "absolute";
      markerStyle.left = `${-markerWidth / 2}px`;
      markerStyle.top = calculateTop();
      domStyle.position = "relative";
    }
    Object.entries(markerStyle).forEach(([k2, v]) => {
      this.marker.style[k2] = v;
    });
    Object.entries(domStyle).forEach(([k2, v]) => {
      this.dom.style[k2] = v;
    });
  }
  #removeList() {
    if (this.marker) {
      this.dom.removeChild(this.marker);
      this.marker = null;
    }
    if (this.separator) {
      this.dom.removeChild(this.separator);
      this.separator = null;
    }
    this.dom.style.position = "";
  }
  #getParagraphContext() {
    const $pos = this.editor.state.doc.resolve(this.getPos());
    const start2 = $pos.start($pos.depth + 1);
    const paragraphContext = extractParagraphContext(this.node, start2, this.editor.helpers);
    return { paragraphContext, start: start2 };
  }
  /**
   * @param {() => void} fn
   */
  #scheduleAnimation(fn2) {
    if (typeof globalThis === "undefined") {
      return;
    }
    this.#cancelScheduledAnimation();
    this._animationFrameRequest = globalThis.requestAnimationFrame(() => {
      fn2();
      this._animationFrameRequest = null;
    });
  }
  #cancelScheduledAnimation() {
    if (typeof globalThis === "undefined" || !this._animationFrameRequest) {
      return;
    }
    globalThis.cancelAnimationFrame(this._animationFrameRequest);
    this._animationFrameRequest = null;
  }
  destroy() {
    this.#cancelScheduledAnimation();
    if (nodeViewMap.get(this.node) === this) {
      nodeViewMap.delete(this.node);
    }
  }
}
function NumberingManager() {
  const manager = createNumberingManager();
  return {
    ...manager,
    _clearCache: manager.clearAllState
  };
}
function createNumberingPlugin(editor) {
  const numberingManager = NumberingManager();
  const applyStartSettingsFromDefinitions = (definitionsMap) => {
    Object.entries(definitionsMap || {}).forEach(([numId, levels]) => {
      Object.entries(levels || {}).forEach(([level, def]) => {
        const start2 = parseInt(def?.start) || 1;
        let restart = def?.restart;
        if (restart != null) {
          restart = parseInt(restart);
        }
        numberingManager.setStartSettings(numId, parseInt(level), start2, restart);
      });
    });
  };
  const refreshStartSettings = () => {
    const definitions = superEditor_converter.ListHelpers.getAllListDefinitions(editor);
    applyStartSettingsFromDefinitions(definitions);
  };
  refreshStartSettings();
  if (typeof editor?.on === "function") {
    editor.on("list-definitions-change", refreshStartSettings);
    if (typeof editor?.off === "function") {
      const cleanupListDefinitionListener = () => {
        editor.off("list-definitions-change", refreshStartSettings);
        editor.off?.("destroy", cleanupListDefinitionListener);
      };
      editor.on("destroy", cleanupListDefinitionListener);
    }
  }
  return new superEditor_converter.Plugin({
    name: "numberingPlugin",
    key: new superEditor_converter.PluginKey("numberingPlugin"),
    /**
     * Scan document changes and collect fresh numbering metadata for list
     * paragraphs. The incoming transactions are marked to avoid reprocessing.
     *
     * @param {import('prosemirror-state').Transaction[]} transactions
     * @param {import('prosemirror-state').EditorState} oldState
     * @param {import('prosemirror-state').EditorState} newState
     * @returns {import('prosemirror-state').Transaction | null}
     */
    appendTransaction(transactions, oldState, newState) {
      const isFromPlugin = transactions.some((tr2) => tr2.getMeta("orderedListSync"));
      const forcePluginPass = transactions.some((tr2) => tr2.getMeta("forcePluginPass"));
      if (isFromPlugin || !forcePluginPass && !transactions.some((tr2) => tr2.docChanged)) {
        return null;
      }
      const tr = newState.tr;
      tr.setMeta("orderedListSync", true);
      numberingManager.enableCache();
      newState.doc.descendants((node, pos) => {
        let resolvedProps = superEditor_converter.calculateResolvedParagraphProperties(editor, node, newState.doc.resolve(pos));
        if (node.type.name !== "paragraph" || !resolvedProps.numberingProperties) {
          return;
        }
        const { numId, ilvl: level = 0 } = resolvedProps.numberingProperties;
        const definitionDetails = superEditor_converter.ListHelpers.getListDefinitionDetails({ numId, level, editor });
        if (!definitionDetails || Object.keys(definitionDetails).length === 0) {
          tr.setNodeAttribute(pos, "listRendering", null);
          return;
        }
        let { lvlText, customFormat, listNumberingType, suffix: suffix2, justification, abstractId } = definitionDetails;
        let markerText = "";
        listNumberingType = listNumberingType || "decimal";
        const count = numberingManager.calculateCounter(numId, level, pos, abstractId);
        numberingManager.setCounter(numId, level, pos, count, abstractId);
        const path = numberingManager.calculatePath(numId, level, pos);
        if (listNumberingType !== "bullet") {
          markerText = superEditor_converter.generateOrderedListIndex({
            listLevel: path,
            lvlText,
            listNumberingType,
            customFormat
          });
        } else {
          markerText = superEditor_converter.docxNumberingHelpers.normalizeLvlTextChar(lvlText);
        }
        const newListRendering = {
          markerText,
          suffix: suffix2,
          justification,
          path,
          numberingType: listNumberingType
        };
        if (JSON.stringify(node.attrs.listRendering) !== JSON.stringify(newListRendering)) {
          tr.setNodeAttribute(pos, "listRendering", newListRendering);
        }
        return false;
      });
      numberingManager.disableCache();
      return tr.docChanged ? tr : null;
    }
  });
}
function createDropcapPlugin(editor) {
  const { view } = editor;
  const dropcapWidthCache = /* @__PURE__ */ new Map();
  const invalidateCacheForRange = (from3, to) => {
    for (const [pos] of dropcapWidthCache) {
      if (pos >= from3 && pos <= to) {
        dropcapWidthCache.delete(pos);
      }
    }
  };
  const getDropcapDecorations = (state, view2, widthCache) => {
    const decorations = [];
    state.doc.descendants((node, pos) => {
      if (hasDropcapParagraph(node, pos, state)) {
        const width = getDropcapWidth(view2, pos, widthCache);
        decorations.push(Decoration.inline(pos, pos + node.nodeSize, { style: `margin-left: -${width}px;` }));
        return false;
      }
      return node.type.name !== "paragraph";
    });
    return decorations;
  };
  function getDropcapWidth(view2, pos, widthCache) {
    if (widthCache.has(pos)) {
      return widthCache.get(pos);
    }
    const domNode = view2.nodeDOM(pos);
    if (domNode) {
      const range = document.createRange();
      range.selectNodeContents(domNode);
      const width = range.getBoundingClientRect().width;
      widthCache.set(pos, width);
      return width;
    }
    return 0;
  }
  const hasDropcapParagraph = (node, pos, state) => {
    if (node.type.name !== "paragraph") return false;
    const paragraphProps = superEditor_converter.calculateResolvedParagraphProperties(editor, node, state.doc.resolve(pos));
    return paragraphProps.framePr?.dropCap === "margin";
  };
  return new superEditor_converter.Plugin({
    name: "dropcapPlugin",
    key: new superEditor_converter.PluginKey("dropcapPlugin"),
    state: {
      init(_2, state) {
        const decorations = getDropcapDecorations(state, view, dropcapWidthCache);
        return DecorationSet.create(state.doc, decorations);
      },
      apply(tr, oldDecorationSet, oldState, newState) {
        if (!tr.docChanged) return oldDecorationSet;
        let hasDropcaps = false;
        newState.doc.descendants((node, pos) => {
          if (hasDropcapParagraph(node, pos, newState)) {
            hasDropcaps = true;
            return false;
          }
        });
        if (!hasDropcaps) {
          dropcapWidthCache.clear();
          return DecorationSet.empty;
        }
        let affectsDropcaps = false;
        tr.steps.forEach((step) => {
          if (step.slice?.content) {
            step.slice.content.descendants((node, pos) => {
              if (hasDropcapParagraph(node, pos, newState)) {
                affectsDropcaps = true;
                return false;
              }
            });
          }
          if (step.jsonID === "replace" && step.from !== void 0 && step.to !== void 0) {
            try {
              oldState.doc.nodesBetween(step.from, step.to, (node, pos) => {
                if (hasDropcapParagraph(node, pos, newState)) {
                  affectsDropcaps = true;
                  return false;
                }
              });
            } catch {
              affectsDropcaps = true;
            }
          }
        });
        if (!affectsDropcaps) {
          return oldDecorationSet.map(tr.mapping, tr.doc);
        }
        tr.steps.forEach((step) => {
          if (step.from !== void 0 && step.to !== void 0) {
            invalidateCacheForRange(step.from, step.to);
          }
        });
        const decorations = getDropcapDecorations(newState, view, dropcapWidthCache);
        return DecorationSet.create(newState.doc, decorations);
      }
    },
    props: {
      decorations(state) {
        return this.getState(state);
      }
    }
  });
}
function parseAttrs(node) {
  const numberingProperties = {};
  let indent, spacing;
  const { styleid: styleId, ...extraAttrs } = Array.from(node.attributes).reduce((acc, attr) => {
    if (attr.name === "data-num-id") {
      numberingProperties.numId = parseInt(attr.value);
    } else if (attr.name === "data-level") {
      numberingProperties.ilvl = parseInt(attr.value);
    } else if (attr.name === "data-indent") {
      try {
        indent = JSON.parse(attr.value);
        Object.keys(indent).forEach((key2) => {
          indent[key2] = Number(indent[key2]);
        });
      } catch {
      }
    } else if (attr.name === "data-spacing") {
      try {
        spacing = JSON.parse(attr.value);
        Object.keys(spacing).forEach((key2) => {
          spacing[key2] = Number(spacing[key2]);
        });
      } catch {
      }
    } else {
      acc[attr.name] = attr.value;
    }
    return acc;
  }, {});
  let attrs = {
    paragraphProperties: {
      styleId: styleId || null
    },
    extraAttrs
  };
  if (indent && Object.keys(indent).length > 0) {
    attrs.paragraphProperties.indent = indent;
  }
  if (spacing && Object.keys(spacing).length > 0) {
    attrs.paragraphProperties.spacing = spacing;
  }
  if (Object.keys(numberingProperties).length > 0) {
    attrs.paragraphProperties.numberingProperties = numberingProperties;
  }
  return attrs;
}
const bulletInputRegex = /^\s*([-+*])\s$/;
const orderedInputRegex = /^(\d+)\.\s$/;
const Paragraph = OxmlNode.create({
  name: "paragraph",
  oXmlName: "w:p",
  priority: 1e3,
  group: "block",
  content: "inline*",
  inline: false,
  summary: "The paragraph node mirrors MS Word w:p paragraphs, and also represents lists in the schema.",
  addOptions() {
    return {
      headingLevels: [1, 2, 3, 4, 5, 6],
      htmlAttributes: {}
    };
  },
  addAttributes() {
    return {
      paraId: { rendered: false },
      textId: { rendered: false },
      rsidR: { rendered: false },
      rsidRDefault: { rendered: false },
      rsidP: { rendered: false },
      rsidRPr: { rendered: false },
      rsidDel: { rendered: false },
      extraAttrs: {
        default: {},
        parseDOM: (element) => {
          const extra = {};
          Array.from(element.attributes).forEach((attr) => {
            extra[attr.name] = attr.value;
          });
          return extra;
        },
        renderDOM: (attributes) => {
          return attributes.extraAttrs || {};
        }
      },
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      },
      attributes: {
        rendered: false
      },
      filename: { rendered: false },
      paragraphProperties: { rendered: false },
      pageBreakSource: { rendered: false },
      sectionMargins: { rendered: false },
      listRendering: {
        keepOnSplit: false,
        renderDOM: ({ listRendering }) => {
          return {
            "data-marker-type": listRendering?.markerText,
            "data-list-level": listRendering?.path ? JSON.stringify(listRendering.path) : null,
            "data-list-numbering-type": listRendering?.numberingType
          };
        }
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: "p",
        getAttrs: parseAttrs
      },
      {
        tag: "div",
        getAttrs: (node) => {
          const extra = {};
          Array.from(node.attributes).forEach((attr) => {
            extra[attr.name] = attr.value;
          });
          return { extraAttrs: extra };
        }
      },
      {
        tag: "blockquote",
        attrs: { paragraphProperties: { styleId: "BlockQuote" } }
      },
      ...this.options.headingLevels.map((level) => ({
        tag: `h${level}`,
        getAttrs: (node) => {
          let attrs = parseAttrs(node);
          return {
            ...attrs,
            paragraphProperties: {
              ...attrs.paragraphProperties,
              styleId: `Heading${level}`
            }
          };
        }
      }))
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["p", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addNodeView() {
    if (this.editor.options?.mode !== "docx" || !this.editor.converter) return null;
    if (shouldSkipNodeView(this.editor)) return null;
    return ({ node, editor, getPos, decorations, extensionAttrs }) => {
      return new ParagraphNodeView(node, editor, getPos, decorations, extensionAttrs);
    };
  },
  addShortcuts() {
    return {
      "Mod-Shift-7": () => {
        return this.editor.commands.toggleOrderedList();
      },
      "Mod-Shift-8": () => {
        return this.editor.commands.toggleBulletList();
      },
      Enter: (params2) => {
        return removeNumberingProperties({ checkType: "empty" })({
          ...params2,
          tr: this.editor.state.tr,
          state: this.editor.state,
          dispatch: this.editor.view.dispatch
        });
      },
      "Shift-Enter": () => {
        return this.editor.commands.first(({ commands: commands2 }) => [
          () => commands2.createParagraphNear(),
          splitBlock$1({
            attrsToRemoveOverride: ["paragraphProperties.numberingProperties", "listRendering", "numberingProperties"]
          })
        ]);
      },
      Tab: () => {
        return this.editor.commands.first(({ commands: commands2 }) => [() => commands2.increaseListIndent()]);
      },
      "Shift-Tab": () => {
        return this.editor.commands.first(({ commands: commands2 }) => [() => commands2.decreaseListIndent()]);
      }
    };
  },
  addInputRules() {
    return [
      { regex: orderedInputRegex, type: "orderedList" },
      { regex: bulletInputRegex, type: "bulletList" }
    ].map(
      ({ regex, type }) => new superEditor_converter.InputRule({
        match: regex,
        handler: ({ state, range }) => {
          const parentListItem = superEditor_converter.findParentNode(superEditor_converter.isList)(state.selection);
          if (parentListItem) {
            return null;
          }
          const { tr } = state;
          tr.delete(range.from, range.to).setSelection(superEditor_converter.TextSelection.create(tr.doc, range.from));
          superEditor_converter.ListHelpers.createNewList({
            listType: type,
            tr,
            editor: this.editor
          });
        }
      })
    );
  },
  addCommands() {
    return {
      /**
       * Toggle ordered list formatting
       * @category Command
       * @example
       * editor.commands.toggleOrderedList()
       * @note Converts selection to ordered list or back to paragraphs
       */
      toggleOrderedList: () => (params2) => {
        return toggleList("orderedList")(params2);
      },
      /**
       * Toggle a bullet list at the current selection
       * @category Command
       * @example
       * // Toggle bullet list on selected text
       * editor.commands.toggleBulletList()
       * @note Converts selected paragraphs to list items or removes list formatting
       */
      toggleBulletList: () => (params2) => {
        return toggleList("bulletList")(params2);
      },
      /**
       * Restart numbering for the current list
       * @category Command
       * @example
       * // Restart numbering for the current list item
       * editor.commands.restartNumbering()
       * @note Resets list numbering for the current list item and following items
       */
      restartNumbering: () => restartNumbering
    };
  },
  addPmPlugins() {
    const dropcapPlugin = createDropcapPlugin(this.editor);
    const numberingPlugin = createNumberingPlugin(this.editor);
    const listEmptyInputPlugin = new superEditor_converter.Plugin({
      props: {
        handleDOMEvents: {
          beforeinput: (view, event) => {
            if (!event || event.inputType !== "insertText" || !event.data) {
              return false;
            }
            if (event.isComposing) return false;
            const { state } = view;
            const { selection } = state;
            if (!selection.empty) return false;
            const $from = selection.$from;
            const paragraph = $from.parent;
            if (!paragraph || paragraph.type.name !== "paragraph") return false;
            if (!superEditor_converter.isList(paragraph)) return false;
            if (!isVisuallyEmptyParagraph(paragraph)) return false;
            const tr = state.tr.insertText(event.data);
            view.dispatch(tr);
            event.preventDefault();
            return true;
          }
        }
      }
    });
    return [dropcapPlugin, numberingPlugin, listEmptyInputPlugin];
  }
});
const Heading = Extension.create({
  name: "heading",
  addOptions() {
    return {
      levels: [1, 2, 3, 4, 5, 6]
    };
  },
  addCommands() {
    return {
      /**
       * Set a heading with specified level
       * @category Command
       * @param {HeadingAttributes} attributes - Heading attributes including level
       * @example
       * editor.commands.setHeading({ level: 2 })
       * @note Converts current block to heading
       */
      setHeading: (attributes) => ({ commands: commands2 }) => {
        const containsLevel = this.options.levels.includes(attributes.level);
        if (!containsLevel) return false;
        return commands2.setLinkedStyle({ id: `Heading${attributes.level}` });
      },
      /**
       * Toggle between heading and paragraph
       * @category Command
       * @param {HeadingAttributes} attributes - Heading attributes including level
       * @example
       * editor.commands.toggleHeading({ level: 1 })
       * editor.commands.toggleHeading({ level: 3 })
       * @note Switches between heading and paragraph for the same level
       */
      toggleHeading: (attributes) => ({ commands: commands2 }) => {
        const containsLevel = this.options.levels.includes(attributes.level);
        if (!containsLevel) return false;
        return commands2.toggleLinkedStyle({ id: `Heading${attributes.level}` }, "paragraph");
      }
    };
  },
  addShortcuts() {
    return this.options.levels.reduce(
      (items, level) => ({
        ...items,
        ...{
          [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
        }
      }),
      {}
    );
  }
});
const CommentRangeStart = Node$1.create({
  name: "commentRangeStart",
  group: "inline",
  inline: true,
  atom: true,
  selectable: false,
  draggable: false,
  parseDOM() {
    return [{ tag: "commentRangeStart" }];
  },
  addOptions() {
    return {
      htmlAttributes: {
        contentEditable: "false",
        "aria-label": "Comment range start node"
      }
    };
  },
  renderDOM({ htmlAttributes }) {
    return ["commentRangeStart", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addAttributes() {
    return {
      "w:id": {
        rendered: false
      },
      internal: {
        default: true,
        rendered: false
      }
    };
  }
});
const CommentRangeEnd = Node$1.create({
  name: "commentRangeEnd",
  group: "inline",
  inline: true,
  atom: true,
  selectable: false,
  draggable: false,
  addOptions() {
    return {
      htmlAttributes: {
        contentEditable: "false",
        "aria-label": "Comment range end node"
      }
    };
  },
  parseDOM() {
    return [{ tag: "commentRangeEnd" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["commentRangeEnd", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addAttributes() {
    return {
      "w:id": {
        rendered: false
      }
    };
  }
});
const CommentReference = Node$1.create({
  name: "commentReference",
  group: "inline",
  inline: true,
  atom: true,
  selectable: false,
  draggable: false,
  addOptions() {
    return {
      htmlAttributes: {
        contentEditable: "false",
        "aria-label": "Comment reference node"
      }
    };
  },
  parseDOM() {
    return [{ tag: "commentReference" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["commentReference", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addAttributes() {
    return {
      attributes: {
        rendered: false
      }
    };
  }
});
const CommentsMark = Mark.create({
  name: CommentMarkName,
  group: "comments",
  excludes: "",
  addOptions() {
    return {
      htmlAttributes: { class: "sd-editor-comment" }
    };
  },
  addAttributes() {
    return {
      commentId: {},
      importedId: {},
      internal: {
        default: true,
        rendered: false
      },
      trackedChange: {
        default: false,
        rendered: false
      }
    };
  },
  parseDOM() {
    return [{ tag: CommentMarkName }];
  },
  renderDOM({ htmlAttributes }) {
    return [CommentMarkName, Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  }
});
const toSuperscriptDigits = (value) => {
  const map3 = {
    0: "",
    1: "",
    2: "",
    3: "",
    4: "",
    5: "",
    6: "",
    7: "",
    8: "",
    9: ""
  };
  return String(value ?? "").split("").map((ch) => map3[ch] ?? ch).join("");
};
const resolveFootnoteDisplayNumber = (editor, id) => {
  const key2 = id == null ? null : String(id);
  if (!key2) return null;
  const map3 = editor?.converter?.footnoteNumberById;
  const mapped = map3 && typeof map3 === "object" ? map3[key2] : void 0;
  return typeof mapped === "number" && Number.isFinite(mapped) && mapped > 0 ? mapped : null;
};
class FootnoteReferenceNodeView {
  constructor(node, getPos, decorations, editor, htmlAttributes = {}) {
    this.node = node;
    this.getPos = getPos;
    this.editor = editor;
    this.dom = this.#renderDom(node, htmlAttributes);
  }
  #renderDom(node, htmlAttributes) {
    const el = document.createElement("sup");
    el.className = "sd-footnote-ref";
    el.setAttribute("contenteditable", "false");
    el.setAttribute("aria-label", "Footnote reference");
    Object.entries(htmlAttributes).forEach(([key2, value]) => {
      if (value != null && value !== false) {
        el.setAttribute(key2, String(value));
      }
    });
    const id = node?.attrs?.id;
    if (id != null) {
      el.setAttribute("data-footnote-id", String(id));
      const display = resolveFootnoteDisplayNumber(this.editor, id) ?? id;
      el.textContent = toSuperscriptDigits(display);
    } else {
      el.textContent = "*";
    }
    return el;
  }
  update(node) {
    const incomingType = node?.type?.name;
    const currentType = this.node?.type?.name;
    if (!incomingType || incomingType !== currentType) return false;
    this.node = node;
    const id = node?.attrs?.id;
    if (id != null) {
      this.dom.setAttribute("data-footnote-id", String(id));
      const display = resolveFootnoteDisplayNumber(this.editor, id) ?? id;
      this.dom.textContent = toSuperscriptDigits(display);
    } else {
      this.dom.removeAttribute("data-footnote-id");
      this.dom.textContent = "*";
    }
    return true;
  }
}
const FootnoteReference = Node$1.create({
  name: "footnoteReference",
  group: "inline",
  inline: true,
  atom: true,
  selectable: false,
  draggable: false,
  addOptions() {
    return {
      htmlAttributes: {
        "data-footnote-ref": "true"
      }
    };
  },
  addAttributes() {
    return {
      id: {
        default: null
      },
      customMarkFollows: {
        default: null
      }
    };
  },
  addNodeView() {
    return ({ node, editor, getPos, decorations }) => {
      const htmlAttributes = this.options.htmlAttributes;
      return new FootnoteReferenceNodeView(node, getPos, decorations, editor, htmlAttributes);
    };
  },
  parseDOM() {
    return [{ tag: "sup[data-footnote-id]" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["sup", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  }
});
let cache$1 = /* @__PURE__ */ new WeakMap();
function getParagraphContext(paragraph, startPos, helpers2, revision, compute) {
  const cached = cache$1.get(paragraph);
  if (cached && cached.revision === revision) {
    return cached.context;
  }
  const context = compute(paragraph, startPos, helpers2);
  cache$1.set(paragraph, { revision, context });
  return context;
}
function clearAllParagraphContexts() {
  cache$1 = /* @__PURE__ */ new WeakMap();
}
const leaderStyles = {
  dot: "border-bottom: 1px dotted black;",
  heavy: "border-bottom: 2px solid black;",
  hyphen: "border-bottom: 1px solid black;",
  middleDot: "border-bottom: 1px dotted black; margin-bottom: 2px;",
  underscore: "border-bottom: 1px solid black;"
};
const paragraphIdFromPos = (startPos) => `para-${startPos}`;
const tabIdForIndex = (paragraphId, index2) => `${paragraphId}-tab-${index2}`;
function createLayoutRequest(doc2, paragraphPos, view, helpers2, revision, paragraphWidthOverride) {
  const $pos = doc2.resolve(paragraphPos);
  const paragraphCache = /* @__PURE__ */ new Map();
  const paragraphContext = findParagraphContext($pos, paragraphCache, helpers2);
  if (!paragraphContext) return null;
  const paragraphId = paragraphIdFromPos(paragraphContext.startPos);
  const paragraphNode = paragraphContext.paragraph;
  const cachedContext = getParagraphContext(
    paragraphNode,
    paragraphContext.startPos,
    helpers2,
    revision,
    () => extractParagraphContext(paragraphNode, paragraphContext.startPos, helpers2, paragraphContext.paragraphDepth)
  );
  const effectiveContext = cachedContext || paragraphContext;
  const { entries } = flattenParagraph(paragraphNode, paragraphContext.startPos);
  const spans = [];
  let tabIndex = 0;
  entries.forEach((entry, idx) => {
    const node = entry.node;
    const spanId = `${paragraphId}-span-${idx}`;
    const from3 = entry.pos;
    const to = entry.pos + node.nodeSize;
    if (node.type.name === "tab") {
      spans.push({
        type: "tab",
        spanId,
        tabId: tabIdForIndex(paragraphId, tabIndex++),
        pos: entry.pos,
        nodeSize: node.nodeSize
      });
    } else if (node.type.name === "lineBreak" || node.type.name === "hardBreak") {
      spans.push({
        type: node.type.name,
        spanId,
        pos: entry.pos,
        nodeSize: node.nodeSize
      });
    } else if (node.type.name === "text") {
      spans.push({
        type: "text",
        spanId,
        text: node.text || "",
        style: node.marks?.find((mark) => mark.type.name === "textStyle")?.attrs || {},
        from: from3,
        to
      });
    }
  });
  const tabStops = Array.isArray(effectiveContext.tabStops) ? [...effectiveContext.tabStops] : [];
  const hangingPx = twipsToPixels(Number(effectiveContext.indent?.hanging) || 0);
  if (hangingPx > 0 && effectiveContext.indentWidth != null) {
    tabStops.unshift({ val: "start", pos: effectiveContext.indentWidth + hangingPx, leader: "none" });
  }
  const paragraphWidth = getBlockNodeWidth(view, effectiveContext.startPos) ?? defaultLineLength;
  const indentWidth = effectiveContext.indentWidth ?? getIndentWidth(view, effectiveContext.startPos, effectiveContext.indent);
  return {
    paragraphId,
    revision,
    paragraphWidth,
    defaultTabDistance,
    defaultLineLength,
    indents: {
      left: twipsToPixels(Number(effectiveContext.indent?.left) || 0),
      right: twipsToPixels(Number(effectiveContext.indent?.right) || 0),
      firstLine: twipsToPixels(Number(effectiveContext.indent?.firstLine) || 0),
      hanging: hangingPx
    },
    tabStops,
    spans,
    indentWidth,
    paragraphNode
  };
}
function calculateTabLayout(request, measurement, view) {
  const {
    spans,
    tabStops,
    paragraphWidth,
    defaultTabDistance: defaultTabDistance2,
    defaultLineLength: defaultLineLength2,
    paragraphId,
    revision,
    indentWidth = 0,
    paragraphNode
  } = request;
  const tabs = {};
  const leftIndentPx = request.indents?.left ?? 0;
  let currentX = indentWidth;
  const measureText2 = (span) => {
    if (view && typeof span.from === "number" && typeof span.to === "number") {
      return measureRangeWidth(view, span.from, span.to);
    }
    return 0;
  };
  const tabHeight = paragraphNode ? calcTabHeight(paragraphNode) : void 0;
  for (let i = 0; i < spans.length; i++) {
    const span = spans[i];
    if (span.type === "text") {
      currentX += measureText2(span);
    } else if (span.type === "lineBreak" || span.type === "hardBreak") {
      currentX = leftIndentPx;
    } else if (span.type === "tab") {
      const followingText = collectFollowingText(spans, i + 1);
      let measureTextCallback;
      if (view) {
        const followingRange = getFollowingTextRange(spans, i + 1);
        if (followingRange) {
          const fullWidth = measureRangeWidth(view, followingRange.from, followingRange.to);
          const fullText = followingText;
          measureTextCallback = (text) => {
            if (text === fullText) return fullWidth;
            if (fullText.length > 0) {
              return text.length / fullText.length * fullWidth;
            }
            return 0;
          };
        }
      }
      const result = calculateTabWidth({
        currentX,
        tabStops,
        paragraphWidth,
        defaultTabDistance: defaultTabDistance2,
        defaultLineLength: defaultLineLength2,
        followingText,
        measureText: measureTextCallback
      });
      tabs[span.tabId] = {
        width: result.width,
        height: tabHeight,
        leader: result.leader,
        alignment: result.alignment,
        tabStopPosUsed: result.tabStopPosUsed
      };
      currentX += result.width;
    }
  }
  return {
    paragraphId,
    revision,
    tabs
  };
}
const MAX_WALK_DEPTH = 50;
function applyLayoutResult(result, paragraph, paragraphPos) {
  const decorations = [];
  let tabIndex = 0;
  const walk = (node, pos, depth = 0) => {
    if (depth > MAX_WALK_DEPTH) {
      console.error(`applyLayoutResult: Maximum recursion depth (${MAX_WALK_DEPTH}) exceeded`);
      return;
    }
    if (!node?.type?.name) {
      console.error("applyLayoutResult: Node missing type.name", { node, pos, depth });
      return;
    }
    if (typeof node.nodeSize !== "number" || node.nodeSize < 0 || !Number.isFinite(node.nodeSize)) {
      console.error("applyLayoutResult: Invalid nodeSize", { nodeSize: node.nodeSize, nodeName: node.type.name, pos });
      return;
    }
    if (node.type.name === "tab") {
      const tabId = tabIdForIndex(result.paragraphId, tabIndex++);
      const layout = result.tabs[tabId];
      if (layout) {
        let style2 = `width: ${layout.width}px;`;
        if (layout.height) style2 += ` height: ${layout.height};`;
        if (layout.leader && leaderStyles[layout.leader]) {
          style2 += ` ${leaderStyles[layout.leader]}`;
        }
        decorations.push(Decoration.node(pos, pos + node.nodeSize, { style: style2 }));
      }
      return;
    }
    try {
      let offset2 = 0;
      node.forEach((child) => {
        const childPos = pos + 1 + offset2;
        walk(child, childPos, depth + 1);
        offset2 += child.nodeSize;
      });
    } catch (error) {
      console.error("applyLayoutResult: Error during recursion", {
        error,
        nodeName: node.type.name,
        pos,
        depth
      });
    }
  };
  walk(paragraph, paragraphPos);
  return decorations;
}
function collectFollowingText(spans, startIndex) {
  let text = "";
  for (let i = startIndex; i < spans.length; i++) {
    const span = spans[i];
    if (span.type === "tab" || span.type === "lineBreak" || span.type === "hardBreak") break;
    if (span.type === "text") text += span.text || "";
  }
  return text;
}
function getFollowingTextRange(spans, startIndex) {
  let from3 = null;
  let to = null;
  for (let i = startIndex; i < spans.length; i++) {
    const span = spans[i];
    if (span.type === "tab" || span.type === "lineBreak" || span.type === "hardBreak") break;
    if (span.type === "text" && typeof span.from === "number" && typeof span.to === "number") {
      if (from3 === null) from3 = span.from;
      to = span.to;
    }
  }
  if (from3 !== null && to !== null) {
    return { from: from3, to };
  }
  return null;
}
const TabNode = Node$1.create({
  name: "tab",
  group: "inline",
  inline: true,
  // need this prop so Prosemirror doesn't treat tab as an
  // empty node and doesn't insert separator after
  content: "inline*",
  selectable: false,
  atom: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: "sd-editor-tab",
        // this works together with content prop:
        // since tab can't have content inside but content prop is defined I have to manually add attribute
        contentEditable: false
      }
    };
  },
  parseDOM() {
    return [{ tag: "span.sd-editor-tab" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      tabSize: {
        renderDOM: ({ tabSize }) => {
          if (!tabSize) return {};
          const style2 = `width: ${tabSize}px; min-width: ${tabSize}px;`;
          return { style: style2 };
        }
      }
    };
  },
  addPmPlugins() {
    if (isHeadless(this.editor)) {
      return [];
    }
    const { view, helpers: helpers2 } = this.editor;
    const tabPlugin = new superEditor_converter.Plugin({
      name: "tabPlugin",
      key: new superEditor_converter.PluginKey("tabPlugin"),
      state: {
        init() {
          const initialDecorations = buildInitialDecorations(view.state.doc, view, helpers2, 0);
          return { decorations: initialDecorations, revision: 0 };
        },
        apply(tr, { decorations, revision }, _oldState, newState) {
          const currentDecorations = decorations && decorations.map ? decorations.map(tr.mapping, tr.doc) : DecorationSet.empty;
          if (!tr.docChanged || tr.getMeta("blockNodeInitialUpdate")) {
            return { decorations: currentDecorations, revision };
          }
          const affectedParagraphs = getAffectedParagraphStarts(tr, newState);
          if (affectedParagraphs.size === 0) {
            return { decorations: currentDecorations, revision };
          }
          let nextDecorations = currentDecorations;
          affectedParagraphs.forEach((pos) => {
            const paragraph = newState.doc.nodeAt(pos);
            if (!paragraph || paragraph.type.name !== "paragraph") return;
            const from3 = pos;
            const to = pos + paragraph.nodeSize;
            const existing = nextDecorations.find(from3, to);
            if (existing?.length) {
              nextDecorations = nextDecorations.remove(existing);
            }
            const paragraphDecorations = buildParagraphDecorations(
              newState.doc,
              pos + 1,
              paragraph,
              view,
              helpers2,
              revision + 1
            );
            nextDecorations = nextDecorations.add(newState.doc, paragraphDecorations);
          });
          return { decorations: nextDecorations, revision: revision + 1 };
        }
      },
      props: {
        decorations(state) {
          return this.getState(state).decorations;
        }
      },
      view() {
        return {
          destroy() {
            clearAllParagraphContexts();
          }
        };
      }
    });
    return [tabPlugin];
  }
});
function buildInitialDecorations(doc2, view, helpers2, revision) {
  const decorations = [];
  doc2.descendants((node, pos) => {
    if (node.type.name !== "paragraph") return;
    let hasTab = false;
    node.descendants((child) => {
      if (child.type.name === "tab") {
        hasTab = true;
        return false;
      }
      return true;
    });
    if (!hasTab) return;
    const request = createLayoutRequest(doc2, pos + 1, view, helpers2, revision);
    if (!request) return;
    const result = calculateTabLayout(request, void 0, view);
    const paragraphDecorations = applyLayoutResult(result, node, pos);
    decorations.push(...paragraphDecorations);
  });
  return DecorationSet.create(doc2, decorations);
}
function buildParagraphDecorations(doc2, paragraphContentPos, paragraphNode, view, helpers2, revision) {
  const request = createLayoutRequest(doc2, paragraphContentPos, view, helpers2, revision);
  if (!request) return [];
  const result = calculateTabLayout(request, void 0, view);
  return applyLayoutResult(result, paragraphNode, paragraphContentPos - 1);
}
function getAffectedParagraphStarts(tr, newState) {
  const affected = /* @__PURE__ */ new Set();
  tr.steps.forEach((step, index2) => {
    if (step.from == null && step.to == null) return;
    let fromPos = step.from;
    let toPos = step.to;
    if (typeof fromPos !== "number" || typeof toPos !== "number") return;
    for (let i = index2; i < tr.steps.length; i++) {
      const stepMap = tr.steps[i].getMap();
      fromPos = stepMap.map(fromPos, -1);
      toPos = stepMap.map(toPos, 1);
    }
    if (fromPos < 0 || toPos < 0 || fromPos > newState.doc.content.size || toPos > newState.doc.content.size) {
      return;
    }
    newState.doc.nodesBetween(fromPos, toPos, (node, pos) => {
      if (node.type.name === "paragraph") {
        affected.add(pos);
        return false;
      }
      return true;
    });
  });
  return affected;
}
const LineBreak = Node$1.create({
  name: "lineBreak",
  group: "inline",
  inline: true,
  marks: "",
  defining: true,
  selectable: false,
  content: "",
  atom: true,
  addOptions() {
    return {};
  },
  parseDOM() {
    return [{ tag: "br" }];
  },
  renderDOM() {
    return ["br", {}];
  },
  addAttributes() {
    return {
      lineBreakType: { rendered: false },
      clear: { rendered: false }
    };
  },
  // @ts-expect-error - Command signatures will be fixed in TS migration
  addCommands() {
    return {
      /**
       * Insert a line break
       * @category Command
       * @example
       * editor.commands.insertLineBreak()
       * @note Creates a soft break within the same paragraph
       */
      insertLineBreak: () => ({ commands: commands2 }) => {
        return commands2.insertContent({ type: "lineBreak" });
      }
    };
  }
});
const HardBreak = Node$1.create({
  name: "hardBreak",
  group: "inline",
  inline: true,
  selectable: false,
  atom: true,
  addOptions() {
    return {
      htmlAttributes: {
        contentEditable: "false",
        lineBreakType: "page",
        "aria-hidden": "true",
        "aria-label": "Hard break node"
      }
    };
  },
  addAttributes() {
    return {
      pageBreakSource: {
        rendered: false,
        default: null
      },
      pageBreakType: {
        default: null,
        rendered: false
      },
      lineBreakType: { rendered: false },
      clear: { rendered: false }
    };
  },
  parseDOM() {
    return [
      {
        tag: 'span[linebreaktype="page"]',
        getAttrs: (dom) => {
          if (!(dom instanceof HTMLElement)) return false;
          return {
            pageBreakSource: dom.getAttribute("pagebreaksource") || null,
            pageBreakType: dom.getAttribute("linebreaktype") || null
          };
        }
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  // @ts-expect-error - Command signatures will be fixed in TS migration
  addCommands() {
    return {
      /**
       * Insert a page break
       * @category Command
       * @example
       * editor.commands.insertPageBreak()
       * @note Forces content to start on a new page when printed
       */
      insertPageBreak: () => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: "hardBreak",
          attrs: { pageBreakType: "page" }
        });
      }
    };
  }
});
const createTableView = ({ editor }) => {
  return class TableView {
    editor;
    node;
    dom;
    table;
    colgroup;
    contentDOM;
    cellMinWidth;
    constructor(node, cellMinWidth) {
      this.editor = editor;
      this.node = node;
      this.cellMinWidth = cellMinWidth;
      this.dom = document.createElement("div");
      this.dom.className = "tableWrapper";
      this.table = this.dom.appendChild(document.createElement("table"));
      this.colgroup = this.table.appendChild(document.createElement("colgroup"));
      updateTable(this.editor, this.node, this.table);
      updateColumns(node, this.colgroup, this.table);
      this.contentDOM = this.table.appendChild(document.createElement("tbody"));
      setTimeout(() => {
        updateTableWrapper(this.dom, this.table);
      }, 0);
    }
    update(node) {
      if (node.type !== this.node.type) {
        return false;
      }
      this.node = node;
      updateTable(this.editor, node, this.table);
      updateColumns(node, this.colgroup, this.table, this.cellMinWidth);
      updateTableWrapper(this.dom, this.table);
      return true;
    }
    ignoreMutation(mutation) {
      const tableWrapper = this.dom;
      if (mutation.target === tableWrapper && mutation.type === "attributes" && mutation.attributeName === "style") {
        return true;
      }
      return mutation.type === "attributes" && (mutation.target === this.table || this.colgroup.contains(mutation.target));
    }
  };
};
function updateColumns(node, colgroup, table, _cellMinWidth) {
  const gridColumns = Array.isArray(node.attrs?.grid) && node.attrs.grid.length ? node.attrs.grid.map((col) => helpers$1.twipsToPixels(col.col)) : null;
  const totalColumns = gridColumns?.length ?? null;
  const resolveColumnWidth = (colIndex2, colwidthValue) => {
    if (colwidthValue != null) return colwidthValue;
    if (gridColumns && gridColumns[colIndex2] != null) return gridColumns[colIndex2];
    return null;
  };
  const widths = [];
  const firstRow = node.firstChild;
  let colIndex = 0;
  if (firstRow !== null) {
    for (let i = 0; i < firstRow.childCount; i++) {
      const child = firstRow.child(i);
      const { colspan, colwidth } = child.attrs;
      for (let span = 0; span < colspan; span += 1, colIndex += 1) {
        widths.push(resolveColumnWidth(colIndex, colwidth && colwidth[span]));
      }
    }
  }
  if (totalColumns != null && colIndex < totalColumns) {
    for (let col = colIndex; col < totalColumns; col += 1) {
      widths.push(resolveColumnWidth(col));
    }
  }
  const normalizedWidths = widths.map((widthPx) => {
    const numericWidth = Number(widthPx);
    if (!Number.isFinite(numericWidth)) return null;
    if (numericWidth < 0) return null;
    if (numericWidth === 0) return 0;
    if (numericWidth < 1) return 0;
    return numericWidth;
  });
  const tableWidthCSS = helpers$1.convertSizeToCSS(
    // TODO: why is tableWidth undefined in src/tests/import-export/font-default-styles.test.js?
    node.attrs.tableProperties.tableWidth?.value ?? null,
    node.attrs.tableProperties.tableWidth?.type ?? "auto"
  );
  let colElement = colgroup.firstChild;
  normalizedWidths.forEach((width) => {
    if (!colElement) {
      colElement = document.createElement("col");
      colgroup.appendChild(colElement);
    }
    colElement.style.width = width !== null && width !== void 0 ? `${width}px` : null;
    colElement = colElement.nextSibling;
  });
  while (colElement) {
    const next = colElement.nextSibling;
    colElement.parentNode?.removeChild(colElement);
    colElement = next;
  }
  const tableIndent = helpers$1.convertSizeToCSS(
    node.attrs.tableProperties.tableIndent?.value ?? 0,
    node.attrs.tableProperties.tableIndent?.type ?? "dxa"
  );
  const firstRowFirstCellPaddingLeftPx = firstRow?.firstChild?.attrs?.cellMargins?.left ?? 0;
  const firstRowLastCellPaddingRightPx = firstRow?.lastChild?.attrs?.cellMargins?.right ?? 0;
  table.style.marginLeft = `${-firstRowFirstCellPaddingLeftPx}px`;
  if (tableIndent !== null) {
    table.style.marginLeft = tableIndent;
  }
  if (node.attrs.tableProperties.tableWidth?.type === "pct") {
    const padding = firstRowFirstCellPaddingLeftPx + firstRowLastCellPaddingRightPx;
    table.style.maxWidth = table.style.width = `calc(${tableWidthCSS} + ${padding}px)`;
  } else {
    table.style.maxWidth = table.style.width = tableWidthCSS;
  }
}
function updateTable(editor, node, table) {
  const allExtensionsAttrs = editor.extensionService.attributes;
  const tableExtensionAttrs = allExtensionsAttrs.filter((e) => e.type === "table");
  const htmlAttributes = Attribute.getAttributesToRender(node, tableExtensionAttrs);
  Object.entries(htmlAttributes).forEach(([key2, value]) => {
    if (key2 === "style") {
      table.style.cssText = value;
    } else {
      table.setAttribute(key2, value);
    }
  });
}
function updateTableWrapper(tableWrapper, table) {
  let defaultBorderWidth = 1;
  let borderWidth;
  if (!table) {
    return;
  }
  let borderLeftMax = parseFloat(table.style.borderLeftWidth || 0);
  let borderRightMax = parseFloat(table.style.borderRightWidth) || 0;
  let firstColumnCells = [...table.querySelectorAll(":scope > tbody > tr > td:first-child")];
  let lastColumnCells = [...table.querySelectorAll(":scope > tbody > tr > td:last-child")];
  for (let cell of firstColumnCells) {
    let borderLeft = parseFloat(cell.style.borderLeftWidth) || 0;
    borderLeftMax = Math.max(borderLeftMax, borderLeft);
  }
  for (let cell of lastColumnCells) {
    let borderRight = parseFloat(cell.style.borderRightWidth) || 0;
    borderRightMax = Math.max(borderRightMax, borderRight);
  }
  borderWidth = Math.ceil(Math.max(borderLeftMax, borderRightMax));
  tableWrapper.style.setProperty("--table-border-width", `${borderWidth || defaultBorderWidth}px`);
}
const createCell = (cellType, cellContent = null) => {
  if (cellContent) {
    return cellType.createChecked(null, cellContent);
  }
  return cellType.createAndFill();
};
const createTableBorders = (borderSpec = {}) => {
  borderSpec = {
    size: 0.66665,
    color: "#000000",
    ...borderSpec
  };
  return {
    top: borderSpec,
    left: borderSpec,
    bottom: borderSpec,
    right: borderSpec,
    insideH: borderSpec,
    insideV: borderSpec
  };
};
const createTable = (schema, rowsCount, colsCount, withHeaderRow, cellContent = null) => {
  const types = {
    table: getNodeType("table", schema),
    tableRow: getNodeType("tableRow", schema),
    tableCell: getNodeType("tableCell", schema),
    tableHeader: getNodeType("tableHeader", schema)
  };
  const headerCells = [];
  const cells = [];
  for (let index2 = 0; index2 < colsCount; index2++) {
    const cell = createCell(types.tableCell, cellContent);
    if (cell) cells.push(cell);
    if (withHeaderRow) {
      const headerCell = createCell(types.tableHeader, cellContent);
      if (headerCell) {
        headerCells.push(headerCell);
      }
    }
  }
  const rows = [];
  for (let index2 = 0; index2 < rowsCount; index2++) {
    const cellsToInsert = withHeaderRow && index2 === 0 ? headerCells : cells;
    rows.push(types.tableRow.createChecked(null, cellsToInsert));
  }
  const tableBorders = createTableBorders();
  return types.table.createChecked({ borders: tableBorders }, rows);
};
const getColStyleDeclaration = (minWidth, width) => {
  if (width != null) {
    const numericWidth = Number(width);
    if (Number.isFinite(numericWidth) && numericWidth >= 0) {
      return ["width", `${numericWidth}px`];
    }
  }
  return ["min-width", `${minWidth}px`];
};
const MIN_MEANINGFUL_WIDTH_PX = 1;
const createColGroup = (node, cellMinWidth, overrideCol, overrideValue) => {
  let totalWidth = 0;
  let fixedWidth = true;
  const cols = [];
  const colsValues = [];
  const row = node.firstChild;
  const gridColumns = Array.isArray(node.attrs?.grid) && node.attrs.grid.length ? node.attrs.grid.map((col) => helpers$1.twipsToPixels(col.col)) : null;
  if (!row) return {};
  const totalColumns = gridColumns?.length;
  const resolveColumnWidth = (colIndex2, colwidthValue) => {
    if (overrideCol === colIndex2) return overrideValue;
    if (colwidthValue != null) return colwidthValue;
    if (gridColumns && gridColumns[colIndex2] != null) return gridColumns[colIndex2];
    return null;
  };
  let colIndex = 0;
  for (let i = 0; i < row.childCount; i++) {
    const child = row.child(i);
    const { colspan, colwidth } = child.attrs;
    for (let j = 0; j < colspan; j++, colIndex++) {
      const candidateWidth = resolveColumnWidth(colIndex, colwidth && colwidth[j]);
      const numericWidth = Number(candidateWidth);
      let effectiveWidth = Number.isFinite(numericWidth) && numericWidth > 0 ? numericWidth : null;
      if (effectiveWidth != null && effectiveWidth < MIN_MEANINGFUL_WIDTH_PX) {
        effectiveWidth = 0;
      }
      if (effectiveWidth == null) {
        totalWidth += cellMinWidth;
        fixedWidth = false;
      } else {
        totalWidth += effectiveWidth;
      }
      const [prop, value] = getColStyleDeclaration(cellMinWidth, effectiveWidth);
      cols.push(["col", { style: `${prop}: ${value}` }]);
      colsValues.push(parseFloat(value));
    }
  }
  if (totalColumns != null) {
    for (let col = colIndex; col < totalColumns; col++) {
      const candidateWidth = resolveColumnWidth(col);
      const numericWidth = Number(candidateWidth);
      let effectiveWidth = Number.isFinite(numericWidth) && numericWidth > 0 ? numericWidth : null;
      if (effectiveWidth != null && effectiveWidth < MIN_MEANINGFUL_WIDTH_PX) {
        effectiveWidth = 0;
      }
      if (effectiveWidth == null) {
        totalWidth += cellMinWidth;
        fixedWidth = false;
      } else {
        totalWidth += effectiveWidth;
      }
      const [prop, value] = getColStyleDeclaration(cellMinWidth, effectiveWidth);
      cols.push(["col", { style: `${prop}: ${value}` }]);
      colsValues.push(parseFloat(value));
    }
  }
  const tableWidth = fixedWidth ? `${totalWidth}px` : "";
  const tableMinWidth = fixedWidth ? "" : `${totalWidth}px`;
  const colgroup = ["colgroup", {}, ...cols];
  const colgroupValues = [...colsValues];
  return {
    colgroup,
    tableWidth,
    tableMinWidth,
    colgroupValues
  };
};
const isCellSelection = (value) => value instanceof CellSelection;
const deleteTableWhenSelected = ({ editor }) => {
  const { selection } = editor.state;
  if (!isCellSelection(selection)) return false;
  let cellCount = 0;
  const table = superEditor_converter.findParentNodeClosestToPos(selection.ranges[0].$from, (node) => {
    return node.type.name === "table";
  });
  table?.node.descendants((node) => {
    if (node.type.name === "table") return false;
    if (["tableCell", "tableHeader"].includes(node.type.name)) {
      cellCount += 1;
    }
  });
  const allCellsSelected = cellCount === selection.ranges.length;
  if (!allCellsSelected) {
    return false;
  }
  editor.commands.deleteTable();
  return true;
};
const createCellBorders = (borderSpec = {}) => {
  borderSpec = {
    size: 0.66665,
    color: "#000000",
    ...borderSpec
  };
  return {
    top: borderSpec,
    left: borderSpec,
    bottom: borderSpec,
    right: borderSpec
  };
};
function cellAround($pos) {
  for (let d = $pos.depth - 1; d > 0; d--)
    if ($pos.node(d).type.spec.tableRole == "row") return $pos.node(0).resolve($pos.before(d + 1));
  return null;
}
function cellWrapping($pos) {
  for (let d = $pos.depth; d > 0; d--) {
    const role = $pos.node(d).type.spec.tableRole;
    if (role === "cell" || role === "header_cell") return $pos.node(d);
  }
  return null;
}
const ZERO_WIDTH_SPACE = "";
const ROW_START_TO_TEXT_OFFSET = 3;
const CELL_TO_TEXT_OFFSET = 2;
function resolveTable(tr, tablePos, tableNode) {
  if (tableNode && tableNode.type && tableNode.type.name === "table") {
    return tableNode;
  }
  if (typeof tablePos === "number") {
    const current = tr.doc.nodeAt(tablePos);
    if (current && current.type.name === "table") {
      return current;
    }
  }
  return null;
}
function pickTemplateRowForAppend(tableNode, schema) {
  const RowType = schema.nodes.tableRow;
  const rows = [];
  tableNode.descendants((child) => {
    if (child.type === RowType) rows.push(child);
  });
  if (!rows.length) return null;
  for (let i = rows.length - 1; i >= 0; i--) {
    const r2 = rows[i];
    const hasBodyCell = r2.content?.content?.some((c2) => c2.type.name === "tableCell");
    if (hasBodyCell) return r2;
  }
  return rows[rows.length - 1];
}
function extractRowTemplateFormatting(cellNode, schema) {
  const ParagraphType = schema.nodes.paragraph;
  let blockType = ParagraphType;
  let blockAttrs = null;
  let textMarks = [];
  const blocks = cellNode?.content?.content || [];
  for (const block of blocks) {
    const isParagraphish = block.type === ParagraphType || block.type.name === "heading";
    if (isParagraphish) {
      blockType = block.type || ParagraphType;
      blockAttrs = block.attrs || null;
    }
    let foundText = null;
    block.descendants?.((n) => {
      if (!foundText && n.isText) foundText = n;
    });
    if (foundText) {
      textMarks = foundText.marks ? Array.from(foundText.marks) : [];
      break;
    }
  }
  if (!blockType || !blockType.validContent) blockType = ParagraphType;
  return { blockType, blockAttrs, textMarks };
}
function buildFormattedCellBlock(schema, value, { blockType, blockAttrs, textMarks }, copyRowStyle = false) {
  const text = typeof value === "string" ? value : value == null ? "" : String(value);
  const type = blockType || schema.nodes.paragraph;
  const marks = copyRowStyle ? textMarks || [] : [];
  if (!text) {
    const content = marks.length > 0 ? schema.text(ZERO_WIDTH_SPACE, marks) : null;
    return type.createAndFill(blockAttrs || null, content);
  }
  const textNode = schema.text(text, marks);
  return type.createAndFill(blockAttrs || null, textNode);
}
function buildRowFromTemplateRow({ schema, tableNode, templateRow, values, copyRowStyle = false }) {
  const RowType = schema.nodes.tableRow;
  const CellType = schema.nodes.tableCell;
  const HeaderType = schema.nodes.tableHeader;
  const map3 = TableMap.get(tableNode);
  const totalColumns = map3.width;
  const byColumns = Array.isArray(values) && values.length === totalColumns;
  const newCells = [];
  let columnCursor = 0;
  templateRow.content.content.forEach((cellNode, cellIndex) => {
    const isHeaderCell = cellNode.type === HeaderType;
    const targetCellType = isHeaderCell ? CellType : cellNode.type;
    const attrs = { ...cellNode.attrs };
    const formatting = extractRowTemplateFormatting(cellNode, schema);
    let cellValue = "";
    if (byColumns) {
      const span = Math.max(1, attrs.colspan || 1);
      cellValue = values[columnCursor] ?? "";
      columnCursor += span;
    } else {
      cellValue = Array.isArray(values) ? values[cellIndex] ?? "" : "";
    }
    const content = buildFormattedCellBlock(schema, cellValue, formatting, copyRowStyle);
    const newCell = targetCellType.createAndFill(attrs, content);
    if (newCell) newCells.push(newCell);
  });
  return RowType.createAndFill(null, newCells);
}
function insertRowsAtTableEnd({ tr, tablePos, tableNode, rows }) {
  if (!rows || !rows.length) return;
  const RowTypeName = "tableRow";
  let lastRowRelPos = 0;
  let lastRowNode = null;
  tableNode.descendants((child, relPos) => {
    if (child.type.name === RowTypeName) {
      lastRowRelPos = relPos;
      lastRowNode = child;
    }
  });
  if (!lastRowNode) return;
  const lastRowAbsEnd = tablePos + 1 + lastRowRelPos + lastRowNode.nodeSize;
  const frag = superEditor_converter.Fragment.fromArray(rows);
  tr.insert(lastRowAbsEnd, frag);
}
function insertRowAtIndex({ tr, tablePos, tableNode, sourceRowIndex, insertIndex, schema }) {
  const sourceRow = tableNode.child(sourceRowIndex);
  if (!sourceRow) return false;
  const map3 = TableMap.get(tableNode);
  const { width, height } = map3;
  const newCells = [];
  const cellsToExtend = [];
  const RowType = schema.nodes.tableRow;
  const CellType = schema.nodes.tableCell;
  const sourceFormatting = extractRowTemplateFormatting(sourceRow.firstChild, schema);
  for (let col = 0; col < width; ) {
    if (insertIndex > 0 && insertIndex < height) {
      const indexAbove = (insertIndex - 1) * width + col;
      const indexAtInsert = insertIndex * width + col;
      if (map3.map[indexAbove] === map3.map[indexAtInsert]) {
        const cellPos = map3.map[indexAbove];
        const cell = tableNode.nodeAt(cellPos);
        if (cell) {
          const attrs = cell.attrs;
          cellsToExtend.push({
            pos: tablePos + 1 + cellPos,
            attrs: { ...attrs, rowspan: (attrs.rowspan || 1) + 1 }
          });
          col += attrs.colspan || 1;
          continue;
        }
      }
    }
    const sourceMapIndex = sourceRowIndex * width + col;
    const sourceCellPos = map3.map[sourceMapIndex];
    const sourceCell = tableNode.nodeAt(sourceCellPos);
    if (!sourceCell) {
      const fallbackCell = sourceRow.firstChild;
      const formatting2 = extractRowTemplateFormatting(fallbackCell, schema);
      const content2 = buildFormattedCellBlock(schema, "", formatting2, true);
      const newCell2 = CellType.createAndFill({ rowspan: 1, colspan: 1 }, content2);
      if (newCell2) newCells.push(newCell2);
      col += 1;
      continue;
    }
    const colspan = sourceCell.attrs.colspan || 1;
    const formatting = extractRowTemplateFormatting(sourceCell, schema);
    const cellAttrs = {
      ...sourceCell.attrs,
      rowspan: 1
      // New cells always have rowspan 1
    };
    const content = buildFormattedCellBlock(schema, "", formatting, true);
    const targetCellType = sourceCell.type.name === "tableHeader" ? CellType : sourceCell.type;
    const newCell = targetCellType.createAndFill(cellAttrs, content);
    if (newCell) newCells.push(newCell);
    col += colspan;
  }
  for (const { pos, attrs } of cellsToExtend) {
    tr.setNodeMarkup(pos, null, attrs);
  }
  let insertPos = tablePos + 1;
  for (let i = 0; i < insertIndex; i++) {
    insertPos += tableNode.child(i).nodeSize;
  }
  if (newCells.length > 0) {
    const newRow = RowType.createAndFill(null, newCells);
    if (newRow) {
      tr.insert(insertPos, newRow);
      const cursorPos = insertPos + ROW_START_TO_TEXT_OFFSET;
      tr.setSelection(superEditor_converter.TextSelection.create(tr.doc, cursorPos));
      const firstCellBlock = newCells[0].firstChild;
      const firstTextNode = firstCellBlock?.firstChild;
      if (firstTextNode?.marks?.length) {
        tr.setStoredMarks(firstTextNode.marks);
      } else if (sourceFormatting.textMarks?.length) {
        tr.setStoredMarks(sourceFormatting.textMarks);
      }
    }
  } else {
    if (cellsToExtend.length > 0) {
      const spanningCellPos = cellsToExtend[0].pos;
      const cursorPos = spanningCellPos + CELL_TO_TEXT_OFFSET;
      tr.setSelection(superEditor_converter.TextSelection.create(tr.doc, cursorPos));
    }
  }
  return true;
}
const Table = Node$1.create({
  name: "table",
  content: "tableRow+",
  group: "block",
  isolating: true,
  tableRole: "table",
  addOptions() {
    return {
      htmlAttributes: {
        "aria-label": "Table node"
      },
      resizable: true,
      handleWidth: 5,
      cellMinWidth: 10,
      lastColumnResizable: true,
      allowTableNodeSelection: false
    };
  },
  addAttributes() {
    return {
      /**
       * @private
       * @category Attribute
       * @param {string} [sdBlockId] - Internal block tracking ID (not user-configurable)
       */
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      },
      /**
       * @category Attribute
       * @param {TableIndent} [tableIndent] - Table indentation configuration
       */
      tableIndent: {
        renderDOM: ({ tableIndent }) => {
          if (!tableIndent) return {};
          const { width } = tableIndent;
          let style2 = "";
          if (width) style2 += `margin-left: ${width}px`;
          return {
            style: style2
          };
        }
      },
      /**
       * @category Attribute
       * @param {import("./tableHelpers/createTableBorders.js").TableBorders} [borders] - Border styling for this table
       */
      borders: {
        default: {}
      },
      /**
       * @category Attribute
       * @param {string} [borderCollapse='collapse'] - CSS border-collapse property
       */
      borderCollapse: {
        default: null,
        renderDOM({ borderCollapse }) {
          return {
            style: `border-collapse: ${borderCollapse || "collapse"}`
          };
        }
      },
      /**
       * @category Attribute
       * @param {string} [justification] - Table alignment ('left', 'center', 'right')
       */
      justification: {
        default: null,
        renderDOM: (attrs) => {
          if (!attrs.justification) return {};
          if (attrs.justification === "center") {
            return { style: `margin: 0 auto` };
          }
          if (attrs.justification === "right") {
            return { style: `margin-left: auto` };
          }
          return {};
        }
      },
      /**
       * @private
       * @category Attribute
       * @param {string} [tableStyleId] - Internal reference to table style (not user-configurable)
       */
      tableStyleId: {
        rendered: false
      },
      /**
       * @private
       * @category Attribute
       * @param {string} [tableLayout] - CSS table-layout property (advanced usage)
       */
      tableLayout: {
        rendered: false
      },
      /**
       * @category Attribute
       * @param {number} [tableCellSpacing] - Cell spacing in pixels for this table
       */
      tableCellSpacing: {
        default: null,
        rendered: false
      },
      /**
       * @category Attribute
       * @param {TableProperties} [tableProperties] - Properties for the table.
       * @see {@link https://ecma-international.org/publications-and-standards/standards/ecma-376/} "Fundamentals And Markup Language Reference", page 371-483
       */
      tableProperties: {
        default: {
          tableWidth: {
            value: null,
            type: "auto"
          }
        },
        rendered: false
      },
      /**
       * @category Attribute
       * @param {TableGrid} [grid] - Grid definition for the table
       * @see {@link https://ecma-international.org/publications-and-standards/standards/ecma-376/} "Fundamentals And Markup Language Reference", page 432
       */
      grid: {
        default: null,
        rendered: false
      },
      /**
       * @category Attribute
       * @param {boolean} [userEdited] - Flag indicating user has manually resized columns
       * Used by pm-adapter to prioritize user edits over original OOXML grid
       */
      userEdited: {
        default: false,
        rendered: false
      }
    };
  },
  parseDOM() {
    return [{ tag: "table" }];
  },
  renderDOM({ node, htmlAttributes }) {
    const { colgroup, tableWidth, tableMinWidth } = createColGroup(node, this.options.cellMinWidth);
    const attrs = Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes, {
      style: tableWidth ? `width: ${tableWidth}` : `min-width: ${tableMinWidth}`
    });
    return ["table", attrs, colgroup, ["tbody", 0]];
  },
  // @ts-expect-error - Command signatures will be fixed in TS migration
  addCommands() {
    return {
      /**
       * Append multiple rows to the end of a table in a single transaction.
       * @category Command
       * @param {appendRowsWithContentOptions} options - Append configuration
       * @example
       * editor.commands.appendRowsWithContent({ tablePos, valueRows: [['A','B'], ['C','D']], copyRowStyle: true })
       */
      appendRowsWithContent: ({ tablePos, tableNode, valueRows = [], copyRowStyle = false }) => ({ editor, chain }) => {
        if (typeof tablePos !== "number" && !tableNode || !Array.isArray(valueRows) || !valueRows.length) {
          return false;
        }
        return chain().command(({ tr, dispatch }) => {
          const workingTable = resolveTable(tr, tablePos, tableNode);
          if (!workingTable) return false;
          const templateRow = pickTemplateRowForAppend(workingTable, editor.schema);
          if (!templateRow) return false;
          const newRows = valueRows.map(
            (vals) => buildRowFromTemplateRow({
              schema: editor.schema,
              tableNode: workingTable,
              templateRow,
              values: vals,
              copyRowStyle
            })
          ).filter(Boolean);
          if (!newRows.length) return false;
          let resolvedTablePos = tablePos;
          if (typeof resolvedTablePos !== "number" && workingTable) {
            const tables = editor.getNodesOfType("table");
            const match = workingTable ? tables.find((t) => t.node.eq(workingTable)) : tables[0];
            resolvedTablePos = match?.pos ?? null;
          }
          if (typeof resolvedTablePos !== "number") {
            return false;
          }
          if (dispatch) {
            insertRowsAtTableEnd({ tr, tablePos, tableNode: workingTable, rows: newRows });
          }
          return true;
        }).run();
      },
      /**
       * Insert a new table into the document
       * @category Command
       * @param {TableConfig} [config] - Table configuration options
       * @example
       * editor.commands.insertTable()
       * editor.commands.insertTable({ rows: 3, cols: 3, withHeaderRow: true })
       */
      insertTable: ({ rows = 3, cols = 3, withHeaderRow = false } = {}) => ({ tr, dispatch, editor }) => {
        const node = createTable(editor.schema, rows, cols, withHeaderRow);
        if (dispatch) {
          let offset2 = tr.selection.$from.end() + 1;
          if (tr.selection.$from.parent?.type?.name === "run") {
            offset2 = tr.selection.$from.after(tr.selection.$from.depth - 1);
          }
          tr.replaceSelectionWith(node).scrollIntoView().setSelection(superEditor_converter.TextSelection.near(tr.doc.resolve(offset2)));
        }
        return true;
      },
      /**
       * Delete the entire table containing the cursor
       * @category Command
       * @example
       * editor.commands.deleteTable()
       */
      deleteTable: () => ({ state, dispatch }) => {
        return deleteTable(state, dispatch);
      },
      /**
       * Add a column before the current column
       * @category Command
       * @example
       * editor.commands.addColumnBefore()
       * @note Preserves cell attributes from current column
       */
      addColumnBefore: () => ({ state, dispatch, chain }) => {
        if (!addColumnBefore(state)) return false;
        let { rect, attrs: currentCellAttrs } = getCurrentCellAttrs(state);
        return chain().command(() => addColumnBefore(state, dispatch)).command(({ tr }) => {
          let table = tr.doc.nodeAt(rect.tableStart - 1);
          if (!table) return false;
          let updatedMap = TableMap.get(table);
          let newColumnIndex = rect.left;
          if (newColumnIndex < 0 || newColumnIndex >= updatedMap.width) {
            return false;
          }
          for (let row = 0; row < updatedMap.height; row++) {
            let cellIndex = row * updatedMap.width + newColumnIndex;
            let cellPos = updatedMap.map[cellIndex];
            let cellAbsolutePos = rect.tableStart + cellPos;
            let cell = tr.doc.nodeAt(cellAbsolutePos);
            if (cell) {
              let attrs = {
                ...currentCellAttrs,
                colspan: cell.attrs.colspan,
                rowspan: cell.attrs.rowspan,
                colwidth: cell.attrs.colwidth
              };
              tr.setNodeMarkup(cellAbsolutePos, null, attrs);
            }
          }
          return true;
        }).run();
      },
      /**
       * Add a column after the current column
       * @category Command
       * @returns {Function} Command
       * @example
       * addColumnAfter()
       * @note Preserves cell attributes from current column
       */
      addColumnAfter: () => ({ state, dispatch, chain }) => {
        if (!addColumnAfter(state)) return false;
        let { rect, attrs: currentCellAttrs } = getCurrentCellAttrs(state);
        return chain().command(() => addColumnAfter(state, dispatch)).command(({ tr }) => {
          let table = tr.doc.nodeAt(rect.tableStart - 1);
          if (!table) return false;
          let updatedMap = TableMap.get(table);
          let newColumnIndex = rect.left + 1;
          if (newColumnIndex < 0 || newColumnIndex >= updatedMap.width) {
            return false;
          }
          for (let row = 0; row < updatedMap.height; row++) {
            let cellIndex = row * updatedMap.width + newColumnIndex;
            let cellPos = updatedMap.map[cellIndex];
            let cellAbsolutePos = rect.tableStart + cellPos;
            let cell = tr.doc.nodeAt(cellAbsolutePos);
            if (cell) {
              let attrs = {
                ...currentCellAttrs,
                colspan: cell.attrs.colspan,
                rowspan: cell.attrs.rowspan,
                colwidth: cell.attrs.colwidth
              };
              tr.setNodeMarkup(cellAbsolutePos, null, attrs);
            }
          }
          return true;
        }).run();
      },
      /**
       * Delete the column containing the cursor
       * @category Command
       * @returns {Function} Command
       * @example
       * deleteColumn()
       */
      deleteColumn: () => ({ state, dispatch }) => {
        return deleteColumn(state, dispatch);
      },
      /**
       * Add a row before the current row
       * @category Command
       * @returns {Function} Command
       * @example
       * addRowBefore()
       * @note Preserves cell attributes from current row
       */
      addRowBefore: () => ({ state, dispatch, editor }) => {
        if (!isInTable$1(state)) return false;
        const { rect } = getCurrentCellAttrs(state);
        const tablePos = rect.tableStart - 1;
        const tableNode = state.doc.nodeAt(tablePos);
        if (!tableNode) return false;
        const tr = state.tr;
        const result = insertRowAtIndex({
          tr,
          tablePos,
          tableNode,
          sourceRowIndex: rect.top,
          insertIndex: rect.top,
          schema: editor.schema
        });
        if (result && dispatch) dispatch(tr);
        return result;
      },
      /**
       * Add a row after the current row
       * @category Command
       * @returns {Function} Command
       * @example
       * addRowAfter()
       * @note Preserves cell attributes from current row
       */
      addRowAfter: () => ({ state, dispatch, editor }) => {
        if (!isInTable$1(state)) return false;
        const { rect } = getCurrentCellAttrs(state);
        const tablePos = rect.tableStart - 1;
        const tableNode = state.doc.nodeAt(tablePos);
        if (!tableNode) return false;
        const tr = state.tr;
        const result = insertRowAtIndex({
          tr,
          tablePos,
          tableNode,
          sourceRowIndex: rect.top,
          insertIndex: rect.top + 1,
          schema: editor.schema
        });
        if (result && dispatch) dispatch(tr);
        return result;
      },
      /**
       * Delete the row containing the cursor
       * @category Command
       * @returns {Function} Command
       * @example
       * deleteRow()
       */
      deleteRow: () => ({ state, dispatch }) => {
        return deleteRow(state, dispatch);
      },
      /**
       * Merge selected cells into one
       * @category Command
       * @returns {Function} Command
       * @example
       * mergeCells()
       * @note Content from all cells is preserved
       */
      mergeCells: () => ({ state, dispatch }) => {
        return mergeCells(state, dispatch);
      },
      /**
       * Split a merged cell back into individual cells
       * @category Command
       * @returns {Function} Command - true if split, false if position invalid
       * @example
       * splitCell()
       */
      splitCell: () => ({ state, dispatch, commands: commands2 }) => {
        if (splitCell(state, dispatch)) {
          return true;
        }
        return commands2.splitSingleCell();
      },
      /**
       * Split a single unmerged cell into two cells horizontally
       * @category Command
       * @returns {Function} Command - true if split, false if position invalid
       * @example
       * splitSingleCell()
       * @note This command splits a single cell (not merged) into two cells by:
       * - Dividing the cell width in half
       * - Inserting a new cell to the right
       * - Adjusting colspan for cells in other rows that span this column
       * - Only works on cells with colspan=1 and rowspan=1
       * @note Different from splitCell which splits merged cells back to original cells
       */
      splitSingleCell: () => ({ state, dispatch, tr }) => {
        const sel = state.selection;
        let cellNode;
        let cellPos;
        if (!(sel instanceof CellSelection)) {
          cellNode = cellWrapping(sel.$from);
          if (!cellNode) return false;
          cellPos = cellAround(sel.$from)?.pos;
        } else {
          if (sel.$anchorCell.pos != sel.$headCell.pos) return false;
          cellNode = sel.$anchorCell.nodeAfter;
          cellPos = sel.$anchorCell.pos;
        }
        if (cellNode == null || cellPos == null) {
          return false;
        }
        if (cellNode.attrs.colspan != 1 || cellNode.attrs.rowspan != 1) {
          return false;
        }
        if (dispatch) {
          let rect = selectedRect(state);
          let currentRow = rect.top;
          let currentCol = rect.left;
          let baseAttrs = { ...cellNode.attrs };
          let currentColWidth2 = baseAttrs.colwidth;
          let newCellWidth = null;
          if (currentColWidth2 && currentColWidth2[0]) {
            newCellWidth = Math.ceil(currentColWidth2[0] / 2);
          }
          if (newCellWidth) {
            tr.setNodeMarkup(tr.mapping.map(cellPos, 1), null, { ...baseAttrs, colwidth: [newCellWidth] });
          }
          const newCellAttrs = { ...baseAttrs, colwidth: newCellWidth ? [newCellWidth] : null };
          const newCell = getCellType({ node: cellNode, state }).createAndFill(newCellAttrs);
          tr.insert(tr.mapping.map(cellPos + cellNode.nodeSize, 1), newCell);
          for (let row = 0; row < rect.map.height; row++) {
            if (row === currentRow) continue;
            let rowCells = /* @__PURE__ */ new Set();
            for (let col = 0; col < rect.map.width; col++) {
              let cellIndex = rect.map.map[row * rect.map.width + col];
              if (cellIndex != null) rowCells.add(cellIndex);
            }
            [...rowCells].forEach((cellIndex) => {
              let cellRect = rect.map.findCell(cellIndex);
              if (cellRect.left <= currentCol && cellRect.right > currentCol) {
                let cellPos2 = tr.mapping.map(rect.tableStart + cellIndex, 1);
                let cell = tr.doc.nodeAt(cellPos2);
                if (cell) {
                  let newColspan = (cell.attrs.colspan || 1) + 1;
                  let updatedColwidth = cell.attrs.colwidth;
                  if (updatedColwidth && newCellWidth) {
                    let originalColIndex = currentCol - cellRect.left;
                    updatedColwidth = [
                      ...updatedColwidth.slice(0, originalColIndex),
                      newCellWidth,
                      // current cell width
                      newCellWidth,
                      // new cell width
                      ...updatedColwidth.slice(originalColIndex + 1)
                    ];
                  }
                  let cellAttrs = { ...cell.attrs, colspan: newColspan, colwidth: updatedColwidth };
                  tr.setNodeMarkup(cellPos2, null, cellAttrs);
                }
              }
            });
          }
        }
        return true;
      },
      /**
       * Toggle between merge and split cells based on selection
       * @category Command
       * @returns {Function} Command
       * @example
       * mergeOrSplit()
       * @note Merges if multiple cells selected, splits if merged cell selected
       */
      mergeOrSplit: () => ({ state, dispatch, commands: commands2 }) => {
        if (mergeCells(state, dispatch)) {
          return true;
        }
        return commands2.splitCell();
      },
      /**
       * Toggle the first column as header column
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleHeaderColumn()
       */
      toggleHeaderColumn: () => ({ state, dispatch }) => {
        return toggleHeader("column")(state, dispatch);
      },
      /**
       * Toggle the first row as header row
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleHeaderRow()
       */
      toggleHeaderRow: () => ({ state, dispatch }) => {
        return toggleHeader("row")(state, dispatch);
      },
      /**
       * Toggle current cell as header cell
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleHeaderCell()
       */
      toggleHeaderCell: () => ({ state, dispatch }) => {
        return toggleHeaderCell(state, dispatch);
      },
      /**
       * Set an attribute on selected cells
       * @category Command
       * @param {string} name - Attribute name
       * @param {*} value - Attribute value
       * @returns {Function} Command
       * @example
       * setCellAttr('background', { color: 'ff0000' })
       * setCellAttr('verticalAlign', 'middle')
       */
      setCellAttr: (name, value) => ({ state, dispatch }) => {
        return setCellAttr(name, value)(state, dispatch);
      },
      /**
       * Navigate to the next cell (Tab behavior)
       * @category Command
       * @returns {Function} Command
       * @example
       * goToNextCell()
       */
      goToNextCell: () => ({ state, dispatch }) => {
        return goToNextCell(1)(state, dispatch);
      },
      /**
       * Navigate to the previous cell (Shift+Tab behavior)
       * @category Command
       * @returns {Function} Command
       * @example
       * goToPreviousCell()
       */
      goToPreviousCell: () => ({ state, dispatch }) => {
        return goToNextCell(-1)(state, dispatch);
      },
      /**
       * Fix table structure inconsistencies
       * @category Command
       * @returns {Function} Command
       * @example
       * fixTables()
       * @note Repairs malformed tables and normalizes structure
       */
      fixTables: () => ({ state, dispatch }) => {
        if (dispatch) {
          fixTables(state);
        }
        return true;
      },
      /**
       * Set cell selection programmatically
       * @category Command
       * @param {CellSelectionPosition} pos - Cell selection coordinates
       * @returns {Function} Command
       * @example
       * setCellSelection({ anchorCell: 10, headCell: 15 })
       */
      setCellSelection: (pos) => ({ tr, dispatch }) => {
        if (dispatch) {
          tr.setSelection(CellSelection.create(tr.doc, pos.anchorCell, pos.headCell));
        }
        return true;
      },
      /**
       * Set background color for selected cells
       * @category Command
       * @param {string} value - Color value (hex with or without #)
       * @example
       * editor.commands.setCellBackground('#ff0000')
       * editor.commands.setCellBackground('ff0000')
       */
      setCellBackground: (value) => ({ editor, commands: commands2, dispatch }) => {
        const { selection } = editor.state;
        if (!isCellSelection(selection)) {
          return false;
        }
        const color = value?.startsWith("#") ? value.slice(1) : value;
        if (dispatch) {
          return commands2.setCellAttr("background", { color });
        }
        return true;
      },
      /**
       * Remove all borders from table and its cells
       * @category Command
       * @returns {Function} Command
       * @example
       * deleteCellAndTableBorders()
       * @note Sets all border sizes to 0
       */
      deleteCellAndTableBorders: () => ({ state, tr }) => {
        if (!isInTable$1(state)) {
          return false;
        }
        const table = superEditor_converter.findParentNode((node) => node.type.name === this.name)(state.selection);
        if (!table) {
          return false;
        }
        const from3 = table.pos;
        const to = table.pos + table.node.nodeSize;
        state.doc.nodesBetween(from3, to, (node, pos) => {
          if (["tableCell", "tableHeader"].includes(node.type.name)) {
            tr.setNodeMarkup(pos, void 0, {
              ...node.attrs,
              borders: createCellBorders({ size: 0, space: 0, val: "none", color: "auto" })
            });
          }
        });
        tr.setNodeMarkup(table.pos, void 0, {
          ...table.node.attrs,
          borders: createTableBorders({ size: 0 }),
          // TODO: This works around the issue that table borders are duplicated between
          // the attributes of the table and the tableProperties attribute.
          // This can be removed when the redundancy is eliminated.
          tableProperties: {
            ...table.node.attrs.tableProperties,
            borders: createTableBorders({ size: 0, space: 0, val: "none", color: "auto" })
          }
        });
        return true;
      }
    };
  },
  addShortcuts() {
    return {
      Tab: () => {
        if (this.editor.commands.goToNextCell()) {
          return true;
        }
        if (!this.editor.can().addRowAfter()) {
          return false;
        }
        return this.editor.chain().addRowAfter().goToNextCell().run();
      },
      "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
      Backspace: deleteTableWhenSelected,
      "Mod-Backspace": deleteTableWhenSelected,
      Delete: deleteTableWhenSelected,
      "Mod-Delete": deleteTableWhenSelected
    };
  },
  addPmPlugins() {
    const resizable = this.options.resizable && this.editor.isEditable;
    return [
      ...resizable ? [
        columnResizing({
          // Disable PM's visual handles (custom overlay handles resizing)
          // Set to 0 to prevent PM from rendering its own resize handles
          // while keeping transaction helpers and constraint logic
          // @ts-expect-error - Options types will be fixed in TS migration
          handleWidth: 0,
          // @ts-expect-error - Options types will be fixed in TS migration
          cellMinWidth: this.options.cellMinWidth,
          // @ts-expect-error - Options types will be fixed in TS migration
          defaultCellMinWidth: this.options.cellMinWidth,
          // @ts-expect-error - Options types will be fixed in TS migration
          lastColumnResizable: this.options.lastColumnResizable,
          View: createTableView({
            editor: this.editor
          })
        })
      ] : [],
      tableEditing({
        // @ts-expect-error - Options types will be fixed in TS migration
        allowTableNodeSelection: this.options.allowTableNodeSelection
      })
    ];
  },
  extendNodeSchema(extension) {
    return {
      tableRole: callOrGet(
        getExtensionConfigField(extension, "tableRole", {
          name: extension.name,
          options: extension.options,
          storage: extension.storage
        })
      )
    };
  }
});
function getCellType({ node, state }) {
  const nodeTypes = tableNodeTypes(state.schema);
  return nodeTypes[node.type.spec.tableRole];
}
function copyCellAttrs(node) {
  const { colspan: _colspan, rowspan: _rowspan, colwidth: _colwidth, ...attrs } = node.attrs;
  return attrs;
}
function getCurrentCellAttrs(state) {
  let rect = selectedRect(state);
  let index2 = rect.top * rect.map.width + rect.left;
  let pos = rect.map.map[index2];
  let cell = rect.table.nodeAt(pos);
  let attrs = copyCellAttrs(cell);
  return { rect, cell, attrs };
}
const TableHeader = Node$1.create({
  name: "tableHeader",
  content: "block+",
  tableRole: "header_cell",
  isolating: true,
  addOptions() {
    return {
      htmlAttributes: {
        "aria-label": "Table head node"
      }
    };
  },
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: null,
        parseDOM: (element) => {
          const colwidth = element.getAttribute("data-colwidth");
          const value = colwidth ? colwidth.split(",").map((width) => parseInt(width, 10)) : null;
          return value;
        },
        renderDOM: (attrs) => {
          if (!attrs.colwidth) return {};
          return {
            // @ts-expect-error - colwidth is known to be an array at runtime
            "data-colwidth": attrs.colwidth.join(",")
          };
        }
      },
      __placeholder: {
        default: null,
        parseDOM: (element) => {
          const value = element.getAttribute("data-placeholder");
          return value || null;
        },
        renderDOM({ __placeholder }) {
          if (!__placeholder) return {};
          return {
            "data-placeholder": __placeholder
          };
        }
      }
    };
  },
  parseDOM() {
    return [{ tag: "th" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["th", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  }
});
const TableRow = Node$1.create({
  name: "tableRow",
  content: "(tableCell | tableHeader)*",
  tableRole: "row",
  addOptions() {
    return {
      htmlAttributes: {
        "aria-label": "Table row node"
      }
    };
  },
  addAttributes() {
    return {
      rowHeight: {
        renderDOM({ rowHeight }) {
          if (!rowHeight) return {};
          const style2 = `height: ${rowHeight}px`;
          return { style: style2 };
        }
      },
      cantSplit: {
        default: false,
        parseDOM() {
          return {};
        },
        renderDOM({ cantSplit }) {
          if (!cantSplit) return {};
          return { "data-cant-split": "true" };
        }
      },
      /**
       * @see {@link https://ecma-international.org/publications-and-standards/standards/ecma-376/} "Fundamentals And Markup Language Reference", page 377-482
       */
      tableRowProperties: { rendered: false },
      /**
       * @see {@link https://ecma-international.org/publications-and-standards/standards/ecma-376/} "Fundamentals And Markup Language Reference", page 472
       */
      rsidDel: { rendered: false },
      /**
       * @see {@link https://ecma-international.org/publications-and-standards/standards/ecma-376/} "Fundamentals And Markup Language Reference", page 472
       */
      rsidR: { rendered: false },
      /**
       * @see {@link https://ecma-international.org/publications-and-standards/standards/ecma-376/} "Fundamentals And Markup Language Reference", page 473
       */
      rsidRPr: { rendered: false },
      /**
       * @see {@link https://ecma-international.org/publications-and-standards/standards/ecma-376/} "Fundamentals And Markup Language Reference", page 473
       */
      rsidTr: { rendered: false },
      /**
       * @see {@link https://learn.microsoft.com/en-us/openspecs/office_standards/ms-docx/a0e7d2e2-2246-44c6-96e8-1cf009823615}
       */
      paraId: { rendered: false },
      /**
       * @see {@link https://learn.microsoft.com/en-us/openspecs/office_standards/ms-docx/b7eeddec-7c50-47fb-88b6-1feec3ed832c}
       */
      textId: { rendered: false }
    };
  },
  parseDOM() {
    return [{ tag: "tr" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["tr", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  }
});
const TableCell = Node$1.create({
  name: "tableCell",
  content: "block+",
  tableRole: "cell",
  isolating: true,
  addOptions() {
    return {
      htmlAttributes: {
        "aria-label": "Table cell node"
      }
    };
  },
  addAttributes() {
    return {
      colspan: {
        default: 1
      },
      rowspan: {
        default: 1
      },
      colwidth: {
        default: [100],
        parseDOM: (elem) => {
          const colwidth = elem.getAttribute("data-colwidth");
          const value = colwidth ? colwidth.split(",").map((width) => parseInt(width, 10)) : null;
          return value;
        },
        renderDOM: (attrs) => {
          if (!attrs.colwidth) return {};
          return {
            // @ts-expect-error - colwidth is known to be an array at runtime
            "data-colwidth": attrs.colwidth.join(",")
          };
        }
      },
      background: {
        renderDOM({ background }) {
          if (!background) return {};
          const { color } = background || {};
          const style2 = `background-color: ${color ? `#${color}` : "transparent"}`;
          return { style: style2 };
        }
      },
      verticalAlign: {
        renderDOM({ verticalAlign }) {
          if (!verticalAlign) return {};
          const style2 = `vertical-align: ${verticalAlign}`;
          return { style: style2 };
        }
      },
      cellMargins: {
        renderDOM({ cellMargins, borders }) {
          if (!cellMargins) return {};
          const sides = ["top", "right", "bottom", "left"];
          const style2 = sides.map((side) => {
            const margin = cellMargins?.[side] ?? 0;
            const border = borders?.[side];
            const borderSize = border && border.val !== "none" ? Math.ceil(border.size) : 0;
            if (margin) return `padding-${side}: ${Math.max(0, margin - borderSize)}px;`;
            return "";
          }).join(" ");
          return { style: style2 };
        }
      },
      borders: {
        default: () => createCellBorders(),
        renderDOM({ borders }) {
          if (!borders) return {};
          const sides = ["top", "right", "bottom", "left"];
          const style2 = sides.map((side) => {
            const border = borders?.[side];
            if (border && border.val === "none") return `border-${side}: ${border.val};`;
            let color = border?.color || "black";
            if (color === "auto") color = "black";
            if (border) return `border-${side}: ${Math.ceil(border.size)}px solid ${color};`;
            return "";
          }).join(" ");
          return { style: style2 };
        }
      },
      widthType: {
        default: "auto",
        rendered: false
      },
      widthUnit: {
        default: "px",
        rendered: false
      },
      __placeholder: {
        default: null,
        parseDOM: (element) => {
          const value = element.getAttribute("data-placeholder");
          return value || null;
        },
        renderDOM({ __placeholder }) {
          if (!__placeholder) return {};
          return {
            "data-placeholder": __placeholder
          };
        }
      },
      /**
       * @category Attribute
       * @param {TableCellProperties} tableCellProperties - Properties for the table cell.
       * @see {@link https://ecma-international.org/publications-and-standards/standards/ecma-376/} "Fundamentals And Markup Language Reference", page 463
       */
      tableCellProperties: {
        default: null,
        rendered: false
      }
    };
  },
  parseDOM() {
    return [{ tag: "td" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["td", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  }
});
class FieldAnnotationView {
  editor;
  node;
  decorations;
  getPos;
  htmlAttributes;
  dom;
  annotationClass;
  annotationContentClass;
  borderColor;
  constructor(options) {
    this.editor = options.editor;
    this.node = options.node;
    this.decorations = options.decorations;
    this.getPos = options.getPos;
    this.htmlAttributes = options.htmlAttributes;
    this.annotationClass = options.annotationClass;
    this.annotationContentClass = options.annotationContentClass;
    this.borderColor = options.borderColor;
    this.handleAnnotationClick = this.handleAnnotationClick.bind(this);
    this.handleAnnotationDoubleClick = this.handleAnnotationDoubleClick.bind(this);
    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);
    this.buildView();
    this.attachEventListeners();
  }
  buildView() {
    let { type } = this.node.attrs;
    let handlers2 = {
      text: (...args) => this.buildTextView(...args),
      image: (...args) => this.buildImageView(...args),
      signature: (...args) => this.buildSignatureView(...args),
      checkbox: (...args) => this.buildCheckboxView(...args),
      html: (...args) => this.buildHTMLView(...args),
      link: (...args) => this.buildLinkView(...args),
      default: (...args) => this.buildTextView(...args)
    };
    let buildHandler = handlers2[type] ?? handlers2.default;
    buildHandler();
  }
  buildTextView() {
    let { displayLabel } = this.node.attrs;
    let { annotation } = this.#createAnnotation({
      displayLabel
    });
    this.dom = annotation;
  }
  buildImageView() {
    let { displayLabel, imageSrc } = this.node.attrs;
    let { annotation, content } = this.#createAnnotation();
    if (imageSrc) {
      let img = document.createElement("img");
      img.src = imageSrc;
      img.alt = displayLabel;
      img.style.height = "auto";
      img.style.maxWidth = "100%";
      img.style.pointerEvents = "none";
      img.style.verticalAlign = "middle";
      content.append(img);
      annotation.style.display = "inline-block";
      content.style.display = "inline-block";
    } else {
      content.textContent = displayLabel;
    }
    this.dom = annotation;
  }
  buildSignatureView() {
    let { displayLabel, imageSrc } = this.node.attrs;
    displayLabel = displayLabel || "Signature";
    let { annotation, content } = this.#createAnnotation();
    if (imageSrc) {
      let img = document.createElement("img");
      img.src = imageSrc;
      img.alt = displayLabel;
      img.style.height = "auto";
      img.style.maxWidth = "100%";
      img.style.maxHeight = "28px";
      img.style.pointerEvents = "none";
      img.style.verticalAlign = "middle";
      content.append(img);
      annotation.style.display = "inline-block";
      content.style.display = "inline-block";
    } else {
      content.textContent = displayLabel;
    }
    this.dom = annotation;
  }
  buildCheckboxView() {
    let { displayLabel } = this.node.attrs;
    let { annotation } = this.#createAnnotation({
      displayLabel
    });
    this.dom = annotation;
  }
  buildHTMLView() {
    let { displayLabel, rawHtml } = this.node.attrs;
    if (!this.editor.options.isHeadless && !!rawHtml) {
      try {
        const tempDiv = document.createElement("div");
        const childEditor = this.editor.createChildEditor({
          element: tempDiv,
          html: rawHtml
        });
        rawHtml = childEditor.view.dom.innerHTML;
      } catch (error) {
        console.warn("Error parsing HTML in FieldAnnotationView:", error);
      }
    }
    let { annotation, content } = this.#createAnnotation();
    if (rawHtml) {
      content.innerHTML = rawHtml.trim();
      annotation.style.display = "inline-block";
      content.style.display = "inline-block";
    } else {
      content.textContent = displayLabel;
    }
    this.dom = annotation;
  }
  buildLinkView() {
    let { displayLabel, linkUrl } = this.node.attrs;
    let { annotation, content } = this.#createAnnotation();
    if (linkUrl) {
      let link = document.createElement("a");
      link.href = linkUrl;
      link.target = "_blank";
      link.textContent = linkUrl;
      link.style.textDecoration = "none";
      content.append(link);
      content.style.pointerEvents = "all";
    } else {
      content.textContent = displayLabel;
    }
    this.dom = annotation;
  }
  #createAnnotation({ displayLabel } = {}) {
    let { highlighted } = this.node.attrs;
    let annotation = document.createElement("span");
    annotation.classList.add(this.annotationClass);
    let content = document.createElement("span");
    content.classList.add(this.annotationContentClass);
    content.style.pointerEvents = "none";
    content.contentEditable = "false";
    if (displayLabel) {
      content.textContent = displayLabel;
    }
    annotation.append(content);
    let omitHighlight = highlighted === false;
    let styles = [
      `border: 2px solid ${this.borderColor}`,
      `border-radius: 2px`,
      `padding: 1px 2px`,
      `box-sizing: border-box`
    ];
    let annotationStyle = styles.join("; ");
    let mergedAttrs = Attribute.mergeAttributes(this.htmlAttributes, {
      style: omitHighlight ? "" : annotationStyle
    });
    for (let [key2, value] of Object.entries(mergedAttrs)) {
      if (key2 === "style") {
        annotation.style.cssText = value;
      } else {
        annotation.setAttribute(key2, value);
      }
    }
    return {
      annotation,
      content
    };
  }
  attachEventListeners() {
    this.dom.addEventListener("click", this.handleAnnotationClick);
    this.dom.addEventListener("dblclick", this.handleAnnotationDoubleClick);
    this.editor.on("selectionUpdate", this.handleSelectionUpdate);
  }
  removeEventListeners() {
    this.dom.removeEventListener("click", this.handleAnnotationClick);
    this.dom.removeEventListener("dblclick", this.handleAnnotationDoubleClick);
    this.editor.off("selectionUpdate", this.handleSelectionUpdate);
  }
  handleSelectionUpdate({ editor }) {
    if (!this.editor.isEditable) {
      return;
    }
    let { selection } = editor.state;
    if (selection instanceof superEditor_converter.NodeSelection) {
      let currentNode = selection.node;
      if (this.node.eq(currentNode)) {
        this.editor.emit("fieldAnnotationSelected", {
          editor: this.editor,
          node: this.node,
          nodePos: this.getPos(),
          target: this.dom
        });
      }
    }
  }
  handleAnnotationClick(event) {
    if (!this.editor.isEditable) {
      return;
    }
    this.editor.emit("fieldAnnotationClicked", {
      editor: this.editor,
      node: this.node,
      nodePos: this.getPos(),
      event,
      currentTarget: event.currentTarget
    });
  }
  handleAnnotationDoubleClick(event) {
    if (!this.editor.isEditable) {
      return;
    }
    this.editor.emit("fieldAnnotationDoubleClicked", {
      editor: this.editor,
      node: this.node,
      nodePos: this.getPos(),
      event,
      currentTarget: event.currentTarget
    });
  }
  stopEvent(event) {
    if (!this.editor.isEditable) {
      event.preventDefault();
      return true;
    }
    return false;
  }
  // Can be used to manually update the NodeView.
  // Otherwise the NodeView is recreated.
  update() {
    return false;
  }
  ignoreMutation() {
    return true;
  }
  destroy() {
    this.removeEventListeners();
  }
  updateAttributes(attributes) {
    this.editor.commands.command(({ tr }) => {
      tr.setNodeMarkup(this.getPos(), void 0, {
        ...this.node.attrs,
        ...attributes
      });
      return true;
    });
  }
}
const mergeRanges = (ranges) => {
  if (ranges.length === 0) return [];
  const sorted = [...ranges].sort((a, b2) => a[0] - b2[0]).map((range) => [...range]);
  const merged = [sorted[0]];
  for (let i = 1; i < sorted.length; i++) {
    const current = sorted[i];
    const lastMerged = merged[merged.length - 1];
    if (current[0] <= lastMerged[1]) {
      lastMerged[1] = Math.max(lastMerged[1], current[1]);
    } else {
      merged.push(current);
    }
  }
  return merged;
};
const clampRange = (start2, end2, docSize) => {
  const safeStart = Math.max(0, Math.min(start2, docSize));
  const safeEnd = Math.max(0, Math.min(end2, docSize));
  if (safeStart >= safeEnd) {
    return null;
  }
  return [safeStart, safeEnd];
};
const FieldAnnotationPlugin = (options = {}) => {
  let { editor, annotationClass: annotationClass2 } = options;
  return new superEditor_converter.Plugin({
    key: new superEditor_converter.PluginKey("fieldAnnotation"),
    state: {
      init() {
        return null;
      },
      apply(tr, prevState) {
        trackFieldAnnotationsDeletion(editor, tr);
        return prevState;
      }
    },
    props: {
      handleDrop(view, event, slice2, moved) {
        if (moved) return false;
        let fieldAnnotation = event?.dataTransfer.getData("fieldAnnotation");
        if (fieldAnnotation) {
          if (options.handleDropOutside) {
            handleDropOutside({
              fieldAnnotation,
              editor,
              view,
              event
            });
          } else {
            let annotationAttrs;
            try {
              let fieldAnnotationObj = JSON.parse(fieldAnnotation);
              annotationAttrs = fieldAnnotationObj.attributes;
            } catch {
              return false;
            }
            const coordinates = view.posAtCoords({
              left: event.clientX,
              top: event.clientY
            });
            if (coordinates) {
              editor.commands.addFieldAnnotation(coordinates.pos, {
                ...annotationAttrs
              });
            }
          }
          return true;
        }
        return false;
      },
      handlePaste(view, event, slice2) {
        const content = slice2.content.content.filter((item) => item.type.name === "fieldAnnotation");
        if (content.length) {
          editor.emit("fieldAnnotationPaste", {
            content,
            editor
          });
        }
        return false;
      },
      handleDOMEvents: {
        dragstart: (view, event) => {
          if (!event.target) return false;
          let { target } = event;
          let isAnnotationField = target.classList?.contains(annotationClass2);
          if (isAnnotationField) {
            event.dataTransfer?.setDragImage(target, 0, 0);
          }
          return false;
        }
        // drop: (view, event) => {
        //   console.log({ view, event });
        // },
      }
    },
    /// For y-prosemirror support.
    appendTransaction: (transactions, oldState, newState) => {
      const docChanges = transactions.some((tr2) => tr2.docChanged) && !oldState.doc.eq(newState.doc);
      if (!docChanges) {
        return;
      }
      const affectedRanges = [];
      let hasFieldAnnotationsInSlice = false;
      let hasSteps = false;
      transactions.forEach((transaction) => {
        if (!transaction.steps) return;
        hasSteps = true;
        transaction.steps.forEach((step) => {
          if (step.slice?.content) {
            step.slice.content.descendants((node) => {
              if (node.type.name === "fieldAnnotation") {
                hasFieldAnnotationsInSlice = true;
                return false;
              }
            });
          }
          if (typeof step.from === "number" && typeof step.to === "number") {
            const from3 = step.from;
            const to = step.from === step.to && step.slice?.size ? step.from + step.slice.size : step.to;
            affectedRanges.push([from3, to]);
          }
        });
      });
      if (hasSteps && !hasFieldAnnotationsInSlice && affectedRanges.length > 0) {
        const mergedRanges = mergeRanges(affectedRanges);
        let hasExistingAnnotations = false;
        for (const [start2, end2] of mergedRanges) {
          const clampedRange = clampRange(start2, end2, newState.doc.content.size);
          if (!clampedRange) continue;
          const [validStart, validEnd] = clampedRange;
          try {
            newState.doc.nodesBetween(validStart, validEnd, (node) => {
              if (node.type.name === "fieldAnnotation") {
                hasExistingAnnotations = true;
                return false;
              }
            });
          } catch (error) {
            console.warn("FieldAnnotationPlugin: range check failed, assuming annotations exist", error);
            hasExistingAnnotations = true;
            break;
          }
          if (hasExistingAnnotations) break;
        }
        if (!hasExistingAnnotations) {
          return;
        }
      }
      const { tr } = newState;
      let changed = false;
      const removeMarksFromAnnotation = (node, pos) => {
        const { marks } = node;
        const currentNode = tr.doc.nodeAt(pos);
        if (marks.length > 0 && node.eq(currentNode)) {
          tr.removeMark(pos, pos + node.nodeSize, null);
          changed = true;
        }
      };
      if (affectedRanges.length > 0) {
        const mergedRanges = mergeRanges(affectedRanges);
        let shouldFallbackToFullScan = false;
        for (const [start2, end2] of mergedRanges) {
          const clampedRange = clampRange(start2, end2, newState.doc.content.size);
          if (!clampedRange) continue;
          const [validStart, validEnd] = clampedRange;
          try {
            newState.doc.nodesBetween(validStart, validEnd, (node, pos) => {
              if (node.type.name === "fieldAnnotation") {
                removeMarksFromAnnotation(node, pos);
              }
            });
          } catch (error) {
            console.warn("FieldAnnotationPlugin: nodesBetween failed, falling back to full scan", error);
            shouldFallbackToFullScan = true;
            break;
          }
        }
        if (shouldFallbackToFullScan) {
          const annotations = getAllFieldAnnotations(newState);
          if (!annotations.length) {
            return changed ? tr : null;
          }
          annotations.forEach(({ node, pos }) => {
            removeMarksFromAnnotation(node, pos);
          });
        }
      } else {
        const annotations = getAllFieldAnnotations(newState);
        if (!annotations.length) {
          return;
        }
        annotations.forEach(({ node, pos }) => {
          removeMarksFromAnnotation(node, pos);
        });
      }
      return changed ? tr : null;
    }
    ///
  });
};
function handleDropOutside({ fieldAnnotation, editor, view, event }) {
  let sourceField;
  try {
    let fieldAnnotationObj = JSON.parse(fieldAnnotation);
    sourceField = fieldAnnotationObj.sourceField;
  } catch {
    return;
  }
  let coordinates = view.posAtCoords({
    left: event.clientX,
    top: event.clientY
  });
  if (coordinates) {
    editor.emit("fieldAnnotationDropped", {
      sourceField,
      editor,
      coordinates,
      pos: coordinates.pos
    });
  }
}
function guard(low, high, value) {
  return Math.min(Math.max(low, value), high);
}
class ColorError extends Error {
  constructor(color) {
    super(`Failed to parse color: "${color}"`);
  }
}
var ColorError$1 = ColorError;
function parseToRgba(color) {
  if (typeof color !== "string") throw new ColorError$1(color);
  if (color.trim().toLowerCase() === "transparent") return [0, 0, 0, 0];
  let normalizedColor = color.trim();
  normalizedColor = namedColorRegex.test(color) ? nameToHex(color) : color;
  const reducedHexMatch = reducedHexRegex.exec(normalizedColor);
  if (reducedHexMatch) {
    const arr = Array.from(reducedHexMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(r(x, 2), 16)), parseInt(r(arr[3] || "f", 2), 16) / 255];
  }
  const hexMatch = hexRegex$1.exec(normalizedColor);
  if (hexMatch) {
    const arr = Array.from(hexMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(x, 16)), parseInt(arr[3] || "ff", 16) / 255];
  }
  const rgbaMatch = rgbaRegex$1.exec(normalizedColor);
  if (rgbaMatch) {
    const arr = Array.from(rgbaMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(x, 10)), parseFloat(arr[3] || "1")];
  }
  const hslaMatch = hslaRegex$1.exec(normalizedColor);
  if (hslaMatch) {
    const [h2, s, l, a] = Array.from(hslaMatch).slice(1).map(parseFloat);
    if (guard(0, 100, s) !== s) throw new ColorError$1(color);
    if (guard(0, 100, l) !== l) throw new ColorError$1(color);
    return [...hslToRgb(h2, s, l), Number.isNaN(a) ? 1 : a];
  }
  throw new ColorError$1(color);
}
function hash$2(str) {
  let hash2 = 5381;
  let i = str.length;
  while (i) {
    hash2 = hash2 * 33 ^ str.charCodeAt(--i);
  }
  return (hash2 >>> 0) % 2341;
}
const colorToInt = (x) => parseInt(x.replace(/_/g, ""), 36);
const compressedColorMap = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((acc, next) => {
  const key2 = colorToInt(next.substring(0, 3));
  const hex2 = colorToInt(next.substring(3)).toString(16);
  let prefix2 = "";
  for (let i = 0; i < 6 - hex2.length; i++) {
    prefix2 += "0";
  }
  acc[key2] = `${prefix2}${hex2}`;
  return acc;
}, {});
function nameToHex(color) {
  const normalizedColorName = color.toLowerCase().trim();
  const result = compressedColorMap[hash$2(normalizedColorName)];
  if (!result) throw new ColorError$1(color);
  return `#${result}`;
}
const r = (str, amount) => Array.from(Array(amount)).map(() => str).join("");
const reducedHexRegex = new RegExp(`^#${r("([a-f0-9])", 3)}([a-f0-9])?$`, "i");
const hexRegex$1 = new RegExp(`^#${r("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i");
const rgbaRegex$1 = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${r(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i");
const hslaRegex$1 = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i;
const namedColorRegex = /^[a-z]+$/i;
const roundColor = (color) => {
  return Math.round(color * 255);
};
const hslToRgb = (hue, saturation, lightness) => {
  let l = lightness / 100;
  if (saturation === 0) {
    return [l, l, l].map(roundColor);
  }
  const huePrime = (hue % 360 + 360) % 360 / 60;
  const chroma = (1 - Math.abs(2 * l - 1)) * (saturation / 100);
  const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
  let red = 0;
  let green = 0;
  let blue = 0;
  if (huePrime >= 0 && huePrime < 1) {
    red = chroma;
    green = secondComponent;
  } else if (huePrime >= 1 && huePrime < 2) {
    red = secondComponent;
    green = chroma;
  } else if (huePrime >= 2 && huePrime < 3) {
    green = chroma;
    blue = secondComponent;
  } else if (huePrime >= 3 && huePrime < 4) {
    green = secondComponent;
    blue = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    red = secondComponent;
    blue = chroma;
  } else if (huePrime >= 5 && huePrime < 6) {
    red = chroma;
    blue = secondComponent;
  }
  const lightnessModification = l - chroma / 2;
  const finalRed = red + lightnessModification;
  const finalGreen = green + lightnessModification;
  const finalBlue = blue + lightnessModification;
  return [finalRed, finalGreen, finalBlue].map(roundColor);
};
function toHex(color) {
  const [r2, g2, b2, a] = parseToRgba(color);
  let hex2 = (x) => {
    const h2 = guard(0, 255, x).toString(16);
    return h2.length === 1 ? `0${h2}` : h2;
  };
  return `#${hex2(r2)}${hex2(g2)}${hex2(b2)}${a < 1 ? hex2(Math.round(a * 255)) : ""}`;
}
const summarizeListContent = (node, fieldsToDeleteSet) => {
  const summary = {
    totalFieldAnnotations: 0,
    deletableFieldAnnotations: 0,
    hasOtherInlineContent: false
  };
  if (typeof node?.descendants !== "function") {
    return summary;
  }
  node.descendants((child) => {
    if (!child) return true;
    if (child.type?.name === "fieldAnnotation") {
      summary.totalFieldAnnotations += 1;
      const fieldId = child.attrs?.fieldId;
      if (fieldId && fieldsToDeleteSet.has(fieldId)) {
        summary.deletableFieldAnnotations += 1;
      } else {
        summary.hasOtherInlineContent = true;
      }
      return false;
    }
    if (child.isText) {
      if (child.text?.trim()) {
        summary.hasOtherInlineContent = true;
      }
      return false;
    }
    if (child.isInline || child.isAtom) {
      summary.hasOtherInlineContent = true;
      return false;
    }
    return true;
  });
  return summary;
};
const cleanUpListsWithAnnotations = (fieldsToDelete = []) => ({ dispatch, tr, state }) => {
  if (!dispatch) return true;
  if (!Array.isArray(fieldsToDelete)) fieldsToDelete = [fieldsToDelete];
  const fieldsToDeleteSet = new Set(fieldsToDelete);
  const { doc: doc2 } = state;
  const docxAnnotations = getAllFieldAnnotations(state) || [];
  const nodesToDelete = [];
  fieldsToDelete.forEach((fieldId) => {
    const matched = docxAnnotations.find((a) => a.node.attrs.fieldId === fieldId);
    if (!matched) return;
    const listItem = superEditor_converter.findParentNodeClosestToPos(doc2.resolve(matched.pos), superEditor_converter.isList);
    if (!listItem) return;
    const { totalFieldAnnotations, deletableFieldAnnotations, hasOtherInlineContent } = summarizeListContent(
      listItem.node,
      fieldsToDeleteSet
    );
    if (!totalFieldAnnotations) return;
    if (hasOtherInlineContent) return;
    if (totalFieldAnnotations !== deletableFieldAnnotations) return;
    let { pos, node, depth } = listItem;
    let $pos = doc2.resolve(pos);
    while (depth > 0) {
      const parent = $pos.node(depth - 1);
      if (parent.childCount === 1) {
        depth -= 1;
        pos = $pos.before(depth);
        node = parent;
        $pos = doc2.resolve(pos);
      } else {
        break;
      }
    }
    if (!nodesToDelete.some((n) => n.pos === pos)) {
      nodesToDelete.push({ pos, node });
    }
  });
  if (!nodesToDelete.length) return true;
  nodesToDelete.sort((a, b2) => b2.pos - a.pos).forEach(({ pos, node }) => {
    tr.delete(pos, pos + node.nodeSize);
  });
  tr.setMeta("updateListSync", true);
  return true;
};
const cleanUpListsCommands = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cleanUpListsWithAnnotations
}, Symbol.toStringTag, { value: "Module" }));
const cleanUpParagraphWithAnnotations = (fieldsToDelete = []) => ({ dispatch, tr, state }) => {
  if (!dispatch) return true;
  const annotations = (typeof findFieldAnnotationsByFieldId === "function" ? findFieldAnnotationsByFieldId(fieldsToDelete, state) : []) || [];
  const toDelete = /* @__PURE__ */ new Map();
  const sizeOf = (doc2) => doc2.content.size;
  const inRange = (doc2, pos) => Number.isInteger(pos) && pos >= 0 && pos <= sizeOf(doc2);
  for (const annotation of annotations) {
    const origPos = annotation && annotation.pos;
    if (!Number.isInteger(origPos)) continue;
    const mappedPos = tr.mapping.map(origPos, 1);
    if (!inRange(tr.doc, mappedPos)) continue;
    let $pos;
    try {
      $pos = tr.doc.resolve(mappedPos);
    } catch {
      continue;
    }
    const parent = $pos.parent;
    if (!parent) continue;
    if (parent.childCount >= 2) continue;
    const currentNode = tr.doc.nodeAt(mappedPos);
    const annotatedNode = annotation && annotation.node;
    if (!currentNode) continue;
    if (annotatedNode && !annotatedNode.sameMarkup?.(currentNode) && annotatedNode.type !== currentNode.type) {
      continue;
    }
    const parentPos = $pos.before();
    if (!inRange(tr.doc, parentPos)) continue;
    toDelete.set(parentPos, true);
  }
  if (toDelete.size === 0) return true;
  const sorted = [...toDelete.keys()].sort((a, b2) => b2 - a);
  let changed = false;
  for (const originalParentPos of sorted) {
    const mappedParentPos = tr.mapping.map(originalParentPos, -1);
    if (!inRange(tr.doc, mappedParentPos)) continue;
    const targetNode = tr.doc.nodeAt(mappedParentPos);
    if (!targetNode) continue;
    const from3 = mappedParentPos;
    const to = mappedParentPos + targetNode.nodeSize;
    if (!inRange(tr.doc, from3) || !inRange(tr.doc, to) || to <= from3) continue;
    try {
      tr.delete(from3, to);
      changed = true;
    } catch {
      continue;
    }
  }
  if (changed) dispatch(tr);
  return true;
};
const cleanUpParagraphCommands = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cleanUpParagraphWithAnnotations
}, Symbol.toStringTag, { value: "Module" }));
const commands = {
  ...cleanUpListsCommands,
  ...cleanUpParagraphCommands
};
const annotationClass = "annotation";
const annotationContentClass = "annotation-content";
const FieldAnnotation = Node$1.create({
  name: "fieldAnnotation",
  group: "inline",
  inline: true,
  atom: true,
  draggable: true,
  selectable: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: annotationClass,
        "aria-label": "Field annotation node"
      },
      annotationClass,
      annotationContentClass,
      types: ["text", "image", "signature", "checkbox", "html", "link"],
      // annotation types
      defaultType: "text",
      borderColor: "#b015b3",
      visibilityOptions: ["visible", "hidden"],
      handleDropOutside: true,
      /// for y-prosemirror support
      toggleFormatNames: ["bold", "italic", "underline"]
    };
  },
  addAttributes() {
    return {
      type: {
        default: this.options.defaultType,
        parseDOM: (elem) => elem.getAttribute("data-type"),
        renderDOM: (attrs) => {
          if (!attrs.type) return {};
          return {
            "data-type": attrs.type
          };
        }
      },
      defaultDisplayLabel: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-default-display-label"),
        renderDOM: (attrs) => {
          if (!attrs.defaultDisplayLabel) return {};
          return {
            "data-default-display-label": attrs.defaultDisplayLabel
          };
        }
      },
      displayLabel: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-display-label"),
        renderDOM: (attrs) => {
          if (!attrs.displayLabel) return {};
          return {
            "data-display-label": attrs.displayLabel
          };
        }
      },
      imageSrc: {
        default: null,
        rendered: false,
        parseDOM: (elem) => {
          let img = elem.querySelector("img");
          return img?.getAttribute("src") || null;
        }
      },
      rawHtml: {
        default: null,
        parseDOM: (elem) => {
          try {
            const isHtmlType = elem.getAttribute("data-type") === "html";
            if (!isHtmlType) return null;
            return JSON.parse(elem.getAttribute("data-raw-html"));
          } catch (e) {
            console.warn("Paste parse error", e);
          }
          return null;
        },
        renderDOM: (attrs) => {
          if (!attrs.rawHtml) return {};
          return {
            "data-raw-html": JSON.stringify(attrs.rawHtml)
          };
        }
      },
      linkUrl: {
        default: null,
        rendered: false,
        parseDOM: (elem) => {
          let link = elem.querySelector("a");
          return link?.getAttribute("href") || null;
        }
      },
      fieldId: {
        default: null,
        parseDOM: (elem) => elem.getAttribute("data-field-id"),
        renderDOM: (attrs) => {
          if (!attrs.fieldId) return {};
          return {
            "data-field-id": attrs.fieldId
          };
        }
      },
      fieldType: {
        default: null,
        parseDOM: (elem) => elem.getAttribute("data-field-type"),
        renderDOM: (attrs) => {
          if (!attrs.fieldType) return {};
          return {
            "data-field-type": attrs.fieldType
          };
        }
      },
      fieldColor: {
        default: "#980043",
        parseDOM: (elem) => elem.getAttribute("data-field-color") || elem.style.backgroundColor || null,
        renderDOM: (attrs) => {
          if (!attrs.fieldColor || attrs.fieldColor == "None") return {};
          let hexColor = toHex(attrs.fieldColor);
          let isSixValueSyntax = hexColor.slice(1).length === 6;
          if (isSixValueSyntax) {
            hexColor = `${hexColor}33`;
          }
          let omitHighlight = attrs.highlighted === false;
          if (omitHighlight) {
            return {
              "data-field-color": hexColor
            };
          }
          return {
            "data-field-color": hexColor,
            style: `background-color: ${hexColor}`
          };
        }
      },
      hidden: {
        default: false,
        parseDOM: (elem) => {
          let hasHiddenAttr = elem.hasAttribute("hidden");
          let hasDisplayNoneStyle = elem.style.display === "none";
          let isHidden2 = hasHiddenAttr || hasDisplayNoneStyle;
          return isHidden2;
        },
        renderDOM: (attrs) => {
          if (!attrs.hidden) return {};
          return {
            style: "display: none"
          };
        }
      },
      visibility: {
        default: "visible",
        parseDOM: (el) => {
          let visibility = el.style.visibility || "visible";
          let containsVisibility = this.options.visibilityOptions.includes(visibility);
          return containsVisibility ? visibility : "visible";
        },
        renderDOM: (attrs) => {
          if (!attrs.visibility || attrs.visibility === "visible") return {};
          return { style: `visibility: ${attrs.visibility}` };
        }
      },
      highlighted: {
        default: true,
        rendered: false
      },
      multipleImage: {
        default: false,
        parseDOM: (elem) => elem.getAttribute("data-multiple-image"),
        renderDOM: (attrs) => {
          if (!attrs.multipleImage) return {};
          return {
            "data-multiple-image": attrs.multipleImage
          };
        }
      },
      size: {
        default: null,
        renderDOM: ({ size: size2 }) => {
          if (!size2 || !size2.width) return {};
          const style2 = `width: ${size2.width}px; height: ${size2.height}px; overflow: hidden;`;
          return { style: style2 };
        }
      },
      extras: {
        default: {},
        rendered: false
      },
      /// Formatting attrs for y-prosemirror support.
      bold: {
        default: false,
        parseDOM: (elem) => elem.getAttribute("data-bold") === "true",
        renderDOM: (attrs) => {
          if (!attrs.bold) return {};
          return {
            "data-bold": "true",
            style: "font-weight: bold"
          };
        }
      },
      italic: {
        default: false,
        parseDOM: (elem) => elem.getAttribute("data-italic") === "true",
        renderDOM: (attrs) => {
          if (!attrs.italic) return {};
          return {
            "data-italic": "true",
            style: "font-style: italic"
          };
        }
      },
      underline: {
        default: false,
        parseDOM: (elem) => elem.getAttribute("data-underline") === "true",
        renderDOM: (attrs) => {
          if (!attrs.underline) return {};
          return {
            "data-underline": "true",
            style: "text-decoration: underline"
          };
        }
      },
      fontFamily: {
        default: null,
        parseDOM: (elem) => elem.getAttribute("data-font-family") || elem.style.fontFamily || null,
        renderDOM: (attrs) => {
          if (!attrs.fontFamily) return {};
          return {
            "data-font-family": attrs.fontFamily,
            style: `font-family: ${attrs.fontFamily}`
          };
        }
      },
      fontSize: {
        default: null,
        parseDOM: (elem) => elem.getAttribute("data-font-size") || elem.style.fontSize || null,
        renderDOM: (attrs) => {
          if (!attrs.fontSize) return {};
          let [value, unit] = parseSizeUnit(attrs.fontSize);
          if (Number.isNaN(value)) return {};
          unit = unit ? unit : "pt";
          let fontSize2 = `${value}${unit}`;
          return {
            "data-font-size": fontSize2,
            style: `font-size: ${fontSize2}`
          };
        }
      },
      textHighlight: {
        default: null,
        parseDOM: (element) => element.getAttribute("data-text-highlight"),
        renderDOM: (attrs) => {
          if (!attrs.textHighlight) return {};
          return {
            "data-text-highlight": attrs.textHighlight,
            // takes precedence over the fieldColor.
            style: `background-color: ${attrs.textHighlight} !important`
          };
        }
      },
      textColor: {
        default: null,
        parseDOM: (element) => element.getAttribute("data-text-color"),
        renderDOM: (attrs) => {
          if (!attrs.textColor) return {};
          return {
            "data-text-color": attrs.textColor,
            style: `color: ${attrs.textColor}`
          };
        }
      },
      /// Formatting attrs - end.
      generatorIndex: {
        rendered: false,
        default: null
      },
      hash: {
        rendered: false,
        default: null
      },
      sdtId: {
        rendered: false,
        default: null
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: `span.${this.options.annotationClass}`,
        priority: 60
      }
    ];
  },
  renderDOM({ node, htmlAttributes }) {
    let { type, displayLabel, imageSrc, linkUrl } = node.attrs;
    let textRenderer = () => {
      return [
        "span",
        Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes),
        [
          "span",
          {
            class: `${this.options.annotationContentClass}`
          },
          displayLabel
        ]
      ];
    };
    let imageRenderer = () => {
      let contentRenderer = () => {
        if (!imageSrc) return displayLabel;
        return [
          "img",
          {
            src: imageSrc,
            alt: displayLabel
          }
        ];
      };
      return [
        "span",
        Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes),
        [
          "span",
          {
            class: `${this.options.annotationContentClass}`
          },
          contentRenderer()
        ]
      ];
    };
    let linkRenderer = () => {
      let contentRenderer = () => {
        if (!linkUrl) return displayLabel;
        return [
          "a",
          {
            href: linkUrl,
            target: "_blank"
          },
          linkUrl
        ];
      };
      return [
        "span",
        Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes),
        [
          "span",
          {
            class: `${this.options.annotationContentClass}`
          },
          contentRenderer()
        ]
      ];
    };
    let renderers = {
      text: () => textRenderer(),
      image: () => imageRenderer(),
      signature: () => imageRenderer(),
      checkbox: () => textRenderer(),
      html: () => textRenderer(),
      link: () => linkRenderer(),
      default: () => textRenderer()
    };
    let renderer = renderers[type] ?? renderers.default;
    return renderer();
  },
  addCommands() {
    const annotationTypes = this.options.types;
    return {
      /**
       * Add field annotation.
       * @param pos The position in the doc.
       * @param attrs The attributes.
       * @example
       * editor.commands.addFieldAnnotation(0, {
       *  displayLabel: 'Enter your info',
       *  fieldId: `123`,
       *  fieldType: 'TEXTINPUT',
       *  fieldColor: '#980043',
       * })
       */
      addFieldAnnotation: (pos, attrs = {}, editorFocus = false) => ({ editor, dispatch, state, tr }) => {
        if (dispatch) {
          let { schema } = editor;
          let newPos = tr.mapping.map(pos);
          let $pos = state.doc.resolve(newPos);
          let currentMarks = $pos.marks();
          currentMarks = currentMarks.length ? [...currentMarks] : null;
          let formatAttrs = getFormatAttrsFromMarks(currentMarks);
          let defaultDisplayLabel = attrs.defaultDisplayLabel ? attrs.defaultDisplayLabel : attrs.displayLabel || "";
          let node = schema.nodes[this.name].create(
            {
              ...attrs,
              ...formatAttrs,
              defaultDisplayLabel,
              hash: attrs.hash || superEditor_converter.generateDocxRandomId(4)
            },
            null,
            null
          );
          state.tr.insert(newPos, node).setSelection(superEditor_converter.Selection.near(tr.doc.resolve(newPos + node.nodeSize)));
          if (editorFocus) {
            this.editor.view.focus();
          }
        }
        return true;
      },
      addFieldAnnotationAtSelection: (attrs = {}, editorFocus = false) => ({ state, commands: commands2 }) => {
        const { from: from3 } = state.selection;
        return commands2.addFieldAnnotation(from3, attrs, editorFocus);
      },
      /**
       * Replace field annotation.
       * @param fieldsArray array of fields with attrs to add as annotation.
       * @example
       * editor.commands.replaceWithFieldAnnotation([
       *  from: 20,
       *  to: 45,
       *  attrs: {
       *    fieldType: 'TEXTINPUT'
       *    fieldColor: '#980043'
       *  }
       * ])
       */
      replaceWithFieldAnnotation: (fieldsArray) => ({ editor, dispatch, tr }) => {
        if (!dispatch) return true;
        fieldsArray.forEach((annotation) => {
          let { from: from3, to, attrs } = annotation;
          let { schema } = editor;
          let newPosFrom = tr.mapping.map(from3);
          let newPosTo = tr.mapping.map(to);
          let defaultDisplayLabel = attrs.defaultDisplayLabel ? attrs.defaultDisplayLabel : attrs.displayLabel || "";
          attrs.hash = superEditor_converter.generateDocxRandomId(4);
          let node = schema.nodes[this.name].create(
            {
              ...attrs,
              defaultDisplayLabel,
              hash: attrs.hash || superEditor_converter.generateDocxRandomId(4)
            },
            null,
            null
          );
          tr.replaceWith(newPosFrom, newPosTo, node);
        });
        return true;
      },
      /**
       * Replace annotations with a label (as text node) in selection.
       * @param options Additional options.
       * @example
       * editor.commands.replaceFieldAnnotationsWithLabelInSelection()
       */
      replaceFieldAnnotationsWithLabelInSelection: (options = {}) => ({ commands: commands2 }) => {
        return commands2.replaceFieldAnnotationsWithLabel(null, {
          ...options,
          isInSelection: true
        });
      },
      /**
       * Replace annotations with a label (as text node).
       * @param fieldIdOrArray The field ID or array of field IDs.
       * @param options.isInSelection Find in selection instead of field IDs.
       * @param options.addToHistory Add to history or not.
       * @param options.types Annotation types to replace.
       * @example
       * editor.commands.replaceFieldAnnotationsWithLabel(['1', '2'])
       */
      replaceFieldAnnotationsWithLabel: (fieldIdOrArray, { isInSelection = false, addToHistory = false, types = annotationTypes } = {}) => ({ dispatch, state, tr }) => {
        let { from: from3, to } = state.selection;
        let annotations = isInSelection ? findFieldAnnotationsBetween(from3, to, state.doc) : findFieldAnnotationsByFieldId(fieldIdOrArray, state);
        annotations = types.length ? annotations.filter(({ node }) => types.includes(node.attrs.type)) : annotations;
        if (!annotations.length) {
          return true;
        }
        if (!addToHistory) {
          tr.setMeta("addToHistory", false);
        }
        if (dispatch) {
          annotations.forEach((annotation) => {
            let { pos, node } = annotation;
            let newPosFrom = tr.mapping.map(pos);
            let newPosTo = tr.mapping.map(pos + node.nodeSize);
            let currentNode = tr.doc.nodeAt(newPosFrom);
            let nodeEqual = node.attrs.fieldId === currentNode?.attrs?.fieldId;
            let $newPosFrom = tr.doc.resolve(newPosFrom);
            let currentMarks = $newPosFrom.marks();
            currentMarks = currentMarks.length ? [...currentMarks] : null;
            if (nodeEqual) {
              let label = node.attrs.displayLabel || " ";
              let textNode = state.schema.text(label, currentMarks);
              tr.replaceWith(newPosFrom, newPosTo, textNode);
            }
          });
        }
        return true;
      },
      /**
       * Resets all annotations to default values.
       * @example
       * editor.commands.resetFieldAnnotations()
       */
      resetFieldAnnotations: () => ({ dispatch, state, tr }) => {
        let annotations = getAllFieldAnnotations(state);
        if (!annotations.length) {
          return true;
        }
        tr.setMeta("fieldAnnotationUpdate", true);
        if (dispatch) {
          annotations.forEach(({ pos, node }) => {
            let newPos = tr.mapping.map(pos);
            let currentNode = tr.doc.nodeAt(newPos);
            let nodeEqual = node.attrs.fieldId === currentNode?.attrs?.fieldId;
            if (nodeEqual) {
              let displayLabel = node.attrs.defaultDisplayLabel || node.attrs.displayLabel || "";
              tr.setNodeMarkup(newPos, void 0, {
                ...node.attrs,
                // reset displayLabel to default.
                displayLabel,
                // reset attrs for specific types.
                imageSrc: null,
                rawHtml: null,
                linkUrl: null,
                hash: null
              });
            }
          });
        }
        return true;
      },
      /**
       * Update annotations associated with a field.
       * @param fieldIdOrArray The field ID or array of field IDs.
       * @param attrs The attributes.
       * @example
       * editor.commands.updateFieldAnnotations('123', {
       *  displayLabel: 'Updated!',
       * })
       * @example
       * editor.commands.updateFieldAnnotations(['123', '456'], {
       *  displayLabel: 'Updated!',
       * })
       */
      updateFieldAnnotations: (fieldIdOrArray, attrs = {}) => ({ dispatch, state, commands: commands2 }) => {
        let annotations = findFieldAnnotationsByFieldId(fieldIdOrArray, state);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          return commands2.updateFieldAnnotationsAttributes(annotations, attrs);
        }
        return true;
      },
      /**
       * Update particular annotation's attributes.
       * @param annotation field annotation node to be updated.
       * @param attrs The attributes.
       *
       * Used for a case when multiple annotations for one input presented
       */
      updateFieldAnnotation: (annotation, attrs = {}) => ({ dispatch, commands: commands2 }) => {
        if (!annotation) {
          return true;
        }
        if (dispatch) {
          commands2.updateFieldAnnotationsAttributes([annotation], attrs);
          if (this.editor.options.pagination && !isHeadless(this.editor)) {
            setTimeout(() => {
              const newTr = this.editor.view.state.tr;
              newTr.setMeta("forceUpdatePagination", true);
              this.editor.view.dispatch(newTr);
            }, 50);
          }
          return true;
        }
        return true;
      },
      /**
       * Update the attributes of annotations.
       * @param annotations The annotations array [{pos, node}].
       * @param attrs The attributes object.
       */
      updateFieldAnnotationsAttributes: (annotations, attrs = {}) => ({ dispatch, tr }) => {
        if (!dispatch) return true;
        tr.setMeta("fieldAnnotationUpdate", true);
        annotations.forEach((annotation) => {
          let { pos, node } = annotation;
          let newPos = tr.mapping.map(pos);
          let currentNode = tr.doc.nodeAt(newPos);
          let nodeEqual = node.attrs.fieldId === currentNode?.attrs?.fieldId;
          if (nodeEqual) {
            tr.setNodeMarkup(newPos, void 0, {
              ...node.attrs,
              ...attrs
            });
          }
        });
        return true;
      },
      /**
       * Delete annotations associated with a field.
       * @param fieldIdOrArray The field ID or array of field IDs.
       * @example
       * editor.commands.deleteFieldAnnotations('123')
       * @example
       * editor.commands.deleteFieldAnnotations(['123', '456'])
       */
      deleteFieldAnnotations: (fieldIdOrArray) => ({ dispatch, state, tr }) => {
        let annotations = findFieldAnnotationsByFieldId(fieldIdOrArray, state);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          annotations.forEach((annotation) => {
            let { pos, node } = annotation;
            let newPosFrom = tr.mapping.map(pos);
            let newPosTo = tr.mapping.map(pos + node.nodeSize);
            let currentNode = tr.doc.nodeAt(newPosFrom);
            if (node.eq(currentNode)) {
              tr.delete(newPosFrom, newPosTo);
            }
          });
        }
        return true;
      },
      deleteFieldAnnotationsByNode: (annotations) => ({ dispatch, tr }) => {
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          annotations.forEach((annotation) => {
            let { pos, node } = annotation;
            let newPosFrom = tr.mapping.map(pos);
            let newPosTo = tr.mapping.map(pos + node.nodeSize);
            let currentNode = tr.doc.nodeAt(newPosFrom);
            if (node.eq(currentNode)) {
              tr.delete(newPosFrom, newPosTo);
            }
          });
        }
        return true;
      },
      deleteFieldAnnotation: (annotation) => ({ dispatch, tr }) => {
        if (!annotation) {
          return true;
        }
        if (dispatch) {
          let { pos, node } = annotation;
          let newPosFrom = tr.mapping.map(pos);
          let newPosTo = tr.mapping.map(pos + node.nodeSize);
          let currentNode = tr.doc.nodeAt(newPosFrom);
          if (node.eq(currentNode)) {
            tr.delete(newPosFrom, newPosTo);
          }
        }
        return true;
      },
      /**
       * Delete a portion of annotations associated with a field.
       * @param fieldIdOrArray The field ID or array of field IDs.
       * @param end index at which to end extraction
       * @example
       * editor.commands.sliceFieldAnnotations('123', 5) - will remove a portion of annotations array starting from index 6
       * @example
       * editor.commands.sliceFieldAnnotations(['123', '456'], 5)
       */
      sliceFieldAnnotations: (fieldIdOrArray, end2) => ({ dispatch, state, tr }) => {
        let annotations = findFieldAnnotationsByFieldId(fieldIdOrArray, state);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          annotations.forEach((annotation, index2) => {
            if (index2 >= end2) {
              let { pos, node } = annotation;
              let newPosFrom = tr.mapping.map(pos);
              let newPosTo = tr.mapping.map(pos + node.nodeSize);
              let currentNode = tr.doc.nodeAt(newPosFrom);
              if (node.eq(currentNode)) {
                tr.delete(newPosFrom, newPosTo);
              }
            }
          });
        }
        return true;
      },
      /**
       * Set `hidden` for annotations matching predicate.
       * Other annotations become unhidden.
       * @param predicate The predicate function.
       * @param unsetFromOthers If should unset hidden from other annotations.
       * @example
       * editor.commands.setFieldAnnotationsHiddenByCondition((node) => {
       *   let ids = ['111', '222', '333'];
       *   return ids.includes(node.attrs.fieldId);
       * })
       */
      setFieldAnnotationsHiddenByCondition: (predicate = () => false, unsetFromOthers = false) => ({ dispatch, state, chain }) => {
        let annotations = getAllFieldAnnotations(state);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          let otherAnnotations = [];
          let matchedAnnotations = annotations.filter((annotation) => {
            if (predicate(annotation.node)) return annotation;
            else otherAnnotations.push(annotation);
          });
          if (unsetFromOthers) {
            return chain().updateFieldAnnotationsAttributes(matchedAnnotations, { hidden: true }).updateFieldAnnotationsAttributes(otherAnnotations, { hidden: false }).run();
          } else {
            return chain().updateFieldAnnotationsAttributes(matchedAnnotations, { hidden: true }).run();
          }
        }
        return true;
      },
      /**
       * Unset `hidden` for all annotations.
       * @example
       * editor.commands.unsetFieldAnnotationsHidden()
       */
      unsetFieldAnnotationsHidden: () => ({ dispatch, state, commands: commands2 }) => {
        let annotations = getAllFieldAnnotations(state);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          return commands2.updateFieldAnnotationsAttributes(annotations, { hidden: false });
        }
        return true;
      },
      /**
       * Set `visibility` for all annotations (without changing the layout).
       * @param visibility The visibility value (visible, hidden).
       * @example
       * editor.commands.setFieldAnnotationsVisibility('visible');
       * @example
       * editor.commands.setFieldAnnotationsVisibility('hidden');
       */
      setFieldAnnotationsVisibility: (visibility = "visible") => ({ dispatch, state, commands: commands2 }) => {
        let annotations = getAllFieldAnnotations(state);
        if (!annotations.length) {
          return true;
        }
        let containsVisibility = this.options.visibilityOptions.includes(visibility);
        if (!containsVisibility) {
          return false;
        }
        if (dispatch) {
          return commands2.updateFieldAnnotationsAttributes(annotations, {
            visibility
          });
        }
        return true;
      },
      /**
       * Set `highlighted` for annotations matching predicate.
       * @param predicate The predicate function.
       * @param highlighted The highlighted attribute.
       * @example
       * editor.commands.setFieldAnnotationsHighlighted((node) => {
       *   let ids = ['111', '222', '333'];
       *   return ids.includes(node.attrs.fieldId);
       * }, false)
       * @example Set for all annotations.
       * editor.commands.setFieldAnnotationsHighlighted(() => true, false)
       * editor.commands.setFieldAnnotationsHighlighted(() => true, true)
       */
      setFieldAnnotationsHighlighted: (predicate = () => false, highlighted = true) => ({ dispatch, state, commands: commands2 }) => {
        let annotations = getAllFieldAnnotations(state);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          let matchedAnnotations = annotations.filter((annotation) => {
            if (predicate(annotation.node)) return annotation;
          });
          return commands2.updateFieldAnnotationsAttributes(matchedAnnotations, {
            highlighted
          });
        }
        return true;
      },
      /// Formatting commands for y-prosemirror support.
      toggleFieldAnnotationsFormat: (name, setSelection = false) => ({ dispatch, tr, state, commands: commands2 }) => {
        let formats = this.options.toggleFormatNames;
        if (!formats.includes(name)) {
          return false;
        }
        let { from: from3, to, node } = state.selection;
        let annotations = findFieldAnnotationsBetween(from3, to, state.doc);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          annotations.forEach((annotation) => {
            commands2.updateFieldAnnotationsAttributes([annotation], {
              [name]: !annotation.node.attrs[name]
            });
          });
          if (setSelection && node?.type.name === this.name) {
            tr.setSelection(superEditor_converter.NodeSelection.create(tr.doc, from3));
          }
        }
        return true;
      },
      setFieldAnnotationsFontFamily: (fontFamily2, setSelection = false) => ({ dispatch, tr, state, commands: commands2 }) => {
        let { from: from3, to, node } = state.selection;
        let annotations = findFieldAnnotationsBetween(from3, to, state.doc);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          annotations.forEach((annotation) => {
            commands2.updateFieldAnnotationsAttributes([annotation], {
              fontFamily: fontFamily2
            });
          });
          if (setSelection && node?.type.name === this.name) {
            tr.setSelection(superEditor_converter.NodeSelection.create(tr.doc, from3));
          }
        }
        return true;
      },
      setFieldAnnotationsFontSize: (fontSize2, setSelection = false) => ({ dispatch, tr, state, commands: commands2 }) => {
        let { from: from3, to, node } = state.selection;
        let annotations = findFieldAnnotationsBetween(from3, to, state.doc);
        if (!annotations.length) {
          return true;
        }
        let [value, unit] = parseSizeUnit(fontSize2);
        let min2 = 8, max2 = 96, defaultUnit = "pt";
        if (Number.isNaN(value)) {
          return false;
        }
        value = minMax(value, min2, max2);
        unit = unit ? unit : defaultUnit;
        if (dispatch) {
          annotations.forEach((annotation) => {
            commands2.updateFieldAnnotationsAttributes([annotation], {
              fontSize: `${value}${unit}`
            });
          });
          if (setSelection && node?.type.name === this.name) {
            tr.setSelection(superEditor_converter.NodeSelection.create(tr.doc, from3));
          }
        }
        return true;
      },
      setFieldAnnotationsTextHighlight: (color, setSelection = false) => ({ dispatch, tr, state, commands: commands2 }) => {
        let { from: from3, to, node } = state.selection;
        let annotations = findFieldAnnotationsBetween(from3, to, state.doc);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          annotations.forEach((annotation) => {
            commands2.updateFieldAnnotationsAttributes([annotation], {
              textHighlight: color
            });
          });
          if (setSelection && node?.type.name === this.name) {
            tr.setSelection(superEditor_converter.NodeSelection.create(tr.doc, from3));
          }
        }
        return true;
      },
      setFieldAnnotationsTextColor: (color, setSelection = false) => ({ dispatch, tr, state, commands: commands2 }) => {
        let { from: from3, to, node } = state.selection;
        let annotations = findFieldAnnotationsBetween(from3, to, state.doc);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          annotations.forEach((annotation) => {
            commands2.updateFieldAnnotationsAttributes([annotation], {
              textColor: color
            });
          });
          if (setSelection && node?.type.name === this.name) {
            tr.setSelection(superEditor_converter.NodeSelection.create(tr.doc, from3));
          }
        }
        return true;
      },
      /// Formatting commands - end.
      // Clean up commands (after field deletion)
      ...commands
    };
  },
  addNodeView() {
    return (props) => {
      return new FieldAnnotationView({
        ...props,
        annotationClass: this.options.annotationClass,
        annotationContentClass: this.options.annotationContentClass,
        borderColor: this.options.borderColor
      });
    };
  },
  addPmPlugins() {
    return [
      FieldAnnotationPlugin({
        editor: this.editor,
        annotationClass: this.options.annotationClass,
        handleDropOutside: this.options.handleDropOutside
      })
    ];
  }
});
function getFormatAttrsFromMarks(marks) {
  if (!marks) {
    return {};
  }
  let formatAttrs = {
    bold: false,
    italic: false,
    underline: false,
    fontFamily: null,
    fontSize: null
  };
  if (marks && marks.length) {
    formatAttrs.bold = marks.some((mark) => mark.type.name === "bold");
    formatAttrs.italic = marks.some((mark) => mark.type.name === "italic");
    formatAttrs.underline = marks.some((mark) => mark.type.name === "underline");
    let textStyle = marks.find((mark) => mark.type.name === "textStyle");
    if (textStyle) {
      formatAttrs.fontFamily = textStyle.attrs.fontFamily ?? null;
      formatAttrs.fontSize = textStyle.attrs.fontSize ?? null;
    }
  }
  return formatAttrs;
}
const DEFAULT_MIME_TYPE = "application/octet-stream";
const simpleHash = (str) => {
  let hash2 = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash2 = (hash2 << 5) - hash2 + char;
    hash2 = hash2 & hash2;
  }
  return Math.abs(hash2).toString();
};
const decodeBase64ToBinaryString = (data) => {
  if (!data) return "";
  if (typeof atob === "function") {
    return atob(data);
  }
  if (typeof jszip.Buffer !== "undefined" && typeof jszip.Buffer.from === "function") {
    return jszip.Buffer.from(data, "base64").toString("binary");
  }
  throw new Error("Unable to decode base64 payload in the current environment.");
};
const extractBase64Meta = (base64String) => {
  const [meta = "", payload = ""] = base64String.split(",");
  const mimeMatch = meta.match(/:(.*?);/);
  const rawMimeType = mimeMatch ? mimeMatch[1] : "";
  const mimeType = rawMimeType || DEFAULT_MIME_TYPE;
  const binaryString = decodeBase64ToBinaryString(payload);
  const hash2 = simpleHash(binaryString);
  const extension = mimeType.split("/")[1] || "bin";
  const filename = `image-${hash2}.${extension}`;
  return { mimeType, binaryString, filename };
};
const getBase64FileMeta = (base64String) => {
  const { mimeType, filename } = extractBase64Meta(base64String);
  return { mimeType, filename };
};
const base64ToFile = (base64String) => {
  const { mimeType, binaryString, filename } = extractBase64Meta(base64String);
  const fileType = mimeType || DEFAULT_MIME_TYPE;
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  const blob = new Blob([bytes], { type: fileType });
  return new File([blob], filename, { type: fileType });
};
const urlToFile = async (url, filename, mimeType) => {
  try {
    const response = await fetch(url, {
      mode: "cors",
      credentials: "omit",
      headers: {
        // Add common headers that might help with CORS
        Accept: "image/*,*/*;q=0.8"
      }
    });
    if (!response.ok) {
      console.warn(`Failed to fetch image from ${url}: ${response.status} ${response.statusText}`);
      return null;
    }
    const blob = await response.blob();
    const finalFilename = filename || extractFilenameFromUrl(url);
    const finalMimeType = mimeType || response.headers.get("content-type") || blob.type || "image/jpeg";
    return new File([blob], finalFilename, { type: finalMimeType });
  } catch (error) {
    if (isCorsError(error)) {
      console.warn(`CORS policy prevents accessing image from ${url}:`, error.message);
      return null;
    }
    console.error(`Error fetching image from ${url}:`, error);
    return null;
  }
};
const isCorsError = (error) => {
  const errorMessage = error.message.toLowerCase();
  const errorName = error.name.toLowerCase();
  return errorName.includes("cors") || errorMessage.includes("cors") || errorMessage.includes("cross-origin") || errorMessage.includes("access-control") || errorMessage.includes("network error") || // Often indicates CORS in browsers
  errorMessage.includes("failed to fetch");
};
const extractFilenameFromUrl = (url) => {
  try {
    const urlObj = new URL(url);
    const pathname = urlObj.pathname;
    const filename = pathname.split("/").pop();
    if (filename && !filename.includes(".")) {
      return `${filename}.jpg`;
    }
    return filename || "image.jpg";
  } catch {
    return "image.jpg";
  }
};
const validateUrlAccessibility = async (url) => {
  try {
    const response = await fetch(url, {
      method: "HEAD",
      mode: "cors",
      credentials: "omit"
    });
    return response.ok;
  } catch {
    return false;
  }
};
const handleImageUpload = (file) => {
  return new Promise((resolve, reject) => {
    let reader = new FileReader();
    reader.onload = (event) => {
      resolve(event.target.result);
    };
    reader.onerror = reject;
    setTimeout(() => reader.readAsDataURL(file), 250);
  });
};
const processUploadedImage = (fileData, getMaxContentSize) => {
  return new Promise((resolve, reject) => {
    const img = new window.Image();
    img.onload = () => {
      const canvas2 = document.createElement("canvas");
      const { width: logicalWidth, height: logicalHeight } = getAllowedImageDimensions(
        img.width,
        img.height,
        getMaxContentSize
      );
      canvas2.width = img.width;
      canvas2.height = img.height;
      const ctx2 = canvas2.getContext("2d");
      if (ctx2) {
        ctx2.imageSmoothingEnabled = true;
        try {
          ctx2.imageSmoothingQuality = "high";
        } catch {
        }
      }
      ctx2.drawImage(img, 0, 0, img.width, img.height);
      const dpr = typeof window !== "undefined" && window.devicePixelRatio ? window.devicePixelRatio : 1;
      const targetPixelWidth = Math.round(logicalWidth * dpr);
      const targetPixelHeight = Math.round(logicalHeight * dpr);
      const finalTargetWidth = Math.min(targetPixelWidth, img.width);
      const finalTargetHeight = Math.min(targetPixelHeight, img.height);
      const resizeNeeded = finalTargetWidth !== img.width || finalTargetHeight !== img.height;
      if (resizeNeeded) {
        multiStepResize(canvas2, finalTargetWidth, finalTargetHeight);
      }
      if (typeof fileData === "string") {
        const resizedBase64 = canvas2.toDataURL();
        resolve(resizedBase64);
      } else {
        canvas2.toBlob((blob) => {
          const updatedFile = new File([blob], fileData.name, {
            type: fileData.type,
            lastModified: Date.now()
          });
          resolve({ file: updatedFile, width: logicalWidth, height: logicalHeight });
        });
      }
    };
    img.onerror = (error) => reject(error);
    img.src = typeof fileData === "string" ? fileData : URL.createObjectURL(fileData);
  });
};
const getAllowedImageDimensions = (width, height, getMaxContentSize) => {
  const { width: maxWidth, height: maxHeight } = getMaxContentSize();
  if (!maxWidth || !maxHeight) return { width, height };
  let adjustedWidth = width;
  let adjustedHeight = height;
  const aspectRatio = width / height;
  if (height > maxHeight) {
    adjustedHeight = maxHeight;
    adjustedWidth = Math.round(maxHeight * aspectRatio);
  }
  if (adjustedWidth > maxWidth) {
    adjustedWidth = maxWidth;
    adjustedHeight = Math.round(maxWidth / aspectRatio);
  }
  return { width: adjustedWidth, height: adjustedHeight };
};
function resample_high_quality(canvas2, width, height, resize_canvas) {
  var width_source = canvas2.width;
  var height_source = canvas2.height;
  width = Math.round(width);
  height = Math.round(height);
  var ratio_w = width_source / width;
  var ratio_h = height_source / height;
  var ratio_w_half = Math.ceil(ratio_w / 2);
  var ratio_h_half = Math.ceil(ratio_h / 2);
  var ctx2 = canvas2.getContext("2d");
  var img = ctx2.getImageData(0, 0, width_source, height_source);
  var img2 = ctx2.createImageData(width, height);
  var data = img.data;
  var data2 = img2.data;
  for (var j = 0; j < height; j++) {
    for (var i = 0; i < width; i++) {
      var x2 = (i + j * width) * 4;
      var weight = 0;
      var weights = 0;
      var weights_alpha = 0;
      var gx_r = 0;
      var gx_g = 0;
      var gx_b = 0;
      var gx_a = 0;
      var center_y = (j + 0.5) * ratio_h;
      var yy_start = Math.floor(j * ratio_h);
      var yy_stop = Math.ceil((j + 1) * ratio_h);
      for (var yy = yy_start; yy < yy_stop; yy++) {
        var dy = Math.abs(center_y - (yy + 0.5)) / ratio_h_half;
        var center_x = (i + 0.5) * ratio_w;
        var w0 = dy * dy;
        var xx_start = Math.floor(i * ratio_w);
        var xx_stop = Math.ceil((i + 1) * ratio_w);
        for (var xx = xx_start; xx < xx_stop; xx++) {
          var dx = Math.abs(center_x - (xx + 0.5)) / ratio_w_half;
          var w = Math.sqrt(w0 + dx * dx);
          if (w >= 1) {
            continue;
          }
          weight = 2 * w * w * w - 3 * w * w + 1;
          var pos_x = 4 * (xx + yy * width_source);
          gx_a += weight * data[pos_x + 3];
          weights_alpha += weight;
          if (data[pos_x + 3] < 255) weight = weight * data[pos_x + 3] / 250;
          gx_r += weight * data[pos_x];
          gx_g += weight * data[pos_x + 1];
          gx_b += weight * data[pos_x + 2];
          weights += weight;
        }
      }
      data2[x2] = gx_r / weights;
      data2[x2 + 1] = gx_g / weights;
      data2[x2 + 2] = gx_b / weights;
      data2[x2 + 3] = gx_a / weights_alpha;
    }
  }
  {
    canvas2.width = width;
    canvas2.height = height;
  }
  ctx2.putImageData(img2, 0, 0);
}
function multiStepResize(canvas2, width, height) {
  let oc = document.createElement("canvas");
  let octx = oc.getContext("2d");
  let ctx2 = canvas2.getContext("2d");
  let steps = Math.ceil(Math.log(canvas2.width / width) / Math.log(2));
  steps = Math.max(steps, 1);
  let stepWidth = width * Math.pow(2, steps - 1);
  let stepHeight = height * Math.pow(2, steps - 1);
  let currentWidth = canvas2.width;
  let currentHeight = canvas2.height;
  oc.width = currentWidth;
  oc.height = currentHeight;
  octx.drawImage(canvas2, 0, 0);
  while (steps > 0) {
    stepWidth = Math.max(stepWidth, width);
    stepHeight = Math.max(stepHeight, height);
    canvas2.width = stepWidth;
    canvas2.height = stepHeight;
    ctx2.drawImage(oc, 0, 0, currentWidth, currentHeight, 0, 0, stepWidth, stepHeight);
    currentWidth = stepWidth;
    currentHeight = stepHeight;
    oc.width = currentWidth;
    oc.height = currentHeight;
    octx.drawImage(canvas2, 0, 0);
    stepWidth = Math.round(stepWidth / 2);
    stepHeight = Math.round(stepHeight / 2);
    steps--;
  }
  resample_high_quality(canvas2, width, height);
}
const FALLBACK_NAME = "image";
const stripDiacritics = (value) => value.normalize("NFKD").replace(/[\u0300-\u036f]/g, "");
const sanitizeSegment = (segment, { allowDots = false } = {}) => {
  if (!segment) return "";
  const normalized = stripDiacritics(segment).replace(/[\s\u2000-\u206f]+/g, "_").replace(/[\\/]+/g, "_");
  const allowedPattern = allowDots ? /[^0-9A-Za-z._-]+/g : /[^0-9A-Za-z_-]+/g;
  let sanitized = normalized.replace(allowedPattern, "_");
  sanitized = sanitized.replace(/_+/g, "_");
  sanitized = sanitized.replace(/^[_.-]+/, "");
  sanitized = sanitized.replace(/[_-]+$/, "");
  return sanitized;
};
const splitFileName = (name) => {
  const trimmed = name?.trim?.() ?? "";
  const lastDot = trimmed.lastIndexOf(".");
  if (lastDot <= 0 || lastDot === trimmed.length - 1) {
    return { base: trimmed, ext: "" };
  }
  return {
    base: trimmed.slice(0, lastDot),
    ext: trimmed.slice(lastDot + 1)
  };
};
const sanitizeImageFileName = (inputName) => {
  const { base: base2, ext } = splitFileName(inputName || "");
  const sanitizedBase = sanitizeSegment(base2, { allowDots: true }) || FALLBACK_NAME;
  const sanitizedExt = sanitizeSegment(ext, { allowDots: false }).toLowerCase();
  if (!sanitizedExt) return sanitizedBase;
  return `${sanitizedBase}.${sanitizedExt}`;
};
const ensureUniqueFileName = (preferredName, existingNames = /* @__PURE__ */ new Set()) => {
  const sanitized = sanitizeImageFileName(preferredName);
  if (!existingNames || typeof existingNames.has !== "function") {
    return sanitized;
  }
  const existingSet = /* @__PURE__ */ new Set();
  existingNames.forEach((name) => existingSet.add(sanitizeImageFileName(name)));
  if (!existingSet.has(sanitized)) {
    return sanitized;
  }
  const { base: base2, ext } = splitFileName(sanitized);
  let counter = 1;
  let candidate = sanitized;
  const suffix2 = () => `${base2}-${counter}${ext ? `.${ext}` : ""}`;
  while (existingSet.has(candidate)) {
    candidate = suffix2();
    counter += 1;
  }
  return candidate;
};
const buildMediaPath = (fileName) => `word/media/${fileName}`;
const fileTooLarge = (file) => {
  let fileSizeMb = Number((file.size / (1024 * 1024)).toFixed(4));
  if (fileSizeMb > 5) {
    window.alert("Image size must be less than 5MB");
    return true;
  }
  return false;
};
const checkAndProcessImage = async ({ getMaxContentSize, file }) => {
  if (fileTooLarge(file)) {
    return { file: null, size: { width: 0, height: 0 } };
  }
  try {
    const processedImageResult = await processUploadedImage(file, getMaxContentSize);
    const process2 = processedImageResult;
    return { file: process2.file, size: { width: process2.width, height: process2.height } };
  } catch (err) {
    console.warn("Error processing image:", err);
    return { file: null, size: { width: 0, height: 0 } };
  }
};
function replaceSelectionWithImagePlaceholder({ editorOptions, view, id }) {
  let { tr } = view.state;
  let { selection } = tr;
  if (editorOptions.isHeaderOrFooter) {
    selection = editorOptions.lastSelection;
  }
  if (!selection.empty && !editorOptions.isHeaderOrFooter) {
    tr.deleteSelection();
  }
  tr = addImagePlaceholder(view.state, tr, id, selection.from);
  view.dispatch(tr);
}
const generateUniqueDocPrId = (editor) => {
  const existingIds = /* @__PURE__ */ new Set();
  editor?.state?.doc?.descendants((node) => {
    if (node.type.name === "image" && node.attrs.id !== void 0 && node.attrs.id !== null) {
      existingIds.add(String(node.attrs.id));
    }
  });
  let candidate;
  do {
    const hex2 = superEditor_converter.generateDocxRandomId();
    candidate = String(parseInt(hex2, 16));
  } while (!candidate || existingIds.has(candidate));
  return candidate;
};
async function uploadAndInsertImage({ editor, view, file, size: size2, id }) {
  const imageUploadHandler = typeof editor.options.handleImageUpload === "function" ? editor.options.handleImageUpload : handleImageUpload;
  const placeholderId = id;
  try {
    const existingFileNames = new Set(Object.keys(editor.storage.image.media ?? {}).map((key2) => key2.split("/").pop()));
    const uniqueFileName = ensureUniqueFileName(file.name, existingFileNames);
    const normalizedFile = uniqueFileName === file.name ? file : new File([file], uniqueFileName, {
      type: file.type,
      lastModified: file.lastModified ?? Date.now()
    });
    let url = await imageUploadHandler(normalizedFile);
    let placeholderPos = findPlaceholder(view.state, placeholderId);
    if (placeholderPos == null) {
      return;
    }
    const mediaPath = buildMediaPath(uniqueFileName);
    const docPrId = generateUniqueDocPrId(editor);
    let rId = null;
    if (editor.options.mode === "docx") {
      const [, path] = mediaPath.split("word/");
      const id2 = addImageRelationship({ editor, path });
      if (id2) rId = id2;
    }
    let imageNode = view.state.schema.nodes.image.create({
      src: mediaPath,
      size: size2,
      id: docPrId,
      rId
    });
    editor.storage.image.media = Object.assign(editor.storage.image.media, { [mediaPath]: url });
    if (editor.options.ydoc && typeof editor.commands.addImageToCollaboration === "function") {
      editor.commands.addImageToCollaboration({ mediaPath, fileData: url });
    }
    let tr = view.state.tr;
    tr.replaceWith(placeholderPos, placeholderPos, imageNode);
    tr = removeImagePlaceholder(view.state, tr, placeholderId);
    view.dispatch(tr);
  } catch {
    const tr = removeImagePlaceholder(view.state, view.state.tr, placeholderId);
    view.dispatch(tr);
  }
}
function addImageRelationship({ editor, path }) {
  const target = path;
  const type = "image";
  try {
    const id = superEditor_converter.insertNewRelationship(target, type, editor);
    return id;
  } catch {
    return null;
  }
}
const key = new superEditor_converter.PluginKey("ImageRegistration");
const needsImageRegistration = (node) => {
  if (!node || node.type?.name !== "image") return false;
  const src = node.attrs?.src;
  if (typeof src !== "string" || src.length === 0) return false;
  if (src.startsWith("word/media")) return false;
  if (src.startsWith("data:") && node.attrs?.rId) return false;
  return true;
};
const ImageRegistrationPlugin = ({ editor }) => {
  const { view } = editor;
  return new superEditor_converter.Plugin({
    key,
    state: {
      init() {
        return { set: DecorationSet.empty };
      },
      apply(tr, { set }) {
        const meta = tr.getMeta(key);
        if (meta) {
          set = meta.set;
          return { set };
        }
        set = set.map(tr.mapping, tr.doc);
        return { set };
      }
    },
    appendTransaction: (trs, _oldState, state) => {
      let foundImages = [];
      if (!trs.some((tr) => tr.docChanged)) return null;
      trs.forEach((tr) => {
        if (tr.docChanged) {
          tr.steps.forEach((step, index2) => {
            const stepMap = step.getMap();
            foundImages = foundImages.map(({ node, pos, id }) => {
              const mappedPos = stepMap.map(pos, -1);
              return { node, pos: mappedPos, id };
            });
            if (step instanceof superEditor_converter.ReplaceStep || step instanceof superEditor_converter.ReplaceAroundStep) {
              (tr.docs[index2 + 1] || tr.doc).nodesBetween(
                stepMap.map(step.from, -1),
                stepMap.map(step.to, 1),
                (node, pos) => {
                  if (node.type.name === "image" && needsImageRegistration(node)) {
                    const id = {};
                    foundImages.push({ node, pos, id });
                  } else {
                    return true;
                  }
                }
              );
            }
          });
        }
      });
      if (!foundImages || foundImages.length === 0) {
        return null;
      }
      if (editor.options.isHeadless) {
        return handleNodePath(foundImages, editor, state);
      }
      return handleBrowserPath(foundImages, editor, view, state);
    },
    props: {
      decorations(state) {
        let { set } = key.getState(state);
        return set;
      }
    }
  });
};
const derivePreferredFileName = (src) => {
  if (typeof src !== "string" || src.length === 0) {
    return "image.bin";
  }
  if (src.startsWith("data:")) {
    return getBase64FileMeta(src).filename;
  }
  const lastSegment = src.split("/").pop() ?? "";
  const trimmed = lastSegment.split(/[?#]/)[0];
  return trimmed || "image.bin";
};
const handleNodePath = (foundImages, editor, state) => {
  const { tr } = state;
  const mediaStore = editor.storage.image.media ?? {};
  if (!editor.storage.image.media) {
    editor.storage.image.media = mediaStore;
  }
  const existingFileNames = new Set(Object.keys(mediaStore).map((key2) => key2.split("/").pop()));
  foundImages.forEach(({ node, pos }) => {
    const { src } = node.attrs;
    const preferredFileName = derivePreferredFileName(src);
    const uniqueFileName = ensureUniqueFileName(preferredFileName, existingFileNames);
    existingFileNames.add(uniqueFileName);
    const mediaPath = buildMediaPath(uniqueFileName);
    mediaStore[mediaPath] = src;
    const path = mediaPath.startsWith("word/") ? mediaPath.slice(5) : mediaPath;
    const rId = addImageRelationship({ editor, path });
    tr.setNodeMarkup(pos, void 0, {
      ...node.attrs,
      src: mediaPath,
      rId
    });
  });
  return tr;
};
const handleBrowserPath = (foundImages, editor, view, state) => {
  registerImages(foundImages, editor, view);
  const tr = state.tr;
  let { set } = key.getState(state);
  foundImages.slice().sort((a, b2) => a.pos - b2.pos).forEach(({ pos, id }) => {
    let deco = Decoration.widget(pos, () => document.createElement("placeholder"), {
      side: -1,
      id
    });
    set = set.add(tr.doc, [deco]);
  });
  foundImages.slice().sort((a, b2) => b2.pos - a.pos).forEach(({ node, pos }) => {
    tr.delete(pos, pos + node.nodeSize);
  });
  set = set.map(tr.mapping, tr.doc);
  tr.setMeta(key, { set });
  return tr;
};
const findPlaceholder = (state, id) => {
  let { set } = key.getState(state);
  let found = set?.find(null, null, (spec) => spec.id === id);
  return found?.length ? found[0].from : null;
};
const removeImagePlaceholder = (state, tr, id) => {
  let { set } = key.getState(state);
  set = set.map(tr.mapping, tr.doc);
  set = set.remove(set.find(null, null, (spec) => spec.id == id));
  return tr.setMeta(key, { set, type: "remove" });
};
const addImagePlaceholder = (state, tr, id, pos) => {
  let { set } = key.getState(state);
  set = set.map(tr.mapping, tr.doc);
  let deco = Decoration.widget(pos, () => document.createElement("placeholder"), {
    id
  });
  set = set.add(tr.doc, [deco]);
  return tr.setMeta(key, { set, type: "add" });
};
const registerImages = async (foundImages, editor, view) => {
  foundImages.forEach(async (image) => {
    const src = image.node.attrs.src;
    const id = image.id;
    let file = null;
    if (src.startsWith("http")) {
      const isAccessible = await validateUrlAccessibility(src);
      if (isAccessible) {
        file = await urlToFile(src);
      } else {
        console.warn(`Image URL ${src} is not accessible due to CORS or other restrictions. Using original URL.`);
        const tr = view.state.tr;
        removeImagePlaceholder(view.state, tr, id);
        view.dispatch(tr);
        return;
      }
    } else if (src.startsWith("data:")) {
      file = base64ToFile(src);
    } else {
      console.error(`Unsupported image source: ${src}`);
    }
    if (!file) {
      const tr = view.state.tr;
      removeImagePlaceholder(view.state, tr, id);
      view.dispatch(tr);
      return;
    }
    try {
      const process2 = await checkAndProcessImage({
        getMaxContentSize: () => editor.getMaxContentSize(),
        file
      });
      if (!process2.file) {
        const tr = view.state.tr;
        removeImagePlaceholder(view.state, tr, id);
        view.dispatch(tr);
        return;
      }
      await uploadAndInsertImage({ editor, view, file: process2.file, size: process2.size, id });
    } catch (error) {
      console.error(`Error processing image from ${src}:`, error);
      const tr = view.state.tr;
      removeImagePlaceholder(view.state, tr, id);
      view.dispatch(tr);
    }
  });
};
const stepHasSlice = (step) => "slice" in step && Boolean(step.slice);
const ImagePositionPluginKey = new superEditor_converter.PluginKey("ImagePosition");
const pageBreakPositionCache = /* @__PURE__ */ new WeakMap();
const ImagePositionPlugin = ({ editor }) => {
  const { view } = editor;
  let shouldUpdate = true;
  return new superEditor_converter.Plugin({
    name: "ImagePositionPlugin",
    key: ImagePositionPluginKey,
    state: {
      init() {
        return DecorationSet.empty;
      },
      apply(tr, oldDecorationSet, oldState, newState) {
        if (!tr.docChanged && !shouldUpdate) return oldDecorationSet;
        const hasDOM = typeof document !== "undefined" && !!(document && document.createElement);
        if (!hasDOM || !view || typeof view.domAtPos !== "function") {
          return oldDecorationSet.map(tr.mapping, tr.doc);
        }
        let affectsImages = false;
        tr.steps.forEach((step) => {
          if (stepHasSlice(step)) {
            step.slice.content.descendants((node) => {
              if (node.type.name === "image" || node.attrs?.anchorData) {
                affectsImages = true;
                return false;
              }
            });
          }
        });
        if (!affectsImages && !shouldUpdate) {
          return oldDecorationSet.map(tr.mapping, tr.doc);
        }
        const decorations = getImagePositionDecorations(newState, view);
        shouldUpdate = false;
        return DecorationSet.create(newState.doc, decorations);
      }
    },
    view: () => {
      return {
        update: (view2, lastState) => {
          const hasDOM = typeof document !== "undefined" && !!(document && document.createElement);
          if (!hasDOM || !view2 || typeof view2.domAtPos !== "function") return;
          if (shouldUpdate) {
            const decorations = getImagePositionDecorations(lastState, view2);
            const updateTransaction = view2.state.tr.setMeta(ImagePositionPluginKey, { decorations });
            view2.dispatch(updateTransaction);
          }
        }
      };
    },
    props: {
      decorations(state) {
        return this.getState(state);
      }
    }
  });
};
const getImagePositionDecorations = (state, view) => {
  let decorations = [];
  const hasDOM = typeof document !== "undefined" && !!(document && document.createElement);
  if (!hasDOM || !view || typeof view.domAtPos !== "function") {
    return decorations;
  }
  let hasAnchoredImages = false;
  state.doc.descendants((node) => {
    if (node.attrs?.anchorData) {
      hasAnchoredImages = true;
      return false;
    }
  });
  if (!hasAnchoredImages) {
    return decorations;
  }
  state.doc.descendants((node, pos) => {
    if (node.attrs.anchorData) {
      let style2 = "";
      let className = "";
      const { vRelativeFrom, alignH } = node.attrs.anchorData;
      const { size: size2, padding } = node.attrs;
      const pageBreak = findPreviousDomNodeWithClass(view, pos, "pagination-break-wrapper");
      if (pageBreak && vRelativeFrom === "margin" && alignH) {
        let pageBreakPos = pageBreakPositionCache.get(pageBreak);
        if (!pageBreakPos) {
          pageBreakPos = {
            top: pageBreak.offsetTop,
            height: pageBreak.offsetHeight
          };
          pageBreakPositionCache.set(pageBreak, pageBreakPos);
        }
        const topPos = pageBreakPos.top + pageBreakPos.height;
        let horizontalAlignment = `${alignH}: 0;`;
        if (alignH === "center") horizontalAlignment = "left: 50%; transform: translateX(-50%);";
        style2 += vRelativeFrom === "margin" ? `position: absolute; top: ${topPos}px; ${horizontalAlignment}` : "";
        const nextPos = view.posAtDOM(pageBreak, 1);
        if (nextPos < 0) {
          const $pos = view.state.doc.resolve(pos);
          decorations.push(
            Decoration.node(pos - 1, pos + $pos.parent.nodeSize - 1, {
              style: `height: ${size2.height + parseInt(padding.top) + parseInt(padding.bottom)}px`
            })
          );
        }
        const imageBlock = document.createElement("div");
        imageBlock.className = "anchor-image-placeholder";
        imageBlock.style.float = alignH === "left" || alignH === "right" ? alignH : "none";
        let paddingHorizontal;
        if (alignH === "center") {
          paddingHorizontal = (parseInt(padding.left) || 0) + (parseInt(padding.right) || 0);
        } else {
          paddingHorizontal = parseInt(padding[alignH]) || 0;
        }
        imageBlock.style.width = size2.width + paddingHorizontal + "px";
        imageBlock.style.height = size2.height + parseInt(padding.top) + parseInt(padding.bottom) + "px";
        decorations.push(Decoration.widget(nextPos, imageBlock, { key: "stable-key" }));
        decorations.push(Decoration.inline(pos, pos + node.nodeSize, { style: style2, class: className }));
      }
    }
  });
  return decorations;
};
const findPreviousDomNodeWithClass = (view, pos, className) => {
  const hasDOM = typeof document !== "undefined" && !!(document && document.createElement);
  if (!hasDOM || !view || typeof view.domAtPos !== "function") return null;
  let { node } = view.domAtPos(pos);
  if (node.nodeType === 3) {
    node = node.parentNode;
  }
  while (node) {
    if (node.classList && node.classList.contains(className)) {
      return node;
    }
    if (node.previousSibling) {
      node = node.previousSibling;
      while (node && node.lastChild) {
        node = node.lastChild;
      }
    } else {
      node = node.parentNode;
    }
  }
  return null;
};
const normalizeWrap = (attrs = {}) => {
  const wrap = attrs.wrap;
  if (wrap?.type && wrap.type !== "Inline") {
    return {
      type: wrap.type,
      attrs: wrap.attrs ?? {}
    };
  }
  if (wrap?.type === "Inline" && Object.keys(wrap.attrs ?? {}).length) {
    return {
      type: "Inline",
      attrs: wrap.attrs
    };
  }
  if (!wrap && attrs.wrapText) {
    return {
      type: "Square",
      attrs: {
        wrapText: attrs.wrapText
      }
    };
  }
  if (!wrap && attrs.wrapTopAndBottom) {
    return {
      type: "TopAndBottom",
      attrs: {}
    };
  }
  if (wrap?.type === "Inline") {
    return {
      type: "Inline",
      attrs: wrap.attrs ?? {}
    };
  }
  return {
    type: "Inline",
    attrs: {}
  };
};
const normalizeMarginOffset = (marginOffset = {}) => {
  const { left: left2, horizontal, ...rest } = marginOffset;
  return {
    ...rest,
    horizontal: horizontal ?? left2
  };
};
const getNormalizedImageAttrs = (attrs = {}) => {
  return {
    wrap: normalizeWrap(attrs),
    marginOffset: normalizeMarginOffset(attrs.marginOffset ?? {})
  };
};
const getRotationMargins = (w, h2, angleDegrees) => {
  const rad = angleDegrees * (Math.PI / 180);
  const cos = Math.abs(Math.cos(rad));
  const sin = Math.abs(Math.sin(rad));
  const boundingWidth = w * cos + h2 * sin;
  const boundingHeight = w * sin + h2 * cos;
  const marginLeftRight = Math.round(Math.max(0, (boundingWidth - w) / 2));
  const marginTopBottom = Math.round(Math.max(0, (boundingHeight - h2) / 2));
  return {
    horizontal: marginLeftRight,
    vertical: marginTopBottom
  };
};
const Image = Node$1.create({
  name: "image",
  group: "inline",
  inline: true,
  draggable: true,
  addOptions() {
    return {
      allowBase64: true,
      htmlAttributes: {
        style: "display: inline-block;",
        "aria-label": "Image node"
      }
    };
  },
  addStorage() {
    return {
      media: {}
    };
  },
  addAttributes() {
    return {
      src: {
        default: null,
        renderDOM: ({ src }) => {
          return {
            src: this.storage.media[src] ?? src
          };
        }
      },
      alt: {
        default: "Uploaded picture"
      },
      id: { rendered: false },
      hidden: {
        default: false,
        rendered: false
      },
      title: {
        default: null
      },
      rId: {
        default: null,
        rendered: false
      },
      originalPadding: {
        default: null,
        rendered: false
      },
      originalAttributes: { rendered: false },
      /**
       * @category Attribute
       * @param {Object} wrap - Wrapping options
       * @param {string} wrap.type - Wrap type: "None", "Square", "Through", "Tight", "TopAndBottom", "Inline"
       * @param {Object} [wrap.attrs] - Wrap attributes (only allowed attributes for the given type will be accepted)
       * @param {string} [wrap.attrs.wrapText] - Text wrapping mode for Square type: "bothSides", "largest", "left", "right"
       * @param {number} [wrap.attrs.distTop] - Top distance in pixels
       * @param {number} [wrap.attrs.distBottom] - Bottom distance in pixels
       * @param {number} [wrap.attrs.distLeft] - Left distance in pixels
       * @param {number} [wrap.attrs.distRight] - Right distance in pixels
       * @param {Array} [wrap.attrs.polygon] - Polygon points for Through/Tight types: [[x1,y1], [x2,y2], ...]
       * @param {boolean} [wrap.attrs.behindDoc] - Whether image should be behind document text (for wrapNone)
       */
      wrap: {
        default: { type: "Inline" },
        rendered: false
        // Handled in main renderDOM
      },
      anchorData: {
        default: null,
        rendered: false
      },
      isAnchor: { rendered: false },
      /**
       * @category Attribute
       * @param {Object} [transformData] - Transform data for image (turn and flip)
       * @param {number} [transformData.rotation] - Turn angle in degrees
       * @param {boolean} [transformData.verticalFlip] - Whether to flip vertically
       * @param {boolean} [transformData.horizontalFlip] - Whether to flip horizontally
       * @param {Object} [transformData.sizeExtension] - Size extension for image due to transformation
       * @param {number} [transformData.sizeExtension.left] - Left size extension for image
       * @param {number} [transformData.sizeExtension.top] - Top size extension for image
       * @param {number} [transformData.sizeExtension.right] - Right size extension for image
       * @param {number} [transformData.sizeExtension.bottom] - Bottom size extension for image
       *
       * @private
       */
      transformData: {
        default: {},
        renderDOM: ({ transformData }) => {
          let style2 = "";
          if (transformData?.rotation) {
            style2 += `rotate(${Math.round(transformData.rotation)}deg) `;
          }
          if (transformData?.verticalFlip) {
            style2 += "scaleY(-1) ";
          }
          if (transformData?.horizontalFlip) {
            style2 += "scaleX(-1) ";
          }
          style2 = style2.trim();
          if (style2.length > 0) {
            return { style: `transform: ${style2};` };
          }
          return;
        }
      },
      /**
       * @category Attribute
       * @param {boolean} [simplePos] - Simple positioning flag
       * @private
       */
      simplePos: { rendered: false },
      extension: { rendered: false },
      // Preserve original EMF/WMF format info when converting to SVG for display.
      // Used during DOCX export to restore the original metafile format.
      originalExtension: { rendered: false },
      originalSrc: { rendered: false },
      shouldCover: {
        default: false,
        rendered: false
      },
      size: {
        default: {},
        renderDOM: ({ size: size2, shouldCover }) => {
          let style2 = "";
          let { width, height } = size2 ?? {};
          if (width) style2 += `width: ${width}px;`;
          if (height && shouldCover) {
            style2 += `height: ${height}px; object-fit: cover; object-position: left top;`;
          } else if (height) style2 += "height: auto;";
          return { style: style2 };
        }
      },
      padding: {
        default: {},
        rendered: false
        // Handled in main renderDOM
      },
      marginOffset: {
        default: {},
        rendered: false
        // Handled in main renderDOM
      },
      style: {
        default: null,
        rendered: true,
        renderDOM: ({ style: style2 }) => {
          if (!style2) return {};
          return { style: style2 };
        }
      },
      drawingChildOrder: {
        default: null,
        rendered: false
      },
      originalDrawingChildren: {
        default: null,
        rendered: false
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderDOM({ node, htmlAttributes }) {
    const { wrap, marginOffset } = getNormalizedImageAttrs(node.attrs);
    const { anchorData, padding, transformData = {}, size: size2 = { width: 0, height: 0 } } = node.attrs;
    const margin = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    };
    let centered = false;
    let floatRight = false;
    let baseHorizontal = marginOffset?.horizontal || 0;
    let style2 = "";
    if (padding) {
      if (padding.left) margin.left += padding.left;
      if (padding.right) margin.right += padding.right;
      if (padding.top) margin.top += padding.top;
      if (padding.bottom) margin.bottom += padding.bottom;
    }
    const { rotation } = transformData;
    const { height, width } = size2;
    if (rotation && height && width) {
      const { horizontal, vertical } = getRotationMargins(width, height, rotation);
      margin.left += horizontal;
      margin.right += horizontal;
      margin.top += vertical;
      margin.bottom += vertical;
    }
    if (wrap && wrap.type) {
      const { type, attrs = {} } = wrap;
      switch (type) {
        case "None":
          style2 += "position: absolute;";
          const relativeHeight = node.attrs.originalAttributes?.relativeHeight;
          if (relativeHeight != null) {
            const zIndex = Math.floor(relativeHeight / 1e6);
            style2 += `z-index: ${zIndex};`;
          } else if (attrs.behindDoc) {
            style2 += "z-index: -1;";
          } else {
            style2 += "z-index: 1;";
          }
          break;
        case "Square":
          style2 += "shape-outside: border-box; clear: both;";
          if (attrs.wrapText === "right") {
            style2 += "float: left;";
          } else if (attrs.wrapText === "left") {
            style2 += "float: right;";
            floatRight = true;
          } else if (["largest", "bothSides"].includes(attrs.wrapText)) {
            const pageStylesData = getDataFromPageStyles({
              editor: this.editor,
              marginOffset,
              size: size2,
              attrs
            });
            style2 += pageStylesData.style;
            floatRight = pageStylesData.floatRight;
            baseHorizontal = pageStylesData.baseHorizontal;
          }
          if (attrs.distTop) margin.top += attrs.distTop;
          if (attrs.distBottom) margin.bottom += attrs.distBottom;
          if (attrs.distLeft) margin.left += attrs.distLeft;
          if (attrs.distRight) margin.right += attrs.distRight;
          break;
        case "Through":
        case "Tight": {
          style2 += "clear: both;";
          const pageStylesData = getDataFromPageStyles({
            editor: this.editor,
            marginOffset,
            size: size2,
            attrs
          });
          style2 += pageStylesData.style;
          floatRight = pageStylesData.floatRight;
          baseHorizontal = pageStylesData.baseHorizontal;
          if (attrs.distTop) margin.top += attrs.distTop;
          if (attrs.distBottom) margin.bottom += attrs.distBottom;
          if (attrs.distLeft) margin.left += attrs.distLeft;
          if (attrs.distRight) margin.right += attrs.distRight;
          if (attrs.polygon) {
            let horizontalOffset = floatRight ? attrs.polygon[0][0] || 0 : marginOffset.horizontal + 15;
            let maxX = 0;
            let minX = 0;
            let minY = 0;
            let maxY = 0;
            attrs.polygon.forEach(([x, y2]) => {
              if (floatRight && x < horizontalOffset) horizontalOffset = x;
              if (x > maxX) maxX = x;
              if (x < minX) minX = x;
              if (y2 > maxY) maxY = y2;
              if (y2 < minY) minY = y2;
            });
            const originalWidth = maxX - minX;
            const originalHeight = maxY - minY;
            const scaleWidth = Math.min(1, size2.width / originalWidth);
            const scaleHeight = Math.min(1, size2.height / originalHeight);
            const verticalOffset = Math.max(0, marginOffset.top);
            const points = attrs.polygon.map(([x, y2]) => `${horizontalOffset + x * scaleWidth}px ${verticalOffset + y2 * scaleHeight}px`).join(", ");
            style2 += `shape-outside: polygon(${points});`;
          }
          break;
        }
        case "TopAndBottom":
          style2 += "display: block; clear: both;";
          if (!anchorData) {
            centered = true;
          }
          if (attrs.distTop) margin.top += attrs.distTop;
          if (attrs.distBottom) margin.bottom += attrs.distBottom;
          break;
      }
    }
    const hasAnchorData = Boolean(anchorData);
    const hasMarginOffsets = marginOffset?.horizontal != null || marginOffset?.top != null;
    const isWrapBehindDoc = wrap?.attrs?.behindDoc;
    const isAnchorBehindDoc = anchorData?.behindDoc;
    const isBehindDocAnchor = wrap?.type === "None" && (isWrapBehindDoc || isAnchorBehindDoc);
    const isAbsolutelyPositioned = style2.includes("position: absolute;");
    if (hasAnchorData) {
      switch (anchorData.hRelativeFrom) {
        case "page":
          const pageStyles2 = this.editor?.converter?.pageStyles || this.editor?.options.parentEditor?.converter?.pageStyles;
          margin.left -= helpers$1.inchesToPixels(pageStyles2?.pageMargins?.left) || 0;
          break;
        case "margin":
          if (anchorData.alignH === "center") {
            style2 += "position: absolute; left: 50%; transform: translateX(-50%);";
          }
          if (anchorData.alignH === "left" || anchorData.alignH === "right") {
            style2 += `position: absolute; ${anchorData.alignH}: 0;`;
          }
          break;
        case "column":
          if (anchorData.alignH === "center") {
            centered = true;
          } else if (anchorData.alignH === "right") {
            floatRight = true;
            if (!style2.includes("float: right;")) {
              style2 += "float: right;";
            }
          } else if (anchorData.alignH === "left") {
            if (!style2.includes("float: left;")) {
              style2 += "float: left;";
            }
          } else if (!anchorData.alignH && marginOffset?.horizontal != null) {
            if (isAbsolutelyPositioned) {
              style2 += `left: ${baseHorizontal}px;`;
              style2 += "max-width: none;";
              baseHorizontal = 0;
            }
          }
          break;
      }
    }
    if (hasAnchorData || hasMarginOffsets) {
      const relativeFromPageV = anchorData?.vRelativeFrom === "page";
      const relativeFromMarginV = anchorData?.vRelativeFrom === "margin";
      const maxMarginV = 500;
      const allowNegativeTopOffset = isBehindDocAnchor;
      const baseTop = allowNegativeTopOffset ? marginOffset?.top ?? 0 : Math.max(0, marginOffset?.top ?? 0);
      let rotationHorizontal = 0;
      let rotationTop = 0;
      const { rotation: rotation2 } = transformData ?? {};
      const { height: height2, width: width2 } = size2 ?? {};
      if (rotation2 && height2 && width2) {
        const { horizontal: horizontal2, vertical } = getRotationMargins(width2, height2, rotation2);
        rotationHorizontal = horizontal2;
        rotationTop = vertical;
      }
      const horizontal = baseHorizontal + rotationHorizontal;
      const top2 = baseTop + rotationTop;
      if (horizontal) {
        if (floatRight) {
          margin.right += horizontal;
        } else {
          margin.left += horizontal;
        }
      }
      const appliedTopViaStyle = isAbsolutelyPositioned && allowNegativeTopOffset && !relativeFromMarginV;
      if (appliedTopViaStyle) {
        style2 += `top: ${top2}px;`;
      } else if (top2 && !relativeFromMarginV) {
        if (relativeFromPageV && top2 >= maxMarginV) margin.top += maxMarginV;
        else margin.top += top2;
      }
    }
    if (centered) {
      style2 += "margin-left: auto; margin-right: auto;";
    } else {
      if (margin.left) style2 += `margin-left: ${margin.left}px;`;
      if (margin.right) style2 += `margin-right: ${margin.right}px;`;
    }
    if (margin.top) style2 += `margin-top: ${margin.top}px;`;
    if (margin.bottom) style2 += `margin-bottom: ${margin.bottom}px;`;
    if (isBehindDocAnchor) {
      style2 += "max-width: none;";
    }
    const finalAttributes = { ...htmlAttributes };
    if (style2) {
      const existingStyle = finalAttributes.style || "";
      finalAttributes.style = existingStyle + (existingStyle ? " " : "") + style2;
    }
    return ["img", Attribute.mergeAttributes(this.options.htmlAttributes, finalAttributes)];
  },
  addCommands() {
    return {
      /**
       * Insert an image at the current position
       * @category Command
       * @param {ImageInsertOptions} options - Image insertion options
       * @example
       * editor.commands.setImage({ src: 'https://example.com/image.jpg' })
       * editor.commands.setImage({
       *   src: 'data:image/png;base64,...',
       *   alt: 'Company logo',
       *   size: { width: 200 }
       * })
       * @note Supports URLs, relative paths, and base64 data URIs
       */
      setImage: (options) => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: this.name,
          attrs: options
        });
      },
      /**
       * Set the wrapping mode and attributes for the selected image
       * @category Command
       * @param {Object} options - Wrapping options
       * @param {string} options.type - Wrap type: "None", "Square", "Through", "Tight", "TopAndBottom", "Inline"
       * @param {Object} [options.attrs] - Wrap attributes (only allowed attributes for the given type will be accepted)
       * @param {string} [options.attrs.wrapText] - Text wrapping mode for Square type: "bothSides", "largest", "left", "right"
       * @param {number} [options.attrs.distTop] - Top distance in pixels
       * @param {number} [options.attrs.distBottom] - Bottom distance in pixels
       * @param {number} [options.attrs.distLeft] - Left distance in pixels
       * @param {number} [options.attrs.distRight] - Right distance in pixels
       * @param {Array} [options.attrs.polygon] - Polygon points for Through/Tight types: [[x1,y1], [x2,y2], ...]
       * @param {boolean} [options.attrs.behindDoc] - Whether image should be behind document text (for wrapNone)
       * @example
       * // No wrapping, behind document
       * editor.commands.setWrapping({ type: 'None', attrs: {behindDoc: true} })
       *
       * // Square wrapping on both sides with distances
       * editor.commands.setWrapping({
       *   type: 'Square',
       *   attrs: {
       *     wrapText: 'bothSides',
       *     distTop: 10,
       *     distBottom: 10,
       *     distLeft: 10,
       *     distRight: 10
       *   }
       * })
       *
       * // Tight wrapping with polygon
       * editor.commands.setWrapping({
       *   type: 'Tight',
       *   attrs: {
       *     polygon: [[0, 0], [100, 0], [100, 100], [0, 100]]
       *   }
       * })
       *
       * // Top and bottom wrapping
       * editor.commands.setWrapping({
       *   type: 'TopAndBottom',
       *   attrs: {
       *     distTop: 15,
       *     distBottom: 15
       *   }
       * })
       */
      setWrapping: (options) => ({ chain, state }) => {
        const { selection } = state;
        const { $from } = selection;
        const node = $from.nodeAfter;
        if (!node || node.type.name !== this.name) {
          return false;
        }
        const { type, attrs = {} } = options;
        const allowedAttrs = {};
        const allowedAttributes = {
          None: ["behindDoc"],
          Square: ["wrapText", "distTop", "distBottom", "distLeft", "distRight"],
          Through: ["distTop", "distBottom", "distLeft", "distRight", "polygon"],
          Tight: ["distTop", "distBottom", "distLeft", "distRight", "polygon"],
          TopAndBottom: ["distTop", "distBottom"],
          Inline: []
        };
        const allowedForType = allowedAttributes[type] || [];
        Object.keys(attrs).forEach((key2) => {
          if (allowedForType.includes(key2)) {
            allowedAttrs[key2] = attrs[key2];
          }
        });
        const updatedAttrs = {
          ...node.attrs,
          wrap: {
            type,
            attrs: allowedAttrs
          },
          isAnchor: type !== "Inline"
        };
        return chain().updateAttributes(this.name, updatedAttrs).run();
      }
    };
  },
  addPmPlugins() {
    return [ImageRegistrationPlugin({ editor: this.editor }), ImagePositionPlugin({ editor: this.editor })];
  }
});
const getDataFromPageStyles = ({ editor, marginOffset, size: size2, attrs }) => {
  let style2 = "";
  let floatRight = false;
  let baseHorizontal = marginOffset?.horizontal || 0;
  const pageStyles2 = editor?.converter?.pageStyles || editor?.options.parentEditor?.converter?.pageStyles;
  if (pageStyles2?.pageSize && pageStyles2?.pageMargins && size2.width) {
    const pageWidth = helpers$1.inchesToPixels(pageStyles2.pageSize.width);
    const leftMargin = helpers$1.inchesToPixels(pageStyles2.pageMargins.left);
    const rightMargin = helpers$1.inchesToPixels(pageStyles2.pageMargins.right);
    const contentWidth = pageWidth - leftMargin - rightMargin;
    const imageWidth = size2.width + (attrs.distLeft || 0) + (attrs.distRight || 0);
    const leftSpace = marginOffset.horizontal;
    const rightSpace = contentWidth - leftSpace - imageWidth;
    if (rightSpace < 0) {
      style2 += "float: left;";
    } else if (rightSpace > leftSpace) {
      style2 += "float: left;";
    } else {
      style2 += "float: right;";
      floatRight = true;
      baseHorizontal = rightSpace;
    }
  } else {
    style2 += "float: left;";
  }
  return {
    style: style2,
    floatRight,
    baseHorizontal
  };
};
const ACCEPT_IMAGE_TYPES = [".jpg", ".jpeg", ".png", "image/jpeg", "image/png"];
const getFileOpener = () => {
  let fileInput = document.createElement("input");
  fileInput.type = "file";
  let acceptTypes = ACCEPT_IMAGE_TYPES;
  fileInput.accept = acceptTypes.join(",");
  const openFile = () => {
    return new Promise((resolve, reject) => {
      fileInput.onchange = async () => {
        const files = fileInput.files;
        if (!files) return resolve(null);
        const file = files.item(0);
        if (!file) return resolve(null);
        return resolve({ file });
      };
      fileInput.oncancel = () => resolve(null);
      fileInput.onerror = reject;
      fileInput.click();
    });
  };
  return openFile;
};
const BookmarkStart = Node$1.create({
  name: "bookmarkStart",
  group: "inline",
  content: "inline*",
  inline: true,
  addOptions() {
    return {
      /**
       * @typedef {Object} BookmarkOptions
       * @category Options
       * @property {Object} [htmlAttributes] - HTML attributes for the bookmark element
       */
      htmlAttributes: {
        style: "height: 0; width: 0;",
        "aria-label": "Bookmark start node",
        role: "link"
      }
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {string} [name] - Bookmark name for cross-references and navigation
       */
      name: {
        default: null,
        renderDOM: ({ name }) => {
          if (name) return { name };
          return {};
        }
      },
      /**
       * @category Attribute
       * @param {string} [id] - Unique identifier for the bookmark
       */
      id: {
        default: null,
        renderDOM: ({ id }) => {
          if (id) return { id };
          return {};
        }
      }
    };
  },
  renderDOM({ htmlAttributes }) {
    return ["a", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  // @ts-expect-error - Command signatures will be fixed in TS migration
  addCommands() {
    return {
      /**
       * Insert a bookmark at the current position
       * @category Command
       * @param {BookmarkConfig} config - Bookmark configuration
       * @returns {Function} Command function
       * @example
       * // Insert a named bookmark
       * insertBookmark({ name: 'chapter1' })
       *
       * // Insert with ID
       * insertBookmark({ name: 'introduction', id: 'intro-001' })
       * @note Bookmarks are invisible markers for navigation and cross-references
       */
      insertBookmark: (config) => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: this.name,
          attrs: config
        });
      },
      /**
       * Navigate to a bookmark by name
       * @category Command
       * @param {string} name - Bookmark name to navigate to
       * @returns {Function} Command function
       * @example
       * goToBookmark('chapter1')
       * @note Scrolls the document to the bookmark position
       */
      goToBookmark: (name) => ({ editor, tr }) => {
        const { doc: doc2 } = tr;
        let targetPos = null;
        doc2.descendants((node, pos) => {
          if (node.type.name === "bookmarkStart" && node.attrs.name === name) {
            targetPos = pos;
            return false;
          }
        });
        if (targetPos !== null) {
          editor.commands.focus(targetPos);
          return true;
        }
        return false;
      }
    };
  }
});
const BookmarkEnd = Node$1.create({
  name: "bookmarkEnd",
  group: "inline",
  inline: true,
  atom: true,
  addOptions() {
    return {
      /**
       * @typedef {Object} BookmarkEndOptions
       * @category Options
       * @property {Object} [htmlAttributes] - HTML attributes for the bookmark end element
       */
      htmlAttributes: {
        style: "height: 0; width: 0; display: none;",
        "aria-label": "Bookmark end node",
        role: "none"
      }
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {string} [id] - Unique identifier matching the corresponding bookmarkStart
       */
      id: {
        default: null,
        renderDOM: ({ id }) => {
          if (id) return { "data-bookmark-end-id": id };
          return {};
        }
      },
      /**
       * @category Attribute
       * @param {string} [displacedByCustomXml] - Indicates if bookmark was displaced by custom XML
       */
      displacedByCustomXml: {
        default: null,
        renderDOM: ({ displacedByCustomXml }) => {
          if (displacedByCustomXml) return { "data-displaced-by-custom-xml": displacedByCustomXml };
          return {};
        }
      },
      // Pass-through attributes that may not be used in rendering but should be preserved
      colFirst: {
        default: null
      },
      colLast: {
        default: null
      }
    };
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  // @ts-expect-error - Command signatures will be fixed in TS migration
  addCommands() {
    return {
      /**
       * Insert a bookmark end marker at the current position
       * @category Command
       * @param {string} id - The bookmark ID to match with bookmarkStart
       * @returns {Function} Command function
       * @example
       * // Insert bookmark end
       * insertBookmarkEnd('bookmark-001')
       */
      insertBookmarkEnd: (id) => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: this.name,
          attrs: { id }
        });
      }
    };
  }
});
const Mention = Node$1.create({
  name: "mention",
  group: "inline",
  inline: true,
  selectable: false,
  excludeFromSummaryJSON: true,
  atom: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: "sd-editor-mention",
        "aria-label": "Mention node"
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: `span[data-type="${this.name || this.email}"]`,
        getAttrs: (node) => ({
          name: node.getAttribute("name") || null,
          email: node.getAttribute("email") || null
        })
      }
    ];
  },
  renderDOM({ node, htmlAttributes }) {
    const { name, email } = node.attrs;
    return [
      "span",
      Attribute.mergeAttributes({ "data-type": this.name || this.email }, this.options.htmlAttributes, htmlAttributes),
      `@${name ? name : email}`
    ];
  },
  addAttributes() {
    return {
      name: { default: null },
      email: { default: null }
    };
  }
});
const PageNumber = Node$1.create({
  name: "page-number",
  group: "inline",
  inline: true,
  atom: true,
  draggable: false,
  selectable: false,
  defining: true,
  content: "",
  addOptions() {
    return {
      htmlAttributes: {
        contenteditable: false,
        "data-id": "auto-page-number",
        "aria-label": "Page number node"
      }
    };
  },
  addAttributes() {
    return {
      marksAsAttrs: {
        default: null,
        rendered: false
      }
    };
  },
  addNodeView() {
    return ({ node, editor, getPos, decorations }) => {
      const htmlAttributes = this.options.htmlAttributes;
      return new AutoPageNumberNodeView(node, getPos, decorations, editor, htmlAttributes);
    };
  },
  parseDOM() {
    return [{ tag: 'span[data-id="auto-page-number"' }];
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addCommands() {
    return {
      /**
       * Insert an automatic page number
       * @category Command
       * @returns {Function} Command function
       * @example
       * editor.commands.addAutoPageNumber()
       * @note Only works in header/footer contexts
       */
      addAutoPageNumber: () => ({ tr, dispatch, state, editor }) => {
        const { options } = editor;
        if (!options.isHeaderOrFooter) return false;
        const { schema } = state;
        const pageNumberType = schema?.nodes?.["page-number"];
        if (!pageNumberType) return false;
        const pageNumberNodeJSON = { type: "page-number" };
        const pageNumberNode = schema.nodeFromJSON(pageNumberNodeJSON);
        if (dispatch) {
          tr.replaceSelectionWith(pageNumberNode, false);
          if (!isHeadless(editor)) {
            tr.setMeta("forceUpdatePagination", true);
          }
        }
        return true;
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-Shift-alt-p": () => this.editor.commands.addAutoPageNumber()
    };
  }
});
const TotalPageCount = Node$1.create({
  name: "total-page-number",
  group: "inline",
  inline: true,
  atom: true,
  draggable: false,
  selectable: false,
  content: "text*",
  addOptions() {
    return {
      htmlAttributes: {
        contenteditable: false,
        "data-id": "auto-total-pages",
        "aria-label": "Total page count node",
        class: "sd-editor-auto-total-pages"
      }
    };
  },
  addAttributes() {
    return {
      marksAsAttrs: {
        default: null,
        rendered: false
      }
    };
  },
  addNodeView() {
    return ({ node, editor, getPos, decorations }) => {
      const htmlAttributes = this.options.htmlAttributes;
      return new AutoPageNumberNodeView(node, getPos, decorations, editor, htmlAttributes);
    };
  },
  parseDOM() {
    return [{ tag: 'span[data-id="auto-total-pages"' }];
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addCommands() {
    return {
      /**
       * Insert total page count
       * @category Command
       * @returns {Function} Command function
       * @example
       * editor.commands.addTotalPageCount()
       * @note Only works in header/footer contexts
       */
      addTotalPageCount: () => ({ tr, dispatch, state, editor }) => {
        const { options } = editor;
        if (!options.isHeaderOrFooter) return false;
        const { schema } = state;
        const pageNumberType = schema.nodes?.["total-page-number"];
        if (!pageNumberType) return false;
        const currentPages = editor?.options?.parentEditor?.currentTotalPages || 1;
        const pageNumberNode = {
          type: "total-page-number",
          content: [{ type: "text", text: String(currentPages) }]
        };
        const pageNode = schema.nodeFromJSON(pageNumberNode);
        if (dispatch) {
          tr.replaceSelectionWith(pageNode, false);
        }
        return true;
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-Shift-alt-c": () => this.editor.commands.addTotalPageCount()
    };
  }
});
const getNodeAttributes = (nodeName, editor) => {
  switch (nodeName) {
    case "page-number":
      return {
        text: editor.options.currentPageNumber || "1",
        className: "sd-editor-auto-page-number",
        dataId: "auto-page-number",
        ariaLabel: "Page number node"
      };
    case "total-page-number":
      return {
        text: editor.options.parentEditor?.currentTotalPages || "1",
        className: "sd-editor-auto-total-pages",
        dataId: "auto-total-pages",
        ariaLabel: "Total page count node"
      };
    default:
      return {};
  }
};
class AutoPageNumberNodeView {
  constructor(node, getPos, decorations, editor, htmlAttributes = {}) {
    this.node = node;
    this.editor = editor;
    this.view = editor.view;
    this.getPos = getPos;
    this.editor = editor;
    this.dom = this.#renderDom(node, htmlAttributes);
  }
  #renderDom(node, htmlAttributes) {
    const attrs = getNodeAttributes(this.node.type.name, this.editor);
    const content = document.createTextNode(String(attrs.text));
    const nodeContent = document.createElement("span");
    nodeContent.className = attrs.className;
    nodeContent.setAttribute("data-id", attrs.dataId);
    nodeContent.setAttribute("aria-label", attrs.ariaLabel);
    const currentPos = this.getPos();
    const { styles, marks } = getMarksFromNeighbors(currentPos, this.view);
    this.#scheduleUpdateNodeStyle(currentPos, marks);
    Object.assign(nodeContent.style, styles);
    nodeContent.appendChild(content);
    Object.entries(htmlAttributes).forEach(([key2, value]) => {
      if (value) nodeContent.setAttribute(key2, value);
    });
    return nodeContent;
  }
  #scheduleUpdateNodeStyle(pos, marks) {
    setTimeout(() => {
      const { state } = this.editor;
      const { dispatch } = this.view;
      const node = state.doc.nodeAt(pos);
      if (!node || node.isText) return;
      const currentMarks = node.attrs.marksAsAttrs || [];
      const newMarks = marks.map((m2) => ({ type: m2.type.name, attrs: m2.attrs }));
      const isEqual = JSON.stringify(currentMarks) === JSON.stringify(newMarks);
      if (isEqual) return;
      const newAttrs = {
        ...node.attrs,
        marksAsAttrs: newMarks
      };
      const tr = state.tr.setNodeMarkup(pos, void 0, newAttrs);
      dispatch(tr);
    }, 0);
  }
  update(node) {
    const incomingType = node?.type?.name;
    const currentType = this.node?.type?.name;
    if (!incomingType || incomingType !== currentType) return false;
    this.node = node;
    return true;
  }
}
const getMarksFromNeighbors = (currentPos, view) => {
  const $pos = view.state.doc.resolve(currentPos);
  const styles = {};
  const marks = [];
  const before = $pos.nodeBefore;
  if (before) {
    Object.assign(styles, processMarks(before.marks));
    marks.push(...before.marks);
  }
  const after = $pos.nodeAfter;
  if (after) {
    Object.assign(styles, { ...styles, ...processMarks(after.marks) });
    marks.push(...after.marks);
  }
  return {
    styles,
    marks
  };
};
const processMarks = (marks) => {
  const styles = {};
  marks.forEach((mark) => {
    const { type, attrs } = mark;
    switch (type.name) {
      case "textStyle":
        if (attrs.fontFamily) styles["font-family"] = attrs.fontFamily;
        if (attrs.fontSize) styles["font-size"] = attrs.fontSize;
        if (attrs.color) styles["color"] = attrs.color;
        if (attrs.backgroundColor) styles["background-color"] = attrs.backgroundColor;
        break;
      case "bold":
        styles["font-weight"] = "bold";
        break;
      case "italic":
        styles["font-style"] = "italic";
        break;
      case "underline":
        styles["text-decoration"] = (styles["text-decoration"] || "") + " underline";
        break;
      case "strike":
        styles["text-decoration"] = (styles["text-decoration"] || "") + " line-through";
        break;
      default:
        if (attrs?.style) {
          Object.entries(attrs.style).forEach(([key2, value]) => {
            styles[key2] = value;
          });
        }
        break;
    }
  });
  return styles;
};
const PageReference = Node$1.create({
  name: "pageReference",
  group: "inline",
  inline: true,
  atom: true,
  draggable: false,
  selectable: false,
  content: "inline*",
  addOptions() {
    return {
      htmlAttributes: {
        contenteditable: false,
        "data-id": "auto-page-reference",
        "aria-label": "Page reference node",
        class: "sd-editor-page-reference"
      }
    };
  },
  addAttributes() {
    return {
      marksAsAttrs: {
        default: null,
        rendered: false
      },
      instruction: {
        default: "",
        rendered: false
      }
    };
  },
  parseDOM() {
    return [{ tag: 'span[data-id="auto-page-reference"]' }];
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  }
});
const ShapeContainer = Node$1.create({
  name: "shapeContainer",
  group: "block",
  content: "block+",
  isolating: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: "sd-editor-shape-container",
        "aria-label": "Shape container node"
      }
    };
  },
  addAttributes() {
    return {
      fillcolor: {
        renderDOM: (attrs) => {
          if (!attrs.fillcolor) return {};
          return {
            style: `background-color: ${attrs.fillcolor}`
          };
        }
      },
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      },
      style: {
        renderDOM: (attrs) => {
          if (!attrs.style) return {};
          return {
            style: attrs.style
          };
        }
      },
      wrapAttributes: {
        rendered: false
      },
      attributes: {
        rendered: false
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: `div[data-type="${this.name}"]`
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return [
      "div",
      Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes, { "data-type": this.name }),
      0
    ];
  }
});
const ShapeTextbox = Node$1.create({
  name: "shapeTextbox",
  group: "block",
  content: "paragraph* block*",
  isolating: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: "sd-editor-shape-textbox",
        "aria-label": "Shape textbox node"
      }
    };
  },
  addAttributes() {
    return {
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      },
      attributes: {
        rendered: false
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: `div[data-type="${this.name}"]`
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return [
      "div",
      Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes, { "data-type": this.name }),
      0
    ];
  }
});
const ContentBlock = Node$1.create({
  name: "contentBlock",
  group: "inline",
  content: "",
  isolating: true,
  atom: true,
  inline: true,
  addOptions() {
    return {
      htmlAttributes: {
        contenteditable: false
      }
    };
  },
  addAttributes() {
    return {
      horizontalRule: {
        default: false,
        renderDOM: ({ horizontalRule }) => {
          if (!horizontalRule) return {};
          return { "data-horizontal-rule": "true" };
        }
      },
      size: {
        default: null,
        renderDOM: (attrs) => {
          if (!attrs.size) return {};
          let style2 = "";
          if (attrs.size.top) style2 += `top: ${attrs.size.top}px; `;
          if (attrs.size.left) style2 += `left: ${attrs.size.left}px; `;
          if (attrs.size.width)
            style2 += `width: ${attrs.size.width.toString().endsWith("%") ? attrs.size.width : `${attrs.size.width}px`}; `;
          if (attrs.size.height)
            style2 += `height: ${attrs.size.height.toString().endsWith("%") ? attrs.size.height : `${attrs.size.height}px`}; `;
          if (attrs.marginOffset?.horizontal != null || attrs.marginOffset?.top != null) {
            style2 += "position: absolute; ";
            const relativeHeight = attrs.originalAttributes?.relativeHeight;
            if (relativeHeight != null) {
              const zIndex = Math.floor(relativeHeight / 1e6);
              style2 += `z-index: ${zIndex}; `;
            } else {
              style2 += "z-index: 1; ";
            }
          }
          return { style: style2 };
        }
      },
      background: {
        default: null,
        renderDOM: (attrs) => {
          if (!attrs.background) return {};
          return {
            style: `background-color: ${attrs.background}`
          };
        }
      },
      drawingContent: {
        rendered: false
      },
      attributes: {
        rendered: false
      },
      originalAttributes: {
        rendered: false
      },
      marginOffset: {
        default: null,
        rendered: false
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: `div[data-type="${this.name}"]`
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["div", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes, { "data-type": this.name })];
  },
  // @ts-expect-error - Command signatures will be fixed in TS migration
  addCommands() {
    return {
      /**
       * Insert a horizontal rule
       * @category Command
       * @example
       * editor.commands.insertHorizontalRule()
       * @note Creates a visual separator between content sections
       */
      insertHorizontalRule: () => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: this.name,
          attrs: {
            horizontalRule: true,
            size: { width: "100%", height: 2 },
            background: "#e5e7eb"
          }
        });
      },
      /**
       * Insert a content block
       * @category Command
       * @param {ContentBlockConfig} config - Block configuration
       * @example
       * // Insert a spacer block
       * editor.commands.insertContentBlock({ size: { height: 20 } })
       *
       * @example
       * // Insert a colored divider
       * editor.commands.insertContentBlock({
       *   size: { width: '50%', height: 3 },
       *   background: '#3b82f6'
       * })
       * @note Used for spacing, dividers, and special inline content
       */
      insertContentBlock: (config) => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: this.name,
          attrs: config
        });
      }
    };
  }
});
const { findChildren } = helpers;
const SD_BLOCK_ID_ATTRIBUTE_NAME = "sdBlockId";
const BlockNodePluginKey = new superEditor_converter.PluginKey("blockNodePlugin");
const BlockNode = Extension.create({
  name: "blockNode",
  addCommands() {
    return {
      /**
       * Replace a block node by its ID with new content
       * @category Command
       * @param {string} id - The sdBlockId of the node to replace
       * @param {ProseMirrorNode} contentNode - The replacement ProseMirror node
       * @example
       * const newParagraph = editor.schema.nodes.paragraph.create({}, editor.schema.text('New content'))
       * editor.commands.replaceBlockNodeById('block-123', newParagraph)
       * @note The replacement node should have the same type as the original
       */
      replaceBlockNodeById: (id, contentNode) => ({ dispatch, tr }) => {
        const blockNode = this.editor.helpers.blockNode.getBlockNodeById(id);
        if (!blockNode || blockNode.length > 1) {
          return false;
        }
        if (dispatch) {
          let { pos, node } = blockNode[0];
          let newPosFrom = tr.mapping.map(pos);
          let newPosTo = tr.mapping.map(pos + node.nodeSize);
          let currentNode = tr.doc.nodeAt(newPosFrom);
          if (node.eq(currentNode)) {
            tr.replaceWith(newPosFrom, newPosTo, contentNode);
          }
        }
        return true;
      },
      /**
       * Delete a block node by its ID
       * @category Command
       * @param {string} id - The sdBlockId of the node to delete
       * @example
       * editor.commands.deleteBlockNodeById('block-123')
       * @note Completely removes the node from the document
       */
      deleteBlockNodeById: (id) => ({ dispatch, tr }) => {
        const blockNode = this.editor.helpers.blockNode.getBlockNodeById(id);
        if (!blockNode || blockNode.length > 1) {
          return false;
        }
        if (dispatch) {
          let { pos, node } = blockNode[0];
          let newPosFrom = tr.mapping.map(pos);
          let newPosTo = tr.mapping.map(pos + node.nodeSize);
          let currentNode = tr.doc.nodeAt(newPosFrom);
          if (node.eq(currentNode)) {
            tr.delete(newPosFrom, newPosTo);
          }
        }
        return true;
      },
      /**
       * Update attributes of a block node by its ID
       * @category Command
       * @param {string} id - The sdBlockId of the node to update
       * @param {Object} attrs - Attributes to update
       * @example
       * editor.commands.updateBlockNodeAttributes('block-123', { textAlign: 'center' })
       * @example
       * editor.commands.updateBlockNodeAttributes('block-123', { indent: { left: 20 } })
       * @note Merges new attributes with existing ones
       */
      updateBlockNodeAttributes: (id, attrs = {}) => ({ dispatch, tr }) => {
        const blockNode = this.editor.helpers.blockNode.getBlockNodeById(id);
        if (!blockNode || blockNode.length > 1) {
          return false;
        }
        if (dispatch) {
          let { pos, node } = blockNode[0];
          let newPos = tr.mapping.map(pos);
          let currentNode = tr.doc.nodeAt(newPos);
          if (node.eq(currentNode)) {
            tr.setNodeMarkup(newPos, void 0, {
              ...node.attrs,
              ...attrs
            });
          }
          return true;
        }
      }
    };
  },
  addHelpers() {
    return {
      /**
       * Get all block nodes in the document
       * @category Helper
       * @returns {Array<BlockNodeInfo>} Array of block node info objects
       * @example
       * const blocks = editor.helpers.blockNode.getBlockNodes()
       * console.log(`Found ${blocks.length} block nodes`)
       */
      getBlockNodes: () => {
        return findChildren(this.editor.state.doc, (node) => nodeAllowsSdBlockIdAttr(node));
      },
      /**
       * Get a specific block node by its ID
       * @category Helper
       * @param {string} id - The sdBlockId to search for
       * @returns {Array<BlockNodeInfo>} Array containing the matching node (or empty)
       * @example
       * const block = editor.helpers.blockNode.getBlockNodeById('block-123')
       * if (block.length) console.log('Found:', block[0].node.type.name)
       */
      getBlockNodeById: (id) => {
        return findChildren(this.editor.state.doc, (node) => node.attrs.sdBlockId === id);
      },
      /**
       * Get all block nodes of a specific type
       * @category Helper
       * @param {string} type - The node type name (e.g., 'paragraph', 'heading')
       * @returns {Array<BlockNodeInfo>} Array of matching block nodes
       * @example
       * const paragraphs = editor.helpers.blockNode.getBlockNodesByType('paragraph')
       * const headings = editor.helpers.blockNode.getBlockNodesByType('heading')
       */
      getBlockNodesByType: (type) => {
        return findChildren(this.editor.state.doc, (node) => node.type.name === type);
      },
      /**
       * Get all block nodes within a position range
       * @category Helper
       * @param {number} from - Start position
       * @param {number} to - End position
       * @returns {Array<BlockNodeInfo>} Array of block nodes in the range
       * @example
       * const selection = editor.state.selection
       * const blocksInSelection = editor.helpers.blockNode.getBlockNodesInRange(
       *   selection.from,
       *   selection.to
       * )
       */
      getBlockNodesInRange: (from3, to) => {
        let blockNodes = [];
        this.editor.state.doc.nodesBetween(from3, to, (node, pos) => {
          if (nodeAllowsSdBlockIdAttr(node)) {
            blockNodes.push({
              node,
              pos
            });
          }
        });
        return blockNodes;
      }
    };
  },
  addPmPlugins() {
    let hasInitialized = false;
    const assignBlockId = (tr, node, pos) => {
      tr.setNodeMarkup(
        pos,
        void 0,
        {
          ...node.attrs,
          sdBlockId: uuid.v4()
        },
        node.marks
      );
    };
    return [
      new superEditor_converter.Plugin({
        key: BlockNodePluginKey,
        appendTransaction: (transactions, oldState, newState) => {
          const docChanges = transactions.some((tr2) => tr2.docChanged) && !oldState.doc.eq(newState.doc);
          if (hasInitialized && !docChanges) {
            return;
          }
          if (hasInitialized && !checkForNewBlockNodesInTrs([...transactions])) {
            return;
          }
          const { tr } = newState;
          let changed = false;
          if (!hasInitialized) {
            newState.doc.descendants((node, pos) => {
              if (nodeAllowsSdBlockIdAttr(node) && nodeNeedsSdBlockId(node)) {
                assignBlockId(tr, node, pos);
                changed = true;
              }
            });
          } else {
            const rangesToCheck = [];
            let shouldFallbackToFullTraversal = false;
            transactions.forEach((transaction, txIndex) => {
              transaction.steps.forEach((step, stepIndex) => {
                if (!(step instanceof superEditor_converter.ReplaceStep)) return;
                const hasNewBlockNodes = step.slice?.content?.content?.some((node) => nodeAllowsSdBlockIdAttr(node));
                if (!hasNewBlockNodes) return;
                const stepMap = step.getMap();
                stepMap.forEach((_oldStart, _oldEnd, newStart, newEnd) => {
                  if (newEnd <= newStart) {
                    if (vue.process$1.env.NODE_ENV === "development") {
                      console.debug("Block node: invalid range in step map, falling back to full traversal");
                    }
                    shouldFallbackToFullTraversal = true;
                    return;
                  }
                  let rangeStart = newStart;
                  let rangeEnd = newEnd;
                  for (let i = stepIndex + 1; i < transaction.steps.length; i++) {
                    const laterStepMap = transaction.steps[i].getMap();
                    rangeStart = laterStepMap.map(rangeStart, -1);
                    rangeEnd = laterStepMap.map(rangeEnd, 1);
                  }
                  for (let i = txIndex + 1; i < transactions.length; i++) {
                    const laterTx = transactions[i];
                    rangeStart = laterTx.mapping.map(rangeStart, -1);
                    rangeEnd = laterTx.mapping.map(rangeEnd, 1);
                  }
                  if (rangeEnd <= rangeStart) {
                    if (vue.process$1.env.NODE_ENV === "development") {
                      console.debug("Block node: invalid range after mapping, falling back to full traversal");
                    }
                    shouldFallbackToFullTraversal = true;
                    return;
                  }
                  rangesToCheck.push([rangeStart, rangeEnd]);
                });
              });
            });
            const mergedRanges = mergeRanges(rangesToCheck);
            for (const [start2, end2] of mergedRanges) {
              const docSize = newState.doc.content.size;
              const clampedRange = clampRange(start2, end2, docSize);
              if (!clampedRange) {
                if (vue.process$1.env.NODE_ENV === "development") {
                  console.debug("Block node: invalid range after clamping, falling back to full traversal");
                }
                shouldFallbackToFullTraversal = true;
                break;
              }
              const [safeStart, safeEnd] = clampedRange;
              try {
                newState.doc.nodesBetween(safeStart, safeEnd, (node, pos) => {
                  if (nodeAllowsSdBlockIdAttr(node) && nodeNeedsSdBlockId(node)) {
                    assignBlockId(tr, node, pos);
                    changed = true;
                  }
                });
              } catch (error) {
                console.warn("Block node plugin: nodesBetween failed, falling back to full traversal", error);
                shouldFallbackToFullTraversal = true;
                break;
              }
            }
            if (shouldFallbackToFullTraversal) {
              newState.doc.descendants((node, pos) => {
                if (nodeAllowsSdBlockIdAttr(node) && nodeNeedsSdBlockId(node)) {
                  assignBlockId(tr, node, pos);
                  changed = true;
                }
              });
            }
          }
          if (changed && !hasInitialized) {
            hasInitialized = true;
            tr.setMeta("blockNodeInitialUpdate", true);
          }
          tr.setStoredMarks(newState.tr.storedMarks);
          return changed ? tr : null;
        }
      })
    ];
  }
});
const nodeAllowsSdBlockIdAttr = (node) => {
  return !!(node?.isBlock && node?.type?.spec?.attrs?.[SD_BLOCK_ID_ATTRIBUTE_NAME]);
};
const nodeNeedsSdBlockId = (node) => {
  const currentId = node?.attrs?.[SD_BLOCK_ID_ATTRIBUTE_NAME];
  return !currentId;
};
const checkForNewBlockNodesInTrs = (transactions) => {
  return Array.from(transactions).some((tr) => {
    return tr.steps.some((step) => {
      if (!(step instanceof superEditor_converter.ReplaceStep)) return false;
      const hasValidSdBlockNodes = step.slice?.content?.content?.some((node) => nodeAllowsSdBlockIdAttr(node));
      return hasValidSdBlockNodes;
    });
  });
};
const TableOfContents = Node$1.create({
  name: "tableOfContents",
  group: "block",
  content: "paragraph+",
  inline: false,
  addOptions() {
    return {
      htmlAttributes: {
        "data-id": "table-of-contents",
        "aria-label": "Table of Contents"
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: 'div[data-id="table-of-contents"]'
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["div", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      instruction: {
        default: null,
        rendered: false
      },
      /**
       * @private
       * @category Attribute
       * @param {string} [sdBlockId] - Internal block tracking ID (not user-configurable)
       */
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      }
    };
  }
});
const DocumentIndex = Node$1.create({
  name: "index",
  group: "block",
  content: "paragraph+",
  inline: false,
  addOptions() {
    return {
      htmlAttributes: {
        "data-id": "document-index",
        "aria-label": "Index"
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: 'div[data-id="document-index"]'
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["div", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      instruction: {
        default: null,
        rendered: false
      },
      instructionTokens: {
        default: null,
        rendered: false
      },
      /**
       * @private
       * @category Attribute
       * @param {string} [sdBlockId] - Internal block tracking ID (not user-configurable)
       */
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      }
    };
  }
});
function createGradient(gradientData, gradientId) {
  const { gradientType, stops, angle } = gradientData;
  if (!stops || stops.length === 0) {
    return null;
  }
  let gradient;
  if (gradientType === "linear") {
    gradient = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
    gradient.setAttribute("id", gradientId);
    const radians = angle * Math.PI / 180;
    const x1 = 50 - 50 * Math.cos(radians);
    const y1 = 50 + 50 * Math.sin(radians);
    const x2 = 50 + 50 * Math.cos(radians);
    const y2 = 50 - 50 * Math.sin(radians);
    gradient.setAttribute("x1", `${x1}%`);
    gradient.setAttribute("y1", `${y1}%`);
    gradient.setAttribute("x2", `${x2}%`);
    gradient.setAttribute("y2", `${y2}%`);
  } else {
    gradient = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
    gradient.setAttribute("id", gradientId);
    gradient.setAttribute("cx", "50%");
    gradient.setAttribute("cy", "50%");
    gradient.setAttribute("r", "50%");
  }
  stops.forEach((stop) => {
    const stopElement = document.createElementNS("http://www.w3.org/2000/svg", "stop");
    stopElement.setAttribute("offset", `${stop.position * 100}%`);
    stopElement.setAttribute("stop-color", stop.color);
    if (stop.alpha != null && stop.alpha < 1) {
      stopElement.setAttribute("stop-opacity", stop.alpha.toString());
    }
    gradient.appendChild(stopElement);
  });
  return gradient;
}
function createTextElement(textContent2, textAlign, width, height, options = {}) {
  const { textInsets, textVerticalAlign, pageNumber, totalPages } = options;
  const foreignObject = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
  foreignObject.setAttribute("x", "0");
  foreignObject.setAttribute("y", "0");
  foreignObject.setAttribute("width", width.toString());
  foreignObject.setAttribute("height", height.toString());
  const div2 = document.createElement("div");
  div2.style.width = "100%";
  div2.style.height = "100%";
  div2.style.display = "flex";
  div2.style.flexDirection = "column";
  const verticalAlign = textVerticalAlign || "center";
  if (verticalAlign === "top") {
    div2.style.justifyContent = "flex-start";
  } else if (verticalAlign === "bottom") {
    div2.style.justifyContent = "flex-end";
  } else {
    div2.style.justifyContent = "center";
  }
  if (textInsets) {
    div2.style.padding = `${textInsets.top}px ${textInsets.right}px ${textInsets.bottom}px ${textInsets.left}px`;
  } else {
    div2.style.padding = "10px";
  }
  div2.style.boxSizing = "border-box";
  div2.style.wordWrap = "break-word";
  div2.style.overflowWrap = "break-word";
  div2.style.fontSize = "12px";
  div2.style.lineHeight = "1.2";
  if (textAlign === "center") {
    div2.style.textAlign = "center";
  } else if (textAlign === "right" || textAlign === "r") {
    div2.style.textAlign = "right";
  } else {
    div2.style.textAlign = "left";
  }
  let currentParagraph = document.createElement("div");
  const resolveFieldText = (part) => {
    if (part.fieldType === "PAGE") {
      return pageNumber != null ? String(pageNumber) : "1";
    }
    if (part.fieldType === "NUMPAGES") {
      return totalPages != null ? String(totalPages) : "1";
    }
    return part.text;
  };
  textContent2.parts.forEach((part) => {
    if (part.isLineBreak) {
      div2.appendChild(currentParagraph);
      currentParagraph = document.createElement("div");
      if (part.isEmptyParagraph) {
        currentParagraph.style.minHeight = "1em";
      }
    } else {
      const span = document.createElement("span");
      span.textContent = resolveFieldText(part);
      if (part.formatting) {
        if (part.formatting.bold) {
          span.style.fontWeight = "bold";
        }
        if (part.formatting.italic) {
          span.style.fontStyle = "italic";
        }
        if (part.formatting.fontFamily) {
          span.style.fontFamily = part.formatting.fontFamily;
        }
        if (part.formatting.color) {
          span.style.color = `#${part.formatting.color}`;
        }
        if (part.formatting.fontSize) {
          span.style.fontSize = `${part.formatting.fontSize}px`;
        }
      }
      currentParagraph.appendChild(span);
    }
  });
  div2.appendChild(currentParagraph);
  foreignObject.appendChild(div2);
  return foreignObject;
}
function applyGradientToSVG(svg, gradientData) {
  const { gradientType, stops, angle } = gradientData;
  const gradientId = `gradient-${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
  let defs = svg.querySelector("defs");
  if (!defs) {
    defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    svg.insertBefore(defs, svg.firstChild);
  }
  let gradient;
  if (gradientType === "linear") {
    gradient = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
    gradient.setAttribute("id", gradientId);
    const radians = angle * Math.PI / 180;
    const x1 = 50 - 50 * Math.cos(radians);
    const y1 = 50 + 50 * Math.sin(radians);
    const x2 = 50 + 50 * Math.cos(radians);
    const y2 = 50 - 50 * Math.sin(radians);
    gradient.setAttribute("x1", `${x1}%`);
    gradient.setAttribute("y1", `${y1}%`);
    gradient.setAttribute("x2", `${x2}%`);
    gradient.setAttribute("y2", `${y2}%`);
  } else {
    gradient = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
    gradient.setAttribute("id", gradientId);
    gradient.setAttribute("cx", "50%");
    gradient.setAttribute("cy", "50%");
    gradient.setAttribute("r", "50%");
  }
  stops.forEach((stop) => {
    const stopElement = document.createElementNS("http://www.w3.org/2000/svg", "stop");
    stopElement.setAttribute("offset", `${stop.position * 100}%`);
    stopElement.setAttribute("stop-color", stop.color);
    if (stop.alpha != null && stop.alpha < 1) {
      stopElement.setAttribute("stop-opacity", stop.alpha.toString());
    }
    gradient.appendChild(stopElement);
  });
  defs.appendChild(gradient);
  const filledElements = svg.querySelectorAll('[fill]:not([fill="none"])');
  filledElements.forEach((el) => {
    el.setAttribute("fill", `url(#${gradientId})`);
  });
}
function applyAlphaToSVG(svg, alphaData) {
  const { color, alpha } = alphaData;
  const filledElements = svg.querySelectorAll('[fill]:not([fill="none"])');
  filledElements.forEach((el) => {
    el.setAttribute("fill", color);
    el.setAttribute("fill-opacity", alpha.toString());
  });
}
function generateTransforms(attrs) {
  const transforms = [];
  if (attrs.rotation != null) {
    transforms.push(`rotate(${attrs.rotation}deg)`);
  }
  if (attrs.flipH) {
    transforms.push(`scaleX(-1)`);
  }
  if (attrs.flipV) {
    transforms.push(`scaleY(-1)`);
  }
  return transforms;
}
const Z_INDEX_SCALE_FACTOR = 1e6;
class VectorShapeView {
  node;
  view;
  getPos;
  decorations;
  innerDecorations;
  editor;
  extension;
  htmlAttributes;
  root;
  constructor(props) {
    this.node = props.node;
    this.view = props.editor.view;
    this.getPos = props.getPos;
    this.decorations = props.decorations;
    this.innerDecorations = props.innerDecorations;
    this.editor = props.editor;
    this.extension = props.extension;
    this.htmlAttributes = props.htmlAttributes;
    this.mount();
  }
  mount() {
    this.buildView();
    this.#ensureParentPositioned();
  }
  /**
   * Ensures the parent paragraph element is positioned for absolute-positioned vector shapes.
   *
   * For vector shapes with wrap type 'None' (absolutely positioned), the parent paragraph
   * element must have `position: relative` to establish a containing block for CSS absolute
   * positioning. This allows the vector shape's `top` and `left` offsets to position correctly
   * relative to the paragraph.
   *
   * Uses requestAnimationFrame to defer the DOM manipulation until after the element is fully
   * mounted in the DOM tree. This prevents race conditions where the parent element might not
   * yet be available during the initial render phase.
   *
   * Only applies to wrap type 'None' - inline and floated elements do not require this setup.
   */
  #ensureParentPositioned() {
    const wrapType = this.node.attrs.wrap?.type;
    if (wrapType !== "None") return;
    if (typeof globalThis !== "undefined" && globalThis.requestAnimationFrame) {
      globalThis.requestAnimationFrame(() => {
        try {
          const parent = this.root?.parentElement;
          if (parent && parent.tagName === "P") {
            parent.style.position = "relative";
          }
        } catch (error) {
          console.warn("Failed to position parent element for vector shape:", error);
        }
      });
    }
  }
  get dom() {
    return this.root;
  }
  get contentDOM() {
    return null;
  }
  createElement() {
    const attrs = this.node.attrs;
    const element = document.createElement("span");
    element.classList.add("sd-vector-shape");
    element.setAttribute("data-vector-shape", "");
    const effectExtent = attrs.effectExtent || null;
    const extentLeft = effectExtent?.left ?? 0;
    const extentTop = effectExtent?.top ?? 0;
    const extentRight = effectExtent?.right ?? 0;
    const extentBottom = effectExtent?.bottom ?? 0;
    const baseWidth = attrs.width ?? 0;
    const baseHeight = attrs.height ?? 0;
    const outerWidth = baseWidth + extentLeft + extentRight;
    const outerHeight = baseHeight + extentTop + extentBottom;
    element.style.width = `${outerWidth}px`;
    element.style.height = `${outerHeight}px`;
    const positioningStyle = this.getPositioningStyle(attrs);
    if (positioningStyle) {
      element.style.cssText += positioningStyle;
    }
    if (effectExtent && (!element.style.position || element.style.position === "static")) {
      element.style.position = "relative";
    }
    const transforms = this.generateTransform();
    const positioningTransform = element.style.transform;
    const combinedTransforms = [];
    if (positioningTransform && positioningTransform.trim() !== "") {
      combinedTransforms.push(positioningTransform.trim());
    }
    if (Array.isArray(transforms) && transforms.length > 0) {
      const validTransforms = transforms.filter(
        (t) => t !== null && t !== void 0 && typeof t === "string" && t.trim() !== ""
      );
      if (validTransforms.length > 0) {
        combinedTransforms.push(...validTransforms);
      }
    }
    if (combinedTransforms.length > 0) {
      element.style.transform = combinedTransforms.join(" ");
    }
    const svg = this.createSVGElement(attrs);
    if (svg) {
      if (effectExtent) {
        svg.style.position = "absolute";
        svg.style.left = `${extentLeft}px`;
        svg.style.top = `${extentTop}px`;
      }
      this.applyLineEnds(svg, attrs);
      element.appendChild(svg);
      if (attrs.textContent && attrs.textContent.parts) {
        const pageNumber = this.editor?.options?.currentPageNumber;
        const totalPages = this.editor?.options?.totalPageCount;
        const textElement = this.createTextElement(attrs.textContent, attrs.textAlign, attrs.width, attrs.height, {
          textVerticalAlign: attrs.textVerticalAlign,
          textInsets: attrs.textInsets,
          pageNumber,
          totalPages
        });
        if (textElement) {
          svg.appendChild(textElement);
        }
      }
    }
    return { element };
  }
  getPositioningStyle(attrs) {
    const { anchorData, marginOffset, wrap, originalAttributes } = attrs;
    if (!anchorData && !marginOffset?.horizontal && !marginOffset?.top) {
      return "";
    }
    let style2 = "";
    const margin = { left: 0, right: 0, top: 0 };
    let centered = false;
    let floatRight = false;
    let baseHorizontal = marginOffset?.horizontal || 0;
    if (wrap?.type === "None") {
      style2 += "position: absolute;";
      const relativeHeight = originalAttributes?.relativeHeight;
      if (relativeHeight != null) {
        const zIndex = Math.floor(relativeHeight / Z_INDEX_SCALE_FACTOR);
        style2 += `z-index: ${zIndex};`;
      } else if (wrap?.attrs?.behindDoc) {
        style2 += "z-index: -1;";
      } else {
        style2 += "z-index: 1;";
      }
    }
    if (anchorData) {
      switch (anchorData.hRelativeFrom) {
        case "page":
          const pageStyles2 = this.editor?.converter?.pageStyles || this.editor?.options?.parentEditor?.converter?.pageStyles;
          margin.left -= helpers$1.inchesToPixels(pageStyles2?.pageMargins?.left) || 0;
          break;
        case "margin":
          if (anchorData.alignH === "center") {
            style2 += "position: absolute; left: 50%; transform: translateX(-50%);";
          }
          if (anchorData.alignH === "left" || anchorData.alignH === "right") {
            style2 += `position: absolute; ${anchorData.alignH}: 0;`;
          }
          break;
        case "column":
          if (anchorData.alignH === "center") {
            centered = true;
          } else if (anchorData.alignH === "right") {
            floatRight = true;
            if (!style2.includes("float: right;")) {
              style2 += "float: right;";
            }
          } else if (anchorData.alignH === "left") {
            if (!style2.includes("float: left;")) {
              style2 += "float: left;";
            }
          } else if (!anchorData.alignH && marginOffset?.horizontal != null) {
            const isAbsolutelyPositioned2 = style2.includes("position: absolute;");
            if (isAbsolutelyPositioned2) {
              style2 += `left: ${baseHorizontal}px;`;
              baseHorizontal = 0;
            }
          }
          break;
      }
    }
    const isAbsolutelyPositioned = style2.includes("position: absolute;");
    if (anchorData || marginOffset?.horizontal != null || marginOffset?.top != null) {
      const horizontal = baseHorizontal;
      const top2 = marginOffset?.top ?? 0;
      if (isAbsolutelyPositioned) {
        if (horizontal && !style2.includes("left:")) {
          style2 += `left: ${horizontal}px;`;
        }
        if (top2 != null) {
          style2 += `top: ${top2}px;`;
        }
      } else {
        if (horizontal) {
          if (floatRight) {
            margin.right += horizontal;
          } else {
            margin.left += horizontal;
          }
        }
        if (top2 > 0) {
          margin.top += top2;
        }
      }
    }
    if (centered) {
      style2 += "margin-left: auto; margin-right: auto;";
    } else if (!isAbsolutelyPositioned) {
      if (margin.left) style2 += `margin-left: ${margin.left}px;`;
      if (margin.right) style2 += `margin-right: ${margin.right}px;`;
    }
    if (!isAbsolutelyPositioned && margin.top) style2 += `margin-top: ${margin.top}px;`;
    return style2;
  }
  generateTransform() {
    return generateTransforms(this.node.attrs);
  }
  createSVGElement(attrs) {
    const { kind, fillColor, strokeColor, strokeWidth, width, height } = attrs;
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("width", width.toString());
    svg.setAttribute("height", height.toString());
    svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    svg.style.display = "block";
    const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    svg.appendChild(defs);
    let fill = "none";
    let fillOpacity = 1;
    if (fillColor) {
      if (typeof fillColor === "object") {
        if (fillColor.type === "gradient") {
          const gradientId = `gradient-${Math.random().toString(36).slice(2, 11)}-${Date.now()}`;
          const gradient = this.createGradient(fillColor, gradientId);
          if (gradient) {
            defs.appendChild(gradient);
            fill = `url(#${gradientId})`;
          }
        } else if (fillColor.type === "solidWithAlpha") {
          fill = fillColor.color;
          fillOpacity = fillColor.alpha;
        }
      } else {
        fill = fillColor;
      }
    }
    const stroke = strokeColor === null ? "none" : strokeColor || "none";
    const strokeW = strokeColor === null ? 0 : strokeColor ? strokeWidth || 1 : 0;
    let shapeElement;
    switch (kind) {
      case "rect":
        shapeElement = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        shapeElement.setAttribute("x", "0");
        shapeElement.setAttribute("y", "0");
        shapeElement.setAttribute("width", width.toString());
        shapeElement.setAttribute("height", height.toString());
        break;
      case "roundRect":
        shapeElement = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        shapeElement.setAttribute("x", "0");
        shapeElement.setAttribute("y", "0");
        shapeElement.setAttribute("width", width.toString());
        shapeElement.setAttribute("height", height.toString());
        const radius = Math.min(width, height) * 0.05;
        shapeElement.setAttribute("rx", radius.toString());
        shapeElement.setAttribute("ry", radius.toString());
        break;
      case "ellipse":
        shapeElement = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
        shapeElement.setAttribute("cx", (width / 2).toString());
        shapeElement.setAttribute("cy", (height / 2).toString());
        shapeElement.setAttribute("rx", (width / 2).toString());
        shapeElement.setAttribute("ry", (height / 2).toString());
        break;
      case "circle":
        shapeElement = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
        shapeElement.setAttribute("cx", (width / 2).toString());
        shapeElement.setAttribute("cy", (height / 2).toString());
        shapeElement.setAttribute("rx", (width / 2).toString());
        shapeElement.setAttribute("ry", (height / 2).toString());
        break;
      case "line":
      case "straightConnector1":
        shapeElement = document.createElementNS("http://www.w3.org/2000/svg", "line");
        shapeElement.setAttribute("x1", "0");
        shapeElement.setAttribute("y1", "0");
        shapeElement.setAttribute("x2", width.toString());
        shapeElement.setAttribute("y2", height.toString());
        break;
      default:
        try {
          const svgTemplate = this.generateSVG({ kind, fillColor, strokeColor, strokeWidth, width, height });
          if (svgTemplate) {
            const tempDiv = document.createElement("div");
            tempDiv.innerHTML = svgTemplate;
            const tempSvg = tempDiv.querySelector("svg");
            if (tempSvg) {
              tempSvg.setAttribute("width", width.toString());
              tempSvg.setAttribute("height", height.toString());
              tempSvg.setAttribute("preserveAspectRatio", "none");
              tempSvg.style.width = `${width}px`;
              tempSvg.style.height = `${height}px`;
              tempSvg.style.display = "block";
              return tempSvg;
            }
          }
        } catch (error) {
          console.warn("Failed to generate SVG for shape:", kind, error);
          return null;
        }
        return null;
    }
    shapeElement.setAttribute("fill", fill);
    if (fillOpacity < 1) {
      shapeElement.setAttribute("fill-opacity", fillOpacity.toString());
    }
    shapeElement.setAttribute("stroke", stroke);
    shapeElement.setAttribute("stroke-width", strokeW.toString());
    svg.appendChild(shapeElement);
    return svg;
  }
  /**
   * Applies line end markers (arrowheads) to an SVG element.
   * @param {SVGElement} svg - The SVG element to apply markers to
   * @param {Object} attrs - Shape attributes containing lineEnds, strokeColor, strokeWidth, effectExtent
   */
  applyLineEnds(svg, attrs) {
    const lineEnds = attrs.lineEnds;
    if (!lineEnds) return;
    if (attrs.strokeColor === null) return;
    const strokeColor = typeof attrs.strokeColor === "string" ? attrs.strokeColor : "#000000";
    const strokeWidth = attrs.strokeWidth ?? 1;
    if (strokeWidth <= 0) return;
    const target = svg.querySelector("line") || svg.querySelector("path") || svg.querySelector("polyline");
    if (!target) return;
    const defs = svg.querySelector("defs") || svg.insertBefore(document.createElementNS("http://www.w3.org/2000/svg", "defs"), svg.firstChild);
    const idBase = `line-end-${Math.random().toString(36).slice(2, 8)}-${Date.now()}`;
    if (lineEnds.tail) {
      const id = `${idBase}-tail`;
      this.createLineEndMarker(defs, id, lineEnds.tail, strokeColor, strokeWidth, true, attrs.effectExtent);
      target.setAttribute("marker-start", `url(#${id})`);
    }
    if (lineEnds.head) {
      const id = `${idBase}-head`;
      this.createLineEndMarker(defs, id, lineEnds.head, strokeColor, strokeWidth, false, attrs.effectExtent);
      target.setAttribute("marker-end", `url(#${id})`);
    }
  }
  /**
   * Creates an SVG marker element for a line end (arrowhead).
   * @param {SVGDefsElement} defs - The defs element to append the marker to
   * @param {string} id - Unique ID for the marker
   * @param {Object} lineEnd - Line end configuration with type, width, length
   * @param {string} strokeColor - Color to use for the marker fill
   * @param {number} _strokeWidth - Stroke width (currently unused, reserved for future scaling)
   * @param {boolean} isStart - Whether this is a start marker (tail) or end marker (head)
   * @param {Object|null} effectExtent - Effect extent for sizing, or null
   */
  createLineEndMarker(defs, id, lineEnd, strokeColor, _strokeWidth, isStart, effectExtent) {
    if (defs.querySelector(`#${id}`)) return;
    const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
    marker.setAttribute("id", id);
    marker.setAttribute("viewBox", "0 0 10 10");
    marker.setAttribute("orient", "auto");
    const sizeScale = (value) => {
      if (value === "sm") return 0.75;
      if (value === "lg") return 1.25;
      return 1;
    };
    const effectMax = effectExtent ? Math.max(effectExtent.left || 0, effectExtent.right || 0, effectExtent.top || 0, effectExtent.bottom || 0) : 0;
    const useEffectExtent = Number.isFinite(effectMax) && effectMax > 0;
    const markerWidth = useEffectExtent ? effectMax * 2 : 4 * sizeScale(lineEnd.length);
    const markerHeight = useEffectExtent ? effectMax * 2 : 4 * sizeScale(lineEnd.width);
    marker.setAttribute("markerUnits", useEffectExtent ? "userSpaceOnUse" : "strokeWidth");
    marker.setAttribute("markerWidth", markerWidth.toString());
    marker.setAttribute("markerHeight", markerHeight.toString());
    marker.setAttribute("refX", isStart ? "0" : "10");
    marker.setAttribute("refY", "5");
    const shape = this.createLineEndShape(lineEnd.type || "triangle", strokeColor, isStart);
    marker.appendChild(shape);
    defs.appendChild(marker);
  }
  /**
   * Creates an SVG shape element for a line end marker.
   * Supports diamond, oval, and triangle (default) shapes.
   * @param {string} type - The shape type ('diamond', 'oval', or 'triangle')
   * @param {string} strokeColor - Color to fill the shape with
   * @param {boolean} isStart - Whether this is a start marker (affects triangle orientation)
   * @returns {SVGElement} The created SVG shape element
   */
  createLineEndShape(type, strokeColor, isStart) {
    const normalized = type.toLowerCase();
    if (normalized === "diamond") {
      const path2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path2.setAttribute("d", "M 0 5 L 5 0 L 10 5 L 5 10 Z");
      path2.setAttribute("fill", strokeColor);
      path2.setAttribute("stroke", "none");
      return path2;
    }
    if (normalized === "oval") {
      const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      circle.setAttribute("cx", "5");
      circle.setAttribute("cy", "5");
      circle.setAttribute("r", "5");
      circle.setAttribute("fill", strokeColor);
      circle.setAttribute("stroke", "none");
      return circle;
    }
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    const d = isStart ? "M 10 0 L 0 5 L 10 10 Z" : "M 0 0 L 10 5 L 0 10 Z";
    path.setAttribute("d", d);
    path.setAttribute("fill", strokeColor);
    path.setAttribute("stroke", "none");
    return path;
  }
  createGradient(gradientData, gradientId) {
    return createGradient(gradientData, gradientId);
  }
  generateSVG({ kind, fillColor, strokeColor, strokeWidth, width, height }) {
    try {
      let fill = fillColor || "none";
      if (fillColor && typeof fillColor === "object") {
        if (fillColor.type === "gradient") {
          fill = "#cccccc";
        } else if (fillColor.type === "solidWithAlpha") {
          fill = fillColor.color;
        }
      }
      return k0({
        preset: kind,
        styleOverrides: {
          fill,
          stroke: strokeColor || "none",
          strokeWidth: strokeWidth || 0
        },
        width,
        height
      });
    } catch {
      return null;
    }
  }
  applyGradientToSVG(svg, gradientData) {
    applyGradientToSVG(svg, gradientData);
  }
  applyAlphaToSVG(svg, alphaData) {
    applyAlphaToSVG(svg, alphaData);
  }
  createTextElement(textContent2, textAlign, width, height, options) {
    return createTextElement(textContent2, textAlign, width, height, options);
  }
  buildView() {
    const { element } = this.createElement();
    this.root = element;
  }
  update() {
    return false;
  }
}
const VectorShape = Node$1.create({
  name: "vectorShape",
  group: "inline",
  inline: true,
  atom: true,
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  addAttributes() {
    return {
      kind: {
        default: "rect",
        renderDOM: (attrs) => {
          if (!attrs.kind) return {};
          return { "data-kind": attrs.kind };
        }
      },
      width: {
        default: 100,
        renderDOM: (attrs) => {
          if (attrs.width == null) return {};
          return { "data-width": attrs.width };
        }
      },
      height: {
        default: 100,
        renderDOM: (attrs) => {
          if (attrs.height == null) return {};
          return { "data-height": attrs.height };
        }
      },
      fillColor: {
        default: "#5b9bd5",
        renderDOM: (attrs) => {
          if (!attrs.fillColor) return {};
          return { "data-fill-color": attrs.fillColor };
        }
      },
      strokeColor: {
        default: "#000000",
        renderDOM: (attrs) => {
          if (!attrs.strokeColor) return {};
          return { "data-stroke-color": attrs.strokeColor };
        }
      },
      strokeWidth: {
        default: 1,
        renderDOM: (attrs) => {
          if (attrs.strokeWidth == null) return {};
          return { "data-stroke-width": attrs.strokeWidth };
        }
      },
      lineEnds: {
        default: null,
        rendered: false
      },
      hidden: {
        default: false,
        rendered: false
      },
      effectExtent: {
        default: null,
        rendered: false
      },
      rotation: {
        default: 0,
        renderDOM: (attrs) => {
          if (attrs.rotation == null) return {};
          return { "data-rotation": attrs.rotation };
        }
      },
      flipH: {
        default: false,
        renderDOM: (attrs) => {
          if (!attrs.flipH) return {};
          return { "data-flip-h": attrs.flipH };
        }
      },
      flipV: {
        default: false,
        renderDOM: (attrs) => {
          if (!attrs.flipV) return {};
          return { "data-flip-v": attrs.flipV };
        }
      },
      wrap: {
        default: { type: "Inline" },
        rendered: false
      },
      anchorData: {
        default: null,
        rendered: false
      },
      isAnchor: {
        rendered: false
      },
      marginOffset: {
        default: {},
        rendered: false
      },
      drawingContent: {
        rendered: false
      },
      originalAttributes: {
        rendered: false
      },
      textContent: {
        default: null,
        rendered: false
      },
      textAlign: {
        default: "center",
        rendered: false
      },
      textVerticalAlign: {
        default: "center",
        rendered: false
      },
      textInsets: {
        default: null,
        rendered: false
      }
    };
  },
  parseDOM() {
    return false;
  },
  renderDOM({ htmlAttributes }) {
    return [
      "span",
      Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes, { "data-vector-shape": "" })
    ];
  },
  addNodeView() {
    return (props) => {
      return new VectorShapeView({ ...props });
    };
  }
});
class ShapeGroupView {
  node;
  view;
  getPos;
  decorations;
  innerDecorations;
  editor;
  extension;
  htmlAttributes;
  root;
  constructor(props) {
    this.node = props.node;
    this.view = props.editor.view;
    this.getPos = props.getPos;
    this.decorations = props.decorations;
    this.innerDecorations = props.innerDecorations;
    this.editor = props.editor;
    this.extension = props.extension;
    this.htmlAttributes = props.htmlAttributes;
    this.mount();
  }
  mount() {
    this.buildView();
    this.#ensureParentPositioned();
  }
  /**
   * Ensures the parent paragraph element is positioned for absolute-positioned shape groups.
   *
   * For shape groups with wrap type 'None' (absolutely positioned), the parent paragraph
   * element must have `position: relative` to establish a containing block for CSS absolute
   * positioning. This allows the shape group's `top` and `left` offsets to position correctly
   * relative to the paragraph.
   *
   * Uses requestAnimationFrame to defer the DOM manipulation until after the element is fully
   * mounted in the DOM tree. This prevents race conditions where the parent element might not
   * yet be available during the initial render phase.
   *
   * Only applies to wrap type 'None' - inline and floated elements do not require this setup.
   */
  #ensureParentPositioned() {
    const wrapType = this.node.attrs.wrap?.type || "Inline";
    if (wrapType !== "None") return;
    if (typeof globalThis !== "undefined" && globalThis.requestAnimationFrame) {
      globalThis.requestAnimationFrame(() => {
        try {
          const parent = this.root?.parentElement;
          if (parent && parent.tagName === "P") {
            parent.style.position = "relative";
          }
        } catch (error) {
          console.warn("Failed to position parent element for shape group:", error);
        }
      });
    }
  }
  get dom() {
    return this.root;
  }
  get contentDOM() {
    return null;
  }
  createElement() {
    const attrs = this.node.attrs;
    const { groupTransform, shapes, size: size2, marginOffset, originalAttributes, wrap, anchorData } = attrs;
    const container = document.createElement("div");
    container.classList.add("sd-shape-group");
    container.setAttribute("data-shape-group", "");
    const width = size2?.width || groupTransform?.width || 300;
    const height = size2?.height || groupTransform?.height || 200;
    container.style.width = `${width}px`;
    container.style.height = `${height}px`;
    container.style.position = "relative";
    container.style.display = "inline-block";
    const wrapType = wrap?.type || "Inline";
    if (wrapType === "None") {
      container.style.position = "absolute";
      if (marginOffset?.horizontal != null) {
        container.style.left = `${marginOffset.horizontal}px`;
      }
      const isColumnRelative = anchorData?.hRelativeFrom === "column";
      if (isColumnRelative && !anchorData?.alignH && marginOffset?.horizontal != null) {
        container.style.maxWidth = "none";
      }
      if (marginOffset?.top != null) {
        container.style.top = `${marginOffset.top}px`;
      }
      const relativeHeight = originalAttributes?.relativeHeight;
      if (relativeHeight != null) {
        const zIndex = Math.floor(relativeHeight / 1e6);
        container.style.zIndex = zIndex.toString();
      } else {
        container.style.zIndex = "1";
      }
    } else if (wrapType === "Square") {
      container.style.float = "left";
      container.style.clear = "both";
      if (marginOffset?.horizontal != null) {
        container.style.marginLeft = `${marginOffset.horizontal}px`;
      }
      if (marginOffset?.top != null) {
        container.style.marginTop = `${marginOffset.top}px`;
      }
      if (wrap?.attrs?.distLeft) {
        container.style.marginLeft = `${(marginOffset?.horizontal || 0) + wrap.attrs.distLeft}px`;
      }
      if (wrap?.attrs?.distRight) {
        container.style.marginRight = `${wrap.attrs.distRight}px`;
      }
      if (wrap?.attrs?.distTop) {
        container.style.marginTop = `${(marginOffset?.top || 0) + wrap.attrs.distTop}px`;
      }
      if (wrap?.attrs?.distBottom) {
        container.style.marginBottom = `${wrap.attrs.distBottom}px`;
      }
    } else {
      if (marginOffset?.horizontal != null) {
        container.style.marginLeft = `${marginOffset.horizontal}px`;
      }
      if (marginOffset?.top != null) {
        container.style.marginTop = `${marginOffset.top}px`;
      }
    }
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("version", "1.1");
    svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
    svg.setAttribute("width", width.toString());
    svg.setAttribute("height", height.toString());
    svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
    svg.style.display = "block";
    const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    svg.appendChild(defs);
    if (shapes && Array.isArray(shapes)) {
      shapes.forEach((shape, index2) => {
        if (shape.shapeType === "vectorShape") {
          const shapeElement = this.createShapeElement(shape, groupTransform, defs, index2);
          if (shapeElement) {
            svg.appendChild(shapeElement);
          }
        } else if (shape.shapeType === "image") {
          const imageElement = this.createImageElement(shape, groupTransform);
          if (imageElement) {
            svg.appendChild(imageElement);
          }
        }
      });
    }
    container.appendChild(svg);
    return { element: container };
  }
  createShapeElement(shape, groupTransform, defs, shapeIndex) {
    const attrs = shape.attrs;
    if (!attrs) return null;
    const x = attrs.x ?? 0;
    const y2 = attrs.y ?? 0;
    const width = attrs.width ?? 100;
    const height = attrs.height ?? 100;
    const g2 = document.createElementNS("http://www.w3.org/2000/svg", "g");
    const transforms = [];
    transforms.push(`translate(${x}, ${y2})`);
    if (attrs.rotation !== 0) {
      transforms.push(`rotate(${attrs.rotation} ${width / 2} ${height / 2})`);
    }
    if (attrs.flipH) {
      transforms.push(`scale(-1, 1) translate(${-width}, 0)`);
    }
    if (attrs.flipV) {
      transforms.push(`scale(1, -1) translate(0, ${-height})`);
    }
    if (transforms.length > 0) {
      g2.setAttribute("transform", transforms.join(" "));
    }
    const shapeKind = attrs.kind || "rect";
    const fillColor = attrs.fillColor === null ? null : attrs.fillColor ?? "#5b9bd5";
    const strokeColor = attrs.strokeColor === null ? null : attrs.strokeColor ?? "#000000";
    const strokeWidth = attrs.strokeWidth ?? 1;
    const lineEnds = attrs.lineEnds;
    let fillValue = fillColor;
    if (fillColor && typeof fillColor === "object" && fillColor.type === "gradient") {
      const gradientId = `gradient-${shapeIndex}-${Date.now()}-${Math.floor(Math.random() * 1e9)}`;
      const gradient = this.createGradient(fillColor, gradientId);
      defs.appendChild(gradient);
      fillValue = `url(#${gradientId})`;
    } else if (fillColor === null) {
      fillValue = "none";
    } else if (typeof fillColor === "string") {
      fillValue = fillColor;
    }
    if (shapeKind === "line") {
      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", "0");
      line.setAttribute("y1", "0");
      line.setAttribute("x2", width.toString());
      line.setAttribute("y2", height.toString());
      line.setAttribute("stroke", strokeColor === null ? "none" : strokeColor);
      line.setAttribute("stroke-width", (strokeColor === null ? 0 : strokeWidth).toString());
      if (lineEnds && strokeColor !== null) {
        const markerBase = `line-end-${shapeIndex}-${Date.now()}-${Math.floor(Math.random() * 1e9)}`;
        this.applyLineEndsToTarget(line, lineEnds, strokeColor, strokeWidth, defs, markerBase);
      }
      g2.appendChild(line);
      if (attrs.textContent && attrs.textContent.parts) {
        const pageNumber = this.editor?.options?.currentPageNumber;
        const totalPages = this.editor?.options?.totalPageCount;
        const textGroup = this.createTextElement(attrs.textContent, attrs.textAlign, width, height, {
          textVerticalAlign: attrs.textVerticalAlign,
          textInsets: attrs.textInsets,
          pageNumber,
          totalPages
        });
        if (textGroup) {
          g2.appendChild(textGroup);
        }
      }
      return g2;
    }
    try {
      const svgContent = k0({
        preset: shapeKind,
        styleOverrides: {
          fill: fillValue || "none",
          stroke: strokeColor === null ? "none" : strokeColor,
          strokeWidth: strokeColor === null ? 0 : strokeWidth
        },
        width,
        height
      });
      if (svgContent) {
        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = svgContent;
        const svgElement = tempDiv.querySelector("svg");
        if (svgElement) {
          const markerBase = lineEnds ? `line-end-${shapeIndex}-${Date.now()}-${Math.floor(Math.random() * 1e9)}` : null;
          let lineEndsApplied = false;
          Array.from(svgElement.children).forEach((child) => {
            const clonedChild = child.cloneNode(true);
            if (clonedChild.tagName === "ellipse") {
              clonedChild.setAttribute("cx", (width / 2).toString());
              clonedChild.setAttribute("cy", (height / 2).toString());
              clonedChild.setAttribute("rx", (width / 2).toString());
              clonedChild.setAttribute("ry", (height / 2).toString());
            } else if (clonedChild.tagName === "circle") {
              if (width !== height) {
                const ellipse = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
                ellipse.setAttribute("cx", (width / 2).toString());
                ellipse.setAttribute("cy", (height / 2).toString());
                ellipse.setAttribute("rx", (width / 2).toString());
                ellipse.setAttribute("ry", (height / 2).toString());
                Array.from(clonedChild.attributes).forEach((attr) => {
                  if (!["cx", "cy", "r"].includes(attr.name)) {
                    ellipse.setAttribute(attr.name, attr.value);
                  }
                });
                g2.appendChild(ellipse);
                return;
              } else {
                clonedChild.setAttribute("cx", (width / 2).toString());
                clonedChild.setAttribute("cy", (height / 2).toString());
                clonedChild.setAttribute("r", (width / 2).toString());
              }
            } else if (clonedChild.tagName === "rect") {
              clonedChild.setAttribute("width", width.toString());
              clonedChild.setAttribute("height", height.toString());
            } else if (clonedChild.tagName === "path" && svgElement.hasAttribute("viewBox")) {
              const viewBox = svgElement.getAttribute("viewBox").split(" ").map(Number);
              if (viewBox.length === 4) {
                const [, , vbWidth, vbHeight] = viewBox;
                const scaleX = width / vbWidth;
                const scaleY = height / vbHeight;
                if (scaleX !== 1 || scaleY !== 1) {
                  const pathTransform = `scale(${scaleX}, ${scaleY})`;
                  const existingTransform = clonedChild.getAttribute("transform");
                  clonedChild.setAttribute(
                    "transform",
                    existingTransform ? `${existingTransform} ${pathTransform}` : pathTransform
                  );
                }
              }
            } else if (clonedChild.hasAttribute("width")) {
              clonedChild.setAttribute("width", width.toString());
            }
            if (clonedChild.hasAttribute("height") && clonedChild.tagName !== "ellipse") {
              clonedChild.setAttribute("height", height.toString());
            }
            if (lineEnds && !lineEndsApplied && (clonedChild.tagName === "path" || clonedChild.tagName === "line" || clonedChild.tagName === "polyline")) {
              this.applyLineEndsToTarget(clonedChild, lineEnds, strokeColor, strokeWidth, defs, markerBase);
              lineEndsApplied = true;
            }
            g2.appendChild(clonedChild);
          });
        }
      }
    } catch (error) {
      console.warn("Failed to generate shape SVG:", error);
      const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect.setAttribute("width", width.toString());
      rect.setAttribute("height", height.toString());
      rect.setAttribute("fill", fillColor === null ? "none" : typeof fillColor === "string" ? fillColor : "#cccccc");
      rect.setAttribute("stroke", strokeColor === null ? "none" : strokeColor);
      rect.setAttribute("stroke-width", strokeColor === null ? "0" : strokeWidth.toString());
      g2.appendChild(rect);
    }
    if (attrs.textContent && attrs.textContent.parts) {
      const pageNumber = this.editor?.options?.currentPageNumber;
      const totalPages = this.editor?.options?.totalPageCount;
      const textGroup = this.createTextElement(attrs.textContent, attrs.textAlign, width, height, {
        textVerticalAlign: attrs.textVerticalAlign,
        textInsets: attrs.textInsets,
        pageNumber,
        totalPages
      });
      if (textGroup) {
        g2.appendChild(textGroup);
      }
    }
    return g2;
  }
  createTextElement(textContent2, textAlign, width, height, options) {
    return createTextElement(textContent2, textAlign, width, height, options);
  }
  /**
   * Applies line end markers (arrowheads) to a target SVG element.
   * @param {SVGElement} target - The SVG element to apply markers to
   * @param {Object} lineEnds - Line ends configuration with head/tail
   * @param {string|null} strokeColor - Stroke color, or null if no stroke
   * @param {number} strokeWidth - Stroke width in pixels
   * @param {SVGDefsElement} defs - The defs element to append markers to
   * @param {string} markerBase - Base ID for generating unique marker IDs
   */
  applyLineEndsToTarget(target, lineEnds, strokeColor, strokeWidth, defs, markerBase) {
    if (!lineEnds || strokeColor === null || strokeWidth <= 0) return;
    if (lineEnds.tail) {
      const id = `${markerBase}-tail`;
      this.createLineEndMarker(defs, id, lineEnds.tail, strokeColor, strokeWidth, true, null);
      target.setAttribute("marker-start", `url(#${id})`);
    }
    if (lineEnds.head) {
      const id = `${markerBase}-head`;
      this.createLineEndMarker(defs, id, lineEnds.head, strokeColor, strokeWidth, false, null);
      target.setAttribute("marker-end", `url(#${id})`);
    }
  }
  /**
   * Creates an SVG marker element for a line end (arrowhead).
   * @param {SVGDefsElement} defs - The defs element to append the marker to
   * @param {string} id - Unique ID for the marker
   * @param {Object} lineEnd - Line end configuration with type, width, length
   * @param {string} strokeColor - Color to use for the marker fill
   * @param {number} _strokeWidth - Stroke width (currently unused, reserved for future scaling)
   * @param {boolean} isStart - Whether this is a start marker (tail) or end marker (head)
   * @param {Object|null} effectExtent - Effect extent for sizing, or null
   */
  createLineEndMarker(defs, id, lineEnd, strokeColor, _strokeWidth, isStart, effectExtent) {
    if (defs.querySelector(`#${id}`)) return;
    const marker = document.createElementNS("http://www.w3.org/2000/svg", "marker");
    marker.setAttribute("id", id);
    marker.setAttribute("viewBox", "0 0 10 10");
    marker.setAttribute("orient", "auto");
    const sizeScale = (value) => {
      if (value === "sm") return 0.75;
      if (value === "lg") return 1.25;
      return 1;
    };
    const effectMax = effectExtent ? Math.max(effectExtent.left || 0, effectExtent.right || 0, effectExtent.top || 0, effectExtent.bottom || 0) : 0;
    const useEffectExtent = Number.isFinite(effectMax) && effectMax > 0;
    const markerWidth = useEffectExtent ? effectMax * 2 : 4 * sizeScale(lineEnd.length);
    const markerHeight = useEffectExtent ? effectMax * 2 : 4 * sizeScale(lineEnd.width);
    marker.setAttribute("markerUnits", useEffectExtent ? "userSpaceOnUse" : "strokeWidth");
    marker.setAttribute("markerWidth", markerWidth.toString());
    marker.setAttribute("markerHeight", markerHeight.toString());
    marker.setAttribute("refX", isStart ? "0" : "10");
    marker.setAttribute("refY", "5");
    const shape = this.createLineEndShape(lineEnd.type || "triangle", strokeColor, isStart);
    marker.appendChild(shape);
    defs.appendChild(marker);
  }
  /**
   * Creates an SVG shape element for a line end marker.
   * Supports diamond, oval, and triangle (default) shapes.
   * @param {string} type - The shape type ('diamond', 'oval', or 'triangle')
   * @param {string} strokeColor - Color to fill the shape with
   * @param {boolean} isStart - Whether this is a start marker (affects triangle orientation)
   * @returns {SVGElement} The created SVG shape element
   */
  createLineEndShape(type, strokeColor, isStart) {
    const normalized = type.toLowerCase();
    if (normalized === "diamond") {
      const path2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path2.setAttribute("d", "M 0 5 L 5 0 L 10 5 L 5 10 Z");
      path2.setAttribute("fill", strokeColor);
      path2.setAttribute("stroke", "none");
      return path2;
    }
    if (normalized === "oval") {
      const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      circle.setAttribute("cx", "5");
      circle.setAttribute("cy", "5");
      circle.setAttribute("r", "5");
      circle.setAttribute("fill", strokeColor);
      circle.setAttribute("stroke", "none");
      return circle;
    }
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    const d = isStart ? "M 10 0 L 0 5 L 10 10 Z" : "M 0 0 L 10 5 L 0 10 Z";
    path.setAttribute("d", d);
    path.setAttribute("fill", strokeColor);
    path.setAttribute("stroke", "none");
    return path;
  }
  createGradient(gradientData, gradientId) {
    return createGradient(gradientData, gradientId);
  }
  createImageElement(shape, _groupTransform) {
    const attrs = shape.attrs;
    if (!attrs) return null;
    const x = attrs.x || 0;
    const y2 = attrs.y || 0;
    const width = attrs.width || 100;
    const height = attrs.height || 100;
    const image = document.createElementNS("http://www.w3.org/2000/svg", "image");
    image.setAttribute("x", x.toString());
    image.setAttribute("y", y2.toString());
    image.setAttribute("width", width.toString());
    image.setAttribute("height", height.toString());
    const src = this.editor?.storage?.image?.media?.[attrs.src] ?? attrs.src;
    image.setAttribute("href", src);
    image.setAttribute("preserveAspectRatio", "none");
    return image;
  }
  buildView() {
    const { element } = this.createElement();
    this.root = element;
  }
  update() {
    return false;
  }
}
const ShapeGroup = Node$1.create({
  name: "shapeGroup",
  group: "inline",
  inline: true,
  atom: true,
  addOptions() {
    return {
      htmlAttributes: {
        contenteditable: false
      }
    };
  },
  addAttributes() {
    return {
      groupTransform: {
        default: {},
        renderDOM: () => ({})
      },
      shapes: {
        default: [],
        renderDOM: () => ({})
      },
      size: {
        default: null,
        renderDOM: (attrs) => {
          if (!attrs.size) return {};
          const sizeData = {};
          if (attrs.size.width) sizeData["data-width"] = attrs.size.width;
          if (attrs.size.height) sizeData["data-height"] = attrs.size.height;
          return sizeData;
        }
      },
      padding: {
        default: null,
        renderDOM: (attrs) => {
          if (!attrs.padding) return {};
          const paddingData = {};
          if (attrs.padding.top != null) paddingData["data-padding-top"] = attrs.padding.top;
          if (attrs.padding.right != null) paddingData["data-padding-right"] = attrs.padding.right;
          if (attrs.padding.bottom != null) paddingData["data-padding-bottom"] = attrs.padding.bottom;
          if (attrs.padding.left != null) paddingData["data-padding-left"] = attrs.padding.left;
          return paddingData;
        }
      },
      marginOffset: {
        default: null,
        renderDOM: (attrs) => {
          if (!attrs.marginOffset) return {};
          const offsetData = {};
          if (attrs.marginOffset.horizontal != null) offsetData["data-offset-x"] = attrs.marginOffset.horizontal;
          if (attrs.marginOffset.top != null) offsetData["data-offset-y"] = attrs.marginOffset.top;
          return offsetData;
        }
      },
      hidden: {
        default: false,
        rendered: false
      },
      drawingContent: {
        rendered: false
      },
      wrap: {
        default: { type: "Inline" },
        rendered: false
      },
      anchorData: {
        default: null,
        rendered: false
      },
      originalAttributes: {
        rendered: false
      }
    };
  },
  parseDOM() {
    return false;
  },
  renderDOM({ htmlAttributes }) {
    return ["div", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes, { "data-shape-group": "" })];
  },
  addNodeView() {
    return (props) => {
      return new ShapeGroupView({ ...props });
    };
  }
});
const sharedAttributes = () => ({
  originalName: {
    default: null
  },
  originalXml: {
    default: null
  }
});
const hiddenRender = (type) => ["sd-passthrough", { "data-sd-passthrough": type, style: "display: none;" }];
const PassthroughBlock = Node$1.create({
  name: "passthroughBlock",
  group: "block",
  atom: true,
  draggable: false,
  selectable: false,
  defining: true,
  parseDOM() {
    return [{ tag: 'sd-passthrough[data-sd-passthrough="block"]' }];
  },
  renderDOM() {
    return hiddenRender("block");
  },
  addAttributes() {
    return sharedAttributes();
  }
});
const PassthroughInline = Node$1.create({
  name: "passthroughInline",
  group: "inline",
  inline: true,
  marks: "",
  // IMPORTANT: This node is registered in pm-adapter/src/constants.ts ATOMIC_INLINE_TYPES
  // If you change atom to false, you MUST remove it from that set to avoid positioning bugs
  atom: true,
  draggable: false,
  selectable: false,
  parseDOM() {
    return [{ tag: 'sd-passthrough[data-sd-passthrough="inline"]' }];
  },
  renderDOM() {
    return hiddenRender("inline");
  },
  addAttributes() {
    return sharedAttributes();
  }
});
const IndexEntry = Node$1.create({
  name: "indexEntry",
  group: "inline",
  inline: true,
  atom: true,
  draggable: false,
  selectable: false,
  content: "inline*",
  addOptions() {
    return {
      htmlAttributes: {
        contenteditable: false,
        "data-id": "document-index-entry",
        "aria-label": "Index entry",
        style: "display:none"
      }
    };
  },
  addAttributes() {
    return {
      instruction: {
        default: "",
        rendered: false
      },
      instructionTokens: {
        default: null,
        rendered: false
      },
      marksAsAttrs: {
        default: null,
        rendered: false
      }
    };
  },
  parseDOM() {
    return [{ tag: 'span[data-id="document-index-entry"]' }];
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  }
});
const TextStyle = Mark.create({
  name: "textStyle",
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  parseDOM() {
    return [
      {
        tag: "span",
        getAttrs: (el) => {
          const hasStyles = el.hasAttribute("style");
          const isAnnotation = el.classList.contains(annotationClass) || el.classList.contains(annotationContentClass);
          if (!hasStyles || isAnnotation) return false;
          return {};
        }
      },
      {
        getAttrs: (node) => {
          const fontFamily2 = node.style.fontFamily?.replace(/['"]+/g, "");
          const fontSize2 = node.style.fontSize;
          const textTransform = node.style.textTransform;
          if (fontFamily2 || fontSize2 || textTransform) {
            return {
              fontFamily: fontFamily2 || null,
              fontSize: fontSize2 || null,
              textTransform: textTransform || null
            };
          }
          return false;
        }
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {string} [styleId] - Style identifier for referencing predefined styles
       */
      styleId: {},
      /**
       * Vertical alignment for subscript/superscript text (DOCX w:vertAlign).
       * Standard values: 'superscript', 'subscript', 'baseline'.
       * When both vertAlign and position are present, position takes precedence.
       * Renders as CSS vertical-align with 65% font-size scaling for super/subscript.
       * @category Attribute
       * @param {string} [vertAlign] - Vertical alignment mode ('superscript' | 'subscript' | 'baseline')
       */
      vertAlign: {
        default: null,
        renderDOM: (attrs) => {
          if (!attrs.vertAlign || attrs.position) return {};
          if (attrs.vertAlign === "superscript") {
            return { style: "vertical-align: super; font-size: 65%;" };
          }
          if (attrs.vertAlign === "subscript") {
            return { style: "vertical-align: sub; font-size: 65%;" };
          }
          if (attrs.vertAlign === "baseline") {
            return { style: "vertical-align: baseline;" };
          }
          return {};
        },
        parseDOM: (el) => {
          const va = el.style?.verticalAlign;
          if (va === "super") return "superscript";
          if (va === "sub") return "subscript";
          if (va === "baseline") return "baseline";
          return null;
        }
      },
      /**
       * Custom vertical position offset in points (DOCX w:position).
       * Numeric value specifying vertical offset (positive raises, negative lowers).
       * Format: '{number}pt' (e.g., '2pt', '-1.5pt').
       * Takes precedence over vertAlign when both are present.
       * Renders as CSS vertical-align with the exact offset value.
       * @category Attribute
       * @param {string} [position] - Vertical position offset (e.g., '2pt', '-1pt')
       */
      position: {
        default: null,
        renderDOM: (attrs) => {
          if (!attrs.position) return {};
          return { style: `vertical-align: ${attrs.position};` };
        },
        parseDOM: (el) => {
          const va = el.style?.verticalAlign;
          if (!va) return null;
          const numeric = parseFloat(va);
          if (!Number.isNaN(numeric)) {
            return `${numeric}pt`;
          }
          return null;
        }
      }
    };
  },
  addCommands() {
    return {
      /**
       * Remove empty text style marks
       * @category Command
       * @example
       * editor.commands.removeEmptyTextStyle()
       * @note Cleanup utility to prevent empty span elements
       * @note Automatically checks if any style attributes exist before removal
       */
      removeEmptyTextStyle: () => ({ state, commands: commands2 }) => {
        const attributes = Attribute.getMarkAttributes(state, this.type);
        const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
        if (hasStyles) return true;
        return commands2.unsetMark(this.name);
      }
    };
  }
});
function createCascadeToggleCommands({
  markName,
  setCommand,
  unsetCommand,
  toggleCommand,
  negationAttrs,
  isNegation,
  extendEmptyMarkRange
} = {}) {
  if (!markName) throw new Error("createCascadeToggleCommands requires a markName");
  const capitalized = markName.charAt(0).toUpperCase() + markName.slice(1);
  const setName = setCommand ?? `set${capitalized}`;
  const unsetName = unsetCommand ?? `unset${capitalized}`;
  const toggleName = toggleCommand ?? `toggle${capitalized}`;
  const cascadeOptions = {};
  if (negationAttrs) cascadeOptions.negationAttrs = negationAttrs;
  if (typeof isNegation === "function") cascadeOptions.isNegation = isNegation;
  if (extendEmptyMarkRange !== void 0) cascadeOptions.extendEmptyMarkRange = extendEmptyMarkRange;
  return {
    [setName]: () => ({ commands: commands2 }) => commands2.setMark(markName),
    [unsetName]: () => ({ commands: commands2 }) => commands2.unsetMark(markName),
    [toggleName]: () => ({ commands: commands2 }) => commands2.toggleMarkCascade(markName, cascadeOptions)
  };
}
const Bold = Mark.create({
  name: "bold",
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  addAttributes() {
    return {
      value: {
        default: null,
        renderDOM: (attrs) => {
          if (attrs.value == null) return {};
          if (attrs.value === "0" || !attrs.value) {
            return { style: "font-weight: normal" };
          }
          return {};
        }
      }
    };
  },
  parseDOM() {
    return [
      { tag: "strong" },
      { tag: "b", getAttrs: (node) => node.style.fontWeight != "normal" && null },
      { style: "font-weight=400", clearMark: (m2) => m2.type.name == "strong" },
      { style: "font-weight", getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null }
    ];
  },
  renderDOM({ htmlAttributes }) {
    const merged = Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes);
    const { value, ...rest } = merged || {};
    if (value === "0") {
      return ["span", rest, 0];
    }
    return ["strong", rest, 0];
  },
  addCommands() {
    const { setBold, unsetBold, toggleBold } = createCascadeToggleCommands({
      markName: this.name,
      negationAttrs: { value: "0" }
    });
    return {
      /**
       * Apply bold formatting
       * @category Command
       * @example
       * editor.commands.setBold()
       * @note '0' renders as normal weight
       */
      setBold,
      /**
       * Remove bold formatting
       * @category Command
       * @example
       * editor.commands.unsetBold()
       */
      unsetBold,
      /**
       * Toggle bold formatting
       * @category Command
       * @example
       * editor.commands.toggleBold()
       */
      toggleBold
    };
  },
  addShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  }
});
const Italic = Mark.create({
  name: "italic",
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {string} [value] - Italic toggle value ('0' renders as normal)
       */
      value: {
        default: null,
        renderDOM: (attrs) => {
          if (attrs.value == null) return {};
          if (attrs.value === "0" || !attrs.value) return { style: "font-style: normal" };
          return {};
        }
      }
    };
  },
  parseDOM() {
    return [
      { tag: "i" },
      { tag: "em" },
      { style: "font-style=italic" },
      { style: "font-style=normal", clearMark: (m2) => m2.type.name == "em" }
    ];
  },
  renderDOM({ htmlAttributes }) {
    const merged = Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes);
    const { value, ...rest } = merged || {};
    if (value === "0") {
      return ["span", rest, 0];
    }
    return ["em", rest, 0];
  },
  addCommands() {
    const { setItalic, unsetItalic, toggleItalic } = createCascadeToggleCommands({
      markName: this.name,
      negationAttrs: { value: "0" }
    });
    return {
      /**
       * Apply italic formatting
       * @category Command
       * @example
       * editor.commands.setItalic()
       */
      setItalic,
      /**
       * Remove italic formatting
       * @category Command
       * @example
       * editor.commands.unsetItalic()
       */
      unsetItalic,
      /**
       * Toggle italic formatting
       * @category Command
       * @example
       * editor.commands.toggleItalic()
       */
      toggleItalic
    };
  },
  addShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  }
});
const isKeyboardInvocation = (event) => {
  return event.type === "contextmenu" && typeof event.detail === "number" && event.detail === 0 && (event.button === 0 || event.button === void 0) && event.clientX === 0 && event.clientY === 0;
};
const prefersNativeMenu = (event) => {
  if (!event) return false;
  if (event.ctrlKey || event.metaKey) {
    return true;
  }
  return isKeyboardInvocation(event);
};
const shouldAllowNativeContextMenu = (event) => {
  return prefersNativeMenu(event);
};
const shouldBypassContextMenu = shouldAllowNativeContextMenu;
const DEFAULT_SELECTION_STATE = Object.freeze({
  focused: false,
  preservedSelection: null,
  showVisualSelection: false,
  skipFocusReset: false
});
const normalizeSelectionState = (state = {}) => ({
  ...DEFAULT_SELECTION_STATE,
  ...state
});
const CustomSelectionPluginKey = new superEditor_converter.PluginKey("CustomSelection");
const handleClickOutside = (event, editor) => {
  const editorElem = editor?.options?.element;
  if (!editorElem) return;
  const isInsideEditor = editorElem?.contains(event.target);
  if (!isInsideEditor) {
    editor.setOptions({
      focusTarget: event.target
    });
  } else {
    editor.setOptions({
      focusTarget: null
    });
  }
};
function getFocusMeta(tr) {
  return tr.getMeta(CustomSelectionPluginKey);
}
function setFocusMeta(tr, value) {
  return tr.setMeta(CustomSelectionPluginKey, value);
}
function getFocusState(state) {
  return CustomSelectionPluginKey.getState(state);
}
const isToolbarInput = (target) => {
  return !!target?.closest(".button-text-input") || target?.classList?.contains("button-text-input");
};
const isToolbarButton = (target) => {
  return !!target?.closest(".toolbar-button") || target?.classList?.contains("toolbar-button");
};
const CustomSelection = Extension.create({
  name: "customSelection",
  addPmPlugins() {
    const editor = this.editor;
    const customSelectionPlugin = new superEditor_converter.Plugin({
      key: CustomSelectionPluginKey,
      state: {
        init: () => ({ ...DEFAULT_SELECTION_STATE }),
        apply: (tr, value) => {
          const meta = getFocusMeta(tr);
          if (meta !== void 0) {
            return { ...value, ...meta };
          }
          return value;
        }
      },
      view: () => {
        const clickHandler = (event) => handleClickOutside(event, editor);
        document?.addEventListener("mousedown", clickHandler);
        return {
          destroy: () => {
            document?.removeEventListener("mousedown", clickHandler);
          }
        };
      },
      props: {
        handleDOMEvents: {
          contextmenu: (view, event) => {
            if (shouldAllowNativeContextMenu(event)) {
              return false;
            }
            event.preventDefault();
            const { selection } = view.state;
            if (!selection.empty) {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: true,
                  preservedSelection: selection,
                  showVisualSelection: true,
                  skipFocusReset: true
                })
              );
            }
            setTimeout(() => {
              view.focus();
            }, 0);
            return false;
          },
          mousedown: (view, event) => {
            if (event.button === 2) {
              if (shouldAllowNativeContextMenu(event)) {
                return false;
              }
              const { selection: selection2 } = view.state;
              if (!selection2.empty) {
                view.dispatch(
                  setFocusMeta(view.state.tr, {
                    focused: true,
                    preservedSelection: selection2,
                    showVisualSelection: true,
                    skipFocusReset: true
                  })
                );
                this.editor.setOptions({
                  lastSelection: selection2,
                  preservedSelection: selection2
                });
              }
              return false;
            }
            const { selection } = view.state;
            const target = event.target;
            const isElement2 = target instanceof Element;
            const isToolbarBtn = isElement2 && isToolbarButton(target);
            const isToolbarInp = isElement2 && isToolbarInput(target);
            this.editor.setOptions({
              focusTarget: target
            });
            if (isToolbarInp && !selection.empty) {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: true,
                  preservedSelection: selection,
                  showVisualSelection: true,
                  skipFocusReset: false
                })
              );
              this.editor.setOptions({
                lastSelection: selection,
                preservedSelection: selection
              });
              return false;
            }
            if (isToolbarBtn && !isToolbarInp) {
              if (!selection.empty) {
                this.editor.setOptions({
                  lastSelection: selection
                });
                view.dispatch(
                  setFocusMeta(view.state.tr, {
                    focused: true,
                    preservedSelection: selection,
                    showVisualSelection: true,
                    skipFocusReset: false
                  })
                );
              }
              return false;
            }
            if (!isToolbarBtn && !isToolbarInp) {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: false,
                  preservedSelection: null,
                  showVisualSelection: false,
                  skipFocusReset: false
                })
              );
              if (!selection.empty && !this.editor.options.element?.contains(target)) {
                this.editor.setOptions({
                  lastSelection: selection
                });
                const clearSelectionTr = view.state.tr.setSelection(superEditor_converter.TextSelection.create(view.state.doc, 0));
                view.dispatch(clearSelectionTr);
              }
            }
          },
          focus: (view) => {
            const target = this.editor.options.focusTarget;
            const isElement2 = target instanceof Element;
            const isToolbarBtn = isElement2 && isToolbarButton(target);
            const isToolbarInp = isElement2 && isToolbarInput(target);
            const focusState = getFocusState(view.state);
            if (focusState?.skipFocusReset) {
              view.dispatch(
                setFocusMeta(view.state.tr, normalizeSelectionState({ ...focusState, skipFocusReset: false }))
              );
              return false;
            }
            if (!isToolbarBtn && !isToolbarInp) {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: false,
                  preservedSelection: null,
                  showVisualSelection: false,
                  skipFocusReset: false
                })
              );
            }
          },
          blur: (view) => {
            const target = this.editor.options.focusTarget;
            const isElement2 = target instanceof Element;
            const isToolbarBtn = isElement2 && isToolbarButton(target);
            const isToolbarInp = isElement2 && isToolbarInput(target);
            const state = getFocusState(view.state);
            if (state?.skipFocusReset) {
              return false;
            }
            if (isToolbarBtn || isToolbarInp) {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: true,
                  preservedSelection: state.preservedSelection || view.state.selection,
                  showVisualSelection: true,
                  skipFocusReset: false
                })
              );
            } else {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: false,
                  preservedSelection: null,
                  showVisualSelection: false,
                  skipFocusReset: false
                })
              );
            }
          }
        },
        decorations: (state) => {
          const { selection, doc: doc2 } = state;
          const focusState = getFocusState(state);
          const shouldShowSelection = focusState.showVisualSelection && (focusState.preservedSelection || !selection.empty && focusState.focused);
          if (!shouldShowSelection) {
            return null;
          }
          const targetSelection = focusState.preservedSelection || selection;
          if (targetSelection.empty) {
            return null;
          }
          return DecorationSet.create(doc2, [
            Decoration.inline(targetSelection.from, targetSelection.to, {
              class: "sd-custom-selection"
            })
          ]);
        }
      }
    });
    return [customSelectionPlugin];
  },
  addCommands() {
    return {
      /**
       * Restore the preserved selection
       * @category Command
       * @returns {Function} Command function
       * @example
       * // Restore selection after toolbar interaction
       * editor.commands.restorePreservedSelection()
       * @note Used internally to maintain selection when interacting with toolbar
       */
      restorePreservedSelection: () => ({ tr, state }) => {
        const focusState = getFocusState(state);
        if (focusState.preservedSelection) {
          return tr.setSelection(focusState.preservedSelection);
        }
        const lastSelection = this.editor.options.lastSelection;
        if (lastSelection) {
          return tr.setSelection(lastSelection);
        }
        return tr;
      }
    };
  }
});
const getLinkedStyle = (styleId, styles = []) => {
  const linkedStyle = styles.find((style2) => style2.id === styleId);
  const basedOn = linkedStyle?.definition?.attrs?.basedOn;
  const basedOnStyle = styles.find((style2) => style2.id === basedOn);
  return { linkedStyle, basedOnStyle };
};
const getQuickFormatList = (editor) => {
  if (!editor?.converter?.linkedStyles) return [];
  return editor.converter.linkedStyles.filter((style2) => style2.type === "paragraph" && style2.definition?.attrs).sort((a, b2) => {
    const nameA = a.definition.attrs?.name ?? "";
    const nameB = b2.definition.attrs?.name ?? "";
    return nameA.localeCompare(nameB);
  });
};
const generateLinkedStyleString = (linkedStyle, basedOnStyle, node, parent, _includeSpacing = true) => {
  if (!linkedStyle?.definition?.styles) return "";
  const markValue = {};
  const linkedDefinitionStyles = { ...linkedStyle.definition.styles };
  const basedOnDefinitionStyles = { ...basedOnStyle?.definition?.styles };
  const resultStyles = { ...linkedDefinitionStyles };
  const inheritKeys = [
    "font-size",
    "font-family",
    "text-transform",
    "bold",
    "italic",
    "underline",
    "strike",
    "color",
    "highlight"
  ];
  inheritKeys.forEach((k2) => {
    if (!linkedDefinitionStyles[k2] && basedOnDefinitionStyles[k2]) {
      resultStyles[k2] = basedOnDefinitionStyles[k2];
    }
  });
  Object.entries(resultStyles).forEach(([k2, value]) => {
    const key2 = superEditor_converter.kebabCase(k2);
    const flattenedMarks = [];
    node?.marks?.forEach((n) => {
      if (n.type.name === "textStyle") {
        Object.entries(n.attrs).forEach(([styleKey, value2]) => {
          const parsedKey = superEditor_converter.kebabCase(styleKey);
          if (!value2) return;
          flattenedMarks.push({ key: parsedKey, value: value2 });
        });
        return;
      }
      flattenedMarks.push({ key: n.type.name, value: n.attrs[key2] });
    });
    const underlineNone = node?.marks?.some((m2) => m2.type?.name === "underline" && m2.attrs?.underlineType === "none");
    if (underlineNone) {
      markValue["text-decoration"] = "none";
    }
    const mark = flattenedMarks.find((n) => n.key === key2);
    if (!mark) {
      if (key2 === "bold" && node) {
        const boldValue = typeof value === "object" && value !== null ? value.value : value;
        const hasInlineBoldOff = node.marks?.some((m2) => m2.type?.name === "bold" && m2.attrs?.value === "0");
        const hasInlineBoldOn = node.marks?.some((m2) => m2.type?.name === "bold" && m2.attrs?.value !== "0");
        if (!hasInlineBoldOff && !hasInlineBoldOn && boldValue !== "0" && boldValue !== false) {
          markValue["font-weight"] = "bold";
        }
      } else if (key2 === "italic" && node) {
        const italicValue = typeof value === "object" && value !== null ? value.value : value;
        const hasInlineItalicOff = node.marks?.some((m2) => m2.type?.name === "italic" && m2.attrs?.value === "0");
        const hasInlineItalicOn = node.marks?.some((m2) => m2.type?.name === "italic" && m2.attrs?.value !== "0");
        if (!hasInlineItalicOff && !hasInlineItalicOn && italicValue !== "0" && italicValue !== false) {
          markValue["font-style"] = "italic";
        }
      } else if (key2 === "strike" && node) {
        const strikeValue = typeof value === "object" && value !== null ? value.value : value;
        const hasInlineStrikeOff = node.marks?.some((m2) => m2.type?.name === "strike" && m2.attrs?.value === "0");
        const hasInlineStrikeOn = node.marks?.some(
          (m2) => m2.type?.name === "strike" && (m2.attrs?.value === void 0 || m2.attrs?.value !== "0")
        );
        if (!hasInlineStrikeOff && !hasInlineStrikeOn && strikeValue !== "0" && strikeValue !== false) {
          markValue["text-decoration"] = "line-through";
        }
      } else if (key2 === "text-transform" && node) {
        markValue[key2] = value;
      } else if (key2 === "font-size" && node) {
        markValue[key2] = value;
      } else if (key2 === "font-family" && node) {
        markValue[key2] = value;
      } else if (key2 === "color" && node) {
        markValue[key2] = value;
      } else if (key2 === "highlight" && node) {
        const hasInlineHighlight = node.marks?.some((m2) => m2.type?.name === "highlight");
        if (!hasInlineHighlight) {
          const color = typeof value === "string" ? value : value?.color;
          if (color) markValue["background-color"] = color;
        }
      } else if (key2 === "underline" && node) {
        const styleValRaw = value?.underline ?? value?.underlineType ?? value?.value ?? (typeof value === "string" ? value : "");
        const styleVal = styleValRaw.toString().toLowerCase();
        const hasInlineUnderlineOff = node.marks?.some(
          (m2) => m2.type?.name === "underline" && m2.attrs?.underlineType === "none"
        );
        const hasInlineUnderlineOn = node.marks?.some(
          (m2) => m2.type?.name === "underline" && m2.attrs?.underlineType && m2.attrs.underlineType !== "none"
        );
        if (!hasInlineUnderlineOff && !hasInlineUnderlineOn) {
          if (styleVal && styleVal !== "none" && styleVal !== "0") {
            const colorVal = value && typeof value === "object" ? value.color || value.underlineColor || null : null;
            const css = superEditor_converter.getUnderlineCssString({ type: styleVal, color: colorVal });
            css.split(";").forEach((decl) => {
              const d = decl.trim();
              if (!d) return;
              const idx = d.indexOf(":");
              if (idx === -1) return;
              const k3 = d.slice(0, idx).trim();
              const v = d.slice(idx + 1).trim();
              markValue[k3] = v;
            });
          }
        }
      } else if (typeof value === "string") {
        markValue[key2] = value;
      }
    }
  });
  const final = Object.entries(markValue).map(([key2, value]) => `${key2}: ${value}`).join(";");
  return final;
};
const applyLinkedStyleToTransaction = (tr, editor, style2) => {
  if (!style2) return false;
  let selection = tr.selection;
  const state = editor.state;
  const focusState = CustomSelectionPluginKey.getState(state);
  if (selection.empty && focusState?.preservedSelection && !focusState?.preservedSelection.empty) {
    selection = focusState.preservedSelection;
    tr.setSelection(selection);
  } else if (selection.empty && editor.options.lastSelection) {
    selection = editor.options.lastSelection;
    tr.setSelection(selection);
  }
  const { from: from3, to } = selection;
  const getUpdatedParagraphAttrs = (node) => {
    return {
      ...node.attrs,
      paragraphProperties: {
        ...node.attrs.paragraphProperties || {},
        styleId: style2.id
      }
    };
  };
  const clearFormattingMarks = (startPos, endPos) => {
    tr.doc.nodesBetween(startPos, endPos, (node, pos) => {
      if (node.isText && node.marks.length > 0) {
        const marksToRemove = [
          "textStyle",
          "bold",
          "italic",
          "underline",
          "strike",
          "subscript",
          "superscript",
          "highlight"
        ];
        node.marks.forEach((mark) => {
          if (marksToRemove.includes(mark.type.name)) {
            tr.removeMark(pos, pos + node.nodeSize, mark);
          }
        });
      }
      return true;
    });
  };
  if (from3 === to) {
    let pos = from3;
    let paragraphNode = tr.doc.nodeAt(from3);
    if (paragraphNode?.type.name !== "paragraph") {
      const parentNode2 = superEditor_converter.findParentNode((node) => node.type.name === "paragraph")(selection);
      if (!parentNode2) return false;
      pos = parentNode2.pos;
      paragraphNode = parentNode2.node;
    }
    clearFormattingMarks(pos + 1, pos + paragraphNode.nodeSize - 1);
    tr.setNodeMarkup(pos, void 0, getUpdatedParagraphAttrs(paragraphNode));
    return true;
  }
  const paragraphPositions = [];
  tr.doc.nodesBetween(from3, to, (node, pos) => {
    if (node.type.name === "paragraph") {
      paragraphPositions.push({ node, pos });
    }
    return true;
  });
  paragraphPositions.forEach(({ node, pos }) => {
    clearFormattingMarks(pos + 1, pos + node.nodeSize - 1);
    tr.setNodeMarkup(pos, void 0, getUpdatedParagraphAttrs(node));
  });
  return true;
};
const stepInsertsTextIntoStyledParagraph = (tr, oldEditorState, step, stepIndex) => {
  if (!step.slice || step.slice.size === 0 || typeof step.from !== "number") {
    return false;
  }
  let insertsText = false;
  step.slice.content.descendants((node) => {
    if (node.type?.name === "text" && node.text?.length) {
      insertsText = true;
      return false;
    }
    return true;
  });
  if (!insertsText) return false;
  const docBeforeStep = tr.docs?.[stepIndex] || oldEditorState.doc;
  if (!docBeforeStep) return false;
  const resolvedPos = Math.min(step.from, docBeforeStep.content.size);
  const $pos = docBeforeStep.resolve(resolvedPos);
  for (let depth = $pos.depth; depth >= 0; depth--) {
    const node = $pos.node(depth);
    if (node?.type?.name === "paragraph") {
      return Boolean(node.attrs?.paragraphProperties?.styleId);
    }
  }
  return false;
};
const LinkedStylesPluginKey = new superEditor_converter.PluginKey("linkedStyles");
const createLinkedStylesPlugin = (editor) => {
  return new superEditor_converter.Plugin({
    key: LinkedStylesPluginKey,
    state: {
      /**
       * Initialize plugin state with styles and decorations
       * @returns {Object} Initial state with styles and decorations
       * @private
       */
      init() {
        if (!editor.converter || editor.options.mode !== "docx") return {};
        const styles = editor.converter?.linkedStyles || [];
        return {
          styles,
          decorations: generateDecorations(editor.state, styles)
        };
      },
      /**
       * Update decorations when document changes
       * @param {Object} tr - The transaction
       * @param {Object} prev - Previous plugin state
       * @param {Object} oldEditorState - Old editor state
       * @param {Object} newEditorState - New editor state
       * @returns {Object} Updated state with styles and decorations
       * @private
       */
      apply(tr, prev, oldEditorState, newEditorState) {
        if (!editor.converter || editor.options.mode !== "docx") return { ...prev };
        let decorations = prev.decorations || DecorationSet.empty;
        if (tr.docChanged) {
          let mightAffectStyles = false;
          const styleRelatedMarks = /* @__PURE__ */ new Set(["textStyle", "bold", "italic", "underline", "strike"]);
          tr.steps.forEach((step, index2) => {
            if (step.slice) {
              step.slice.content.descendants((node, pos) => {
                if (node.type.name === "paragraph") {
                  const paragraphProps = superEditor_converter.calculateResolvedParagraphProperties(
                    editor,
                    node,
                    newEditorState.doc.resolve(pos)
                  );
                  if (paragraphProps.styleId) {
                    mightAffectStyles = true;
                  }
                  return false;
                }
                if (node.marks.length > 0) {
                  const hasStyleMarks = node.marks.some((mark) => styleRelatedMarks.has(mark.type.name));
                  if (hasStyleMarks) {
                    mightAffectStyles = true;
                    return false;
                  }
                }
              });
            }
            if (step.jsonID === "addMark" || step.jsonID === "removeMark") {
              if (step.mark && styleRelatedMarks.has(step.mark.type.name)) {
                mightAffectStyles = true;
              }
            }
            if (!mightAffectStyles && stepInsertsTextIntoStyledParagraph(tr, oldEditorState, step, index2)) {
              mightAffectStyles = true;
            }
          });
          if (mightAffectStyles) {
            const styles = LinkedStylesPluginKey.getState(editor.state).styles;
            decorations = generateDecorations(newEditorState, styles);
          } else {
            decorations = decorations.map(tr.mapping, tr.doc);
          }
        }
        return { ...prev, decorations };
      }
    },
    props: {
      /**
       * Provide decorations to the editor view
       * @param {Object} state - Current editor state
       * @returns {Object} The decoration set
       * @private
       */
      decorations(state) {
        return LinkedStylesPluginKey.getState(state)?.decorations;
      }
    }
  });
};
const generateDecorations = (state, styles) => {
  const decorations = [];
  const doc2 = state?.doc;
  if (!doc2 || !state) return DecorationSet.empty;
  const getParagraphStyleId = (pos) => {
    const $pos = state.doc.resolve(pos);
    for (let d = $pos.depth; d >= 0; d--) {
      const n = $pos.node(d);
      if (n?.type?.name === "paragraph") {
        const paragraphProps = superEditor_converter.getResolvedParagraphProperties(n);
        return paragraphProps.styleId || null;
      }
    }
    return null;
  };
  doc2.descendants((node, pos) => {
    const { name } = node.type;
    if (name !== "text") return;
    const paragraphStyleId = getParagraphStyleId(pos);
    let runStyleId = null;
    let inlineTextStyleId = null;
    for (const mark of node.marks) {
      if (mark.type.name === "run") {
        const rp = mark.attrs?.runProperties;
        if (rp && typeof rp === "object" && !Array.isArray(rp) && rp.styleId) runStyleId = rp.styleId;
        else if (Array.isArray(rp)) {
          const ent = rp.find((e) => e?.xmlName === "w:rStyle");
          const sid = ent?.attributes?.["w:val"];
          if (sid) runStyleId = sid;
        }
      } else if (mark.type.name === "textStyle" && mark.attrs?.styleId) {
        inlineTextStyleId = mark.attrs.styleId;
      }
    }
    const buildStyleMap = (sid) => {
      if (!sid) return {};
      const { linkedStyle, basedOnStyle: basedOnStyle2 } = getLinkedStyle(sid, styles);
      if (!linkedStyle) return {};
      const base2 = { ...basedOnStyle2?.definition?.styles || {} };
      return { ...base2, ...linkedStyle.definition?.styles || {} };
    };
    const pMap = buildStyleMap(paragraphStyleId);
    let tMap;
    if (paragraphStyleId?.startsWith("TOC")) {
      tMap = {};
    } else {
      tMap = buildStyleMap(inlineTextStyleId);
    }
    const rMap = buildStyleMap(runStyleId);
    const finalStyles = { ...pMap, ...tMap, ...rMap };
    if (Object.keys(finalStyles).length === 0) return;
    const mergedLinkedStyle = { definition: { styles: finalStyles, attrs: {} } };
    const basedOnStyle = null;
    const $pos = state.doc.resolve(pos);
    $pos.parent;
    const styleString = generateLinkedStyleString(mergedLinkedStyle, basedOnStyle, node);
    if (!styleString) return;
    const decoration = Decoration.inline(pos, pos + node.nodeSize, { style: styleString });
    decorations.push(decoration);
  });
  return DecorationSet.create(doc2, decorations);
};
const LinkedStyles = Extension.create({
  name: "linkedStyles",
  priority: 1,
  // We need this plugin to run before the list plugins
  addOptions() {
    return {};
  },
  addPmPlugins() {
    return [createLinkedStylesPlugin(this.editor)];
  },
  addCommands() {
    return {
      /**
       * Apply a linked style to the selected paragraphs
       * @category Command
       * @param {LinkedStyle} style - The style object to apply
       * @example
       * const style = editor.helpers.linkedStyles.getStyleById('Heading1');
       * editor.commands.setLinkedStyle(style);
       * @note Clears existing formatting when applying a style
       * @note Works with custom selection preservation
       */
      setLinkedStyle: (style2) => (params2) => {
        const { tr } = params2;
        return applyLinkedStyleToTransaction(tr, this.editor, style2);
      },
      /**
       * Toggle a linked style on the current selection
       * @category Command
       * @param {LinkedStyle} style - The linked style to apply (with id property)
       * @example
       * const style = editor.helpers.linkedStyles.getStyleById('Heading1');
       * editor.commands.toggleLinkedStyle(style)
       * @note If selection is empty, returns false
       * @note Removes style if already applied, applies it if not
       */
      toggleLinkedStyle: (style2) => (params2) => {
        const { tr } = params2;
        if (tr.selection.empty) {
          return false;
        }
        let node = tr.doc.nodeAt(tr.selection.$from.pos);
        if (node && node.type.name !== "paragraph") {
          node = superEditor_converter.findParentNodeClosestToPos(tr.selection.$from, (n) => {
            return n.type.name === "paragraph";
          })?.node;
        }
        if (!node) {
          return false;
        }
        const paragraphProps = superEditor_converter.getResolvedParagraphProperties(node);
        const currentStyleId = paragraphProps.styleId;
        if (currentStyleId === style2.id) {
          return applyLinkedStyleToTransaction(tr, this.editor, { id: null });
        }
        return applyLinkedStyleToTransaction(tr, this.editor, style2);
      },
      /**
       * Apply a linked style by its ID
       * @category Command
       * @param {string} styleId - The style ID to apply (e.g., 'Heading1')
       * @example
       * editor.commands.setStyleById('Heading1')
       * editor.commands.setStyleById('Normal')
       * @note Looks up the style from loaded Word styles
       */
      setStyleById: (styleId) => (params2) => {
        const { state, tr } = params2;
        const pluginState = LinkedStylesPluginKey.getState(state);
        if (!pluginState) return false;
        const style2 = pluginState.styles?.find((s) => s.id === styleId);
        if (!style2) return false;
        return applyLinkedStyleToTransaction(tr, this.editor, style2);
      }
    };
  },
  addHelpers() {
    return {
      /**
       * Get all available linked styles
       * @category Helper
       * @returns {Array} Array of linked style objects
       * @example
       * const styles = editor.helpers.linkedStyles.getStyles();
       * // Returns all styles from the Word document
       */
      getStyles: () => {
        const styles = LinkedStylesPluginKey.getState(this.editor.state)?.styles || [];
        return styles;
      },
      /**
       * Get a specific style by ID
       * @category Helper
       * @param {string} styleId - The style ID to find
       * @returns {Object} The style object or undefined
       * @example
       * const headingStyle = editor.helpers.linkedStyles.getStyleById('Heading1');
       */
      getStyleById: (styleId) => {
        const styles = this.editor.helpers[this.name].getStyles();
        return styles.find((s) => s.id === styleId);
      },
      /**
       * Get the CSS string for a style
       * @category Helper
       * @param {string} styleId - The style ID
       * @returns {string} CSS style string
       * @example
       * const css = editor.helpers.linkedStyles.getLinkedStyleString('Heading1');
       * // Returns: "font-size: 16pt; font-weight: bold; color: #2E74B5"
       * @private
       */
      getLinkedStyleString: (styleId) => {
        const styles = this.editor.helpers.linkedStyles.getStyles();
        const style2 = styles.find((s) => s.id === styleId);
        if (!style2) return "";
        return generateLinkedStyleString(style2);
      }
    };
  }
});
const Underline = Mark.create({
  name: "underline",
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  parseDOM() {
    return [
      { tag: "u" },
      { style: "text-decoration=underline" },
      { style: "text-decoration=auto", clearMark: (m2) => m2.type.name == "u" }
    ];
  },
  renderDOM({ htmlAttributes }) {
    const merged = Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes);
    const type = merged?.underlineType;
    const color = merged?.underlineColor;
    const css = superEditor_converter.getUnderlineCssString({ type, color });
    const { style: style2, ...rest } = merged || {};
    const styleString = [style2, css].filter(Boolean).join("; ");
    if (type === "none") {
      return ["span", { ...rest, ...styleString ? { style: styleString } : {} }, 0];
    }
    return ["u", { ...rest, ...styleString ? { style: styleString } : {} }, 0];
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {UnderlineConfig} [underlineType='single'] - Style of underline
       */
      underlineType: {
        default: "single"
      },
      underlineColor: {
        default: null
      }
    };
  },
  addCommands() {
    const { setUnderline, unsetUnderline, toggleUnderline } = createCascadeToggleCommands({
      markName: this.name,
      negationAttrs: { underlineType: "none" },
      isNegation: (attrs) => attrs?.underlineType === "none"
    });
    return {
      /**
       * Apply underline formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * setUnderline()
       */
      setUnderline,
      /**
       * Remove underline formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * unsetUnderline()
       */
      unsetUnderline,
      /**
       * Toggle underline formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleUnderline()
       */
      toggleUnderline
    };
  },
  addShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});
const Highlight = Mark.create({
  name: "highlight",
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  addAttributes() {
    return {
      color: {
        default: null,
        parseDOM: (element) => element.getAttribute("data-color") || element.style.backgroundColor,
        renderDOM: (attributes) => {
          if (!attributes.color) {
            return {};
          }
          return {
            "data-color": attributes.color,
            style: `background-color: ${attributes.color}; color: inherit`
          };
        }
      }
    };
  },
  parseDOM() {
    return [{ tag: "mark" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["mark", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addCommands() {
    return {
      /**
       * Apply highlight with specified color
       * @category Command
       * @param {string} color - CSS color value
       * @example
       * editor.commands.setHighlight('#FFEB3B')
       * editor.commands.setHighlight('rgba(255, 235, 59, 0.5)')
       */
      setHighlight: (color) => ({ commands: commands2 }) => commands2.setMark(this.name, { color }),
      /**
       * Remove highlight formatting
       * @category Command
       * @example
       * editor.commands.unsetHighlight()
       */
      unsetHighlight: () => ({ commands: commands2 }) => commands2.unsetMark(this.name),
      /**
       * Toggle highlight formatting
       * @category Command
       * @example
       * editor.commands.toggleHighlight()
       */
      toggleHighlight: () => ({ commands: commands2 }) => commands2.toggleMark(this.name)
    };
  },
  addShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  }
});
const Strike = Mark.create({
  name: "strike",
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  parseDOM() {
    return [
      { tag: "s" },
      { style: "text-decoration=line-through" },
      { style: "text-decoration=auto", clearMark: (m2) => m2.type.name == "s" }
    ];
  },
  renderDOM({ mark, htmlAttributes }) {
    const merged = Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes);
    const { value } = mark.attrs;
    const { ...rest } = merged || {};
    if (value === "0" || value === false) {
      return ["span", rest, 0];
    }
    return ["s", rest, 0];
  },
  addCommands() {
    const { setStrike, unsetStrike, toggleStrike } = createCascadeToggleCommands({
      markName: this.name,
      negationAttrs: { value: "0" }
    });
    return {
      /**
       * Apply strikethrough formatting
       * @category Command
       * @example
       * editor.commands.setStrike()
       */
      setStrike,
      /**
       * Remove strikethrough formatting
       * @category Command
       * @example
       * editor.commands.unsetStrike()
       */
      unsetStrike,
      /**
       * Toggle strikethrough formatting
       * @category Command
       * @example
       * editor.commands.toggleStrike()
       */
      toggleStrike
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {string} [value] - Strike toggle value ('0' renders as normal)
       */
      value: {
        default: null,
        renderDOM: (attrs) => {
          if (attrs.value == null) return {};
          if (attrs.value === "0" || !attrs.value) {
            return { style: "text-decoration: none" };
          }
          return {};
        }
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-Shift-x": () => this.editor.commands.toggleStrike(),
      "Mod-Shift-X": () => this.editor.commands.toggleStrike()
    };
  }
});
const Link = Mark.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: false,
  inclusive: false,
  addOptions() {
    return {
      protocols: ["http", "https"],
      htmlAttributes: {
        target: null,
        rel: "noopener noreferrer nofollow",
        class: null,
        title: null
      }
    };
  },
  parseDOM() {
    return [{ tag: "a" }];
  },
  renderDOM({ htmlAttributes }) {
    const sanitizedHref = sanitizeLinkHref(htmlAttributes.href, this.options.protocols);
    const attrs = { ...htmlAttributes };
    attrs.href = sanitizedHref ? sanitizedHref.href : "";
    return ["a", Attribute.mergeAttributes(this.options.htmlAttributes, attrs), 0];
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {string} [href] - URL or anchor reference
       */
      href: {
        default: null,
        renderDOM: ({ href, name }) => {
          const sanitized = sanitizeLinkHref(href, this.options.protocols);
          if (sanitized) return { href: sanitized.href };
          if (name) return { href: `#${name}` };
          return {};
        }
      },
      /**
       * @category Attribute
       * @param {TargetFrameOptions} [target='_blank'] - Link target window
       */
      target: {
        default: this.options.htmlAttributes.target,
        renderDOM: ({ target, href }) => {
          if (target) return { target };
          const sanitized = sanitizeLinkHref(href, this.options.protocols);
          if (sanitized && sanitized.isExternal) return { target: "_blank" };
          return {};
        }
      },
      /**
       * @category Attribute
       * @param {string} [rel='noopener noreferrer nofollow'] - Relationship attributes
       */
      rel: { default: this.options.htmlAttributes.rel },
      /**
       * @private
       * @category Attribute
       * @param {string} [rId] - Word relationship ID for internal links
       */
      rId: { default: this.options.htmlAttributes.rId || null },
      /**
       * @category Attribute
       * @param {string} [text] - Display text for the link
       */
      text: { default: null },
      /**
       * @category Attribute
       * @param {string} [name] - Anchor name for internal references
       */
      name: { default: null },
      /**
       * @category Attribute
       * @param {boolean} [history] - Specifies whether the target of the hyperlink  shall be added to a list of viewed hyperlinks when it is invoked.
       */
      history: { default: true, rendered: false },
      /**
       * @category Attribute
       * @param {string|null} [anchor] - Specifies the name of a bookmark that is the target of this link. If the rId and href attributes are specified, then this attribute is ignored.
       */
      anchor: { rendered: false },
      /**
       * @category Attribute
       * @param {string|null} [docLocation] - Specifies a location in the target of the hyperlink.
       */
      docLocation: { rendered: false },
      /**
       * @category Attribute
       * @param {string|null} [tooltip] - A tooltip for the link
       */
      tooltip: {
        default: null,
        renderDOM: ({ tooltip }) => {
          const result = encodeTooltip(tooltip);
          if (result) {
            const attrs = { title: result.text };
            if (result.wasTruncated) {
              attrs["data-link-tooltip-truncated"] = "true";
            }
            return attrs;
          }
          return {};
        }
      }
    };
  },
  addCommands() {
    return {
      /**
       * Create or update a link
       * @category Command
       * @param {SetLinkOptions} [options] - Link configuration
       * @example
       * editor.commands.setLink({ href: 'https://example.com' })
       * editor.commands.setLink({
       *   href: 'https://example.com',
       *   text: 'Visit Example'
       * })
       * @note Automatically adds underline formatting and trims whitespace from link boundaries
       */
      setLink: ({ href, text } = {}) => ({ state, dispatch, editor }) => {
        const { selection } = state;
        const linkMarkType = editor.schema.marks.link;
        const underlineMarkType = editor.schema.marks.underline;
        const sanitizedHref = href ? sanitizeLinkHref(href, this.options.protocols) : null;
        if (href && !sanitizedHref) {
          return false;
        }
        let from3 = selection.from;
        let to = selection.to;
        if (selection.empty) {
          const range = getMarkRange(selection.$from, linkMarkType);
          if (range) {
            from3 = range.from;
            to = range.to;
          }
        } else {
          const fromLinkRange = getMarkRange(selection.$from, linkMarkType);
          const toLinkRange = getMarkRange(selection.$to, linkMarkType);
          if (fromLinkRange || toLinkRange) {
            const linkRange = fromLinkRange || toLinkRange;
            from3 = linkRange.from;
            to = linkRange.to;
          }
        }
        ({ from: from3, to } = trimRange(state.doc, from3, to));
        const currentText = state.doc.textBetween(from3, to);
        const computedText = text ?? currentText;
        const fallbackHref = sanitizedHref?.href ?? "";
        const finalText = computedText && computedText.length > 0 ? computedText : fallbackHref;
        let tr = state.tr;
        if (finalText && currentText !== finalText) {
          tr = tr.insertText(finalText, from3, to);
          to = from3 + finalText.length;
        }
        if (linkMarkType) tr = tr.removeMark(from3, to, linkMarkType);
        if (underlineMarkType) tr = tr.removeMark(from3, to, underlineMarkType);
        if (underlineMarkType) tr = tr.addMark(from3, to, underlineMarkType.create());
        let rId = null;
        if (editor.options.mode === "docx") {
          const id = addLinkRelationship({ editor, href });
          if (id) rId = id;
        }
        const linkAttrs = { text: finalText, rId };
        if (sanitizedHref?.href) {
          linkAttrs.href = sanitizedHref.href;
        }
        const newLinkMarkType = linkMarkType.create(linkAttrs);
        tr = tr.addMark(from3, to, newLinkMarkType);
        dispatch(tr.scrollIntoView());
        return true;
      },
      /**
       * Remove link and associated formatting
       * @category Command
       * @example
       * editor.commands.unsetLink()
       * @note Also removes underline and text color
       */
      unsetLink: () => ({ chain }) => {
        return chain().unsetMark("underline", { extendEmptyMarkRange: true }).unsetColor().unsetMark("link", { extendEmptyMarkRange: true }).run();
      },
      /**
       * Toggle link on selection
       * @category Command
       * @param {SetLinkOptions} [options] - Link configuration
       * @example
       * editor.commands.toggleLink({ href: 'https://example.com' })
       * editor.commands.toggleLink()
       */
      toggleLink: ({ href, text } = {}) => ({ commands: commands2 }) => {
        if (!href) return commands2.unsetLink();
        return commands2.setLink({ href, text });
      }
    };
  }
});
function normalizeProtocols(protocols = []) {
  const result = [];
  protocols.forEach((protocol) => {
    if (!protocol) return;
    if (typeof protocol === "string" && protocol.trim()) {
      result.push(protocol.trim().toLowerCase());
    } else if (typeof protocol === "object" && typeof protocol.scheme === "string" && protocol.scheme.trim()) {
      result.push(protocol.scheme.trim().toLowerCase());
    }
  });
  return result;
}
function sanitizeLinkHref(href, protocols) {
  if (!href) return null;
  const normalizedProtocols = Array.isArray(protocols) ? normalizeProtocols(protocols) : [];
  const allowedProtocols = Array.from(
    /* @__PURE__ */ new Set([...UrlValidationConstants.DEFAULT_ALLOWED_PROTOCOLS, ...normalizedProtocols])
  );
  return sanitizeHref(href, { allowedProtocols });
}
const trimRange = (doc2, from3, to) => {
  while (from3 < to && doc2.textBetween(from3, from3 + 1, "") === "") {
    from3 += 1;
  }
  while (to > from3 && doc2.textBetween(to - 1, to, "") === "") {
    to -= 1;
  }
  return { from: from3, to };
};
function addLinkRelationship({ editor, href }) {
  const target = href;
  const type = "hyperlink";
  try {
    const id = superEditor_converter.insertNewRelationship(target, type, editor);
    return id;
  } catch {
    return null;
  }
}
const trackInsertClass = "track-insert";
const TrackInsert = Mark.create({
  name: superEditor_converter.TrackInsertMarkName,
  group: "track",
  inclusive: false,
  addOptions() {
    return {
      htmlAttributes: {
        class: trackInsertClass
      }
    };
  },
  addAttributes() {
    return {
      id: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-id"),
        renderDOM: (attrs) => {
          if (!attrs.id) return {};
          return {
            "data-id": attrs.id
          };
        }
      },
      author: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-author"),
        renderDOM: (attrs) => {
          if (!attrs.author) return {};
          return {
            "data-author": attrs.author
          };
        }
      },
      authorEmail: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-authoremail"),
        renderDOM: (attrs) => {
          if (!attrs.authorEmail) return {};
          return {
            "data-authoremail": attrs.authorEmail
          };
        }
      },
      authorImage: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-authorimage"),
        renderDOM: (attrs) => {
          if (!attrs.authorImage) return {};
          return {
            "data-authorimage": attrs.authorImage
          };
        }
      },
      date: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-date"),
        renderDOM: (attrs) => {
          if (!attrs.date) return {};
          return {
            "data-date": attrs.date
          };
        }
      },
      importedAuthor: {
        default: "",
        rendered: false
      }
    };
  },
  parseDOM() {
    return false;
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  }
});
const trackDeleteClass = "track-delete";
const TrackDelete = Mark.create({
  name: superEditor_converter.TrackDeleteMarkName,
  group: "track",
  inclusive: false,
  addOptions() {
    return {
      htmlAttributes: {
        class: trackDeleteClass
      }
    };
  },
  addAttributes() {
    return {
      id: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-id"),
        renderDOM: (attrs) => {
          if (!attrs.id) return {};
          return {
            "data-id": attrs.id
          };
        }
      },
      author: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-author"),
        renderDOM: (attrs) => {
          if (!attrs.author) return {};
          return {
            "data-author": attrs.author
          };
        }
      },
      authorEmail: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-authoremail"),
        renderDOM: (attrs) => {
          if (!attrs.authorEmail) return {};
          return {
            "data-authoremail": attrs.authorEmail
          };
        }
      },
      authorImage: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-authorimage"),
        renderDOM: (attrs) => {
          if (!attrs.authorImage) return {};
          return {
            "data-authorimage": attrs.authorImage
          };
        }
      },
      date: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-date"),
        renderDOM: (attrs) => {
          if (!attrs.date) return {};
          return {
            "data-date": attrs.date
          };
        }
      },
      importedAuthor: {
        default: "",
        rendered: false
      }
    };
  },
  parseDOM() {
    return false;
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  }
});
const replaceAroundStep = () => {
};
const markWrapping = () => {
};
const parseFormatList = (str) => {
  if (!str) return [];
  let formatList;
  try {
    formatList = JSON.parse(str);
  } catch {
    return [];
  }
  if (!Array.isArray(formatList)) {
    return [];
  }
  return formatList.filter((format) => Object.hasOwn(format, "type") && Object.hasOwn(format, "attrs"));
};
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addMarkStep,
  documentHelpers,
  findTrackedMarkBetween,
  getTrackChanges,
  markDeletion,
  markInsertion,
  markWrapping,
  parseFormatList,
  removeMarkStep,
  replaceAroundStep,
  replaceStep,
  trackedTransaction
}, Symbol.toStringTag, { value: "Module" }));
const trackFormatClass = "track-format";
const TrackFormat = Mark.create({
  name: superEditor_converter.TrackFormatMarkName,
  group: "track",
  inclusive: false,
  addOptions() {
    return {
      htmlAttributes: {
        class: trackFormatClass
      }
    };
  },
  addAttributes() {
    return {
      id: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-id"),
        renderDOM: (attrs) => {
          if (!attrs.id) return {};
          return {
            "data-id": attrs.id
          };
        }
      },
      author: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-author"),
        renderDOM: (attrs) => {
          if (!attrs.author) return {};
          return {
            "data-author": attrs.author
          };
        }
      },
      authorEmail: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-authoremail"),
        renderDOM: (attrs) => {
          if (!attrs.authorEmail) return {};
          return {
            "data-authoremail": attrs.authorEmail
          };
        }
      },
      authorImage: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-authorimage"),
        renderDOM: (attrs) => {
          if (!attrs.authorImage) return {};
          return {
            "data-authorimage": attrs.authorImage
          };
        }
      },
      date: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-date"),
        renderDOM: (attrs) => {
          if (!attrs.date) return {};
          return {
            "data-date": attrs.date
          };
        }
      },
      // {
      //   type: string, // the mark name
      //   attrs: object, // the mark attrs
      // }
      before: {
        default: [],
        parseDOM: (elem) => {
          return parseFormatList(elem.getAttribute("data-before"));
        },
        renderDOM: (attrs) => {
          if (!attrs.before) return {};
          return {
            "data-before": JSON.stringify(attrs.before)
          };
        }
      },
      // {
      //   type: string, // the mark name
      //   attrs: object, // the mark attrs
      // }
      after: {
        default: [],
        parseDOM: (elem) => {
          return parseFormatList(elem.getAttribute("data-after"));
        },
        renderDOM: (attrs) => {
          if (!attrs.after) return {};
          return {
            "data-after": JSON.stringify(attrs.after)
          };
        }
      },
      importedAuthor: {
        default: "",
        rendered: false
      }
    };
  },
  parseDOM() {
    return false;
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  }
});
const PERMISSION_MAP = {
  accept: {
    own: "RESOLVE_OWN",
    other: "RESOLVE_OTHER"
  },
  reject: {
    own: "REJECT_OWN",
    other: "REJECT_OTHER"
  }
};
const buildKey = (change) => {
  const id = change.mark?.attrs?.id ?? `${change.from}-${change.to}`;
  return `${id}:${change.mark?.type?.name ?? "unknown"}`;
};
const mergeChange = (bucket, change) => {
  const key2 = buildKey(change);
  const existing = bucket.get(key2);
  if (existing) {
    existing.from = Math.min(existing.from, change.from);
    existing.to = Math.max(existing.to, change.to);
    existing.segments.push({ from: change.from, to: change.to });
  } else {
    bucket.set(key2, {
      id: change.mark?.attrs?.id ?? null,
      type: change.mark?.type?.name ?? null,
      attrs: { ...change.mark?.attrs ?? {} },
      from: change.from,
      to: change.to,
      segments: [{ from: change.from, to: change.to }]
    });
  }
};
const collectTrackedChanges = ({ state, from: from3, to }) => {
  if (!state) return [];
  const collapsed = from3 === to;
  const changes = getTrackChanges(state);
  if (!changes?.length) return [];
  const bucket = /* @__PURE__ */ new Map();
  changes.forEach((change) => {
    const overlaps = collapsed ? change.from <= from3 && change.to >= from3 : change.from < to && change.to > from3;
    if (!overlaps) return;
    mergeChange(bucket, change);
  });
  return Array.from(bucket.values());
};
const derivePermissionKey = ({ action, isOwn }) => {
  const mapping = PERMISSION_MAP[action];
  if (!mapping) return null;
  return isOwn ? mapping.own : mapping.other;
};
const normalizeEmail = (value) => {
  if (typeof value !== "string") return "";
  return value.trim().toLowerCase();
};
const resolveChanges = (editor) => {
  if (!editor) return { role: "editor", isInternal: false, currentUser: null, resolver: null };
  const role = editor.options?.role ?? "editor";
  const isInternal = Boolean(editor.options?.isInternal);
  const currentUser = editor.options?.user ?? null;
  const resolver = editor.options?.permissionResolver;
  return { role, isInternal, currentUser, resolver };
};
const isTrackedChangeActionAllowed = ({ editor, action, trackedChanges }) => {
  if (!trackedChanges?.length) return true;
  const { role, isInternal, currentUser, resolver } = resolveChanges(editor);
  if (typeof resolver !== "function") return true;
  const currentEmail = normalizeEmail(currentUser?.email);
  return trackedChanges.every((change) => {
    const authorEmail = normalizeEmail(change.attrs?.authorEmail);
    const isOwn = !currentEmail || !authorEmail || currentEmail === authorEmail;
    const permission = derivePermissionKey({ action, isOwn });
    if (!permission) return true;
    const payload = {
      permission,
      role,
      isInternal,
      trackedChange: {
        id: change.id,
        type: change.type,
        attrs: change.attrs,
        from: change.from,
        to: change.to,
        segments: change.segments,
        commentId: change.id
      },
      comment: change.comment ?? null
    };
    return resolver(payload) !== false;
  });
};
const collectTrackedChangesForContext = ({ state, pos, trackedChangeId }) => {
  if (pos == null) return [];
  const changes = collectTrackedChanges({ state, from: pos, to: pos });
  if (!trackedChangeId) return changes;
  return changes.filter((change) => change.id === trackedChangeId);
};
const TrackChanges = Extension.create({
  name: "trackChanges",
  addCommands() {
    return {
      acceptTrackedChangesBetween: (from3, to) => ({ state, dispatch, editor }) => {
        const trackedChanges = collectTrackedChanges({ state, from: from3, to });
        if (!isTrackedChangeActionAllowed({ editor, action: "accept", trackedChanges })) return false;
        let { tr, doc: doc2 } = state;
        tr.setMeta("inputType", "acceptReject");
        const map3 = new superEditor_converter.Mapping();
        doc2.nodesBetween(from3, to, (node, pos) => {
          if (node.marks && node.marks.find((mark) => mark.type.name === superEditor_converter.TrackDeleteMarkName)) {
            const deletionStep = new superEditor_converter.ReplaceStep(
              map3.map(Math.max(pos, from3)),
              map3.map(Math.min(pos + node.nodeSize, to)),
              superEditor_converter.Slice.empty
            );
            tr.step(deletionStep);
            map3.appendMap(deletionStep.getMap());
          } else if (node.marks && node.marks.find((mark) => mark.type.name === superEditor_converter.TrackInsertMarkName)) {
            const insertionMark = node.marks.find((mark) => mark.type.name === superEditor_converter.TrackInsertMarkName);
            tr.step(
              new superEditor_converter.RemoveMarkStep(
                map3.map(Math.max(pos, from3)),
                map3.map(Math.min(pos + node.nodeSize, to)),
                insertionMark
              )
            );
          } else if (node.marks && node.marks.find((mark) => mark.type.name === superEditor_converter.TrackFormatMarkName)) {
            const formatChangeMark = node.marks.find((mark) => mark.type.name === superEditor_converter.TrackFormatMarkName);
            tr.step(
              new superEditor_converter.RemoveMarkStep(
                map3.map(Math.max(pos, from3)),
                map3.map(Math.min(pos + node.nodeSize, to)),
                formatChangeMark
              )
            );
          }
        });
        if (tr.steps.length) {
          dispatch(tr);
        }
        return true;
      },
      rejectTrackedChangesBetween: (from3, to) => ({ state, dispatch, editor }) => {
        const trackedChanges = collectTrackedChanges({ state, from: from3, to });
        if (!isTrackedChangeActionAllowed({ editor, action: "reject", trackedChanges })) return false;
        const { tr, doc: doc2 } = state;
        tr.setMeta("inputType", "acceptReject");
        const map3 = new superEditor_converter.Mapping();
        doc2.nodesBetween(from3, to, (node, pos) => {
          if (node.marks && node.marks.find((mark) => mark.type.name === superEditor_converter.TrackDeleteMarkName)) {
            const deletionMark = node.marks.find((mark) => mark.type.name === superEditor_converter.TrackDeleteMarkName);
            tr.step(
              new superEditor_converter.RemoveMarkStep(
                map3.map(Math.max(pos, from3)),
                map3.map(Math.min(pos + node.nodeSize, to)),
                deletionMark
              )
            );
          } else if (node.marks && node.marks.find((mark) => mark.type.name === superEditor_converter.TrackInsertMarkName)) {
            const deletionStep = new superEditor_converter.ReplaceStep(
              map3.map(Math.max(pos, from3)),
              map3.map(Math.min(pos + node.nodeSize, to)),
              superEditor_converter.Slice.empty
            );
            tr.step(deletionStep);
            map3.appendMap(deletionStep.getMap());
          } else if (node.marks && node.marks.find((mark) => mark.type.name === superEditor_converter.TrackFormatMarkName)) {
            const formatChangeMark = node.marks.find((mark) => mark.type.name === superEditor_converter.TrackFormatMarkName);
            formatChangeMark.attrs.before.forEach((oldMark) => {
              tr.step(
                new superEditor_converter.AddMarkStep(
                  map3.map(Math.max(pos, from3)),
                  map3.map(Math.min(pos + node.nodeSize, to)),
                  state.schema.marks[oldMark.type].create(oldMark.attrs)
                )
              );
            });
            formatChangeMark.attrs.after.forEach((newMark) => {
              tr.step(
                new superEditor_converter.RemoveMarkStep(
                  map3.map(Math.max(pos, from3)),
                  map3.map(Math.min(pos + node.nodeSize, to)),
                  node.marks.find((mark) => mark.type.name === newMark.type)
                )
              );
            });
            tr.step(
              new superEditor_converter.RemoveMarkStep(
                map3.map(Math.max(pos, from3)),
                map3.map(Math.min(pos + node.nodeSize, to)),
                formatChangeMark
              )
            );
          }
        });
        if (tr.steps.length) {
          dispatch(tr);
        }
        return true;
      },
      acceptTrackedChange: ({ trackedChange }) => ({ commands: commands2 }) => {
        const { start: from3, end: to } = trackedChange;
        return commands2.acceptTrackedChangesBetween(from3, to);
      },
      acceptTrackedChangeBySelection: () => ({ state, commands: commands2 }) => {
        const { from: from3, to } = state.selection;
        return commands2.acceptTrackedChangesBetween(from3, to);
      },
      acceptTrackedChangeFromToolbar: () => ({ state, commands: commands2 }) => {
        const commentsPluginState = CommentsPluginKey.getState(state);
        const activeThreadId = commentsPluginState?.activeThreadId;
        if (activeThreadId && commentsPluginState?.trackedChanges?.[activeThreadId]) {
          return commands2.acceptTrackedChangeById(activeThreadId);
        } else {
          return commands2.acceptTrackedChangeBySelection();
        }
      },
      acceptTrackedChangeById: (id) => ({ state, tr, commands: commands2 }) => {
        const toResolve = getChangesByIdToResolve(state, id) || [];
        return toResolve.map(({ from: from3, to }) => {
          let mappedFrom = tr.mapping.map(from3);
          let mappedTo = tr.mapping.map(to);
          return commands2.acceptTrackedChangesBetween(mappedFrom, mappedTo);
        }).every((result) => result);
      },
      acceptAllTrackedChanges: () => ({ state, commands: commands2 }) => {
        const from3 = 0, to = state.doc.content.size;
        return commands2.acceptTrackedChangesBetween(from3, to);
      },
      rejectTrackedChangeById: (id) => ({ state, tr, commands: commands2 }) => {
        const toReject = getChangesByIdToResolve(state, id) || [];
        return toReject.map(({ from: from3, to }) => {
          let mappedFrom = tr.mapping.map(from3);
          let mappedTo = tr.mapping.map(to);
          return commands2.rejectTrackedChangesBetween(mappedFrom, mappedTo);
        }).every((result) => result);
      },
      rejectTrackedChange: ({ trackedChange }) => ({ commands: commands2 }) => {
        const { start: from3, end: to } = trackedChange;
        return commands2.rejectTrackedChangesBetween(from3, to);
      },
      rejectTrackedChangeOnSelection: () => ({ state, commands: commands2 }) => {
        const { from: from3, to } = state.selection;
        return commands2.rejectTrackedChangesBetween(from3, to);
      },
      rejectTrackedChangeFromToolbar: () => ({ state, commands: commands2 }) => {
        const commentsPluginState = CommentsPluginKey.getState(state);
        const activeThreadId = commentsPluginState?.activeThreadId;
        if (activeThreadId && commentsPluginState?.trackedChanges?.[activeThreadId]) {
          return commands2.rejectTrackedChangeById(activeThreadId);
        } else {
          return commands2.rejectTrackedChangeOnSelection();
        }
      },
      rejectAllTrackedChanges: () => ({ state, commands: commands2 }) => {
        const from3 = 0, to = state.doc.content.size;
        return commands2.rejectTrackedChangesBetween(from3, to);
      },
      insertTrackedChange: (options = {}) => ({ state, dispatch, editor }) => {
        const {
          from: from3 = state.selection.from,
          to = state.selection.to,
          text = "",
          user,
          comment,
          addToHistory = true
        } = options;
        const docSize = state.doc.content.size;
        if (from3 < 0 || to > docSize || from3 > to) {
          console.warn("insertTrackedChange: invalid range", { from: from3, to, docSize });
          return false;
        }
        const originalText = state.doc.textBetween(from3, to, "", "");
        if (originalText === text) {
          return false;
        }
        if (!dispatch) {
          return true;
        }
        const resolvedUser = user ?? editor?.options?.user ?? {};
        if (!resolvedUser.name && !resolvedUser.email) {
          console.warn("insertTrackedChange: no user name/email provided, track change will have undefined author");
        }
        const date = (/* @__PURE__ */ new Date()).toISOString();
        const tr = state.tr;
        const marks = state.doc.resolve(from3).marks();
        const isReplacement = from3 !== to && text;
        const sharedId = isReplacement ? uuid.v4() : null;
        let changeId = sharedId;
        let insertPos = to;
        let deletionMark = null;
        let deletionNodes = [];
        if (from3 !== to) {
          const result = markDeletion({
            tr,
            from: from3,
            to,
            user: resolvedUser,
            date,
            id: sharedId
          });
          deletionMark = result.deletionMark;
          deletionNodes = result.nodes || [];
          if (!changeId) {
            changeId = deletionMark.attrs.id;
          }
          insertPos = result.deletionMap.map(to);
        }
        let insertedMark = null;
        let insertedNode = null;
        if (text) {
          insertedNode = state.schema.text(text, marks);
          tr.insert(insertPos, insertedNode);
          const insertedFrom = insertPos;
          const insertedTo = insertPos + insertedNode.nodeSize;
          insertedMark = markInsertion({
            tr,
            from: insertedFrom,
            to: insertedTo,
            user: resolvedUser,
            date,
            id: sharedId
          });
          if (!changeId) {
            changeId = insertedMark.attrs.id;
          }
        }
        const mockStep = insertedNode ? {
          slice: { content: { content: [insertedNode] } }
        } : null;
        tr.setMeta(TrackChangesBasePluginKey, {
          insertedMark: insertedMark || null,
          deletionMark: deletionMark || null,
          deletionNodes,
          step: mockStep
        });
        tr.setMeta(CommentsPluginKey, { type: "force" });
        tr.setMeta("skipTrackChanges", true);
        if (!addToHistory) {
          tr.setMeta("addToHistory", false);
        }
        dispatch(tr);
        if (comment?.trim() && changeId && editor.commands.addCommentReply) {
          editor.commands.addCommentReply({
            parentId: changeId,
            content: comment,
            author: resolvedUser.name,
            authorEmail: resolvedUser.email,
            authorImage: resolvedUser.image
          });
        }
        return true;
      },
      toggleTrackChanges: () => ({ state }) => {
        const trackChangeState = TrackChangesBasePluginKey.getState(state);
        if (trackChangeState === void 0) return false;
        state.tr.setMeta(TrackChangesBasePluginKey, {
          type: "TRACK_CHANGES_ENABLE",
          value: !trackChangeState.isTrackChangesActive
        });
        return true;
      },
      enableTrackChanges: () => ({ state }) => {
        state.tr.setMeta(TrackChangesBasePluginKey, {
          type: "TRACK_CHANGES_ENABLE",
          value: true
        });
        return true;
      },
      disableTrackChanges: () => ({ state }) => {
        state.tr.setMeta(TrackChangesBasePluginKey, {
          type: "TRACK_CHANGES_ENABLE",
          value: false
        });
        return true;
      },
      toggleTrackChangesShowOriginal: () => ({ state }) => {
        const trackChangeState = TrackChangesBasePluginKey.getState(state);
        if (trackChangeState === void 0) return false;
        state.tr.setMeta(TrackChangesBasePluginKey, {
          type: "SHOW_ONLY_ORIGINAL",
          value: !trackChangeState.onlyOriginalShown
        });
        return true;
      },
      enableTrackChangesShowOriginal: () => ({ state }) => {
        state.tr.setMeta(TrackChangesBasePluginKey, {
          type: "SHOW_ONLY_ORIGINAL",
          value: true
        });
        return true;
      },
      disableTrackChangesShowOriginal: () => ({ state }) => {
        state.tr.setMeta(TrackChangesBasePluginKey, {
          type: "SHOW_ONLY_ORIGINAL",
          value: false
        });
        return true;
      },
      toggleTrackChangesShowFinal: () => ({ state }) => {
        const trackChangeState = TrackChangesBasePluginKey.getState(state);
        if (trackChangeState === void 0) return false;
        state.tr.setMeta(TrackChangesBasePluginKey, {
          type: "SHOW_ONLY_MODIFIED",
          value: !trackChangeState.onlyModifiedShown
        });
        return true;
      },
      enableTrackChangesShowFinal: () => ({ state }) => {
        state.tr.setMeta(TrackChangesBasePluginKey, {
          type: "SHOW_ONLY_MODIFIED",
          value: true
        });
        return true;
      }
    };
  },
  addPmPlugins() {
    return [TrackChangesBasePlugin()];
  }
});
const getChangesByIdToResolve = (state, id) => {
  const trackedChanges = getTrackChanges(state);
  const changeIndex = trackedChanges.findIndex(({ mark }) => mark.attrs.id === id);
  if (changeIndex === -1) return;
  const matchingChange = trackedChanges[changeIndex];
  const matchingId = matchingChange.mark.attrs.id;
  const getSegmentSize = ({ from: from3, to }) => to - from3;
  const areDirectlyConnected = (left2, right2) => {
    if (!left2 || !right2) {
      return false;
    }
    if (left2.to !== right2.from) {
      return false;
    }
    const hasContentBetween = state.doc.textBetween(left2.from, right2.to, "\n").length > getSegmentSize(left2) + getSegmentSize(right2);
    return !hasContentBetween;
  };
  const isComplementaryPair = (firstType, secondType) => firstType === superEditor_converter.TrackDeleteMarkName && secondType === superEditor_converter.TrackInsertMarkName || firstType === superEditor_converter.TrackInsertMarkName && secondType === superEditor_converter.TrackDeleteMarkName;
  const linkedBefore = [];
  const linkedAfter = [];
  const collectDirection = (direction, collection) => {
    let currentIndex = changeIndex;
    let currentChange = matchingChange;
    while (true) {
      const neighborIndex = currentIndex + direction;
      const neighbor = trackedChanges[neighborIndex];
      if (!neighbor) {
        break;
      }
      const [left2, right2] = direction < 0 ? [neighbor, currentChange] : [currentChange, neighbor];
      const sharesId = neighbor.mark.attrs.id === matchingId;
      const complementary = isComplementaryPair(currentChange.mark.type.name, neighbor.mark.type.name);
      if (!sharesId && !areDirectlyConnected(left2, right2)) {
        break;
      }
      if (!sharesId && !complementary) {
        break;
      }
      collection.push(neighbor);
      currentIndex = neighborIndex;
      currentChange = neighbor;
      if (!sharesId) {
        break;
      }
    }
  };
  collectDirection(-1, linkedBefore);
  collectDirection(1, linkedAfter);
  return [matchingChange, ...linkedAfter, ...linkedBefore];
};
const TextTransform = Extension.create({
  name: "textTransform",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          /**
           * @category Attribute
           * @param {string} [textTransform] - Text transform value (uppercase, lowercase, capitalize, none)
           */
          textTransform: {
            default: null,
            renderDOM: (attrs) => {
              if (!attrs.textTransform) return {};
              return {
                style: `text-transform: ${attrs.textTransform}`
              };
            }
          }
        }
      }
    ];
  }
});
const Placeholder = Extension.create({
  name: "placeholder",
  addOptions() {
    return {
      placeholder: "Type something..."
    };
  },
  addPmPlugins() {
    const applyDecoration = (state) => {
      const plainText = state.doc.textBetween(0, state.doc.content.size, " ", " ");
      if (plainText !== "") return DecorationSet.empty;
      const { $from } = state.selection;
      const decoration = Decoration.node($from.before(), $from.after(), {
        "data-placeholder": this.options.placeholder,
        class: "sd-editor-placeholder"
      });
      return DecorationSet.create(state.doc, [decoration]);
    };
    const placeholderPlugin = new superEditor_converter.Plugin({
      key: new superEditor_converter.PluginKey("placeholder"),
      state: {
        init: (_2, state) => {
          return applyDecoration(state);
        },
        apply: (tr, oldValue, oldState, newState) => {
          return applyDecoration(newState);
        }
      },
      props: {
        decorations(state) {
          return this.getState(state);
        }
      }
    });
    return [placeholderPlugin];
  }
});
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement$2(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement$1(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles$1(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style2 = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement$1(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style2);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style2 = styleProperties.reduce(function(style3, property2) {
        style3[property2] = "";
        return style3;
      }, {});
      if (!isHTMLElement$1(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles$1,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement$1(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect2 = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement$1(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect2.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect2.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement$2(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect2.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y2 = (clientRect2.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect2.width / scaleX;
  var height = clientRect2.height / scaleY;
  return {
    width,
    height,
    top: y2,
    right: x + width,
    bottom: y2 + height,
    left: x,
    x,
    y: y2
  };
}
function getLayoutRect(element) {
  var clientRect2 = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect2.width - width) <= 1) {
    width = clientRect2.width;
  }
  if (Math.abs(clientRect2.height - height) <= 1) {
    height = clientRect2.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains$1(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement$2(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode$1(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement$1(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement$1(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode$1(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement$1(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle$1(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$12, value, max$12) {
  return max(min$12, min(value, max$12));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key2) {
    hashMap[key2] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow$1(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement$1(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains$1(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
const arrow = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow$1,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y2 = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y2 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y: y2
  }) : {
    x,
    y: y2
  };
  x = _ref3.x;
  y2 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y2 -= offsetY - popperRect.height;
      y2 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y: y2
  }, getWindow(popper2)) : {
    x,
    y: y2
  };
  x = _ref4.x;
  y2 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y2 + "px)" : "translate3d(" + x + "px, " + y2 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles$1(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement$1(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
const computeStyles = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles$1,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element),
    y: y2
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y2 = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y: y2
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent$1(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement$1(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent$1(getParentNode$1(node));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent$1(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode$1(target)))
  );
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement$2(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode$1(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent(element) : element;
  if (!isElement$2(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement$2(clippingParent) && contains$1(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement$1(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement$2(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key2) {
      var multiply = [right, bottom].indexOf(key2) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key2) >= 0 ? "y" : "x";
      overflowOffsets[key2] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement$1(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b2) {
    return overflows[a] - overflows[b2];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement$1(placement) === auto) {
    return [];
  }
  var oppositePlacement2 = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement2, getOppositeVariationPlacement(oppositePlacement2)];
}
function flip$1(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement$1(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement$1(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement$1(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
const flip = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip$1,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide$1(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
const hide = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide$1
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement$1(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset$1(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y2 = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y2;
  }
  state.modifiersData[name] = data;
}
const offset = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset$1
};
function popperOffsets$1(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    placement: state.placement
  });
}
const popperOffsets = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets$1,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow$1(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement$1(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$12 = offset2 + overflow[mainSide];
    var max$12 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$12, tetherMin) : min$12, offset2, tether ? max(max$12, tetherMax) : max$12);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
const preventOverflow = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow$1,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement$1(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  var offsetParentIsScaled = isHTMLElement$1(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers2) {
  var map3 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers2.forEach(function(modifier) {
    map3.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map3.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers2.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers2) {
  var orderedModifiers = order(modifiers2);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce$1(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers2) {
  var merged = modifiers2.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key2) {
    return merged[key2];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement$2(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce$1(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect3 = _ref.effect;
        if (typeof effect3 === "function") {
          var cleanupFn = effect3({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets, computeStyles, applyStyles, offset, flip, preventOverflow, arrow, hide];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};
var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
  return document.body;
};
function hasOwnProperty$c(obj, key2) {
  return {}.hasOwnProperty.call(obj, key2);
}
function getValueAtIndexOrReturn(value, index2, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index2];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index2] : defaultValue : v;
  }
  return value;
}
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === "function" ? value.apply(void 0, args) : value;
}
function debounce(fn2, ms) {
  if (ms === 0) {
    return fn2;
  }
  var timeout2;
  return function(arg) {
    clearTimeout(timeout2);
    timeout2 = setTimeout(function() {
      fn2(arg);
    }, ms);
  };
}
function removeProperties(obj, keys2) {
  var clone = Object.assign({}, obj);
  keys2.forEach(function(key2) {
    delete clone[key2];
  });
  return clone;
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function(item, index2) {
    return arr.indexOf(item) === index2;
  });
}
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}
function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function(acc, key2) {
    if (obj[key2] !== void 0) {
      acc[key2] = obj[key2];
    }
    return acc;
  }, {});
}
function div() {
  return document.createElement("div");
}
function isElement$1(value) {
  return ["Element", "Fragment"].some(function(type) {
    return isType(value, type);
  });
}
function isNodeList(value) {
  return isType(value, "NodeList");
}
function isMouseEvent(value) {
  return isType(value, "MouseEvent");
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement$1(value)) {
    return [value];
  }
  if (isNodeList(value)) {
    return arrayFrom(value);
  }
  if (Array.isArray(value)) {
    return value;
  }
  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function(el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function(el) {
    if (el) {
      el.setAttribute("data-state", state);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _element$ownerDocumen;
  var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
  return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX, clientY = event.clientY;
  return popperTreeData.every(function(_ref) {
    var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement(popperState.placement);
    var offsetData = popperState.modifiersData.offset;
    if (!offsetData) {
      return true;
    }
    var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
    var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
    box[method](event, listener);
  });
}
function actualContains(parent, child) {
  var target = child;
  while (target) {
    var _target$getRootNode;
    if (parent.contains(target)) {
      return true;
    }
    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
  }
  return false;
}
var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }
  currentInput.isTouch = true;
  if (window.performance) {
    document.addEventListener("mousemove", onDocumentMouseMove);
  }
}
function onDocumentMouseMove() {
  var now = performance.now();
  if (now - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener("mousemove", onDocumentMouseMove);
  }
  lastMouseMoveTime = now;
}
function onWindowBlur() {
  var activeElement = document.activeElement;
  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;
    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener("blur", onWindowBlur);
}
var isBrowser$3 = typeof window !== "undefined" && typeof document !== "undefined";
var isIE11 = isBrowser$3 ? (
  // @ts-ignore
  !!window.msCrypto
) : false;
function createMemoryLeakWarning(method) {
  var txt = method === "destroy" ? "n already-" : " ";
  return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function clean(value) {
  var spacesAndTabs = /[ \t]{2,}/g;
  var lineStartWithSpaces = /^[ \t]*/gm;
  return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
}
function getDevMessage(message) {
  return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c This is a development-only message. It will be removed in production.\n  ");
}
function getFormattedMessage(message) {
  return [
    getDevMessage(message),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var visitedMessages;
if (vue.process$1.env.NODE_ENV !== "production") {
  resetVisitedMessages();
}
function resetVisitedMessages() {
  visitedMessages = /* @__PURE__ */ new Set();
}
function warnWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console;
    visitedMessages.add(message);
    (_console = console).warn.apply(_console, getFormattedMessage(message));
  }
}
function errorWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console2;
    visitedMessages.add(message);
    (_console2 = console).error.apply(_console2, getFormattedMessage(message));
  }
}
function validateTargets(targets) {
  var didPassFalsyValue = !targets;
  var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
  errorWhen(didPassFalsyValue, ["tippy() was passed", "`" + String(targets) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" "));
  errorWhen(didPassPlainObject, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: "fade",
  arrow: true,
  content: "",
  inertia: false,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: TIPPY_DEFAULT_APPEND_TO,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {
  },
  onBeforeUpdate: function onBeforeUpdate() {
  },
  onCreate: function onCreate() {
  },
  onDestroy: function onDestroy() {
  },
  onHidden: function onHidden() {
  },
  onHide: function onHide() {
  },
  onMount: function onMount() {
  },
  onShow: function onShow() {
  },
  onShown: function onShown() {
  },
  onTrigger: function onTrigger() {
  },
  onUntrigger: function onUntrigger() {
  },
  onClickOutside: function onClickOutside() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: "mouseenter focus",
  triggerTarget: null
}, pluginProps, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps2(partialProps) {
  if (vue.process$1.env.NODE_ENV !== "production") {
    validateProps(partialProps, []);
  }
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(key2) {
    defaultProps[key2] = partialProps[key2];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps2 = plugins.reduce(function(acc, plugin2) {
    var name = plugin2.name, defaultValue = plugin2.defaultValue;
    if (name) {
      var _name;
      acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
    }
    return acc;
  }, {});
  return Object.assign({}, passedProps, pluginProps2);
}
function getDataAttributeProps(reference2, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function(acc, key2) {
    var valueAsString = (reference2.getAttribute("data-tippy-" + key2) || "").trim();
    if (!valueAsString) {
      return acc;
    }
    if (key2 === "content") {
      acc[key2] = valueAsString;
    } else {
      try {
        acc[key2] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key2] = valueAsString;
      }
    }
    return acc;
  }, {});
  return props;
}
function evaluateProps(reference2, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference2])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, out.aria);
  out.aria = {
    expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
    content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
  };
  return out;
}
function validateProps(partialProps, plugins) {
  if (partialProps === void 0) {
    partialProps = {};
  }
  if (plugins === void 0) {
    plugins = [];
  }
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(prop) {
    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
    var didPassUnknownProp = !hasOwnProperty$c(nonPluginProps, prop);
    if (didPassUnknownProp) {
      didPassUnknownProp = plugins.filter(function(plugin2) {
        return plugin2.name === prop;
      }).length === 0;
    }
    warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var innerHTML = function innerHTML2() {
  return "innerHTML";
};
function dangerouslySetInnerHTML(element, html) {
  element[innerHTML()] = html;
}
function createArrowElement(value) {
  var arrow2 = div();
  if (value === true) {
    arrow2.className = ARROW_CLASS;
  } else {
    arrow2.className = SVG_ARROW_CLASS;
    if (isElement$1(value)) {
      arrow2.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow2, value);
    }
  }
  return arrow2;
}
function setContent(content, props) {
  if (isElement$1(props.content)) {
    dangerouslySetInnerHTML(content, "");
    content.appendChild(props.content);
  } else if (typeof props.content !== "function") {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content, props.content);
    } else {
      content.textContent = props.content;
    }
  }
}
function getChildren(popper2) {
  var box = popper2.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box,
    content: boxChildren.find(function(node) {
      return node.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function(node) {
      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function(node) {
      return node.classList.contains(BACKDROP_CLASS);
    })
  };
}
function render$2(instance) {
  var popper2 = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute("data-state", "hidden");
  box.setAttribute("tabindex", "-1");
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute("data-state", "hidden");
  setContent(content, instance.props);
  popper2.appendChild(box);
  box.appendChild(content);
  onUpdate(instance.props, instance.props);
  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper2), box2 = _getChildren.box, content2 = _getChildren.content, arrow2 = _getChildren.arrow;
    if (nextProps.theme) {
      box2.setAttribute("data-theme", nextProps.theme);
    } else {
      box2.removeAttribute("data-theme");
    }
    if (typeof nextProps.animation === "string") {
      box2.setAttribute("data-animation", nextProps.animation);
    } else {
      box2.removeAttribute("data-animation");
    }
    if (nextProps.inertia) {
      box2.setAttribute("data-inertia", "");
    } else {
      box2.removeAttribute("data-inertia");
    }
    box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
    if (nextProps.role) {
      box2.setAttribute("role", nextProps.role);
    } else {
      box2.removeAttribute("role");
    }
    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent(content2, instance.props);
    }
    if (nextProps.arrow) {
      if (!arrow2) {
        box2.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box2.removeChild(arrow2);
        box2.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow2) {
      box2.removeChild(arrow2);
    }
  }
  return {
    popper: popper2,
    onUpdate
  };
}
render$2.$$tippy = true;
var idCounter = 1;
var mouseMoveListeners = [];
var mountedInstances = [];
function createTippy(reference2, passedProps) {
  var props = evaluateProps(reference2, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
  var currentTarget;
  var id = idCounter++;
  var popperInstance = null;
  var plugins = unique(props.plugins);
  var state = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance = {
    // properties
    id,
    reference: reference2,
    popper: div(),
    popperInstance,
    props,
    state,
    plugins,
    // methods
    clearDelayTimeouts,
    setProps,
    setContent: setContent2,
    show,
    hide: hide2,
    hideWithInteractivity,
    enable,
    disable,
    unmount: unmount2,
    destroy
  };
  if (!props.render) {
    if (vue.process$1.env.NODE_ENV !== "production") {
      errorWhen(true, "render() function has not been supplied.");
    }
    return instance;
  }
  var _props$render = props.render(instance), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
  popper2.setAttribute("data-tippy-root", "");
  popper2.id = "tippy-" + instance.id;
  instance.popper = popper2;
  reference2._tippy = instance;
  popper2._tippy = instance;
  var pluginsHooks = plugins.map(function(plugin2) {
    return plugin2.fn(instance);
  });
  var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook("onCreate", [instance]);
  if (props.showOnCreate) {
    scheduleShow();
  }
  popper2.addEventListener("mouseenter", function() {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper2.addEventListener("mouseleave", function() {
    if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) {
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    }
  });
  return instance;
  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }
  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === "hold";
  }
  function getIsDefaultRenderFn() {
    var _instance$props$rende;
    return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
  }
  function getCurrentTarget() {
    return currentTarget || reference2;
  }
  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }
  function getDefaultTemplateChildren() {
    return getChildren(popper2);
  }
  function getDelay(isShow) {
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
      return 0;
    }
    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }
  function handleStyles(fromHide) {
    if (fromHide === void 0) {
      fromHide = false;
    }
    popper2.style.pointerEvents = instance.props.interactive && !fromHide ? "" : "none";
    popper2.style.zIndex = "" + instance.props.zIndex;
  }
  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }
    pluginsHooks.forEach(function(pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(pluginHooks, args);
      }
    });
    if (shouldInvokePropsHook) {
      var _instance$props;
      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }
  function handleAriaContentAttribute() {
    var aria = instance.props.aria;
    if (!aria.content) {
      return;
    }
    var attr = "aria-" + aria.content;
    var id2 = popper2.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      var currentValue = node.getAttribute(attr);
      if (instance.state.isVisible) {
        node.setAttribute(attr, currentValue ? currentValue + " " + id2 : id2);
      } else {
        var nextValue = currentValue && currentValue.replace(id2, "").trim();
        if (nextValue) {
          node.setAttribute(attr, nextValue);
        } else {
          node.removeAttribute(attr);
        }
      }
    });
  }
  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance.props.aria.expanded) {
      return;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      if (instance.props.interactive) {
        node.setAttribute("aria-expanded", instance.state.isVisible && node === getCurrentTarget() ? "true" : "false");
      } else {
        node.removeAttribute("aria-expanded");
      }
    });
  }
  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
      return listener !== debouncedOnMouseMove;
    });
  }
  function onDocumentPress(event) {
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === "mousedown") {
        return;
      }
    }
    var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
    if (instance.props.interactive && actualContains(popper2, actualTarget)) {
      return;
    }
    if (normalizeToArray(instance.props.triggerTarget || reference2).some(function(el) {
      return actualContains(el, actualTarget);
    })) {
      if (currentInput.isTouch) {
        return;
      }
      if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) {
        return;
      }
    } else {
      invokeHook("onClickOutside", [instance, event]);
    }
    if (instance.props.hideOnClick === true) {
      instance.clearDelayTimeouts();
      instance.hide();
      didHideDueToDocumentMouseDown = true;
      setTimeout(function() {
        didHideDueToDocumentMouseDown = false;
      });
      if (!instance.state.isMounted) {
        removeDocumentPress();
      }
    }
  }
  function onTouchMove() {
    didTouchMove = true;
  }
  function onTouchStart() {
    didTouchMove = false;
  }
  function addDocumentPress() {
    var doc2 = getDocument();
    doc2.addEventListener("mousedown", onDocumentPress, true);
    doc2.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc2.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc2.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function removeDocumentPress() {
    var doc2 = getDocument();
    doc2.removeEventListener("mousedown", onDocumentPress, true);
    doc2.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc2.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc2.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function() {
      if (!instance.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
        callback();
      }
    });
  }
  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }
  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;
    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, "remove", listener);
        callback();
      }
    }
    if (duration === 0) {
      return callback();
    }
    updateTransitionEndListener(box, "remove", currentTransitionEndListener);
    updateTransitionEndListener(box, "add", listener);
    currentTransitionEndListener = listener;
  }
  function on2(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      node.addEventListener(eventType, handler, options);
      listeners.push({
        node,
        eventType,
        handler,
        options
      });
    });
  }
  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on2("touchstart", onTrigger2, {
        passive: true
      });
      on2("touchend", onMouseLeave, {
        passive: true
      });
    }
    splitBySpaces(instance.props.trigger).forEach(function(eventType) {
      if (eventType === "manual") {
        return;
      }
      on2(eventType, onTrigger2);
      switch (eventType) {
        case "mouseenter":
          on2("mouseleave", onMouseLeave);
          break;
        case "focus":
          on2(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
          break;
        case "focusin":
          on2("focusout", onBlurOrFocusOut);
          break;
      }
    });
  }
  function removeListeners() {
    listeners.forEach(function(_ref) {
      var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }
  function onTrigger2(event) {
    var _lastTriggerEvent;
    var shouldScheduleClickHide = false;
    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }
    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();
    if (!instance.state.isVisible && isMouseEvent(event)) {
      mouseMoveListeners.forEach(function(listener) {
        return listener(event);
      });
    }
    if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }
    if (event.type === "click") {
      isVisibleFromClick = !shouldScheduleClickHide;
    }
    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }
  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
    if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
      return;
    }
    var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
      var _instance$popperInsta;
      var instance2 = popper3._tippy;
      var state2 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;
      if (state2) {
        return {
          popperRect: popper3.getBoundingClientRect(),
          popperState: state2,
          props
        };
      }
      return null;
    }).filter(Boolean);
    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }
  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
    if (shouldBail) {
      return;
    }
    if (instance.props.interactive) {
      instance.hideWithInteractivity(event);
      return;
    }
    scheduleHide(event);
  }
  function onBlurOrFocusOut(event) {
    if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
      return;
    }
    if (instance.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {
      return;
    }
    scheduleHide(event);
  }
  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
  }
  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset2 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
    var arrow2 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference2;
    var tippyModifier = {
      name: "$$tippy",
      enabled: true,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function fn2(_ref2) {
        var state2 = _ref2.state;
        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
            if (attr === "placement") {
              box.setAttribute("data-placement", state2.placement);
            } else {
              if (state2.attributes.popper["data-popper-" + attr]) {
                box.setAttribute("data-" + attr, "");
              } else {
                box.removeAttribute("data-" + attr);
              }
            }
          });
          state2.attributes.popper = {};
        }
      }
    };
    var modifiers2 = [{
      name: "offset",
      options: {
        offset: offset2
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];
    if (getIsDefaultRenderFn() && arrow2) {
      modifiers2.push({
        name: "arrow",
        options: {
          element: arrow2,
          padding: 3
        }
      });
    }
    modifiers2.push.apply(modifiers2, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, {
      placement,
      onFirstUpdate,
      modifiers: modifiers2
    }));
  }
  function destroyPopperInstance() {
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
      instance.popperInstance = null;
    }
  }
  function mount2() {
    var appendTo = instance.props.appendTo;
    var parentNode2;
    var node = getCurrentTarget();
    if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
      parentNode2 = node.parentNode;
    } else {
      parentNode2 = invokeWithArgsOrReturn(appendTo, [node]);
    }
    if (!parentNode2.contains(popper2)) {
      parentNode2.appendChild(popper2);
    }
    instance.state.isMounted = true;
    createPopperInstance();
    if (vue.process$1.env.NODE_ENV !== "production") {
      warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper2, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
    }
  }
  function getNestedPopperTree() {
    return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
  }
  function scheduleShow(event) {
    instance.clearDelayTimeouts();
    if (event) {
      invokeHook("onTrigger", [instance, event]);
    }
    addDocumentPress();
    var delay = getDelay(true);
    var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
    if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
      delay = touchDelay;
    }
    if (delay) {
      showTimeout = setTimeout(function() {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }
  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook("onUntrigger", [instance, event]);
    if (!instance.state.isVisible) {
      removeDocumentPress();
      return;
    }
    if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }
    var delay = getDelay(false);
    if (delay) {
      hideTimeout = setTimeout(function() {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      scheduleHideAnimationFrame = requestAnimationFrame(function() {
        instance.hide();
      });
    }
  }
  function enable() {
    instance.state.isEnabled = true;
  }
  function disable() {
    instance.hide();
    instance.state.isEnabled = false;
  }
  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }
  function setProps(partialProps) {
    if (vue.process$1.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("setProps"));
    }
    if (instance.state.isDestroyed) {
      return;
    }
    invokeHook("onBeforeUpdate", [instance, partialProps]);
    removeListeners();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference2, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
      ignoreAttributes: true
    }));
    instance.props = nextProps;
    addListeners();
    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
    }
    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
        node.removeAttribute("aria-expanded");
      });
    } else if (nextProps.triggerTarget) {
      reference2.removeAttribute("aria-expanded");
    }
    handleAriaExpandedAttribute();
    handleStyles();
    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }
    if (instance.popperInstance) {
      createPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }
    invokeHook("onAfterUpdate", [instance, partialProps]);
  }
  function setContent2(content) {
    instance.setProps({
      content
    });
  }
  function show() {
    if (vue.process$1.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("show"));
    }
    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled2 = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
    if (isAlreadyVisible || isDestroyed || isDisabled2 || isTouchAndTouchDisabled) {
      return;
    }
    if (getCurrentTarget().hasAttribute("disabled")) {
      return;
    }
    invokeHook("onShow", [instance], false);
    if (instance.props.onShow(instance) === false) {
      return;
    }
    instance.state.isVisible = true;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "visible";
    }
    handleStyles();
    addDocumentPress();
    if (!instance.state.isMounted) {
      popper2.style.transition = "none";
    }
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
      setTransitionDuration([box, content], 0);
    }
    onFirstUpdate = function onFirstUpdate2() {
      var _instance$popperInsta2;
      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }
      ignoreOnFirstUpdate = true;
      void popper2.offsetHeight;
      popper2.style.transition = instance.props.moveTransition;
      if (getIsDefaultRenderFn() && instance.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], "visible");
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance);
      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
      invokeHook("onMount", [instance]);
      if (instance.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function() {
          instance.state.isShown = true;
          invokeHook("onShown", [instance]);
        });
      }
    };
    mount2();
  }
  function hide2() {
    if (vue.process$1.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hide"));
    }
    var isAlreadyHidden = !instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled2 = !instance.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
    if (isAlreadyHidden || isDestroyed || isDisabled2) {
      return;
    }
    invokeHook("onHide", [instance], false);
    if (instance.props.onHide(instance) === false) {
      return;
    }
    instance.state.isVisible = false;
    instance.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "hidden";
    }
    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles(true);
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
      if (instance.props.animation) {
        setTransitionDuration([box, content], duration);
        setVisibilityState([box, content], "hidden");
      }
    }
    handleAriaContentAttribute();
    handleAriaExpandedAttribute();
    if (instance.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance.unmount);
      }
    } else {
      instance.unmount();
    }
  }
  function hideWithInteractivity(event) {
    if (vue.process$1.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hideWithInteractivity"));
    }
    getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }
  function unmount2() {
    if (vue.process$1.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("unmount"));
    }
    if (instance.state.isVisible) {
      instance.hide();
    }
    if (!instance.state.isMounted) {
      return;
    }
    destroyPopperInstance();
    getNestedPopperTree().forEach(function(nestedPopper) {
      nestedPopper._tippy.unmount();
    });
    if (popper2.parentNode) {
      popper2.parentNode.removeChild(popper2);
    }
    mountedInstances = mountedInstances.filter(function(i) {
      return i !== instance;
    });
    instance.state.isMounted = false;
    invokeHook("onHidden", [instance]);
  }
  function destroy() {
    if (vue.process$1.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("destroy"));
    }
    if (instance.state.isDestroyed) {
      return;
    }
    instance.clearDelayTimeouts();
    instance.unmount();
    removeListeners();
    delete reference2._tippy;
    instance.state.isDestroyed = true;
    invokeHook("onDestroy", [instance]);
  }
}
function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }
  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
  if (vue.process$1.env.NODE_ENV !== "production") {
    validateTargets(targets);
    validateProps(optionalProps, plugins);
  }
  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins
  });
  var elements = getArrayOfElements(targets);
  if (vue.process$1.env.NODE_ENV !== "production") {
    var isSingleContentElement = isElement$1(passedProps.content);
    var isMoreThanOneReferenceElement = elements.length > 1;
    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var instances = elements.reduce(function(acc, reference2) {
    var instance = reference2 && createTippy(reference2, passedProps);
    if (instance) {
      acc.push(instance);
    }
    return acc;
  }, []);
  return isElement$1(targets) ? instances[0] : instances;
}
tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
Object.assign({}, applyStyles, {
  effect: function effect2(_ref) {
    var state = _ref.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
  }
});
tippy.setDefaultProps({
  render: render$2
});
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key2, val] of props) {
    target[key2] = val;
  }
  return target;
};
const _hoisted_1$l = ["onClick", "onMouseenter"];
const _hoisted_2$f = { key: 0 };
const _hoisted_3$b = { key: 0 };
const _hoisted_4$7 = { key: 1 };
const _hoisted_5$5 = { key: 1 };
const _sfc_main$o = {
  __name: "Mentions",
  props: {
    users: {
      type: Array,
      required: true
    },
    mention: {
      type: String,
      default: ""
    },
    inserMention: {
      type: Function,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const container = vue.ref(null);
    const activeUserIndex = vue.ref(null);
    const getFilteredUsers = vue.computed(() => {
      const mention = props.mention.slice(1)?.toLowerCase();
      const filtered = props.users.filter((user) => {
        const isViewer = user.role === "viewer";
        const userMatch = user.name?.toLowerCase().startsWith(mention);
        const emailMatch = user.email?.toLowerCase().startsWith(mention);
        return !isViewer && (userMatch || emailMatch);
      }) || [];
      return filtered;
    });
    const handleClick2 = (user) => {
      props.inserMention(user);
    };
    const handleKeydown = (event) => {
      if (event.key === "ArrowDown") {
        activeUserIndex.value += 1;
        if (activeUserIndex.value === getFilteredUsers.value.length) {
          activeUserIndex.value = 0;
        }
      } else if (event.key === "ArrowUp") {
        activeUserIndex.value -= 1;
        if (activeUserIndex.value < 0) {
          activeUserIndex.value = getFilteredUsers.value.length - 1;
        }
      } else if (event.key === "Enter") {
        const user = getFilteredUsers.value[activeUserIndex.value];
        if (user) {
          props.inserMention(user);
        }
      }
    };
    const handleFocus = () => {
      activeUserIndex.value = 0;
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: "mentions-container",
        ref_key: "container",
        ref: container,
        onKeydown: vue.withModifiers(handleKeydown, ["prevent"]),
        onFocus: vue.withModifiers(handleFocus, ["stop", "prevent"]),
        tabindex: "0"
      }, [
        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(getFilteredUsers.value, (user, index2) => {
          return vue.openBlock(), vue.createElementBlock("div", {
            onClick: vue.withModifiers(($event) => handleClick2(user), ["stop", "prevent"]),
            onMouseenter: ($event) => activeUserIndex.value = index2,
            onMouseleave: _cache[0] || (_cache[0] = ($event) => activeUserIndex.value = null),
            key: user.email,
            class: vue.normalizeClass(["user-row", { selected: activeUserIndex.value === index2 }])
          }, [
            user.name ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$f, [
              user.name ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_3$b, vue.toDisplayString(user.name), 1)) : vue.createCommentVNode("", true),
              user.name && user.email ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_4$7, " (" + vue.toDisplayString(user.email) + ")", 1)) : vue.createCommentVNode("", true)
            ])) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_5$5, [
              vue.createBaseVNode("span", null, vue.toDisplayString(user.email), 1)
            ]))
          ], 42, _hoisted_1$l);
        }), 128))
      ], 544);
    };
  }
};
const Mentions = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["__scopeId", "data-v-72af6874"]]);
const popoverPluginKey = new superEditor_converter.PluginKey("popoverPlugin");
const PopoverPlugin = Extension.create({
  name: "popoverPlugin",
  addOptions() {
    return {};
  },
  addPmPlugins() {
    const popover = new superEditor_converter.Plugin({
      key: popoverPluginKey,
      state: {
        init: () => {
          return {};
        },
        apply: (tr, value) => {
          const newValue = { ...value };
          if (tr.docChanged || tr.selectionSet) {
            newValue.shouldUpdate = true;
          } else {
            newValue.shouldUpdate = false;
          }
          return newValue;
        }
      },
      view: (view) => {
        const popover2 = new Popover(view, this.editor);
        return {
          update: (view2, lastState) => {
            const pluginState = popoverPluginKey.getState(view2.state);
            if (!pluginState.shouldUpdate) return;
            popover2.update(view2, lastState);
          },
          destroy: () => {
            popover2.destroy();
          }
        };
      }
    });
    return [popover];
  }
});
class Popover {
  constructor(view, editor) {
    this.editor = editor;
    this.view = view;
    this.popover = document.createElement("div");
    this.popover.className = "sd-editor-popover";
    applyStyleIsolationClass(this.popover);
    document.body.appendChild(this.popover);
    this.tippyInstance = tippy(this.popover, {
      trigger: "manual",
      placement: "bottom-start",
      interactive: true,
      appendTo: document.body,
      arrow: false,
      onShow: (instance) => {
        instance.setProps({ getReferenceClientRect: () => this.popoverRect });
        this.bindKeyDownEvents();
      },
      onHide: () => {
        this.unbindKeyDownEvents();
      },
      theme: "sd-editor-popover"
    });
  }
  bindKeyDownEvents() {
    this.view.dom.addEventListener("keydown", this.handleKeyDown);
  }
  unbindKeyDownEvents() {
    this.view.dom.removeEventListener("keydown", this.handleKeyDown);
  }
  handleKeyDown = (event) => {
    const isArrow = event.key === "ArrowDown" || event.key === "ArrowUp";
    if (this.tippyInstance.state.isVisible && isArrow) {
      event.preventDefault();
      this.popover.firstChild.focus();
    }
  };
  mountVueComponent(component, props = {}) {
    if (this.app) this.app.unmount();
    this.app = vue.createApp(component, props);
    this.app.mount(this.popover);
    this.tippyInstance.setContent(this.popover);
  }
  update(view) {
    this.state = view.state;
    const showPopover = this.isShowMentions;
    let popoverContent = { component: null, props: null };
    if (this.isShowMentions) {
      const { from: from3 } = this.state.selection;
      const atMention = this.getMentionText(from3);
      popoverContent = {
        component: Mentions,
        props: {
          users: this.editor.users,
          mention: atMention,
          inserMention: (user) => {
            const { $from } = this.state.selection;
            const length2 = atMention.length;
            const attributes = { ...user };
            const mentionNode = this.editor.schema.nodes.mention.create(attributes);
            const tr = this.state.tr.replaceWith($from.pos - length2, $from.pos, mentionNode);
            this.editor.view.dispatch(tr);
            this.editor.view.focus();
          }
        }
      };
    }
    if (showPopover && popoverContent.component) {
      const { to } = this.state.selection;
      const { component, props } = popoverContent;
      this.mountVueComponent(component, props);
      this.showPopoverAtPosition(to);
    } else this.tippyInstance.hide();
  }
  showPopoverAtPosition(pos) {
    const end2 = this.view.coordsAtPos(pos);
    this.popoverRect = {
      width: 0,
      height: 0,
      top: end2.bottom,
      left: end2.left,
      bottom: end2.bottom,
      right: end2.left
    };
    this.tippyInstance.show();
  }
  getMentionText(from3) {
    const maxLookBehind = 20;
    const startPos = Math.max(0, from3 - maxLookBehind);
    const textBefore = this.state.doc.textBetween(startPos, from3, "\n", "\0");
    const atIndex = textBefore.lastIndexOf("@");
    if (atIndex !== -1) return textBefore.substring(atIndex);
    return "";
  }
  get isShowMentions() {
    const { from: from3 } = this.state.selection;
    if (from3 < 1) return false;
    const textBefore = this.getMentionText(from3);
    const mentionPattern = /(?:^|\s)@[\w]*$/;
    const match = textBefore.match(mentionPattern);
    return match && this.state.selection.empty;
  }
  destroy() {
    this.tippyInstance.destroy();
    this.popover.remove();
  }
}
class SearchQuery {
  /**
    Create a query object.
    */
  constructor(config) {
    this.search = config.search;
    this.caseSensitive = !!config.caseSensitive;
    this.literal = !!config.literal;
    this.regexp = !!config.regexp;
    this.replace = config.replace || "";
    this.valid = !!this.search && !(this.regexp && !validRegExp(this.search));
    this.wholeWord = !!config.wholeWord;
    this.filter = config.filter || null;
    this.impl = !this.valid ? nullQuery : this.regexp ? new RegExpQuery(this) : new StringQuery(this);
  }
  /**
    Compare this query to another query.
    */
  eq(other) {
    return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
  }
  /**
    Find the next occurrence of this query in the given range.
    */
  findNext(state, from3 = 0, to = state.doc.content.size) {
    for (; ; ) {
      if (from3 >= to) return null;
      let result = this.impl.findNext(state, from3, to);
      if (!result || this.checkResult(state, result)) return result;
      from3 = result.from + 1;
    }
  }
  /**
    Find the previous occurrence of this query in the given range.
    Note that, if `to` is given, it should be _less_ than `from`.
    */
  findPrev(state, from3 = state.doc.content.size, to = 0) {
    for (; ; ) {
      if (from3 <= to) return null;
      let result = this.impl.findPrev(state, from3, to);
      if (!result || this.checkResult(state, result)) return result;
      from3 = result.to - 1;
    }
  }
  /**
    @internal
    */
  checkResult(state, result) {
    return (!this.wholeWord || checkWordBoundary(state, result.from) && checkWordBoundary(state, result.to)) && (!this.filter || this.filter(state, result));
  }
  /**
    @internal
    */
  unquote(string) {
    return this.literal ? string : string.replace(/\\([nrt\\])/g, (_2, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
  }
  /**
    Get the ranges that should be replaced for this result. This can
    return multiple ranges when `this.replace` contains
    `$1`/`$&`-style placeholders, in which case the preserved
    content is skipped by the replacements.
    
    Ranges are sorted by position, and `from`/`to` positions all
    refer to positions in `state.doc`. When applying these, you'll
    want to either apply them from back to front, or map these
    positions through your transaction's current mapping.
    */
  getReplacements(state, result) {
    let $from = state.doc.resolve(result.from);
    let marks = $from.marksAcross(state.doc.resolve(result.to));
    let ranges = [];
    let frag = superEditor_converter.Fragment.empty, pos = result.from, { match } = result;
    let groups = match ? getGroupIndices(match) : [[0, result.to - result.from]];
    let replParts = parseReplacement(this.unquote(this.replace));
    for (let part of replParts) {
      if (typeof part == "string") {
        frag = frag.addToEnd(state.schema.text(part, marks));
      } else {
        const groupSpan = groups[part.group];
        if (!groupSpan) continue;
        let from3 = result.matchStart + groupSpan[0], to = result.matchStart + groupSpan[1];
        if (part.copy) {
          frag = frag.append(state.doc.slice(from3, to).content);
        } else {
          if (frag != superEditor_converter.Fragment.empty || from3 > pos) {
            ranges.push({ from: pos, to: from3, insert: new superEditor_converter.Slice(frag, 0, 0) });
            frag = superEditor_converter.Fragment.empty;
          }
          pos = to;
        }
      }
    }
    if (frag != superEditor_converter.Fragment.empty || pos < result.to)
      ranges.push({ from: pos, to: result.to, insert: new superEditor_converter.Slice(frag, 0, 0) });
    return ranges;
  }
}
const nullQuery = new class {
  findNext() {
    return null;
  }
  findPrev() {
    return null;
  }
}();
class StringQuery {
  constructor(query) {
    this.query = query;
    let string = query.unquote(query.search);
    if (!query.caseSensitive) string = string.toLowerCase();
    this.string = string;
  }
  findNext(state, from3, to) {
    return scanTextblocks(state.doc, from3, to, (node, start2) => {
      let off2 = Math.max(from3, start2);
      let content = textContent(node).slice(off2 - start2, Math.min(node.content.size, to - start2));
      let index2 = (this.query.caseSensitive ? content : content.toLowerCase()).indexOf(this.string);
      if (index2 < 0) return null;
      const startOffset = off2 - start2;
      const absoluteIndex = startOffset + index2;
      const fromPos = mapIndexToDocPos(node, start2, absoluteIndex);
      const toPos = mapIndexToDocPos(node, start2, absoluteIndex + this.string.length);
      return { from: fromPos, to: toPos, match: null, matchStart: start2 };
    });
  }
  findPrev(state, from3, to) {
    return scanTextblocks(state.doc, from3, to, (node, start2) => {
      let off2 = Math.max(start2, to);
      let content = textContent(node).slice(off2 - start2, Math.min(node.content.size, from3 - start2));
      if (!this.query.caseSensitive) content = content.toLowerCase();
      let index2 = content.lastIndexOf(this.string);
      if (index2 < 0) return null;
      const startOffset = off2 - start2;
      const absoluteIndex = startOffset + index2;
      const fromPos = mapIndexToDocPos(node, start2, absoluteIndex);
      const toPos = mapIndexToDocPos(node, start2, absoluteIndex + this.string.length);
      return { from: fromPos, to: toPos, match: null, matchStart: start2 };
    });
  }
}
const baseFlags = "g" + (/x/.unicode == null ? "" : "u") + (/x/.hasIndices == null ? "" : "d");
class RegExpQuery {
  constructor(query) {
    this.query = query;
    this.regexp = new RegExp(query.search, baseFlags + (query.caseSensitive ? "" : "i"));
  }
  findNext(state, from3, to) {
    return scanTextblocks(state.doc, from3, to, (node, start2) => {
      let content = textContent(node).slice(0, Math.min(node.content.size, to - start2));
      this.regexp.lastIndex = from3 - start2;
      let match = this.regexp.exec(content);
      if (!match) return null;
      const absoluteIndex = match.index;
      const fromPos = mapIndexToDocPos(node, start2, absoluteIndex);
      const toPos = mapIndexToDocPos(node, start2, absoluteIndex + match[0].length);
      return { from: fromPos, to: toPos, match, matchStart: start2 };
    });
  }
  findPrev(state, from3, to) {
    return scanTextblocks(state.doc, from3, to, (node, start2) => {
      let content = textContent(node).slice(0, Math.min(node.content.size, from3 - start2));
      let match;
      for (let off2 = 0; ; ) {
        this.regexp.lastIndex = off2;
        let next = this.regexp.exec(content);
        if (!next) break;
        match = next;
        off2 = next.index + 1;
      }
      if (!match) return null;
      const absoluteIndex = match.index;
      const fromPos = mapIndexToDocPos(node, start2, absoluteIndex);
      const toPos = mapIndexToDocPos(node, start2, absoluteIndex + match[0].length);
      return { from: fromPos, to: toPos, match, matchStart: start2 };
    });
  }
}
function getGroupIndices(match) {
  if (match.indices) return match.indices;
  let result = [[0, match[0].length]];
  for (let i = 1, pos = 0; i < match.length; i++) {
    let found = match[i] ? match[0].indexOf(match[i], pos) : -1;
    result.push(found < 0 ? void 0 : [found, pos = found + match[i].length]);
  }
  return result;
}
function parseReplacement(text) {
  let result = [], highestSeen = -1;
  function add(text2) {
    let last = result.length - 1;
    if (last > -1 && typeof result[last] == "string") result[last] += text2;
    else result.push(text2);
  }
  while (text.length) {
    let m2 = /\$([$&\d+])/.exec(text);
    if (!m2) {
      add(text);
      return result;
    }
    if (m2.index > 0) add(text.slice(0, m2.index + (m2[1] == "$" ? 1 : 0)));
    if (m2[1] != "$") {
      let n = m2[1] == "&" ? 0 : +m2[1];
      if (highestSeen >= n) {
        result.push({ group: n, copy: true });
      } else {
        highestSeen = n || 1e3;
        result.push({ group: n, copy: false });
      }
    }
    text = text.slice(m2.index + m2[0].length);
  }
  return result;
}
function validRegExp(source) {
  try {
    new RegExp(source, baseFlags);
    return true;
  } catch {
    return false;
  }
}
const TextContentCache = /* @__PURE__ */ new WeakMap();
const transparentInlineNodes = /* @__PURE__ */ new Set(["run", "bookmarkStart"]);
function textContent(node) {
  let cached = TextContentCache.get(node);
  if (cached) return cached;
  let content = "";
  for (let i = 0; i < node.childCount; i++) {
    let child = node.child(i);
    if (child.isText) content += child.text;
    else if (child.isLeaf) content += "";
    else if (child.type && transparentInlineNodes.has(child.type.name)) content += textContent(child);
    else content += " " + textContent(child) + " ";
  }
  TextContentCache.set(node, content);
  return content;
}
function mapIndexToDocPos(node, start2, index2) {
  if (index2 <= 0) return start2;
  const fullTextLength = textContent(node).length;
  if (index2 >= fullTextLength) return start2 + node.content.size;
  return mapIndexWithinNode(node, start2, index2);
}
function mapIndexWithinNode(node, start2, index2) {
  if (index2 <= 0) return start2;
  let offset2 = start2;
  for (let i = 0; i < node.childCount; i++) {
    const child = node.child(i);
    const childStart = offset2;
    if (child.isText) {
      const len = child.text.length;
      if (index2 <= len) return childStart + index2;
      index2 -= len;
      offset2 += child.nodeSize;
      continue;
    }
    if (child.isLeaf) {
      if (index2 <= 1) return childStart + Math.min(index2, 1);
      index2 -= 1;
      offset2 += child.nodeSize;
      continue;
    }
    const isTransparentInline = child.inlineContent && child.type && transparentInlineNodes.has(child.type.name);
    const innerTextLength = textContent(child).length;
    if (isTransparentInline) {
      if (index2 <= innerTextLength) return mapIndexWithinNode(child, childStart + 1, index2);
      index2 -= innerTextLength;
      offset2 += child.nodeSize;
      continue;
    }
    const contribution = innerTextLength + 2;
    const relativeIndex = index2 - 1;
    if (relativeIndex < 0) return childStart;
    if (relativeIndex <= innerTextLength) {
      return mapIndexWithinNode(child, childStart + 1, relativeIndex);
    }
    if (relativeIndex === innerTextLength + 1) return childStart + child.nodeSize;
    index2 -= contribution;
    offset2 += child.nodeSize;
  }
  return start2 + node.content.size;
}
function scanTextblocks(node, from3, to, f, nodeStart = 0) {
  const isTransparentInline = node.inlineContent && node.type && transparentInlineNodes.has(node.type.name);
  if (node.inlineContent && !isTransparentInline) {
    return f(node, nodeStart);
  } else if (!node.isLeaf) {
    if (from3 > to) {
      for (let i = node.childCount - 1, pos = nodeStart + node.content.size; i >= 0 && pos > to; i--) {
        let child = node.child(i);
        pos -= child.nodeSize;
        if (pos < from3) {
          let result = scanTextblocks(child, from3, to, f, pos + 1);
          if (result != null) return result;
        }
      }
    } else {
      for (let i = 0, pos = nodeStart; i < node.childCount && pos < to; i++) {
        let child = node.child(i), start2 = pos;
        pos += child.nodeSize;
        if (pos > from3) {
          let result = scanTextblocks(child, from3, to, f, start2 + 1);
          if (result != null) return result;
        }
      }
    }
  }
  return null;
}
function checkWordBoundary(state, pos) {
  let $pos = state.doc.resolve(pos);
  let before = $pos.nodeBefore, after = $pos.nodeAfter;
  if (!before || !after || !before.isText || !after.isText) return true;
  return !/\p{L}$/u.test(before.text) || !/^\p{L}/u.test(after.text);
}
class SearchState {
  /**
   * Create a new SearchState instance.
   *
   * @param {SearchQuery} query - The search query to execute
   * @param {{from: number, to: number}|null} range - Optional range to restrict search to, or null for entire document
   * @param {boolean} highlight - Whether to apply CSS classes for visual highlighting of matches
   * @param {DecorationSet} deco - The decoration set containing match highlights
   */
  constructor(query, range, highlight, deco) {
    this.query = query;
    this.range = range;
    this.highlight = highlight;
    this.deco = deco;
  }
}
function buildMatchDeco(state, query, range, highlight = true) {
  if (!query.valid) return DecorationSet.empty;
  let deco = [];
  let sel = state.selection;
  for (let pos = range ? range.from : 0, end2 = range ? range.to : state.doc.content.size; ; ) {
    let next = query.findNext(state, pos, end2);
    if (!next) break;
    let cls = next.from == sel.from && next.to == sel.to ? "ProseMirror-active-search-match" : "ProseMirror-search-match";
    const attrs = highlight ? { class: cls } : {};
    deco.push(Decoration.inline(next.from, next.to, attrs));
    pos = next.to;
  }
  return DecorationSet.create(state.doc, deco);
}
const searchKey = new superEditor_converter.PluginKey("search");
function search(options = {}) {
  return new superEditor_converter.Plugin({
    key: searchKey,
    state: {
      init(_config, state) {
        let query = options.initialQuery || new SearchQuery({ search: "" });
        let range = options.initialRange || null;
        const highlight = options.initialHighlight ?? true;
        return new SearchState(query, range, highlight, buildMatchDeco(state, query, range, highlight));
      },
      apply(tr, search2, _oldState, state) {
        let set = tr.getMeta(searchKey);
        if (set) {
          const highlight = typeof set.highlight === "boolean" ? set.highlight : true;
          return new SearchState(
            set.query,
            set.range,
            highlight,
            buildMatchDeco(state, set.query, set.range, highlight)
          );
        }
        if (tr.docChanged || tr.selectionSet) {
          let range = search2.range;
          if (range) {
            let from3 = tr.mapping.map(range.from, 1);
            let to = tr.mapping.map(range.to, -1);
            range = from3 < to ? { from: from3, to } : null;
          }
          const highlight = typeof search2.highlight === "boolean" ? search2.highlight : true;
          search2 = new SearchState(
            search2.query,
            range,
            highlight,
            buildMatchDeco(state, search2.query, range, highlight)
          );
        }
        return search2;
      }
    },
    props: {
      decorations: (state) => searchKey.getState(state).deco
    }
  });
}
function getMatchHighlights(state) {
  let search2 = searchKey.getState(state);
  return search2 ? search2.deco : DecorationSet.empty;
}
const BLOCK_SEPARATOR = "\n";
const ATOM_PLACEHOLDER = "";
class SearchIndex {
  /** @type {string} */
  text = "";
  /** @type {Segment[]} */
  segments = [];
  /** @type {boolean} */
  valid = false;
  /** @type {number} */
  docSize = 0;
  /**
   * Build the search index from a ProseMirror document.
   * Uses doc.textBetween for the flattened string and walks
   * the document to build the segment offset map.
   *
   * @param {import('prosemirror-model').Node} doc - The ProseMirror document
   */
  build(doc2) {
    this.text = doc2.textBetween(0, doc2.content.size, BLOCK_SEPARATOR, ATOM_PLACEHOLDER);
    this.segments = [];
    this.docSize = doc2.content.size;
    let offset2 = 0;
    this.#walkNodeContent(doc2, 0, offset2, (segment) => {
      this.segments.push(segment);
      offset2 = segment.offsetEnd;
    });
    this.valid = true;
  }
  /**
   * Walk the content of a node to build segments.
   * This method processes the children of a node, given the position
   * where the node's content starts.
   *
   * @param {import('prosemirror-model').Node} node - Current node
   * @param {number} contentStart - Document position where this node's content starts
   * @param {number} offset - Current offset in flattened string
   * @param {(segment: Segment) => void} addSegment - Callback to add a segment
   * @returns {number} The new offset after processing this node's content
   */
  #walkNodeContent(node, contentStart, offset2, addSegment) {
    let currentOffset = offset2;
    let isFirstChild = true;
    node.forEach((child, childContentOffset) => {
      const childDocPos = contentStart + childContentOffset;
      if (child.isBlock && !isFirstChild) {
        addSegment({
          offsetStart: currentOffset,
          offsetEnd: currentOffset + 1,
          docFrom: childDocPos,
          docTo: childDocPos,
          kind: "blockSep"
        });
        currentOffset += 1;
      }
      currentOffset = this.#walkNode(child, childDocPos, currentOffset, addSegment);
      isFirstChild = false;
    });
    return currentOffset;
  }
  /**
   * Recursively walk a node and its descendants to build segments.
   *
   * @param {import('prosemirror-model').Node} node - Current node
   * @param {number} docPos - Document position at start of this node
   * @param {number} offset - Current offset in flattened string
   * @param {(segment: Segment) => void} addSegment - Callback to add a segment
   * @returns {number} The new offset after processing this node
   */
  #walkNode(node, docPos, offset2, addSegment) {
    if (node.isText) {
      const text = node.text || "";
      if (text.length > 0) {
        addSegment({
          offsetStart: offset2,
          offsetEnd: offset2 + text.length,
          docFrom: docPos,
          docTo: docPos + text.length,
          kind: "text"
        });
        return offset2 + text.length;
      }
      return offset2;
    }
    if (node.isLeaf) {
      if (node.type.name === "hard_break") {
        addSegment({
          offsetStart: offset2,
          offsetEnd: offset2 + 1,
          docFrom: docPos,
          docTo: docPos + node.nodeSize,
          kind: "hardBreak"
        });
        return offset2 + 1;
      }
      addSegment({
        offsetStart: offset2,
        offsetEnd: offset2 + 1,
        docFrom: docPos,
        docTo: docPos + node.nodeSize,
        kind: "atom"
      });
      return offset2 + 1;
    }
    return this.#walkNodeContent(node, docPos + 1, offset2, addSegment);
  }
  /**
   * Mark the index as stale. It will be rebuilt on next search.
   */
  invalidate() {
    this.valid = false;
  }
  /**
   * Check if the index needs rebuilding for the given document.
   *
   * @param {import('prosemirror-model').Node} doc - The document to check against
   * @returns {boolean} True if index is stale and needs rebuilding
   */
  isStale(doc2) {
    return !this.valid || doc2.content.size !== this.docSize;
  }
  /**
   * Ensure the index is valid for the given document.
   * Rebuilds if stale.
   *
   * @param {import('prosemirror-model').Node} doc - The document
   */
  ensureValid(doc2) {
    if (this.isStale(doc2)) {
      this.build(doc2);
    }
  }
  /**
   * Convert an offset range in the flattened string to document ranges.
   * Skips separator/atom segments and returns only text ranges.
   *
   * @param {number} start - Start offset in flattened string
   * @param {number} end - End offset in flattened string
   * @returns {DocRange[]} Array of document ranges (text segments only)
   */
  offsetRangeToDocRanges(start2, end2) {
    const ranges = [];
    for (const segment of this.segments) {
      if (segment.offsetEnd <= start2) continue;
      if (segment.offsetStart >= end2) break;
      if (segment.kind !== "text") continue;
      const overlapStart = Math.max(start2, segment.offsetStart);
      const overlapEnd = Math.min(end2, segment.offsetEnd);
      if (overlapStart < overlapEnd) {
        const startInSegment = overlapStart - segment.offsetStart;
        const endInSegment = overlapEnd - segment.offsetStart;
        ranges.push({
          from: segment.docFrom + startInSegment,
          to: segment.docFrom + endInSegment
        });
      }
    }
    return ranges;
  }
  /**
   * Find the document position for a given offset in the flattened string.
   *
   * @param {number} offset - Offset in flattened string
   * @returns {number|null} Document position, or null if not found
   */
  offsetToDocPos(offset2) {
    for (const segment of this.segments) {
      if (offset2 >= segment.offsetStart && offset2 < segment.offsetEnd) {
        if (segment.kind === "text") {
          return segment.docFrom + (offset2 - segment.offsetStart);
        }
        return segment.docFrom;
      }
    }
    if (this.segments.length > 0 && offset2 === this.segments[this.segments.length - 1].offsetEnd) {
      const lastSeg = this.segments[this.segments.length - 1];
      return lastSeg.docTo;
    }
    return null;
  }
  /**
   * Escape special regex characters in a string.
   *
   * @param {string} str - String to escape
   * @returns {string} Escaped string safe for use in RegExp
   */
  static escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  /**
   * Convert a plain search string to a whitespace-flexible regex pattern.
   * This allows matching across paragraph boundaries.
   *
   * @param {string} searchString - The search string
   * @returns {string} Regex pattern string
   */
  static toFlexiblePattern(searchString) {
    const hasLeadingWhitespace = /^[\s\u00a0]+/.test(searchString);
    const hasTrailingWhitespace = /[\s\u00a0]+$/.test(searchString);
    const trimmed = searchString.replace(/^[\s\u00a0]+|[\s\u00a0]+$/g, "");
    const parts = trimmed.split(/[\s\u00a0]+/).filter((part) => part.length > 0);
    if (parts.length === 0) {
      return hasLeadingWhitespace || hasTrailingWhitespace ? "[\\s\\u00a0]+" : "";
    }
    const blockSeparatorPattern = "(?:\\n)*";
    const escapedParts = parts.map((part) => {
      const chars = Array.from(part);
      return chars.map((ch) => SearchIndex.escapeRegex(ch)).join(blockSeparatorPattern);
    });
    let pattern = escapedParts.join("[\\s\\u00a0]+");
    if (hasLeadingWhitespace) {
      pattern = "[\\s\\u00a0]+" + pattern;
    }
    if (hasTrailingWhitespace) {
      pattern = pattern + "[\\s\\u00a0]+";
    }
    return pattern;
  }
  /**
   * Search the index for matches.
   *
   * @param {string | RegExp} pattern - Search pattern (string or regex)
   * @param {Object} options - Search options
   * @param {boolean} [options.caseSensitive=false] - Case sensitive search
   * @param {number} [options.maxMatches=1000] - Maximum number of matches to return
   * @returns {Array<{start: number, end: number, text: string}>} Array of matches with offsets
   */
  search(pattern, options = {}) {
    const { caseSensitive = false, maxMatches = 1e3 } = options;
    const matches = [];
    let regex;
    if (pattern instanceof RegExp) {
      const flags = pattern.flags.includes("g") ? pattern.flags : pattern.flags + "g";
      regex = new RegExp(pattern.source, flags);
    } else if (typeof pattern === "string") {
      if (pattern.length === 0) return matches;
      const flexiblePattern = SearchIndex.toFlexiblePattern(pattern);
      if (flexiblePattern.length === 0) return matches;
      const flags = caseSensitive ? "g" : "gi";
      regex = new RegExp(flexiblePattern, flags);
    } else {
      return matches;
    }
    let match;
    while ((match = regex.exec(this.text)) !== null && matches.length < maxMatches) {
      matches.push({
        start: match.index,
        end: match.index + match[0].length,
        text: match[0]
      });
      if (match[0].length === 0) {
        regex.lastIndex++;
      }
    }
    return matches;
  }
}
const customSearchHighlightsKey = new superEditor_converter.PluginKey("customSearchHighlights");
const isRegExp = (value) => Object.prototype.toString.call(value) === "[object RegExp]";
const resolveInlineTextPosition = (doc2, position, direction) => {
  const docSize = doc2.content.size;
  if (!Number.isFinite(position) || position < 0 || position > docSize) {
    return position;
  }
  const step = direction === "forward" ? 1 : -1;
  let current = position;
  let iterations = 0;
  while (iterations < 8) {
    iterations += 1;
    const resolved = doc2.resolve(current);
    const boundaryNode = direction === "forward" ? resolved.nodeAfter : resolved.nodeBefore;
    if (!boundaryNode) break;
    if (boundaryNode.isText) break;
    if (!boundaryNode.isInline || boundaryNode.isAtom || boundaryNode.content.size === 0) break;
    const next = current + step;
    if (next < 0 || next > docSize) break;
    current = next;
    const adjacent = doc2.resolve(current);
    const checkNode = direction === "forward" ? adjacent.nodeAfter : adjacent.nodeBefore;
    if (checkNode && checkNode.isText) break;
  }
  return current;
};
const resolveSearchRange = ({ doc: doc2, from: from3, to, expectedText, highlights }) => {
  const docSize = doc2.content.size;
  let resolvedFrom = Math.max(0, Math.min(from3, docSize));
  let resolvedTo = Math.max(0, Math.min(to, docSize));
  if (highlights) {
    const windowStart = Math.max(0, resolvedFrom - 4);
    const windowEnd = Math.min(docSize, resolvedTo + 4);
    const candidates = highlights.find(windowStart, windowEnd);
    if (candidates.length > 0) {
      let chosen = candidates[0];
      if (expectedText) {
        const matching = candidates.filter(
          (decoration) => doc2.textBetween(decoration.from, decoration.to) === expectedText
        );
        if (matching.length > 0) {
          chosen = matching[0];
        }
      }
      resolvedFrom = chosen.from;
      resolvedTo = chosen.to;
    }
  }
  const normalizedFrom = resolveInlineTextPosition(doc2, resolvedFrom, "forward");
  const normalizedTo = resolveInlineTextPosition(doc2, resolvedTo, "backward");
  if (Number.isFinite(normalizedFrom) && Number.isFinite(normalizedTo) && normalizedFrom <= normalizedTo) {
    resolvedFrom = normalizedFrom;
    resolvedTo = normalizedTo;
  }
  return { from: resolvedFrom, to: resolvedTo };
};
const getPositionTracker = (editor) => {
  if (!editor) return null;
  if (editor.positionTracker) return editor.positionTracker;
  const storageTracker = editor.storage?.positionTracker?.tracker;
  if (storageTracker) {
    editor.positionTracker = storageTracker;
    return storageTracker;
  }
  const tracker = new PositionTracker(editor);
  if (editor.storage?.positionTracker) {
    editor.storage.positionTracker.tracker = tracker;
  }
  editor.positionTracker = tracker;
  return tracker;
};
const Search = Extension.create({
  // @ts-expect-error - Storage type mismatch will be fixed in TS migration
  addStorage() {
    return {
      /**
       * @private
       * @type {SearchMatch[]|null}
       */
      searchResults: [],
      /**
       * @private
       * @type {boolean}
       * Whether to apply CSS highlight classes to matches
       */
      highlightEnabled: true,
      /**
       * @private
       * @type {SearchIndex}
       * Lazily-built search index for cross-paragraph matching
       */
      searchIndex: new SearchIndex()
    };
  },
  addPmPlugins() {
    const editor = this.editor;
    const storage = this.storage;
    const searchIndexInvalidatorPlugin = new superEditor_converter.Plugin({
      key: new superEditor_converter.PluginKey("searchIndexInvalidator"),
      appendTransaction(transactions, oldState, newState) {
        const docChanged = transactions.some((tr) => tr.docChanged);
        if (docChanged && storage?.searchIndex) {
          storage.searchIndex.invalidate();
        }
        return null;
      }
    });
    const searchHighlightWithIdPlugin = new superEditor_converter.Plugin({
      key: customSearchHighlightsKey,
      props: {
        decorations(state) {
          if (!editor) return null;
          const matches = storage?.searchResults;
          if (!matches?.length) return null;
          const highlightEnabled = storage?.highlightEnabled !== false;
          const decorations = [];
          for (const match of matches) {
            const attrs = highlightEnabled ? { id: `search-match-${match.id}`, class: "ProseMirror-search-match" } : { id: `search-match-${match.id}` };
            if (match.ranges && match.ranges.length > 0) {
              for (const range of match.ranges) {
                decorations.push(Decoration.inline(range.from, range.to, attrs));
              }
            } else {
              decorations.push(Decoration.inline(match.from, match.to, attrs));
            }
          }
          return DecorationSet.create(state.doc, decorations);
        }
      }
    });
    return [search(), searchIndexInvalidatorPlugin, searchHighlightWithIdPlugin];
  },
  addCommands() {
    return {
      /**
       * Navigate to the first search match
       * @category Command
       * @example
       * editor.commands.goToFirstMatch()
       * @note Scrolls editor to the first match from previous search
       */
      goToFirstMatch: () => (
        /** @returns {boolean} */
        ({ state, editor, dispatch }) => {
          const searchResults = this.storage?.searchResults;
          if (Array.isArray(searchResults) && searchResults.length > 0) {
            const firstMatch = searchResults[0];
            const from3 = firstMatch.ranges?.[0]?.from ?? firstMatch.from;
            const to = firstMatch.ranges?.[0]?.to ?? firstMatch.to;
            if (typeof from3 !== "number" || typeof to !== "number") {
              return false;
            }
            editor.view.focus();
            const tr2 = state.tr.setSelection(superEditor_converter.TextSelection.create(state.doc, from3, to)).scrollIntoView();
            if (dispatch) dispatch(tr2);
            const presentationEditor2 = editor.presentationEditor;
            if (presentationEditor2 && typeof presentationEditor2.scrollToPosition === "function") {
              const didScroll = presentationEditor2.scrollToPosition(from3, { block: "center" });
              if (didScroll) return true;
            }
            try {
              const domPos = editor.view.domAtPos(from3);
              if (domPos?.node?.scrollIntoView) {
                domPos.node.scrollIntoView(true);
              }
            } catch {
            }
            return true;
          }
          const highlights = getMatchHighlights(state);
          if (!highlights) return false;
          const decorations = highlights.find();
          if (!decorations?.length) return false;
          const firstDeco = decorations[0];
          editor.view.focus();
          const tr = state.tr.setSelection(superEditor_converter.TextSelection.create(state.doc, firstDeco.from, firstDeco.to)).scrollIntoView();
          if (dispatch) dispatch(tr);
          const presentationEditor = editor.presentationEditor;
          if (presentationEditor && typeof presentationEditor.scrollToPosition === "function") {
            const didScroll = presentationEditor.scrollToPosition(firstDeco.from, { block: "center" });
            if (didScroll) return true;
          }
          try {
            const domPos = editor.view.domAtPos(firstDeco.from);
            if (domPos?.node?.scrollIntoView) {
              domPos.node.scrollIntoView(true);
            }
          } catch {
          }
          return true;
        }
      ),
      /**
       * Search for string matches in editor content
       * @category Command
       * @param {String|RegExp} patternInput - Search string or pattern
       * @param {SearchCommandOptions} [options={}] - Options to control search behavior
       * @example
       * // Basic search with highlighting (default)
       * const matches = editor.commands.search('test string')
       *
       * // Regex search
       * const regexMatches = editor.commands.search(/test/i)
       *
       * // Search without visual highlighting
       * const silentMatches = editor.commands.search('test', { highlight: false })
       *
       * // Cross-paragraph search (works by default for plain strings)
       * const crossParagraphMatches = editor.commands.search('end of paragraph start of next')
       * @note Returns array of SearchMatch objects with positions and IDs.
       *       Plain string searches are whitespace-flexible and match across paragraphs.
       *       Regex searches match exactly as specified.
       */
      search: (patternInput, options = {}) => (
        /** @returns {SearchMatch[]} */
        ({ state, dispatch, editor }) => {
          if (options != null && (typeof options !== "object" || Array.isArray(options))) {
            throw new TypeError("Search options must be an object");
          }
          const highlight = typeof options?.highlight === "boolean" ? options.highlight : true;
          const maxMatches = typeof options?.maxMatches === "number" ? options.maxMatches : 1e3;
          let caseSensitive = false;
          let searchPattern = patternInput;
          if (isRegExp(patternInput)) {
            caseSensitive = !patternInput.flags.includes("i");
            searchPattern = patternInput;
          } else if (typeof patternInput === "string" && /^\/(.+)\/([gimsuy]*)$/.test(patternInput)) {
            const [, body, flags] = patternInput.match(/^\/(.+)\/([gimsuy]*)$/);
            caseSensitive = !flags.includes("i");
            searchPattern = new RegExp(body, flags.includes("g") ? flags : flags + "g");
          } else {
            searchPattern = String(patternInput);
          }
          const searchIndex = this.storage.searchIndex;
          searchIndex.ensureValid(state.doc);
          const indexMatches = searchIndex.search(searchPattern, {
            caseSensitive,
            maxMatches
          });
          const resultMatches = [];
          for (const indexMatch of indexMatches) {
            const ranges = searchIndex.offsetRangeToDocRanges(indexMatch.start, indexMatch.end);
            if (ranges.length === 0) continue;
            const matchTexts = ranges.map((r2) => state.doc.textBetween(r2.from, r2.to));
            const combinedText = matchTexts.join("");
            const match = {
              from: ranges[0].from,
              to: ranges[ranges.length - 1].to,
              text: combinedText,
              id: uuid.v4(),
              ranges,
              trackerIds: []
            };
            resultMatches.push(match);
          }
          this.storage.searchResults = resultMatches;
          this.storage.highlightEnabled = highlight;
          return resultMatches;
        }
      ),
      /**
       * Navigate to a specific search match
       * @category Command
       * @param {SearchMatch} match - Match object to navigate to
       * @example
       * const searchResults = editor.commands.search('test string')
       * editor.commands.goToSearchResult(searchResults[3])
       * @note Scrolls to match and selects it. For multi-range matches (cross-paragraph),
       *       selects the first range and scrolls to it.
       */
      goToSearchResult: (match) => (
        /** @returns {boolean} */
        ({ state, dispatch, editor }) => {
          const positionTracker = getPositionTracker(editor);
          const doc2 = state.doc;
          const highlights = getMatchHighlights(state);
          let from3, to;
          if (match?.ranges && match.ranges.length > 0 && match?.trackerIds && match.trackerIds.length > 0) {
            if (positionTracker?.resolve && match.trackerIds[0]) {
              const resolved = positionTracker.resolve(match.trackerIds[0]);
              if (resolved) {
                from3 = resolved.from;
                to = resolved.to;
              }
            }
            if (from3 === void 0) {
              from3 = match.ranges[0].from;
              to = match.ranges[0].to;
            }
          } else {
            from3 = match.from;
            to = match.to;
            if (positionTracker?.resolve && match?.id) {
              const resolved = positionTracker.resolve(match.id);
              if (resolved) {
                from3 = resolved.from;
                to = resolved.to;
              }
            }
          }
          const normalized = resolveSearchRange({
            doc: doc2,
            from: from3,
            to,
            expectedText: match?.text ?? null,
            highlights
          });
          from3 = normalized.from;
          to = normalized.to;
          editor.view.focus();
          const tr = state.tr.setSelection(superEditor_converter.TextSelection.create(state.doc, from3, to)).scrollIntoView();
          if (dispatch) dispatch(tr);
          const presentationEditor = editor.presentationEditor;
          if (presentationEditor && typeof presentationEditor.scrollToPosition === "function") {
            const didScroll = presentationEditor.scrollToPosition(from3, { block: "center" });
            if (didScroll) return true;
          }
          const { node } = editor.view.domAtPos(from3);
          if (node?.scrollIntoView) {
            node.scrollIntoView({ block: "center", inline: "nearest" });
          }
          return true;
        }
      )
    };
  }
});
const NodeResizerKey = new superEditor_converter.PluginKey("node-resizer");
const nodeResizer = (nodeNames = ["image"], editor) => {
  let resizeState = {
    dragging: false,
    startX: 0,
    startWidth: 0,
    handle: null,
    pos: null,
    resizableElement: null,
    aspectRatio: 1
  };
  let resizeContainer = null;
  let editorView = null;
  let globalClickHandler = null;
  let globalMousedownHandler = null;
  let scrollHandler = null;
  let currentWrapper = null;
  return new superEditor_converter.Plugin({
    key: NodeResizerKey,
    state: {
      init() {
        return DecorationSet.empty;
      },
      apply(tr, oldState, _2, newState) {
        if (tr.getMeta(NodeResizerKey)) {
          return oldState;
        }
        if (typeof document === "undefined" || editor.options.isHeadless) return oldState;
        if (!editor.options.isHeaderOrFooter && (editor.options.documentMode === "viewing" || !editor.isEditable)) {
          return DecorationSet.empty;
        }
        const { selection } = newState;
        const node = selection.node;
        if (!node || !nodeNames.includes(node.type.name)) {
          return DecorationSet.empty;
        }
        if (node.attrs?.vmlWatermark === true) {
          return DecorationSet.empty;
        }
        const decorations = [];
        if (nodeNames.includes(selection.node?.type.name)) {
          decorations.push(
            Decoration.node(selection.from, selection.to, {
              nodeName: "span",
              class: "sd-editor-resizable-wrapper",
              "data-pos": selection.from
            })
          );
        }
        return DecorationSet.create(newState.doc, decorations);
      }
    },
    props: {
      decorations(state) {
        return this.getState(state);
      }
    },
    view(view) {
      editorView = view;
      globalClickHandler = (event) => {
        if (!event.target.closest(".sd-editor-resizable-wrapper") && !event.target.closest(".sd-editor-resize-container")) {
          hideResizeHandles();
        }
      };
      document.addEventListener("click", globalClickHandler);
      globalMousedownHandler = (event) => {
        if (event.target.closest(".sd-editor-resize-handle")) {
          event.preventDefault();
          event.stopPropagation();
          startResize(editorView, event, event.target);
          return true;
        }
      };
      document.addEventListener("mousedown", globalMousedownHandler);
      scrollHandler = () => {
        if (currentWrapper && resizeContainer) {
          updateHandlePositions(currentWrapper);
        }
      };
      window.addEventListener("scroll", scrollHandler, true);
      return {
        update(view2, prevState) {
          const { selection } = view2.state;
          const prevSelection = prevState.selection;
          if (selection.from !== prevSelection.from || selection.to !== prevSelection.to) {
            setTimeout(() => {
              const searchRoot = editorView?.dom;
              const selectedResizableWrapper = searchRoot?.querySelector(".sd-editor-resizable-wrapper");
              if (selectedResizableWrapper) {
                showResizeHandles(view2, selectedResizableWrapper);
              } else {
                hideResizeHandles();
              }
            }, 10);
          }
        },
        destroy() {
          hideResizeHandles();
          cleanupEventListeners();
          if (globalClickHandler) {
            document.removeEventListener("click", globalClickHandler);
            globalClickHandler = null;
          }
          if (globalMousedownHandler) {
            document.removeEventListener("mousedown", globalMousedownHandler);
            globalMousedownHandler = null;
          }
          if (scrollHandler) {
            window.removeEventListener("scroll", scrollHandler, true);
            scrollHandler = null;
          }
          editorView = null;
        }
      };
    }
  });
  function showResizeHandles(view, wrapper) {
    hideResizeHandles();
    const pos = Number.parseInt(wrapper.getAttribute("data-pos"), 10);
    const node = view.state.doc.nodeAt(pos);
    if (!nodeNames.includes(node?.type.name)) return;
    if (node?.attrs?.vmlWatermark === true) return;
    currentWrapper = wrapper;
    resizeContainer = document.createElement("div");
    resizeContainer.className = "sd-editor-resize-container";
    resizeContainer.style.position = "absolute";
    resizeContainer.style.pointerEvents = "none";
    resizeContainer.style.zIndex = "1000";
    const handles = ["nw", "ne", "sw", "se"];
    for (const handle of handles) {
      const handleEl = document.createElement("div");
      handleEl.className = `sd-editor-resize-handle sd-editor-resize-handle-${handle}`;
      handleEl.setAttribute("data-handle", handle);
      handleEl.setAttribute("data-pos", pos);
      handleEl.style.pointerEvents = "auto";
      resizeContainer.appendChild(handleEl);
    }
    applyStyleIsolationClass(resizeContainer);
    document.body.appendChild(resizeContainer);
    updateHandlePositions(wrapper);
  }
  function hideResizeHandles() {
    if (resizeContainer?.parentNode) {
      resizeContainer.parentNode.removeChild(resizeContainer);
      resizeContainer = null;
    }
    currentWrapper = null;
  }
  function updateHandlePositions(resizableElement) {
    if (!resizeContainer || !resizableElement) return;
    const rect = resizableElement.getBoundingClientRect();
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    resizeContainer.style.left = `${rect.left + scrollLeft}px`;
    resizeContainer.style.top = `${rect.top + scrollTop}px`;
    resizeContainer.style.width = `${rect.width}px`;
    resizeContainer.style.height = `${rect.height}px`;
  }
  function startResize(view, event, handleElement) {
    if (!view.hasFocus()) return;
    const handle = handleElement.getAttribute("data-handle");
    const pos = Number.parseInt(handleElement.getAttribute("data-pos"), 10);
    if (view.state.selection.from !== pos || !nodeNames.includes(view.state.selection.node?.type.name)) return;
    const resizableElement = view.nodeDOM(pos);
    if (!resizableElement) return;
    const rect = resizableElement.getBoundingClientRect();
    resizeState = {
      dragging: true,
      startX: event.clientX,
      startY: event.clientY,
      startWidth: rect.width,
      startHeight: rect.height,
      handle,
      pos,
      resizableElement,
      aspectRatio: rect.width / rect.height
    };
    document.addEventListener("mousemove", handleMouseMove2);
    document.addEventListener("mouseup", handleMouseUp);
    document.body.style.cursor = getResizeCursor(handle);
    document.body.style.userSelect = "none";
  }
  function handleMouseMove2(event) {
    if (!resizeState.dragging) return;
    event.preventDefault();
    event.stopPropagation();
    let deltaX = event.clientX - resizeState.startX;
    if (resizeState.handle.includes("w")) deltaX = -deltaX;
    const newWidth = Math.max(20, resizeState.startWidth + deltaX);
    if (resizeState.resizableElement) {
      resizeState.resizableElement.style.width = `${newWidth}px`;
      resizeState.resizableElement.style.height = "auto";
      updateHandlePositions(resizeState.resizableElement);
    }
  }
  function handleMouseUp(event) {
    if (!resizeState.dragging) return;
    cleanupEventListeners();
    let deltaX = event.clientX - resizeState.startX;
    if (resizeState.handle.includes("w")) deltaX = -deltaX;
    const newWidth = Math.max(20, resizeState.startWidth + deltaX);
    const newHeight = newWidth / resizeState.aspectRatio;
    if (editorView && resizeState.pos < editorView.state.doc.content.size) {
      const tr = editorView.state.tr;
      const node = tr.doc.nodeAt(resizeState.pos);
      if (nodeNames.includes(node?.type.name)) {
        const attrs = {
          ...node.attrs,
          size: {
            ...node.attrs.size,
            width: Math.round(newWidth),
            height: Math.round(newHeight)
          }
        };
        tr.setNodeMarkup(resizeState.pos, null, attrs);
        tr.setMeta(NodeResizerKey, { action: "resize" });
        editorView.dispatch(tr);
      }
    }
    resizeState = {
      dragging: false,
      startX: 0,
      startY: 0,
      startWidth: 0,
      startHeight: 0,
      handle: null,
      pos: null,
      resizableElement: null,
      aspectRatio: 1
    };
  }
  function cleanupEventListeners() {
    document.removeEventListener("mousemove", handleMouseMove2);
    document.removeEventListener("mouseup", handleMouseUp);
    document.body.style.cursor = "";
    document.body.style.userSelect = "";
  }
  function getResizeCursor(handle) {
    switch (handle) {
      case "nw":
      case "se":
        return "nwse-resize";
      case "ne":
      case "sw":
        return "nesw-resize";
      default:
        return "default";
    }
  }
};
const NodeResizer = Extension.create({
  name: "nodeResizer",
  addOptions() {
    return {};
  },
  addPmPlugins() {
    const isHeadless2 = this.editor.options.isHeadless;
    const hasDocument = typeof document !== "undefined";
    if (isHeadless2 || !hasDocument) return [];
    return [nodeResizer(["image"], this.editor)];
  }
});
const PERMISSION_PLUGIN_KEY = new superEditor_converter.PluginKey("permissionRanges");
const EVERYONE_GROUP = "everyone";
const EMPTY_IDENTIFIER_SET = Object.freeze(/* @__PURE__ */ new Set());
const normalizeIdentifier = (value) => typeof value === "string" ? value.trim().toLowerCase() : "";
const buildAllowedIdentifierSet = (editor) => {
  const email = normalizeIdentifier(editor?.options?.user?.email);
  if (!email) {
    return EMPTY_IDENTIFIER_SET;
  }
  const [localPart, domain] = email.split("@");
  if (!localPart || !domain) {
    return EMPTY_IDENTIFIER_SET;
  }
  const formatted = `${domain}\\${localPart}`;
  return formatted ? /* @__PURE__ */ new Set([formatted]) : EMPTY_IDENTIFIER_SET;
};
const isEveryoneGroup = (value) => normalizeIdentifier(value) === EVERYONE_GROUP;
const isRangeAllowedForUser = (attrs, allowedIdentifiers) => {
  if (!attrs) return false;
  if (isEveryoneGroup(attrs.edGrp)) {
    return true;
  }
  if (!allowedIdentifiers?.size) {
    return false;
  }
  const normalizedEd = normalizeIdentifier(attrs.ed);
  return normalizedEd && allowedIdentifiers.has(normalizedEd);
};
const getPermissionNodeId = (node, pos, fallbackPrefix) => String(node.attrs?.id ?? `${fallbackPrefix}-${pos}`);
const buildPermissionState = (doc2, allowedIdentifiers = EMPTY_IDENTIFIER_SET) => {
  const ranges = [];
  const openRanges = /* @__PURE__ */ new Map();
  doc2.descendants((node, pos) => {
    if (node.type?.name === "permStart") {
      const id = getPermissionNodeId(node, pos, "permStart");
      openRanges.set(id, {
        from: pos + node.nodeSize,
        attrs: node.attrs ?? {}
      });
      return false;
    }
    if (node.type?.name === "permEnd") {
      const id = getPermissionNodeId(node, pos, "permEnd");
      const start2 = openRanges.get(id);
      if (start2 && isRangeAllowedForUser(start2.attrs, allowedIdentifiers)) {
        const to = Math.max(pos, start2.from);
        if (to > start2.from) {
          ranges.push({
            id,
            from: start2.from,
            to
          });
        }
      }
      if (start2) {
        openRanges.delete(id);
      }
      return false;
    }
  });
  return {
    ranges,
    hasAllowedRanges: ranges.length > 0
  };
};
const collectPermissionTags = (doc2, permStartType, permEndType) => {
  const tags = /* @__PURE__ */ new Map();
  doc2.descendants((node, pos) => {
    if (node.type !== permStartType && node.type !== permEndType) {
      return;
    }
    const id = node.attrs?.id;
    if (!id) {
      return;
    }
    const entry = tags.get(id) ?? {};
    if (node.type === permStartType) {
      entry.start = { pos, attrs: node.attrs ?? {} };
    } else if (node.type === permEndType) {
      entry.end = { pos, attrs: node.attrs ?? {} };
    }
    tags.set(id, entry);
  });
  return tags;
};
const clampPosition = (pos, size2) => {
  if (Number.isNaN(pos) || !Number.isFinite(pos)) {
    return 0;
  }
  return Math.max(0, Math.min(pos, size2));
};
const trimPermissionTagsFromRange = (doc2, range, permStartType, permEndType) => {
  let from3 = range.from;
  let to = range.to;
  while (from3 < to) {
    const node = doc2.nodeAt(from3);
    if (!node || node.type !== permStartType && node.type !== permEndType) {
      break;
    }
    from3 += node.nodeSize;
  }
  while (to > from3) {
    const $pos = doc2.resolve(to);
    const nodeBefore = $pos.nodeBefore;
    if (!nodeBefore || nodeBefore.type !== permStartType && nodeBefore.type !== permEndType) {
      break;
    }
    to -= nodeBefore.nodeSize;
  }
  return { from: from3, to };
};
const collectChangedRanges = (tr) => {
  const ranges = [];
  tr.mapping.maps.forEach((map3) => {
    map3.forEach((oldStart, oldEnd) => {
      const from3 = Math.min(oldStart, oldEnd);
      const to = Math.max(oldStart, oldEnd);
      ranges.push({ from: from3, to });
    });
  });
  return ranges;
};
const isRangeAllowed = (range, allowedRanges) => {
  if (!allowedRanges?.length) return false;
  return allowedRanges.some((allowed) => range.from >= allowed.from && range.to <= allowed.to);
};
const PermissionRanges = Extension.create({
  name: "permissionRanges",
  addStorage() {
    return {
      ranges: [],
      hasAllowedRanges: false
    };
  },
  addPmPlugins() {
    const editor = this.editor;
    const storage = this.storage;
    let originalSetDocumentMode = null;
    const getAllowedIdentifiers = () => buildAllowedIdentifierSet(editor);
    const toggleEditableIfAllowed = (hasAllowedRanges) => {
      if (!editor || editor.isDestroyed) return;
      if (editor.options.documentMode !== "viewing") return;
      if (hasAllowedRanges && !editor.isEditable) {
        editor.setEditable(true, false);
      } else if (!hasAllowedRanges && editor.isEditable) {
        editor.setEditable(false, false);
      }
    };
    const updateEditableState = (hasAllowedRanges) => {
      const nextValue = Boolean(hasAllowedRanges);
      const previousValue = storage.hasAllowedRanges;
      storage.hasAllowedRanges = nextValue;
      if (previousValue === nextValue) {
        return;
      }
      toggleEditableIfAllowed(nextValue);
    };
    if (editor && typeof editor.setDocumentMode === "function") {
      originalSetDocumentMode = editor.setDocumentMode.bind(editor);
      editor.setDocumentMode = (mode, caller) => {
        originalSetDocumentMode(mode, caller);
        const state = editor.state;
        if (!state) return;
        const pluginState = PERMISSION_PLUGIN_KEY.getState(state);
        if (pluginState) {
          toggleEditableIfAllowed(pluginState.hasAllowedRanges);
        }
      };
    }
    return [
      new superEditor_converter.Plugin({
        key: PERMISSION_PLUGIN_KEY,
        state: {
          init(_2, state) {
            const permissionState = buildPermissionState(state.doc, getAllowedIdentifiers());
            storage.ranges = permissionState.ranges;
            updateEditableState(permissionState.hasAllowedRanges);
            return permissionState;
          },
          apply(tr, value, _oldState, newState) {
            let permissionState = value;
            if (tr.docChanged) {
              permissionState = buildPermissionState(newState.doc, getAllowedIdentifiers());
              storage.ranges = permissionState.ranges;
              updateEditableState(permissionState.hasAllowedRanges);
            }
            return permissionState;
          }
        },
        view() {
          return {
            destroy() {
              if (editor && originalSetDocumentMode) {
                editor.setDocumentMode = originalSetDocumentMode;
              }
            }
          };
        },
        // Appends transactions to the document to ensure permission ranges are updated.
        appendTransaction(transactions, oldState, newState) {
          if (!transactions.some((tr2) => tr2.docChanged)) return null;
          const permStartType = newState.schema.nodes["permStart"];
          const permEndType = newState.schema.nodes["permEnd"];
          if (!permStartType || !permEndType) return null;
          const oldTags = collectPermissionTags(oldState.doc, permStartType, permEndType);
          if (!oldTags.size) {
            return null;
          }
          const newTags = collectPermissionTags(newState.doc, permStartType, permEndType);
          const mappingToNew = new superEditor_converter.Mapping();
          transactions.forEach((tr2) => {
            mappingToNew.appendMapping(tr2.mapping);
          });
          const pendingInsertions = [];
          oldTags.forEach((tag, id) => {
            const current = newTags.get(id);
            if (tag.start && !current?.start) {
              const mapped = mappingToNew.mapResult(tag.start.pos, -1);
              pendingInsertions.push({
                pos: mapped.pos,
                nodeType: permStartType,
                attrs: tag.start.attrs,
                priority: 0
              });
            }
            if (tag.end && !current?.end) {
              const mapped = mappingToNew.mapResult(tag.end.pos, 1);
              pendingInsertions.push({
                pos: mapped.pos,
                nodeType: permEndType,
                attrs: tag.end.attrs,
                priority: 1
              });
            }
          });
          if (!pendingInsertions.length) {
            return null;
          }
          pendingInsertions.sort((a, b2) => {
            if (a.pos === b2.pos) {
              return a.priority - b2.priority;
            }
            return a.pos - b2.pos;
          });
          const tr = newState.tr;
          let offset2 = 0;
          pendingInsertions.forEach((item) => {
            const node = item.nodeType.create(item.attrs);
            const insertPos = clampPosition(item.pos + offset2, tr.doc.content.size);
            tr.insert(insertPos, node);
            offset2 += node.nodeSize;
          });
          return tr.docChanged ? tr : null;
        },
        // Filters transactions to ensure only allowed edits are applied.
        filterTransaction(tr, state) {
          if (!tr.docChanged) return true;
          if (!editor || editor.options.documentMode !== "viewing") return true;
          const pluginState = PERMISSION_PLUGIN_KEY.getState(state);
          if (!pluginState?.hasAllowedRanges) {
            return true;
          }
          const changedRanges = collectChangedRanges(tr);
          if (!changedRanges.length) return true;
          const permStartType = state.schema.nodes["permStart"];
          const permEndType = state.schema.nodes["permEnd"];
          if (!permStartType || !permEndType) return true;
          const allRangesAllowed = changedRanges.every((range) => {
            const trimmed = trimPermissionTagsFromRange(state.doc, range, permStartType, permEndType);
            return isRangeAllowed(trimmed, pluginState.ranges);
          });
          return allRangesAllowed;
        }
      })
    ];
  }
});
const PermStart = Node$1.create({
  name: "permStart",
  group: "inline",
  inline: true,
  renderDOM() {
    return ["span", { style: "display: none;" }];
  },
  addAttributes() {
    return {
      id: {
        default: null
      },
      edGrp: {
        default: null
      },
      ed: {
        default: null
      },
      colFirst: {
        default: null
      },
      colLast: {
        default: null
      }
    };
  }
});
const PermEnd = Node$1.create({
  name: "permEnd",
  group: "inline",
  inline: true,
  renderDOM() {
    return ["span", { style: "display: none;" }];
  },
  addAttributes() {
    return {
      id: {
        default: null
      },
      edGrp: {
        default: null
      },
      displacedByCustomXml: {
        default: null
      }
    };
  }
});
const getRichTextExtensions = () => {
  return [
    Bold,
    Color,
    Document,
    FontFamily,
    FontSize,
    History,
    Heading,
    Italic,
    Link,
    Paragraph,
    Strike,
    Text,
    TextAlign,
    TextStyle,
    Underline,
    Placeholder,
    PopoverPlugin,
    Mention,
    Highlight,
    FormatCommands,
    Table,
    TableRow,
    TableCell,
    TableHeader,
    FieldAnnotation,
    DropCursor,
    TrackInsert,
    TrackDelete,
    TrackFormat,
    AiPlugin,
    Image,
    NodeResizer,
    CustomSelection,
    PassthroughInline,
    PassthroughBlock
  ];
};
const getStarterExtensions = () => {
  return [
    Bold,
    BlockNode,
    Color,
    CommentRangeStart,
    CommentRangeEnd,
    CommentReference,
    FootnoteReference,
    Document,
    FontFamily,
    FontSize,
    History,
    Heading,
    Italic,
    Link,
    Paragraph,
    LineBreak,
    HardBreak,
    Run,
    SlashMenu,
    Strike,
    TabNode,
    TableOfContents,
    DocumentIndex,
    Text,
    TextAlign,
    TextStyle,
    Underline,
    FormatCommands,
    CommentsPlugin,
    Gapcursor,
    Table,
    TableRow,
    TableCell,
    TableHeader,
    FieldAnnotation,
    DropCursor,
    Image,
    BookmarkStart,
    BookmarkEnd,
    Mention,
    Collaboration,
    CollaborationCursor,
    TrackChanges,
    TrackInsert,
    TrackDelete,
    TrackFormat,
    CommentsMark,
    Highlight,
    LinkedStyles,
    AiPlugin,
    AiMark,
    AiAnimationMark,
    AiLoaderNode,
    PageNumber,
    TotalPageCount,
    PageReference,
    IndexEntry,
    ShapeContainer,
    ShapeTextbox,
    ContentBlock,
    Search,
    StructuredContent,
    StructuredContentBlock,
    StructuredContentCommands,
    DocumentSection,
    DocumentPartObject,
    NodeResizer,
    CustomSelection,
    TextTransform,
    VectorShape,
    ShapeGroup,
    PermStart,
    PermEnd,
    PermissionRanges,
    PassthroughInline,
    PassthroughBlock
  ];
};
const sanitizeNumber = (value, defaultNumber) => {
  let sanitized = value.replace(/[^0-9.]/g, "");
  sanitized = parseFloat(sanitized);
  if (isNaN(sanitized)) sanitized = defaultNumber;
  sanitized = parseFloat(sanitized);
  return sanitized;
};
const throttle = (func, wait, options) => {
  let timeout2, args, result;
  let previous = 0;
  if (!options) options = {};
  const later = () => {
    previous = options.leading === false ? 0 : Date.now();
    timeout2 = null;
    result = func(...args);
    if (!timeout2) args = null;
  };
  const throttled = (...callArgs) => {
    const _now = Date.now();
    if (!previous && options.leading === false) previous = _now;
    const remaining = wait - (_now - previous);
    args = callArgs;
    if (remaining <= 0 || remaining > wait) {
      if (timeout2) {
        clearTimeout(timeout2);
        timeout2 = null;
      }
      previous = _now;
      result = func(...callArgs);
      if (!timeout2) args = null;
    } else if (!timeout2 && options.trailing !== false) {
      timeout2 = setTimeout(later, remaining);
    }
    return result;
  };
  throttled.cancel = function() {
    clearTimeout(timeout2);
    previous = 0;
    timeout2 = args = null;
  };
  return throttled;
};
const useToolbarItem = (options) => {
  const types = ["button", "options", "separator", "dropdown", "overflow"];
  if (!types.includes(options.type)) {
    throw new Error("Invalid toolbar item type - " + options.type);
  }
  if (options.type === "button" && !options.defaultLabel && !options.icon) {
    throw new Error("Toolbar button item needs either icon or label - " + options.name);
  }
  if (!options.name) {
    throw new Error("Invalid toolbar item name - " + options.name);
  }
  const id = vue.ref(uuid.v4());
  const type = options.type;
  const name = vue.ref(options.name);
  const command2 = options.command;
  const noArgumentCommand = options.noArgumentCommand;
  const icon = vue.ref(options.icon);
  const group = vue.ref(options.group || "center");
  const allowWithoutEditor = vue.ref(options.allowWithoutEditor);
  const attributes = vue.ref(options.attributes || {});
  const initiallyDisabled = options.disabled || false;
  const disabled = vue.ref(options.disabled);
  const active = vue.ref(false);
  const expand = vue.ref(false);
  const style2 = vue.ref(options.style);
  const isNarrow = vue.ref(options.isNarrow);
  const isWide = vue.ref(options.isWide);
  const minWidth = vue.ref(options.minWidth);
  const suppressActiveHighlight = vue.ref(options.suppressActiveHighlight || false);
  const argument = vue.ref(options.argument);
  const childItem = vue.ref(null);
  const parentItem = vue.ref(null);
  const iconColor = vue.ref(options.iconColor);
  const hasCaret = vue.ref(options.hasCaret);
  const restoreEditorFocus = Boolean(options.restoreEditorFocus);
  const dropdownStyles = vue.ref(options.dropdownStyles);
  const tooltip = vue.ref(options.tooltip);
  const tooltipVisible = vue.ref(options.tooltipVisible);
  const tooltipTimeout = vue.ref(options.tooltipTimeout);
  const defaultLabel = vue.ref(options.defaultLabel);
  const label = vue.ref(options.label);
  const hideLabel = vue.ref(options.hideLabel);
  const inlineTextInputVisible = vue.ref(options.inlineTextInputVisible);
  const hasInlineTextInput = vue.ref(options.hasInlineTextInput);
  const markName = vue.ref(options.markName);
  const labelAttr = vue.ref(options.labelAttr);
  const selectedValue = vue.ref(options.selectedValue);
  const dropdownValueKey = vue.ref(options.dropdownValueKey);
  const inputRef = vue.ref(options.inputRef || null);
  const nestedOptions = vue.ref([]);
  if (options.options) {
    if (!Array.isArray(options.options)) throw new Error("Invalid toolbar item options - " + options.options);
    nestedOptions.value?.push(...options.options);
  }
  const activate = (attrs = {}, ...args) => {
    onActivate(attrs, ...args);
    if (suppressActiveHighlight.value) return;
    active.value = true;
  };
  const deactivate = () => {
    onDeactivate();
    active.value = false;
  };
  const setDisabled = (state) => {
    disabled.value = state;
  };
  const resetDisabled = () => {
    disabled.value = initiallyDisabled;
  };
  const onActivate = options.onActivate || (() => null);
  const onDeactivate = options.onDeactivate || (() => null);
  const unref = () => {
    const flattened = {};
    Object.keys(refs).forEach((key2) => {
      if (refs[key2].value !== void 0) {
        flattened[key2] = refs[key2].value;
      }
    });
    return flattened;
  };
  const refs = {
    id,
    name,
    type,
    command: command2,
    noArgumentCommand,
    icon,
    tooltip,
    group,
    attributes,
    disabled,
    active,
    expand,
    nestedOptions,
    style: style2,
    isNarrow,
    isWide,
    minWidth,
    argument,
    parentItem,
    iconColor,
    hasCaret,
    dropdownStyles,
    tooltipVisible,
    tooltipTimeout,
    defaultLabel,
    label,
    hideLabel,
    inlineTextInputVisible,
    hasInlineTextInput,
    restoreEditorFocus,
    markName,
    labelAttr,
    childItem,
    allowWithoutEditor,
    dropdownValueKey,
    selectedValue,
    inputRef
  };
  return {
    ...refs,
    unref,
    activate,
    deactivate,
    setDisabled,
    resetDisabled,
    onActivate,
    onDeactivate
  };
};
const DEFAULT_API_ENDPOINT = "https://sd-dev-express-gateway-i6xtm.ondigitalocean.app/insights";
const SYSTEM_PROMPT = "You are an expert copywriter and you are immersed in a document editor. You are to provide document related text responses based on the user prompts. Only write what is asked for. Do not provide explanations. Try to keep placeholders as short as possible. Do not output your prompt. Your instructions are: ";
async function baseInsightsFetch(payload, options = {}) {
  const apiKey = options.apiKey;
  const apiEndpoint = options.endpoint || DEFAULT_API_ENDPOINT;
  try {
    const headers = {
      "Content-Type": "application/json"
    };
    if (apiKey) {
      headers["x-api-key"] = apiKey;
    }
    const response = await fetch(apiEndpoint, {
      method: "POST",
      headers,
      body: JSON.stringify(payload)
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Harbour API error: ${response.status} - ${errorText}`);
    }
    return response;
  } catch (error) {
    console.error("Error calling Harbour API:", error);
    throw error;
  }
}
async function processStream(stream, onChunk, onDone) {
  const reader = stream.getReader();
  const decoder = new TextDecoder();
  let result = "";
  let buffer = "";
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        if (typeof onDone === "function") {
          onDone();
        }
        break;
      }
      const chunk = decoder.decode(value, { stream: true });
      if (typeof onChunk === "function") {
        onChunk(chunk);
      }
    }
    let extractedValue = getJsonBetweenFencesFromResponse(buffer);
    if (extractedValue !== null) {
      result = extractedValue;
    }
    return result || "";
  } catch (error) {
    console.error("Error reading stream:", error);
    throw error;
  } finally {
    reader.releaseLock();
  }
}
function getJsonBetweenFencesFromResponse(buffer) {
  try {
    const jsonRegex = /```json\s*\n([\s\S]*?)\n\s*```/;
    const match = buffer.match(jsonRegex);
    if (match && match[1]) {
      const jsonObj = JSON.parse(match[1]);
      if (jsonObj.custom_prompt && jsonObj.custom_prompt.value !== void 0) {
        return jsonObj.custom_prompt.value || "";
      }
    }
    return null;
  } catch {
    return null;
  }
}
async function writeStreaming(prompt, options = {}, onChunk, onDone) {
  if (!prompt) {
    throw new Error("Prompt is required for text generation");
  }
  const payload = {
    stream: true,
    context: SYSTEM_PROMPT,
    doc_text: "",
    insights: [
      {
        type: "custom_prompt",
        name: "text_generation",
        message: `Generate text based on the following prompt: ${prompt}`
      }
    ]
  };
  if (options.documentXml) {
    payload.document_content = options.documentXml;
  }
  const response = await baseInsightsFetch(payload, options.config || {});
  if (!response.body) return "";
  return await processStream(response.body, onChunk, onDone);
}
async function rewriteStreaming(text, prompt = "", options = {}, onChunk, onDone) {
  if (!text) {
    throw new Error("Text is required for rewriting");
  }
  const message = prompt ? `Rewrite the following text: "${text}" using these instructions: ${prompt}` : `Rewrite the following text: "${text}"`;
  const payload = {
    stream: true,
    context: SYSTEM_PROMPT,
    insights: [
      {
        type: "custom_prompt",
        name: "text_rewrite",
        message
      }
    ]
  };
  const response = await baseInsightsFetch(payload, options.config || {});
  if (!response.body) return "";
  return await processStream(response.body, onChunk, onDone);
}
const formatRegistry = {
  rules: [
    {
      name: "bold",
      pattern: /\*\*(.*?)\*\*/g,
      transform: (_match, content) => ({
        type: "text",
        marks: [{ type: "bold" }],
        text: content
      })
    },
    {
      name: "italic",
      pattern: /\*(.*?)\*/g,
      transform: (_match, content) => ({
        type: "text",
        marks: [{ type: "italic" }],
        text: content
      })
    },
    {
      name: "underline",
      pattern: /<(?:u|ins)>(.*?)<\/(?:u|ins)>/g,
      transform: (_match, content) => ({
        type: "text",
        marks: [{ type: "underline" }],
        text: content
      })
    }
  ]
};
function formatDocument(editor) {
  try {
    let doc2 = editor.state.doc;
    const docText = doc2.textContent || "";
    if (!docText) return;
    formatRegistry.rules.forEach((rule) => {
      rule.pattern.lastIndex = 0;
      const matches = [];
      let match;
      while ((match = rule.pattern.exec(docText)) !== null) {
        matches.push({
          rule,
          startPos: match.index,
          endPos: match.index + match[0].length,
          originalText: match[0],
          contentText: match[1]
        });
      }
      matches.sort((a, b2) => b2.startPos - a.startPos);
      for (const match2 of matches) {
        const { startPos, endPos, originalText, contentText } = match2;
        try {
          let tr = editor.state.tr;
          const replacement = rule.transform(originalText, contentText, editor);
          const nodesInRange = [];
          doc2.nodesBetween(startPos, Math.min(endPos, doc2.content.size), (node, pos) => {
            if (node.isText) {
              nodesInRange.push({ node, pos });
            }
            return true;
          });
          if (nodesInRange.length > 0) {
            let foundExactMatch = false;
            let actualStartPos = -1;
            let actualEndPos = -1;
            for (let i = 0; i < nodesInRange.length; i++) {
              const nodeInfo = nodesInRange[i];
              const nodeText = nodeInfo.node.text || "";
              const nodePos = nodeInfo.pos;
              if (nodeText.includes(originalText)) {
                const nodeMatchIndex = nodeText.indexOf(originalText);
                actualStartPos = nodePos + nodeMatchIndex;
                actualEndPos = actualStartPos + originalText.length;
                foundExactMatch = true;
                break;
              }
            }
            if (!foundExactMatch) {
              let combinedText = "";
              let offsets = [];
              let basePos = nodesInRange[0].pos;
              for (const nodeInfo of nodesInRange) {
                const nodeText = nodeInfo.node.text || "";
                const relativePos = nodeInfo.pos - basePos;
                for (let i = 0; i < nodeText.length; i++) {
                  offsets.push(relativePos + i);
                }
                combinedText += nodeText;
              }
              const matchIndex = combinedText.indexOf(originalText);
              if (matchIndex >= 0) {
                actualStartPos = basePos + offsets[matchIndex];
                const endIndex = matchIndex + originalText.length - 1;
                actualEndPos = basePos + (offsets[endIndex] || 0) + 1;
                foundExactMatch = true;
              }
            }
            if (foundExactMatch) {
              const marks = replacement.marks ? replacement.marks.map((mark) => editor.schema.marks[mark.type].create(mark.attrs)) : [];
              tr = tr.delete(actualStartPos, actualEndPos);
              tr = tr.insert(actualStartPos, editor.schema.text(replacement.text, marks));
              if (tr.docChanged) {
                editor.view.dispatch(tr);
                doc2 = editor.state.doc;
              }
            }
          }
        } catch (error) {
          console.error("Error processing match:", error);
        }
      }
    });
  } catch (error) {
    console.error("Error formatting document:", error);
  }
}
const edit = '<!-- @note: includes color gradient for inline svg AI Writer -->\n<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.-->\n    <linearGradient id="gradient" x1="125%" y1="50%" x2="-25%" y2="50%">\n        <stop offset="-20%" stop-color="rgba(218, 215, 118, 0.5)" />\n        <stop offset="30%" stop-color="rgb(191, 100, 100)" />\n        <stop offset="60%" stop-color="rgb(77, 82, 217)" />\n        <stop offset="150%" stop-color="rgb(255, 219, 102)" />\n    </linearGradient>\n    <path fill="url(#gradient)" d="M402.3 344.9l32-32c5-5 13.7-1.5 13.7 5.7V464c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h273.5c7.1 0 10.7 8.6 5.7 13.7l-32 32c-1.5 1.5-3.5 2.3-5.7 2.3H48v352h352V350.5c0-2.1 .8-4.1 2.3-5.6zm156.6-201.8L296.3 405.7l-90.4 10c-26.2 2.9-48.5-19.2-45.6-45.6l10-90.4L432.9 17.1c22.9-22.9 59.9-22.9 82.7 0l43.2 43.2c22.9 22.9 22.9 60 .1 82.8zM460.1 174L402 115.9 216.2 301.8l-7.3 65.3 65.3-7.3L460.1 174zm64.8-79.7l-43.2-43.2c-4.1-4.1-10.8-4.1-14.8 0L436 82l58.1 58.1 30.9-30.9c4-4.2 4-10.8-.1-14.9z"/>\n</svg>';
const paperPlane = '<!-- @note: includes color gradient for inline svg AI Writer -->\n<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.-->\n  <defs>\n    <linearGradient id="gradient" x1="125%" y1="50%" x2="-25%" y2="50%">\n      <stop offset="-20%" stop-color="rgba(218, 215, 118, 0.5)" />\n      <stop offset="30%" stop-color="rgb(191, 100, 100)" />\n      <stop offset="60%" stop-color="rgb(77, 82, 217)" />\n      <stop offset="150%" stop-color="rgb(255, 219, 102)" />\n    </linearGradient>\n  </defs>\n  <path fill="url(#gradient)" d="M440 6.5L24 246.4c-34.4 19.9-31.1 70.8 5.7 85.9L144 379.6V464c0 46.4 59.2 65.5 86.6 28.6l43.8-59.1 111.9 46.2c5.9 2.4 12.1 3.6 18.3 3.6 8.2 0 16.3-2.1 23.6-6.2 12.8-7.2 21.6-20 23.9-34.5l59.4-387.2c6.1-40.1-36.9-68.8-71.5-48.9zM192 464v-64.6l36.6 15.1L192 464zm212.6-28.7l-153.8-63.5L391 169.5c10.7-15.5-9.5-33.5-23.7-21.2L155.8 332.6 48 288 464 48l-59.4 387.3z"/>\n</svg>';
const _hoisted_1$k = { class: "ai-user-input-field" };
const _hoisted_2$e = ["innerHTML"];
const _hoisted_3$a = ["placeholder"];
const _hoisted_4$6 = { class: "ai-loader" };
const _hoisted_5$4 = ["innerHTML"];
const _sfc_main$n = {
  __name: "AIWriter",
  props: {
    selectedText: {
      type: String,
      required: true
    },
    handleClose: {
      type: Function,
      required: true
    },
    editor: {
      type: Object,
      required: true
    },
    apiKey: {
      type: String
    },
    endpoint: {
      type: String,
      required: false
    }
  },
  setup(__props) {
    const props = __props;
    const selectionState = vue.ref(null);
    const aiWriterRef = vue.ref(null);
    const handleClickOutside2 = (event) => {
      if (aiWriterRef.value && !aiWriterRef.value.contains(event.target)) {
        if (!isLoading.value) {
          props.editor.commands.removeAiMark();
        }
        props.handleClose();
      }
    };
    const editableRef = vue.ref(null);
    const saveSelection = () => {
      if (props.selectedText) {
        selectionState.value = {
          ...props.editor.state.selection,
          from: props.editor.state.selection.from,
          to: props.editor.state.selection.to
        };
        props.editor.commands.setMeta("storedSelection", selectionState.value);
        props.editor.commands.insertAiMark();
      }
    };
    const focusTextarea = () => {
      setTimeout(() => {
        vue.nextTick(() => {
          if (editableRef.value) {
            editableRef.value.focus();
          }
        });
      }, 0);
    };
    const addEventListeners = () => {
      document.addEventListener("mousedown", handleClickOutside2);
      document.addEventListener("keydown", handleCaptureKeyDown, true);
    };
    const removeEventListeners = () => {
      document.removeEventListener("mousedown", handleClickOutside2);
      document.removeEventListener("keydown", handleCaptureKeyDown, true);
    };
    vue.onMounted(() => {
      saveSelection();
      focusTextarea();
      addEventListeners();
    });
    vue.onUnmounted(() => {
      if (!isLoading.value) {
        props.editor.commands.removeAiMark();
      }
      removeEventListeners();
    });
    const handleCaptureKeyDown = (event) => {
      if (editableRef.value && event.target === editableRef.value && ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.stopPropagation();
      }
    };
    const placeholderText = vue.computed(
      () => props.selectedText ? "Insert prompt to update text" : "Insert prompt to generate text"
    );
    const isLoading = vue.ref(false);
    const isError = vue.ref("");
    const promptText = vue.ref("");
    const textProcessingStarted = vue.ref(false);
    const previousText = vue.ref("");
    const isFormatting = vue.ref(false);
    const pendingFormatting = vue.ref(false);
    const isInSuggestingMode = vue.computed(() => {
      return props.editor.isInSuggestingMode?.() || false;
    });
    const getDocumentXml = () => {
      try {
        return props.editor.state.doc.textContent || "";
      } catch (error) {
        console.error("Error getting document XML:", error);
        return "";
      }
    };
    const handleTextChunk = async (text) => {
      try {
        props.editor.commands.removeAiNode("aiLoaderNode");
        if (props.selectedText && !textProcessingStarted.value) {
          props.editor.commands.removeAiMark();
          props.editor.commands.clearAiHighlightStyle();
          if (selectionState.value) {
            const { state } = props.editor;
            const { from: from3, to } = selectionState.value;
            const tr = state.tr.setSelection(superEditor_converter.TextSelection.create(state.doc, from3, to));
            props.editor.view.dispatch(tr);
          } else {
            console.warn("[AIWriter] No stored selection to restore");
          }
          props.editor.commands.deleteSelection();
          textProcessingStarted.value = true;
        }
        if (text === null || text === void 0 || text === "") {
          return;
        }
        const textStr = String(text);
        const wrappedContent = {
          type: "text",
          marks: [
            {
              type: "aiAnimationMark",
              attrs: {
                class: "sd-ai-text-appear",
                dataMarkId: `ai-animation-${Date.now()}`
              }
            }
          ],
          text: textStr
        };
        props.editor.commands.insertContent(wrappedContent);
        pendingFormatting.value = true;
        if (!isFormatting.value) {
          await runSafeFormat();
        }
        props.handleClose();
      } catch (error) {
        console.error("Error handling text chunk:", error);
      }
    };
    const runSafeFormat = async () => {
      if (isFormatting.value) return;
      try {
        isFormatting.value = true;
        pendingFormatting.value = false;
        await vue.nextTick();
        formatDocument(props.editor);
        if (pendingFormatting.value) {
          pendingFormatting.value = false;
          await runSafeFormat();
        }
      } finally {
        isFormatting.value = false;
      }
    };
    const handleDone = async () => {
      if (pendingFormatting.value || isFormatting.value) {
        pendingFormatting.value = true;
        await new Promise((resolve) => {
          const checkFormatting = () => {
            if (!isFormatting.value && !pendingFormatting.value) {
              resolve();
            } else {
              setTimeout(checkFormatting, 100);
            }
          };
          checkFormatting();
        });
      }
      await runSafeFormat();
      setTimeout(() => {
        props.editor.commands.removeAiMark("aiAnimationMark");
        props.editor.commands.removeAiMark();
      }, 1e3);
    };
    const handleSubmit = async () => {
      isError.value = "";
      textProcessingStarted.value = false;
      previousText.value = "";
      isLoading.value = true;
      try {
        props.handleClose();
        if (props.selectedText) {
          props.editor.commands.updateAiHighlightStyle("sd-ai-highlight-pulse");
          props.editor.commands.removeSelectionAfterAiPulse();
        } else {
          props.editor.commands.insertContent({
            type: "aiLoaderNode"
          });
        }
        if (isInSuggestingMode.value) {
          props.editor.commands.enableTrackChanges();
        }
        const documentXml = getDocumentXml();
        const options = {
          // @todo: implement grabbing document text
          docText: "",
          documentXml,
          config: {
            // Pass the aiApiKey to the AI helper functions
            apiKey: props.apiKey,
            endpoint: props.endpoint
          }
        };
        if (props.selectedText) {
          await rewriteStreaming(props.selectedText, promptText.value, options, handleTextChunk, handleDone);
        } else {
          await writeStreaming(promptText.value, options, handleTextChunk, handleDone);
        }
      } catch (error) {
        console.error("AI generation error:", error);
        isError.value = error.message || "An error occurred";
      } finally {
        promptText.value = "";
        if (isInSuggestingMode.value) {
          props.editor.commands.disableTrackChanges();
        }
        isLoading.value = false;
        textProcessingStarted.value = false;
      }
    };
    const handleKeyDown2 = (event) => {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        handleSubmit();
      }
    };
    const handleInput = (event) => {
      if (isError.value) {
        isError.value = "";
      }
      promptText.value = event.target.value;
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: "ai-writer prosemirror-isolated",
        ref_key: "aiWriterRef",
        ref: aiWriterRef,
        onMousedown: _cache[1] || (_cache[1] = vue.withModifiers(() => {
        }, ["stop"]))
      }, [
        vue.createBaseVNode("div", _hoisted_1$k, [
          vue.createBaseVNode("span", {
            class: "ai-textarea-icon",
            innerHTML: vue.unref(edit)
          }, null, 8, _hoisted_2$e),
          vue.withDirectives(vue.createBaseVNode("textarea", {
            ref_key: "editableRef",
            ref: editableRef,
            class: "ai-textarea",
            placeholder: placeholderText.value,
            onKeydown: handleKeyDown2,
            onInput: handleInput,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => promptText.value = $event),
            rows: "4"
          }, null, 40, _hoisted_3$a), [
            [vue.vModelText, promptText.value]
          ])
        ]),
        vue.createBaseVNode("div", _hoisted_4$6, [
          promptText.value ? (vue.openBlock(), vue.createElementBlock("span", {
            key: 0,
            class: "ai-textarea-icon ai-submit-button",
            onClick: vue.withModifiers(handleSubmit, ["stop"]),
            innerHTML: vue.unref(paperPlane)
          }, null, 8, _hoisted_5$4)) : vue.createCommentVNode("", true)
        ])
      ], 544);
    };
  }
};
const AIWriter = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["__scopeId", "data-v-5bf16391"]]);
const boldIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M0 64C0 46.3 14.3 32 32 32l48 0 16 0 128 0c70.7 0 128 57.3 128 128c0 31.3-11.3 60.1-30 82.3c37.1 22.4 62 63.1 62 109.7c0 70.7-57.3 128-128 128L96 480l-16 0-48 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l16 0 0-160L48 96 32 96C14.3 96 0 81.7 0 64zM224 224c35.3 0 64-28.7 64-64s-28.7-64-64-64L112 96l0 128 112 0zM112 288l0 128 144 0c35.3 0 64-28.7 64-64s-28.7-64-64-64l-32 0-112 0z"/></svg>';
const italicIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M128 64c0-17.7 14.3-32 32-32l192 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-58.7 0L160 416l64 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32s14.3-32 32-32l58.7 0L224 96l-64 0c-17.7 0-32-14.3-32-32z"/></svg>';
const underlineIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M16 64c0-17.7 14.3-32 32-32l96 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-16 0 0 128c0 53 43 96 96 96s96-43 96-96l0-128-16 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l96 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-16 0 0 128c0 88.4-71.6 160-160 160s-160-71.6-160-160L64 96 48 96C30.3 96 16 81.7 16 64zM0 448c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32z"/></svg>';
const listIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M40 48C26.7 48 16 58.7 16 72l0 48c0 13.3 10.7 24 24 24l48 0c13.3 0 24-10.7 24-24l0-48c0-13.3-10.7-24-24-24L40 48zM192 64c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L192 64zm0 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-288 0zm0 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-288 0zM16 232l0 48c0 13.3 10.7 24 24 24l48 0c13.3 0 24-10.7 24-24l0-48c0-13.3-10.7-24-24-24l-48 0c-13.3 0-24 10.7-24 24zM40 368c-13.3 0-24 10.7-24 24l0 48c0 13.3 10.7 24 24 24l48 0c13.3 0 24-10.7 24-24l0-48c0-13.3-10.7-24-24-24l-48 0z"/></svg>';
const listOlIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M24 56c0-13.3 10.7-24 24-24l32 0c13.3 0 24 10.7 24 24l0 120 16 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-80 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l16 0 0-96-8 0C34.7 80 24 69.3 24 56zM86.7 341.2c-6.5-7.4-18.3-6.9-24 1.2L51.5 357.9c-7.7 10.8-22.7 13.3-33.5 5.6s-13.3-22.7-5.6-33.5l11.1-15.6c23.7-33.2 72.3-35.6 99.2-4.9c21.3 24.4 20.8 60.9-1.1 84.7L86.8 432l33.2 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-88 0c-9.5 0-18.2-5.6-22-14.4s-2.1-18.9 4.3-25.9l72-78c5.3-5.8 5.4-14.6 .3-20.5zM224 64l256 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-256 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zm0 160l256 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-256 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zm0 160l256 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-256 0c-17.7 0-32-14.3-32-32s14.3-32 32-32z"/></svg>';
const imageIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M0 96C0 60.7 28.7 32 64 32l384 0c35.3 0 64 28.7 64 64l0 320c0 35.3-28.7 64-64 64L64 480c-35.3 0-64-28.7-64-64L0 96zM323.8 202.5c-4.5-6.6-11.9-10.5-19.8-10.5s-15.4 3.9-19.8 10.5l-87 127.6L170.7 297c-4.6-5.7-11.5-9-18.7-9s-14.2 3.3-18.7 9l-64 80c-5.8 7.2-6.9 17.1-2.9 25.4s12.4 13.6 21.6 13.6l96 0 32 0 208 0c8.9 0 17.1-4.9 21.2-12.8s3.6-17.4-1.4-24.7l-120-176zM112 192a48 48 0 1 0 0-96 48 48 0 1 0 0 96z"/></svg>';
const linkIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z"/></svg>';
const alignLeftIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M288 64c0 17.7-14.3 32-32 32L32 96C14.3 96 0 81.7 0 64S14.3 32 32 32l224 0c17.7 0 32 14.3 32 32zm0 256c0 17.7-14.3 32-32 32L32 352c-17.7 0-32-14.3-32-32s14.3-32 32-32l224 0c17.7 0 32 14.3 32 32zM0 192c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 224c-17.7 0-32-14.3-32-32zM448 448c0 17.7-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"/></svg>';
const alignCenterIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M352 64c0-17.7-14.3-32-32-32L128 32c-17.7 0-32 14.3-32 32s14.3 32 32 32l192 0c17.7 0 32-14.3 32-32zm96 128c0-17.7-14.3-32-32-32L32 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l384 0c17.7 0 32-14.3 32-32zM0 448c0 17.7 14.3 32 32 32l384 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 416c-17.7 0-32 14.3-32 32zM352 320c0-17.7-14.3-32-32-32l-192 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l192 0c17.7 0 32-14.3 32-32z"/></svg>';
const alignRightIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M448 64c0 17.7-14.3 32-32 32L192 96c-17.7 0-32-14.3-32-32s14.3-32 32-32l224 0c17.7 0 32 14.3 32 32zm0 256c0 17.7-14.3 32-32 32l-224 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l224 0c17.7 0 32 14.3 32 32zM0 192c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 224c-17.7 0-32-14.3-32-32zM448 448c0 17.7-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"/></svg>';
const alignJustifyIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M448 64c0-17.7-14.3-32-32-32L32 32C14.3 32 0 46.3 0 64S14.3 96 32 96l384 0c17.7 0 32-14.3 32-32zm0 256c0-17.7-14.3-32-32-32L32 288c-17.7 0-32 14.3-32 32s14.3 32 32 32l384 0c17.7 0 32-14.3 32-32zM0 192c0 17.7 14.3 32 32 32l384 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 160c-17.7 0-32 14.3-32 32zM448 448c0-17.7-14.3-32-32-32L32 416c-17.7 0-32 14.3-32 32s14.3 32 32 32l384 0c17.7 0 32-14.3 32-32z"/></svg>';
const indentIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M0 64C0 46.3 14.3 32 32 32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 96C14.3 96 0 81.7 0 64zM192 192c0-17.7 14.3-32 32-32l192 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-192 0c-17.7 0-32-14.3-32-32zm32 96l192 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-192 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zM0 448c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32zM127.8 268.6L25.8 347.9C15.3 356.1 0 348.6 0 335.3L0 176.7c0-13.3 15.3-20.8 25.8-12.6l101.9 79.3c8.2 6.4 8.2 18.9 0 25.3z"/></svg>';
const outdentIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M0 64C0 46.3 14.3 32 32 32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 96C14.3 96 0 81.7 0 64zM192 192c0-17.7 14.3-32 32-32l192 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-192 0c-17.7 0-32-14.3-32-32zm32 96l192 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-192 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zM0 448c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32zM.2 268.6c-8.2-6.4-8.2-18.9 0-25.3l101.9-79.3c10.5-8.2 25.8-.7 25.8 12.6l0 158.6c0 13.3-15.3 20.8-25.8 12.6L.2 268.6z"/></svg>';
const paintRollerIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M0 64C0 28.7 28.7 0 64 0L352 0c35.3 0 64 28.7 64 64l0 64c0 35.3-28.7 64-64 64L64 192c-35.3 0-64-28.7-64-64L0 64zM160 352c0-17.7 14.3-32 32-32l0-16c0-44.2 35.8-80 80-80l144 0c17.7 0 32-14.3 32-32l0-32 0-90.5c37.3 13.2 64 48.7 64 90.5l0 32c0 53-43 96-96 96l-144 0c-8.8 0-16 7.2-16 16l0 16c17.7 0 32 14.3 32 32l0 128c0 17.7-14.3 32-32 32l-64 0c-17.7 0-32-14.3-32-32l0-128z"/></svg>';
const textSlashIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L355.7 253.5 400.2 96 503 96 497 120.2c-4.3 17.1 6.1 34.5 23.3 38.8s34.5-6.1 38.8-23.3l11-44.1C577.6 61.3 554.7 32 523.5 32L376.1 32l-.3 0L204.5 32c-22 0-41.2 15-46.6 36.4l-6.3 25.2L38.8 5.1zm168 131.7c.1-.3 .2-.7 .3-1L217 96l116.7 0L301.3 210.8l-94.5-74.1zM243.3 416L192 416c-17.7 0-32 14.3-32 32s14.3 32 32 32l160 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-42.2 0 17.6-62.1L272.9 311 243.3 416z"/></svg>';
const rotateLeftIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M48.5 224L40 224c-13.3 0-24-10.7-24-24L16 72c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2L98.6 96.6c87.6-86.5 228.7-86.2 315.8 1c87.5 87.5 87.5 229.3 0 316.8s-229.3 87.5-316.8 0c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0c62.5 62.5 163.8 62.5 226.3 0s62.5-163.8 0-226.3c-62.2-62.2-162.7-62.5-225.3-1L185 183c6.9 6.9 8.9 17.2 5.2 26.2s-12.5 14.8-22.2 14.8L48.5 224z"/></svg>';
const rotateRightIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M463.5 224l8.5 0c13.3 0 24-10.7 24-24l0-128c0-9.7-5.8-18.5-14.8-22.2s-19.3-1.7-26.2 5.2L413.4 96.6c-87.6-86.5-228.7-86.2-315.8 1c-87.5 87.5-87.5 229.3 0 316.8s229.3 87.5 316.8 0c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0c-62.5 62.5-163.8 62.5-226.3 0s-62.5-163.8 0-226.3c62.2-62.2 162.7-62.5 225.3-1L327 183c-6.9 6.9-8.9 17.2-5.2 26.2s12.5 14.8 22.2 14.8l119.5 0z"/></svg>';
const calendarCheckIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M128 0c17.7 0 32 14.3 32 32l0 32 128 0 0-32c0-17.7 14.3-32 32-32s32 14.3 32 32l0 32 48 0c26.5 0 48 21.5 48 48l0 48L0 160l0-48C0 85.5 21.5 64 48 64l48 0 0-32c0-17.7 14.3-32 32-32zM0 192l448 0 0 272c0 26.5-21.5 48-48 48L48 512c-26.5 0-48-21.5-48-48L0 192zM329 305c9.4-9.4 9.4-24.6 0-33.9s-24.6-9.4-33.9 0l-95 95-47-47c-9.4-9.4-24.6-9.4-33.9 0s-9.4 24.6 0 33.9l64 64c9.4 9.4 24.6 9.4 33.9 0L329 305z"/></svg>';
const calendarXmarkIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M128 0c17.7 0 32 14.3 32 32l0 32 128 0 0-32c0-17.7 14.3-32 32-32s32 14.3 32 32l0 32 48 0c26.5 0 48 21.5 48 48l0 48L0 160l0-48C0 85.5 21.5 64 48 64l48 0 0-32c0-17.7 14.3-32 32-32zM0 192l448 0 0 272c0 26.5-21.5 48-48 48L48 512c-26.5 0-48-21.5-48-48L0 192zM305 305c9.4-9.4 9.4-24.6 0-33.9s-24.6-9.4-33.9 0l-47 47-47-47c-9.4-9.4-24.6-9.4-33.9 0s-9.4 24.6 0 33.9l47 47-47 47c-9.4 9.4-9.4 24.6 0 33.9s24.6 9.4 33.9 0l47-47 47 47c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-47-47 47-47z"/></svg>';
const listCheckIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M152.1 38.2c9.9 8.9 10.7 24 1.8 33.9l-72 80c-4.4 4.9-10.6 7.8-17.2 7.9s-12.9-2.4-17.6-7L7 113C-2.3 103.6-2.3 88.4 7 79s24.6-9.4 33.9 0l22.1 22.1 55.1-61.2c8.9-9.9 24-10.7 33.9-1.8zm0 160c9.9 8.9 10.7 24 1.8 33.9l-72 80c-4.4 4.9-10.6 7.8-17.2 7.9s-12.9-2.4-17.6-7L7 273c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l22.1 22.1 55.1-61.2c8.9-9.9 24-10.7 33.9-1.8zM224 96c0-17.7 14.3-32 32-32l224 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-224 0c-17.7 0-32-14.3-32-32zm0 160c0-17.7 14.3-32 32-32l224 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-224 0c-17.7 0-32-14.3-32-32zM160 416c0-17.7 14.3-32 32-32l288 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-288 0c-17.7 0-32-14.3-32-32zM48 368a48 48 0 1 1 0 96 48 48 0 1 1 0-96z"/></svg>';
const userEditIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M224 256A128 128 0 1 0 224 0a128 128 0 1 0 0 256zm-45.7 48C79.8 304 0 383.8 0 482.3C0 498.7 13.3 512 29.7 512l293.1 0c-3.1-8.8-3.7-18.4-1.4-27.8l15-60.1c2.8-11.3 8.6-21.5 16.8-29.7l40.3-40.3c-32.1-31-75.7-50.1-123.9-50.1l-91.4 0zm435.5-68.3c-15.6-15.6-40.9-15.6-56.6 0l-29.4 29.4 71 71 29.4-29.4c15.6-15.6 15.6-40.9 0-56.6l-14.4-14.4zM375.9 417c-4.1 4.1-7 9.2-8.4 14.9l-15 60.1c-1.4 5.5 .2 11.2 4.2 15.2s9.7 5.6 15.2 4.2l60.1-15c5.6-1.4 10.8-4.3 14.9-8.4L576.1 358.7l-71-71L375.9 417z"/></svg>';
const eyeIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM144 256a144 144 0 1 1 288 0 144 144 0 1 1 -288 0zm144-64c0 35.3-28.7 64-64 64c-7.1 0-13.9-1.2-20.3-3.3c-5.5-1.8-11.9 1.6-11.7 7.4c.3 6.9 1.3 13.8 3.2 20.7c13.7 51.2 66.4 81.6 117.6 67.9s81.6-66.4 67.9-117.6c-11.1-41.5-47.8-69.4-88.6-71.1c-5.8-.2-9.2 6.1-7.4 11.7c2.1 6.4 3.3 13.2 3.3 20.3z"/></svg>';
const fileIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M0 64C0 28.7 28.7 0 64 0L224 0l0 128c0 17.7 14.3 32 32 32l128 0 0 288c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 64zm384 64l-128 0L256 0 384 128z"/></svg>';
const fontIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M254 52.8C249.3 40.3 237.3 32 224 32s-25.3 8.3-30 20.8L57.8 416 32 416c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-1.8 0 18-48 159.6 0 18 48-1.8 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-25.8 0L254 52.8zM279.8 304l-111.6 0L224 155.1 279.8 304z"/></svg>';
const fileHalfDashedIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M64 0C28.7 0 0 28.7 0 64L0 320l384 0 0-160-128 0c-17.7 0-32-14.3-32-32L224 0 64 0zM256 0l0 128 128 0L256 0zM0 416l64 0 0-64L0 352l0 64zm288 32l-80 0 0 64 80 0 0-64zm-112 0l-80 0 0 64 80 0 0-64zM64 448L0 448c0 35.3 28.7 64 64 64l0-64zm256 0l0 64c35.3 0 64-28.7 64-64l-64 0zm64-32l0-64-64 0 0 64 64 0z"/></svg>';
const commentIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M512 240c0 114.9-114.6 208-256 208c-37.1 0-72.3-6.4-104.1-17.9c-11.9 8.7-31.3 20.6-54.3 30.6C73.6 471.1 44.7 480 16 480c-6.5 0-12.3-3.9-14.8-9.9c-2.5-6-1.1-12.8 3.4-17.4c0 0 0 0 0 0s0 0 0 0s0 0 0 0c0 0 0 0 0 0l.3-.3c.3-.3 .7-.7 1.3-1.4c1.1-1.2 2.8-3.1 4.9-5.7c4.1-5 9.6-12.4 15.2-21.6c10-16.6 19.5-38.4 21.4-62.9C17.7 326.8 0 285.1 0 240C0 125.1 114.6 32 256 32s256 93.1 256 208z"/></svg>';
const circleIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"/></svg>';
const checkIconSvg$1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M438.6 105.4c12.5 12.5 12.5 32.8 0 45.3l-256 256c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 338.7 393.4 105.4c12.5-12.5 32.8-12.5 45.3 0z"/></svg>';
const xmarkIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"/></svg>';
const upRightFromSquareIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M352 0c-12.9 0-24.6 7.8-29.6 19.8s-2.2 25.7 6.9 34.9L370.7 96 201.4 265.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L416 141.3l41.4 41.4c9.2 9.2 22.9 11.9 34.9 6.9s19.8-16.6 19.8-29.6l0-128c0-17.7-14.3-32-32-32L352 0zM80 32C35.8 32 0 67.8 0 112L0 432c0 44.2 35.8 80 80 80l320 0c44.2 0 80-35.8 80-80l0-112c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 112c0 8.8-7.2 16-16 16L80 448c-8.8 0-16-7.2-16-16l0-320c0-8.8 7.2-16 16-16l112 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L80 32z"/></svg>';
const ellipsisVerticalSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M64 360a56 56 0 1 0 0 112 56 56 0 1 0 0-112zm0-160a56 56 0 1 0 0 112 56 56 0 1 0 0-112zM120 96A56 56 0 1 0 8 96a56 56 0 1 0 112 0z"/></svg>';
const caretUpIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M182.6 137.4c-12.5-12.5-32.8-12.5-45.3 0l-128 128c-9.2 9.2-11.9 22.9-6.9 34.9s16.6 19.8 29.6 19.8l256 0c12.9 0 24.6-7.8 29.6-19.8s2.2-25.7-6.9-34.9l-128-128z"/></svg>';
const caretDownIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M137.4 374.6c12.5 12.5 32.8 12.5 45.3 0l128-128c9.2-9.2 11.9-22.9 6.9-34.9s-16.6-19.8-29.6-19.8L32 192c-12.9 0-24.6 7.8-29.6 19.8s-2.2 25.7 6.9 34.9l128 128z"/></svg>';
const rulerSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M177.9 494.1c-18.7 18.7-49.1 18.7-67.9 0L17.9 401.9c-18.7-18.7-18.7-49.1 0-67.9l50.7-50.7 48 48c6.2 6.2 16.4 6.2 22.6 0s6.2-16.4 0-22.6l-48-48 41.4-41.4 48 48c6.2 6.2 16.4 6.2 22.6 0s6.2-16.4 0-22.6l-48-48 41.4-41.4 48 48c6.2 6.2 16.4 6.2 22.6 0s6.2-16.4 0-22.6l-48-48 41.4-41.4 48 48c6.2 6.2 16.4 6.2 22.6 0s6.2-16.4 0-22.6l-48-48 50.7-50.7c18.7-18.7 49.1-18.7 67.9 0l92.1 92.1c18.7 18.7 18.7 49.1 0 67.9L177.9 494.1z"/></svg>';
const paintbrushSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M339.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L568.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S517.7-4.4 499.1 9.6L262.4 187.2c-24 18-38.2 46.1-38.4 76.1L339.3 367.1zm-19.6 25.4l-116-104.4C143.9 290.3 96 339.6 96 400c0 3.9 .2 7.8 .6 11.6C98.4 429.1 86.4 448 68.8 448L64 448c-17.7 0-32 14.3-32 32s14.3 32 32 32l144 0c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg>';
const highlighterIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M315 315l158.4-215L444.1 70.6 229 229 315 315zm-187 5s0 0 0 0l0-71.7c0-15.3 7.2-29.6 19.5-38.6L420.6 8.4C428 2.9 437 0 446.2 0c11.4 0 22.4 4.5 30.5 12.6l54.8 54.8c8.1 8.1 12.6 19 12.6 30.5c0 9.2-2.9 18.2-8.4 25.6L334.4 396.5c-9 12.3-23.4 19.5-38.6 19.5L224 416l-25.4 25.4c-12.5 12.5-32.8 12.5-45.3 0l-50.7-50.7c-12.5-12.5-12.5-32.8 0-45.3L128 320zM7 466.3l63-63 70.6 70.6-31 31c-4.5 4.5-10.6 7-17 7L24 512c-13.3 0-24-10.7-24-24l0-4.7c0-6.4 2.5-12.5 7-17z"/></svg>\n';
const magicWandIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M224 96l16-32 32-16-32-16-16-32-16 32-32 16 32 16 16 32zM80 160l26.7-53.3L160 80l-53.3-26.7L80 0 53.3 53.3 0 80l53.3 26.7L80 160zm352 128l-26.7 53.3L352 368l53.3 26.7L432 448l26.7-53.3L512 368l-53.3-26.7L432 288zm70.6-193.8L417.8 9.4C411.5 3.1 403.3 0 395.2 0c-8.2 0-16.4 3.1-22.6 9.4L9.4 372.5c-12.5 12.5-12.5 32.8 0 45.3l84.9 84.9c6.3 6.3 14.4 9.4 22.6 9.4 8.2 0 16.4-3.1 22.6-9.4l363.1-363.2c12.5-12.5 12.5-32.8 0-45.2zM359.5 203.5l-50.9-50.9 86.6-86.6 50.9 50.9-86.6 86.6z"/></svg>';
const tableIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M64 256l0-96 160 0 0 96L64 256zm0 64l160 0 0 96L64 416l0-96zm224 96l0-96 160 0 0 96-160 0zM448 256l-160 0 0-96 160 0 0 96zM64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l384 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32z"/></svg>';
const tableColumnsIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M0 96C0 60.7 28.7 32 64 32l384 0c35.3 0 64 28.7 64 64l0 320c0 35.3-28.7 64-64 64L64 480c-35.3 0-64-28.7-64-64L0 96zm64 64l0 256 160 0 0-256L64 160zm384 0l-160 0 0 256 160 0 0-256z"/></svg>';
const arrowsLeftRightIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M406.6 374.6l96-96c12.5-12.5 12.5-32.8 0-45.3l-96-96c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L402.7 224l-293.5 0 41.4-41.4c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-96 96c-12.5 12.5-12.5 32.8 0 45.3l96 96c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 288l293.5 0-41.4 41.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0z"/></svg>';
const arrowsToDotIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M256 0c17.7 0 32 14.3 32 32l0 32 32 0c12.9 0 24.6 7.8 29.6 19.8s2.2 25.7-6.9 34.9l-64 64c-12.5 12.5-32.8 12.5-45.3 0l-64-64c-9.2-9.2-11.9-22.9-6.9-34.9s16.6-19.8 29.6-19.8l32 0 0-32c0-17.7 14.3-32 32-32zM169.4 393.4l64-64c12.5-12.5 32.8-12.5 45.3 0l64 64c9.2 9.2 11.9 22.9 6.9 34.9s-16.6 19.8-29.6 19.8l-32 0 0 32c0 17.7-14.3 32-32 32s-32-14.3-32-32l0-32-32 0c-12.9 0-24.6-7.8-29.6-19.8s-2.2-25.7 6.9-34.9zM32 224l32 0 0-32c0-12.9 7.8-24.6 19.8-29.6s25.7-2.2 34.9 6.9l64 64c12.5 12.5 12.5 32.8 0 45.3l-64 64c-9.2 9.2-22.9 11.9-34.9 6.9s-19.8-16.6-19.8-29.6l0-32-32 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zm297.4 54.6c-12.5-12.5-12.5-32.8 0-45.3l64-64c9.2-9.2 22.9-11.9 34.9-6.9s19.8 16.6 19.8 29.6l0 32 32 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-32 0 0 32c0 12.9-7.8 24.6-19.8 29.6s-25.7 2.2-34.9-6.9l-64-64zM256 224a32 32 0 1 1 0 64 32 32 0 1 1 0-64z"/></svg>';
const plusIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M256 80c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 144L48 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l144 0 0 144c0 17.7 14.3 32 32 32s32-14.3 32-32l0-144 144 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-144 0 0-144z"/></svg>';
const trashIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M135.2 17.7C140.6 6.8 151.7 0 163.8 0L284.2 0c12.1 0 23.2 6.8 28.6 17.7L320 32l96 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 96C14.3 96 0 81.7 0 64S14.3 32 32 32l96 0 7.2-14.3zM32 128l384 0 0 320c0 35.3-28.7 64-64 64L96 512c-35.3 0-64-28.7-64-64l0-320zm96 64c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16zm96 0c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16zm96 0c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16z"/></svg>';
const wrenchIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M352 320c88.4 0 160-71.6 160-160c0-15.3-2.2-30.1-6.2-44.2c-3.1-10.8-16.4-13.2-24.3-5.3l-76.8 76.8c-3 3-7.1 4.7-11.3 4.7L336 192c-8.8 0-16-7.2-16-16l0-57.4c0-4.2 1.7-8.3 4.7-11.3l76.8-76.8c7.9-7.9 5.4-21.2-5.3-24.3C382.1 2.2 367.3 0 352 0C263.6 0 192 71.6 192 160c0 19.1 3.4 37.5 9.5 54.5L19.9 396.1C7.2 408.8 0 426.1 0 444.1C0 481.6 30.4 512 67.9 512c18 0 35.3-7.2 48-19.9L297.5 310.5c17 6.2 35.4 9.5 54.5 9.5zM80 408a24 24 0 1 1 0 48 24 24 0 1 1 0-48z"/></svg>';
const borderNoneIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M32 480a32 32 0 1 1 0-64 32 32 0 1 1 0 64zm96-64a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm0-384a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm0 256a32 32 0 1 1 0-64 32 32 0 1 1 0 64zM320 416a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm0-320a32 32 0 1 1 0-64 32 32 0 1 1 0 64zm0 128a32 32 0 1 1 0 64 32 32 0 1 1 0-64zM224 480a32 32 0 1 1 0-64 32 32 0 1 1 0 64zm0-448a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm0 256a32 32 0 1 1 0-64 32 32 0 1 1 0 64zM416 416a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm0-384a32 32 0 1 1 0 64 32 32 0 1 1 0-64zM32 96a32 32 0 1 1 0-64 32 32 0 1 1 0 64zM416 224a32 32 0 1 1 0 64 32 32 0 1 1 0-64zM32 288a32 32 0 1 1 0-64 32 32 0 1 1 0 64zm192 32a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm192 64a32 32 0 1 1 0-64 32 32 0 1 1 0 64zM32 320a32 32 0 1 1 0 64 32 32 0 1 1 0-64zM416 192a32 32 0 1 1 0-64 32 32 0 1 1 0 64zM32 128a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm192 64a32 32 0 1 1 0-64 32 32 0 1 1 0 64z"/></svg>';
const upDownIconSvg = '<svg xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" viewBox="3 4 18 16"><path stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 10V5m0 0L4 7m2-2 2 2m-2 7v5m0 0 2-2m-2 2-2-2m8-10h8m0 5h-8m0 5h8"></path></svg>\n';
const magnifyingGlassSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"/></svg>\n';
const scissorsIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M278.1 256L444.5 89.6c4.7-4.7 4.7-12.3 0-17-32.8-32.8-86-32.8-118.8 0L210.2 188.1l-24.9-24.9c4.3-10.9 6.7-22.8 6.7-35.3 0-53-43-96-96-96S0 75 0 128s43 96 96 96c4.5 0 9-.3 13.4-.9L142.3 256l-32.9 32.9c-4.4-.6-8.8-.9-13.4-.9-53 0-96 43-96 96s43 96 96 96 96-43 96-96c0-12.5-2.4-24.3-6.7-35.3l24.9-24.9L325.7 439.4c32.8 32.8 86 32.8 118.8 0 4.7-4.7 4.7-12.3 0-17L278.1 256zM96 160c-17.6 0-32-14.4-32-32s14.4-32 32-32 32 14.4 32 32-14.4 32-32 32zm0 256c-17.6 0-32-14.4-32-32s14.4-32 32-32 32 14.4 32 32-14.4 32-32 32z"/></svg>';
const copyIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M320 448v40c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V120c0-13.3 10.7-24 24-24h72v296c0 30.9 25.1 56 56 56h168zm0-344V0H152c-13.3 0-24 10.7-24 24v368c0 13.3 10.7 24 24 24h272c13.3 0 24-10.7 24-24V128H344c-13.2 0-24-10.8-24-24zm121-31L375 7A24 24 0 0 0 358.1 0H352v96h96v-6.1a24 24 0 0 0 -7-17z"/></svg>';
const pasteIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M128 184c0-30.9 25.1-56 56-56h136V56c0-13.3-10.7-24-24-24h-80.6C204.3 12.9 183.6 0 160 0s-44.3 12.9-55.4 32H24C10.7 32 0 42.7 0 56v336c0 13.3 10.7 24 24 24h104V184zm32-144c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm184 248h104v200c0 13.3-10.7 24-24 24H184c-13.3 0-24-10.7-24-24V184c0-13.3 10.7-24 24-24h136v104c0 13.2 10.8 24 24 24zm104-38.1V256h-96v-96h6.1a24 24 0 0 1 17 7l65.9 65.9a24 24 0 0 1 7 17z"/></svg>';
const strikethroughSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M161.3 144c3.2-17.2 14-30.1 33.7-38.6c21.1-9 51.8-12.3 88.6-6.5c11.9 1.9 48.8 9.1 60.1 12c17.1 4.5 34.6-5.6 39.2-22.7s-5.6-34.6-22.7-39.2c-14.3-3.8-53.6-11.4-66.6-13.4c-44.7-7-88.3-4.2-123.7 10.9c-36.5 15.6-64.4 44.8-71.8 87.3c-.1 .6-.2 1.1-.2 1.7c-2.8 23.9 .5 45.6 10.1 64.6c4.5 9 10.2 16.9 16.7 23.9L32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l448 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-209.9 0-.4-.1-1.1-.3c-36-10.8-65.2-19.6-85.2-33.1c-9.3-6.3-15-12.6-18.2-19.1c-3.1-6.1-5.2-14.6-3.8-27.4zM348.9 337.2c2.7 6.5 4.4 15.8 1.9 30.1c-3 17.6-13.8 30.8-33.9 39.4c-21.1 9-51.7 12.3-88.5 6.5c-18-2.9-49.1-13.5-74.4-22.1c-5.6-1.9-11-3.7-15.9-5.4c-16.8-5.6-34.9 3.5-40.5 20.3s3.5 34.9 20.3 40.5c3.6 1.2 7.9 2.7 12.7 4.3c0 0 0 0 0 0s0 0 0 0c24.9 8.5 63.6 21.7 87.6 25.6c0 0 0 0 0 0l.2 0c44.7 7 88.3 4.2 123.7-10.9c36.5-15.6 64.4-44.8 71.8-87.3c3.6-21 2.7-40.4-3.1-58.1l-75.7 0c7 5.6 11.4 11.2 13.9 17.2z"/></svg>\n';
const toolbarIcons = {
  undo: rotateLeftIconSvg,
  redo: rotateRightIconSvg,
  bold: boldIconSvg,
  italic: italicIconSvg,
  underline: underlineIconSvg,
  color: fontIconSvg,
  link: linkIconSvg,
  image: imageIconSvg,
  alignLeft: alignLeftIconSvg,
  alignRight: alignRightIconSvg,
  alignCenter: alignCenterIconSvg,
  alignJustify: alignJustifyIconSvg,
  bulletList: listIconSvg,
  numberedList: listOlIconSvg,
  indentLeft: outdentIconSvg,
  indentRight: indentIconSvg,
  pageBreak: fileHalfDashedIconSvg,
  copyFormat: paintRollerIconSvg,
  clearFormatting: textSlashIconSvg,
  trackChanges: listCheckIconSvg,
  trackChangesFinal: fileIconSvg,
  trackChangesOriginal: eyeIconSvg,
  trackChangesAccept: calendarCheckIconSvg,
  trackChangesReject: calendarXmarkIconSvg,
  documentMode: userEditIconSvg,
  documentEditingMode: userEditIconSvg,
  documentSuggestingMode: commentIconSvg,
  documentViewingMode: eyeIconSvg,
  colorOption: circleIconSvg,
  colorOptionCheck: checkIconSvg$1,
  linkInput: linkIconSvg,
  removeLink: xmarkIconSvg,
  openLink: upRightFromSquareIconSvg,
  overflow: ellipsisVerticalSvg,
  dropdownCaretUp: caretUpIconSvg,
  dropdownCaretDown: caretDownIconSvg,
  ruler: rulerSvg,
  paintbrush: paintbrushSvg,
  highlight: highlighterIcon,
  ai: magicWandIcon,
  table: tableIconSvg,
  tableActions: tableColumnsIconSvg,
  splitCell: arrowsLeftRightIconSvg,
  mergeCells: arrowsToDotIconSvg,
  addRowBefore: plusIconSvg,
  addRowAfter: plusIconSvg,
  addColumnBefore: plusIconSvg,
  addColumnAfter: plusIconSvg,
  deleteRow: trashIconSvg,
  deleteColumn: trashIconSvg,
  deleteTable: trashIconSvg,
  deleteBorders: borderNoneIconSvg,
  fixTables: wrenchIconSvg,
  lineHeight: upDownIconSvg,
  search: magnifyingGlassSvg,
  cut: scissorsIconSvg,
  copy: copyIconSvg,
  paste: pasteIconSvg,
  strikethrough: strikethroughSvg
};
const _hoisted_1$j = ["onClick", "innerHTML", "aria-label", "onKeydown"];
const _sfc_main$m = {
  __name: "AlignmentButtons",
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const { isHighContrastMode: isHighContrastMode2 } = useHighContrastMode();
    const emit = __emit;
    const alignmentButtonsRefs = vue.ref([]);
    const alignmentButtons = [
      {
        key: "left",
        ariaLabel: "Align left",
        icon: toolbarIcons.alignLeft
      },
      {
        key: "center",
        ariaLabel: "Align center",
        icon: toolbarIcons.alignCenter
      },
      {
        key: "right",
        ariaLabel: "Align right",
        icon: toolbarIcons.alignRight
      },
      {
        key: "justify",
        ariaLabel: "Justify",
        icon: toolbarIcons.alignJustify
      }
    ];
    const select = (alignment2) => {
      emit("select", alignment2);
    };
    const moveToNextButton = (index2) => {
      if (index2 === alignmentButtonsRefs.value.length - 1) return;
      const nextButton = alignmentButtonsRefs.value[index2 + 1];
      if (nextButton) {
        nextButton.setAttribute("tabindex", "0");
        nextButton.focus();
      }
    };
    const moveToPreviousButton = (index2) => {
      if (index2 === 0) return;
      const previousButton = alignmentButtonsRefs.value[index2 - 1];
      if (previousButton) {
        previousButton.setAttribute("tabindex", "0");
        previousButton.focus();
      }
    };
    const handleKeyDown2 = (e, index2) => {
      switch (e.key) {
        case "ArrowLeft":
          moveToPreviousButton(index2);
          break;
        case "ArrowRight":
          moveToNextButton(index2);
          break;
        case "Enter":
          select(alignmentButtons[index2].key);
          break;
      }
    };
    vue.onMounted(() => {
      const firstButton = alignmentButtonsRefs.value[0];
      if (firstButton) {
        firstButton.setAttribute("tabindex", "0");
        firstButton.focus();
      }
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: vue.normalizeClass(["alignment-buttons", { "high-contrast": vue.unref(isHighContrastMode2) }])
      }, [
        (vue.openBlock(), vue.createElementBlock(vue.Fragment, null, vue.renderList(alignmentButtons, (button, index2) => {
          return vue.createBaseVNode("div", {
            key: button.key,
            class: "button-icon",
            onClick: ($event) => select(button.key),
            innerHTML: button.icon,
            "data-item": "btn-textAlign-option",
            role: "menuitem",
            "aria-label": button.ariaLabel,
            ref_for: true,
            ref_key: "alignmentButtonsRefs",
            ref: alignmentButtonsRefs,
            onKeydown: vue.withModifiers((event) => handleKeyDown2(event, index2), ["prevent"])
          }, null, 40, _hoisted_1$j);
        }), 64))
      ], 2);
    };
  }
};
const AlignmentButtons = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["__scopeId", "data-v-b4162baa"]]);
const _hoisted_1$i = ["onClick", "onKeydown"];
const _hoisted_2$d = { class: "document-mode-column icon-column" };
const _hoisted_3$9 = ["innerHTML"];
const _hoisted_4$5 = { class: "document-mode-column text-column" };
const _hoisted_5$3 = { class: "document-mode-type" };
const _hoisted_6$2 = { class: "document-mode-description" };
const _sfc_main$l = {
  __name: "DocumentMode",
  props: {
    options: {
      type: Array
    }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const documentModeRefs = vue.ref([]);
    const { isHighContrastMode: isHighContrastMode2 } = useHighContrastMode();
    const props = __props;
    const handleClick2 = (item) => {
      emit("select", item);
    };
    const moveToNextOption = (index2) => {
      if (index2 === documentModeRefs.value.length - 1) return;
      const nextOption = documentModeRefs.value[index2 + 1];
      if (nextOption) {
        nextOption.setAttribute("tabindex", "0");
        nextOption.focus();
      }
    };
    const moveToPreviousOption = (index2) => {
      if (index2 === 0) return;
      const previousOption = documentModeRefs.value[index2 - 1];
      if (previousOption) {
        previousOption.setAttribute("tabindex", "0");
        previousOption.focus();
      }
    };
    const handleKeyDown2 = (e, index2) => {
      switch (e.key) {
        case "ArrowDown":
          moveToNextOption(index2);
          break;
        case "ArrowUp":
          moveToPreviousOption(index2);
          break;
        case "Enter":
          handleClick2(props.options[index2]);
          break;
      }
    };
    vue.onMounted(() => {
      documentModeRefs.value[0].setAttribute("tabindex", "0");
      documentModeRefs.value[0].focus();
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: vue.normalizeClass(["document-mode", { "high-contrast": vue.unref(isHighContrastMode2) }])
      }, [
        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.options, (option, index2) => {
          return vue.openBlock(), vue.createElementBlock("div", {
            class: vue.normalizeClass(["option-item", { disabled: option.disabled }]),
            onClick: ($event) => handleClick2(option),
            "data-item": "btn-documentMode-option",
            role: "menuitem",
            ref_for: true,
            ref_key: "documentModeRefs",
            ref: documentModeRefs,
            onKeydown: vue.withModifiers((event) => handleKeyDown2(event, index2), ["prevent"])
          }, [
            vue.createBaseVNode("div", _hoisted_2$d, [
              vue.createBaseVNode("div", {
                class: "icon-column__icon",
                innerHTML: option.icon
              }, null, 8, _hoisted_3$9)
            ]),
            vue.createBaseVNode("div", _hoisted_4$5, [
              vue.createBaseVNode("div", _hoisted_5$3, vue.toDisplayString(option.label), 1),
              vue.createBaseVNode("div", _hoisted_6$2, vue.toDisplayString(option.description), 1)
            ])
          ], 42, _hoisted_1$i);
        }), 256))
      ], 2);
    };
  }
};
const DocumentMode = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["__scopeId", "data-v-6e1ad9c8"]]);
const _hoisted_1$h = {
  key: 0,
  class: "linked-style-buttons",
  "data-editor-ui-surface": ""
};
const _hoisted_2$c = ["onClick", "onKeydown", "aria-label"];
const _sfc_main$k = {
  __name: "LinkedStyle",
  props: {
    editor: {
      type: Object,
      required: true
    },
    selectedOption: {
      type: String
    }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const styleRefs = vue.ref([]);
    const props = __props;
    const select = (style2) => {
      emit("select", style2);
    };
    const moveToNextStyle = (index2) => {
      if (index2 === styleRefs.value.length - 1) {
        return;
      }
      const nextItem = styleRefs.value[index2 + 1];
      nextItem.setAttribute("tabindex", "0");
      nextItem.focus();
    };
    const moveToPreviousStyle = (index2) => {
      if (index2 === 0) {
        return;
      }
      const previousItem = styleRefs.value[index2 - 1];
      previousItem.setAttribute("tabindex", "0");
      previousItem.focus();
    };
    const handleKeyDown2 = (event, index2, style2) => {
      switch (event.key) {
        case "ArrowDown":
          moveToNextStyle(index2);
          break;
        case "ArrowUp":
          moveToPreviousStyle(index2);
          break;
        case "Enter":
          event.preventDefault();
          select(style2);
          break;
      }
    };
    vue.onMounted(() => {
      styleRefs.value[0].setAttribute("tabindex", "0");
      styleRefs.value[0].focus();
    });
    return (_ctx, _cache) => {
      return props.editor ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$h, [
        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(vue.unref(getQuickFormatList)(__props.editor), (style2, index2) => {
          return vue.openBlock(), vue.createElementBlock("div", {
            class: vue.normalizeClass(["style-item", { selected: __props.selectedOption === style2.id }]),
            onClick: ($event) => select(style2),
            onKeydown: (event) => handleKeyDown2(event, index2, style2),
            "aria-label": `Linked style - ${style2.id}`,
            ref_for: true,
            ref_key: "styleRefs",
            ref: styleRefs
          }, [
            vue.createBaseVNode("div", {
              class: "style-name",
              style: vue.normalizeStyle(vue.unref(generateLinkedStyleString)(style2, null, null, false)),
              "data-item": "btn-linkedStyles-option"
            }, vue.toDisplayString(style2.definition.attrs.name), 5)
          ], 42, _hoisted_2$c);
        }), 256))
      ])) : vue.createCommentVNode("", true);
    };
  }
};
const LinkedStyle = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["__scopeId", "data-v-073a491c"]]);
const _hoisted_1$g = {
  key: 0,
  class: "link-title"
};
const _hoisted_2$b = {
  key: 1,
  class: "link-title"
};
const _hoisted_3$8 = {
  key: 2,
  class: "link-title"
};
const _hoisted_4$4 = {
  key: 3,
  class: "link-input-wrapper"
};
const _hoisted_5$2 = { class: "input-row text-input-row" };
const _hoisted_6$1 = ["onKeydown"];
const _hoisted_7$1 = { class: "input-row url-input-row" };
const _hoisted_8$1 = ["innerHTML"];
const _hoisted_9 = ["onKeydown"];
const _hoisted_10 = ["innerHTML"];
const _hoisted_11 = { class: "input-row link-buttons" };
const _hoisted_12 = ["innerHTML"];
const _hoisted_13 = {
  key: 4,
  class: "input-row go-to-anchor clickable"
};
const _sfc_main$j = {
  __name: "LinkInput",
  props: {
    showInput: {
      type: Boolean,
      default: true
    },
    showLink: {
      type: Boolean,
      default: true
    },
    goToAnchor: {
      type: Function,
      default: () => {
      }
    },
    editor: {
      type: Object,
      required: true
    },
    closePopover: {
      type: Function,
      default: () => {
      }
    }
  },
  setup(__props) {
    const props = __props;
    const { isHighContrastMode: isHighContrastMode2 } = useHighContrastMode();
    const urlError = vue.ref(false);
    const getSelectedText = () => {
      if (!props.editor || !props.editor.state) return "";
      const { state } = props.editor;
      const { selection } = state;
      const linkMark = state.schema.marks.link;
      if (selection.empty) {
        const range = getMarkRange(selection.$from, linkMark);
        return range ? state.doc.textBetween(range.from, range.to, " ") : "";
      }
      const rangeFrom = getMarkRange(selection.$from, linkMark);
      const rangeTo = getMarkRange(selection.$to, linkMark);
      if (rangeFrom || rangeTo) {
        const linkRange = rangeFrom || rangeTo;
        return state.doc.textBetween(linkRange.from, linkRange.to, " ");
      }
      return state.doc.textBetween(selection.from, selection.to, " ");
    };
    const getLinkHrefAtSelection = () => {
      if (!props.editor || !props.editor.state) return "";
      const { state } = props.editor;
      const { schema, selection } = state;
      const linkMark = schema.marks.link;
      if (!linkMark) return "";
      let href = "";
      const { $from, empty: empty2 } = selection;
      if (empty2) {
        const marks = state.storedMarks || $from.marks();
        let link = marks.find((mark) => mark.type === linkMark);
        if (!link) {
          const nodeAfter = $from.nodeAfter;
          const nodeBefore = $from.nodeBefore;
          const marksOnNodeAfter = nodeAfter && Array.isArray(nodeAfter.marks) ? nodeAfter.marks : [];
          const marksOnNodeBefore = nodeBefore && Array.isArray(nodeBefore.marks) ? nodeBefore.marks : [];
          link = marksOnNodeAfter.find((mark) => mark.type === linkMark) || marksOnNodeBefore.find((mark) => mark.type === linkMark);
        }
        if (link && link.attrs && link.attrs.href) href = link.attrs.href;
      } else {
        state.doc.nodesBetween(selection.from, selection.to, (node) => {
          if (node.marks) {
            const link = node.marks.find((mark) => mark.type === linkMark);
            if (link && link.attrs && link.attrs.href) href = link.attrs.href;
          }
        });
      }
      return href || "";
    };
    const text = vue.ref("");
    const rawUrl = vue.ref("");
    const isAnchor = vue.ref(false);
    const url = vue.computed(() => {
      if (!rawUrl.value) return "";
      if (!rawUrl.value.startsWith("http") && !rawUrl.value.startsWith("#")) return "http://" + rawUrl.value;
      return rawUrl.value;
    });
    const validUrl = vue.computed(() => {
      if (url.value.startsWith("#")) return true;
      const urlSplit = url.value.split(".").filter(Boolean);
      return url.value.includes(".") && urlSplit.length > 1;
    });
    const isEditing = vue.computed(() => !isAnchor.value && !!getLinkHrefAtSelection());
    const isDisabled2 = vue.computed(() => !validUrl.value);
    const openLink = () => {
      window.open(url.value, "_blank");
    };
    const updateFromEditor = () => {
      text.value = getSelectedText();
      rawUrl.value = getLinkHrefAtSelection();
    };
    vue.watch(
      () => props.editor?.state?.selection,
      () => {
        updateFromEditor();
      },
      { immediate: true }
    );
    const focusInput = () => {
      const input = document.querySelector(".link-input-ctn input");
      if (!input) return;
      input.focus();
    };
    vue.onMounted(() => {
      updateFromEditor();
      isAnchor.value = rawUrl.value.startsWith("#");
      if (props.showInput) focusInput();
    });
    const handleSubmit = () => {
      const editor = props.editor;
      if (!editor) return;
      if (!rawUrl.value) {
        if (editor.commands?.unsetLink) editor.commands.unsetLink();
        props.closePopover();
        return;
      }
      if (!validUrl.value) {
        urlError.value = true;
        return;
      }
      const finalText = text.value || url.value;
      if (editor.commands?.toggleLink) {
        editor.commands.toggleLink({ href: url.value, text: finalText });
      }
      const endPos = editor.view.state.selection.$to.pos;
      editor.view.dispatch(editor.view.state.tr.setSelection(new superEditor_converter.TextSelection(editor.view.state.doc.resolve(endPos))));
      setTimeout(() => editor.view.focus(), 100);
      props.closePopover();
    };
    const handleRemove = () => {
      if (props.editor && props.editor.commands && props.editor.commands.unsetLink) {
        props.editor.commands.unsetLink();
        props.closePopover();
      }
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: vue.normalizeClass(["link-input-ctn", { "high-contrast": vue.unref(isHighContrastMode2) }])
      }, [
        isAnchor.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$g, "Page anchor")) : isEditing.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$b, "Edit link")) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_3$8, "Add link")),
        __props.showInput && !isAnchor.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_4$4, [
          vue.createBaseVNode("div", _hoisted_5$2, [
            _cache[4] || (_cache[4] = vue.createBaseVNode("div", { class: "input-icon text-input-icon" }, "T", -1)),
            vue.withDirectives(vue.createBaseVNode("input", {
              type: "text",
              name: "text",
              placeholder: "Text",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => text.value = $event),
              onKeydown: vue.withKeys(vue.withModifiers(handleSubmit, ["stop", "prevent"]), ["enter"])
            }, null, 40, _hoisted_6$1), [
              [vue.vModelText, text.value]
            ])
          ]),
          vue.createBaseVNode("div", _hoisted_7$1, [
            vue.createBaseVNode("div", {
              class: "input-icon",
              innerHTML: vue.unref(toolbarIcons).linkInput
            }, null, 8, _hoisted_8$1),
            vue.withDirectives(vue.createBaseVNode("input", {
              type: "text",
              name: "link",
              placeholder: "Type or paste a link",
              class: vue.normalizeClass({ error: urlError.value }),
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => rawUrl.value = $event),
              onKeydown: [
                vue.withKeys(vue.withModifiers(handleSubmit, ["stop", "prevent"]), ["enter"]),
                _cache[2] || (_cache[2] = ($event) => urlError.value = false)
              ]
            }, null, 42, _hoisted_9), [
              [vue.vModelText, rawUrl.value]
            ]),
            vue.createBaseVNode("div", {
              class: vue.normalizeClass(["open-link-icon", { disabled: !validUrl.value }]),
              innerHTML: vue.unref(toolbarIcons).openLink,
              onClick: openLink,
              "data-item": "btn-link-open"
            }, null, 10, _hoisted_10)
          ]),
          vue.createBaseVNode("div", _hoisted_11, [
            isEditing.value ? (vue.openBlock(), vue.createElementBlock("button", {
              key: 0,
              class: "remove-btn",
              onClick: handleRemove,
              "data-item": "btn-link-remove"
            }, [
              vue.createBaseVNode("div", {
                class: "remove-btn__icon",
                innerHTML: vue.unref(toolbarIcons).removeLink
              }, null, 8, _hoisted_12),
              _cache[5] || (_cache[5] = vue.createTextVNode(" Remove ", -1))
            ])) : vue.createCommentVNode("", true),
            vue.createBaseVNode("button", {
              class: vue.normalizeClass(["submit-btn", { "disable-btn": isDisabled2.value }]),
              onClick: handleSubmit,
              "data-item": "btn-link-apply"
            }, " Apply ", 2)
          ])
        ])) : isAnchor.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_13, [
          vue.createBaseVNode("a", {
            onClick: _cache[3] || (_cache[3] = vue.withModifiers((...args) => __props.goToAnchor && __props.goToAnchor(...args), ["stop", "prevent"]))
          }, "Go to " + vue.toDisplayString(rawUrl.value.startsWith("#_") ? rawUrl.value.substring(2) : rawUrl.value), 1)
        ])) : vue.createCommentVNode("", true)
      ], 2);
    };
  }
};
const LinkInput = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["__scopeId", "data-v-f64d35e8"]]);
const _hoisted_1$f = ["aria-label", "onClick", "onKeydown"];
const _hoisted_2$a = ["innerHTML"];
const _hoisted_3$7 = ["innerHTML"];
const ROW_SIZE$1 = 7;
const _sfc_main$i = {
  __name: "IconGridRow",
  props: {
    icons: {
      type: Array,
      required: true
    },
    activeColor: {
      type: Object,
      required: false
    }
  },
  emits: ["select", "clickoutside"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const props = __props;
    const isActive2 = vue.computed(() => (option) => {
      if (!props.activeColor.value) return false;
      return props.activeColor.value.toUpperCase() === option.value;
    });
    const getCheckStyle = (color, optionIndex) => {
      const lightColors = ["#FFFFFF", "#FAFF09"];
      if (optionIndex === 5 || lightColors.includes(color)) return { color: "#000" };
      return { color: "#FFF" };
    };
    const handleClick2 = (option) => {
      emit("select", option.value);
    };
    const rowRefs = vue.ref([]);
    const iconRefs = vue.ref([]);
    vue.onMounted(() => {
      const isMatrix = props.icons.every((row) => Array.isArray(row));
      if (!isMatrix) throw new Error("icon props must be 2d array");
      const firstIcon = iconRefs.value[0];
      if (firstIcon) {
        firstIcon.setAttribute("tabindex", "0");
        firstIcon.focus();
      }
    });
    const moveToNextIcon = (rowIndex, optionIndex) => {
      const iconIndex = ROW_SIZE$1 * rowIndex + optionIndex + 1;
      const nextIcon = iconRefs.value[iconIndex];
      if (nextIcon) {
        nextIcon.setAttribute("tabindex", "0");
        nextIcon.focus();
      }
    };
    const moveToPreviousIcon = (rowIndex, optionIndex) => {
      const iconIndex = ROW_SIZE$1 * rowIndex + optionIndex - 1;
      const previousIcon = iconRefs.value[iconIndex];
      if (previousIcon) {
        previousIcon.setAttribute("tabindex", "0");
        previousIcon.focus();
      }
    };
    const moveToNextRow = (rowIndex, optionIndex) => {
      const iconIndex = optionIndex + ROW_SIZE$1 * (rowIndex + 1);
      const nextIcon = iconRefs.value[iconIndex];
      if (nextIcon) {
        nextIcon.setAttribute("tabindex", "0");
        nextIcon.focus();
      }
    };
    const moveToPreviousRow = (rowIndex, optionIndex) => {
      const iconIndex = optionIndex + ROW_SIZE$1 * (rowIndex - 1);
      const previousIcon = iconRefs.value[iconIndex];
      if (previousIcon) {
        previousIcon.setAttribute("tabindex", "0");
        previousIcon.focus();
      }
    };
    const handleKeyDown2 = (event, rowIndex, optionIndex, option) => {
      switch (event.key) {
        case "ArrowRight":
          moveToNextIcon(rowIndex, optionIndex);
          break;
        case "ArrowLeft":
          moveToPreviousIcon(rowIndex, optionIndex);
          break;
        case "ArrowDown":
          moveToNextRow(rowIndex, optionIndex);
          break;
        case "ArrowUp":
          moveToPreviousRow(rowIndex, optionIndex);
          break;
        case "Enter":
          handleClick2(option);
          break;
        case "Escape":
          emit("clickoutside");
          break;
      }
    };
    return (_ctx, _cache) => {
      return vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.icons, (row, rowIndex) => {
        return vue.openBlock(), vue.createElementBlock("div", {
          class: "option-row",
          key: rowIndex,
          role: "group",
          ref_for: true,
          ref_key: "rowRefs",
          ref: rowRefs
        }, [
          (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(row, (option, optionIndex) => {
            return vue.openBlock(), vue.createElementBlock("div", {
              class: "option",
              key: optionIndex,
              "aria-label": option.label,
              role: "menuitem",
              ref_for: true,
              ref_key: "iconRefs",
              ref: iconRefs,
              onClick: vue.withModifiers(($event) => handleClick2(option), ["stop", "prevent"]),
              onKeydown: vue.withModifiers((event) => handleKeyDown2(event, rowIndex, optionIndex, option), ["prevent"])
            }, [
              vue.createBaseVNode("div", {
                class: "option__icon",
                innerHTML: option.icon,
                style: vue.normalizeStyle(option.style)
              }, null, 12, _hoisted_2$a),
              isActive2.value(option) ? (vue.openBlock(), vue.createElementBlock("div", {
                key: 0,
                class: "option__check",
                innerHTML: vue.unref(toolbarIcons).colorOptionCheck,
                style: vue.normalizeStyle(getCheckStyle(option.value, optionIndex))
              }, null, 12, _hoisted_3$7)) : vue.createCommentVNode("", true)
            ], 40, _hoisted_1$f);
          }), 128))
        ]);
      }), 128);
    };
  }
};
const IconGridRow = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["__scopeId", "data-v-7eb02a60"]]);
const DropIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M320 512c53.2 0 101.4-21.6 136.1-56.6l-298.3-235C140 257.1 128 292.3 128 320c0 106 86 192 192 192zM505.2 370.7c4.4-16.2 6.8-33.1 6.8-50.7c0-91.2-130.2-262.3-166.6-308.3C339.4 4.2 330.5 0 320.9 0l-1.8 0c-9.6 0-18.5 4.2-24.5 11.7C277.8 33 240.7 81.3 205.8 136L38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L505.2 370.7zM224 336c0 44.2 35.8 80 80 80c8.8 0 16 7.2 16 16s-7.2 16-16 16c-61.9 0-112-50.1-112-112c0-8.8 7.2-16 16-16s16 7.2 16 16z"/></svg>\n';
const _hoisted_1$e = { class: "options-grid-wrap" };
const _hoisted_2$9 = ["innerHTML"];
const _hoisted_3$6 = { class: "option-grid-ctn" };
const _sfc_main$h = {
  __name: "IconGrid",
  props: {
    icons: {
      type: Array,
      required: true
    },
    customIcons: {
      type: Array,
      required: false
    },
    activeColor: {
      type: Object,
      required: false
    },
    hasNoneIcon: {
      type: Boolean,
      required: false
    }
  },
  emits: ["select", "clickoutside"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const handleSelect = (option) => {
      emit("select", option);
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$e, [
        __props.hasNoneIcon ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: "none-option",
          role: "menuitem",
          "aria-label": "Clear color selection",
          onClick: _cache[0] || (_cache[0] = ($event) => handleSelect("none"))
        }, [
          vue.createBaseVNode("span", {
            innerHTML: vue.unref(DropIcon),
            class: "none-icon"
          }, null, 8, _hoisted_2$9),
          _cache[1] || (_cache[1] = vue.createTextVNode(" None ", -1))
        ])) : vue.createCommentVNode("", true),
        vue.createBaseVNode("div", _hoisted_3$6, [
          vue.createVNode(IconGridRow, {
            icons: __props.icons,
            "active-color": __props.activeColor,
            onSelect: handleSelect
          }, null, 8, ["icons", "active-color"]),
          __props.customIcons.flat().length ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
            _cache[2] || (_cache[2] = vue.createBaseVNode("span", { class: "option-grid-ctn__subtitle" }, "Custom colors", -1)),
            vue.createVNode(IconGridRow, {
              icons: __props.customIcons,
              "active-color": __props.activeColor,
              onSelect: handleSelect
            }, null, 8, ["icons", "active-color"])
          ], 64)) : vue.createCommentVNode("", true)
        ])
      ]);
    };
  }
};
const IconGrid = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["__scopeId", "data-v-891fd942"]]);
const closeDropdown$1 = (dropdown) => {
  dropdown.expand.value = false;
};
const makeColorOption = (color, label = null) => {
  return {
    label,
    icon: toolbarIcons.colorOption,
    value: color,
    style: {
      color,
      boxShadow: "0 0 5px 1px rgba(0, 0, 0, 0.1)",
      borderRadius: "50%"
    }
  };
};
const renderColorOptions = (superToolbar, button, customIcons = [], hasNoneIcon = false) => {
  const handleSelect = (e) => {
    button.iconColor.value = e;
    superToolbar.emitCommand({ item: button, argument: e });
    closeDropdown$1(button);
  };
  return vue.h("div", {}, [
    vue.h(IconGrid, {
      icons,
      customIcons,
      activeColor: button.iconColor,
      hasNoneIcon,
      onSelect: handleSelect
    })
  ]);
};
const icons = [
  [
    makeColorOption("#111111", "black"),
    makeColorOption("#333333", "dark gray"),
    makeColorOption("#5C5C5C", "medium gray"),
    makeColorOption("#858585", "light gray"),
    makeColorOption("#ADADAD", "very light gray"),
    makeColorOption("#D6D6D6", "transparent gray"),
    makeColorOption("#FFFFFF", "white")
  ],
  [
    makeColorOption("#860028", "dark red"),
    makeColorOption("#D2003F", "red"),
    makeColorOption("#DB3365", "coral red"),
    makeColorOption("#E4668C", "light red"),
    makeColorOption("#ED99B2", "pale pink"),
    makeColorOption("#F6CCD9", "transparent pink"),
    makeColorOption("#FF004D", "bright pink")
  ],
  [
    makeColorOption("#83015E", "dark purple"),
    makeColorOption("#CD0194", "purple"),
    makeColorOption("#D734A9", "orchid"),
    makeColorOption("#E167BF", "light purple"),
    makeColorOption("#EB99D4", "lavender"),
    makeColorOption("#F5CCEA", "transparent pink"),
    makeColorOption("#FF00A8", "neon pink")
  ],
  [
    makeColorOption("#8E220A", "maroon"),
    makeColorOption("#DD340F", "red-orange"),
    makeColorOption("#E45C3F", "burnt orange"),
    makeColorOption("#EB856F", "peach"),
    makeColorOption("#F1AE9F", "pale peach"),
    makeColorOption("#F8D6CF", "transparent peach"),
    makeColorOption("#FF7A00", "orange")
  ],
  [
    makeColorOption("#947D02", "olive"),
    makeColorOption("#E7C302", "mustard yellow"),
    makeColorOption("#ECCF35", "yellow"),
    makeColorOption("#F1DB67", "light yellow"),
    makeColorOption("#F5E79A", "very pale yellow"),
    makeColorOption("#FAF3CC", "transparent yellow"),
    makeColorOption("#FAFF09", "neon yellow")
  ],
  [
    makeColorOption("#055432", "forest green"),
    makeColorOption("#07834F", "green"),
    makeColorOption("#399C72", "medium green"),
    makeColorOption("#6AB595", "light green"),
    makeColorOption("#9CCDB9", "mint"),
    makeColorOption("#CDE6DC", "transparent mint"),
    makeColorOption("#05F38F", "bright teal")
  ],
  [
    makeColorOption("#063E7E", "navy blue"),
    makeColorOption("#0A60C5", "blue"),
    makeColorOption("#3B80D1", "sky blue"),
    makeColorOption("#6CA0DC", "cornflower blue"),
    makeColorOption("#9DBFE8", "light blue"),
    makeColorOption("#CEDFF3", "very light blue"),
    makeColorOption("#21c8ce", "cyan")
  ],
  [
    makeColorOption("#3E027A", "deep purple"),
    makeColorOption("#6103BF", "indigo"),
    makeColorOption("#8136CC", "violet"),
    makeColorOption("#A068D9", "lavender pink"),
    makeColorOption("#C09AE6", "light lilac"),
    makeColorOption("#DFCDF2", "transparent lilac"),
    makeColorOption("#A91DFF", "neon purple")
  ]
];
const getAvailableColorOptions = () => {
  return icons.flat().map((item) => item.value);
};
const _hoisted_1$d = ["data-cols", "data-rows", "onKeydown", "onClick"];
const _hoisted_2$8 = ["aria-valuetext"];
const ROW_SIZE = 5;
const _sfc_main$g = {
  __name: "TableGrid",
  emits: ["select", "clickoutside"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const selectedRows = vue.ref(0);
    const selectedCols = vue.ref(0);
    const { isHighContrastMode: isHighContrastMode2 } = useHighContrastMode();
    const tableGridItems = vue.ref([]);
    const onTableGridMouseOver = (event) => {
      let target = event.target;
      let isGrid = !!target.dataset.grid;
      if (isGrid) {
        return;
      }
      let grid = target.parentElement;
      let allItems = [...grid.querySelectorAll("[data-item]")];
      let cols = parseInt(target.dataset.cols, 10);
      let rows = parseInt(target.dataset.rows, 10);
      selectGridItems(allItems, cols, rows);
    };
    const selectGridItems = (allItems, cols, rows) => {
      selectedCols.value = cols;
      selectedRows.value = rows;
      for (let i = 0; i < allItems.length; i++) {
        let item = allItems[i];
        let itemsCols = parseInt(item.dataset.cols, 10);
        let itemsRows = parseInt(item.dataset.rows, 10);
        if (itemsCols <= cols && itemsRows <= rows) {
          item.classList.add("selected");
        } else {
          item.classList.remove("selected");
        }
      }
    };
    const handleClick2 = ({ cols, rows }) => {
      emit("select", { cols, rows });
    };
    const handleKeyDown2 = (event, cols, rows) => {
      let normalizedCols = cols - 1;
      let normalizedRows = rows - 1;
      switch (event.key) {
        case "ArrowRight": {
          if (normalizedCols >= 4) {
            return;
          }
          const currentRow = normalizedRows * ROW_SIZE;
          tableGridItems.value[currentRow + normalizedCols + 1].setAttribute("tabindex", "0");
          tableGridItems.value[currentRow + normalizedCols + 1].focus();
          selectGridItems(tableGridItems.value, cols + 1, rows);
          break;
        }
        case "ArrowLeft": {
          if (normalizedCols <= 0) {
            return;
          }
          const currentRow = normalizedRows * ROW_SIZE;
          tableGridItems.value[currentRow + normalizedCols - 1].setAttribute("tabindex", "0");
          tableGridItems.value[currentRow + normalizedCols - 1].focus();
          selectGridItems(tableGridItems.value, cols - 1, rows);
          break;
        }
        case "ArrowDown": {
          if (normalizedRows >= 4) {
            return;
          }
          const nextRow = (normalizedRows + 1) * ROW_SIZE;
          tableGridItems.value[nextRow + normalizedCols].setAttribute("tabindex", "0");
          tableGridItems.value[nextRow + normalizedCols].focus();
          selectGridItems(tableGridItems.value, cols, rows + 1);
          break;
        }
        case "ArrowUp": {
          if (normalizedRows <= 0) {
            return;
          }
          const previousRow = (normalizedRows - 1) * ROW_SIZE;
          tableGridItems.value[previousRow + normalizedCols].setAttribute("tabindex", "0");
          tableGridItems.value[previousRow + normalizedCols].focus();
          selectGridItems(tableGridItems.value, cols, rows - 1);
          break;
        }
        case "Enter": {
          handleClick2({ cols, rows });
          break;
        }
      }
    };
    vue.onMounted(() => {
      tableGridItems.value[0].setAttribute("tabindex", "0");
      tableGridItems.value[0].focus();
      selectGridItems(tableGridItems.value, 1, 1);
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: vue.normalizeClass(["toolbar-table-grid-wrapper", { "high-contrast": vue.unref(isHighContrastMode2) }])
      }, [
        vue.createBaseVNode("div", {
          class: "toolbar-table-grid",
          onMouseover: onTableGridMouseOver,
          "data-grid": "true"
        }, [
          (vue.openBlock(), vue.createElementBlock(vue.Fragment, null, vue.renderList(5, (i) => {
            return vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: i }, [
              (vue.openBlock(), vue.createElementBlock(vue.Fragment, null, vue.renderList(5, (n) => {
                return vue.createBaseVNode("div", {
                  class: "toolbar-table-grid__item",
                  key: `${i}_${n}`,
                  "data-cols": n,
                  "data-rows": i,
                  "data-item": "true",
                  ref_for: true,
                  ref_key: "tableGridItems",
                  ref: tableGridItems,
                  onKeydown: vue.withModifiers((event) => handleKeyDown2(event, n, i), ["prevent"]),
                  onClick: vue.withModifiers(($event) => handleClick2({ cols: n, rows: i }), ["stop", "prevent"])
                }, null, 40, _hoisted_1$d);
              }), 64))
            ], 64);
          }), 64))
        ], 32),
        vue.createBaseVNode("div", {
          class: "toolbar-table-grid-value",
          "aria-valuetext": `${selectedRows.value} x ${selectedCols.value}`
        }, vue.toDisplayString(selectedRows.value) + " x " + vue.toDisplayString(selectedCols.value), 9, _hoisted_2$8)
      ], 2);
    };
  }
};
const TableGrid = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__scopeId", "data-v-07c60426"]]);
const _hoisted_1$c = { class: "toolbar-table-actions" };
const _hoisted_2$7 = ["onClick", "data-item", "ariaLabel"];
const _hoisted_3$5 = { class: "toolbar-table-actions__icon" };
const _hoisted_4$3 = ["innerHTML"];
const _hoisted_5$1 = { class: "toolbar-table-actions__label" };
const _sfc_main$f = {
  __name: "TableActions",
  props: {
    options: {
      type: Array
    }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const handleClick2 = (item) => {
      emit("select", { command: item.command });
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$c, [
        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.options, (option) => {
          return vue.openBlock(), vue.createElementBlock("div", {
            class: vue.normalizeClass(["toolbar-table-actions__item", { "toolbar-table-actions__item--border": option.bottomBorder }]),
            onClick: ($event) => handleClick2(option),
            "data-item": option.props?.["data-item"] || "",
            ariaLabel: option.props?.ariaLabel,
            role: "menuitem"
          }, [
            vue.createBaseVNode("div", _hoisted_3$5, [
              vue.createBaseVNode("div", {
                class: "toolbar-table-actions__icon-wrapper",
                innerHTML: option.icon
              }, null, 8, _hoisted_4$3)
            ]),
            vue.createBaseVNode("div", _hoisted_5$1, vue.toDisplayString(option.label), 1)
          ], 10, _hoisted_2$7);
        }), 256))
      ]);
    };
  }
};
const TableActions = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__scopeId", "data-v-d1697e32"]]);
function getScrollableParent(element) {
  let currentElement = element;
  while (currentElement) {
    const overflowY = window.getComputedStyle(currentElement).overflowY;
    if (/(auto|scroll)/.test(overflowY) && currentElement.scrollHeight > currentElement.clientHeight) {
      return currentElement;
    }
    currentElement = currentElement.parentElement;
  }
  return document.scrollingElement || document.documentElement;
}
function scrollToElement(targetElement, options = { behavior: "smooth", block: "start" }) {
  if (!targetElement) return;
  const container = getScrollableParent(targetElement);
  const containerRect = container.getBoundingClientRect();
  const targetRect = targetElement.getBoundingClientRect();
  const offsetTop = targetRect.top - containerRect.top + container.scrollTop;
  container.scrollTo({
    top: options.block === "start" ? offsetTop : offsetTop - container.clientHeight + targetElement.offsetHeight,
    behavior: options.behavior
  });
}
const checkIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M438.6 105.4c12.5 12.5 12.5 32.8 0 45.3l-256 256c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 338.7 393.4 105.4c12.5-12.5 32.8-12.5 45.3 0z"/></svg>\n';
const _hoisted_1$b = { class: "search-input-ctn" };
const _hoisted_2$6 = { class: "row" };
const _hoisted_3$4 = ["onKeydown"];
const _sfc_main$e = {
  __name: "SearchInput",
  props: {
    searchRef: {
      type: Object
    }
  },
  emits: ["submit"],
  setup(__props, { emit: __emit }) {
    const searchValue = vue.ref("");
    const emit = __emit;
    const handleSubmit = () => {
      emit("submit", { value: searchValue.value });
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$b, [
        vue.createBaseVNode("div", _hoisted_2$6, [
          vue.withDirectives(vue.createBaseVNode("input", {
            ref: __props.searchRef,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchValue.value = $event),
            class: "search-input",
            type: "text",
            name: "search",
            placeholder: "Type search string",
            onKeydown: vue.withKeys(vue.withModifiers(handleSubmit, ["stop", "prevent"]), ["enter"])
          }, null, 40, _hoisted_3$4), [
            [vue.vModelText, searchValue.value]
          ])
        ]),
        vue.createBaseVNode("div", { class: "row submit" }, [
          vue.createBaseVNode("button", {
            class: "submit-btn",
            onClick: handleSubmit
          }, "Apply")
        ])
      ]);
    };
  }
};
const SearchInput = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__scopeId", "data-v-ab2fefe3"]]);
const TOOLBAR_FONTS = [
  {
    label: "Georgia",
    key: "Georgia, serif",
    fontWeight: 400,
    props: {
      style: { fontFamily: "Georgia, serif" },
      "data-item": "btn-fontFamily-option"
    }
  },
  {
    label: "Arial",
    key: "Arial, sans-serif",
    fontWeight: 400,
    props: {
      style: { fontFamily: "Arial, sans-serif" },
      "data-item": "btn-fontFamily-option"
    }
  },
  {
    label: "Courier New",
    key: "Courier New, monospace",
    fontWeight: 400,
    props: {
      style: { fontFamily: "Courier New, monospace" },
      "data-item": "btn-fontFamily-option"
    }
  },
  {
    label: "Times New Roman",
    key: "Times New Roman, serif",
    fontWeight: 400,
    props: {
      style: { fontFamily: "Times New Roman, serif" },
      "data-item": "btn-fontFamily-option"
    }
  }
];
const TOOLBAR_FONT_SIZES = [
  { label: "8", key: "8pt", props: { "data-item": "btn-fontSize-option" } },
  { label: "9", key: "9pt", props: { "data-item": "btn-fontSize-option" } },
  { label: "10", key: "10pt", props: { "data-item": "btn-fontSize-option" } },
  { label: "11", key: "11pt", props: { "data-item": "btn-fontSize-option" } },
  { label: "12", key: "12pt", props: { "data-item": "btn-fontSize-option" } },
  { label: "14", key: "14pt", props: { "data-item": "btn-fontSize-option" } },
  { label: "18", key: "18pt", props: { "data-item": "btn-fontSize-option" } },
  { label: "24", key: "24pt", props: { "data-item": "btn-fontSize-option" } },
  { label: "30", key: "30pt", props: { "data-item": "btn-fontSize-option" } },
  { label: "36", key: "36pt", props: { "data-item": "btn-fontSize-option" } },
  { label: "48", key: "48pt", props: { "data-item": "btn-fontSize-option" } },
  { label: "60", key: "60pt", props: { "data-item": "btn-fontSize-option" } },
  { label: "72", key: "72pt", props: { "data-item": "btn-fontSize-option" } },
  { label: "96", key: "96pt", props: { "data-item": "btn-fontSize-option" } }
];
const closeDropdown = (dropdown) => {
  dropdown.expand.value = false;
};
const makeDefaultItems = ({
  superToolbar,
  toolbarIcons: toolbarIcons2,
  toolbarTexts: toolbarTexts2,
  toolbarFonts,
  hideButtons,
  availableWidth,
  role,
  isDev = false
} = {}) => {
  const bold = useToolbarItem({
    type: "button",
    name: "bold",
    command: "toggleBold",
    icon: toolbarIcons2.bold,
    tooltip: toolbarTexts2.bold,
    attributes: {
      ariaLabel: "Bold"
    }
  });
  const fontOptions = [...toolbarFonts ? toolbarFonts : TOOLBAR_FONTS];
  const fontButton = useToolbarItem({
    type: "dropdown",
    name: "fontFamily",
    tooltip: toolbarTexts2.fontFamily,
    command: "setFontFamily",
    defaultLabel: "Arial",
    label: "Arial",
    markName: "textStyle",
    labelAttr: "fontFamily",
    hasCaret: true,
    isWide: true,
    style: { width: "116px" },
    suppressActiveHighlight: true,
    attributes: {
      ariaLabel: "Font family"
    },
    options: fontOptions,
    onActivate: ({ fontFamily: fontFamily2 }) => {
      if (!fontFamily2) return;
      fontFamily2 = fontFamily2.split(",")[0];
      fontButton.label.value = fontFamily2;
      const defaultFont = fontOptions.find((i) => i.label === fontButton.defaultLabel.value);
      const foundFont = fontOptions.find((i) => i.label === fontFamily2);
      if (foundFont) {
        fontButton.selectedValue.value = foundFont.key;
      } else if (defaultFont) {
        fontButton.selectedValue.value = defaultFont.key;
      } else {
        fontButton.selectedValue.value = "";
      }
    },
    onDeactivate: () => {
      fontButton.label.value = fontButton.defaultLabel.value;
      const defaultFont = fontOptions.find((i) => i.label === fontButton.defaultLabel.value);
      if (defaultFont) fontButton.selectedValue.value = defaultFont.key;
      else fontButton.selectedValue.value = "";
    }
  });
  const aiButton = useToolbarItem({
    type: "dropdown",
    dropdownStyles: {
      padding: 0,
      outline: "none"
    },
    name: "ai",
    tooltip: toolbarTexts2.ai,
    icon: toolbarIcons2.ai,
    hideLabel: true,
    hasCaret: false,
    isWide: true,
    suppressActiveHighlight: true,
    attributes: {
      ariaLabel: "AI"
    },
    options: [
      {
        type: "render",
        key: "ai",
        render: () => {
          let selectedText = "";
          if (superToolbar.activeEditor) {
            const { state } = superToolbar.activeEditor;
            const { from: from3, to, empty: empty2 } = state.selection;
            selectedText = !empty2 ? state.doc.textBetween(from3, to) : "";
          }
          const handleClose = () => {
            closeDropdown(aiButton);
          };
          return vue.h("div", {}, [
            vue.h(AIWriter, {
              handleClose,
              selectedText,
              editor: superToolbar.activeEditor,
              apiKey: superToolbar.config.aiApiKey,
              endpoint: superToolbar.config.aiEndpoint,
              superToolbar
            })
          ]);
        }
      }
    ]
  });
  const fontSizeOptions = TOOLBAR_FONT_SIZES;
  const fontSize2 = useToolbarItem({
    type: "dropdown",
    name: "fontSize",
    defaultLabel: "12",
    label: "12",
    minWidth: "50px",
    markName: "textStyle",
    labelAttr: "fontSize",
    tooltip: toolbarTexts2.fontSize,
    hasCaret: true,
    hasInlineTextInput: true,
    inlineTextInputVisible: true,
    suppressActiveHighlight: true,
    isWide: true,
    command: "setFontSize",
    attributes: {
      ariaLabel: "Font size"
    },
    options: fontSizeOptions,
    onActivate: ({ fontSize: size2 }, isMultiple = false) => {
      if (isMultiple) {
        fontSize2.label.value = "";
        fontSize2.selectedValue.value = "";
        return;
      }
      const defaultSize = fontSizeOptions.find((i) => i.label === String(fontSize2.defaultLabel.value));
      if (!size2) {
        fontSize2.label.value = fontSize2.defaultLabel.value;
        if (defaultSize) fontSize2.selectedValue.value = defaultSize.key;
        else fontSize2.selectedValue.value = "";
        return;
      }
      let sanitizedValue = sanitizeNumber(size2, 12);
      if (sanitizedValue < 8) sanitizedValue = 8;
      if (sanitizedValue > 96) sanitizedValue = 96;
      let sanitizedValueStr = String(sanitizedValue);
      const foundSize = fontSizeOptions.find((i) => {
        return i.label === sanitizedValueStr || i.key === sanitizedValueStr;
      });
      if (foundSize) {
        fontSize2.selectedValue.value = foundSize.key;
      } else {
        fontSize2.selectedValue.value = "";
      }
      fontSize2.label.value = sanitizedValueStr;
    },
    onDeactivate: () => {
      fontSize2.label.value = fontSize2.defaultLabel.value;
      const defaultSize = fontSizeOptions.find((i) => i.label === String(fontSize2.defaultLabel.value));
      if (defaultSize) fontSize2.selectedValue.value = defaultSize.key;
      else fontSize2.selectedValue.value = "";
    }
  });
  const separator = useToolbarItem({
    type: "separator",
    name: "separator",
    isNarrow: true
  });
  const italic = useToolbarItem({
    type: "button",
    name: "italic",
    command: "toggleItalic",
    icon: toolbarIcons2.italic,
    tooltip: toolbarTexts2.italic,
    attributes: {
      ariaLabel: "Italic"
    }
  });
  const underline = useToolbarItem({
    type: "button",
    name: "underline",
    command: "toggleUnderline",
    icon: toolbarIcons2.underline,
    tooltip: toolbarTexts2.underline,
    attributes: {
      ariaLabel: "Underline"
    }
  });
  const strikethrough = useToolbarItem({
    type: "button",
    name: "strike",
    command: "toggleStrike",
    icon: toolbarIcons2.strikethrough,
    tooltip: toolbarTexts2.strikethrough,
    attributes: {
      ariaLabel: "Strikethrough"
    }
  });
  const highlight = useToolbarItem({
    type: "dropdown",
    name: "highlight",
    icon: toolbarIcons2.highlight,
    hideLabel: true,
    markName: "highlight",
    labelAttr: "color",
    tooltip: toolbarTexts2.highlight,
    command: "setHighlight",
    noArgumentCommand: "unsetHighlight",
    suppressActiveHighlight: true,
    attributes: {
      ariaLabel: "Highlight"
    },
    options: [
      {
        key: "color",
        type: "render",
        render: () => renderColorOptions(superToolbar, highlight, [], true)
      }
    ],
    onActivate: ({ color }) => {
      highlight.iconColor.value = color || "";
    },
    onDeactivate: () => highlight.iconColor.value = ""
  });
  const colorButton = useToolbarItem({
    type: "dropdown",
    name: "color",
    icon: toolbarIcons2.color,
    hideLabel: true,
    markName: "textStyle",
    labelAttr: "color",
    tooltip: toolbarTexts2.color,
    command: "setColor",
    suppressActiveHighlight: true,
    attributes: {
      ariaLabel: "Color"
    },
    options: [
      {
        key: "color",
        type: "render",
        render: () => renderColorOptions(superToolbar, colorButton)
      }
    ],
    onActivate: ({ color }) => {
      colorButton.iconColor.value = color;
    },
    onDeactivate: () => colorButton.iconColor.value = "#000"
  });
  const searchRef = vue.ref(null);
  const search2 = useToolbarItem({
    type: "dropdown",
    name: "search",
    icon: toolbarIcons2.search,
    tooltip: toolbarTexts2.search,
    group: "right",
    inputRef: searchRef,
    attributes: {
      ariaLabel: "Search"
    },
    options: [
      {
        type: "render",
        key: "searchDropdown",
        render: () => renderSearchDropdown()
      }
    ]
  });
  const renderSearchDropdown = () => {
    const handleSubmit = ({ value }) => {
      superToolbar.activeEditor.commands.search(value);
    };
    return vue.h("div", {}, [
      vue.h(SearchInput, {
        onSubmit: handleSubmit,
        searchRef
      })
    ]);
  };
  const link = useToolbarItem({
    type: "dropdown",
    name: "link",
    markName: "link",
    icon: toolbarIcons2.link,
    tooltip: toolbarTexts2.link,
    attributes: {
      ariaLabel: "Link dropdown"
    },
    options: [
      {
        type: "render",
        key: "linkDropdown",
        render: () => renderLinkDropdown(link)
      }
    ],
    onActivate: ({ href }) => {
      if (href) link.attributes.value = { href };
      else link.attributes.value = {};
    },
    onDeactivate: () => {
      link.attributes.value = {};
      link.expand.value = false;
    }
  });
  function renderLinkDropdown(link2) {
    return vue.h("div", {}, [
      vue.h(LinkInput, {
        editor: superToolbar.activeEditor,
        closePopover: () => closeDropdown(link2),
        goToAnchor: () => {
          closeDropdown(link2);
          if (!superToolbar.activeEditor || !link2.attributes.value?.href) return;
          const anchorName = link2.attributes.value?.href?.slice(1);
          const container = superToolbar.activeEditor.element;
          const anchor = container.querySelector(`a[name='${anchorName}']`);
          if (anchor) scrollToElement(anchor);
        }
      })
    ]);
  }
  const linkInput = useToolbarItem({
    type: "options",
    name: "linkInput",
    command: "toggleLink"
  });
  link.childItem = linkInput;
  linkInput.parentItem = link;
  const image = useToolbarItem({
    type: "button",
    name: "image",
    command: "startImageUpload",
    icon: toolbarIcons2.image,
    tooltip: toolbarTexts2.image,
    disabled: false,
    attributes: {
      ariaLabel: "Image"
    }
  });
  const tableItem = useToolbarItem({
    type: "dropdown",
    name: "table",
    icon: toolbarIcons2.table,
    hideLabel: true,
    labelAttr: "table",
    tooltip: toolbarTexts2.table,
    command: "insertTable",
    suppressActiveHighlight: true,
    attributes: {
      ariaLabel: "Table"
    },
    options: [
      {
        key: "table",
        type: "render",
        render: () => renderTableGrid(tableItem)
      }
    ]
  });
  function renderTableGrid(tableItem2) {
    const handleSelect = (e) => {
      superToolbar.emitCommand({ item: tableItem2, argument: e });
      closeDropdown(tableItem2);
    };
    return vue.h("div", {}, [
      vue.h(TableGrid, {
        onSelect: handleSelect
      })
    ]);
  }
  const tableActionsItem = useToolbarItem({
    type: "dropdown",
    name: "tableActions",
    command: "executeTableCommand",
    tooltip: toolbarTexts2.tableActions,
    icon: toolbarIcons2.tableActions,
    hideLabel: true,
    disabled: true,
    attributes: {
      ariaLabel: "Table actions"
    },
    options: [
      {
        type: "render",
        render: () => renderTableActions(tableActionsItem)
      }
    ]
  });
  const tableActionsOptions2 = [
    {
      label: toolbarTexts2.addRowBefore,
      command: "addRowBefore",
      icon: toolbarIcons2.addRowBefore,
      props: {
        "data-item": "btn-tableActions-option",
        ariaLabel: "Add row before"
      }
    },
    {
      label: toolbarTexts2.addRowAfter,
      command: "addRowAfter",
      icon: toolbarIcons2.addRowAfter,
      props: {
        "data-item": "btn-tableActions-option",
        ariaLabel: "Add row after"
      }
    },
    {
      label: toolbarTexts2.addColumnBefore,
      command: "addColumnBefore",
      icon: toolbarIcons2.addColumnBefore,
      props: {
        "data-item": "btn-tableActions-option",
        ariaLabel: "Add column before"
      }
    },
    {
      label: toolbarTexts2.addColumnAfter,
      command: "addColumnAfter",
      icon: toolbarIcons2.addColumnAfter,
      bottomBorder: true,
      props: {
        "data-item": "btn-tableActions-option",
        ariaLabel: "Add column after"
      }
    },
    {
      label: toolbarTexts2.deleteRow,
      command: "deleteRow",
      icon: toolbarIcons2.deleteRow,
      props: {
        "data-item": "btn-tableActions-option",
        ariaLabel: " "
      }
    },
    {
      label: toolbarTexts2.deleteColumn,
      command: "deleteColumn",
      icon: toolbarIcons2.deleteColumn,
      props: {
        "data-item": "btn-tableActions-option",
        ariaLabel: "Delete column"
      }
    },
    {
      label: toolbarTexts2.deleteTable,
      command: "deleteTable",
      icon: toolbarIcons2.deleteTable,
      props: {
        "data-item": "btn-tableActions-option",
        ariaLabel: "Delete table"
      }
    },
    {
      label: toolbarTexts2.removeBorders,
      command: "deleteCellAndTableBorders",
      icon: toolbarIcons2.deleteBorders,
      bottomBorder: true,
      props: {
        "data-item": "btn-tableActions-option",
        ariaLabel: "Delete cell and table borders"
      }
    },
    {
      label: toolbarTexts2.mergeCells,
      command: "mergeCells",
      icon: toolbarIcons2.mergeCells,
      props: {
        "data-item": "btn-tableActions-option",
        ariaLabel: "Merge cells"
      }
    },
    {
      label: toolbarTexts2.splitCell,
      command: "splitCell",
      icon: toolbarIcons2.splitCell,
      props: {
        "data-item": "btn-tableActions-option",
        ariaLabel: "Split cells"
      }
    },
    {
      label: toolbarTexts2.fixTables,
      command: "fixTables",
      icon: toolbarIcons2.fixTables,
      props: {
        "data-item": "btn-tableActions-option",
        ariaLabel: "Fix tables"
      }
    }
  ];
  function renderTableActions(tableActionsItem2) {
    return vue.h(TableActions, {
      options: tableActionsOptions2,
      onSelect: (event) => {
        closeDropdown(tableActionsItem2);
        const { command: command2 } = event;
        superToolbar.emitCommand({ item: tableActionsItem2, argument: { command: command2 } });
      }
    });
  }
  const alignment2 = useToolbarItem({
    type: "dropdown",
    name: "textAlign",
    tooltip: toolbarTexts2.textAlign,
    icon: toolbarIcons2.alignLeft,
    command: "setTextAlign",
    hasCaret: true,
    markName: "textAlign",
    labelAttr: "textAlign",
    suppressActiveHighlight: true,
    attributes: {
      ariaLabel: "Text align"
    },
    options: [
      {
        type: "render",
        render: () => {
          const handleSelect = (e) => {
            closeDropdown(alignment2);
            const buttonWithCommand = { ...alignment2, command: "setTextAlign" };
            buttonWithCommand.command = "setTextAlign";
            superToolbar.emitCommand({ item: buttonWithCommand, argument: e });
            setAlignmentIcon(alignment2, e);
          };
          return vue.h("div", {}, [
            vue.h(AlignmentButtons, {
              onSelect: handleSelect
            })
          ]);
        },
        key: "alignment"
      }
    ],
    onActivate: ({ textAlign }) => {
      setAlignmentIcon(alignment2, textAlign);
    },
    onDeactivate: () => {
      setAlignmentIcon(alignment2, "left");
    }
  });
  const setAlignmentIcon = (alignment3, e) => {
    let alignValue = e === "both" ? "justify" : e;
    let icons2 = {
      left: toolbarIcons2.alignLeft,
      right: toolbarIcons2.alignRight,
      center: toolbarIcons2.alignCenter,
      justify: toolbarIcons2.alignJustify
    };
    let icon = icons2[alignValue] ?? icons2.left;
    alignment3.icon.value = icon;
  };
  const bulletedList = useToolbarItem({
    type: "button",
    name: "list",
    command: "toggleBulletList",
    icon: toolbarIcons2.bulletList,
    tooltip: toolbarTexts2.bulletList,
    restoreEditorFocus: true,
    attributes: {
      ariaLabel: "Bullet list"
    }
  });
  const numberedList = useToolbarItem({
    type: "button",
    name: "numberedlist",
    command: "toggleOrderedList",
    icon: toolbarIcons2.numberedList,
    tooltip: toolbarTexts2.numberedList,
    restoreEditorFocus: true,
    attributes: {
      ariaLabel: "Numbered list"
    }
  });
  const indentLeft = useToolbarItem({
    type: "button",
    name: "indentleft",
    command: "decreaseTextIndent",
    icon: toolbarIcons2.indentLeft,
    tooltip: toolbarTexts2.indentLeft,
    disabled: false,
    attributes: {
      ariaLabel: "Left indent"
    }
  });
  const indentRight = useToolbarItem({
    type: "button",
    name: "indentright",
    command: "increaseTextIndent",
    icon: toolbarIcons2.indentRight,
    tooltip: toolbarTexts2.indentRight,
    disabled: false,
    attributes: {
      ariaLabel: "Right indent"
    }
  });
  const overflow = useToolbarItem({
    type: "overflow",
    name: "overflow",
    command: null,
    icon: toolbarIcons2.overflow,
    disabled: false,
    attributes: {
      ariaLabel: "Overflow items"
    }
  });
  const zoom = useToolbarItem({
    type: "dropdown",
    name: "zoom",
    allowWithoutEditor: true,
    tooltip: toolbarTexts2.zoom,
    defaultLabel: "100%",
    label: "100%",
    hasCaret: true,
    command: "setZoom",
    isWide: true,
    inlineTextInputVisible: false,
    hasInlineTextInput: true,
    attributes: {
      ariaLabel: "Zoom"
    },
    options: [
      { label: "50%", key: 0.5, props: { "data-item": "btn-zoom-option" } },
      { label: "75%", key: 0.75, props: { "data-item": "btn-zoom-option" } },
      { label: "90%", key: 0.9, props: { "data-item": "btn-zoom-option" } },
      { label: "100%", key: 1, props: { "data-item": "btn-zoom-option" } },
      { label: "125%", key: 1.25, props: { "data-item": "btn-zoom-option" } },
      { label: "150%", key: 1.5, props: { "data-item": "btn-zoom-option" } },
      { label: "200%", key: 2, props: { "data-item": "btn-zoom-option" } }
    ],
    onActivate: ({ zoom: value }) => {
      if (!value) return;
      zoom.label.value = value;
    }
  });
  const undo2 = useToolbarItem({
    type: "button",
    name: "undo",
    disabled: true,
    tooltip: toolbarTexts2.undo,
    command: "undo",
    icon: toolbarIcons2.undo,
    group: "left",
    attributes: {
      ariaLabel: "Undo"
    }
  });
  const redo2 = useToolbarItem({
    type: "button",
    disabled: true,
    name: "redo",
    tooltip: toolbarTexts2.redo,
    command: "redo",
    icon: toolbarIcons2.redo,
    group: "left",
    attributes: {
      ariaLabel: "Redo"
    }
  });
  const toggleTrackChanges = useToolbarItem({
    type: "button",
    disabled: false,
    name: "toggleTrackChanges",
    tooltip: toolbarTexts2.trackChanges,
    command: "toggleTrackChanges",
    icon: toolbarIcons2.trackChanges,
    group: "left",
    attributes: {
      ariaLabel: "Track changes"
    }
  });
  const acceptTrackedChangeBySelection = useToolbarItem({
    type: "button",
    disabled: false,
    name: "acceptTrackedChangeBySelection",
    tooltip: toolbarTexts2.trackChangesAccept,
    command: "acceptTrackedChangeFromToolbar",
    icon: toolbarIcons2.trackChangesAccept,
    group: "left",
    attributes: {
      ariaLabel: "Accept tracked changes"
    }
  });
  const rejectTrackedChangeOnSelection = useToolbarItem({
    type: "button",
    disabled: false,
    name: "rejectTrackedChangeOnSelection",
    tooltip: toolbarTexts2.trackChangesReject,
    command: "rejectTrackedChangeFromToolbar",
    icon: toolbarIcons2.trackChangesReject,
    group: "left",
    attributes: {
      ariaLabel: "Reject tracked changes"
    }
  });
  const toggleTrackChangesOriginal = useToolbarItem({
    type: "button",
    disabled: false,
    name: "toggleTrackChangesShowOriginal",
    tooltip: toolbarTexts2.trackChangesOriginal,
    command: "toggleTrackChangesShowOriginal",
    icon: toolbarIcons2.trackChangesOriginal,
    group: "left",
    attributes: {
      ariaLabel: "Toggle tracked changes show original"
    }
  });
  const toggleTrackChangesFinal = useToolbarItem({
    type: "button",
    disabled: false,
    name: "toggleTrackChangesShowFinal",
    tooltip: toolbarTexts2.trackChangesFinal,
    command: "toggleTrackChangesShowFinal",
    icon: toolbarIcons2.trackChangesFinal,
    group: "left",
    attributes: {
      ariaLabel: "Toggle tracked changes show final"
    }
  });
  const clearFormatting = useToolbarItem({
    type: "button",
    name: "clearFormatting",
    command: "clearFormat",
    tooltip: toolbarTexts2.clearFormatting,
    icon: toolbarIcons2.clearFormatting,
    attributes: {
      ariaLabel: "Clear formatting"
    }
  });
  const copyFormat = useToolbarItem({
    type: "button",
    name: "copyFormat",
    tooltip: toolbarTexts2.copyFormat,
    icon: toolbarIcons2.copyFormat,
    command: "copyFormat",
    attributes: {
      ariaLabel: "Copy formatting"
    }
  });
  const getDocumentOptionsAfterRole = (role2, documentOptions2) => {
    if (role2 === "editor") return documentOptions2;
    else if (role2 === "suggester") return documentOptions2.filter((option) => option.value === "suggesting");
    else return documentOptions2.filter((option) => option.value === "viewing");
  };
  const getDefaultLabel = (role2) => {
    if (role2 === "editor") return "Editing";
    else if (role2 === "suggester") return "Suggesting";
    else return "Viewing";
  };
  const documentMode = useToolbarItem({
    type: "dropdown",
    name: "documentMode",
    command: "setDocumentMode",
    allowWithoutEditor: true,
    icon: toolbarIcons2.documentMode,
    defaultLabel: getDefaultLabel(role),
    label: getDefaultLabel(role),
    hasCaret: role === "editor",
    isWide: true,
    style: { display: "flex", justifyContent: "flex-end" },
    inlineTextInputVisible: false,
    hasInlineTextInput: false,
    group: "right",
    disabled: role !== "editor",
    attributes: {
      dropdownPosition: "right",
      className: "toolbar-item--doc-mode",
      ariaLabel: "Document mode"
    },
    options: [
      {
        type: "render",
        render: () => renderDocumentMode(documentMode)
      }
    ]
  });
  const documentOptions = [
    {
      label: toolbarTexts2.documentEditingMode,
      value: "editing",
      icon: toolbarIcons2.documentEditingMode,
      description: toolbarTexts2.documentEditingModeDescription
    },
    {
      label: toolbarTexts2.documentSuggestingMode,
      value: "suggesting",
      icon: toolbarIcons2.documentSuggestingMode,
      description: toolbarTexts2.documentSuggestingModeDescription
    },
    {
      label: toolbarTexts2.documentViewingMode,
      value: "viewing",
      icon: toolbarIcons2.documentViewingMode,
      description: toolbarTexts2.documentViewingModeDescription
    }
  ];
  function renderDocumentMode(renderDocumentButton) {
    const optionsAfterRole = getDocumentOptionsAfterRole(role, documentOptions);
    return vue.h(DocumentMode, {
      options: optionsAfterRole,
      onSelect: (item) => {
        closeDropdown(renderDocumentButton);
        const { label, icon } = item;
        documentMode.label.value = label;
        documentMode.icon.value = icon;
        superToolbar.emitCommand({ item: documentMode, argument: label });
      }
    });
  }
  const controlSizes = /* @__PURE__ */ new Map([
    ["separator", 20],
    ["zoom", 71],
    ["fontFamily", 118],
    ["fontSize", 57],
    ["textAlign", 40],
    ["linkedStyles", 142],
    ["documentMode", 47],
    ["ai", 32],
    ["default", 32]
  ]);
  const ruler = useToolbarItem({
    type: "button",
    name: "ruler",
    command: "toggleRuler",
    icon: toolbarIcons2.ruler,
    tooltip: toolbarTexts2.ruler,
    attributes: {
      ariaLabel: "Ruler"
    }
  });
  const selectedLinkedStyle = vue.ref(null);
  const linkedStyles = useToolbarItem({
    type: "dropdown",
    name: "linkedStyles",
    command: "setLinkedStyle",
    tooltip: toolbarTexts2.linkedStyles,
    icon: toolbarIcons2.paintbrush,
    defaultLabel: toolbarTexts2.formatText,
    label: toolbarTexts2.formatText,
    hasCaret: true,
    isWide: true,
    style: { width: "140px" },
    suppressActiveHighlight: true,
    disabled: false,
    attributes: {
      className: "toolbar-item--linked-styles",
      ariaLabel: "Linked styles"
    },
    options: [
      {
        type: "render",
        key: "linkedStyle",
        render: () => {
          const handleSelect = (style2) => {
            closeDropdown(linkedStyles);
            const itemWithCommand = { ...linkedStyles, command: "setLinkedStyle" };
            superToolbar.emitCommand({ item: itemWithCommand, argument: style2 });
            selectedLinkedStyle.value = style2.id;
          };
          return vue.h("div", {}, [
            vue.h(LinkedStyle, {
              editor: superToolbar.activeEditor,
              onSelect: handleSelect,
              selectedOption: selectedLinkedStyle.value
            })
          ]);
        }
      }
    ],
    onActivate: ({ styleId }) => {
      const styles = getQuickFormatList(superToolbar.activeEditor);
      const selectedStyle = styles?.find((style2) => style2.id === styleId);
      linkedStyles.label.value = selectedStyle && selectedStyle.id !== "Normal" ? selectedStyle.definition.attrs.name : toolbarTexts2.formatText;
      linkedStyles.disabled.value = false;
    },
    onDeactivate: () => {
      linkedStyles.disabled.value = true;
      linkedStyles.label.value = toolbarTexts2.formatText;
    }
  });
  const renderIcon = (value, selectedValue) => {
    if (selectedValue.value != value) return;
    return vue.h("div", { innerHTML: checkIconSvg, class: "dropdown-select-icon" });
  };
  const lineHeight2 = useToolbarItem({
    type: "dropdown",
    name: "lineHeight",
    tooltip: toolbarTexts2.lineHeight,
    icon: toolbarIcons2.lineHeight,
    hasCaret: false,
    hasInlineTextInput: false,
    inlineTextInputVisible: false,
    suppressActiveHighlight: true,
    isWide: false,
    command: "setLineHeight",
    dropdownValueKey: "key",
    selectedValue: "1",
    attributes: {
      ariaLabel: "Line height"
    },
    options: [1, 1.15, 1.5, 2, 2.5, 3].map((lineHeightValue) => {
      return {
        label: lineHeightValue.toFixed(2),
        key: lineHeightValue,
        icon: () => renderIcon(lineHeightValue, lineHeight2.selectedValue),
        props: { "data-item": "btn-lineHeight-option" }
      };
    })
  });
  const breakpoints = {
    sm: 768,
    md: 1024,
    xl: 1410
  };
  const stickyItemsWidth = 120;
  const toolbarPadding = 32;
  const itemsToHideXL = ["linkedStyles", "clearFormatting", "copyFormat", "ruler"];
  const itemsToHideSM = ["zoom", "fontFamily", "fontSize", "redo"];
  let toolbarItems = [
    undo2,
    redo2,
    // Dev - tracked changes
    // toggleTrackChanges,
    acceptTrackedChangeBySelection,
    rejectTrackedChangeOnSelection,
    // toggleTrackChangesOriginal,
    // toggleTrackChangesFinal,
    zoom,
    fontButton,
    separator,
    fontSize2,
    separator,
    bold,
    italic,
    underline,
    strikethrough,
    colorButton,
    highlight,
    separator,
    link,
    image,
    tableItem,
    tableActionsItem,
    separator,
    alignment2,
    bulletedList,
    numberedList,
    indentLeft,
    indentRight,
    lineHeight2,
    separator,
    linkedStyles,
    separator,
    ruler,
    copyFormat,
    clearFormatting,
    aiButton,
    overflow,
    documentMode
  ];
  if (!superToolbar.config?.superdoc?.config?.modules?.ai) {
    toolbarItems = toolbarItems.filter((item) => item.name.value !== "ai");
  }
  if (availableWidth <= breakpoints.md && hideButtons) {
    toolbarItems = toolbarItems.filter((item) => item.type !== "separator");
  }
  if (superToolbar.config.mode !== "docx") {
    const getLinkedStylesIndex = toolbarItems.findIndex((item) => item.name.value === "linkedStyles");
    toolbarItems.splice(getLinkedStylesIndex - 1, 2);
    const filterItems = ["ruler", "zoom", "undo", "redo"];
    toolbarItems = toolbarItems.filter((item) => !filterItems.includes(item.name.value));
  }
  const devItems = [toggleTrackChanges, toggleTrackChangesOriginal, toggleTrackChangesFinal];
  if (!isDev) {
    if (role === "viewer") {
      devItems.push(...[acceptTrackedChangeBySelection, rejectTrackedChangeOnSelection]);
    }
    toolbarItems = toolbarItems.filter((item) => !devItems.includes(item));
  }
  const toolbarItemsSticky = [search2, undo2, overflow, documentMode].map((item) => item.name);
  const isStickyItem = (item) => toolbarItemsSticky.includes(item.name);
  const overflowItems = [];
  const visibleItems = [];
  let totalWidth = toolbarPadding + stickyItemsWidth;
  toolbarItems.forEach((item) => {
    const itemWidth = controlSizes.get(item.name.value) || controlSizes.get("default");
    if (availableWidth < breakpoints.xl && itemsToHideXL.includes(item.name.value) && hideButtons) {
      overflowItems.push(item);
      if (item.name.value === "linkedStyles") {
        const linkedStylesIdx = toolbarItems.findIndex((item2) => item2.name.value === "linkedStyles");
        toolbarItems.splice(linkedStylesIdx + 1, 1);
      }
      return;
    }
    if (availableWidth < breakpoints.sm && itemsToHideSM.includes(item.name.value) && hideButtons) {
      overflowItems.push(item);
      return;
    }
    if (isStickyItem(item)) {
      visibleItems.push(item);
      totalWidth += itemWidth;
      return;
    }
    if (totalWidth < availableWidth || !hideButtons) {
      visibleItems.push(item);
      totalWidth += itemWidth;
    } else {
      overflowItems.push(item);
    }
  });
  return {
    defaultItems: visibleItems,
    overflowItems: overflowItems.filter((item) => item.type !== "separator")
  };
};
function plugin$1(options) {
  let _bPrefix = ".";
  let _ePrefix = "__";
  let _mPrefix = "--";
  let c2;
  if (options) {
    let t = options.blockPrefix;
    if (t) {
      _bPrefix = t;
    }
    t = options.elementPrefix;
    if (t) {
      _ePrefix = t;
    }
    t = options.modifierPrefix;
    if (t) {
      _mPrefix = t;
    }
  }
  const _plugin = {
    install(instance) {
      c2 = instance.c;
      const ctx2 = instance.context;
      ctx2.bem = {};
      ctx2.bem.b = null;
      ctx2.bem.els = null;
    }
  };
  function b2(arg) {
    let memorizedB;
    let memorizedE;
    return {
      before(ctx2) {
        memorizedB = ctx2.bem.b;
        memorizedE = ctx2.bem.els;
        ctx2.bem.els = null;
      },
      after(ctx2) {
        ctx2.bem.b = memorizedB;
        ctx2.bem.els = memorizedE;
      },
      $({ context, props }) {
        arg = typeof arg === "string" ? arg : arg({ context, props });
        context.bem.b = arg;
        return `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}`;
      }
    };
  }
  function e(arg) {
    let memorizedE;
    return {
      before(ctx2) {
        memorizedE = ctx2.bem.els;
      },
      after(ctx2) {
        ctx2.bem.els = memorizedE;
      },
      $({ context, props }) {
        arg = typeof arg === "string" ? arg : arg({ context, props });
        context.bem.els = arg.split(",").map((v) => v.trim());
        return context.bem.els.map((el) => `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${_ePrefix}${el}`).join(", ");
      }
    };
  }
  function m2(arg) {
    return {
      $({ context, props }) {
        arg = typeof arg === "string" ? arg : arg({ context, props });
        const modifiers2 = arg.split(",").map((v) => v.trim());
        function elementToSelector(el) {
          return modifiers2.map((modifier) => `&${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${el !== void 0 ? `${_ePrefix}${el}` : ""}${_mPrefix}${modifier}`).join(", ");
        }
        const els = context.bem.els;
        if (els !== null) {
          if (vue.process$1.env.NODE_ENV !== "production" && els.length >= 2) {
            throw Error(`[css-render/plugin-bem]: m(${arg}) is invalid, using modifier inside multiple elements is not allowed`);
          }
          return elementToSelector(els[0]);
        } else {
          return elementToSelector();
        }
      }
    };
  }
  function notM(arg) {
    return {
      $({ context, props }) {
        arg = typeof arg === "string" ? arg : arg({ context, props });
        const els = context.bem.els;
        if (vue.process$1.env.NODE_ENV !== "production" && els !== null && els.length >= 2) {
          throw Error(`[css-render/plugin-bem]: notM(${arg}) is invalid, using modifier inside multiple elements is not allowed`);
        }
        return `&:not(${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${els !== null && els.length > 0 ? `${_ePrefix}${els[0]}` : ""}${_mPrefix}${arg})`;
      }
    };
  }
  const cB2 = ((...args) => c2(b2(args[0]), args[1], args[2]));
  const cE2 = ((...args) => c2(e(args[0]), args[1], args[2]));
  const cM2 = ((...args) => c2(m2(args[0]), args[1], args[2]));
  const cNotM2 = ((...args) => c2(notM(args[0]), args[1], args[2]));
  Object.assign(_plugin, {
    cB: cB2,
    cE: cE2,
    cM: cM2,
    cNotM: cNotM2
  });
  return _plugin;
}
function ampCount(selector) {
  let cnt = 0;
  for (let i = 0; i < selector.length; ++i) {
    if (selector[i] === "&")
      ++cnt;
  }
  return cnt;
}
const separatorRegex = /\s*,(?![^(]*\))\s*/g;
const extraSpaceRegex = /\s+/g;
function resolveSelectorWithAmp(amp, selector) {
  const nextAmp = [];
  selector.split(separatorRegex).forEach((partialSelector) => {
    let round2 = ampCount(partialSelector);
    if (!round2) {
      amp.forEach((partialAmp) => {
        nextAmp.push(
          // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
          (partialAmp && partialAmp + " ") + partialSelector
        );
      });
      return;
    } else if (round2 === 1) {
      amp.forEach((partialAmp) => {
        nextAmp.push(partialSelector.replace("&", partialAmp));
      });
      return;
    }
    let partialNextAmp = [
      partialSelector
    ];
    while (round2--) {
      const nextPartialNextAmp = [];
      partialNextAmp.forEach((selectorItr) => {
        amp.forEach((partialAmp) => {
          nextPartialNextAmp.push(selectorItr.replace("&", partialAmp));
        });
      });
      partialNextAmp = nextPartialNextAmp;
    }
    partialNextAmp.forEach((part) => nextAmp.push(part));
  });
  return nextAmp;
}
function resolveSelector(amp, selector) {
  const nextAmp = [];
  selector.split(separatorRegex).forEach((partialSelector) => {
    amp.forEach((partialAmp) => {
      nextAmp.push((partialAmp && partialAmp + " ") + partialSelector);
    });
  });
  return nextAmp;
}
function parseSelectorPath(selectorPaths) {
  let amp = [""];
  selectorPaths.forEach((selector) => {
    selector = selector && selector.trim();
    if (
      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
      !selector
    ) {
      return;
    }
    if (selector.includes("&")) {
      amp = resolveSelectorWithAmp(amp, selector);
    } else {
      amp = resolveSelector(amp, selector);
    }
  });
  return amp.join(", ").replace(extraSpaceRegex, " ");
}
function removeElement(el) {
  if (!el)
    return;
  const parentElement = el.parentElement;
  if (parentElement)
    parentElement.removeChild(el);
}
function queryElement(id, parent) {
  return (parent !== null && parent !== void 0 ? parent : document.head).querySelector(`style[cssr-id="${id}"]`);
}
function createElement(id) {
  const el = document.createElement("style");
  el.setAttribute("cssr-id", id);
  return el;
}
function isMediaOrSupports(selector) {
  if (!selector)
    return false;
  return /^\s*@(s|m)/.test(selector);
}
const kebabRegex = /[A-Z]/g;
function kebabCase(pattern) {
  return pattern.replace(kebabRegex, (match) => "-" + match.toLowerCase());
}
function unwrapProperty(prop, indent = "  ") {
  if (typeof prop === "object" && prop !== null) {
    return " {\n" + Object.entries(prop).map((v) => {
      return indent + `  ${kebabCase(v[0])}: ${v[1]};`;
    }).join("\n") + "\n" + indent + "}";
  }
  return `: ${prop};`;
}
function unwrapProperties(props, instance, params2) {
  if (typeof props === "function") {
    return props({
      context: instance.context,
      props: params2
    });
  }
  return props;
}
function createStyle(selector, props, instance, params2) {
  if (!props)
    return "";
  const unwrappedProps = unwrapProperties(props, instance, params2);
  if (!unwrappedProps)
    return "";
  if (typeof unwrappedProps === "string") {
    return `${selector} {
${unwrappedProps}
}`;
  }
  const propertyNames = Object.keys(unwrappedProps);
  if (propertyNames.length === 0) {
    if (instance.config.keepEmptyBlock)
      return selector + " {\n}";
    return "";
  }
  const statements = selector ? [
    selector + " {"
  ] : [];
  propertyNames.forEach((propertyName) => {
    const property2 = unwrappedProps[propertyName];
    if (propertyName === "raw") {
      statements.push("\n" + property2 + "\n");
      return;
    }
    propertyName = kebabCase(propertyName);
    if (property2 !== null && property2 !== void 0) {
      statements.push(`  ${propertyName}${unwrapProperty(property2)}`);
    }
  });
  if (selector) {
    statements.push("}");
  }
  return statements.join("\n");
}
function loopCNodeListWithCallback(children, options, callback) {
  if (!children)
    return;
  children.forEach((child) => {
    if (Array.isArray(child)) {
      loopCNodeListWithCallback(child, options, callback);
    } else if (typeof child === "function") {
      const grandChildren = child(options);
      if (Array.isArray(grandChildren)) {
        loopCNodeListWithCallback(grandChildren, options, callback);
      } else if (grandChildren) {
        callback(grandChildren);
      }
    } else if (child) {
      callback(child);
    }
  });
}
function traverseCNode(node, selectorPaths, styles, instance, params2) {
  const $ = node.$;
  let blockSelector = "";
  if (!$ || typeof $ === "string") {
    if (isMediaOrSupports($)) {
      blockSelector = $;
    } else {
      selectorPaths.push($);
    }
  } else if (typeof $ === "function") {
    const selector2 = $({
      context: instance.context,
      props: params2
    });
    if (isMediaOrSupports(selector2)) {
      blockSelector = selector2;
    } else {
      selectorPaths.push(selector2);
    }
  } else {
    if ($.before)
      $.before(instance.context);
    if (!$.$ || typeof $.$ === "string") {
      if (isMediaOrSupports($.$)) {
        blockSelector = $.$;
      } else {
        selectorPaths.push($.$);
      }
    } else if ($.$) {
      const selector2 = $.$({
        context: instance.context,
        props: params2
      });
      if (isMediaOrSupports(selector2)) {
        blockSelector = selector2;
      } else {
        selectorPaths.push(selector2);
      }
    }
  }
  const selector = parseSelectorPath(selectorPaths);
  const style2 = createStyle(selector, node.props, instance, params2);
  if (blockSelector) {
    styles.push(`${blockSelector} {`);
  } else if (style2.length) {
    styles.push(style2);
  }
  if (node.children) {
    loopCNodeListWithCallback(node.children, {
      context: instance.context,
      props: params2
    }, (childNode) => {
      if (typeof childNode === "string") {
        const style3 = createStyle(selector, { raw: childNode }, instance, params2);
        styles.push(style3);
      } else {
        traverseCNode(childNode, selectorPaths, styles, instance, params2);
      }
    });
  }
  selectorPaths.pop();
  if (blockSelector) {
    styles.push("}");
  }
  if ($ && $.after)
    $.after(instance.context);
}
function render$1(node, instance, props) {
  const styles = [];
  traverseCNode(node, [], styles, instance, props);
  return styles.join("\n\n");
}
function murmur2(str) {
  var h2 = 0;
  var k2, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
if (typeof window !== "undefined") {
  window.__cssrContext = {};
}
function unmount(instance, node, id, parent) {
  const { els } = node;
  if (id === void 0) {
    els.forEach(removeElement);
    node.els = [];
  } else {
    const target = queryElement(id, parent);
    if (target && els.includes(target)) {
      removeElement(target);
      node.els = els.filter((el) => el !== target);
    }
  }
}
function addElementToList(els, target) {
  els.push(target);
}
function mount(instance, node, id, props, head, force, anchorMetaName, parent, ssrAdapter2) {
  let style2;
  if (id === void 0) {
    style2 = node.render(props);
    id = murmur2(style2);
  }
  if (ssrAdapter2) {
    ssrAdapter2.adapter(id, style2 !== null && style2 !== void 0 ? style2 : node.render(props));
    return;
  }
  if (parent === void 0) {
    parent = document.head;
  }
  const queriedTarget = queryElement(id, parent);
  if (queriedTarget !== null && !force) {
    return queriedTarget;
  }
  const target = queriedTarget !== null && queriedTarget !== void 0 ? queriedTarget : createElement(id);
  if (style2 === void 0)
    style2 = node.render(props);
  target.textContent = style2;
  if (queriedTarget !== null)
    return queriedTarget;
  if (anchorMetaName) {
    const anchorMetaEl = parent.querySelector(`meta[name="${anchorMetaName}"]`);
    if (anchorMetaEl) {
      parent.insertBefore(target, anchorMetaEl);
      addElementToList(node.els, target);
      return target;
    }
  }
  if (head) {
    parent.insertBefore(target, parent.querySelector("style, link"));
  } else {
    parent.appendChild(target);
  }
  addElementToList(node.els, target);
  return target;
}
function wrappedRender(props) {
  return render$1(this, this.instance, props);
}
function wrappedMount(options = {}) {
  const { id, ssr, props, head = false, force = false, anchorMetaName, parent } = options;
  const targetElement = mount(this.instance, this, id, props, head, force, anchorMetaName, parent, ssr);
  return targetElement;
}
function wrappedUnmount(options = {}) {
  const { id, parent } = options;
  unmount(this.instance, this, id, parent);
}
const createCNode = function(instance, $, props, children) {
  return {
    instance,
    $,
    props,
    children,
    els: [],
    render: wrappedRender,
    mount: wrappedMount,
    unmount: wrappedUnmount
  };
};
const c$2 = function(instance, $, props, children) {
  if (Array.isArray($)) {
    return createCNode(instance, { $: null }, null, $);
  } else if (Array.isArray(props)) {
    return createCNode(instance, $, null, props);
  } else if (Array.isArray(children)) {
    return createCNode(instance, $, props, children);
  } else {
    return createCNode(instance, $, props, null);
  }
};
function CssRender(config = {}) {
  const cssr2 = {
    c: ((...args) => c$2(cssr2, ...args)),
    use: (plugin2, ...args) => plugin2.install(cssr2, ...args),
    find: queryElement,
    context: {},
    config
  };
  return cssr2;
}
function exists(id, ssr) {
  if (id === void 0)
    return false;
  if (ssr) {
    const { context: { ids } } = ssr;
    return ids.has(id);
  }
  return queryElement(id) !== null;
}
const namespace = "n";
const prefix$1 = `.${namespace}-`;
const elementPrefix = "__";
const modifierPrefix = "--";
const cssr = CssRender();
const plugin = plugin$1({
  blockPrefix: prefix$1,
  elementPrefix,
  modifierPrefix
});
cssr.use(plugin);
const {
  c: c$1,
  find
} = cssr;
const {
  cB,
  cE,
  cM,
  cNotM
} = plugin;
function insideModal(style2) {
  return c$1(({
    props: {
      bPrefix
    }
  }) => `${bPrefix || prefix$1}modal, ${bPrefix || prefix$1}drawer`, [style2]);
}
function insidePopover(style2) {
  return c$1(({
    props: {
      bPrefix
    }
  }) => `${bPrefix || prefix$1}popover`, [style2]);
}
const cCB = (...args) => {
  return c$1(">", [cB(...args)]);
};
function createKey(prefix2, suffix2) {
  return prefix2 + (suffix2 === "default" ? "" : suffix2.replace(/^[a-z]/, (startChar) => startChar.toUpperCase()));
}
let onceCbs = [];
const paramsMap = /* @__PURE__ */ new WeakMap();
function flushOnceCallbacks() {
  onceCbs.forEach((cb) => cb(...paramsMap.get(cb)));
  onceCbs = [];
}
function beforeNextFrameOnce(cb, ...params2) {
  paramsMap.set(cb, params2);
  if (onceCbs.includes(cb))
    return;
  onceCbs.push(cb) === 1 && requestAnimationFrame(flushOnceCallbacks);
}
function happensIn(e, dataSetPropName) {
  let { target } = e;
  while (target) {
    if (target.dataset) {
      if (target.dataset[dataSetPropName] !== void 0)
        return true;
    }
    target = target.parentElement;
  }
  return false;
}
function getPreciseEventTarget(event) {
  return event.composedPath()[0] || null;
}
function depx(value) {
  if (typeof value === "string") {
    if (value.endsWith("px")) {
      return Number(value.slice(0, value.length - 2));
    }
    return Number(value);
  }
  return value;
}
function pxfy(value) {
  if (value === void 0 || value === null)
    return void 0;
  if (typeof value === "number")
    return `${value}px`;
  if (value.endsWith("px"))
    return value;
  return `${value}px`;
}
function getMargin(value, position) {
  const parts = value.trim().split(/\s+/g);
  const margin = {
    top: parts[0]
  };
  switch (parts.length) {
    case 1:
      margin.right = parts[0];
      margin.bottom = parts[0];
      margin.left = parts[0];
      break;
    case 2:
      margin.right = parts[1];
      margin.left = parts[1];
      margin.bottom = parts[0];
      break;
    case 3:
      margin.right = parts[1];
      margin.bottom = parts[2];
      margin.left = parts[1];
      break;
    case 4:
      margin.right = parts[1];
      margin.bottom = parts[2];
      margin.left = parts[3];
      break;
    default:
      throw new Error("[seemly/getMargin]:" + value + " is not a valid value.");
  }
  return margin;
}
const colors = {
  aliceblue: "#F0F8FF",
  antiquewhite: "#FAEBD7",
  aqua: "#0FF",
  aquamarine: "#7FFFD4",
  azure: "#F0FFFF",
  beige: "#F5F5DC",
  bisque: "#FFE4C4",
  black: "#000",
  blanchedalmond: "#FFEBCD",
  blue: "#00F",
  blueviolet: "#8A2BE2",
  brown: "#A52A2A",
  burlywood: "#DEB887",
  cadetblue: "#5F9EA0",
  chartreuse: "#7FFF00",
  chocolate: "#D2691E",
  coral: "#FF7F50",
  cornflowerblue: "#6495ED",
  cornsilk: "#FFF8DC",
  crimson: "#DC143C",
  cyan: "#0FF",
  darkblue: "#00008B",
  darkcyan: "#008B8B",
  darkgoldenrod: "#B8860B",
  darkgray: "#A9A9A9",
  darkgrey: "#A9A9A9",
  darkgreen: "#006400",
  darkkhaki: "#BDB76B",
  darkmagenta: "#8B008B",
  darkolivegreen: "#556B2F",
  darkorange: "#FF8C00",
  darkorchid: "#9932CC",
  darkred: "#8B0000",
  darksalmon: "#E9967A",
  darkseagreen: "#8FBC8F",
  darkslateblue: "#483D8B",
  darkslategray: "#2F4F4F",
  darkslategrey: "#2F4F4F",
  darkturquoise: "#00CED1",
  darkviolet: "#9400D3",
  deeppink: "#FF1493",
  deepskyblue: "#00BFFF",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1E90FF",
  firebrick: "#B22222",
  floralwhite: "#FFFAF0",
  forestgreen: "#228B22",
  fuchsia: "#F0F",
  gainsboro: "#DCDCDC",
  ghostwhite: "#F8F8FF",
  gold: "#FFD700",
  goldenrod: "#DAA520",
  gray: "#808080",
  grey: "#808080",
  green: "#008000",
  greenyellow: "#ADFF2F",
  honeydew: "#F0FFF0",
  hotpink: "#FF69B4",
  indianred: "#CD5C5C",
  indigo: "#4B0082",
  ivory: "#FFFFF0",
  khaki: "#F0E68C",
  lavender: "#E6E6FA",
  lavenderblush: "#FFF0F5",
  lawngreen: "#7CFC00",
  lemonchiffon: "#FFFACD",
  lightblue: "#ADD8E6",
  lightcoral: "#F08080",
  lightcyan: "#E0FFFF",
  lightgoldenrodyellow: "#FAFAD2",
  lightgray: "#D3D3D3",
  lightgrey: "#D3D3D3",
  lightgreen: "#90EE90",
  lightpink: "#FFB6C1",
  lightsalmon: "#FFA07A",
  lightseagreen: "#20B2AA",
  lightskyblue: "#87CEFA",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#B0C4DE",
  lightyellow: "#FFFFE0",
  lime: "#0F0",
  limegreen: "#32CD32",
  linen: "#FAF0E6",
  magenta: "#F0F",
  maroon: "#800000",
  mediumaquamarine: "#66CDAA",
  mediumblue: "#0000CD",
  mediumorchid: "#BA55D3",
  mediumpurple: "#9370DB",
  mediumseagreen: "#3CB371",
  mediumslateblue: "#7B68EE",
  mediumspringgreen: "#00FA9A",
  mediumturquoise: "#48D1CC",
  mediumvioletred: "#C71585",
  midnightblue: "#191970",
  mintcream: "#F5FFFA",
  mistyrose: "#FFE4E1",
  moccasin: "#FFE4B5",
  navajowhite: "#FFDEAD",
  navy: "#000080",
  oldlace: "#FDF5E6",
  olive: "#808000",
  olivedrab: "#6B8E23",
  orange: "#FFA500",
  orangered: "#FF4500",
  orchid: "#DA70D6",
  palegoldenrod: "#EEE8AA",
  palegreen: "#98FB98",
  paleturquoise: "#AFEEEE",
  palevioletred: "#DB7093",
  papayawhip: "#FFEFD5",
  peachpuff: "#FFDAB9",
  peru: "#CD853F",
  pink: "#FFC0CB",
  plum: "#DDA0DD",
  powderblue: "#B0E0E6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#F00",
  rosybrown: "#BC8F8F",
  royalblue: "#4169E1",
  saddlebrown: "#8B4513",
  salmon: "#FA8072",
  sandybrown: "#F4A460",
  seagreen: "#2E8B57",
  seashell: "#FFF5EE",
  sienna: "#A0522D",
  silver: "#C0C0C0",
  skyblue: "#87CEEB",
  slateblue: "#6A5ACD",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#FFFAFA",
  springgreen: "#00FF7F",
  steelblue: "#4682B4",
  tan: "#D2B48C",
  teal: "#008080",
  thistle: "#D8BFD8",
  tomato: "#FF6347",
  turquoise: "#40E0D0",
  violet: "#EE82EE",
  wheat: "#F5DEB3",
  white: "#FFF",
  whitesmoke: "#F5F5F5",
  yellow: "#FF0",
  yellowgreen: "#9ACD32",
  transparent: "#0000"
};
function hsv2rgb(h2, s, v) {
  s /= 100;
  v /= 100;
  let f = (n, k2 = (n + h2 / 60) % 6) => v - v * s * Math.max(Math.min(k2, 4 - k2, 1), 0);
  return [f(5) * 255, f(3) * 255, f(1) * 255];
}
function hsl2rgb(h2, s, l) {
  s /= 100;
  l /= 100;
  let a = s * Math.min(l, 1 - l);
  let f = (n, k2 = (n + h2 / 30) % 12) => l - a * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
  return [f(0) * 255, f(8) * 255, f(4) * 255];
}
const prefix = "^\\s*";
const suffix = "\\s*$";
const percent = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))%\\s*";
const float = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))\\s*";
const hex = "([0-9A-Fa-f])";
const dhex = "([0-9A-Fa-f]{2})";
const hslRegex = new RegExp(`${prefix}hsl\\s*\\(${float},${percent},${percent}\\)${suffix}`);
const hsvRegex = new RegExp(`${prefix}hsv\\s*\\(${float},${percent},${percent}\\)${suffix}`);
const hslaRegex = new RegExp(`${prefix}hsla\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
const hsvaRegex = new RegExp(`${prefix}hsva\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
const rgbRegex = new RegExp(`${prefix}rgb\\s*\\(${float},${float},${float}\\)${suffix}`);
const rgbaRegex = new RegExp(`${prefix}rgba\\s*\\(${float},${float},${float},${float}\\)${suffix}`);
const sHexRegex = new RegExp(`${prefix}#${hex}${hex}${hex}${suffix}`);
const hexRegex = new RegExp(`${prefix}#${dhex}${dhex}${dhex}${suffix}`);
const sHexaRegex = new RegExp(`${prefix}#${hex}${hex}${hex}${hex}${suffix}`);
const hexaRegex = new RegExp(`${prefix}#${dhex}${dhex}${dhex}${dhex}${suffix}`);
function parseHex(value) {
  return parseInt(value, 16);
}
function hsla(color) {
  try {
    let i;
    if (i = hslaRegex.exec(color)) {
      return [
        roundDeg(i[1]),
        roundPercent(i[5]),
        roundPercent(i[9]),
        roundAlpha(i[13])
      ];
    } else if (i = hslRegex.exec(color)) {
      return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
    }
    throw new Error(`[seemly/hsla]: Invalid color value ${color}.`);
  } catch (e) {
    throw e;
  }
}
function hsva(color) {
  try {
    let i;
    if (i = hsvaRegex.exec(color)) {
      return [
        roundDeg(i[1]),
        roundPercent(i[5]),
        roundPercent(i[9]),
        roundAlpha(i[13])
      ];
    } else if (i = hsvRegex.exec(color)) {
      return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
    }
    throw new Error(`[seemly/hsva]: Invalid color value ${color}.`);
  } catch (e) {
    throw e;
  }
}
function rgba(color) {
  try {
    let i;
    if (i = hexRegex.exec(color)) {
      return [parseHex(i[1]), parseHex(i[2]), parseHex(i[3]), 1];
    } else if (i = rgbRegex.exec(color)) {
      return [roundChannel(i[1]), roundChannel(i[5]), roundChannel(i[9]), 1];
    } else if (i = rgbaRegex.exec(color)) {
      return [
        roundChannel(i[1]),
        roundChannel(i[5]),
        roundChannel(i[9]),
        roundAlpha(i[13])
      ];
    } else if (i = sHexRegex.exec(color)) {
      return [
        parseHex(i[1] + i[1]),
        parseHex(i[2] + i[2]),
        parseHex(i[3] + i[3]),
        1
      ];
    } else if (i = hexaRegex.exec(color)) {
      return [
        parseHex(i[1]),
        parseHex(i[2]),
        parseHex(i[3]),
        roundAlpha(parseHex(i[4]) / 255)
      ];
    } else if (i = sHexaRegex.exec(color)) {
      return [
        parseHex(i[1] + i[1]),
        parseHex(i[2] + i[2]),
        parseHex(i[3] + i[3]),
        roundAlpha(parseHex(i[4] + i[4]) / 255)
      ];
    } else if (color in colors) {
      return rgba(colors[color]);
    } else if (hslRegex.test(color) || hslaRegex.test(color)) {
      const [h2, s, l, a] = hsla(color);
      return [...hsl2rgb(h2, s, l), a];
    } else if (hsvRegex.test(color) || hsvaRegex.test(color)) {
      const [h2, s, v, a] = hsva(color);
      return [...hsv2rgb(h2, s, v), a];
    }
    throw new Error(`[seemly/rgba]: Invalid color value ${color}.`);
  } catch (e) {
    throw e;
  }
}
function normalizeAlpha(alphaValue) {
  return alphaValue > 1 ? 1 : alphaValue < 0 ? 0 : alphaValue;
}
function stringifyRgba(r2, g2, b2, a) {
  return `rgba(${roundChannel(r2)}, ${roundChannel(g2)}, ${roundChannel(b2)}, ${normalizeAlpha(a)})`;
}
function compositeChannel(v1, a1, v2, a2, a) {
  return roundChannel((v1 * a1 * (1 - a2) + v2 * a2) / a);
}
function composite(background, overlay2) {
  if (!Array.isArray(background))
    background = rgba(background);
  if (!Array.isArray(overlay2))
    overlay2 = rgba(overlay2);
  const a1 = background[3];
  const a2 = overlay2[3];
  const alpha = roundAlpha(a1 + a2 - a1 * a2);
  return stringifyRgba(compositeChannel(background[0], a1, overlay2[0], a2, alpha), compositeChannel(background[1], a1, overlay2[1], a2, alpha), compositeChannel(background[2], a1, overlay2[2], a2, alpha), alpha);
}
function changeColor(base2, options) {
  const [r2, g2, b2, a = 1] = Array.isArray(base2) ? base2 : rgba(base2);
  if (typeof options.alpha === "number") {
    return stringifyRgba(r2, g2, b2, options.alpha);
  }
  return stringifyRgba(r2, g2, b2, a);
}
function scaleColor(base2, options) {
  const [r2, g2, b2, a = 1] = Array.isArray(base2) ? base2 : rgba(base2);
  const { lightness = 1, alpha = 1 } = options;
  return toRgbaString([r2 * lightness, g2 * lightness, b2 * lightness, a * alpha]);
}
function roundAlpha(value) {
  const v = Math.round(Number(value) * 100) / 100;
  if (v > 1)
    return 1;
  if (v < 0)
    return 0;
  return v;
}
function roundDeg(value) {
  const v = Math.round(Number(value));
  if (v >= 360)
    return 0;
  if (v < 0)
    return 0;
  return v;
}
function roundChannel(value) {
  const v = Math.round(Number(value));
  if (v > 255)
    return 255;
  if (v < 0)
    return 0;
  return v;
}
function roundPercent(value) {
  const v = Math.round(Number(value));
  if (v > 100)
    return 100;
  if (v < 0)
    return 0;
  return v;
}
function toRgbaString(base2) {
  const [r2, g2, b2] = base2;
  if (3 in base2) {
    return `rgba(${roundChannel(r2)}, ${roundChannel(g2)}, ${roundChannel(b2)}, ${roundAlpha(base2[3])})`;
  }
  return `rgba(${roundChannel(r2)}, ${roundChannel(g2)}, ${roundChannel(b2)}, 1)`;
}
function createId(length2 = 8) {
  return Math.random().toString(16).slice(2, 2 + length2);
}
function repeat(count, v) {
  const ret = [];
  for (let i = 0; i < count; ++i) {
    ret.push(v);
  }
  return ret;
}
function getEventTarget(e) {
  const path = e.composedPath();
  return path[0];
}
const traps = {
  mousemoveoutside: /* @__PURE__ */ new WeakMap(),
  clickoutside: /* @__PURE__ */ new WeakMap()
};
function createTrapHandler(name, el, originalHandler) {
  if (name === "mousemoveoutside") {
    const moveHandler = (e) => {
      if (el.contains(getEventTarget(e)))
        return;
      originalHandler(e);
    };
    return {
      mousemove: moveHandler,
      touchstart: moveHandler
    };
  } else if (name === "clickoutside") {
    let mouseDownOutside = false;
    const downHandler = (e) => {
      mouseDownOutside = !el.contains(getEventTarget(e));
    };
    const upHanlder = (e) => {
      if (!mouseDownOutside)
        return;
      if (el.contains(getEventTarget(e)))
        return;
      originalHandler(e);
    };
    return {
      mousedown: downHandler,
      mouseup: upHanlder,
      touchstart: downHandler,
      touchend: upHanlder
    };
  }
  console.error(
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    `[evtd/create-trap-handler]: name \`${name}\` is invalid. This could be a bug of evtd.`
  );
  return {};
}
function ensureTrapHandlers(name, el, handler) {
  const handlers2 = traps[name];
  let elHandlers = handlers2.get(el);
  if (elHandlers === void 0) {
    handlers2.set(el, elHandlers = /* @__PURE__ */ new WeakMap());
  }
  let trapHandler = elHandlers.get(handler);
  if (trapHandler === void 0) {
    elHandlers.set(handler, trapHandler = createTrapHandler(name, el, handler));
  }
  return trapHandler;
}
function trapOn(name, el, handler, options) {
  if (name === "mousemoveoutside" || name === "clickoutside") {
    const trapHandlers = ensureTrapHandlers(name, el, handler);
    Object.keys(trapHandlers).forEach((key2) => {
      on(key2, document, trapHandlers[key2], options);
    });
    return true;
  }
  return false;
}
function trapOff(name, el, handler, options) {
  if (name === "mousemoveoutside" || name === "clickoutside") {
    const trapHandlers = ensureTrapHandlers(name, el, handler);
    Object.keys(trapHandlers).forEach((key2) => {
      off(key2, document, trapHandlers[key2], options);
    });
    return true;
  }
  return false;
}
function createDelegate() {
  if (typeof window === "undefined") {
    return {
      on: () => {
      },
      off: () => {
      }
    };
  }
  const propagationStopped = /* @__PURE__ */ new WeakMap();
  const immediatePropagationStopped = /* @__PURE__ */ new WeakMap();
  function trackPropagation() {
    propagationStopped.set(this, true);
  }
  function trackImmediate() {
    propagationStopped.set(this, true);
    immediatePropagationStopped.set(this, true);
  }
  function spy(event, propName, fn2) {
    const source = event[propName];
    event[propName] = function() {
      fn2.apply(event, arguments);
      return source.apply(event, arguments);
    };
    return event;
  }
  function unspy(event, propName) {
    event[propName] = Event.prototype[propName];
  }
  const currentTargets = /* @__PURE__ */ new WeakMap();
  const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, "currentTarget");
  function getCurrentTarget() {
    var _a;
    return (_a = currentTargets.get(this)) !== null && _a !== void 0 ? _a : null;
  }
  function defineCurrentTarget(event, getter) {
    if (currentTargetDescriptor === void 0)
      return;
    Object.defineProperty(event, "currentTarget", {
      configurable: true,
      enumerable: true,
      get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get
    });
  }
  const phaseToTypeToElToHandlers = {
    bubble: {},
    capture: {}
  };
  const typeToWindowEventHandlers = {};
  function createUnifiedHandler() {
    const delegeteHandler = function(e) {
      const { type, eventPhase, bubbles } = e;
      const target = getEventTarget(e);
      if (eventPhase === 2)
        return;
      const phase = eventPhase === 1 ? "capture" : "bubble";
      let cursor = target;
      const path = [];
      while (true) {
        if (cursor === null)
          cursor = window;
        path.push(cursor);
        if (cursor === window) {
          break;
        }
        cursor = cursor.parentNode || null;
      }
      const captureElToHandlers = phaseToTypeToElToHandlers.capture[type];
      const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type];
      spy(e, "stopPropagation", trackPropagation);
      spy(e, "stopImmediatePropagation", trackImmediate);
      defineCurrentTarget(e, getCurrentTarget);
      if (phase === "capture") {
        if (captureElToHandlers === void 0)
          return;
        for (let i = path.length - 1; i >= 0; --i) {
          if (propagationStopped.has(e))
            break;
          const target2 = path[i];
          const handlers2 = captureElToHandlers.get(target2);
          if (handlers2 !== void 0) {
            currentTargets.set(e, target2);
            for (const handler of handlers2) {
              if (immediatePropagationStopped.has(e))
                break;
              handler(e);
            }
          }
          if (i === 0 && !bubbles && bubbleElToHandlers !== void 0) {
            const bubbleHandlers = bubbleElToHandlers.get(target2);
            if (bubbleHandlers !== void 0) {
              for (const handler of bubbleHandlers) {
                if (immediatePropagationStopped.has(e))
                  break;
                handler(e);
              }
            }
          }
        }
      } else if (phase === "bubble") {
        if (bubbleElToHandlers === void 0)
          return;
        for (let i = 0; i < path.length; ++i) {
          if (propagationStopped.has(e))
            break;
          const target2 = path[i];
          const handlers2 = bubbleElToHandlers.get(target2);
          if (handlers2 !== void 0) {
            currentTargets.set(e, target2);
            for (const handler of handlers2) {
              if (immediatePropagationStopped.has(e))
                break;
              handler(e);
            }
          }
        }
      }
      unspy(e, "stopPropagation");
      unspy(e, "stopImmediatePropagation");
      defineCurrentTarget(e);
    };
    delegeteHandler.displayName = "evtdUnifiedHandler";
    return delegeteHandler;
  }
  function createUnifiedWindowEventHandler() {
    const delegateHandler = function(e) {
      const { type, eventPhase } = e;
      if (eventPhase !== 2)
        return;
      const handlers2 = typeToWindowEventHandlers[type];
      if (handlers2 === void 0)
        return;
      handlers2.forEach((handler) => handler(e));
    };
    delegateHandler.displayName = "evtdUnifiedWindowEventHandler";
    return delegateHandler;
  }
  const unifiedHandler = createUnifiedHandler();
  const unfiendWindowEventHandler = createUnifiedWindowEventHandler();
  function ensureElToHandlers(phase, type) {
    const phaseHandlers = phaseToTypeToElToHandlers[phase];
    if (phaseHandlers[type] === void 0) {
      phaseHandlers[type] = /* @__PURE__ */ new Map();
      window.addEventListener(type, unifiedHandler, phase === "capture");
    }
    return phaseHandlers[type];
  }
  function ensureWindowEventHandlers(type) {
    const windowEventHandlers = typeToWindowEventHandlers[type];
    if (windowEventHandlers === void 0) {
      typeToWindowEventHandlers[type] = /* @__PURE__ */ new Set();
      window.addEventListener(type, unfiendWindowEventHandler);
    }
    return typeToWindowEventHandlers[type];
  }
  function ensureHandlers(elToHandlers, el) {
    let elHandlers = elToHandlers.get(el);
    if (elHandlers === void 0) {
      elToHandlers.set(el, elHandlers = /* @__PURE__ */ new Set());
    }
    return elHandlers;
  }
  function handlerExist(el, phase, type, handler) {
    const elToHandlers = phaseToTypeToElToHandlers[phase][type];
    if (elToHandlers !== void 0) {
      const handlers2 = elToHandlers.get(el);
      if (handlers2 !== void 0) {
        if (handlers2.has(handler))
          return true;
      }
    }
    return false;
  }
  function windowEventHandlerExist(type, handler) {
    const handlers2 = typeToWindowEventHandlers[type];
    if (handlers2 !== void 0) {
      if (handlers2.has(handler)) {
        return true;
      }
    }
    return false;
  }
  function on2(type, el, handler, options) {
    let mergedHandler;
    if (typeof options === "object" && options.once === true) {
      mergedHandler = (e) => {
        off2(type, el, mergedHandler, options);
        handler(e);
      };
    } else {
      mergedHandler = handler;
    }
    const trapped = trapOn(type, el, mergedHandler, options);
    if (trapped)
      return;
    const phase = options === true || typeof options === "object" && options.capture === true ? "capture" : "bubble";
    const elToHandlers = ensureElToHandlers(phase, type);
    const handlers2 = ensureHandlers(elToHandlers, el);
    if (!handlers2.has(mergedHandler))
      handlers2.add(mergedHandler);
    if (el === window) {
      const windowEventHandlers = ensureWindowEventHandlers(type);
      if (!windowEventHandlers.has(mergedHandler)) {
        windowEventHandlers.add(mergedHandler);
      }
    }
  }
  function off2(type, el, handler, options) {
    const trapped = trapOff(type, el, handler, options);
    if (trapped)
      return;
    const capture = options === true || typeof options === "object" && options.capture === true;
    const phase = capture ? "capture" : "bubble";
    const elToHandlers = ensureElToHandlers(phase, type);
    const handlers2 = ensureHandlers(elToHandlers, el);
    if (el === window) {
      const mirrorPhase = capture ? "bubble" : "capture";
      if (!handlerExist(el, mirrorPhase, type, handler) && windowEventHandlerExist(type, handler)) {
        const windowEventHandlers = typeToWindowEventHandlers[type];
        windowEventHandlers.delete(handler);
        if (windowEventHandlers.size === 0) {
          window.removeEventListener(type, unfiendWindowEventHandler);
          typeToWindowEventHandlers[type] = void 0;
        }
      }
    }
    if (handlers2.has(handler))
      handlers2.delete(handler);
    if (handlers2.size === 0) {
      elToHandlers.delete(el);
    }
    if (elToHandlers.size === 0) {
      window.removeEventListener(type, unifiedHandler, phase === "capture");
      phaseToTypeToElToHandlers[phase][type] = void 0;
    }
  }
  return {
    on: on2,
    off: off2
  };
}
const { on, off } = createDelegate();
function useFalseUntilTruthy(originalRef) {
  const currentRef = vue.ref(!!originalRef.value);
  if (currentRef.value)
    return vue.readonly(currentRef);
  const stop = vue.watch(originalRef, (value) => {
    if (value) {
      currentRef.value = true;
      stop();
    }
  });
  return vue.readonly(currentRef);
}
function useMemo(getterOrOptions) {
  const computedValueRef = vue.computed(getterOrOptions);
  const valueRef = vue.ref(computedValueRef.value);
  vue.watch(computedValueRef, (value) => {
    valueRef.value = value;
  });
  if (typeof getterOrOptions === "function") {
    return valueRef;
  } else {
    return {
      __v_isRef: true,
      get value() {
        return valueRef.value;
      },
      set value(v) {
        getterOrOptions.set(v);
      }
    };
  }
}
function hasInstance() {
  return vue.getCurrentInstance() !== null;
}
const isBrowser$2 = typeof window !== "undefined";
let fontsReady;
let isFontReady;
const init = () => {
  var _a, _b;
  fontsReady = isBrowser$2 ? (_b = (_a = document) === null || _a === void 0 ? void 0 : _a.fonts) === null || _b === void 0 ? void 0 : _b.ready : void 0;
  isFontReady = false;
  if (fontsReady !== void 0) {
    void fontsReady.then(() => {
      isFontReady = true;
    });
  } else {
    isFontReady = true;
  }
};
init();
function onFontsReady(cb) {
  if (isFontReady)
    return;
  let deactivated = false;
  vue.onMounted(() => {
    if (!isFontReady) {
      fontsReady === null || fontsReady === void 0 ? void 0 : fontsReady.then(() => {
        if (deactivated)
          return;
        cb();
      });
    }
  });
  vue.onBeforeUnmount(() => {
    deactivated = true;
  });
}
function useMergedState(controlledStateRef, uncontrolledStateRef) {
  vue.watch(controlledStateRef, (value) => {
    if (value !== void 0) {
      uncontrolledStateRef.value = value;
    }
  });
  return vue.computed(() => {
    if (controlledStateRef.value === void 0) {
      return uncontrolledStateRef.value;
    }
    return controlledStateRef.value;
  });
}
function isMounted() {
  const isMounted2 = vue.ref(false);
  vue.onMounted(() => {
    isMounted2.value = true;
  });
  return vue.readonly(isMounted2);
}
function useCompitable(reactive, keys2) {
  return vue.computed(() => {
    for (const key2 of keys2) {
      if (reactive[key2] !== void 0)
        return reactive[key2];
    }
    return reactive[keys2[keys2.length - 1]];
  });
}
const isIos = (typeof window === "undefined" ? false : /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) && // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
!window.MSStream;
function useIsIos() {
  return isIos;
}
function useKeyboard(options = {}, enabledRef) {
  const state = vue.reactive({
    ctrl: false,
    command: false,
    win: false,
    shift: false,
    tab: false
  });
  const { keydown, keyup } = options;
  const keydownHandler2 = (e) => {
    switch (e.key) {
      case "Control":
        state.ctrl = true;
        break;
      case "Meta":
        state.command = true;
        state.win = true;
        break;
      case "Shift":
        state.shift = true;
        break;
      case "Tab":
        state.tab = true;
        break;
    }
    if (keydown !== void 0) {
      Object.keys(keydown).forEach((key2) => {
        if (key2 !== e.key)
          return;
        const handler = keydown[key2];
        if (typeof handler === "function") {
          handler(e);
        } else {
          const { stop = false, prevent = false } = handler;
          if (stop)
            e.stopPropagation();
          if (prevent)
            e.preventDefault();
          handler.handler(e);
        }
      });
    }
  };
  const keyupHandler = (e) => {
    switch (e.key) {
      case "Control":
        state.ctrl = false;
        break;
      case "Meta":
        state.command = false;
        state.win = false;
        break;
      case "Shift":
        state.shift = false;
        break;
      case "Tab":
        state.tab = false;
        break;
    }
    if (keyup !== void 0) {
      Object.keys(keyup).forEach((key2) => {
        if (key2 !== e.key)
          return;
        const handler = keyup[key2];
        if (typeof handler === "function") {
          handler(e);
        } else {
          const { stop = false, prevent = false } = handler;
          if (stop)
            e.stopPropagation();
          if (prevent)
            e.preventDefault();
          handler.handler(e);
        }
      });
    }
  };
  const setup = () => {
    if (enabledRef === void 0 || enabledRef.value) {
      on("keydown", document, keydownHandler2);
      on("keyup", document, keyupHandler);
    }
    if (enabledRef !== void 0) {
      vue.watch(enabledRef, (value) => {
        if (value) {
          on("keydown", document, keydownHandler2);
          on("keyup", document, keyupHandler);
        } else {
          off("keydown", document, keydownHandler2);
          off("keyup", document, keyupHandler);
        }
      });
    }
  };
  if (hasInstance()) {
    vue.onBeforeMount(setup);
    vue.onBeforeUnmount(() => {
      if (enabledRef === void 0 || enabledRef.value) {
        off("keydown", document, keydownHandler2);
        off("keyup", document, keyupHandler);
      }
    });
  } else {
    setup();
  }
  return vue.readonly(state);
}
function createInjectionKey(key2) {
  return key2;
}
const internalSelectionMenuBodyInjectionKey = createInjectionKey("n-internal-select-menu-body");
const drawerBodyInjectionKey = createInjectionKey("n-drawer-body");
const modalBodyInjectionKey = createInjectionKey("n-modal-body");
const popoverBodyInjectionKey = createInjectionKey("n-popover-body");
const teleportDisabled = "__disabled__";
function useAdjustedTo(props) {
  const modal = vue.inject(modalBodyInjectionKey, null);
  const drawer = vue.inject(drawerBodyInjectionKey, null);
  const popover = vue.inject(popoverBodyInjectionKey, null);
  const selectMenu = vue.inject(internalSelectionMenuBodyInjectionKey, null);
  const fullscreenElementRef = vue.ref();
  if (typeof document !== "undefined") {
    fullscreenElementRef.value = document.fullscreenElement;
    const handleFullscreenChange = () => {
      fullscreenElementRef.value = document.fullscreenElement;
    };
    vue.onMounted(() => {
      on("fullscreenchange", document, handleFullscreenChange);
    });
    vue.onBeforeUnmount(() => {
      off("fullscreenchange", document, handleFullscreenChange);
    });
  }
  return useMemo(() => {
    var _a;
    const {
      to
    } = props;
    if (to !== void 0) {
      if (to === false) return teleportDisabled;
      if (to === true) return fullscreenElementRef.value || "body";
      return to;
    }
    if (modal === null || modal === void 0 ? void 0 : modal.value) {
      return (_a = modal.value.$el) !== null && _a !== void 0 ? _a : modal.value;
    }
    if (drawer === null || drawer === void 0 ? void 0 : drawer.value) return drawer.value;
    if (popover === null || popover === void 0 ? void 0 : popover.value) return popover.value;
    if (selectMenu === null || selectMenu === void 0 ? void 0 : selectMenu.value) return selectMenu.value;
    return to !== null && to !== void 0 ? to : fullscreenElementRef.value || "body";
  });
}
useAdjustedTo.tdkey = teleportDisabled;
useAdjustedTo.propTo = {
  type: [String, Object, Boolean],
  default: void 0
};
function useDeferredTrue(valueRef, delay, shouldDelayRef) {
  const delayedRef = vue.ref(valueRef.value);
  let timerId = null;
  vue.watch(valueRef, (value) => {
    if (timerId !== null) window.clearTimeout(timerId);
    if (value === true) {
      if (shouldDelayRef && !shouldDelayRef.value) {
        delayedRef.value = true;
      } else {
        timerId = window.setTimeout(() => {
          delayedRef.value = true;
        }, delay);
      }
    } else {
      delayedRef.value = false;
    }
  });
  return delayedRef;
}
const isBrowser$1 = typeof document !== "undefined" && typeof window !== "undefined";
let houdiniRegistered = false;
function useHoudini() {
  if (!isBrowser$1) return;
  if (!window.CSS) return;
  if (!houdiniRegistered) {
    houdiniRegistered = true;
    if ("registerProperty" in (window === null || window === void 0 ? void 0 : window.CSS)) {
      try {
        ;
        CSS.registerProperty({
          name: "--n-color-start",
          syntax: "<color>",
          inherits: false,
          initialValue: "#0000"
        });
        CSS.registerProperty({
          name: "--n-color-end",
          syntax: "<color>",
          inherits: false,
          initialValue: "#0000"
        });
      } catch (_a) {
      }
    }
  }
}
function useReactivated(callback) {
  const isDeactivatedRef = {
    isDeactivated: false
  };
  let activateStateInitialized = false;
  vue.onActivated(() => {
    isDeactivatedRef.isDeactivated = false;
    if (!activateStateInitialized) {
      activateStateInitialized = true;
      return;
    }
    callback();
  });
  vue.onDeactivated(() => {
    isDeactivatedRef.isDeactivated = true;
    if (!activateStateInitialized) {
      activateStateInitialized = true;
    }
  });
  return isDeactivatedRef;
}
function getSlot(scope, slots, slotName = "default") {
  const slot = slots[slotName];
  if (slot === void 0) {
    throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
  }
  return slot();
}
function flatten$2(vNodes, filterCommentNode = true, result = []) {
  vNodes.forEach((vNode) => {
    if (vNode === null)
      return;
    if (typeof vNode !== "object") {
      if (typeof vNode === "string" || typeof vNode === "number") {
        result.push(vue.createTextVNode(String(vNode)));
      }
      return;
    }
    if (Array.isArray(vNode)) {
      flatten$2(vNode, filterCommentNode, result);
      return;
    }
    if (vNode.type === vue.Fragment) {
      if (vNode.children === null)
        return;
      if (Array.isArray(vNode.children)) {
        flatten$2(vNode.children, filterCommentNode, result);
      }
    } else if (vNode.type !== vue.Comment) {
      result.push(vNode);
    }
  });
  return result;
}
function getFirstVNode(scope, slots, slotName = "default") {
  const slot = slots[slotName];
  if (slot === void 0) {
    throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
  }
  const content = flatten$2(slot());
  if (content.length === 1) {
    return content[0];
  } else {
    throw new Error(`[vueuc/${scope}]: slot[${slotName}] should have exactly one child.`);
  }
}
let viewMeasurer = null;
function ensureViewBoundingRect() {
  if (viewMeasurer === null) {
    viewMeasurer = document.getElementById("v-binder-view-measurer");
    if (viewMeasurer === null) {
      viewMeasurer = document.createElement("div");
      viewMeasurer.id = "v-binder-view-measurer";
      const { style: style2 } = viewMeasurer;
      style2.position = "fixed";
      style2.left = "0";
      style2.right = "0";
      style2.top = "0";
      style2.bottom = "0";
      style2.pointerEvents = "none";
      style2.visibility = "hidden";
      document.body.appendChild(viewMeasurer);
    }
  }
  return viewMeasurer.getBoundingClientRect();
}
function getPointRect(x, y2) {
  const viewRect = ensureViewBoundingRect();
  return {
    top: y2,
    left: x,
    height: 0,
    width: 0,
    right: viewRect.width - x,
    bottom: viewRect.height - y2
  };
}
function getRect(el) {
  const elRect = el.getBoundingClientRect();
  const viewRect = ensureViewBoundingRect();
  return {
    left: elRect.left - viewRect.left,
    top: elRect.top - viewRect.top,
    bottom: viewRect.height + viewRect.top - elRect.bottom,
    right: viewRect.width + viewRect.left - elRect.right,
    width: elRect.width,
    height: elRect.height
  };
}
function getParentNode(node) {
  if (node.nodeType === 9) {
    return null;
  }
  return node.parentNode;
}
function getScrollParent(node) {
  if (node === null)
    return null;
  const parentNode2 = getParentNode(node);
  if (parentNode2 === null) {
    return null;
  }
  if (parentNode2.nodeType === 9) {
    return document;
  }
  if (parentNode2.nodeType === 1) {
    const { overflow, overflowX, overflowY } = getComputedStyle(parentNode2);
    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      return parentNode2;
    }
  }
  return getScrollParent(parentNode2);
}
const Binder = vue.defineComponent({
  name: "Binder",
  props: {
    syncTargetWithParent: Boolean,
    syncTarget: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    var _a;
    vue.provide("VBinder", (_a = vue.getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy);
    const VBinder = vue.inject("VBinder", null);
    const targetRef = vue.ref(null);
    const setTargetRef = (el) => {
      targetRef.value = el;
      if (VBinder && props.syncTargetWithParent) {
        VBinder.setTargetRef(el);
      }
    };
    let scrollableNodes = [];
    const ensureScrollListener = () => {
      let cursor = targetRef.value;
      while (true) {
        cursor = getScrollParent(cursor);
        if (cursor === null)
          break;
        scrollableNodes.push(cursor);
      }
      for (const el of scrollableNodes) {
        on("scroll", el, onScroll, true);
      }
    };
    const removeScrollListeners = () => {
      for (const el of scrollableNodes) {
        off("scroll", el, onScroll, true);
      }
      scrollableNodes = [];
    };
    const followerScrollListeners = /* @__PURE__ */ new Set();
    const addScrollListener = (listener) => {
      if (followerScrollListeners.size === 0) {
        ensureScrollListener();
      }
      if (!followerScrollListeners.has(listener)) {
        followerScrollListeners.add(listener);
      }
    };
    const removeScrollListener = (listener) => {
      if (followerScrollListeners.has(listener)) {
        followerScrollListeners.delete(listener);
      }
      if (followerScrollListeners.size === 0) {
        removeScrollListeners();
      }
    };
    const onScroll = () => {
      beforeNextFrameOnce(onScrollRaf);
    };
    const onScrollRaf = () => {
      followerScrollListeners.forEach((listener) => listener());
    };
    const followerResizeListeners = /* @__PURE__ */ new Set();
    const addResizeListener = (listener) => {
      if (followerResizeListeners.size === 0) {
        on("resize", window, onResize);
      }
      if (!followerResizeListeners.has(listener)) {
        followerResizeListeners.add(listener);
      }
    };
    const removeResizeListener = (listener) => {
      if (followerResizeListeners.has(listener)) {
        followerResizeListeners.delete(listener);
      }
      if (followerResizeListeners.size === 0) {
        off("resize", window, onResize);
      }
    };
    const onResize = () => {
      followerResizeListeners.forEach((listener) => listener());
    };
    vue.onBeforeUnmount(() => {
      off("resize", window, onResize);
      removeScrollListeners();
    });
    return {
      targetRef,
      setTargetRef,
      addScrollListener,
      removeScrollListener,
      addResizeListener,
      removeResizeListener
    };
  },
  render() {
    return getSlot("binder", this.$slots);
  }
});
const VTarget = vue.defineComponent({
  name: "Target",
  setup() {
    const { setTargetRef, syncTarget } = vue.inject("VBinder");
    const setTargetDirective = {
      mounted: setTargetRef,
      updated: setTargetRef
    };
    return {
      syncTarget,
      setTargetDirective
    };
  },
  render() {
    const { syncTarget, setTargetDirective } = this;
    if (syncTarget) {
      return vue.withDirectives(getFirstVNode("follower", this.$slots), [
        [setTargetDirective]
      ]);
    }
    return getFirstVNode("follower", this.$slots);
  }
});
const ctxKey$1 = "@@mmoContext";
const mousemoveoutside = {
  mounted(el, { value }) {
    el[ctxKey$1] = {
      handler: void 0
    };
    if (typeof value === "function") {
      el[ctxKey$1].handler = value;
      on("mousemoveoutside", el, value);
    }
  },
  updated(el, { value }) {
    const ctx2 = el[ctxKey$1];
    if (typeof value === "function") {
      if (ctx2.handler) {
        if (ctx2.handler !== value) {
          off("mousemoveoutside", el, ctx2.handler);
          ctx2.handler = value;
          on("mousemoveoutside", el, value);
        }
      } else {
        el[ctxKey$1].handler = value;
        on("mousemoveoutside", el, value);
      }
    } else {
      if (ctx2.handler) {
        off("mousemoveoutside", el, ctx2.handler);
        ctx2.handler = void 0;
      }
    }
  },
  unmounted(el) {
    const { handler } = el[ctxKey$1];
    if (handler) {
      off("mousemoveoutside", el, handler);
    }
    el[ctxKey$1].handler = void 0;
  }
};
const ctxKey = "@@coContext";
const clickoutside = {
  mounted(el, { value, modifiers: modifiers2 }) {
    el[ctxKey] = {
      handler: void 0
    };
    if (typeof value === "function") {
      el[ctxKey].handler = value;
      on("clickoutside", el, value, {
        capture: modifiers2.capture
      });
    }
  },
  updated(el, { value, modifiers: modifiers2 }) {
    const ctx2 = el[ctxKey];
    if (typeof value === "function") {
      if (ctx2.handler) {
        if (ctx2.handler !== value) {
          off("clickoutside", el, ctx2.handler, {
            capture: modifiers2.capture
          });
          ctx2.handler = value;
          on("clickoutside", el, value, {
            capture: modifiers2.capture
          });
        }
      } else {
        el[ctxKey].handler = value;
        on("clickoutside", el, value, {
          capture: modifiers2.capture
        });
      }
    } else {
      if (ctx2.handler) {
        off("clickoutside", el, ctx2.handler, {
          capture: modifiers2.capture
        });
        ctx2.handler = void 0;
      }
    }
  },
  unmounted(el, { modifiers: modifiers2 }) {
    const { handler } = el[ctxKey];
    if (handler) {
      off("clickoutside", el, handler, {
        capture: modifiers2.capture
      });
    }
    el[ctxKey].handler = void 0;
  }
};
function warn$2(location2, message) {
  console.error(`[vdirs/${location2}]: ${message}`);
}
class ZIndexManager {
  constructor() {
    this.elementZIndex = /* @__PURE__ */ new Map();
    this.nextZIndex = 2e3;
  }
  get elementCount() {
    return this.elementZIndex.size;
  }
  ensureZIndex(el, zIndex) {
    const { elementZIndex } = this;
    if (zIndex !== void 0) {
      el.style.zIndex = `${zIndex}`;
      elementZIndex.delete(el);
      return;
    }
    const { nextZIndex } = this;
    if (elementZIndex.has(el)) {
      const currentZIndex = elementZIndex.get(el);
      if (currentZIndex + 1 === this.nextZIndex)
        return;
    }
    el.style.zIndex = `${nextZIndex}`;
    elementZIndex.set(el, nextZIndex);
    this.nextZIndex = nextZIndex + 1;
    this.squashState();
  }
  unregister(el, zIndex) {
    const { elementZIndex } = this;
    if (elementZIndex.has(el)) {
      elementZIndex.delete(el);
    } else if (zIndex === void 0) {
      warn$2("z-index-manager/unregister-element", "Element not found when unregistering.");
    }
    this.squashState();
  }
  squashState() {
    const { elementCount } = this;
    if (!elementCount) {
      this.nextZIndex = 2e3;
    }
    if (this.nextZIndex - elementCount > 2500)
      this.rearrange();
  }
  rearrange() {
    const elementZIndexPair = Array.from(this.elementZIndex.entries());
    elementZIndexPair.sort((pair1, pair2) => {
      return pair1[1] - pair2[1];
    });
    this.nextZIndex = 2e3;
    elementZIndexPair.forEach((pair) => {
      const el = pair[0];
      const zIndex = this.nextZIndex++;
      if (`${zIndex}` !== el.style.zIndex)
        el.style.zIndex = `${zIndex}`;
    });
  }
}
const zIndexManager = new ZIndexManager();
const ctx = "@@ziContext";
const zindexable = {
  mounted(el, bindings) {
    const { value = {} } = bindings;
    const { zIndex, enabled } = value;
    el[ctx] = {
      enabled: !!enabled,
      initialized: false
    };
    if (enabled) {
      zIndexManager.ensureZIndex(el, zIndex);
      el[ctx].initialized = true;
    }
  },
  updated(el, bindings) {
    const { value = {} } = bindings;
    const { zIndex, enabled } = value;
    const cachedEnabled = el[ctx].enabled;
    if (enabled && !cachedEnabled) {
      zIndexManager.ensureZIndex(el, zIndex);
      el[ctx].initialized = true;
    }
    el[ctx].enabled = !!enabled;
  },
  unmounted(el, bindings) {
    if (!el[ctx].initialized)
      return;
    const { value = {} } = bindings;
    const { zIndex } = value;
    zIndexManager.unregister(el, zIndex);
  }
};
const ssrContextKey = "@css-render/vue3-ssr";
function createStyleString(id, style2) {
  return `<style cssr-id="${id}">
${style2}
</style>`;
}
function ssrAdapter(id, style2, ssrContext) {
  const { styles, ids } = ssrContext;
  if (ids.has(id))
    return;
  if (styles !== null) {
    ids.add(id);
    styles.push(createStyleString(id, style2));
  }
}
const isBrowser = typeof document !== "undefined";
function useSsrAdapter() {
  if (isBrowser)
    return void 0;
  const context = vue.inject(ssrContextKey, null);
  if (context === null)
    return void 0;
  return {
    adapter: (id, style2) => ssrAdapter(id, style2, context),
    context
  };
}
function warn$1(location2, message) {
  console.error(`[vueuc/${location2}]: ${message}`);
}
const { c } = CssRender();
const cssrAnchorMetaName$1 = "vueuc-style";
function resolveTo(selector) {
  if (typeof selector === "string") {
    return document.querySelector(selector);
  }
  return selector() || null;
}
const LazyTeleport = vue.defineComponent({
  name: "LazyTeleport",
  props: {
    to: {
      type: [String, Object],
      default: void 0
    },
    disabled: Boolean,
    show: {
      type: Boolean,
      required: true
    }
  },
  setup(props) {
    return {
      showTeleport: useFalseUntilTruthy(vue.toRef(props, "show")),
      mergedTo: vue.computed(() => {
        const { to } = props;
        return to !== null && to !== void 0 ? to : "body";
      })
    };
  },
  render() {
    return this.showTeleport ? this.disabled ? getSlot("lazy-teleport", this.$slots) : vue.h(vue.Teleport, {
      disabled: this.disabled,
      to: this.mergedTo
    }, getSlot("lazy-teleport", this.$slots)) : null;
  }
});
const oppositionPositions = {
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
};
const oppositeAligns = {
  start: "end",
  center: "center",
  end: "start"
};
const propToCompare = {
  top: "height",
  bottom: "height",
  left: "width",
  right: "width"
};
const transformOrigins = {
  "bottom-start": "top left",
  bottom: "top center",
  "bottom-end": "top right",
  "top-start": "bottom left",
  top: "bottom center",
  "top-end": "bottom right",
  "right-start": "top left",
  right: "center left",
  "right-end": "bottom left",
  "left-start": "top right",
  left: "center right",
  "left-end": "bottom right"
};
const overlapTransformOrigin = {
  "bottom-start": "bottom left",
  bottom: "bottom center",
  "bottom-end": "bottom right",
  "top-start": "top left",
  top: "top center",
  "top-end": "top right",
  "right-start": "top right",
  right: "center right",
  "right-end": "bottom right",
  "left-start": "top left",
  left: "center left",
  "left-end": "bottom left"
};
const oppositeAlignCssPositionProps = {
  "bottom-start": "right",
  "bottom-end": "left",
  "top-start": "right",
  "top-end": "left",
  "right-start": "bottom",
  "right-end": "top",
  "left-start": "bottom",
  "left-end": "top"
};
const keepOffsetDirection = {
  top: true,
  // top++
  bottom: false,
  // top--
  left: true,
  // left++
  right: false
  // left--
};
const cssPositionToOppositeAlign = {
  top: "end",
  bottom: "start",
  left: "end",
  right: "start"
};
function getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, shift2, flip2, overlap) {
  if (!flip2 || overlap) {
    return { placement, top: 0, left: 0 };
  }
  const [position, align] = placement.split("-");
  let properAlign = align !== null && align !== void 0 ? align : "center";
  let properOffset = {
    top: 0,
    left: 0
  };
  const deriveOffset = (oppositeAlignCssSizeProp, alignCssPositionProp, offsetVertically2) => {
    let left2 = 0;
    let top2 = 0;
    const diff = followerRect[oppositeAlignCssSizeProp] - targetRect[alignCssPositionProp] - targetRect[oppositeAlignCssSizeProp];
    if (diff > 0 && shift2) {
      if (offsetVertically2) {
        top2 = keepOffsetDirection[alignCssPositionProp] ? diff : -diff;
      } else {
        left2 = keepOffsetDirection[alignCssPositionProp] ? diff : -diff;
      }
    }
    return {
      left: left2,
      top: top2
    };
  };
  const offsetVertically = position === "left" || position === "right";
  if (properAlign !== "center") {
    const oppositeAlignCssPositionProp = oppositeAlignCssPositionProps[placement];
    const currentAlignCssPositionProp = oppositionPositions[oppositeAlignCssPositionProp];
    const oppositeAlignCssSizeProp = propToCompare[oppositeAlignCssPositionProp];
    if (followerRect[oppositeAlignCssSizeProp] > targetRect[oppositeAlignCssSizeProp]) {
      if (
        // current space is not enough
        // ----------[ target ]---------|
        // -------[     follower        ]
        targetRect[oppositeAlignCssPositionProp] + targetRect[oppositeAlignCssSizeProp] < followerRect[oppositeAlignCssSizeProp]
      ) {
        const followerOverTargetSize = (followerRect[oppositeAlignCssSizeProp] - targetRect[oppositeAlignCssSizeProp]) / 2;
        if (targetRect[oppositeAlignCssPositionProp] < followerOverTargetSize || targetRect[currentAlignCssPositionProp] < followerOverTargetSize) {
          if (targetRect[oppositeAlignCssPositionProp] < targetRect[currentAlignCssPositionProp]) {
            properAlign = oppositeAligns[align];
            properOffset = deriveOffset(oppositeAlignCssSizeProp, currentAlignCssPositionProp, offsetVertically);
          } else {
            properOffset = deriveOffset(oppositeAlignCssSizeProp, oppositeAlignCssPositionProp, offsetVertically);
          }
        } else {
          properAlign = "center";
        }
      }
    } else if (followerRect[oppositeAlignCssSizeProp] < targetRect[oppositeAlignCssSizeProp]) {
      if (targetRect[currentAlignCssPositionProp] < 0 && // opposite align has larger space
      // ------------[   target   ]
      // ----------------[follower]
      targetRect[oppositeAlignCssPositionProp] > targetRect[currentAlignCssPositionProp]) {
        properAlign = oppositeAligns[align];
      }
    }
  } else {
    const possibleAlternativeAlignCssPositionProp1 = position === "bottom" || position === "top" ? "left" : "top";
    const possibleAlternativeAlignCssPositionProp2 = oppositionPositions[possibleAlternativeAlignCssPositionProp1];
    const alternativeAlignCssSizeProp = propToCompare[possibleAlternativeAlignCssPositionProp1];
    const followerOverTargetSize = (followerRect[alternativeAlignCssSizeProp] - targetRect[alternativeAlignCssSizeProp]) / 2;
    if (
      // center is not enough
      // ----------- [ target ]--|
      // -------[     follower     ]
      targetRect[possibleAlternativeAlignCssPositionProp1] < followerOverTargetSize || targetRect[possibleAlternativeAlignCssPositionProp2] < followerOverTargetSize
    ) {
      if (targetRect[possibleAlternativeAlignCssPositionProp1] > targetRect[possibleAlternativeAlignCssPositionProp2]) {
        properAlign = cssPositionToOppositeAlign[possibleAlternativeAlignCssPositionProp1];
        properOffset = deriveOffset(alternativeAlignCssSizeProp, possibleAlternativeAlignCssPositionProp1, offsetVertically);
      } else {
        properAlign = cssPositionToOppositeAlign[possibleAlternativeAlignCssPositionProp2];
        properOffset = deriveOffset(alternativeAlignCssSizeProp, possibleAlternativeAlignCssPositionProp2, offsetVertically);
      }
    }
  }
  let properPosition = position;
  if (
    // space is not enough
    targetRect[position] < followerRect[propToCompare[position]] && // opposite position's space is larger
    targetRect[position] < targetRect[oppositionPositions[position]]
  ) {
    properPosition = oppositionPositions[position];
  }
  return {
    placement: properAlign !== "center" ? `${properPosition}-${properAlign}` : properPosition,
    left: properOffset.left,
    top: properOffset.top
  };
}
function getProperTransformOrigin(placement, overlap) {
  if (overlap)
    return overlapTransformOrigin[placement];
  return transformOrigins[placement];
}
function getOffset(placement, offsetRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap) {
  if (overlap) {
    switch (placement) {
      case "bottom-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left)}px`,
          transform: "translateY(-100%)"
        };
      case "bottom-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
          transform: "translateX(-100%) translateY(-100%)"
        };
      case "top-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left)}px`,
          transform: ""
        };
      case "top-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
          transform: "translateX(-100%)"
        };
      case "right-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
          transform: "translateX(-100%)"
        };
      case "right-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
          transform: "translateX(-100%) translateY(-100%)"
        };
      case "left-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left)}px`,
          transform: ""
        };
      case "left-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left)}px`,
          transform: "translateY(-100%)"
        };
      case "top":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
          transform: "translateX(-50%)"
        };
      case "right":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
          transform: "translateX(-100%) translateY(-50%)"
        };
      case "left":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left)}px`,
          transform: "translateY(-50%)"
        };
      case "bottom":
      default:
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
          transform: "translateX(-50%) translateY(-100%)"
        };
    }
  }
  switch (placement) {
    case "bottom-start":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
        transform: ""
      };
    case "bottom-end":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
        transform: "translateX(-100%)"
      };
    case "top-start":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
        transform: "translateY(-100%)"
      };
    case "top-end":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
        transform: "translateX(-100%) translateY(-100%)"
      };
    case "right-start":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
        transform: ""
      };
    case "right-end":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
        transform: "translateY(-100%)"
      };
    case "left-start":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
        transform: "translateX(-100%)"
      };
    case "left-end":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
        transform: "translateX(-100%) translateY(-100%)"
      };
    case "top":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2 + offsetLeftToStandardPlacement)}px`,
        transform: "translateY(-100%) translateX(-50%)"
      };
    case "right":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2 + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
        transform: "translateY(-50%)"
      };
    case "left":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2 + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
        transform: "translateY(-50%) translateX(-100%)"
      };
    case "bottom":
    default:
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2 + offsetLeftToStandardPlacement)}px`,
        transform: "translateX(-50%)"
      };
  }
}
const style$5 = c([
  c(".v-binder-follower-container", {
    position: "absolute",
    left: "0",
    right: "0",
    top: "0",
    height: "0",
    pointerEvents: "none",
    zIndex: "auto"
  }),
  c(".v-binder-follower-content", {
    position: "absolute",
    zIndex: "auto"
  }, [
    c("> *", {
      pointerEvents: "all"
    })
  ])
]);
const VFollower = vue.defineComponent({
  name: "Follower",
  inheritAttrs: false,
  props: {
    show: Boolean,
    enabled: {
      type: Boolean,
      default: void 0
    },
    placement: {
      type: String,
      default: "bottom"
    },
    syncTrigger: {
      type: Array,
      default: ["resize", "scroll"]
    },
    to: [String, Object],
    flip: {
      type: Boolean,
      default: true
    },
    internalShift: Boolean,
    x: Number,
    y: Number,
    width: String,
    minWidth: String,
    containerClass: String,
    teleportDisabled: Boolean,
    zindexable: {
      type: Boolean,
      default: true
    },
    zIndex: Number,
    overlap: Boolean
  },
  setup(props) {
    const VBinder = vue.inject("VBinder");
    const mergedEnabledRef = useMemo(() => {
      return props.enabled !== void 0 ? props.enabled : props.show;
    });
    const followerRef = vue.ref(null);
    const offsetContainerRef = vue.ref(null);
    const ensureListeners2 = () => {
      const { syncTrigger } = props;
      if (syncTrigger.includes("scroll")) {
        VBinder.addScrollListener(syncPosition);
      }
      if (syncTrigger.includes("resize")) {
        VBinder.addResizeListener(syncPosition);
      }
    };
    const removeListeners = () => {
      VBinder.removeScrollListener(syncPosition);
      VBinder.removeResizeListener(syncPosition);
    };
    vue.onMounted(() => {
      if (mergedEnabledRef.value) {
        syncPosition();
        ensureListeners2();
      }
    });
    const ssrAdapter2 = useSsrAdapter();
    style$5.mount({
      id: "vueuc/binder",
      head: true,
      anchorMetaName: cssrAnchorMetaName$1,
      ssr: ssrAdapter2
    });
    vue.onBeforeUnmount(() => {
      removeListeners();
    });
    onFontsReady(() => {
      if (mergedEnabledRef.value) {
        syncPosition();
      }
    });
    const syncPosition = () => {
      if (!mergedEnabledRef.value) {
        return;
      }
      const follower = followerRef.value;
      if (follower === null)
        return;
      const target = VBinder.targetRef;
      const { x, y: y2, overlap } = props;
      const targetRect = x !== void 0 && y2 !== void 0 ? getPointRect(x, y2) : getRect(target);
      follower.style.setProperty("--v-target-width", `${Math.round(targetRect.width)}px`);
      follower.style.setProperty("--v-target-height", `${Math.round(targetRect.height)}px`);
      const { width, minWidth, placement, internalShift, flip: flip2 } = props;
      follower.setAttribute("v-placement", placement);
      if (overlap) {
        follower.setAttribute("v-overlap", "");
      } else {
        follower.removeAttribute("v-overlap");
      }
      const { style: style2 } = follower;
      if (width === "target") {
        style2.width = `${targetRect.width}px`;
      } else if (width !== void 0) {
        style2.width = width;
      } else {
        style2.width = "";
      }
      if (minWidth === "target") {
        style2.minWidth = `${targetRect.width}px`;
      } else if (minWidth !== void 0) {
        style2.minWidth = minWidth;
      } else {
        style2.minWidth = "";
      }
      const followerRect = getRect(follower);
      const offsetContainerRect = getRect(offsetContainerRef.value);
      const { left: offsetLeftToStandardPlacement, top: offsetTopToStandardPlacement, placement: properPlacement } = getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, internalShift, flip2, overlap);
      const properTransformOrigin = getProperTransformOrigin(properPlacement, overlap);
      const { left: left2, top: top2, transform } = getOffset(properPlacement, offsetContainerRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap);
      follower.setAttribute("v-placement", properPlacement);
      follower.style.setProperty("--v-offset-left", `${Math.round(offsetLeftToStandardPlacement)}px`);
      follower.style.setProperty("--v-offset-top", `${Math.round(offsetTopToStandardPlacement)}px`);
      follower.style.transform = `translateX(${left2}) translateY(${top2}) ${transform}`;
      follower.style.setProperty("--v-transform-origin", properTransformOrigin);
      follower.style.transformOrigin = properTransformOrigin;
    };
    vue.watch(mergedEnabledRef, (value) => {
      if (value) {
        ensureListeners2();
        syncOnNextTick();
      } else {
        removeListeners();
      }
    });
    const syncOnNextTick = () => {
      vue.nextTick().then(syncPosition).catch((e) => console.error(e));
    };
    [
      "placement",
      "x",
      "y",
      "internalShift",
      "flip",
      "width",
      "overlap",
      "minWidth"
    ].forEach((prop) => {
      vue.watch(vue.toRef(props, prop), syncPosition);
    });
    ["teleportDisabled"].forEach((prop) => {
      vue.watch(vue.toRef(props, prop), syncOnNextTick);
    });
    vue.watch(vue.toRef(props, "syncTrigger"), (value) => {
      if (!value.includes("resize")) {
        VBinder.removeResizeListener(syncPosition);
      } else {
        VBinder.addResizeListener(syncPosition);
      }
      if (!value.includes("scroll")) {
        VBinder.removeScrollListener(syncPosition);
      } else {
        VBinder.addScrollListener(syncPosition);
      }
    });
    const isMountedRef = isMounted();
    const mergedToRef = useMemo(() => {
      const { to } = props;
      if (to !== void 0)
        return to;
      if (isMountedRef.value) {
        return void 0;
      }
      return void 0;
    });
    return {
      VBinder,
      mergedEnabled: mergedEnabledRef,
      offsetContainerRef,
      followerRef,
      mergedTo: mergedToRef,
      syncPosition
    };
  },
  render() {
    return vue.h(LazyTeleport, {
      show: this.show,
      to: this.mergedTo,
      disabled: this.teleportDisabled
    }, {
      default: () => {
        var _a, _b;
        const vNode = vue.h("div", {
          class: ["v-binder-follower-container", this.containerClass],
          ref: "offsetContainerRef"
        }, [
          vue.h("div", {
            class: "v-binder-follower-content",
            ref: "followerRef"
          }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a))
        ]);
        if (this.zindexable) {
          return vue.withDirectives(vNode, [
            [
              zindexable,
              {
                enabled: this.mergedEnabled,
                zIndex: this.zIndex
              }
            ]
          ]);
        }
        return vNode;
      }
    });
  }
});
var resizeObservers = [];
var hasActiveObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.activeTargets.length > 0;
  });
};
var hasSkippedObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.skippedTargets.length > 0;
  });
};
var msg = "ResizeObserver loop completed with undelivered notifications.";
var deliverResizeLoopError = function() {
  var event;
  if (typeof ErrorEvent === "function") {
    event = new ErrorEvent("error", {
      message: msg
    });
  } else {
    event = document.createEvent("Event");
    event.initEvent("error", false, false);
    event.message = msg;
  }
  window.dispatchEvent(event);
};
var ResizeObserverBoxOptions;
(function(ResizeObserverBoxOptions2) {
  ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
  ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
  ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
var freeze = function(obj) {
  return Object.freeze(obj);
};
var ResizeObserverSize = /* @__PURE__ */ (function() {
  function ResizeObserverSize2(inlineSize, blockSize) {
    this.inlineSize = inlineSize;
    this.blockSize = blockSize;
    freeze(this);
  }
  return ResizeObserverSize2;
})();
var DOMRectReadOnly = (function() {
  function DOMRectReadOnly2(x, y2, width, height) {
    this.x = x;
    this.y = y2;
    this.width = width;
    this.height = height;
    this.top = this.y;
    this.left = this.x;
    this.bottom = this.top + this.height;
    this.right = this.left + this.width;
    return freeze(this);
  }
  DOMRectReadOnly2.prototype.toJSON = function() {
    var _a = this, x = _a.x, y2 = _a.y, top2 = _a.top, right2 = _a.right, bottom2 = _a.bottom, left2 = _a.left, width = _a.width, height = _a.height;
    return { x, y: y2, top: top2, right: right2, bottom: bottom2, left: left2, width, height };
  };
  DOMRectReadOnly2.fromRect = function(rectangle) {
    return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  };
  return DOMRectReadOnly2;
})();
var isSVG = function(target) {
  return target instanceof SVGElement && "getBBox" in target;
};
var isHidden = function(target) {
  if (isSVG(target)) {
    var _a = target.getBBox(), width = _a.width, height = _a.height;
    return !width && !height;
  }
  var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement = function(obj) {
  var _a;
  if (obj instanceof Element) {
    return true;
  }
  var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
  return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function(target) {
  switch (target.tagName) {
    case "INPUT":
      if (target.type !== "image") {
        break;
      }
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return true;
  }
  return false;
};
var global = typeof window !== "undefined" ? window : {};
var cache = /* @__PURE__ */ new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(global.navigator && global.navigator.userAgent);
var parseDimension = function(pixel) {
  return parseFloat(pixel || "0");
};
var size = function(inlineSize, blockSize, switchSizes) {
  if (inlineSize === void 0) {
    inlineSize = 0;
  }
  if (blockSize === void 0) {
    blockSize = 0;
  }
  if (switchSizes === void 0) {
    switchSizes = false;
  }
  return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = freeze({
  devicePixelContentBoxSize: size(),
  borderBoxSize: size(),
  contentBoxSize: size(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function(target, forceRecalculation) {
  if (forceRecalculation === void 0) {
    forceRecalculation = false;
  }
  if (cache.has(target) && !forceRecalculation) {
    return cache.get(target);
  }
  if (isHidden(target)) {
    cache.set(target, zeroBoxes);
    return zeroBoxes;
  }
  var cs = getComputedStyle(target);
  var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
  var removePadding = !IE && cs.boxSizing === "border-box";
  var switchSizes = verticalRegexp.test(cs.writingMode || "");
  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
  var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
  var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
  var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
  var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
  var horizontalPadding = paddingLeft + paddingRight;
  var verticalPadding = paddingTop + paddingBottom;
  var horizontalBorderArea = borderLeft + borderRight;
  var verticalBorderArea = borderTop + borderBottom;
  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
  var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
  var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
  var boxes = freeze({
    devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size(contentWidth, contentHeight, switchSizes),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  cache.set(target, boxes);
  return boxes;
};
var calculateBoxSize = function(target, observedBox, forceRecalculation) {
  var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
};
var ResizeObserverEntry = /* @__PURE__ */ (function() {
  function ResizeObserverEntry2(target) {
    var boxes = calculateBoxSizes(target);
    this.target = target;
    this.contentRect = boxes.contentRect;
    this.borderBoxSize = freeze([boxes.borderBoxSize]);
    this.contentBoxSize = freeze([boxes.contentBoxSize]);
    this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry2;
})();
var calculateDepthForNode = function(node) {
  if (isHidden(node)) {
    return Infinity;
  }
  var depth = 0;
  var parent = node.parentNode;
  while (parent) {
    depth += 1;
    parent = parent.parentNode;
  }
  return depth;
};
var broadcastActiveObservations = function() {
  var shallowestDepth = Infinity;
  var callbacks2 = [];
  resizeObservers.forEach(function processObserver(ro) {
    if (ro.activeTargets.length === 0) {
      return;
    }
    var entries = [];
    ro.activeTargets.forEach(function processTarget(ot) {
      var entry = new ResizeObserverEntry(ot.target);
      var targetDepth = calculateDepthForNode(ot.target);
      entries.push(entry);
      ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
      if (targetDepth < shallowestDepth) {
        shallowestDepth = targetDepth;
      }
    });
    callbacks2.push(function resizeObserverCallback() {
      ro.callback.call(ro.observer, entries, ro.observer);
    });
    ro.activeTargets.splice(0, ro.activeTargets.length);
  });
  for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
    var callback = callbacks_1[_i];
    callback();
  }
  return shallowestDepth;
};
var gatherActiveObservationsAtDepth = function(depth) {
  resizeObservers.forEach(function processObserver(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length);
    ro.skippedTargets.splice(0, ro.skippedTargets.length);
    ro.observationTargets.forEach(function processTarget(ot) {
      if (ot.isActive()) {
        if (calculateDepthForNode(ot.target) > depth) {
          ro.activeTargets.push(ot);
        } else {
          ro.skippedTargets.push(ot);
        }
      }
    });
  });
};
var process = function() {
  var depth = 0;
  gatherActiveObservationsAtDepth(depth);
  while (hasActiveObservations()) {
    depth = broadcastActiveObservations();
    gatherActiveObservationsAtDepth(depth);
  }
  if (hasSkippedObservations()) {
    deliverResizeLoopError();
  }
  return depth > 0;
};
var trigger;
var callbacks = [];
var notify = function() {
  return callbacks.splice(0).forEach(function(cb) {
    return cb();
  });
};
var queueMicroTask = function(callback) {
  if (!trigger) {
    var toggle_1 = 0;
    var el_1 = document.createTextNode("");
    var config = { characterData: true };
    new MutationObserver(function() {
      return notify();
    }).observe(el_1, config);
    trigger = function() {
      el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback);
  trigger();
};
var queueResizeObserver = function(cb) {
  queueMicroTask(function ResizeObserver2() {
    requestAnimationFrame(cb);
  });
};
var watching = 0;
var isWatching = function() {
  return !!watching;
};
var CATCH_PERIOD = 250;
var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
var events = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
];
var time = function(timeout2) {
  if (timeout2 === void 0) {
    timeout2 = 0;
  }
  return Date.now() + timeout2;
};
var scheduled = false;
var Scheduler = (function() {
  function Scheduler2() {
    var _this = this;
    this.stopped = true;
    this.listener = function() {
      return _this.schedule();
    };
  }
  Scheduler2.prototype.run = function(timeout2) {
    var _this = this;
    if (timeout2 === void 0) {
      timeout2 = CATCH_PERIOD;
    }
    if (scheduled) {
      return;
    }
    scheduled = true;
    var until = time(timeout2);
    queueResizeObserver(function() {
      var elementsHaveResized = false;
      try {
        elementsHaveResized = process();
      } finally {
        scheduled = false;
        timeout2 = until - time();
        if (!isWatching()) {
          return;
        }
        if (elementsHaveResized) {
          _this.run(1e3);
        } else if (timeout2 > 0) {
          _this.run(timeout2);
        } else {
          _this.start();
        }
      }
    });
  };
  Scheduler2.prototype.schedule = function() {
    this.stop();
    this.run();
  };
  Scheduler2.prototype.observe = function() {
    var _this = this;
    var cb = function() {
      return _this.observer && _this.observer.observe(document.body, observerConfig);
    };
    document.body ? cb() : global.addEventListener("DOMContentLoaded", cb);
  };
  Scheduler2.prototype.start = function() {
    var _this = this;
    if (this.stopped) {
      this.stopped = false;
      this.observer = new MutationObserver(this.listener);
      this.observe();
      events.forEach(function(name) {
        return global.addEventListener(name, _this.listener, true);
      });
    }
  };
  Scheduler2.prototype.stop = function() {
    var _this = this;
    if (!this.stopped) {
      this.observer && this.observer.disconnect();
      events.forEach(function(name) {
        return global.removeEventListener(name, _this.listener, true);
      });
      this.stopped = true;
    }
  };
  return Scheduler2;
})();
var scheduler = new Scheduler();
var updateCount = function(n) {
  !watching && n > 0 && scheduler.start();
  watching += n;
  !watching && scheduler.stop();
};
var skipNotifyOnElement = function(target) {
  return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
};
var ResizeObservation = (function() {
  function ResizeObservation2(target, observedBox) {
    this.target = target;
    this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
    this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  ResizeObservation2.prototype.isActive = function() {
    var size2 = calculateBoxSize(this.target, this.observedBox, true);
    if (skipNotifyOnElement(this.target)) {
      this.lastReportedSize = size2;
    }
    if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {
      return true;
    }
    return false;
  };
  return ResizeObservation2;
})();
var ResizeObserverDetail = /* @__PURE__ */ (function() {
  function ResizeObserverDetail2(resizeObserver, callback) {
    this.activeTargets = [];
    this.skippedTargets = [];
    this.observationTargets = [];
    this.observer = resizeObserver;
    this.callback = callback;
  }
  return ResizeObserverDetail2;
})();
var observerMap = /* @__PURE__ */ new WeakMap();
var getObservationIndex = function(observationTargets, target) {
  for (var i = 0; i < observationTargets.length; i += 1) {
    if (observationTargets[i].target === target) {
      return i;
    }
  }
  return -1;
};
var ResizeObserverController = (function() {
  function ResizeObserverController2() {
  }
  ResizeObserverController2.connect = function(resizeObserver, callback) {
    var detail = new ResizeObserverDetail(resizeObserver, callback);
    observerMap.set(resizeObserver, detail);
  };
  ResizeObserverController2.observe = function(resizeObserver, target, options) {
    var detail = observerMap.get(resizeObserver);
    var firstObservation = detail.observationTargets.length === 0;
    if (getObservationIndex(detail.observationTargets, target) < 0) {
      firstObservation && resizeObservers.push(detail);
      detail.observationTargets.push(new ResizeObservation(target, options && options.box));
      updateCount(1);
      scheduler.schedule();
    }
  };
  ResizeObserverController2.unobserve = function(resizeObserver, target) {
    var detail = observerMap.get(resizeObserver);
    var index2 = getObservationIndex(detail.observationTargets, target);
    var lastObservation = detail.observationTargets.length === 1;
    if (index2 >= 0) {
      lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
      detail.observationTargets.splice(index2, 1);
      updateCount(-1);
    }
  };
  ResizeObserverController2.disconnect = function(resizeObserver) {
    var _this = this;
    var detail = observerMap.get(resizeObserver);
    detail.observationTargets.slice().forEach(function(ot) {
      return _this.unobserve(resizeObserver, ot.target);
    });
    detail.activeTargets.splice(0, detail.activeTargets.length);
  };
  return ResizeObserverController2;
})();
var ResizeObserver$1 = (function() {
  function ResizeObserver2(callback) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (typeof callback !== "function") {
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    }
    ResizeObserverController.connect(this, callback);
  }
  ResizeObserver2.prototype.observe = function(target, options) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.observe(this, target, options);
  };
  ResizeObserver2.prototype.unobserve = function(target) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.unobserve(this, target);
  };
  ResizeObserver2.prototype.disconnect = function() {
    ResizeObserverController.disconnect(this);
  };
  ResizeObserver2.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  };
  return ResizeObserver2;
})();
class ResizeObserverDelegate {
  constructor() {
    this.handleResize = this.handleResize.bind(this);
    this.observer = new (typeof window !== "undefined" && window.ResizeObserver || ResizeObserver$1)(this.handleResize);
    this.elHandlersMap = /* @__PURE__ */ new Map();
  }
  handleResize(entries) {
    for (const entry of entries) {
      const handler = this.elHandlersMap.get(entry.target);
      if (handler !== void 0) {
        handler(entry);
      }
    }
  }
  registerHandler(el, handler) {
    this.elHandlersMap.set(el, handler);
    this.observer.observe(el);
  }
  unregisterHandler(el) {
    if (!this.elHandlersMap.has(el)) {
      return;
    }
    this.elHandlersMap.delete(el);
    this.observer.unobserve(el);
  }
}
const resizeObserverManager = new ResizeObserverDelegate();
const VResizeObserver = vue.defineComponent({
  name: "ResizeObserver",
  props: {
    onResize: Function
  },
  setup(props) {
    let registered = false;
    const proxy = vue.getCurrentInstance().proxy;
    function handleResize(entry) {
      const { onResize } = props;
      if (onResize !== void 0)
        onResize(entry);
    }
    vue.onMounted(() => {
      const el = proxy.$el;
      if (el === void 0) {
        warn$1("resize-observer", "$el does not exist.");
        return;
      }
      if (el.nextElementSibling !== el.nextSibling) {
        if (el.nodeType === 3 && el.nodeValue !== "") {
          warn$1("resize-observer", "$el can not be observed (it may be a text node).");
          return;
        }
      }
      if (el.nextElementSibling !== null) {
        resizeObserverManager.registerHandler(el.nextElementSibling, handleResize);
        registered = true;
      }
    });
    vue.onBeforeUnmount(() => {
      if (registered) {
        resizeObserverManager.unregisterHandler(proxy.$el.nextElementSibling);
      }
    });
  },
  render() {
    return vue.renderSlot(this.$slots, "default");
  }
});
function isHTMLElement(node) {
  return node instanceof HTMLElement;
}
function focusFirstDescendant(node) {
  for (let i = 0; i < node.childNodes.length; i++) {
    const child = node.childNodes[i];
    if (isHTMLElement(child)) {
      if (attemptFocus(child) || focusFirstDescendant(child)) {
        return true;
      }
    }
  }
  return false;
}
function focusLastDescendant(element) {
  for (let i = element.childNodes.length - 1; i >= 0; i--) {
    const child = element.childNodes[i];
    if (isHTMLElement(child)) {
      if (attemptFocus(child) || focusLastDescendant(child)) {
        return true;
      }
    }
  }
  return false;
}
function attemptFocus(element) {
  if (!isFocusable(element)) {
    return false;
  }
  try {
    element.focus({ preventScroll: true });
  } catch (e) {
  }
  return document.activeElement === element;
}
function isFocusable(element) {
  if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
    return true;
  }
  if (element.getAttribute("disabled")) {
    return false;
  }
  switch (element.nodeName) {
    case "A":
      return !!element.href && element.rel !== "ignore";
    case "INPUT":
      return element.type !== "hidden" && element.type !== "file";
    case "SELECT":
    case "TEXTAREA":
      return true;
    default:
      return false;
  }
}
let stack = [];
const FocusTrap = vue.defineComponent({
  name: "FocusTrap",
  props: {
    disabled: Boolean,
    active: Boolean,
    autoFocus: {
      type: Boolean,
      default: true
    },
    onEsc: Function,
    initialFocusTo: [String, Function],
    finalFocusTo: [String, Function],
    returnFocusOnDeactivated: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    const id = createId();
    const focusableStartRef = vue.ref(null);
    const focusableEndRef = vue.ref(null);
    let activated = false;
    let ignoreInternalFocusChange = false;
    const lastFocusedElement = typeof document === "undefined" ? null : document.activeElement;
    function isCurrentActive() {
      const currentActiveId = stack[stack.length - 1];
      return currentActiveId === id;
    }
    function handleDocumentKeydown(e) {
      var _a;
      if (e.code === "Escape") {
        if (isCurrentActive()) {
          (_a = props.onEsc) === null || _a === void 0 ? void 0 : _a.call(props, e);
        }
      }
    }
    vue.onMounted(() => {
      vue.watch(() => props.active, (value) => {
        if (value) {
          activate();
          on("keydown", document, handleDocumentKeydown);
        } else {
          off("keydown", document, handleDocumentKeydown);
          if (activated) {
            deactivate();
          }
        }
      }, {
        immediate: true
      });
    });
    vue.onBeforeUnmount(() => {
      off("keydown", document, handleDocumentKeydown);
      if (activated)
        deactivate();
    });
    function handleDocumentFocus(e) {
      if (ignoreInternalFocusChange)
        return;
      if (isCurrentActive()) {
        const mainEl = getMainEl();
        if (mainEl === null)
          return;
        if (mainEl.contains(getPreciseEventTarget(e)))
          return;
        resetFocusTo("first");
      }
    }
    function getMainEl() {
      const focusableStartEl = focusableStartRef.value;
      if (focusableStartEl === null)
        return null;
      let mainEl = focusableStartEl;
      while (true) {
        mainEl = mainEl.nextSibling;
        if (mainEl === null)
          break;
        if (mainEl instanceof Element && mainEl.tagName === "DIV") {
          break;
        }
      }
      return mainEl;
    }
    function activate() {
      var _a;
      if (props.disabled)
        return;
      stack.push(id);
      if (props.autoFocus) {
        const { initialFocusTo } = props;
        if (initialFocusTo === void 0) {
          resetFocusTo("first");
        } else {
          (_a = resolveTo(initialFocusTo)) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
        }
      }
      activated = true;
      document.addEventListener("focus", handleDocumentFocus, true);
    }
    function deactivate() {
      var _a;
      if (props.disabled)
        return;
      document.removeEventListener("focus", handleDocumentFocus, true);
      stack = stack.filter((idInStack) => idInStack !== id);
      if (isCurrentActive())
        return;
      const { finalFocusTo } = props;
      if (finalFocusTo !== void 0) {
        (_a = resolveTo(finalFocusTo)) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
      } else if (props.returnFocusOnDeactivated) {
        if (lastFocusedElement instanceof HTMLElement) {
          ignoreInternalFocusChange = true;
          lastFocusedElement.focus({ preventScroll: true });
          ignoreInternalFocusChange = false;
        }
      }
    }
    function resetFocusTo(target) {
      if (!isCurrentActive())
        return;
      if (props.active) {
        const focusableStartEl = focusableStartRef.value;
        const focusableEndEl = focusableEndRef.value;
        if (focusableStartEl !== null && focusableEndEl !== null) {
          const mainEl = getMainEl();
          if (mainEl == null || mainEl === focusableEndEl) {
            ignoreInternalFocusChange = true;
            focusableStartEl.focus({ preventScroll: true });
            ignoreInternalFocusChange = false;
            return;
          }
          ignoreInternalFocusChange = true;
          const focused = target === "first" ? focusFirstDescendant(mainEl) : focusLastDescendant(mainEl);
          ignoreInternalFocusChange = false;
          if (!focused) {
            ignoreInternalFocusChange = true;
            focusableStartEl.focus({ preventScroll: true });
            ignoreInternalFocusChange = false;
          }
        }
      }
    }
    function handleStartFocus(e) {
      if (ignoreInternalFocusChange)
        return;
      const mainEl = getMainEl();
      if (mainEl === null)
        return;
      if (e.relatedTarget !== null && mainEl.contains(e.relatedTarget)) {
        resetFocusTo("last");
      } else {
        resetFocusTo("first");
      }
    }
    function handleEndFocus(e) {
      if (ignoreInternalFocusChange)
        return;
      if (e.relatedTarget !== null && e.relatedTarget === focusableStartRef.value) {
        resetFocusTo("last");
      } else {
        resetFocusTo("first");
      }
    }
    return {
      focusableStartRef,
      focusableEndRef,
      focusableStyle: "position: absolute; height: 0; width: 0;",
      handleStartFocus,
      handleEndFocus
    };
  },
  render() {
    const { default: defaultSlot } = this.$slots;
    if (defaultSlot === void 0)
      return null;
    if (this.disabled)
      return defaultSlot();
    const { active, focusableStyle } = this;
    return vue.h(vue.Fragment, null, [
      vue.h("div", {
        "aria-hidden": "true",
        tabindex: active ? "0" : "-1",
        ref: "focusableStartRef",
        style: focusableStyle,
        onFocus: this.handleStartFocus
      }),
      defaultSlot(),
      vue.h("div", {
        "aria-hidden": "true",
        style: focusableStyle,
        ref: "focusableEndRef",
        tabindex: active ? "0" : "-1",
        onFocus: this.handleEndFocus
      })
    ]);
  }
});
const pureNumberRegex = /^(\d|\.)+$/;
const numberRegex = /(\d|\.)+/;
function formatLength(length2, {
  c: c2 = 1,
  offset: offset2 = 0,
  attachPx = true
} = {}) {
  if (typeof length2 === "number") {
    const result = (length2 + offset2) * c2;
    if (result === 0) return "0";
    return `${result}px`;
  } else if (typeof length2 === "string") {
    if (pureNumberRegex.test(length2)) {
      const result = (Number(length2) + offset2) * c2;
      if (attachPx) {
        if (result === 0) return "0";
        return `${result}px`;
      } else {
        return `${result}`;
      }
    } else {
      const result = numberRegex.exec(length2);
      if (!result) return length2;
      return length2.replace(numberRegex, String((Number(result[0]) + offset2) * c2));
    }
  }
  return length2;
}
function rtlInset(inset) {
  const {
    left: left2,
    right: right2,
    top: top2,
    bottom: bottom2
  } = getMargin(inset);
  return `${top2} ${left2} ${bottom2} ${right2}`;
}
let _isJsdom;
function isJsdom() {
  if (_isJsdom === void 0) {
    _isJsdom = navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom");
  }
  return _isJsdom;
}
const warnedMessages = /* @__PURE__ */ new Set();
function warnOnce(location2, message) {
  const mergedMessage = `[naive/${location2}]: ${message}`;
  if (warnedMessages.has(mergedMessage)) return;
  warnedMessages.add(mergedMessage);
  console.error(mergedMessage);
}
function warn(location2, message) {
  console.error(`[naive/${location2}]: ${message}`);
}
function throwError(location2, message) {
  throw new Error(`[naive/${location2}]: ${message}`);
}
function call(funcs, ...args) {
  if (Array.isArray(funcs)) {
    funcs.forEach((func) => call(func, ...args));
  } else {
    return funcs(...args);
  }
}
function createRefSetter(ref) {
  return (inst) => {
    if (inst) {
      ref.value = inst.$el;
    } else {
      ref.value = null;
    }
  };
}
function flatten$1(vNodes, filterCommentNode = true, result = []) {
  vNodes.forEach((vNode) => {
    if (vNode === null) return;
    if (typeof vNode !== "object") {
      if (typeof vNode === "string" || typeof vNode === "number") {
        result.push(vue.createTextVNode(String(vNode)));
      }
      return;
    }
    if (Array.isArray(vNode)) {
      flatten$1(vNode, filterCommentNode, result);
      return;
    }
    if (vNode.type === vue.Fragment) {
      if (vNode.children === null) return;
      if (Array.isArray(vNode.children)) {
        flatten$1(vNode.children, filterCommentNode, result);
      }
    } else {
      if (vNode.type === vue.Comment && filterCommentNode) return;
      result.push(vNode);
    }
  });
  return result;
}
function getFirstSlotVNode(slots, slotName = "default", props = void 0) {
  const slot = slots[slotName];
  if (!slot) {
    warn("getFirstSlotVNode", `slot[${slotName}] is empty`);
    return null;
  }
  const slotContent = flatten$1(slot(props));
  if (slotContent.length === 1) {
    return slotContent[0];
  } else {
    warn("getFirstSlotVNode", `slot[${slotName}] should have exactly one child`);
    return null;
  }
}
function keep(object, keys2 = [], rest) {
  const keepedObject = {};
  keys2.forEach((key2) => {
    keepedObject[key2] = object[key2];
  });
  return Object.assign(keepedObject, rest);
}
function render(r2, ...args) {
  if (typeof r2 === "function") {
    return r2(...args);
  } else if (typeof r2 === "string") {
    return vue.createTextVNode(r2);
  } else if (typeof r2 === "number") {
    return vue.createTextVNode(String(r2));
  } else {
    return null;
  }
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!vue.isVNode(child)) {
      return true;
    }
    if (child.type === vue.Comment) {
      return false;
    }
    if (child.type === vue.Fragment && !ensureValidVNode(child.children)) {
      return false;
    }
    return true;
  }) ? vnodes : null;
}
function resolveWrappedSlot(slot, wrapper) {
  const children = slot && ensureValidVNode(slot());
  return wrapper(children || null);
}
function isSlotEmpty(slot) {
  return !(slot && ensureValidVNode(slot()));
}
const Wrapper = vue.defineComponent({
  render() {
    var _a, _b;
    return (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a);
  }
});
const configProviderInjectionKey = createInjectionKey("n-config-provider");
const defaultClsPrefix = "n";
function useConfig(props = {}, options = {
  defaultBordered: true
}) {
  const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
  return {
    // NConfigProvider,
    inlineThemeDisabled: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.inlineThemeDisabled,
    mergedRtlRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedRtlRef,
    mergedComponentPropsRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedComponentPropsRef,
    mergedBreakpointsRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBreakpointsRef,
    mergedBorderedRef: vue.computed(() => {
      var _a, _b;
      const {
        bordered
      } = props;
      if (bordered !== void 0) return bordered;
      return (_b = (_a = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBorderedRef.value) !== null && _a !== void 0 ? _a : options.defaultBordered) !== null && _b !== void 0 ? _b : true;
    }),
    mergedClsPrefixRef: NConfigProvider2 ? NConfigProvider2.mergedClsPrefixRef : vue.shallowRef(defaultClsPrefix),
    namespaceRef: vue.computed(() => NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedNamespaceRef.value)
  };
}
function useThemeClass(componentName, hashRef, cssVarsRef, props) {
  if (!cssVarsRef) throwError("useThemeClass", "cssVarsRef is not passed");
  const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
  const mergedThemeHashRef = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeHashRef;
  const styleMountTarget = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget;
  const themeClassRef = vue.ref("");
  const ssrAdapter2 = useSsrAdapter();
  let renderCallback;
  const hashClassPrefix = `__${componentName}`;
  const mountStyle = () => {
    let finalThemeHash = hashClassPrefix;
    const hashValue = hashRef ? hashRef.value : void 0;
    const themeHash = mergedThemeHashRef === null || mergedThemeHashRef === void 0 ? void 0 : mergedThemeHashRef.value;
    if (themeHash) finalThemeHash += `-${themeHash}`;
    if (hashValue) finalThemeHash += `-${hashValue}`;
    const {
      themeOverrides,
      builtinThemeOverrides
    } = props;
    if (themeOverrides) {
      finalThemeHash += `-${murmur2(JSON.stringify(themeOverrides))}`;
    }
    if (builtinThemeOverrides) {
      finalThemeHash += `-${murmur2(JSON.stringify(builtinThemeOverrides))}`;
    }
    themeClassRef.value = finalThemeHash;
    renderCallback = () => {
      const cssVars = cssVarsRef.value;
      let style2 = "";
      for (const key2 in cssVars) {
        style2 += `${key2}: ${cssVars[key2]};`;
      }
      c$1(`.${finalThemeHash}`, style2).mount({
        id: finalThemeHash,
        ssr: ssrAdapter2,
        parent: styleMountTarget
      });
      renderCallback = void 0;
    };
  };
  vue.watchEffect(() => {
    mountStyle();
  });
  return {
    themeClass: themeClassRef,
    onRender: () => {
      renderCallback === null || renderCallback === void 0 ? void 0 : renderCallback();
    }
  };
}
var freeGlobal = typeof vue.global == "object" && vue.global && vue.global.Object === Object && vue.global;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var Symbol$1 = root.Symbol;
var objectProto$e = Object.prototype;
var hasOwnProperty$b = objectProto$e.hasOwnProperty;
var nativeObjectToString$1 = objectProto$e.toString;
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$d = Object.prototype;
var nativeObjectToString = objectProto$d.toString;
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var symbolTag$1 = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
}
function arrayMap(array, iteratee) {
  var index2 = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
  while (++index2 < length2) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var isArray = Array.isArray;
var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -Infinity ? "-0" : result;
}
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
function identity(value) {
  return value;
}
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root["__core-js_shared__"];
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
})();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$c = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$a = objectProto$c.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue(object, key2) {
  return object == null ? void 0 : object[key2];
}
function getNative(object, key2) {
  var value = getValue(object, key2);
  return baseIsNative(value) ? value : void 0;
}
var WeakMap$1 = getNative(root, "WeakMap");
var objectCreate = Object.create;
var baseCreate = /* @__PURE__ */ (function() {
  function object() {
  }
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
})();
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
function copyArray(source, array) {
  var index2 = -1, length2 = source.length;
  array || (array = Array(length2));
  while (++index2 < length2) {
    array[index2] = source[index2];
  }
  return array;
}
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
function constant(value) {
  return function() {
    return value;
  };
}
var defineProperty = (function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
})();
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var setToString = shortOut(baseSetToString);
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length2) {
  var type = typeof value;
  length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
  return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
}
function baseAssignValue(object, key2, value) {
  if (key2 == "__proto__" && defineProperty) {
    defineProperty(object, key2, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key2] = value;
  }
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var objectProto$b = Object.prototype;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
function assignValue(object, key2, value) {
  var objValue = object[key2];
  if (!(hasOwnProperty$9.call(object, key2) && eq(objValue, value)) || value === void 0 && !(key2 in object)) {
    baseAssignValue(object, key2, value);
  }
}
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length2 = props.length;
  while (++index2 < length2) {
    var key2 = props[index2];
    var newValue = void 0;
    if (newValue === void 0) {
      newValue = source[key2];
    }
    if (isNew) {
      baseAssignValue(object, key2, newValue);
    } else {
      assignValue(object, key2, newValue);
    }
  }
  return object;
}
var nativeMax = Math.max;
function overRest(func, start2, transform) {
  start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index2 = -1, length2 = nativeMax(args.length - start2, 0), array = Array(length2);
    while (++index2 < length2) {
      array[index2] = args[start2 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start2 + 1);
    while (++index2 < start2) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start2] = transform(array);
    return apply(func, this, otherArgs);
  };
}
function baseRest(func, start2) {
  return setToString(overRest(func, start2, identity), func + "");
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
function isIterateeCall(value, index2, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index2;
  if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
    return eq(object[index2], value);
  }
  return false;
}
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard2 = length2 > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
    if (guard2 && isIterateeCall(sources[0], sources[1], guard2)) {
      customizer = length2 < 3 ? void 0 : customizer;
      length2 = 1;
    }
    object = Object(object);
    while (++index2 < length2) {
      var source = sources[index2];
      if (source) {
        assigner(object, source, index2, customizer);
      }
    }
    return object;
  });
}
var objectProto$a = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
  return value === proto;
}
function baseTimes(n, iteratee) {
  var index2 = -1, result = Array(n);
  while (++index2 < n) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$2;
}
var objectProto$9 = Object.prototype;
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
var isArguments = baseIsArguments(/* @__PURE__ */ (function() {
  return arguments;
})()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$8.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
function stubFalse() {
  return false;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal.process;
var nodeUtil = (function() {
  try {
    var types = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
})();
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
  for (var key2 in value) {
    if ((inherited || hasOwnProperty$7.call(value, key2)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key2 == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key2 == "offset" || key2 == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType2 && (key2 == "buffer" || key2 == "byteLength" || key2 == "byteOffset") || // Skip index properties.
    isIndex(key2, length2)))) {
      result.push(key2);
    }
  }
  return result;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var nativeKeys = overArg(Object.keys, Object);
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key2 in Object(object)) {
    if (hasOwnProperty$6.call(object, key2) && key2 != "constructor") {
      result.push(key2);
    }
  }
  return result;
}
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key2 in Object(object)) {
      result.push(key2);
    }
  }
  return result;
}
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result = [];
  for (var key2 in object) {
    if (!(key2 == "constructor" && (isProto || !hasOwnProperty$5.call(object, key2)))) {
      result.push(key2);
    }
  }
  return result;
}
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var nativeCreate = getNative(Object, "create");
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}
function hashDelete(key2) {
  var result = this.has(key2) && delete this.__data__[key2];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function hashGet(key2) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key2];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$4.call(data, key2) ? data[key2] : void 0;
}
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function hashHas(key2) {
  var data = this.__data__;
  return nativeCreate ? data[key2] !== void 0 : hasOwnProperty$3.call(data, key2);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key2, value) {
  var data = this.__data__;
  this.size += this.has(key2) ? 0 : 1;
  data[key2] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array, key2) {
  var length2 = array.length;
  while (length2--) {
    if (eq(array[length2][0], key2)) {
      return length2;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key2) {
  var data = this.__data__, index2 = assocIndexOf(data, key2);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key2) {
  var data = this.__data__, index2 = assocIndexOf(data, key2);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key2) {
  return assocIndexOf(this.__data__, key2) > -1;
}
function listCacheSet(key2, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key2);
  if (index2 < 0) {
    ++this.size;
    data.push([key2, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root, "Map");
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$1 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map3, key2) {
  var data = map3.__data__;
  return isKeyable(key2) ? data[typeof key2 == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key2) {
  var result = getMapData(this, key2)["delete"](key2);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key2) {
  return getMapData(this, key2).get(key2);
}
function mapCacheHas(key2) {
  return getMapData(this, key2).has(key2);
}
function mapCacheSet(key2, value) {
  var data = getMapData(this, key2), size2 = data.size;
  data.set(key2, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key2 = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key2)) {
      return cache2.get(key2);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key2, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key2) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key2;
  });
  var cache2 = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -Infinity ? "-0" : result;
}
function baseGet(object, path) {
  path = castPath(path, object);
  var index2 = 0, length2 = path.length;
  while (object != null && index2 < length2) {
    object = object[toKey(path[index2++])];
  }
  return index2 && index2 == length2 ? object : void 0;
}
function get2(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet(object, path);
  return result === void 0 ? defaultValue : result;
}
function arrayPush(array, values) {
  var index2 = -1, length2 = values.length, offset2 = array.length;
  while (++index2 < length2) {
    array[offset2 + index2] = values[index2];
  }
  return array;
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
var objectTag$2 = "[object Object]";
var funcProto = Function.prototype, objectProto$3 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$2) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$2.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key2) {
  var data = this.__data__, result = data["delete"](key2);
  this.size = data.size;
  return result;
}
function stackGet(key2) {
  return this.__data__.get(key2);
}
function stackHas(key2) {
  return this.__data__.has(key2);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(key2, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key2, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key2, value);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root.Buffer : void 0;
Buffer ? Buffer.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  {
    return buffer.slice();
  }
}
function arrayFilter(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length2) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$2 = Object.prototype;
var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}
var DataView$1 = getNative(root, "DataView");
var Promise$1 = getNative(root, "Promise");
var Set$1 = getNative(root, "Set");
var mapTag$1 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$1 = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag$1 = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
var getTag = baseGetTag;
if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$1 || Map$1 && getTag(new Map$1()) != mapTag$1 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$1 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$1;
        case mapCtorString:
          return mapTag$1;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$1;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var Uint8Array$1 = root.Uint8Array;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer = cloneArrayBuffer(typedArray.buffer);
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values) {
  var index2 = -1, length2 = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index2 < length2) {
    this.add(values[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache2, key2) {
  return cache2.has(key2);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack2.get(array);
  var othStacked = stack2.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack2.set(array, other);
  stack2.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack2) : customizer(arrValue, othValue, index2, array, other, stack2);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
      result = false;
      break;
    }
  }
  stack2["delete"](array);
  stack2["delete"](other);
  return result;
}
function mapToArray(map3) {
  var index2 = -1, result = Array(map3.size);
  map3.forEach(function(value, key2) {
    result[++index2] = [key2, value];
  });
  return result;
}
function setToArray(set) {
  var index2 = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
      return object == other + "";
    case mapTag:
      var convert = mapToArray;
    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack2.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack2.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
      stack2["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key2 = objProps[index2];
    if (!(isPartial ? key2 in other : hasOwnProperty$1.call(other, key2))) {
      return false;
    }
  }
  var objStacked = stack2.get(object);
  var othStacked = stack2.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack2.set(object, other);
  stack2.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key2 = objProps[index2];
    var objValue = object[key2], othValue = other[key2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key2, other, object, stack2) : customizer(objValue, othValue, key2, object, other, stack2);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key2 == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack2["delete"](object);
  stack2["delete"](other);
  return result;
}
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
  var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack2 || (stack2 = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack2 || (stack2 = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack2 || (stack2 = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
}
function baseIsEqual(value, other, bitmask, customizer, stack2) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index2 = matchData.length, length2 = index2;
  if (object == null) {
    return !length2;
  }
  object = Object(object);
  while (index2--) {
    var data = matchData[index2];
    if (data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index2 < length2) {
    data = matchData[index2];
    var key2 = data[0], objValue = object[key2], srcValue = data[1];
    if (data[2]) {
      if (objValue === void 0 && !(key2 in object)) {
        return false;
      }
    } else {
      var stack2 = new Stack();
      var result;
      if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result)) {
        return false;
      }
    }
  }
  return true;
}
function isStrictComparable(value) {
  return value === value && !isObject(value);
}
function getMatchData(object) {
  var result = keys(object), length2 = result.length;
  while (length2--) {
    var key2 = result[length2], value = object[key2];
    result[length2] = [key2, value, isStrictComparable(value)];
  }
  return result;
}
function matchesStrictComparable(key2, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key2] === srcValue && (srcValue !== void 0 || key2 in Object(object));
  };
}
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}
function baseHasIn(object, key2) {
  return object != null && key2 in Object(object);
}
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index2 = -1, length2 = path.length, result = false;
  while (++index2 < length2) {
    var key2 = toKey(path[index2]);
    if (!(result = object != null && hasFunc(object, key2))) {
      break;
    }
    object = object[key2];
  }
  if (result || ++index2 != length2) {
    return result;
  }
  length2 = object == null ? 0 : object.length;
  return !!length2 && isLength(length2) && isIndex(key2, length2) && (isArray(object) || isArguments(object));
}
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get2(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(key2) {
  return function(object) {
    return object == null ? void 0 : object[key2];
  };
}
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == "object") {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
    while (length2--) {
      var key2 = props[++index2];
      if (iteratee(iterable[key2], key2, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var baseFor = createBaseFor();
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length2 = collection.length, index2 = -1, iterable = Object(collection);
    while (++index2 < length2) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var baseEach = createBaseEach(baseForOwn);
function assignMergeValue(object, key2, value) {
  if (value !== void 0 && !eq(object[key2], value) || value === void 0 && !(key2 in object)) {
    baseAssignValue(object, key2, value);
  }
}
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}
function safeGet(object, key2) {
  if (key2 === "constructor" && typeof object[key2] === "function") {
    return;
  }
  if (key2 == "__proto__") {
    return;
  }
  return object[key2];
}
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}
function baseMergeDeep(object, source, key2, srcIndex, mergeFunc, customizer, stack2) {
  var objValue = safeGet(object, key2), srcValue = safeGet(source, key2), stacked = stack2.get(srcValue);
  if (stacked) {
    assignMergeValue(object, key2, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key2 + "", object, source, stack2) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack2.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
    stack2["delete"](srcValue);
  }
  assignMergeValue(object, key2, newValue);
}
function baseMerge(object, source, srcIndex, customizer, stack2) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key2) {
    stack2 || (stack2 = new Stack());
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key2, srcIndex, baseMerge, customizer, stack2);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key2), srcValue, key2 + "", object, source, stack2) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object, key2, newValue);
    }
  }, keysIn);
}
function baseMap(collection, iteratee) {
  var index2 = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
  baseEach(collection, function(value, key2, collection2) {
    result[++index2] = iteratee(value, key2, collection2);
  });
  return result;
}
function map2(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee));
}
var merge$1 = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
const cssrAnchorMetaName = "naive-ui-style";
function useRtl(mountId, rtlStateRef, clsPrefixRef) {
  if (!rtlStateRef) return void 0;
  const ssrAdapter2 = useSsrAdapter();
  const componentRtlStateRef = vue.computed(() => {
    const {
      value: rtlState
    } = rtlStateRef;
    if (!rtlState) {
      return void 0;
    }
    const componentRtlState = rtlState[mountId];
    if (!componentRtlState) {
      return void 0;
    }
    return componentRtlState;
  });
  const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
  const mountStyle = () => {
    vue.watchEffect(() => {
      const {
        value: clsPrefix
      } = clsPrefixRef;
      const id = `${clsPrefix}${mountId}Rtl`;
      if (exists(id, ssrAdapter2)) return;
      const {
        value: componentRtlState
      } = componentRtlStateRef;
      if (!componentRtlState) return;
      componentRtlState.style.mount({
        id,
        head: true,
        anchorMetaName: cssrAnchorMetaName,
        props: {
          bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
        },
        ssr: ssrAdapter2,
        parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
      });
    });
  };
  if (ssrAdapter2) {
    mountStyle();
  } else {
    vue.onBeforeMount(mountStyle);
  }
  return componentRtlStateRef;
}
const commonVariables$2 = {
  fontFamily: 'v-sans, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
  fontFamilyMono: "v-mono, SFMono-Regular, Menlo, Consolas, Courier, monospace",
  fontWeight: "400",
  fontWeightStrong: "500",
  cubicBezierEaseInOut: "cubic-bezier(.4, 0, .2, 1)",
  cubicBezierEaseOut: "cubic-bezier(0, 0, .2, 1)",
  cubicBezierEaseIn: "cubic-bezier(.4, 0, 1, 1)",
  borderRadius: "3px",
  borderRadiusSmall: "2px",
  fontSize: "14px",
  fontSizeMini: "12px",
  fontSizeTiny: "12px",
  fontSizeSmall: "14px",
  fontSizeMedium: "14px",
  fontSizeLarge: "15px",
  fontSizeHuge: "16px",
  lineHeight: "1.6",
  heightMini: "16px",
  // private now, it's too small
  heightTiny: "22px",
  heightSmall: "28px",
  heightMedium: "34px",
  heightLarge: "40px",
  heightHuge: "46px"
};
const {
  fontSize,
  fontFamily,
  lineHeight
} = commonVariables$2;
const globalStyle = c$1("body", `
 margin: 0;
 font-size: ${fontSize};
 font-family: ${fontFamily};
 line-height: ${lineHeight};
 -webkit-text-size-adjust: 100%;
 -webkit-tap-highlight-color: transparent;
`, [c$1("input", `
 font-family: inherit;
 font-size: inherit;
 `)]);
function createTheme(theme) {
  return theme;
}
function useTheme(resolveId, mountId, style2, defaultTheme, props, clsPrefixRef) {
  const ssrAdapter2 = useSsrAdapter();
  const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
  if (style2) {
    const mountStyle = () => {
      const clsPrefix = clsPrefixRef === null || clsPrefixRef === void 0 ? void 0 : clsPrefixRef.value;
      style2.mount({
        id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
        head: true,
        props: {
          bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
        },
        anchorMetaName: cssrAnchorMetaName,
        ssr: ssrAdapter2,
        parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
      });
      if (!(NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled)) {
        globalStyle.mount({
          id: "n-global",
          head: true,
          anchorMetaName: cssrAnchorMetaName,
          ssr: ssrAdapter2,
          parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
        });
      }
    };
    if (ssrAdapter2) {
      mountStyle();
    } else {
      vue.onBeforeMount(mountStyle);
    }
  }
  const mergedThemeRef = vue.computed(() => {
    var _a;
    const {
      theme: {
        common: selfCommon,
        self: self2,
        peers = {}
      } = {},
      themeOverrides: selfOverrides = {},
      builtinThemeOverrides: builtinOverrides = {}
    } = props;
    const {
      common: selfCommonOverrides,
      peers: peersOverrides
    } = selfOverrides;
    const {
      common: globalCommon = void 0,
      [resolveId]: {
        common: globalSelfCommon = void 0,
        self: globalSelf = void 0,
        peers: globalPeers = {}
      } = {}
    } = (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeRef.value) || {};
    const {
      common: globalCommonOverrides = void 0,
      [resolveId]: globalSelfOverrides = {}
    } = (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value) || {};
    const {
      common: globalSelfCommonOverrides,
      peers: globalPeersOverrides = {}
    } = globalSelfOverrides;
    const mergedCommon = merge$1({}, selfCommon || globalSelfCommon || globalCommon || defaultTheme.common, globalCommonOverrides, globalSelfCommonOverrides, selfCommonOverrides);
    const mergedSelf = merge$1(
      // {}, executed every time, no need for empty obj
      (_a = self2 || globalSelf || defaultTheme.self) === null || _a === void 0 ? void 0 : _a(mergedCommon),
      builtinOverrides,
      globalSelfOverrides,
      selfOverrides
    );
    return {
      common: mergedCommon,
      self: mergedSelf,
      peers: merge$1({}, defaultTheme.peers, globalPeers, peers),
      peerOverrides: merge$1({}, builtinOverrides.peers, globalPeersOverrides, peersOverrides)
    };
  });
  return mergedThemeRef;
}
useTheme.props = {
  theme: Object,
  themeOverrides: Object,
  builtinThemeOverrides: Object
};
const ChevronRightIcon = vue.defineComponent({
  name: "ChevronRight",
  render() {
    return vue.h("svg", {
      viewBox: "0 0 16 16",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, vue.h("path", {
      d: "M5.64645 3.14645C5.45118 3.34171 5.45118 3.65829 5.64645 3.85355L9.79289 8L5.64645 12.1464C5.45118 12.3417 5.45118 12.6583 5.64645 12.8536C5.84171 13.0488 6.15829 13.0488 6.35355 12.8536L10.8536 8.35355C11.0488 8.15829 11.0488 7.84171 10.8536 7.64645L6.35355 3.14645C6.15829 2.95118 5.84171 2.95118 5.64645 3.14645Z",
      fill: "currentColor"
    }));
  }
});
const {
  cubicBezierEaseInOut
} = commonVariables$2;
function fadeInTransition({
  name = "fade-in",
  enterDuration = "0.2s",
  leaveDuration = "0.2s",
  enterCubicBezier = cubicBezierEaseInOut,
  leaveCubicBezier = cubicBezierEaseInOut
} = {}) {
  return [c$1(`&.${name}-transition-enter-active`, {
    transition: `all ${enterDuration} ${enterCubicBezier}!important`
  }), c$1(`&.${name}-transition-leave-active`, {
    transition: `all ${leaveDuration} ${leaveCubicBezier}!important`
  }), c$1(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
    opacity: 0
  }), c$1(`&.${name}-transition-leave-from, &.${name}-transition-enter-to`, {
    opacity: 1
  })];
}
const base = {
  neutralBase: "#FFF",
  neutralInvertBase: "#000",
  neutralTextBase: "#000",
  neutralPopover: "#fff",
  neutralCard: "#fff",
  neutralModal: "#fff",
  neutralBody: "#fff",
  alpha1: "0.82",
  alpha2: "0.72",
  alpha3: "0.38",
  alpha4: "0.24",
  // disabled text, placeholder, icon
  alpha5: "0.18",
  // disabled placeholder
  alphaClose: "0.6",
  alphaDisabled: "0.5",
  alphaAvatar: "0.2",
  alphaProgressRail: ".08",
  alphaInput: "0",
  alphaScrollbar: "0.25",
  alphaScrollbarHover: "0.4",
  // primary
  primaryHover: "#36ad6a",
  primaryDefault: "#18a058",
  primaryActive: "#0c7a43",
  primarySuppl: "#36ad6a",
  // info
  infoHover: "#4098fc",
  infoDefault: "#2080f0",
  infoActive: "#1060c9",
  infoSuppl: "#4098fc",
  // error
  errorHover: "#de576d",
  errorDefault: "#d03050",
  errorActive: "#ab1f3f",
  errorSuppl: "#de576d",
  // warning
  warningHover: "#fcb040",
  warningDefault: "#f0a020",
  warningActive: "#c97c10",
  warningSuppl: "#fcb040",
  // success
  successHover: "#36ad6a",
  successDefault: "#18a058",
  successActive: "#0c7a43",
  successSuppl: "#36ad6a"
};
const baseBackgroundRgb = rgba(base.neutralBase);
const baseInvertBackgroundRgb = rgba(base.neutralInvertBase);
const overlayPrefix = `rgba(${baseInvertBackgroundRgb.slice(0, 3).join(", ")}, `;
function overlay(alpha) {
  return `${overlayPrefix + String(alpha)})`;
}
function neutral(alpha) {
  const overlayRgba = Array.from(baseInvertBackgroundRgb);
  overlayRgba[3] = Number(alpha);
  return composite(baseBackgroundRgb, overlayRgba);
}
const derived = Object.assign(Object.assign({
  name: "common"
}, commonVariables$2), {
  baseColor: base.neutralBase,
  // primary color
  primaryColor: base.primaryDefault,
  primaryColorHover: base.primaryHover,
  primaryColorPressed: base.primaryActive,
  primaryColorSuppl: base.primarySuppl,
  // info color
  infoColor: base.infoDefault,
  infoColorHover: base.infoHover,
  infoColorPressed: base.infoActive,
  infoColorSuppl: base.infoSuppl,
  // success color
  successColor: base.successDefault,
  successColorHover: base.successHover,
  successColorPressed: base.successActive,
  successColorSuppl: base.successSuppl,
  // warning color
  warningColor: base.warningDefault,
  warningColorHover: base.warningHover,
  warningColorPressed: base.warningActive,
  warningColorSuppl: base.warningSuppl,
  // error color
  errorColor: base.errorDefault,
  errorColorHover: base.errorHover,
  errorColorPressed: base.errorActive,
  errorColorSuppl: base.errorSuppl,
  // text color
  textColorBase: base.neutralTextBase,
  textColor1: "rgb(31, 34, 37)",
  textColor2: "rgb(51, 54, 57)",
  textColor3: "rgb(118, 124, 130)",
  // textColor4: neutral(base.alpha4), // disabled, placeholder, icon
  // textColor5: neutral(base.alpha5),
  textColorDisabled: neutral(base.alpha4),
  placeholderColor: neutral(base.alpha4),
  placeholderColorDisabled: neutral(base.alpha5),
  iconColor: neutral(base.alpha4),
  iconColorHover: scaleColor(neutral(base.alpha4), {
    lightness: 0.75
  }),
  iconColorPressed: scaleColor(neutral(base.alpha4), {
    lightness: 0.9
  }),
  iconColorDisabled: neutral(base.alpha5),
  opacity1: base.alpha1,
  opacity2: base.alpha2,
  opacity3: base.alpha3,
  opacity4: base.alpha4,
  opacity5: base.alpha5,
  dividerColor: "rgb(239, 239, 245)",
  borderColor: "rgb(224, 224, 230)",
  // close
  closeIconColor: neutral(Number(base.alphaClose)),
  closeIconColorHover: neutral(Number(base.alphaClose)),
  closeIconColorPressed: neutral(Number(base.alphaClose)),
  closeColorHover: "rgba(0, 0, 0, .09)",
  closeColorPressed: "rgba(0, 0, 0, .13)",
  // clear
  clearColor: neutral(base.alpha4),
  clearColorHover: scaleColor(neutral(base.alpha4), {
    lightness: 0.75
  }),
  clearColorPressed: scaleColor(neutral(base.alpha4), {
    lightness: 0.9
  }),
  scrollbarColor: overlay(base.alphaScrollbar),
  scrollbarColorHover: overlay(base.alphaScrollbarHover),
  scrollbarWidth: "5px",
  scrollbarHeight: "5px",
  scrollbarBorderRadius: "5px",
  progressRailColor: neutral(base.alphaProgressRail),
  railColor: "rgb(219, 219, 223)",
  popoverColor: base.neutralPopover,
  tableColor: base.neutralCard,
  cardColor: base.neutralCard,
  modalColor: base.neutralModal,
  bodyColor: base.neutralBody,
  tagColor: "#eee",
  avatarColor: neutral(base.alphaAvatar),
  invertedColor: "rgb(0, 20, 40)",
  inputColor: neutral(base.alphaInput),
  codeColor: "rgb(244, 244, 248)",
  tabColor: "rgb(247, 247, 250)",
  actionColor: "rgb(250, 250, 252)",
  tableHeaderColor: "rgb(250, 250, 252)",
  hoverColor: "rgb(243, 243, 245)",
  // use color with alpha since it can be nested with header filter & sorter effect
  tableColorHover: "rgba(0, 0, 100, 0.03)",
  tableColorStriped: "rgba(0, 0, 100, 0.02)",
  pressedColor: "rgb(237, 237, 239)",
  opacityDisabled: base.alphaDisabled,
  inputColorDisabled: "rgb(250, 250, 252)",
  // secondary button color
  // can also be used in tertiary button & quaternary button
  buttonColor2: "rgba(46, 51, 56, .05)",
  buttonColor2Hover: "rgba(46, 51, 56, .09)",
  buttonColor2Pressed: "rgba(46, 51, 56, .13)",
  boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .08), 0 3px 6px 0 rgba(0, 0, 0, .06), 0 5px 12px 4px rgba(0, 0, 0, .04)",
  boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .12), 0 6px 16px 0 rgba(0, 0, 0, .08), 0 9px 28px 8px rgba(0, 0, 0, .05)",
  boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
});
const commonVars$1 = {
  railInsetHorizontalBottom: "auto 2px 4px 2px",
  railInsetHorizontalTop: "4px 2px auto 2px",
  railInsetVerticalRight: "2px 4px 2px auto",
  railInsetVerticalLeft: "2px auto 2px 4px",
  railColor: "transparent"
};
function self$6(vars) {
  const {
    scrollbarColor,
    scrollbarColorHover,
    scrollbarHeight,
    scrollbarWidth,
    scrollbarBorderRadius
  } = vars;
  return Object.assign(Object.assign({}, commonVars$1), {
    height: scrollbarHeight,
    width: scrollbarWidth,
    borderRadius: scrollbarBorderRadius,
    color: scrollbarColor,
    colorHover: scrollbarColorHover
  });
}
const scrollbarLight = {
  name: "Scrollbar",
  common: derived,
  self: self$6
};
const style$4 = cB("scrollbar", `
 overflow: hidden;
 position: relative;
 z-index: auto;
 height: 100%;
 width: 100%;
`, [c$1(">", [cB("scrollbar-container", `
 width: 100%;
 overflow: scroll;
 height: 100%;
 min-height: inherit;
 max-height: inherit;
 scrollbar-width: none;
 `, [c$1("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), c$1(">", [
  // We can't set overflow hidden since it affects positioning.
  cB("scrollbar-content", `
 box-sizing: border-box;
 min-width: 100%;
 `)
])])]), c$1(">, +", [cB("scrollbar-rail", `
 position: absolute;
 pointer-events: none;
 user-select: none;
 background: var(--n-scrollbar-rail-color);
 -webkit-user-select: none;
 `, [cM("horizontal", `
 height: var(--n-scrollbar-height);
 `, [c$1(">", [cE("scrollbar", `
 height: var(--n-scrollbar-height);
 border-radius: var(--n-scrollbar-border-radius);
 right: 0;
 `)])]), cM("horizontal--top", `
 top: var(--n-scrollbar-rail-top-horizontal-top); 
 right: var(--n-scrollbar-rail-right-horizontal-top); 
 bottom: var(--n-scrollbar-rail-bottom-horizontal-top); 
 left: var(--n-scrollbar-rail-left-horizontal-top); 
 `), cM("horizontal--bottom", `
 top: var(--n-scrollbar-rail-top-horizontal-bottom); 
 right: var(--n-scrollbar-rail-right-horizontal-bottom); 
 bottom: var(--n-scrollbar-rail-bottom-horizontal-bottom); 
 left: var(--n-scrollbar-rail-left-horizontal-bottom); 
 `), cM("vertical", `
 width: var(--n-scrollbar-width);
 `, [c$1(">", [cE("scrollbar", `
 width: var(--n-scrollbar-width);
 border-radius: var(--n-scrollbar-border-radius);
 bottom: 0;
 `)])]), cM("vertical--left", `
 top: var(--n-scrollbar-rail-top-vertical-left); 
 right: var(--n-scrollbar-rail-right-vertical-left); 
 bottom: var(--n-scrollbar-rail-bottom-vertical-left); 
 left: var(--n-scrollbar-rail-left-vertical-left); 
 `), cM("vertical--right", `
 top: var(--n-scrollbar-rail-top-vertical-right); 
 right: var(--n-scrollbar-rail-right-vertical-right); 
 bottom: var(--n-scrollbar-rail-bottom-vertical-right); 
 left: var(--n-scrollbar-rail-left-vertical-right); 
 `), cM("disabled", [c$1(">", [cE("scrollbar", "pointer-events: none;")])]), c$1(">", [cE("scrollbar", `
 z-index: 1;
 position: absolute;
 cursor: pointer;
 pointer-events: all;
 background-color: var(--n-scrollbar-color);
 transition: background-color .2s var(--n-scrollbar-bezier);
 `, [fadeInTransition(), c$1("&:hover", "background-color: var(--n-scrollbar-color-hover);")])])])])]);
const scrollbarProps = Object.assign(Object.assign({}, useTheme.props), {
  duration: {
    type: Number,
    default: 0
  },
  scrollable: {
    type: Boolean,
    default: true
  },
  xScrollable: Boolean,
  trigger: {
    type: String,
    default: "hover"
  },
  useUnifiedContainer: Boolean,
  triggerDisplayManually: Boolean,
  // If container is set, resize observer won't not attached
  container: Function,
  content: Function,
  containerClass: String,
  containerStyle: [String, Object],
  contentClass: [String, Array],
  contentStyle: [String, Object],
  horizontalRailStyle: [String, Object],
  verticalRailStyle: [String, Object],
  onScroll: Function,
  onWheel: Function,
  onResize: Function,
  internalOnUpdateScrollLeft: Function,
  internalHoistYRail: Boolean,
  yPlacement: {
    type: String,
    default: "right"
  },
  xPlacement: {
    type: String,
    default: "bottom"
  }
});
const Scrollbar = vue.defineComponent({
  name: "Scrollbar",
  props: scrollbarProps,
  inheritAttrs: false,
  setup(props) {
    const {
      mergedClsPrefixRef,
      inlineThemeDisabled,
      mergedRtlRef
    } = useConfig(props);
    const rtlEnabledRef = useRtl("Scrollbar", mergedRtlRef, mergedClsPrefixRef);
    const wrapperRef = vue.ref(null);
    const containerRef = vue.ref(null);
    const contentRef = vue.ref(null);
    const yRailRef = vue.ref(null);
    const xRailRef = vue.ref(null);
    const contentHeightRef = vue.ref(null);
    const contentWidthRef = vue.ref(null);
    const containerHeightRef = vue.ref(null);
    const containerWidthRef = vue.ref(null);
    const yRailSizeRef = vue.ref(null);
    const xRailSizeRef = vue.ref(null);
    const containerScrollTopRef = vue.ref(0);
    const containerScrollLeftRef = vue.ref(0);
    const isShowXBarRef = vue.ref(false);
    const isShowYBarRef = vue.ref(false);
    let yBarPressed = false;
    let xBarPressed = false;
    let xBarVanishTimerId;
    let yBarVanishTimerId;
    let memoYTop = 0;
    let memoXLeft = 0;
    let memoMouseX = 0;
    let memoMouseY = 0;
    const isIos2 = useIsIos();
    const themeRef = useTheme("Scrollbar", "-scrollbar", style$4, scrollbarLight, props, mergedClsPrefixRef);
    const yBarSizeRef = vue.computed(() => {
      const {
        value: containerHeight
      } = containerHeightRef;
      const {
        value: contentHeight
      } = contentHeightRef;
      const {
        value: yRailSize
      } = yRailSizeRef;
      if (containerHeight === null || contentHeight === null || yRailSize === null) {
        return 0;
      } else {
        return Math.min(containerHeight, yRailSize * containerHeight / contentHeight + depx(themeRef.value.self.width) * 1.5);
      }
    });
    const yBarSizePxRef = vue.computed(() => {
      return `${yBarSizeRef.value}px`;
    });
    const xBarSizeRef = vue.computed(() => {
      const {
        value: containerWidth
      } = containerWidthRef;
      const {
        value: contentWidth
      } = contentWidthRef;
      const {
        value: xRailSize
      } = xRailSizeRef;
      if (containerWidth === null || contentWidth === null || xRailSize === null) {
        return 0;
      } else {
        return xRailSize * containerWidth / contentWidth + depx(themeRef.value.self.height) * 1.5;
      }
    });
    const xBarSizePxRef = vue.computed(() => {
      return `${xBarSizeRef.value}px`;
    });
    const yBarTopRef = vue.computed(() => {
      const {
        value: containerHeight
      } = containerHeightRef;
      const {
        value: containerScrollTop
      } = containerScrollTopRef;
      const {
        value: contentHeight
      } = contentHeightRef;
      const {
        value: yRailSize
      } = yRailSizeRef;
      if (containerHeight === null || contentHeight === null || yRailSize === null) {
        return 0;
      } else {
        const heightDiff = contentHeight - containerHeight;
        if (!heightDiff) return 0;
        return containerScrollTop / heightDiff * (yRailSize - yBarSizeRef.value);
      }
    });
    const yBarTopPxRef = vue.computed(() => {
      return `${yBarTopRef.value}px`;
    });
    const xBarLeftRef = vue.computed(() => {
      const {
        value: containerWidth
      } = containerWidthRef;
      const {
        value: containerScrollLeft
      } = containerScrollLeftRef;
      const {
        value: contentWidth
      } = contentWidthRef;
      const {
        value: xRailSize
      } = xRailSizeRef;
      if (containerWidth === null || contentWidth === null || xRailSize === null) {
        return 0;
      } else {
        const widthDiff = contentWidth - containerWidth;
        if (!widthDiff) return 0;
        return containerScrollLeft / widthDiff * (xRailSize - xBarSizeRef.value);
      }
    });
    const xBarLeftPxRef = vue.computed(() => {
      return `${xBarLeftRef.value}px`;
    });
    const needYBarRef = vue.computed(() => {
      const {
        value: containerHeight
      } = containerHeightRef;
      const {
        value: contentHeight
      } = contentHeightRef;
      return containerHeight !== null && contentHeight !== null && contentHeight > containerHeight;
    });
    const needXBarRef = vue.computed(() => {
      const {
        value: containerWidth
      } = containerWidthRef;
      const {
        value: contentWidth
      } = contentWidthRef;
      return containerWidth !== null && contentWidth !== null && contentWidth > containerWidth;
    });
    const mergedShowXBarRef = vue.computed(() => {
      const {
        trigger: trigger2
      } = props;
      return trigger2 === "none" || isShowXBarRef.value;
    });
    const mergedShowYBarRef = vue.computed(() => {
      const {
        trigger: trigger2
      } = props;
      return trigger2 === "none" || isShowYBarRef.value;
    });
    const mergedContainerRef = vue.computed(() => {
      const {
        container
      } = props;
      if (container) return container();
      return containerRef.value;
    });
    const mergedContentRef = vue.computed(() => {
      const {
        content
      } = props;
      if (content) return content();
      return contentRef.value;
    });
    const scrollTo = (options, y2) => {
      if (!props.scrollable) return;
      if (typeof options === "number") {
        scrollToPosition(options, y2 !== null && y2 !== void 0 ? y2 : 0, 0, false, "auto");
        return;
      }
      const {
        left: left2,
        top: top2,
        index: index2,
        elSize,
        position,
        behavior,
        el,
        debounce: debounce2 = true
      } = options;
      if (left2 !== void 0 || top2 !== void 0) {
        scrollToPosition(left2 !== null && left2 !== void 0 ? left2 : 0, top2 !== null && top2 !== void 0 ? top2 : 0, 0, false, behavior);
      }
      if (el !== void 0) {
        scrollToPosition(0, el.offsetTop, el.offsetHeight, debounce2, behavior);
      } else if (index2 !== void 0 && elSize !== void 0) {
        scrollToPosition(0, index2 * elSize, elSize, debounce2, behavior);
      } else if (position === "bottom") {
        scrollToPosition(0, Number.MAX_SAFE_INTEGER, 0, false, behavior);
      } else if (position === "top") {
        scrollToPosition(0, 0, 0, false, behavior);
      }
    };
    const activateState = useReactivated(() => {
      if (!props.container) {
        scrollTo({
          top: containerScrollTopRef.value,
          left: containerScrollLeftRef.value
        });
      }
    });
    const handleContentResize = () => {
      if (activateState.isDeactivated) return;
      sync();
    };
    const handleContainerResize = (e) => {
      if (activateState.isDeactivated) return;
      const {
        onResize
      } = props;
      if (onResize) onResize(e);
      sync();
    };
    const scrollBy = (options, y2) => {
      if (!props.scrollable) return;
      const {
        value: container
      } = mergedContainerRef;
      if (!container) return;
      if (typeof options === "object") {
        container.scrollBy(options);
      } else {
        container.scrollBy(options, y2 || 0);
      }
    };
    function scrollToPosition(left2, top2, elSize, debounce2, behavior) {
      const {
        value: container
      } = mergedContainerRef;
      if (!container) return;
      if (debounce2) {
        const {
          scrollTop,
          offsetHeight
        } = container;
        if (top2 > scrollTop) {
          if (top2 + elSize <= scrollTop + offsetHeight) ;
          else {
            container.scrollTo({
              left: left2,
              top: top2 + elSize - offsetHeight,
              behavior
            });
          }
          return;
        }
      }
      container.scrollTo({
        left: left2,
        top: top2,
        behavior
      });
    }
    function handleMouseEnterWrapper() {
      showXBar();
      showYBar();
      sync();
    }
    function handleMouseLeaveWrapper() {
      hideBar();
    }
    function hideBar() {
      hideYBar();
      hideXBar();
    }
    function hideYBar() {
      if (yBarVanishTimerId !== void 0) {
        window.clearTimeout(yBarVanishTimerId);
      }
      yBarVanishTimerId = window.setTimeout(() => {
        isShowYBarRef.value = false;
      }, props.duration);
    }
    function hideXBar() {
      if (xBarVanishTimerId !== void 0) {
        window.clearTimeout(xBarVanishTimerId);
      }
      xBarVanishTimerId = window.setTimeout(() => {
        isShowXBarRef.value = false;
      }, props.duration);
    }
    function showXBar() {
      if (xBarVanishTimerId !== void 0) {
        window.clearTimeout(xBarVanishTimerId);
      }
      isShowXBarRef.value = true;
    }
    function showYBar() {
      if (yBarVanishTimerId !== void 0) {
        window.clearTimeout(yBarVanishTimerId);
      }
      isShowYBarRef.value = true;
    }
    function handleScroll(e) {
      const {
        onScroll
      } = props;
      if (onScroll) onScroll(e);
      syncScrollState();
    }
    function syncScrollState() {
      const {
        value: container
      } = mergedContainerRef;
      if (container) {
        containerScrollTopRef.value = container.scrollTop;
        containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
      }
    }
    function syncPositionState() {
      const {
        value: content
      } = mergedContentRef;
      if (content) {
        contentHeightRef.value = content.offsetHeight;
        contentWidthRef.value = content.offsetWidth;
      }
      const {
        value: container
      } = mergedContainerRef;
      if (container) {
        containerHeightRef.value = container.offsetHeight;
        containerWidthRef.value = container.offsetWidth;
      }
      const {
        value: xRailEl
      } = xRailRef;
      const {
        value: yRailEl
      } = yRailRef;
      if (xRailEl) {
        xRailSizeRef.value = xRailEl.offsetWidth;
      }
      if (yRailEl) {
        yRailSizeRef.value = yRailEl.offsetHeight;
      }
    }
    function syncUnifiedContainer() {
      const {
        value: container
      } = mergedContainerRef;
      if (container) {
        containerScrollTopRef.value = container.scrollTop;
        containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
        containerHeightRef.value = container.offsetHeight;
        containerWidthRef.value = container.offsetWidth;
        contentHeightRef.value = container.scrollHeight;
        contentWidthRef.value = container.scrollWidth;
      }
      const {
        value: xRailEl
      } = xRailRef;
      const {
        value: yRailEl
      } = yRailRef;
      if (xRailEl) {
        xRailSizeRef.value = xRailEl.offsetWidth;
      }
      if (yRailEl) {
        yRailSizeRef.value = yRailEl.offsetHeight;
      }
    }
    function sync() {
      if (!props.scrollable) return;
      if (props.useUnifiedContainer) {
        syncUnifiedContainer();
      } else {
        syncPositionState();
        syncScrollState();
      }
    }
    function isMouseUpAway(e) {
      var _a;
      return !((_a = wrapperRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e)));
    }
    function handleXScrollMouseDown(e) {
      e.preventDefault();
      e.stopPropagation();
      xBarPressed = true;
      on("mousemove", window, handleXScrollMouseMove, true);
      on("mouseup", window, handleXScrollMouseUp, true);
      memoXLeft = containerScrollLeftRef.value;
      memoMouseX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX : e.clientX;
    }
    function handleXScrollMouseMove(e) {
      if (!xBarPressed) return;
      if (xBarVanishTimerId !== void 0) {
        window.clearTimeout(xBarVanishTimerId);
      }
      if (yBarVanishTimerId !== void 0) {
        window.clearTimeout(yBarVanishTimerId);
      }
      const {
        value: containerWidth
      } = containerWidthRef;
      const {
        value: contentWidth
      } = contentWidthRef;
      const {
        value: xBarSize
      } = xBarSizeRef;
      if (containerWidth === null || contentWidth === null) return;
      const dX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX - memoMouseX : e.clientX - memoMouseX;
      const dScrollLeft = dX * (contentWidth - containerWidth) / (containerWidth - xBarSize);
      const toScrollLeftUpperBound = contentWidth - containerWidth;
      let toScrollLeft = memoXLeft + dScrollLeft;
      toScrollLeft = Math.min(toScrollLeftUpperBound, toScrollLeft);
      toScrollLeft = Math.max(toScrollLeft, 0);
      const {
        value: container
      } = mergedContainerRef;
      if (container) {
        container.scrollLeft = toScrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
        const {
          internalOnUpdateScrollLeft
        } = props;
        if (internalOnUpdateScrollLeft) internalOnUpdateScrollLeft(toScrollLeft);
      }
    }
    function handleXScrollMouseUp(e) {
      e.preventDefault();
      e.stopPropagation();
      off("mousemove", window, handleXScrollMouseMove, true);
      off("mouseup", window, handleXScrollMouseUp, true);
      xBarPressed = false;
      sync();
      if (isMouseUpAway(e)) {
        hideBar();
      }
    }
    function handleYScrollMouseDown(e) {
      e.preventDefault();
      e.stopPropagation();
      yBarPressed = true;
      on("mousemove", window, handleYScrollMouseMove, true);
      on("mouseup", window, handleYScrollMouseUp, true);
      memoYTop = containerScrollTopRef.value;
      memoMouseY = e.clientY;
    }
    function handleYScrollMouseMove(e) {
      if (!yBarPressed) return;
      if (xBarVanishTimerId !== void 0) {
        window.clearTimeout(xBarVanishTimerId);
      }
      if (yBarVanishTimerId !== void 0) {
        window.clearTimeout(yBarVanishTimerId);
      }
      const {
        value: containerHeight
      } = containerHeightRef;
      const {
        value: contentHeight
      } = contentHeightRef;
      const {
        value: yBarSize
      } = yBarSizeRef;
      if (containerHeight === null || contentHeight === null) return;
      const dY = e.clientY - memoMouseY;
      const dScrollTop = dY * (contentHeight - containerHeight) / (containerHeight - yBarSize);
      const toScrollTopUpperBound = contentHeight - containerHeight;
      let toScrollTop = memoYTop + dScrollTop;
      toScrollTop = Math.min(toScrollTopUpperBound, toScrollTop);
      toScrollTop = Math.max(toScrollTop, 0);
      const {
        value: container
      } = mergedContainerRef;
      if (container) {
        container.scrollTop = toScrollTop;
      }
    }
    function handleYScrollMouseUp(e) {
      e.preventDefault();
      e.stopPropagation();
      off("mousemove", window, handleYScrollMouseMove, true);
      off("mouseup", window, handleYScrollMouseUp, true);
      yBarPressed = false;
      sync();
      if (isMouseUpAway(e)) {
        hideBar();
      }
    }
    vue.watchEffect(() => {
      const {
        value: needXBar
      } = needXBarRef;
      const {
        value: needYBar
      } = needYBarRef;
      const {
        value: mergedClsPrefix
      } = mergedClsPrefixRef;
      const {
        value: xRailEl
      } = xRailRef;
      const {
        value: yRailEl
      } = yRailRef;
      if (xRailEl) {
        if (!needXBar) {
          xRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
        } else {
          xRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
        }
      }
      if (yRailEl) {
        if (!needYBar) {
          yRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
        } else {
          yRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
        }
      }
    });
    vue.onMounted(() => {
      if (props.container) return;
      sync();
    });
    vue.onBeforeUnmount(() => {
      if (xBarVanishTimerId !== void 0) {
        window.clearTimeout(xBarVanishTimerId);
      }
      if (yBarVanishTimerId !== void 0) {
        window.clearTimeout(yBarVanishTimerId);
      }
      off("mousemove", window, handleYScrollMouseMove, true);
      off("mouseup", window, handleYScrollMouseUp, true);
    });
    const cssVarsRef = vue.computed(() => {
      const {
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2
        },
        self: {
          color,
          colorHover,
          height,
          width,
          borderRadius,
          railInsetHorizontalTop,
          railInsetHorizontalBottom,
          railInsetVerticalRight,
          railInsetVerticalLeft,
          railColor
        }
      } = themeRef.value;
      const {
        top: railTopHorizontalTop,
        right: railRightHorizontalTop,
        bottom: railBottomHorizontalTop,
        left: railLeftHorizontalTop
      } = getMargin(railInsetHorizontalTop);
      const {
        top: railTopHorizontalBottom,
        right: railRightHorizontalBottom,
        bottom: railBottomHorizontalBottom,
        left: railLeftHorizontalBottom
      } = getMargin(railInsetHorizontalBottom);
      const {
        top: railTopVerticalRight,
        right: railRightVerticalRight,
        bottom: railBottomVerticalRight,
        left: railLeftVerticalRight
      } = getMargin((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? rtlInset(railInsetVerticalRight) : railInsetVerticalRight);
      const {
        top: railTopVerticalLeft,
        right: railRightVerticalLeft,
        bottom: railBottomVerticalLeft,
        left: railLeftVerticalLeft
      } = getMargin((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? rtlInset(railInsetVerticalLeft) : railInsetVerticalLeft);
      return {
        "--n-scrollbar-bezier": cubicBezierEaseInOut2,
        "--n-scrollbar-color": color,
        "--n-scrollbar-color-hover": colorHover,
        "--n-scrollbar-border-radius": borderRadius,
        "--n-scrollbar-width": width,
        "--n-scrollbar-height": height,
        "--n-scrollbar-rail-top-horizontal-top": railTopHorizontalTop,
        "--n-scrollbar-rail-right-horizontal-top": railRightHorizontalTop,
        "--n-scrollbar-rail-bottom-horizontal-top": railBottomHorizontalTop,
        "--n-scrollbar-rail-left-horizontal-top": railLeftHorizontalTop,
        "--n-scrollbar-rail-top-horizontal-bottom": railTopHorizontalBottom,
        "--n-scrollbar-rail-right-horizontal-bottom": railRightHorizontalBottom,
        "--n-scrollbar-rail-bottom-horizontal-bottom": railBottomHorizontalBottom,
        "--n-scrollbar-rail-left-horizontal-bottom": railLeftHorizontalBottom,
        "--n-scrollbar-rail-top-vertical-right": railTopVerticalRight,
        "--n-scrollbar-rail-right-vertical-right": railRightVerticalRight,
        "--n-scrollbar-rail-bottom-vertical-right": railBottomVerticalRight,
        "--n-scrollbar-rail-left-vertical-right": railLeftVerticalRight,
        "--n-scrollbar-rail-top-vertical-left": railTopVerticalLeft,
        "--n-scrollbar-rail-right-vertical-left": railRightVerticalLeft,
        "--n-scrollbar-rail-bottom-vertical-left": railBottomVerticalLeft,
        "--n-scrollbar-rail-left-vertical-left": railLeftVerticalLeft,
        "--n-scrollbar-rail-color": railColor
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("scrollbar", void 0, cssVarsRef, props) : void 0;
    const exposedMethods = {
      scrollTo,
      scrollBy,
      sync,
      syncUnifiedContainer,
      handleMouseEnterWrapper,
      handleMouseLeaveWrapper
    };
    return Object.assign(Object.assign({}, exposedMethods), {
      mergedClsPrefix: mergedClsPrefixRef,
      rtlEnabled: rtlEnabledRef,
      containerScrollTop: containerScrollTopRef,
      wrapperRef,
      containerRef,
      contentRef,
      yRailRef,
      xRailRef,
      needYBar: needYBarRef,
      needXBar: needXBarRef,
      yBarSizePx: yBarSizePxRef,
      xBarSizePx: xBarSizePxRef,
      yBarTopPx: yBarTopPxRef,
      xBarLeftPx: xBarLeftPxRef,
      isShowXBar: mergedShowXBarRef,
      isShowYBar: mergedShowYBarRef,
      isIos: isIos2,
      handleScroll,
      handleContentResize,
      handleContainerResize,
      handleYScrollMouseDown,
      handleXScrollMouseDown,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    });
  },
  render() {
    var _a;
    const {
      $slots,
      mergedClsPrefix,
      triggerDisplayManually,
      rtlEnabled,
      internalHoistYRail,
      yPlacement,
      xPlacement,
      xScrollable
    } = this;
    if (!this.scrollable) return (_a = $slots.default) === null || _a === void 0 ? void 0 : _a.call($slots);
    const triggerIsNone = this.trigger === "none";
    const createYRail = (className, style2) => {
      return vue.h("div", {
        ref: "yRailRef",
        class: [`${mergedClsPrefix}-scrollbar-rail`, `${mergedClsPrefix}-scrollbar-rail--vertical`, `${mergedClsPrefix}-scrollbar-rail--vertical--${yPlacement}`, className],
        "data-scrollbar-rail": true,
        style: [style2 || "", this.verticalRailStyle],
        "aria-hidden": true
      }, vue.h(triggerIsNone ? Wrapper : vue.Transition, triggerIsNone ? null : {
        name: "fade-in-transition"
      }, {
        default: () => this.needYBar && this.isShowYBar && !this.isIos ? vue.h("div", {
          class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`,
          style: {
            height: this.yBarSizePx,
            top: this.yBarTopPx
          },
          onMousedown: this.handleYScrollMouseDown
        }) : null
      }));
    };
    const createChildren = () => {
      var _a2, _b;
      (_a2 = this.onRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
      return vue.h("div", vue.mergeProps(this.$attrs, {
        role: "none",
        ref: "wrapperRef",
        class: [`${mergedClsPrefix}-scrollbar`, this.themeClass, rtlEnabled && `${mergedClsPrefix}-scrollbar--rtl`],
        style: this.cssVars,
        onMouseenter: triggerDisplayManually ? void 0 : this.handleMouseEnterWrapper,
        onMouseleave: triggerDisplayManually ? void 0 : this.handleMouseLeaveWrapper
      }), [this.container ? (_b = $slots.default) === null || _b === void 0 ? void 0 : _b.call($slots) : vue.h("div", {
        role: "none",
        ref: "containerRef",
        class: [`${mergedClsPrefix}-scrollbar-container`, this.containerClass],
        style: this.containerStyle,
        onScroll: this.handleScroll,
        onWheel: this.onWheel
      }, vue.h(VResizeObserver, {
        onResize: this.handleContentResize
      }, {
        default: () => vue.h("div", {
          ref: "contentRef",
          role: "none",
          style: [{
            width: this.xScrollable ? "fit-content" : null
          }, this.contentStyle],
          class: [`${mergedClsPrefix}-scrollbar-content`, this.contentClass]
        }, $slots)
      })), internalHoistYRail ? null : createYRail(void 0, void 0), xScrollable && vue.h("div", {
        ref: "xRailRef",
        class: [`${mergedClsPrefix}-scrollbar-rail`, `${mergedClsPrefix}-scrollbar-rail--horizontal`, `${mergedClsPrefix}-scrollbar-rail--horizontal--${xPlacement}`],
        style: this.horizontalRailStyle,
        "data-scrollbar-rail": true,
        "aria-hidden": true
      }, vue.h(triggerIsNone ? Wrapper : vue.Transition, triggerIsNone ? null : {
        name: "fade-in-transition"
      }, {
        default: () => this.needXBar && this.isShowXBar && !this.isIos ? vue.h("div", {
          class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`,
          style: {
            width: this.xBarSizePx,
            right: rtlEnabled ? this.xBarLeftPx : void 0,
            left: rtlEnabled ? void 0 : this.xBarLeftPx
          },
          onMousedown: this.handleXScrollMouseDown
        }) : null
      }))]);
    };
    const scrollbarNode = this.container ? createChildren() : vue.h(VResizeObserver, {
      onResize: this.handleContainerResize
    }, {
      default: createChildren
    });
    if (internalHoistYRail) {
      return vue.h(vue.Fragment, null, scrollbarNode, createYRail(this.themeClass, this.cssVars));
    } else {
      return scrollbarNode;
    }
  }
});
const XScrollbar = Scrollbar;
function toArray(arg) {
  if (Array.isArray(arg))
    return arg;
  return [arg];
}
const TRAVERSE_COMMAND = {
  STOP: "STOP"
};
function traverseWithCb(treeNode, callback) {
  const command2 = callback(treeNode);
  if (treeNode.children !== void 0 && command2 !== TRAVERSE_COMMAND.STOP) {
    treeNode.children.forEach((childNode) => traverseWithCb(childNode, callback));
  }
}
function getNonLeafKeys(treeNodes, options = {}) {
  const { preserveGroup = false } = options;
  const keys2 = [];
  const cb = preserveGroup ? (node) => {
    if (!node.isLeaf) {
      keys2.push(node.key);
      traverse(node.children);
    }
  } : (node) => {
    if (!node.isLeaf) {
      if (!node.isGroup)
        keys2.push(node.key);
      traverse(node.children);
    }
  };
  function traverse(nodes) {
    nodes.forEach(cb);
  }
  traverse(treeNodes);
  return keys2;
}
function isLeaf(rawNode, getChildren2) {
  const { isLeaf: isLeaf2 } = rawNode;
  if (isLeaf2 !== void 0)
    return isLeaf2;
  else if (!getChildren2(rawNode))
    return true;
  return false;
}
function defaultGetChildren(node) {
  return node.children;
}
function defaultGetKey(node) {
  return node.key;
}
function isIgnored() {
  return false;
}
function isShallowLoaded(rawNode, getChildren2) {
  const { isLeaf: isLeaf2 } = rawNode;
  if (isLeaf2 === false && !Array.isArray(getChildren2(rawNode)))
    return false;
  return true;
}
function isDisabled(rawNode) {
  return rawNode.disabled === true;
}
function isExpilicitlyNotLoaded(rawNode, getChildren2) {
  return rawNode.isLeaf === false && !Array.isArray(getChildren2(rawNode));
}
function isNodeInvalid(rawNode, getChildren2) {
  if (rawNode.isLeaf === true) {
    const children = getChildren2(rawNode);
    if (Array.isArray(children) && children.length > 0)
      return true;
  }
  return false;
}
function unwrapCheckedKeys(result) {
  var _a;
  if (result === void 0 || result === null)
    return [];
  if (Array.isArray(result))
    return result;
  return (_a = result.checkedKeys) !== null && _a !== void 0 ? _a : [];
}
function unwrapIndeterminateKeys(result) {
  var _a;
  if (result === void 0 || result === null || Array.isArray(result)) {
    return [];
  }
  return (_a = result.indeterminateKeys) !== null && _a !== void 0 ? _a : [];
}
function merge(originalKeys, keysToAdd) {
  const set = new Set(originalKeys);
  keysToAdd.forEach((key2) => {
    if (!set.has(key2)) {
      set.add(key2);
    }
  });
  return Array.from(set);
}
function minus(originalKeys, keysToRemove) {
  const set = new Set(originalKeys);
  keysToRemove.forEach((key2) => {
    if (set.has(key2)) {
      set.delete(key2);
    }
  });
  return Array.from(set);
}
function isGroup(rawNode) {
  return (rawNode === null || rawNode === void 0 ? void 0 : rawNode.type) === "group";
}
class SubtreeNotLoadedError extends Error {
  constructor() {
    super();
    this.message = "SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded.";
  }
}
function getExtendedCheckedKeySetAfterCheck(checkKeys, currentCheckedKeys, treeMate, allowNotLoaded) {
  return getExtendedCheckedKeySet(currentCheckedKeys.concat(checkKeys), treeMate, allowNotLoaded, false);
}
function getAvailableAscendantNodeSet(uncheckedKeys, treeMate) {
  const visitedKeys = /* @__PURE__ */ new Set();
  uncheckedKeys.forEach((uncheckedKey) => {
    const uncheckedTreeNode = treeMate.treeNodeMap.get(uncheckedKey);
    if (uncheckedTreeNode !== void 0) {
      let nodeCursor = uncheckedTreeNode.parent;
      while (nodeCursor !== null) {
        if (nodeCursor.disabled)
          break;
        if (visitedKeys.has(nodeCursor.key))
          break;
        else {
          visitedKeys.add(nodeCursor.key);
        }
        nodeCursor = nodeCursor.parent;
      }
    }
  });
  return visitedKeys;
}
function getExtendedCheckedKeySetAfterUncheck(uncheckedKeys, currentCheckedKeys, treeMate, allowNotLoaded) {
  const extendedCheckedKeySet = getExtendedCheckedKeySet(currentCheckedKeys, treeMate, allowNotLoaded, false);
  const extendedKeySetToUncheck = getExtendedCheckedKeySet(uncheckedKeys, treeMate, allowNotLoaded, true);
  const ascendantKeySet = getAvailableAscendantNodeSet(uncheckedKeys, treeMate);
  const keysToRemove = [];
  extendedCheckedKeySet.forEach((key2) => {
    if (extendedKeySetToUncheck.has(key2) || ascendantKeySet.has(key2)) {
      keysToRemove.push(key2);
    }
  });
  keysToRemove.forEach((key2) => extendedCheckedKeySet.delete(key2));
  return extendedCheckedKeySet;
}
function getCheckedKeys(options, treeMate) {
  const { checkedKeys, keysToCheck, keysToUncheck, indeterminateKeys, cascade, leafOnly, checkStrategy, allowNotLoaded } = options;
  if (!cascade) {
    if (keysToCheck !== void 0) {
      return {
        checkedKeys: merge(checkedKeys, keysToCheck),
        indeterminateKeys: Array.from(indeterminateKeys)
      };
    } else if (keysToUncheck !== void 0) {
      return {
        checkedKeys: minus(checkedKeys, keysToUncheck),
        indeterminateKeys: Array.from(indeterminateKeys)
      };
    } else {
      return {
        checkedKeys: Array.from(checkedKeys),
        indeterminateKeys: Array.from(indeterminateKeys)
      };
    }
  }
  const { levelTreeNodeMap } = treeMate;
  let extendedCheckedKeySet;
  if (keysToUncheck !== void 0) {
    extendedCheckedKeySet = getExtendedCheckedKeySetAfterUncheck(keysToUncheck, checkedKeys, treeMate, allowNotLoaded);
  } else if (keysToCheck !== void 0) {
    extendedCheckedKeySet = getExtendedCheckedKeySetAfterCheck(keysToCheck, checkedKeys, treeMate, allowNotLoaded);
  } else {
    extendedCheckedKeySet = getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, false);
  }
  const checkStrategyIsParent = checkStrategy === "parent";
  const checkStrategyIsChild = checkStrategy === "child" || leafOnly;
  const syntheticCheckedKeySet = extendedCheckedKeySet;
  const syntheticIndeterminateKeySet = /* @__PURE__ */ new Set();
  const maxLevel = Math.max.apply(null, Array.from(levelTreeNodeMap.keys()));
  for (let level = maxLevel; level >= 0; level -= 1) {
    const levelIsZero = level === 0;
    const levelTreeNodes = levelTreeNodeMap.get(level);
    for (const levelTreeNode of levelTreeNodes) {
      if (levelTreeNode.isLeaf)
        continue;
      const { key: levelTreeNodeKey, shallowLoaded } = levelTreeNode;
      if (checkStrategyIsChild && shallowLoaded) {
        levelTreeNode.children.forEach((v) => {
          if (!v.disabled && !v.isLeaf && v.shallowLoaded && syntheticCheckedKeySet.has(v.key)) {
            syntheticCheckedKeySet.delete(v.key);
          }
        });
      }
      if (levelTreeNode.disabled || !shallowLoaded) {
        continue;
      }
      let fullyChecked = true;
      let partialChecked = false;
      let allDisabled = true;
      for (const childNode of levelTreeNode.children) {
        const childKey = childNode.key;
        if (childNode.disabled)
          continue;
        if (allDisabled)
          allDisabled = false;
        if (syntheticCheckedKeySet.has(childKey)) {
          partialChecked = true;
        } else if (syntheticIndeterminateKeySet.has(childKey)) {
          partialChecked = true;
          fullyChecked = false;
          break;
        } else {
          fullyChecked = false;
          if (partialChecked) {
            break;
          }
        }
      }
      if (fullyChecked && !allDisabled) {
        if (checkStrategyIsParent) {
          levelTreeNode.children.forEach((v) => {
            if (!v.disabled && syntheticCheckedKeySet.has(v.key)) {
              syntheticCheckedKeySet.delete(v.key);
            }
          });
        }
        syntheticCheckedKeySet.add(levelTreeNodeKey);
      } else if (partialChecked) {
        syntheticIndeterminateKeySet.add(levelTreeNodeKey);
      }
      if (levelIsZero && checkStrategyIsChild && syntheticCheckedKeySet.has(levelTreeNodeKey)) {
        syntheticCheckedKeySet.delete(levelTreeNodeKey);
      }
    }
  }
  return {
    checkedKeys: Array.from(syntheticCheckedKeySet),
    indeterminateKeys: Array.from(syntheticIndeterminateKeySet)
  };
}
function getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, isUnchecking) {
  const { treeNodeMap, getChildren: getChildren2 } = treeMate;
  const visitedKeySet = /* @__PURE__ */ new Set();
  const extendedKeySet = new Set(checkedKeys);
  checkedKeys.forEach((checkedKey) => {
    const checkedTreeNode = treeNodeMap.get(checkedKey);
    if (checkedTreeNode !== void 0) {
      traverseWithCb(checkedTreeNode, (treeNode) => {
        if (treeNode.disabled) {
          return TRAVERSE_COMMAND.STOP;
        }
        const { key: key2 } = treeNode;
        if (visitedKeySet.has(key2))
          return;
        visitedKeySet.add(key2);
        extendedKeySet.add(key2);
        if (isExpilicitlyNotLoaded(treeNode.rawNode, getChildren2)) {
          if (isUnchecking) {
            return TRAVERSE_COMMAND.STOP;
          } else if (!allowNotLoaded) {
            throw new SubtreeNotLoadedError();
          }
        }
      });
    }
  });
  return extendedKeySet;
}
function getPath(key2, { includeGroup = false, includeSelf = true }, treeMate) {
  var _a;
  const treeNodeMap = treeMate.treeNodeMap;
  let treeNode = key2 === null || key2 === void 0 ? null : (_a = treeNodeMap.get(key2)) !== null && _a !== void 0 ? _a : null;
  const mergedPath = {
    keyPath: [],
    treeNodePath: [],
    treeNode
  };
  if (treeNode === null || treeNode === void 0 ? void 0 : treeNode.ignored) {
    mergedPath.treeNode = null;
    return mergedPath;
  }
  while (treeNode) {
    if (!treeNode.ignored && (includeGroup || !treeNode.isGroup)) {
      mergedPath.treeNodePath.push(treeNode);
    }
    treeNode = treeNode.parent;
  }
  mergedPath.treeNodePath.reverse();
  if (!includeSelf)
    mergedPath.treeNodePath.pop();
  mergedPath.keyPath = mergedPath.treeNodePath.map((treeNode2) => treeNode2.key);
  return mergedPath;
}
function getFirstAvailableNode(nodes) {
  if (nodes.length === 0)
    return null;
  const node = nodes[0];
  if (node.isGroup || node.ignored || node.disabled) {
    return node.getNext();
  }
  return node;
}
function rawGetNext(node, loop) {
  const sibs = node.siblings;
  const l = sibs.length;
  const { index: index2 } = node;
  if (loop) {
    return sibs[(index2 + 1) % l];
  } else {
    if (index2 === sibs.length - 1)
      return null;
    return sibs[index2 + 1];
  }
}
function move(fromNode, dir, { loop = false, includeDisabled = false } = {}) {
  const iterate = dir === "prev" ? rawGetPrev : rawGetNext;
  const getChildOptions = {
    reverse: dir === "prev"
  };
  let meet = false;
  let endNode = null;
  function traverse(node) {
    if (node === null)
      return;
    if (node === fromNode) {
      if (!meet) {
        meet = true;
      } else if (!fromNode.disabled && !fromNode.isGroup) {
        endNode = fromNode;
        return;
      }
    } else {
      if ((!node.disabled || includeDisabled) && !node.ignored && !node.isGroup) {
        endNode = node;
        return;
      }
    }
    if (node.isGroup) {
      const child = getChild(node, getChildOptions);
      if (child !== null) {
        endNode = child;
      } else {
        traverse(iterate(node, loop));
      }
    } else {
      const nextNode = iterate(node, false);
      if (nextNode !== null) {
        traverse(nextNode);
      } else {
        const parent = rawGetParent(node);
        if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {
          traverse(iterate(parent, loop));
        } else if (loop) {
          traverse(iterate(node, true));
        }
      }
    }
  }
  traverse(fromNode);
  return endNode;
}
function rawGetPrev(node, loop) {
  const sibs = node.siblings;
  const l = sibs.length;
  const { index: index2 } = node;
  if (loop) {
    return sibs[(index2 - 1 + l) % l];
  } else {
    if (index2 === 0)
      return null;
    return sibs[index2 - 1];
  }
}
function rawGetParent(node) {
  return node.parent;
}
function getChild(node, options = {}) {
  const { reverse = false } = options;
  const { children } = node;
  if (children) {
    const { length: length2 } = children;
    const start2 = reverse ? length2 - 1 : 0;
    const end2 = reverse ? -1 : length2;
    const delta = reverse ? -1 : 1;
    for (let i = start2; i !== end2; i += delta) {
      const child = children[i];
      if (!child.disabled && !child.ignored) {
        if (child.isGroup) {
          const childInGroup = getChild(child, options);
          if (childInGroup !== null)
            return childInGroup;
        } else {
          return child;
        }
      }
    }
  }
  return null;
}
const moveMethods = {
  getChild() {
    if (this.ignored)
      return null;
    return getChild(this);
  },
  getParent() {
    const { parent } = this;
    if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {
      return parent.getParent();
    }
    return parent;
  },
  getNext(options = {}) {
    return move(this, "next", options);
  },
  getPrev(options = {}) {
    return move(this, "prev", options);
  }
};
function flatten(treeNodes, expandedKeys) {
  const expandedKeySet = expandedKeys ? new Set(expandedKeys) : void 0;
  const flattenedNodes = [];
  function traverse(treeNodes2) {
    treeNodes2.forEach((treeNode) => {
      flattenedNodes.push(treeNode);
      if (treeNode.isLeaf || !treeNode.children || treeNode.ignored)
        return;
      if (treeNode.isGroup) {
        traverse(treeNode.children);
      } else if (
        // normal non-leaf node
        expandedKeySet === void 0 || expandedKeySet.has(treeNode.key)
      ) {
        traverse(treeNode.children);
      }
    });
  }
  traverse(treeNodes);
  return flattenedNodes;
}
function contains(parent, child) {
  const parentKey = parent.key;
  while (child) {
    if (child.key === parentKey)
      return true;
    child = child.parent;
  }
  return false;
}
function createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren2, parent = null, level = 0) {
  const treeNodes = [];
  rawNodes.forEach((rawNode, index2) => {
    var _a;
    if (vue.process$1.env.NODE_ENV !== "production" && isNodeInvalid(rawNode, getChildren2)) {
      console.error("[treemate]: node", rawNode, "is invalid");
    }
    const treeNode = Object.create(nodeProto);
    treeNode.rawNode = rawNode;
    treeNode.siblings = treeNodes;
    treeNode.level = level;
    treeNode.index = index2;
    treeNode.isFirstChild = index2 === 0;
    treeNode.isLastChild = index2 + 1 === rawNodes.length;
    treeNode.parent = parent;
    if (!treeNode.ignored) {
      const rawChildren = getChildren2(rawNode);
      if (Array.isArray(rawChildren)) {
        treeNode.children = createTreeNodes(rawChildren, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren2, treeNode, level + 1);
      }
    }
    treeNodes.push(treeNode);
    treeNodeMap.set(treeNode.key, treeNode);
    if (!levelTreeNodeMap.has(level))
      levelTreeNodeMap.set(level, []);
    (_a = levelTreeNodeMap.get(level)) === null || _a === void 0 ? void 0 : _a.push(treeNode);
  });
  return treeNodes;
}
function createTreeMate(rawNodes, options = {}) {
  var _a;
  const treeNodeMap = /* @__PURE__ */ new Map();
  const levelTreeNodeMap = /* @__PURE__ */ new Map();
  const { getDisabled = isDisabled, getIgnored = isIgnored, getIsGroup = isGroup, getKey = defaultGetKey } = options;
  const _getChildren = (_a = options.getChildren) !== null && _a !== void 0 ? _a : defaultGetChildren;
  const getChildren2 = options.ignoreEmptyChildren ? (node) => {
    const children = _getChildren(node);
    if (Array.isArray(children)) {
      if (!children.length)
        return null;
      return children;
    }
    return children;
  } : _getChildren;
  const nodeProto = Object.assign({
    get key() {
      return getKey(this.rawNode);
    },
    get disabled() {
      return getDisabled(this.rawNode);
    },
    get isGroup() {
      return getIsGroup(this.rawNode);
    },
    get isLeaf() {
      return isLeaf(this.rawNode, getChildren2);
    },
    get shallowLoaded() {
      return isShallowLoaded(this.rawNode, getChildren2);
    },
    get ignored() {
      return getIgnored(this.rawNode);
    },
    contains(node) {
      return contains(this, node);
    }
  }, moveMethods);
  const treeNodes = createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren2);
  function getNode(key2) {
    if (key2 === null || key2 === void 0)
      return null;
    const tmNode = treeNodeMap.get(key2);
    if (tmNode && !tmNode.isGroup && !tmNode.ignored) {
      return tmNode;
    }
    return null;
  }
  function _getNode(key2) {
    if (key2 === null || key2 === void 0)
      return null;
    const tmNode = treeNodeMap.get(key2);
    if (tmNode && !tmNode.ignored) {
      return tmNode;
    }
    return null;
  }
  function getPrev(key2, options2) {
    const node = _getNode(key2);
    if (!node)
      return null;
    return node.getPrev(options2);
  }
  function getNext(key2, options2) {
    const node = _getNode(key2);
    if (!node)
      return null;
    return node.getNext(options2);
  }
  function getParent(key2) {
    const node = _getNode(key2);
    if (!node)
      return null;
    return node.getParent();
  }
  function getChild2(key2) {
    const node = _getNode(key2);
    if (!node)
      return null;
    return node.getChild();
  }
  const treemate = {
    treeNodes,
    treeNodeMap,
    levelTreeNodeMap,
    maxLevel: Math.max(...levelTreeNodeMap.keys()),
    getChildren: getChildren2,
    getFlattenedNodes(expandedKeys) {
      return flatten(treeNodes, expandedKeys);
    },
    getNode,
    getPrev,
    getNext,
    getParent,
    getChild: getChild2,
    getFirstAvailableNode() {
      return getFirstAvailableNode(treeNodes);
    },
    getPath(key2, options2 = {}) {
      return getPath(key2, options2, treemate);
    },
    getCheckedKeys(checkedKeys, options2 = {}) {
      const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
      return getCheckedKeys({
        checkedKeys: unwrapCheckedKeys(checkedKeys),
        indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
        cascade,
        leafOnly,
        checkStrategy,
        allowNotLoaded
      }, treemate);
    },
    check(keysToCheck, checkedKeys, options2 = {}) {
      const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
      return getCheckedKeys({
        checkedKeys: unwrapCheckedKeys(checkedKeys),
        indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
        keysToCheck: keysToCheck === void 0 || keysToCheck === null ? [] : toArray(keysToCheck),
        cascade,
        leafOnly,
        checkStrategy,
        allowNotLoaded
      }, treemate);
    },
    uncheck(keysToUncheck, checkedKeys, options2 = {}) {
      const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
      return getCheckedKeys({
        checkedKeys: unwrapCheckedKeys(checkedKeys),
        indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
        keysToUncheck: keysToUncheck === null || keysToUncheck === void 0 ? [] : toArray(keysToUncheck),
        cascade,
        leafOnly,
        checkStrategy,
        allowNotLoaded
      }, treemate);
    },
    getNonLeafKeys(options2 = {}) {
      return getNonLeafKeys(treeNodes, options2);
    }
  };
  return treemate;
}
const {
  cubicBezierEaseIn,
  cubicBezierEaseOut
} = commonVariables$2;
function fadeInScaleUpTransition({
  transformOrigin = "inherit",
  duration = ".2s",
  enterScale = ".9",
  originalTransform = "",
  originalTransition = ""
} = {}) {
  return [c$1("&.fade-in-scale-up-transition-leave-active", {
    transformOrigin,
    transition: `opacity ${duration} ${cubicBezierEaseIn}, transform ${duration} ${cubicBezierEaseIn} ${originalTransition && `,${originalTransition}`}`
  }), c$1("&.fade-in-scale-up-transition-enter-active", {
    transformOrigin,
    transition: `opacity ${duration} ${cubicBezierEaseOut}, transform ${duration} ${cubicBezierEaseOut} ${originalTransition && `,${originalTransition}`}`
  }), c$1("&.fade-in-scale-up-transition-enter-from, &.fade-in-scale-up-transition-leave-to", {
    opacity: 0,
    transform: `${originalTransform} scale(${enterScale})`
  }), c$1("&.fade-in-scale-up-transition-leave-from, &.fade-in-scale-up-transition-enter-to", {
    opacity: 1,
    transform: `${originalTransform} scale(1)`
  })];
}
const commonVariables$1 = {
  space: "6px",
  spaceArrow: "10px",
  arrowOffset: "10px",
  arrowOffsetVertical: "10px",
  arrowHeight: "6px",
  padding: "8px 14px"
};
function self$5(vars) {
  const {
    boxShadow2,
    popoverColor,
    textColor2,
    borderRadius,
    fontSize: fontSize2,
    dividerColor
  } = vars;
  return Object.assign(Object.assign({}, commonVariables$1), {
    fontSize: fontSize2,
    borderRadius,
    color: popoverColor,
    dividerColor,
    textColor: textColor2,
    boxShadow: boxShadow2
  });
}
const popoverLight = createTheme({
  name: "Popover",
  common: derived,
  peers: {
    Scrollbar: scrollbarLight
  },
  self: self$5
});
const oppositePlacement = {
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
};
const arrowSize = "var(--n-arrow-height) * 1.414";
const style$3 = c$1([cB("popover", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 position: relative;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 box-shadow: var(--n-box-shadow);
 word-break: break-word;
 `, [c$1(">", [cB("scrollbar", `
 height: inherit;
 max-height: inherit;
 `)]), cNotM("raw", `
 background-color: var(--n-color);
 border-radius: var(--n-border-radius);
 `, [cNotM("scrollable", [cNotM("show-header-or-footer", "padding: var(--n-padding);")])]), cE("header", `
 padding: var(--n-padding);
 border-bottom: 1px solid var(--n-divider-color);
 transition: border-color .3s var(--n-bezier);
 `), cE("footer", `
 padding: var(--n-padding);
 border-top: 1px solid var(--n-divider-color);
 transition: border-color .3s var(--n-bezier);
 `), cM("scrollable, show-header-or-footer", [cE("content", `
 padding: var(--n-padding);
 `)])]), cB("popover-shared", `
 transform-origin: inherit;
 `, [
  cB("popover-arrow-wrapper", `
 position: absolute;
 overflow: hidden;
 pointer-events: none;
 `, [cB("popover-arrow", `
 transition: background-color .3s var(--n-bezier);
 position: absolute;
 display: block;
 width: calc(${arrowSize});
 height: calc(${arrowSize});
 box-shadow: 0 0 8px 0 rgba(0, 0, 0, .12);
 transform: rotate(45deg);
 background-color: var(--n-color);
 pointer-events: all;
 `)]),
  // body transition
  c$1("&.popover-transition-enter-from, &.popover-transition-leave-to", `
 opacity: 0;
 transform: scale(.85);
 `),
  c$1("&.popover-transition-enter-to, &.popover-transition-leave-from", `
 transform: scale(1);
 opacity: 1;
 `),
  c$1("&.popover-transition-enter-active", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .15s var(--n-bezier-ease-out),
 transform .15s var(--n-bezier-ease-out);
 `),
  c$1("&.popover-transition-leave-active", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .15s var(--n-bezier-ease-in),
 transform .15s var(--n-bezier-ease-in);
 `)
]), placementStyle("top-start", `
 top: calc(${arrowSize} / -2);
 left: calc(${getArrowOffset("top-start")} - var(--v-offset-left));
 `), placementStyle("top", `
 top: calc(${arrowSize} / -2);
 transform: translateX(calc(${arrowSize} / -2)) rotate(45deg);
 left: 50%;
 `), placementStyle("top-end", `
 top: calc(${arrowSize} / -2);
 right: calc(${getArrowOffset("top-end")} + var(--v-offset-left));
 `), placementStyle("bottom-start", `
 bottom: calc(${arrowSize} / -2);
 left: calc(${getArrowOffset("bottom-start")} - var(--v-offset-left));
 `), placementStyle("bottom", `
 bottom: calc(${arrowSize} / -2);
 transform: translateX(calc(${arrowSize} / -2)) rotate(45deg);
 left: 50%;
 `), placementStyle("bottom-end", `
 bottom: calc(${arrowSize} / -2);
 right: calc(${getArrowOffset("bottom-end")} + var(--v-offset-left));
 `), placementStyle("left-start", `
 left: calc(${arrowSize} / -2);
 top: calc(${getArrowOffset("left-start")} - var(--v-offset-top));
 `), placementStyle("left", `
 left: calc(${arrowSize} / -2);
 transform: translateY(calc(${arrowSize} / -2)) rotate(45deg);
 top: 50%;
 `), placementStyle("left-end", `
 left: calc(${arrowSize} / -2);
 bottom: calc(${getArrowOffset("left-end")} + var(--v-offset-top));
 `), placementStyle("right-start", `
 right: calc(${arrowSize} / -2);
 top: calc(${getArrowOffset("right-start")} - var(--v-offset-top));
 `), placementStyle("right", `
 right: calc(${arrowSize} / -2);
 transform: translateY(calc(${arrowSize} / -2)) rotate(45deg);
 top: 50%;
 `), placementStyle("right-end", `
 right: calc(${arrowSize} / -2);
 bottom: calc(${getArrowOffset("right-end")} + var(--v-offset-top));
 `), ...map2({
  top: ["right-start", "left-start"],
  right: ["top-end", "bottom-end"],
  bottom: ["right-end", "left-end"],
  left: ["top-start", "bottom-start"]
}, (placements2, direction) => {
  const isVertical = ["right", "left"].includes(direction);
  const sizeType = isVertical ? "width" : "height";
  return placements2.map((placement) => {
    const isReverse = placement.split("-")[1] === "end";
    const targetSize = `var(--v-target-${sizeType}, 0px)`;
    const centerOffset = `calc((${targetSize} - ${arrowSize}) / 2)`;
    const offset2 = getArrowOffset(placement);
    return c$1(`[v-placement="${placement}"] >`, [cB("popover-shared", [cM("center-arrow", [cB("popover-arrow", `${direction}: calc(max(${centerOffset}, ${offset2}) ${isReverse ? "+" : "-"} var(--v-offset-${isVertical ? "left" : "top"}));`)])])]);
  });
})]);
function getArrowOffset(placement) {
  return ["top", "bottom"].includes(placement.split("-")[0]) ? "var(--n-arrow-offset)" : "var(--n-arrow-offset-vertical)";
}
function placementStyle(placement, arrowStyleLiteral) {
  const position = placement.split("-")[0];
  const sizeStyle = ["top", "bottom"].includes(position) ? "height: var(--n-space-arrow);" : "width: var(--n-space-arrow);";
  return c$1(`[v-placement="${placement}"] >`, [cB("popover-shared", `
 margin-${oppositePlacement[position]}: var(--n-space);
 `, [cM("show-arrow", `
 margin-${oppositePlacement[position]}: var(--n-space-arrow);
 `), cM("overlap", `
 margin: 0;
 `), cCB("popover-arrow-wrapper", `
 right: 0;
 left: 0;
 top: 0;
 bottom: 0;
 ${position}: 100%;
 ${oppositePlacement[position]}: auto;
 ${sizeStyle}
 `, [cB("popover-arrow", arrowStyleLiteral)])])]);
}
const popoverBodyProps = Object.assign(Object.assign({}, useTheme.props), {
  to: useAdjustedTo.propTo,
  show: Boolean,
  trigger: String,
  showArrow: Boolean,
  delay: Number,
  duration: Number,
  raw: Boolean,
  arrowPointToCenter: Boolean,
  arrowClass: String,
  arrowStyle: [String, Object],
  arrowWrapperClass: String,
  arrowWrapperStyle: [String, Object],
  displayDirective: String,
  x: Number,
  y: Number,
  flip: Boolean,
  overlap: Boolean,
  placement: String,
  width: [Number, String],
  keepAliveOnHover: Boolean,
  scrollable: Boolean,
  contentClass: String,
  contentStyle: [Object, String],
  headerClass: String,
  headerStyle: [Object, String],
  footerClass: String,
  footerStyle: [Object, String],
  // private
  internalDeactivateImmediately: Boolean,
  animated: Boolean,
  onClickoutside: Function,
  internalTrapFocus: Boolean,
  internalOnAfterLeave: Function,
  // deprecated
  minWidth: Number,
  maxWidth: Number
});
function renderArrow({
  arrowClass,
  arrowStyle,
  arrowWrapperClass,
  arrowWrapperStyle,
  clsPrefix
}) {
  return vue.h("div", {
    key: "__popover-arrow__",
    style: arrowWrapperStyle,
    class: [`${clsPrefix}-popover-arrow-wrapper`, arrowWrapperClass]
  }, vue.h("div", {
    class: [`${clsPrefix}-popover-arrow`, arrowClass],
    style: arrowStyle
  }));
}
const NPopoverBody = vue.defineComponent({
  name: "PopoverBody",
  inheritAttrs: false,
  props: popoverBodyProps,
  setup(props, {
    slots,
    attrs
  }) {
    const {
      namespaceRef,
      mergedClsPrefixRef,
      inlineThemeDisabled,
      mergedRtlRef
    } = useConfig(props);
    const themeRef = useTheme("Popover", "-popover", style$3, popoverLight, props, mergedClsPrefixRef);
    const rtlEnabledRef = useRtl("Popover", mergedRtlRef, mergedClsPrefixRef);
    const followerRef = vue.ref(null);
    const NPopover2 = vue.inject("NPopover");
    const bodyRef = vue.ref(null);
    const followerEnabledRef = vue.ref(props.show);
    const displayedRef = vue.ref(false);
    vue.watchEffect(() => {
      const {
        show
      } = props;
      if (show && !isJsdom() && !props.internalDeactivateImmediately) {
        displayedRef.value = true;
      }
    });
    const directivesRef = vue.computed(() => {
      const {
        trigger: trigger2,
        onClickoutside
      } = props;
      const directives = [];
      const {
        positionManuallyRef: {
          value: positionManually
        }
      } = NPopover2;
      if (!positionManually) {
        if (trigger2 === "click" && !onClickoutside) {
          directives.push([clickoutside, handleClickOutside2, void 0, {
            capture: true
          }]);
        }
        if (trigger2 === "hover") {
          directives.push([mousemoveoutside, handleMouseMoveOutside]);
        }
      }
      if (onClickoutside) {
        directives.push([clickoutside, handleClickOutside2, void 0, {
          capture: true
        }]);
      }
      if (props.displayDirective === "show" || props.animated && displayedRef.value) {
        directives.push([vue.vShow, props.show]);
      }
      return directives;
    });
    const cssVarsRef = vue.computed(() => {
      const {
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2,
          cubicBezierEaseIn: cubicBezierEaseIn2,
          cubicBezierEaseOut: cubicBezierEaseOut2
        },
        self: {
          space,
          spaceArrow,
          padding,
          fontSize: fontSize2,
          textColor,
          dividerColor,
          color,
          boxShadow,
          borderRadius,
          arrowHeight,
          arrowOffset,
          arrowOffsetVertical
        }
      } = themeRef.value;
      return {
        "--n-box-shadow": boxShadow,
        "--n-bezier": cubicBezierEaseInOut2,
        "--n-bezier-ease-in": cubicBezierEaseIn2,
        "--n-bezier-ease-out": cubicBezierEaseOut2,
        "--n-font-size": fontSize2,
        "--n-text-color": textColor,
        "--n-color": color,
        "--n-divider-color": dividerColor,
        "--n-border-radius": borderRadius,
        "--n-arrow-height": arrowHeight,
        "--n-arrow-offset": arrowOffset,
        "--n-arrow-offset-vertical": arrowOffsetVertical,
        "--n-padding": padding,
        "--n-space": space,
        "--n-space-arrow": spaceArrow
      };
    });
    const styleRef = vue.computed(() => {
      const width = props.width === "trigger" ? void 0 : formatLength(props.width);
      const style2 = [];
      if (width) {
        style2.push({
          width
        });
      }
      const {
        maxWidth,
        minWidth
      } = props;
      if (maxWidth) {
        style2.push({
          maxWidth: formatLength(maxWidth)
        });
      }
      if (minWidth) {
        style2.push({
          maxWidth: formatLength(minWidth)
        });
      }
      if (!inlineThemeDisabled) {
        style2.push(cssVarsRef.value);
      }
      return style2;
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("popover", void 0, cssVarsRef, props) : void 0;
    NPopover2.setBodyInstance({
      syncPosition
    });
    vue.onBeforeUnmount(() => {
      NPopover2.setBodyInstance(null);
    });
    vue.watch(vue.toRef(props, "show"), (value) => {
      if (props.animated) return;
      if (value) {
        followerEnabledRef.value = true;
      } else {
        followerEnabledRef.value = false;
      }
    });
    function syncPosition() {
      var _a;
      (_a = followerRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
    }
    function handleMouseEnter(e) {
      if (props.trigger === "hover" && props.keepAliveOnHover && props.show) {
        NPopover2.handleMouseEnter(e);
      }
    }
    function handleMouseLeave2(e) {
      if (props.trigger === "hover" && props.keepAliveOnHover) {
        NPopover2.handleMouseLeave(e);
      }
    }
    function handleMouseMoveOutside(e) {
      if (props.trigger === "hover" && !getTriggerElement().contains(getPreciseEventTarget(e))) {
        NPopover2.handleMouseMoveOutside(e);
      }
    }
    function handleClickOutside2(e) {
      if (props.trigger === "click" && !getTriggerElement().contains(getPreciseEventTarget(e)) || props.onClickoutside) {
        NPopover2.handleClickOutside(e);
      }
    }
    function getTriggerElement() {
      return NPopover2.getTriggerElement();
    }
    vue.provide(popoverBodyInjectionKey, bodyRef);
    vue.provide(drawerBodyInjectionKey, null);
    vue.provide(modalBodyInjectionKey, null);
    function renderContentNode() {
      themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender();
      const shouldRenderDom = props.displayDirective === "show" || props.show || props.animated && displayedRef.value;
      if (!shouldRenderDom) {
        return null;
      }
      let contentNode;
      const renderBody = NPopover2.internalRenderBodyRef.value;
      const {
        value: mergedClsPrefix
      } = mergedClsPrefixRef;
      if (!renderBody) {
        const {
          value: extraClass
        } = NPopover2.extraClassRef;
        const {
          internalTrapFocus
        } = props;
        const hasHeaderOrFooter = !isSlotEmpty(slots.header) || !isSlotEmpty(slots.footer);
        const renderContentInnerNode = () => {
          var _a, _b;
          const body = hasHeaderOrFooter ? vue.h(vue.Fragment, null, resolveWrappedSlot(slots.header, (children) => {
            return children ? vue.h("div", {
              class: [`${mergedClsPrefix}-popover__header`, props.headerClass],
              style: props.headerStyle
            }, children) : null;
          }), resolveWrappedSlot(slots.default, (children) => {
            return children ? vue.h("div", {
              class: [`${mergedClsPrefix}-popover__content`, props.contentClass],
              style: props.contentStyle
            }, slots) : null;
          }), resolveWrappedSlot(slots.footer, (children) => {
            return children ? vue.h("div", {
              class: [`${mergedClsPrefix}-popover__footer`, props.footerClass],
              style: props.footerStyle
            }, children) : null;
          })) : props.scrollable ? (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots) : vue.h("div", {
            class: [`${mergedClsPrefix}-popover__content`, props.contentClass],
            style: props.contentStyle
          }, slots);
          const maybeScrollableBody = props.scrollable ? vue.h(XScrollbar, {
            themeOverrides: themeRef.value.peerOverrides.Scrollbar,
            theme: themeRef.value.peers.Scrollbar,
            contentClass: hasHeaderOrFooter ? void 0 : `${mergedClsPrefix}-popover__content ${(_b = props.contentClass) !== null && _b !== void 0 ? _b : ""}`,
            contentStyle: hasHeaderOrFooter ? void 0 : props.contentStyle
          }, {
            default: () => body
          }) : body;
          const arrow2 = props.showArrow ? renderArrow({
            arrowClass: props.arrowClass,
            arrowStyle: props.arrowStyle,
            arrowWrapperClass: props.arrowWrapperClass,
            arrowWrapperStyle: props.arrowWrapperStyle,
            clsPrefix: mergedClsPrefix
          }) : null;
          return [maybeScrollableBody, arrow2];
        };
        contentNode = vue.h("div", vue.mergeProps({
          class: [`${mergedClsPrefix}-popover`, `${mergedClsPrefix}-popover-shared`, (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) && `${mergedClsPrefix}-popover--rtl`, themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value, extraClass.map((v) => `${mergedClsPrefix}-${v}`), {
            [`${mergedClsPrefix}-popover--scrollable`]: props.scrollable,
            [`${mergedClsPrefix}-popover--show-header-or-footer`]: hasHeaderOrFooter,
            [`${mergedClsPrefix}-popover--raw`]: props.raw,
            [`${mergedClsPrefix}-popover-shared--overlap`]: props.overlap,
            [`${mergedClsPrefix}-popover-shared--show-arrow`]: props.showArrow,
            [`${mergedClsPrefix}-popover-shared--center-arrow`]: props.arrowPointToCenter
          }],
          ref: bodyRef,
          style: styleRef.value,
          onKeydown: NPopover2.handleKeydown,
          onMouseenter: handleMouseEnter,
          onMouseleave: handleMouseLeave2
        }, attrs), internalTrapFocus ? vue.h(FocusTrap, {
          active: props.show,
          autoFocus: true
        }, {
          default: renderContentInnerNode
        }) : renderContentInnerNode());
      } else {
        contentNode = renderBody(
          // The popover class and overlap class must exists, they will be used
          // to place the body & transition animation.
          // Shadow class exists for reuse box-shadow.
          [`${mergedClsPrefix}-popover-shared`, (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) && `${mergedClsPrefix}-popover--rtl`, themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value, props.overlap && `${mergedClsPrefix}-popover-shared--overlap`, props.showArrow && `${mergedClsPrefix}-popover-shared--show-arrow`, props.arrowPointToCenter && `${mergedClsPrefix}-popover-shared--center-arrow`],
          bodyRef,
          styleRef.value,
          handleMouseEnter,
          handleMouseLeave2
        );
      }
      return vue.withDirectives(contentNode, directivesRef.value);
    }
    return {
      displayed: displayedRef,
      namespace: namespaceRef,
      isMounted: NPopover2.isMountedRef,
      zIndex: NPopover2.zIndexRef,
      followerRef,
      adjustedTo: useAdjustedTo(props),
      followerEnabled: followerEnabledRef,
      renderContentNode
    };
  },
  render() {
    return vue.h(VFollower, {
      ref: "followerRef",
      zIndex: this.zIndex,
      show: this.show,
      enabled: this.followerEnabled,
      to: this.adjustedTo,
      x: this.x,
      y: this.y,
      flip: this.flip,
      placement: this.placement,
      containerClass: this.namespace,
      overlap: this.overlap,
      width: this.width === "trigger" ? "target" : void 0,
      teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey
    }, {
      default: () => {
        return this.animated ? vue.h(vue.Transition, {
          name: "popover-transition",
          appear: this.isMounted,
          // Don't use watch to enable follower, since the transition may
          // make position sync timing very subtle and buggy.
          onEnter: () => {
            this.followerEnabled = true;
          },
          onAfterLeave: () => {
            var _a;
            (_a = this.internalOnAfterLeave) === null || _a === void 0 ? void 0 : _a.call(this);
            this.followerEnabled = false;
            this.displayed = false;
          }
        }, {
          default: this.renderContentNode
        }) : this.renderContentNode();
      }
    });
  }
});
const bodyPropKeys = Object.keys(popoverBodyProps);
const triggerEventMap = {
  focus: ["onFocus", "onBlur"],
  click: ["onClick"],
  hover: ["onMouseenter", "onMouseleave"],
  manual: [],
  nested: ["onFocus", "onBlur", "onMouseenter", "onMouseleave", "onClick"]
};
function appendEvents(vNode, trigger2, events2) {
  triggerEventMap[trigger2].forEach((eventName) => {
    if (!vNode.props) {
      vNode.props = {};
    } else {
      vNode.props = Object.assign({}, vNode.props);
    }
    const originalHandler = vNode.props[eventName];
    const handler = events2[eventName];
    if (!originalHandler) {
      vNode.props[eventName] = handler;
    } else {
      vNode.props[eventName] = (...args) => {
        originalHandler(...args);
        handler(...args);
      };
    }
  });
}
const popoverBaseProps = {
  show: {
    type: Boolean,
    default: void 0
  },
  defaultShow: Boolean,
  showArrow: {
    type: Boolean,
    default: true
  },
  trigger: {
    type: String,
    default: "hover"
  },
  delay: {
    type: Number,
    default: 100
  },
  duration: {
    type: Number,
    default: 100
  },
  raw: Boolean,
  placement: {
    type: String,
    default: "top"
  },
  x: Number,
  y: Number,
  arrowPointToCenter: Boolean,
  disabled: Boolean,
  getDisabled: Function,
  displayDirective: {
    type: String,
    default: "if"
  },
  arrowClass: String,
  arrowStyle: [String, Object],
  arrowWrapperClass: String,
  arrowWrapperStyle: [String, Object],
  flip: {
    type: Boolean,
    default: true
  },
  animated: {
    type: Boolean,
    default: true
  },
  width: {
    type: [Number, String],
    default: void 0
  },
  overlap: Boolean,
  keepAliveOnHover: {
    type: Boolean,
    default: true
  },
  zIndex: Number,
  to: useAdjustedTo.propTo,
  scrollable: Boolean,
  contentClass: String,
  contentStyle: [Object, String],
  headerClass: String,
  headerStyle: [Object, String],
  footerClass: String,
  footerStyle: [Object, String],
  // events
  onClickoutside: Function,
  "onUpdate:show": [Function, Array],
  onUpdateShow: [Function, Array],
  // internal
  internalDeactivateImmediately: Boolean,
  internalSyncTargetWithParent: Boolean,
  internalInheritedEventHandlers: {
    type: Array,
    default: () => []
  },
  internalTrapFocus: Boolean,
  internalExtraClass: {
    type: Array,
    default: () => []
  },
  // deprecated
  onShow: [Function, Array],
  onHide: [Function, Array],
  arrow: {
    type: Boolean,
    default: void 0
  },
  minWidth: Number,
  maxWidth: Number
};
const popoverProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), popoverBaseProps), {
  internalOnAfterLeave: Function,
  internalRenderBody: Function
});
const NPopover = vue.defineComponent({
  name: "Popover",
  inheritAttrs: false,
  props: popoverProps,
  slots: Object,
  __popover__: true,
  setup(props) {
    if (vue.process$1.env.NODE_ENV !== "production") {
      vue.watchEffect(() => {
        if (props.maxWidth !== void 0) {
          warnOnce("popover", "`max-width` is deprecated, please use `style` instead.");
        }
        if (props.minWidth !== void 0) {
          warnOnce("popover", "`min-width` is deprecated, please use `style` instead.");
        }
        if (props.arrow !== void 0) {
          warnOnce("popover", "`arrow` is deprecated, please use `showArrow` instead.");
        }
        if (props.onHide !== void 0) {
          warnOnce("popover", "`on-hide` is deprecated, please use `on-update:show` instead.");
        }
        if (props.onShow !== void 0) {
          warnOnce("popover", "`on-show` is deprecated, please use `on-update:show` instead.");
        }
      });
    }
    const isMountedRef = isMounted();
    const binderInstRef = vue.ref(null);
    const controlledShowRef = vue.computed(() => props.show);
    const uncontrolledShowRef = vue.ref(props.defaultShow);
    const mergedShowWithoutDisabledRef = useMergedState(controlledShowRef, uncontrolledShowRef);
    const mergedShowConsideringDisabledPropRef = useMemo(() => {
      if (props.disabled) return false;
      return mergedShowWithoutDisabledRef.value;
    });
    const getMergedDisabled = () => {
      if (props.disabled) return true;
      const {
        getDisabled
      } = props;
      if (getDisabled === null || getDisabled === void 0 ? void 0 : getDisabled()) return true;
      return false;
    };
    const getMergedShow = () => {
      if (getMergedDisabled()) return false;
      return mergedShowWithoutDisabledRef.value;
    };
    const compatibleShowArrowRef = useCompitable(props, ["arrow", "showArrow"]);
    const mergedShowArrowRef = vue.computed(() => {
      if (props.overlap) return false;
      return compatibleShowArrowRef.value;
    });
    let bodyInstance = null;
    const showTimerIdRef = vue.ref(null);
    const hideTimerIdRef = vue.ref(null);
    const positionManuallyRef = useMemo(() => {
      return props.x !== void 0 && props.y !== void 0;
    });
    function doUpdateShow(value) {
      const {
        "onUpdate:show": _onUpdateShow,
        onUpdateShow,
        onShow: onShow2,
        onHide: onHide2
      } = props;
      uncontrolledShowRef.value = value;
      if (_onUpdateShow) {
        call(_onUpdateShow, value);
      }
      if (onUpdateShow) {
        call(onUpdateShow, value);
      }
      if (value && onShow2) {
        call(onShow2, true);
      }
      if (value && onHide2) {
        call(onHide2, false);
      }
    }
    function syncPosition() {
      if (bodyInstance) {
        bodyInstance.syncPosition();
      }
    }
    function clearShowTimer() {
      const {
        value: showTimerId
      } = showTimerIdRef;
      if (showTimerId) {
        window.clearTimeout(showTimerId);
        showTimerIdRef.value = null;
      }
    }
    function clearHideTimer() {
      const {
        value: hideTimerId
      } = hideTimerIdRef;
      if (hideTimerId) {
        window.clearTimeout(hideTimerId);
        hideTimerIdRef.value = null;
      }
    }
    function handleFocus() {
      const mergedDisabled = getMergedDisabled();
      if (props.trigger === "focus" && !mergedDisabled) {
        if (getMergedShow()) return;
        doUpdateShow(true);
      }
    }
    function handleBlur() {
      const mergedDisabled = getMergedDisabled();
      if (props.trigger === "focus" && !mergedDisabled) {
        if (!getMergedShow()) return;
        doUpdateShow(false);
      }
    }
    function handleMouseEnter() {
      const mergedDisabled = getMergedDisabled();
      if (props.trigger === "hover" && !mergedDisabled) {
        clearHideTimer();
        if (showTimerIdRef.value !== null) return;
        if (getMergedShow()) return;
        const delayCallback = () => {
          doUpdateShow(true);
          showTimerIdRef.value = null;
        };
        const {
          delay
        } = props;
        if (delay === 0) {
          delayCallback();
        } else {
          showTimerIdRef.value = window.setTimeout(delayCallback, delay);
        }
      }
    }
    function handleMouseLeave2() {
      const mergedDisabled = getMergedDisabled();
      if (props.trigger === "hover" && !mergedDisabled) {
        clearShowTimer();
        if (hideTimerIdRef.value !== null) return;
        if (!getMergedShow()) return;
        const delayedCallback = () => {
          doUpdateShow(false);
          hideTimerIdRef.value = null;
        };
        const {
          duration
        } = props;
        if (duration === 0) {
          delayedCallback();
        } else {
          hideTimerIdRef.value = window.setTimeout(delayedCallback, duration);
        }
      }
    }
    function handleMouseMoveOutside() {
      handleMouseLeave2();
    }
    function handleClickOutside2(e) {
      var _a;
      if (!getMergedShow()) return;
      if (props.trigger === "click") {
        clearShowTimer();
        clearHideTimer();
        doUpdateShow(false);
      }
      (_a = props.onClickoutside) === null || _a === void 0 ? void 0 : _a.call(props, e);
    }
    function handleClick2() {
      if (props.trigger === "click" && !getMergedDisabled()) {
        clearShowTimer();
        clearHideTimer();
        const nextShow = !getMergedShow();
        doUpdateShow(nextShow);
      }
    }
    function handleKeydown(e) {
      if (!props.internalTrapFocus) return;
      if (e.key === "Escape") {
        clearShowTimer();
        clearHideTimer();
        doUpdateShow(false);
      }
    }
    function setShow(value) {
      uncontrolledShowRef.value = value;
    }
    function getTriggerElement() {
      var _a;
      return (_a = binderInstRef.value) === null || _a === void 0 ? void 0 : _a.targetRef;
    }
    function setBodyInstance(value) {
      bodyInstance = value;
    }
    vue.provide("NPopover", {
      getTriggerElement,
      handleKeydown,
      handleMouseEnter,
      handleMouseLeave: handleMouseLeave2,
      handleClickOutside: handleClickOutside2,
      handleMouseMoveOutside,
      setBodyInstance,
      positionManuallyRef,
      isMountedRef,
      zIndexRef: vue.toRef(props, "zIndex"),
      extraClassRef: vue.toRef(props, "internalExtraClass"),
      internalRenderBodyRef: vue.toRef(props, "internalRenderBody")
    });
    vue.watchEffect(() => {
      if (mergedShowWithoutDisabledRef.value && getMergedDisabled()) {
        doUpdateShow(false);
      }
    });
    const returned = {
      binderInstRef,
      positionManually: positionManuallyRef,
      mergedShowConsideringDisabledProp: mergedShowConsideringDisabledPropRef,
      // if to show popover body
      uncontrolledShow: uncontrolledShowRef,
      mergedShowArrow: mergedShowArrowRef,
      getMergedShow,
      setShow,
      handleClick: handleClick2,
      handleMouseEnter,
      handleMouseLeave: handleMouseLeave2,
      handleFocus,
      handleBlur,
      syncPosition
    };
    return returned;
  },
  render() {
    var _a;
    const {
      positionManually,
      $slots: slots
    } = this;
    let triggerVNode;
    let popoverInside = false;
    if (!positionManually) {
      triggerVNode = getFirstSlotVNode(slots, "trigger");
      if (triggerVNode) {
        triggerVNode = vue.cloneVNode(triggerVNode);
        triggerVNode = triggerVNode.type === vue.Text ? vue.h("span", [triggerVNode]) : triggerVNode;
        const handlers2 = {
          onClick: this.handleClick,
          onMouseenter: this.handleMouseEnter,
          onMouseleave: this.handleMouseLeave,
          onFocus: this.handleFocus,
          onBlur: this.handleBlur
        };
        if ((_a = triggerVNode.type) === null || _a === void 0 ? void 0 : _a.__popover__) {
          popoverInside = true;
          if (!triggerVNode.props) {
            triggerVNode.props = {
              internalSyncTargetWithParent: true,
              internalInheritedEventHandlers: []
            };
          }
          triggerVNode.props.internalSyncTargetWithParent = true;
          if (!triggerVNode.props.internalInheritedEventHandlers) {
            triggerVNode.props.internalInheritedEventHandlers = [handlers2];
          } else {
            triggerVNode.props.internalInheritedEventHandlers = [handlers2, ...triggerVNode.props.internalInheritedEventHandlers];
          }
        } else {
          const {
            internalInheritedEventHandlers
          } = this;
          const ascendantAndCurrentHandlers = [handlers2, ...internalInheritedEventHandlers];
          const mergedHandlers = {
            onBlur: (e) => {
              ascendantAndCurrentHandlers.forEach((_handlers) => {
                _handlers.onBlur(e);
              });
            },
            onFocus: (e) => {
              ascendantAndCurrentHandlers.forEach((_handlers) => {
                _handlers.onFocus(e);
              });
            },
            onClick: (e) => {
              ascendantAndCurrentHandlers.forEach((_handlers) => {
                _handlers.onClick(e);
              });
            },
            onMouseenter: (e) => {
              ascendantAndCurrentHandlers.forEach((_handlers) => {
                _handlers.onMouseenter(e);
              });
            },
            onMouseleave: (e) => {
              ascendantAndCurrentHandlers.forEach((_handlers) => {
                _handlers.onMouseleave(e);
              });
            }
          };
          appendEvents(triggerVNode, internalInheritedEventHandlers ? "nested" : positionManually ? "manual" : this.trigger, mergedHandlers);
        }
      }
    }
    return vue.h(Binder, {
      ref: "binderInstRef",
      syncTarget: !popoverInside,
      syncTargetWithParent: this.internalSyncTargetWithParent
    }, {
      default: () => {
        void this.mergedShowConsideringDisabledProp;
        const mergedShow = this.getMergedShow();
        return [this.internalTrapFocus && mergedShow ? vue.withDirectives(vue.h("div", {
          style: {
            position: "fixed",
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          }
        }), [[zindexable, {
          enabled: mergedShow,
          zIndex: this.zIndex
        }]]) : null, positionManually ? null : vue.h(VTarget, null, {
          default: () => triggerVNode
        }), vue.h(NPopoverBody, keep(this.$props, bodyPropKeys, Object.assign(Object.assign({}, this.$attrs), {
          showArrow: this.mergedShowArrow,
          show: mergedShow
        })), {
          default: () => {
            var _a2, _b;
            return (_b = (_a2 = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a2);
          },
          header: () => {
            var _a2, _b;
            return (_b = (_a2 = this.$slots).header) === null || _b === void 0 ? void 0 : _b.call(_a2);
          },
          footer: () => {
            var _a2, _b;
            return (_b = (_a2 = this.$slots).footer) === null || _b === void 0 ? void 0 : _b.call(_a2);
          }
        })];
      }
    });
  }
});
const configProviderProps = {
  abstract: Boolean,
  bordered: {
    type: Boolean,
    default: void 0
  },
  clsPrefix: String,
  locale: Object,
  dateLocale: Object,
  namespace: String,
  rtl: Array,
  tag: {
    type: String,
    default: "div"
  },
  hljs: Object,
  katex: Object,
  theme: Object,
  themeOverrides: Object,
  componentOptions: Object,
  icons: Object,
  breakpoints: Object,
  preflightStyleDisabled: Boolean,
  styleMountTarget: Object,
  inlineThemeDisabled: {
    type: Boolean,
    default: void 0
  },
  // deprecated
  as: {
    type: String,
    validator: () => {
      warn("config-provider", "`as` is deprecated, please use `tag` instead.");
      return true;
    },
    default: void 0
  }
};
const NConfigProvider = vue.defineComponent({
  name: "ConfigProvider",
  alias: ["App"],
  props: configProviderProps,
  setup(props) {
    const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
    const mergedThemeRef = vue.computed(() => {
      const {
        theme
      } = props;
      if (theme === null) return void 0;
      const inheritedTheme = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeRef.value;
      return theme === void 0 ? inheritedTheme : inheritedTheme === void 0 ? theme : Object.assign({}, inheritedTheme, theme);
    });
    const mergedThemeOverridesRef = vue.computed(() => {
      const {
        themeOverrides
      } = props;
      if (themeOverrides === null) return void 0;
      if (themeOverrides === void 0) {
        return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value;
      } else {
        const inheritedThemeOverrides = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value;
        if (inheritedThemeOverrides === void 0) {
          return themeOverrides;
        } else {
          return merge$1({}, inheritedThemeOverrides, themeOverrides);
        }
      }
    });
    const mergedNamespaceRef = useMemo(() => {
      const {
        namespace: namespace2
      } = props;
      return namespace2 === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedNamespaceRef.value : namespace2;
    });
    const mergedBorderedRef = useMemo(() => {
      const {
        bordered
      } = props;
      return bordered === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBorderedRef.value : bordered;
    });
    const mergedIconsRef = vue.computed(() => {
      const {
        icons: icons2
      } = props;
      return icons2 === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedIconsRef.value : icons2;
    });
    const mergedComponentPropsRef = vue.computed(() => {
      const {
        componentOptions
      } = props;
      if (componentOptions !== void 0) return componentOptions;
      return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedComponentPropsRef.value;
    });
    const mergedClsPrefixRef = vue.computed(() => {
      const {
        clsPrefix
      } = props;
      if (clsPrefix !== void 0) return clsPrefix;
      if (NConfigProvider2) return NConfigProvider2.mergedClsPrefixRef.value;
      return defaultClsPrefix;
    });
    const mergedRtlRef = vue.computed(() => {
      var _a;
      const {
        rtl
      } = props;
      if (rtl === void 0) {
        return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedRtlRef.value;
      }
      const rtlEnabledState = {};
      for (const rtlInfo of rtl) {
        rtlEnabledState[rtlInfo.name] = vue.markRaw(rtlInfo);
        (_a = rtlInfo.peers) === null || _a === void 0 ? void 0 : _a.forEach((peerRtlInfo) => {
          if (!(peerRtlInfo.name in rtlEnabledState)) {
            rtlEnabledState[peerRtlInfo.name] = vue.markRaw(peerRtlInfo);
          }
        });
      }
      return rtlEnabledState;
    });
    const mergedBreakpointsRef = vue.computed(() => {
      return props.breakpoints || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBreakpointsRef.value);
    });
    const inlineThemeDisabled = props.inlineThemeDisabled || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.inlineThemeDisabled);
    const preflightStyleDisabled = props.preflightStyleDisabled || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled);
    const styleMountTarget = props.styleMountTarget || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget);
    const mergedThemeHashRef = vue.computed(() => {
      const {
        value: theme
      } = mergedThemeRef;
      const {
        value: mergedThemeOverrides
      } = mergedThemeOverridesRef;
      const hasThemeOverrides = mergedThemeOverrides && Object.keys(mergedThemeOverrides).length !== 0;
      const themeName = theme === null || theme === void 0 ? void 0 : theme.name;
      if (themeName) {
        if (hasThemeOverrides) {
          return `${themeName}-${murmur2(JSON.stringify(mergedThemeOverridesRef.value))}`;
        }
        return themeName;
      } else {
        if (hasThemeOverrides) {
          return murmur2(JSON.stringify(mergedThemeOverridesRef.value));
        }
        return "";
      }
    });
    vue.provide(configProviderInjectionKey, {
      mergedThemeHashRef,
      mergedBreakpointsRef,
      mergedRtlRef,
      mergedIconsRef,
      mergedComponentPropsRef,
      mergedBorderedRef,
      mergedNamespaceRef,
      mergedClsPrefixRef,
      mergedLocaleRef: vue.computed(() => {
        const {
          locale
        } = props;
        if (locale === null) return void 0;
        return locale === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedLocaleRef.value : locale;
      }),
      mergedDateLocaleRef: vue.computed(() => {
        const {
          dateLocale
        } = props;
        if (dateLocale === null) return void 0;
        return dateLocale === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedDateLocaleRef.value : dateLocale;
      }),
      mergedHljsRef: vue.computed(() => {
        const {
          hljs
        } = props;
        return hljs === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedHljsRef.value : hljs;
      }),
      mergedKatexRef: vue.computed(() => {
        const {
          katex
        } = props;
        return katex === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedKatexRef.value : katex;
      }),
      mergedThemeRef,
      mergedThemeOverridesRef,
      inlineThemeDisabled: inlineThemeDisabled || false,
      preflightStyleDisabled: preflightStyleDisabled || false,
      styleMountTarget
    });
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      mergedBordered: mergedBorderedRef,
      mergedNamespace: mergedNamespaceRef,
      mergedTheme: mergedThemeRef,
      mergedThemeOverrides: mergedThemeOverridesRef
    };
  },
  render() {
    var _a, _b, _c, _d;
    return !this.abstract ? vue.h(this.as || this.tag, {
      class: `${this.mergedClsPrefix || defaultClsPrefix}-config-provider`
    }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a)) : (_d = (_c = this.$slots).default) === null || _d === void 0 ? void 0 : _d.call(_c);
  }
});
const commonVariables = {
  padding: "4px 0",
  optionIconSizeSmall: "14px",
  optionIconSizeMedium: "16px",
  optionIconSizeLarge: "16px",
  optionIconSizeHuge: "18px",
  optionSuffixWidthSmall: "14px",
  optionSuffixWidthMedium: "14px",
  optionSuffixWidthLarge: "16px",
  optionSuffixWidthHuge: "16px",
  optionIconSuffixWidthSmall: "32px",
  optionIconSuffixWidthMedium: "32px",
  optionIconSuffixWidthLarge: "36px",
  optionIconSuffixWidthHuge: "36px",
  optionPrefixWidthSmall: "14px",
  optionPrefixWidthMedium: "14px",
  optionPrefixWidthLarge: "16px",
  optionPrefixWidthHuge: "16px",
  optionIconPrefixWidthSmall: "36px",
  optionIconPrefixWidthMedium: "36px",
  optionIconPrefixWidthLarge: "40px",
  optionIconPrefixWidthHuge: "40px"
};
function self$4(vars) {
  const {
    primaryColor,
    textColor2,
    dividerColor,
    hoverColor,
    popoverColor,
    invertedColor,
    borderRadius,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    fontSizeHuge,
    heightSmall,
    heightMedium,
    heightLarge,
    heightHuge,
    textColor3,
    opacityDisabled
  } = vars;
  return Object.assign(Object.assign({}, commonVariables), {
    optionHeightSmall: heightSmall,
    optionHeightMedium: heightMedium,
    optionHeightLarge: heightLarge,
    optionHeightHuge: heightHuge,
    borderRadius,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    fontSizeHuge,
    // non-inverted
    optionTextColor: textColor2,
    optionTextColorHover: textColor2,
    optionTextColorActive: primaryColor,
    optionTextColorChildActive: primaryColor,
    color: popoverColor,
    dividerColor,
    suffixColor: textColor2,
    prefixColor: textColor2,
    optionColorHover: hoverColor,
    optionColorActive: changeColor(primaryColor, {
      alpha: 0.1
    }),
    groupHeaderTextColor: textColor3,
    // inverted
    optionTextColorInverted: "#BBB",
    optionTextColorHoverInverted: "#FFF",
    optionTextColorActiveInverted: "#FFF",
    optionTextColorChildActiveInverted: "#FFF",
    colorInverted: invertedColor,
    dividerColorInverted: "#BBB",
    suffixColorInverted: "#BBB",
    prefixColorInverted: "#BBB",
    optionColorHoverInverted: primaryColor,
    optionColorActiveInverted: primaryColor,
    groupHeaderTextColorInverted: "#AAA",
    optionOpacityDisabled: opacityDisabled
  });
}
const dropdownLight = createTheme({
  name: "Dropdown",
  common: derived,
  peers: {
    Popover: popoverLight
  },
  self: self$4
});
const commonVars = {
  padding: "8px 14px"
};
function self$3(vars) {
  const {
    borderRadius,
    boxShadow2,
    baseColor
  } = vars;
  return Object.assign(Object.assign({}, commonVars), {
    borderRadius,
    boxShadow: boxShadow2,
    color: composite(baseColor, "rgba(0, 0, 0, .85)"),
    textColor: baseColor
  });
}
const tooltipLight = createTheme({
  name: "Tooltip",
  common: derived,
  peers: {
    Popover: popoverLight
  },
  self: self$3
});
const tooltipProps = Object.assign(Object.assign({}, popoverBaseProps), useTheme.props);
const NTooltip = vue.defineComponent({
  name: "Tooltip",
  props: tooltipProps,
  slots: Object,
  __popover__: true,
  setup(props) {
    const {
      mergedClsPrefixRef
    } = useConfig(props);
    const themeRef = useTheme("Tooltip", "-tooltip", void 0, tooltipLight, props, mergedClsPrefixRef);
    const popoverRef = vue.ref(null);
    const tooltipExposedMethod = {
      syncPosition() {
        popoverRef.value.syncPosition();
      },
      setShow(show) {
        popoverRef.value.setShow(show);
      }
    };
    return Object.assign(Object.assign({}, tooltipExposedMethod), {
      popoverRef,
      mergedTheme: themeRef,
      popoverThemeOverrides: vue.computed(() => {
        return themeRef.value.self;
      })
    });
  },
  render() {
    const {
      mergedTheme,
      internalExtraClass
    } = this;
    return vue.h(NPopover, Object.assign(Object.assign({}, this.$props), {
      theme: mergedTheme.peers.Popover,
      themeOverrides: mergedTheme.peerOverrides.Popover,
      builtinThemeOverrides: this.popoverThemeOverrides,
      internalExtraClass: internalExtraClass.concat("tooltip"),
      ref: "popoverRef"
    }), this.$slots);
  }
});
const dropdownMenuInjectionKey = createInjectionKey("n-dropdown-menu");
const dropdownInjectionKey = createInjectionKey("n-dropdown");
const dropdownOptionInjectionKey = createInjectionKey("n-dropdown-option");
const NDropdownDivider = vue.defineComponent({
  name: "DropdownDivider",
  props: {
    clsPrefix: {
      type: String,
      required: true
    }
  },
  render() {
    return vue.h("div", {
      class: `${this.clsPrefix}-dropdown-divider`
    });
  }
});
const NDropdownGroupHeader = vue.defineComponent({
  name: "DropdownGroupHeader",
  props: {
    clsPrefix: {
      type: String,
      required: true
    },
    tmNode: {
      type: Object,
      required: true
    }
  },
  setup() {
    const {
      showIconRef,
      hasSubmenuRef
    } = vue.inject(dropdownMenuInjectionKey);
    const {
      renderLabelRef,
      labelFieldRef,
      nodePropsRef,
      renderOptionRef
    } = vue.inject(dropdownInjectionKey);
    return {
      labelField: labelFieldRef,
      showIcon: showIconRef,
      hasSubmenu: hasSubmenuRef,
      renderLabel: renderLabelRef,
      nodeProps: nodePropsRef,
      renderOption: renderOptionRef
    };
  },
  render() {
    var _a;
    const {
      clsPrefix,
      hasSubmenu,
      showIcon,
      nodeProps,
      renderLabel,
      renderOption
    } = this;
    const {
      rawNode
    } = this.tmNode;
    const node = vue.h("div", Object.assign({
      class: `${clsPrefix}-dropdown-option`
    }, nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode)), vue.h("div", {
      class: `${clsPrefix}-dropdown-option-body ${clsPrefix}-dropdown-option-body--group`
    }, vue.h("div", {
      "data-dropdown-option": true,
      class: [`${clsPrefix}-dropdown-option-body__prefix`, showIcon && `${clsPrefix}-dropdown-option-body__prefix--show-icon`]
    }, render(rawNode.icon)), vue.h("div", {
      class: `${clsPrefix}-dropdown-option-body__label`,
      "data-dropdown-option": true
    }, renderLabel ? renderLabel(rawNode) : render((_a = rawNode.title) !== null && _a !== void 0 ? _a : rawNode[this.labelField])), vue.h("div", {
      class: [`${clsPrefix}-dropdown-option-body__suffix`, hasSubmenu && `${clsPrefix}-dropdown-option-body__suffix--has-submenu`],
      "data-dropdown-option": true
    })));
    if (renderOption) {
      return renderOption({
        node,
        option: rawNode
      });
    }
    return node;
  }
});
function self$2(vars) {
  const {
    textColorBase,
    opacity1,
    opacity2,
    opacity3,
    opacity4,
    opacity5
  } = vars;
  return {
    color: textColorBase,
    opacity1Depth: opacity1,
    opacity2Depth: opacity2,
    opacity3Depth: opacity3,
    opacity4Depth: opacity4,
    opacity5Depth: opacity5
  };
}
const iconLight = {
  common: derived,
  self: self$2
};
const style$2 = cB("icon", `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
`, [cM("color-transition", {
  transition: "color .3s var(--n-bezier)"
}), cM("depth", {
  color: "var(--n-color)"
}, [c$1("svg", {
  opacity: "var(--n-opacity)",
  transition: "opacity .3s var(--n-bezier)"
})]), c$1("svg", {
  height: "1em",
  width: "1em"
})]);
const iconProps = Object.assign(Object.assign({}, useTheme.props), {
  depth: [String, Number],
  size: [Number, String],
  color: String,
  component: [Object, Function]
});
const NIcon = vue.defineComponent({
  _n_icon__: true,
  name: "Icon",
  inheritAttrs: false,
  props: iconProps,
  setup(props) {
    const {
      mergedClsPrefixRef,
      inlineThemeDisabled
    } = useConfig(props);
    const themeRef = useTheme("Icon", "-icon", style$2, iconLight, props, mergedClsPrefixRef);
    const cssVarsRef = vue.computed(() => {
      const {
        depth
      } = props;
      const {
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2
        },
        self: self2
      } = themeRef.value;
      if (depth !== void 0) {
        const {
          color,
          [`opacity${depth}Depth`]: opacity
        } = self2;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-color": color,
          "--n-opacity": opacity
        };
      }
      return {
        "--n-bezier": cubicBezierEaseInOut2,
        "--n-color": "",
        "--n-opacity": ""
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("icon", vue.computed(() => `${props.depth || "d"}`), cssVarsRef, props) : void 0;
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      mergedStyle: vue.computed(() => {
        const {
          size: size2,
          color
        } = props;
        return {
          fontSize: formatLength(size2),
          color
        };
      }),
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    var _a;
    const {
      $parent,
      depth,
      mergedClsPrefix,
      component,
      onRender,
      themeClass
    } = this;
    if ((_a = $parent === null || $parent === void 0 ? void 0 : $parent.$options) === null || _a === void 0 ? void 0 : _a._n_icon__) {
      warn("icon", "don't wrap `n-icon` inside `n-icon`");
    }
    onRender === null || onRender === void 0 ? void 0 : onRender();
    return vue.h("i", vue.mergeProps(this.$attrs, {
      role: "img",
      class: [`${mergedClsPrefix}-icon`, themeClass, {
        [`${mergedClsPrefix}-icon--depth`]: depth,
        [`${mergedClsPrefix}-icon--color-transition`]: depth !== void 0
      }],
      style: [this.cssVars, this.mergedStyle]
    }), component ? vue.h(component) : this.$slots);
  }
});
function isSubmenuNode(rawNode, childrenField) {
  return rawNode.type === "submenu" || rawNode.type === void 0 && rawNode[childrenField] !== void 0;
}
function isGroupNode(rawNode) {
  return rawNode.type === "group";
}
function isDividerNode(rawNode) {
  return rawNode.type === "divider";
}
function isRenderNode(rawNode) {
  return rawNode.type === "render";
}
const NDropdownOption = vue.defineComponent({
  name: "DropdownOption",
  props: {
    clsPrefix: {
      type: String,
      required: true
    },
    tmNode: {
      type: Object,
      required: true
    },
    parentKey: {
      type: [String, Number],
      default: null
    },
    placement: {
      type: String,
      default: "right-start"
    },
    props: Object,
    scrollable: Boolean
  },
  setup(props) {
    const NDropdown2 = vue.inject(dropdownInjectionKey);
    const {
      hoverKeyRef,
      keyboardKeyRef,
      lastToggledSubmenuKeyRef,
      pendingKeyPathRef,
      activeKeyPathRef,
      animatedRef,
      mergedShowRef,
      renderLabelRef,
      renderIconRef,
      labelFieldRef,
      childrenFieldRef,
      renderOptionRef,
      nodePropsRef,
      menuPropsRef
    } = NDropdown2;
    const NDropdownOption2 = vue.inject(dropdownOptionInjectionKey, null);
    const NDropdownMenu2 = vue.inject(dropdownMenuInjectionKey);
    const NPopoverBody2 = vue.inject(popoverBodyInjectionKey);
    const rawNodeRef = vue.computed(() => props.tmNode.rawNode);
    const hasSubmenuRef = vue.computed(() => {
      const {
        value: childrenField
      } = childrenFieldRef;
      return isSubmenuNode(props.tmNode.rawNode, childrenField);
    });
    const mergedDisabledRef = vue.computed(() => {
      const {
        disabled
      } = props.tmNode;
      return disabled;
    });
    const showSubmenuRef = vue.computed(() => {
      if (!hasSubmenuRef.value) return false;
      const {
        key: key2,
        disabled
      } = props.tmNode;
      if (disabled) return false;
      const {
        value: hoverKey
      } = hoverKeyRef;
      const {
        value: keyboardKey
      } = keyboardKeyRef;
      const {
        value: lastToggledSubmenuKey
      } = lastToggledSubmenuKeyRef;
      const {
        value: pendingKeyPath
      } = pendingKeyPathRef;
      if (hoverKey !== null) return pendingKeyPath.includes(key2);
      if (keyboardKey !== null) {
        return pendingKeyPath.includes(key2) && pendingKeyPath[pendingKeyPath.length - 1] !== key2;
      }
      if (lastToggledSubmenuKey !== null) return pendingKeyPath.includes(key2);
      return false;
    });
    const shouldDelayRef = vue.computed(() => {
      return keyboardKeyRef.value === null && !animatedRef.value;
    });
    const deferredShowSubmenuRef = useDeferredTrue(showSubmenuRef, 300, shouldDelayRef);
    const parentEnteringSubmenuRef = vue.computed(() => {
      return !!(NDropdownOption2 === null || NDropdownOption2 === void 0 ? void 0 : NDropdownOption2.enteringSubmenuRef.value);
    });
    const enteringSubmenuRef = vue.ref(false);
    vue.provide(dropdownOptionInjectionKey, {
      enteringSubmenuRef
    });
    function handleSubmenuBeforeEnter() {
      enteringSubmenuRef.value = true;
    }
    function handleSubmenuAfterEnter() {
      enteringSubmenuRef.value = false;
    }
    function handleMouseEnter() {
      const {
        parentKey,
        tmNode
      } = props;
      if (tmNode.disabled) return;
      if (!mergedShowRef.value) return;
      lastToggledSubmenuKeyRef.value = parentKey;
      keyboardKeyRef.value = null;
      hoverKeyRef.value = tmNode.key;
    }
    function handleMouseMove2() {
      const {
        tmNode
      } = props;
      if (tmNode.disabled) return;
      if (!mergedShowRef.value) return;
      if (hoverKeyRef.value === tmNode.key) return;
      handleMouseEnter();
    }
    function handleMouseLeave2(e) {
      if (props.tmNode.disabled) return;
      if (!mergedShowRef.value) return;
      const {
        relatedTarget
      } = e;
      if (relatedTarget && !happensIn({
        target: relatedTarget
      }, "dropdownOption") && !happensIn({
        target: relatedTarget
      }, "scrollbarRail")) {
        hoverKeyRef.value = null;
      }
    }
    function handleClick2() {
      const {
        value: hasSubmenu
      } = hasSubmenuRef;
      const {
        tmNode
      } = props;
      if (!mergedShowRef.value) return;
      if (!hasSubmenu && !tmNode.disabled) {
        NDropdown2.doSelect(tmNode.key, tmNode.rawNode);
        NDropdown2.doUpdateShow(false);
      }
    }
    return {
      labelField: labelFieldRef,
      renderLabel: renderLabelRef,
      renderIcon: renderIconRef,
      siblingHasIcon: NDropdownMenu2.showIconRef,
      siblingHasSubmenu: NDropdownMenu2.hasSubmenuRef,
      menuProps: menuPropsRef,
      popoverBody: NPopoverBody2,
      animated: animatedRef,
      mergedShowSubmenu: vue.computed(() => {
        return deferredShowSubmenuRef.value && !parentEnteringSubmenuRef.value;
      }),
      rawNode: rawNodeRef,
      hasSubmenu: hasSubmenuRef,
      pending: useMemo(() => {
        const {
          value: pendingKeyPath
        } = pendingKeyPathRef;
        const {
          key: key2
        } = props.tmNode;
        return pendingKeyPath.includes(key2);
      }),
      childActive: useMemo(() => {
        const {
          value: activeKeyPath
        } = activeKeyPathRef;
        const {
          key: key2
        } = props.tmNode;
        const index2 = activeKeyPath.findIndex((k2) => key2 === k2);
        if (index2 === -1) return false;
        return index2 < activeKeyPath.length - 1;
      }),
      active: useMemo(() => {
        const {
          value: activeKeyPath
        } = activeKeyPathRef;
        const {
          key: key2
        } = props.tmNode;
        const index2 = activeKeyPath.findIndex((k2) => key2 === k2);
        if (index2 === -1) return false;
        return index2 === activeKeyPath.length - 1;
      }),
      mergedDisabled: mergedDisabledRef,
      renderOption: renderOptionRef,
      nodeProps: nodePropsRef,
      handleClick: handleClick2,
      handleMouseMove: handleMouseMove2,
      handleMouseEnter,
      handleMouseLeave: handleMouseLeave2,
      handleSubmenuBeforeEnter,
      handleSubmenuAfterEnter
    };
  },
  render() {
    var _a, _b;
    const {
      animated,
      rawNode,
      mergedShowSubmenu,
      clsPrefix,
      siblingHasIcon,
      siblingHasSubmenu,
      renderLabel,
      renderIcon,
      renderOption,
      nodeProps,
      props,
      scrollable
    } = this;
    let submenuVNode = null;
    if (mergedShowSubmenu) {
      const submenuNodeProps = (_a = this.menuProps) === null || _a === void 0 ? void 0 : _a.call(this, rawNode, rawNode.children);
      submenuVNode = vue.h(NDropdownMenu, Object.assign({}, submenuNodeProps, {
        clsPrefix,
        scrollable: this.scrollable,
        tmNodes: this.tmNode.children,
        parentKey: this.tmNode.key
      }));
    }
    const builtinProps = {
      class: [`${clsPrefix}-dropdown-option-body`, this.pending && `${clsPrefix}-dropdown-option-body--pending`, this.active && `${clsPrefix}-dropdown-option-body--active`, this.childActive && `${clsPrefix}-dropdown-option-body--child-active`, this.mergedDisabled && `${clsPrefix}-dropdown-option-body--disabled`],
      onMousemove: this.handleMouseMove,
      onMouseenter: this.handleMouseEnter,
      onMouseleave: this.handleMouseLeave,
      onClick: this.handleClick
    };
    const optionNodeProps = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode);
    const node = vue.h("div", Object.assign({
      class: [`${clsPrefix}-dropdown-option`, optionNodeProps === null || optionNodeProps === void 0 ? void 0 : optionNodeProps.class],
      "data-dropdown-option": true
    }, optionNodeProps), vue.h("div", vue.mergeProps(builtinProps, props), [vue.h("div", {
      class: [`${clsPrefix}-dropdown-option-body__prefix`, siblingHasIcon && `${clsPrefix}-dropdown-option-body__prefix--show-icon`]
    }, [renderIcon ? renderIcon(rawNode) : render(rawNode.icon)]), vue.h("div", {
      "data-dropdown-option": true,
      class: `${clsPrefix}-dropdown-option-body__label`
    }, renderLabel ? renderLabel(rawNode) : render((_b = rawNode[this.labelField]) !== null && _b !== void 0 ? _b : rawNode.title)), vue.h("div", {
      "data-dropdown-option": true,
      class: [`${clsPrefix}-dropdown-option-body__suffix`, siblingHasSubmenu && `${clsPrefix}-dropdown-option-body__suffix--has-submenu`]
    }, this.hasSubmenu ? vue.h(NIcon, null, {
      default: () => vue.h(ChevronRightIcon, null)
    }) : null)]), this.hasSubmenu ? vue.h(Binder, null, {
      default: () => [vue.h(VTarget, null, {
        default: () => vue.h("div", {
          class: `${clsPrefix}-dropdown-offset-container`
        }, vue.h(VFollower, {
          show: this.mergedShowSubmenu,
          placement: this.placement,
          to: scrollable ? this.popoverBody || void 0 : void 0,
          teleportDisabled: !scrollable
        }, {
          default: () => {
            return vue.h("div", {
              class: `${clsPrefix}-dropdown-menu-wrapper`
            }, animated ? vue.h(vue.Transition, {
              onBeforeEnter: this.handleSubmenuBeforeEnter,
              onAfterEnter: this.handleSubmenuAfterEnter,
              name: "fade-in-scale-up-transition",
              appear: true
            }, {
              default: () => submenuVNode
            }) : submenuVNode);
          }
        }))
      })]
    }) : null);
    if (renderOption) {
      return renderOption({
        node,
        option: rawNode
      });
    }
    return node;
  }
});
const NDropdownGroup = vue.defineComponent({
  name: "NDropdownGroup",
  props: {
    clsPrefix: {
      type: String,
      required: true
    },
    tmNode: {
      type: Object,
      required: true
    },
    parentKey: {
      type: [String, Number],
      default: null
    }
  },
  render() {
    const {
      tmNode,
      parentKey,
      clsPrefix
    } = this;
    const {
      children
    } = tmNode;
    return vue.h(vue.Fragment, null, vue.h(NDropdownGroupHeader, {
      clsPrefix,
      tmNode,
      key: tmNode.key
    }), children === null || children === void 0 ? void 0 : children.map((child) => {
      const {
        rawNode
      } = child;
      if (rawNode.show === false) return null;
      if (isDividerNode(rawNode)) {
        return vue.h(NDropdownDivider, {
          clsPrefix,
          key: child.key
        });
      }
      if (child.isGroup) {
        warn("dropdown", "`group` node is not allowed to be put in `group` node.");
        return null;
      }
      return vue.h(NDropdownOption, {
        clsPrefix,
        tmNode: child,
        parentKey,
        key: child.key
      });
    }));
  }
});
const NDropdownRenderOption = vue.defineComponent({
  name: "DropdownRenderOption",
  props: {
    tmNode: {
      type: Object,
      required: true
    }
  },
  render() {
    const {
      rawNode: {
        render: render2,
        props
      }
    } = this.tmNode;
    return vue.h("div", props, [render2 === null || render2 === void 0 ? void 0 : render2()]);
  }
});
const NDropdownMenu = vue.defineComponent({
  name: "DropdownMenu",
  props: {
    scrollable: Boolean,
    showArrow: Boolean,
    arrowStyle: [String, Object],
    clsPrefix: {
      type: String,
      required: true
    },
    tmNodes: {
      type: Array,
      default: () => []
    },
    parentKey: {
      type: [String, Number],
      default: null
    }
  },
  setup(props) {
    const {
      renderIconRef,
      childrenFieldRef
    } = vue.inject(dropdownInjectionKey);
    vue.provide(dropdownMenuInjectionKey, {
      showIconRef: vue.computed(() => {
        const renderIcon = renderIconRef.value;
        return props.tmNodes.some((tmNode) => {
          var _a;
          if (tmNode.isGroup) {
            return (_a = tmNode.children) === null || _a === void 0 ? void 0 : _a.some(({
              rawNode: rawChild
            }) => renderIcon ? renderIcon(rawChild) : rawChild.icon);
          }
          const {
            rawNode
          } = tmNode;
          return renderIcon ? renderIcon(rawNode) : rawNode.icon;
        });
      }),
      hasSubmenuRef: vue.computed(() => {
        const {
          value: childrenField
        } = childrenFieldRef;
        return props.tmNodes.some((tmNode) => {
          var _a;
          if (tmNode.isGroup) {
            return (_a = tmNode.children) === null || _a === void 0 ? void 0 : _a.some(({
              rawNode: rawChild
            }) => isSubmenuNode(rawChild, childrenField));
          }
          const {
            rawNode
          } = tmNode;
          return isSubmenuNode(rawNode, childrenField);
        });
      })
    });
    const bodyRef = vue.ref(null);
    vue.provide(modalBodyInjectionKey, null);
    vue.provide(drawerBodyInjectionKey, null);
    vue.provide(popoverBodyInjectionKey, bodyRef);
    return {
      bodyRef
    };
  },
  render() {
    const {
      parentKey,
      clsPrefix,
      scrollable
    } = this;
    const menuOptionsNode = this.tmNodes.map((tmNode) => {
      const {
        rawNode
      } = tmNode;
      if (rawNode.show === false) return null;
      if (isRenderNode(rawNode)) {
        return vue.h(NDropdownRenderOption, {
          tmNode,
          key: tmNode.key
        });
      }
      if (isDividerNode(rawNode)) {
        return vue.h(NDropdownDivider, {
          clsPrefix,
          key: tmNode.key
        });
      }
      if (isGroupNode(rawNode)) {
        return vue.h(NDropdownGroup, {
          clsPrefix,
          tmNode,
          parentKey,
          key: tmNode.key
        });
      }
      return vue.h(NDropdownOption, {
        clsPrefix,
        tmNode,
        parentKey,
        key: tmNode.key,
        props: rawNode.props,
        scrollable
      });
    });
    return vue.h("div", {
      class: [`${clsPrefix}-dropdown-menu`, scrollable && `${clsPrefix}-dropdown-menu--scrollable`],
      ref: "bodyRef"
    }, scrollable ? vue.h(XScrollbar, {
      contentClass: `${clsPrefix}-dropdown-menu__content`
    }, {
      default: () => menuOptionsNode
    }) : menuOptionsNode, this.showArrow ? renderArrow({
      clsPrefix,
      arrowStyle: this.arrowStyle,
      arrowClass: void 0,
      arrowWrapperClass: void 0,
      arrowWrapperStyle: void 0
    }) : null);
  }
});
const style$1 = cB("dropdown-menu", `
 transform-origin: var(--v-transform-origin);
 background-color: var(--n-color);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 position: relative;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
`, [fadeInScaleUpTransition(), cB("dropdown-option", `
 position: relative;
 `, [c$1("a", `
 text-decoration: none;
 color: inherit;
 outline: none;
 `, [c$1("&::before", `
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), cB("dropdown-option-body", `
 display: flex;
 cursor: pointer;
 position: relative;
 height: var(--n-option-height);
 line-height: var(--n-option-height);
 font-size: var(--n-font-size);
 color: var(--n-option-text-color);
 transition: color .3s var(--n-bezier);
 `, [c$1("&::before", `
 content: "";
 position: absolute;
 top: 0;
 bottom: 0;
 left: 4px;
 right: 4px;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 `), cNotM("disabled", [cM("pending", `
 color: var(--n-option-text-color-hover);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-hover);
 `), c$1("&::before", "background-color: var(--n-option-color-hover);")]), cM("active", `
 color: var(--n-option-text-color-active);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-active);
 `), c$1("&::before", "background-color: var(--n-option-color-active);")]), cM("child-active", `
 color: var(--n-option-text-color-child-active);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-child-active);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 opacity: var(--n-option-opacity-disabled);
 `), cM("group", `
 font-size: calc(var(--n-font-size) - 1px);
 color: var(--n-group-header-text-color);
 `, [cE("prefix", `
 width: calc(var(--n-option-prefix-width) / 2);
 `, [cM("show-icon", `
 width: calc(var(--n-option-icon-prefix-width) / 2);
 `)])]), cE("prefix", `
 width: var(--n-option-prefix-width);
 display: flex;
 justify-content: center;
 align-items: center;
 color: var(--n-prefix-color);
 transition: color .3s var(--n-bezier);
 z-index: 1;
 `, [cM("show-icon", `
 width: var(--n-option-icon-prefix-width);
 `), cB("icon", `
 font-size: var(--n-option-icon-size);
 `)]), cE("label", `
 white-space: nowrap;
 flex: 1;
 z-index: 1;
 `), cE("suffix", `
 box-sizing: border-box;
 flex-grow: 0;
 flex-shrink: 0;
 display: flex;
 justify-content: flex-end;
 align-items: center;
 min-width: var(--n-option-suffix-width);
 padding: 0 8px;
 transition: color .3s var(--n-bezier);
 color: var(--n-suffix-color);
 z-index: 1;
 `, [cM("has-submenu", `
 width: var(--n-option-icon-suffix-width);
 `), cB("icon", `
 font-size: var(--n-option-icon-size);
 `)]), cB("dropdown-menu", "pointer-events: all;")]), cB("dropdown-offset-container", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: -4px;
 bottom: -4px;
 `)]), cB("dropdown-divider", `
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-divider-color);
 height: 1px;
 margin: 4px 0;
 `), cB("dropdown-menu-wrapper", `
 transform-origin: var(--v-transform-origin);
 width: fit-content;
 `), c$1(">", [cB("scrollbar", `
 height: inherit;
 max-height: inherit;
 `)]), cNotM("scrollable", `
 padding: var(--n-padding);
 `), cM("scrollable", [cE("content", `
 padding: var(--n-padding);
 `)])]);
const dropdownBaseProps = {
  animated: {
    type: Boolean,
    default: true
  },
  keyboard: {
    type: Boolean,
    default: true
  },
  size: {
    type: String,
    default: "medium"
  },
  inverted: Boolean,
  placement: {
    type: String,
    default: "bottom"
  },
  onSelect: [Function, Array],
  options: {
    type: Array,
    default: () => []
  },
  menuProps: Function,
  showArrow: Boolean,
  renderLabel: Function,
  renderIcon: Function,
  renderOption: Function,
  nodeProps: Function,
  labelField: {
    type: String,
    default: "label"
  },
  keyField: {
    type: String,
    default: "key"
  },
  childrenField: {
    type: String,
    default: "children"
  },
  // for menu, not documented
  value: [String, Number]
};
const popoverPropKeys = Object.keys(popoverBaseProps);
const dropdownProps = Object.assign(Object.assign(Object.assign({}, popoverBaseProps), dropdownBaseProps), useTheme.props);
const NDropdown = vue.defineComponent({
  name: "Dropdown",
  inheritAttrs: false,
  props: dropdownProps,
  setup(props) {
    const uncontrolledShowRef = vue.ref(false);
    const mergedShowRef = useMergedState(vue.toRef(props, "show"), uncontrolledShowRef);
    const treemateRef = vue.computed(() => {
      const {
        keyField,
        childrenField
      } = props;
      return createTreeMate(props.options, {
        getKey(node) {
          return node[keyField];
        },
        getDisabled(node) {
          return node.disabled === true;
        },
        getIgnored(node) {
          return node.type === "divider" || node.type === "render";
        },
        getChildren(node) {
          return node[childrenField];
        }
      });
    });
    const tmNodesRef = vue.computed(() => {
      return treemateRef.value.treeNodes;
    });
    const hoverKeyRef = vue.ref(null);
    const keyboardKeyRef = vue.ref(null);
    const lastToggledSubmenuKeyRef = vue.ref(null);
    const pendingKeyRef = vue.computed(() => {
      var _a, _b, _c;
      return (_c = (_b = (_a = hoverKeyRef.value) !== null && _a !== void 0 ? _a : keyboardKeyRef.value) !== null && _b !== void 0 ? _b : lastToggledSubmenuKeyRef.value) !== null && _c !== void 0 ? _c : null;
    });
    const pendingKeyPathRef = vue.computed(() => treemateRef.value.getPath(pendingKeyRef.value).keyPath);
    const activeKeyPathRef = vue.computed(() => treemateRef.value.getPath(props.value).keyPath);
    const keyboardEnabledRef = useMemo(() => {
      return props.keyboard && mergedShowRef.value;
    });
    useKeyboard({
      keydown: {
        ArrowUp: {
          prevent: true,
          handler: handleKeydownUp
        },
        ArrowRight: {
          prevent: true,
          handler: handleKeydownRight
        },
        ArrowDown: {
          prevent: true,
          handler: handleKeydownDown
        },
        ArrowLeft: {
          prevent: true,
          handler: handleKeydownLeft
        },
        Enter: {
          prevent: true,
          handler: handleKeydownEnter
        },
        Escape: handleKeydownEsc
      }
    }, keyboardEnabledRef);
    const {
      mergedClsPrefixRef,
      inlineThemeDisabled
    } = useConfig(props);
    const themeRef = useTheme("Dropdown", "-dropdown", style$1, dropdownLight, props, mergedClsPrefixRef);
    vue.provide(dropdownInjectionKey, {
      labelFieldRef: vue.toRef(props, "labelField"),
      childrenFieldRef: vue.toRef(props, "childrenField"),
      renderLabelRef: vue.toRef(props, "renderLabel"),
      renderIconRef: vue.toRef(props, "renderIcon"),
      hoverKeyRef,
      keyboardKeyRef,
      lastToggledSubmenuKeyRef,
      pendingKeyPathRef,
      activeKeyPathRef,
      animatedRef: vue.toRef(props, "animated"),
      mergedShowRef,
      nodePropsRef: vue.toRef(props, "nodeProps"),
      renderOptionRef: vue.toRef(props, "renderOption"),
      menuPropsRef: vue.toRef(props, "menuProps"),
      doSelect,
      doUpdateShow
    });
    vue.watch(mergedShowRef, (value) => {
      if (!props.animated && !value) {
        clearPendingState();
      }
    });
    function doSelect(key2, node) {
      const {
        onSelect
      } = props;
      if (onSelect) call(onSelect, key2, node);
    }
    function doUpdateShow(value) {
      const {
        "onUpdate:show": _onUpdateShow,
        onUpdateShow
      } = props;
      if (_onUpdateShow) call(_onUpdateShow, value);
      if (onUpdateShow) call(onUpdateShow, value);
      uncontrolledShowRef.value = value;
    }
    function clearPendingState() {
      hoverKeyRef.value = null;
      keyboardKeyRef.value = null;
      lastToggledSubmenuKeyRef.value = null;
    }
    function handleKeydownEsc() {
      doUpdateShow(false);
    }
    function handleKeydownLeft() {
      handleKeydown("left");
    }
    function handleKeydownRight() {
      handleKeydown("right");
    }
    function handleKeydownUp() {
      handleKeydown("up");
    }
    function handleKeydownDown() {
      handleKeydown("down");
    }
    function handleKeydownEnter() {
      const pendingNode = getPendingNode();
      if ((pendingNode === null || pendingNode === void 0 ? void 0 : pendingNode.isLeaf) && mergedShowRef.value) {
        doSelect(pendingNode.key, pendingNode.rawNode);
        doUpdateShow(false);
      }
    }
    function getPendingNode() {
      var _a;
      const {
        value: treeMate
      } = treemateRef;
      const {
        value: pendingKey
      } = pendingKeyRef;
      if (!treeMate || pendingKey === null) return null;
      return (_a = treeMate.getNode(pendingKey)) !== null && _a !== void 0 ? _a : null;
    }
    function handleKeydown(direction) {
      const {
        value: pendingKey
      } = pendingKeyRef;
      const {
        value: {
          getFirstAvailableNode: getFirstAvailableNode2
        }
      } = treemateRef;
      let nextKeyboardKey = null;
      if (pendingKey === null) {
        const firstNode = getFirstAvailableNode2();
        if (firstNode !== null) {
          nextKeyboardKey = firstNode.key;
        }
      } else {
        const currentNode = getPendingNode();
        if (currentNode) {
          let nextNode;
          switch (direction) {
            case "down":
              nextNode = currentNode.getNext();
              break;
            case "up":
              nextNode = currentNode.getPrev();
              break;
            case "right":
              nextNode = currentNode.getChild();
              break;
            case "left":
              nextNode = currentNode.getParent();
              break;
          }
          if (nextNode) nextKeyboardKey = nextNode.key;
        }
      }
      if (nextKeyboardKey !== null) {
        hoverKeyRef.value = null;
        keyboardKeyRef.value = nextKeyboardKey;
      }
    }
    const cssVarsRef = vue.computed(() => {
      const {
        size: size2,
        inverted
      } = props;
      const {
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2
        },
        self: self2
      } = themeRef.value;
      const {
        padding,
        dividerColor,
        borderRadius,
        optionOpacityDisabled,
        [createKey("optionIconSuffixWidth", size2)]: optionIconSuffixWidth,
        [createKey("optionSuffixWidth", size2)]: optionSuffixWidth,
        [createKey("optionIconPrefixWidth", size2)]: optionIconPrefixWidth,
        [createKey("optionPrefixWidth", size2)]: optionPrefixWidth,
        [createKey("fontSize", size2)]: fontSize2,
        [createKey("optionHeight", size2)]: optionHeight,
        [createKey("optionIconSize", size2)]: optionIconSize
      } = self2;
      const vars = {
        "--n-bezier": cubicBezierEaseInOut2,
        "--n-font-size": fontSize2,
        "--n-padding": padding,
        "--n-border-radius": borderRadius,
        "--n-option-height": optionHeight,
        "--n-option-prefix-width": optionPrefixWidth,
        "--n-option-icon-prefix-width": optionIconPrefixWidth,
        "--n-option-suffix-width": optionSuffixWidth,
        "--n-option-icon-suffix-width": optionIconSuffixWidth,
        "--n-option-icon-size": optionIconSize,
        "--n-divider-color": dividerColor,
        "--n-option-opacity-disabled": optionOpacityDisabled
      };
      if (inverted) {
        vars["--n-color"] = self2.colorInverted;
        vars["--n-option-color-hover"] = self2.optionColorHoverInverted;
        vars["--n-option-color-active"] = self2.optionColorActiveInverted;
        vars["--n-option-text-color"] = self2.optionTextColorInverted;
        vars["--n-option-text-color-hover"] = self2.optionTextColorHoverInverted;
        vars["--n-option-text-color-active"] = self2.optionTextColorActiveInverted;
        vars["--n-option-text-color-child-active"] = self2.optionTextColorChildActiveInverted;
        vars["--n-prefix-color"] = self2.prefixColorInverted;
        vars["--n-suffix-color"] = self2.suffixColorInverted;
        vars["--n-group-header-text-color"] = self2.groupHeaderTextColorInverted;
      } else {
        vars["--n-color"] = self2.color;
        vars["--n-option-color-hover"] = self2.optionColorHover;
        vars["--n-option-color-active"] = self2.optionColorActive;
        vars["--n-option-text-color"] = self2.optionTextColor;
        vars["--n-option-text-color-hover"] = self2.optionTextColorHover;
        vars["--n-option-text-color-active"] = self2.optionTextColorActive;
        vars["--n-option-text-color-child-active"] = self2.optionTextColorChildActive;
        vars["--n-prefix-color"] = self2.prefixColor;
        vars["--n-suffix-color"] = self2.suffixColor;
        vars["--n-group-header-text-color"] = self2.groupHeaderTextColor;
      }
      return vars;
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("dropdown", vue.computed(() => `${props.size[0]}${props.inverted ? "i" : ""}`), cssVarsRef, props) : void 0;
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      mergedTheme: themeRef,
      // data
      tmNodes: tmNodesRef,
      // show
      mergedShow: mergedShowRef,
      // methods
      handleAfterLeave: () => {
        if (!props.animated) return;
        clearPendingState();
      },
      doUpdateShow,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    const renderPopoverBody = (className, ref, style2, onMouseenter, onMouseleave) => {
      var _a;
      const {
        mergedClsPrefix,
        menuProps
      } = this;
      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
      const menuNodeProps = (menuProps === null || menuProps === void 0 ? void 0 : menuProps(void 0, this.tmNodes.map((v) => v.rawNode))) || {};
      const dropdownProps2 = {
        ref: createRefSetter(ref),
        class: [className, `${mergedClsPrefix}-dropdown`, this.themeClass],
        clsPrefix: mergedClsPrefix,
        tmNodes: this.tmNodes,
        style: [...style2, this.cssVars],
        showArrow: this.showArrow,
        arrowStyle: this.arrowStyle,
        scrollable: this.scrollable,
        onMouseenter,
        onMouseleave
      };
      return vue.h(NDropdownMenu, vue.mergeProps(this.$attrs, dropdownProps2, menuNodeProps));
    };
    const {
      mergedTheme
    } = this;
    const popoverProps2 = {
      show: this.mergedShow,
      theme: mergedTheme.peers.Popover,
      themeOverrides: mergedTheme.peerOverrides.Popover,
      internalOnAfterLeave: this.handleAfterLeave,
      internalRenderBody: renderPopoverBody,
      onUpdateShow: this.doUpdateShow,
      "onUpdate:show": void 0
    };
    return vue.h(NPopover, Object.assign({}, keep(this.$props, popoverPropKeys), popoverProps2), {
      trigger: () => {
        var _a, _b;
        return (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
    });
  }
});
const messageApiInjectionKey = createInjectionKey("n-message-api");
const messageProviderInjectionKey = createInjectionKey("n-message-provider");
function useMessage() {
  const api = vue.inject(messageApiInjectionKey, null);
  if (api === null) {
    throwError("use-message", "No outer <n-message-provider /> founded. See prerequisite in https://www.naiveui.com/en-US/os-theme/components/message for more details. If you want to use `useMessage` outside setup, please check https://www.naiveui.com/zh-CN/os-theme/components/message#Q-&-A.");
  }
  return api;
}
function self$1(vars) {
  const {
    heightSmall,
    heightMedium,
    heightLarge,
    borderRadius
  } = vars;
  return {
    color: "#eee",
    colorEnd: "#ddd",
    borderRadius,
    heightSmall,
    heightMedium,
    heightLarge
  };
}
const skeletonLight = {
  common: derived,
  self: self$1
};
const style = c$1([cB("skeleton", `
 height: 1em;
 width: 100%;
 transition:
 --n-color-start .3s var(--n-bezier),
 --n-color-end .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 animation: 2s skeleton-loading infinite cubic-bezier(0.36, 0, 0.64, 1);
 background-color: var(--n-color-start);
 `), c$1("@keyframes skeleton-loading", `
 0% {
 background: var(--n-color-start);
 }
 40% {
 background: var(--n-color-end);
 }
 80% {
 background: var(--n-color-start);
 }
 100% {
 background: var(--n-color-start);
 }
 `)]);
const skeletonProps = Object.assign(Object.assign({}, useTheme.props), {
  text: Boolean,
  round: Boolean,
  circle: Boolean,
  height: [String, Number],
  width: [String, Number],
  size: String,
  repeat: {
    type: Number,
    default: 1
  },
  animated: {
    type: Boolean,
    default: true
  },
  sharp: {
    type: Boolean,
    default: true
  }
});
const NSkeleton = vue.defineComponent({
  name: "Skeleton",
  inheritAttrs: false,
  props: skeletonProps,
  setup(props) {
    useHoudini();
    const {
      mergedClsPrefixRef
    } = useConfig(props);
    const themeRef = useTheme("Skeleton", "-skeleton", style, skeletonLight, props, mergedClsPrefixRef);
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      style: vue.computed(() => {
        var _a, _b;
        const theme = themeRef.value;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          }
        } = theme;
        const selfThemeVars = theme.self;
        const {
          color,
          colorEnd,
          borderRadius
        } = selfThemeVars;
        let sizeHeight;
        const {
          circle,
          sharp,
          round: round2,
          width,
          height,
          size: size2,
          text,
          animated
        } = props;
        if (size2 !== void 0) {
          sizeHeight = selfThemeVars[createKey("height", size2)];
        }
        const mergedWidth = circle ? (_a = width !== null && width !== void 0 ? width : height) !== null && _a !== void 0 ? _a : sizeHeight : width;
        const mergedHeight = (_b = circle ? width !== null && width !== void 0 ? width : height : height) !== null && _b !== void 0 ? _b : sizeHeight;
        return {
          display: text ? "inline-block" : "",
          verticalAlign: text ? "-0.125em" : "",
          borderRadius: circle ? "50%" : round2 ? "4096px" : sharp ? "" : borderRadius,
          width: typeof mergedWidth === "number" ? pxfy(mergedWidth) : mergedWidth,
          height: typeof mergedHeight === "number" ? pxfy(mergedHeight) : mergedHeight,
          animation: !animated ? "none" : "",
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-color-start": color,
          "--n-color-end": colorEnd
        };
      })
    };
  },
  render() {
    const {
      repeat: repeatProp,
      style: style2,
      mergedClsPrefix,
      $attrs
    } = this;
    const child = vue.h("div", vue.mergeProps({
      class: `${mergedClsPrefix}-skeleton`,
      style: style2
    }, $attrs));
    if (repeatProp > 1) {
      return vue.h(vue.Fragment, null, repeat(repeatProp, null).map((_2) => [child, "\n"]));
    }
    return child;
  }
});
const _hoisted_1$a = { class: "toolbar-icon" };
const _hoisted_2$5 = ["innerHTML"];
const _sfc_main$d = {
  __name: "ToolbarButtonIcon",
  props: {
    name: {
      type: String,
      required: true
    },
    color: {
      type: String,
      default: null
    },
    icon: {
      type: String,
      default: null
    }
  },
  setup(__props) {
    const props = __props;
    const getBarColor = vue.computed(() => {
      if (props.name === "color") return { backgroundColor: props.color || "#111111" };
      if (props.name === "highlight") return { backgroundColor: props.color || "#D6D6D6" };
    });
    const hasColorBar = vue.computed(() => {
      return ["color", "highlight"].includes(props.name);
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$a, [
        vue.createBaseVNode("div", {
          class: vue.normalizeClass(["toolbar-icon__icon", [`toolbar-icon__icon--${props.name}`]]),
          innerHTML: __props.icon
        }, null, 10, _hoisted_2$5),
        hasColorBar.value ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: "color-bar",
          style: vue.normalizeStyle(getBarColor.value)
        }, null, 4)) : vue.createCommentVNode("", true)
      ]);
    };
  }
};
const ToolbarButtonIcon = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["__scopeId", "data-v-8bc7866c"]]);
const _hoisted_1$9 = ["role", "aria-label", "onKeydown"];
const _hoisted_2$4 = ["data-item"];
const _hoisted_3$3 = {
  key: 1,
  class: "button-label"
};
const _hoisted_4$2 = { key: 2 };
const _hoisted_5 = ["onKeydown", "id"];
const _hoisted_6 = ["placeholder", "onKeydown", "id"];
const _hoisted_7 = ["innerHTML"];
const _hoisted_8 = {
  "aria-live": "polite",
  class: "visually-hidden"
};
const _sfc_main$c = {
  __name: "ToolbarButton",
  props: {
    iconColor: {
      type: String,
      default: null
    },
    active: {
      type: Boolean,
      default: false
    },
    isNarrow: {
      type: Boolean,
      default: false
    },
    isWide: {
      type: Boolean,
      default: false
    },
    toolbarItem: {
      type: Object,
      required: true
    },
    defaultLabel: {
      type: String,
      default: null
    },
    isOverflowItem: {
      type: Boolean,
      default: false
    }
  },
  emits: ["buttonClick", "textSubmit"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const props = __props;
    const {
      name,
      active,
      icon,
      label,
      hideLabel,
      iconColor,
      hasCaret,
      disabled,
      inlineTextInputVisible,
      hasInlineTextInput,
      minWidth,
      style: style2,
      attributes
    } = props.toolbarItem;
    const inlineTextInput = vue.ref(label);
    const inlineInput = vue.ref(null);
    const { isHighContrastMode: isHighContrastMode2 } = useHighContrastMode();
    const handleClick2 = () => {
      if (hasInlineTextInput) {
        vue.nextTick(() => {
          inlineInput.value?.focus();
          inlineInput.value?.select();
        });
      }
      emit("buttonClick");
    };
    const handleInputSubmit = () => {
      const value = inlineTextInput.value;
      const cleanValue = value.match(/^\d+(\.5)?$/) ? value : Math.floor(parseFloat(value)).toString();
      emit("textSubmit", cleanValue);
      inlineTextInput.value = cleanValue;
    };
    const getStyle = vue.computed(() => {
      if (style2.value) return style2.value;
      return {
        minWidth: props.minWidth
      };
    });
    const caretIcon = vue.computed(() => {
      return active.value ? toolbarIcons.dropdownCaretUp : toolbarIcons.dropdownCaretDown;
    });
    const labelRu = vue.computed(() => {
      return label.value === "Editing" ? "" : label.value;
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: vue.normalizeClass(["toolbar-item", vue.unref(attributes).className]),
        style: vue.normalizeStyle(getStyle.value),
        role: __props.isOverflowItem ? "menuitem" : "button",
        "aria-label": vue.unref(attributes).ariaLabel,
        onClick: handleClick2,
        onKeydown: vue.withKeys(vue.withModifiers(handleClick2, ["stop"]), ["enter"]),
        tabindex: "0"
      }, [
        vue.createBaseVNode("div", {
          class: vue.normalizeClass(["toolbar-button", {
            active: vue.unref(active),
            disabled: vue.unref(disabled),
            narrow: __props.isNarrow,
            wide: __props.isWide,
            "has-inline-text-input": vue.unref(hasInlineTextInput),
            "high-contrast": vue.unref(isHighContrastMode2)
          }]),
          "data-item": `btn-${vue.unref(name) || ""}`
        }, [
          vue.unref(icon) ? (vue.openBlock(), vue.createBlock(ToolbarButtonIcon, {
            key: 0,
            color: vue.unref(iconColor),
            class: "toolbar-icon",
            icon: vue.unref(icon),
            name: vue.unref(name)
          }, null, 8, ["color", "icon", "name"])) : vue.createCommentVNode("", true),
          vue.unref(label) && !vue.unref(hideLabel) && !vue.unref(inlineTextInputVisible) ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_3$3, vue.toDisplayString(labelRu.value), 1)) : vue.createCommentVNode("", true),
          vue.unref(inlineTextInputVisible) ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_4$2, [
            vue.unref(name) === "fontSize" ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("input", {
              key: 0,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => inlineTextInput.value = $event),
              onKeydown: vue.withKeys(vue.withModifiers(handleInputSubmit, ["prevent"]), ["enter"]),
              type: "text",
              class: vue.normalizeClass(["button-text-input button-text-input--font-size", { "high-contrast": vue.unref(isHighContrastMode2) }]),
              id: "inlineTextInput-" + vue.unref(name),
              autocomplete: "off",
              ref_key: "inlineInput",
              ref: inlineInput
            }, null, 42, _hoisted_5)), [
              [vue.vModelText, inlineTextInput.value]
            ]) : vue.withDirectives((vue.openBlock(), vue.createElementBlock("input", {
              key: 1,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => inlineTextInput.value = $event),
              placeholder: vue.unref(label),
              onKeydown: vue.withKeys(vue.withModifiers(handleInputSubmit, ["prevent"]), ["enter"]),
              type: "text",
              class: "button-text-input",
              id: "inlineTextInput-" + vue.unref(name),
              autocomplete: "off",
              ref_key: "inlineInput",
              ref: inlineInput
            }, null, 40, _hoisted_6)), [
              [vue.vModelText, inlineTextInput.value]
            ])
          ])) : vue.createCommentVNode("", true),
          vue.unref(hasCaret) ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 3,
            class: "dropdown-caret",
            innerHTML: caretIcon.value,
            style: vue.normalizeStyle({ opacity: vue.unref(disabled) ? 0.6 : 1 })
          }, null, 12, _hoisted_7)) : vue.createCommentVNode("", true),
          vue.createBaseVNode("div", _hoisted_8, vue.toDisplayString(`${vue.unref(attributes).ariaLabel} ${vue.unref(active) ? "selected" : "unset"}`), 1)
        ], 10, _hoisted_2$4)
      ], 46, _hoisted_1$9);
    };
  }
};
const ToolbarButton = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__scopeId", "data-v-191789e4"]]);
const _hoisted_1$8 = {
  class: "toolbar-separator",
  role: "separator",
  "aria-label": "Toolbar separator"
};
const _sfc_main$b = {
  __name: "ToolbarSeparator",
  props: {
    active: {
      type: Boolean,
      default: false
    }
  },
  emits: ["command"],
  setup(__props, { emit: __emit }) {
    const { isHighContrastMode: isHighContrastMode2 } = useHighContrastMode();
    const getSeparatorColor = () => {
      if (isHighContrastMode2.value) {
        return "#000";
      }
      return "#dbdbdb";
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$8, [
        vue.createBaseVNode("div", {
          class: "separator-inner",
          style: vue.normalizeStyle({ backgroundColor: getSeparatorColor() })
        }, null, 4)
      ]);
    };
  }
};
const ToolbarSeparator = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__scopeId", "data-v-c7e2cd4d"]]);
const _hoisted_1$7 = { class: "overflow-menu" };
const _hoisted_2$3 = { class: "overflow-menu-trigger" };
const _hoisted_3$2 = {
  key: 0,
  class: "overflow-menu_items",
  role: "group"
};
const _sfc_main$a = {
  __name: "OverflowMenu",
  props: {
    toolbarItem: {
      type: Object,
      required: true
    },
    overflowItems: {
      type: Array,
      required: true
    }
  },
  emits: ["buttonClick", "close"],
  setup(__props, { emit: __emit }) {
    const { proxy } = vue.getCurrentInstance();
    const emit = __emit;
    const props = __props;
    const isOverflowMenuOpened = vue.computed(() => props.toolbarItem.expand.value);
    const hasOpenDropdown = vue.ref(false);
    const overflowToolbarItem = vue.computed(() => ({
      ...props.toolbarItem,
      active: isOverflowMenuOpened.value
    }));
    const toggleOverflowMenu = () => {
      emit("buttonClick", props.toolbarItem);
    };
    const handleCommand = ({ item, argument }) => {
      proxy.$toolbar.emitCommand({ item, argument });
    };
    const handleKeyDown2 = (e) => {
      if (e.key === "Escape") {
        if (isOverflowMenuOpened.value && !hasOpenDropdown.value) {
          e.preventDefault();
          emit("close");
        }
      }
    };
    vue.onMounted(() => {
      document.addEventListener("keydown", handleKeyDown2, true);
    });
    vue.onBeforeUnmount(() => {
      document.removeEventListener("keydown", handleKeyDown2, true);
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$7, [
        vue.createBaseVNode("div", _hoisted_2$3, [
          vue.createVNode(ToolbarButton, {
            "toolbar-item": overflowToolbarItem.value,
            onButtonClick: toggleOverflowMenu
          }, null, 8, ["toolbar-item"])
        ]),
        isOverflowMenuOpened.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_3$2, [
          vue.createVNode(ButtonGroup, {
            class: "superdoc-toolbar-overflow",
            "toolbar-items": __props.overflowItems,
            "from-overflow": "",
            onCommand: handleCommand,
            onDropdownUpdateShow: _cache[0] || (_cache[0] = ($event) => hasOpenDropdown.value = $event)
          }, null, 8, ["toolbar-items"])
        ])) : vue.createCommentVNode("", true)
      ]);
    };
  }
};
const OverflowMenu = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__scopeId", "data-v-23c383c4"]]);
const _hoisted_1$6 = ["onKeydown", "tabindex", "data-item-id"];
const _hoisted_2$2 = { key: 0 };
const _hoisted_3$1 = { key: 0 };
const _hoisted_4$1 = { key: 0 };
const _sfc_main$9 = {
  __name: "ButtonGroup",
  props: {
    toolbarItems: {
      type: Array,
      required: true
    },
    overflowItems: {
      type: Array,
      default: () => []
    },
    /**
     * The font-family to use for UI elements like dropdowns and tooltips.
     * This ensures consistent typography across toolbar UI components.
     * @type {string}
     * @default 'Arial, Helvetica, sans-serif'
     */
    uiFontFamily: {
      type: String,
      default: "Arial, Helvetica, sans-serif"
    },
    position: {
      type: String,
      default: "left"
    },
    fromOverflow: {
      type: Boolean,
      default: false
    }
  },
  emits: ["command", "item-clicked", "dropdown-update-show"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const toolbarItemRefs = vue.ref([]);
    const props = __props;
    const currentItem = vue.ref(null);
    const { isHighContrastMode: isHighContrastMode2 } = useHighContrastMode();
    const isMobile = window.matchMedia("(max-width: 768px)").matches;
    const styleMap = {
      left: {
        minWidth: "120px",
        justifyContent: "flex-start"
      },
      right: {
        minWidth: "120px",
        justifyContent: "flex-end"
      },
      default: {
        // Only grow if not on a mobile device
        flexGrow: isMobile ? 0 : 1,
        justifyContent: "center"
      }
    };
    const getPositionStyle = vue.computed(() => {
      return styleMap[props.position] || styleMap.default;
    });
    const isButton = (item) => item.type === "button";
    const isDropdown = (item) => item.type === "dropdown";
    const isSeparator = (item) => item.type === "separator";
    const isOverflow = (item) => item.type === "overflow";
    const handleToolbarButtonClick = (item, argument = null) => {
      emit("item-clicked");
      currentItem.value = item;
      currentItem.value.expand = !currentItem.value.expand;
      if (item.disabled.value) return;
      emit("command", { item, argument });
    };
    const handleToolbarButtonTextSubmit = (item, argument) => {
      if (item.disabled.value) return;
      currentItem.value = null;
      emit("command", { item, argument });
    };
    const closeDropdowns = () => {
      if (!currentItem.value) return;
      currentItem.value.expand = false;
      currentItem.value = null;
    };
    const handleSelect = (item, option) => {
      closeDropdowns();
      const value = item.dropdownValueKey.value ? option[item.dropdownValueKey.value] : option.label;
      emit("command", { item, argument: value, option });
      item.selectedValue.value = option.key;
    };
    const dropdownOptions = (item) => {
      if (!item.nestedOptions?.value?.length) return [];
      return item.nestedOptions.value.map((option) => {
        return {
          ...option,
          props: {
            ...option.props,
            class: item.selectedValue.value === option.key ? "selected" : ""
          }
        };
      });
    };
    const getDropdownAttributes = (option, item) => {
      return {
        role: "menuitem",
        ariaLabel: `${item.attributes.value.ariaLabel} - ${option.label}`
      };
    };
    const moveToNextButton = (e) => {
      const currentButton = e.target;
      const nextButton = e.target.closest(".toolbar-item-ctn").nextElementSibling;
      if (nextButton) {
        currentButton.setAttribute("tabindex", "-1");
        nextButton.setAttribute("tabindex", "0");
        nextButton.focus();
      }
    };
    const moveToPreviousButton = (e) => {
      const currentButton = e.target;
      const previousButton = e.target.closest(".toolbar-item-ctn").previousElementSibling;
      if (previousButton) {
        currentButton.setAttribute("tabindex", "-1");
        previousButton.setAttribute("tabindex", "0");
        previousButton.focus();
      }
    };
    const moveToNextButtonGroup = (e) => {
      const nextButtonGroup = e.target.closest(".button-group").nextElementSibling;
      if (nextButtonGroup) {
        nextButtonGroup.setAttribute("tabindex", "0");
        nextButtonGroup.focus();
      } else {
        const editor = document.querySelector(".ProseMirror");
        if (editor) {
          editor.focus();
        }
      }
    };
    const moveToPreviousButtonGroup = (e) => {
      const previousButtonGroup = e.target.closest(".button-group").previousElementSibling;
      if (previousButtonGroup) {
        previousButtonGroup.setAttribute("tabindex", "0");
        previousButtonGroup.focus();
      }
    };
    const handleKeyDown2 = (e, item) => {
      const isTypingField = e.target.nodeName === "INPUT" || e.target.nodeName === "TEXTAREA";
      const isTypingToolbarItem = item.name.value === "fontSize";
      if (isTypingField && isTypingToolbarItem) {
        return;
      }
      e.preventDefault();
      switch (e.key) {
        case "Enter":
          handleToolbarButtonClick(item, null);
          break;
        case "Escape":
          closeDropdowns();
          break;
        case "ArrowRight":
          closeDropdowns();
          moveToNextButton(e);
          break;
        case "ArrowLeft":
          closeDropdowns();
          moveToPreviousButton(e);
          break;
        case "Tab":
          if (e.shiftKey) {
            moveToPreviousButtonGroup(e);
          } else {
            moveToNextButtonGroup(e);
          }
          break;
      }
    };
    const handleFocus = (e) => {
      const firstButton = toolbarItemRefs.value.find((item) => !item.classList.contains("disabled"));
      if (firstButton) {
        firstButton.setAttribute("tabindex", "0");
        firstButton.focus();
      }
    };
    const handleDropdownUpdateShow = (open) => {
      if (!open) {
        closeDropdowns();
      }
      emit("dropdown-update-show", open);
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        style: vue.normalizeStyle(getPositionStyle.value),
        class: "button-group",
        role: "group",
        onFocus: handleFocus
      }, [
        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.toolbarItems, (item, index2) => {
          return vue.openBlock(), vue.createElementBlock("div", {
            key: item.id.value,
            class: vue.normalizeClass([{
              narrow: item.isNarrow.value,
              wide: item.isWide.value,
              disabled: item.disabled.value
            }, "toolbar-item-ctn"]),
            onKeydown: (e) => handleKeyDown2(e, item),
            ref_for: true,
            ref_key: "toolbarItemRefs",
            ref: toolbarItemRefs,
            tabindex: index2 === 0 ? 0 : -1,
            "data-item-id": item.id.value
          }, [
            isSeparator(item) ? (vue.openBlock(), vue.createBlock(ToolbarSeparator, {
              key: 0,
              style: { "width": "20px" }
            })) : vue.createCommentVNode("", true),
            isDropdown(item) && item.nestedOptions?.value?.length ? (vue.openBlock(), vue.createBlock(vue.unref(NDropdown), {
              key: 1,
              options: dropdownOptions(item),
              trigger: item.disabled.value ? null : "click",
              show: item.expand.value,
              "content-style": { fontFamily: props.uiFontFamily },
              size: "medium",
              placement: "bottom-start",
              class: vue.normalizeClass(["toolbar-button toolbar-dropdown sd-editor-toolbar-dropdown", { "high-contrast": vue.unref(isHighContrastMode2) }]),
              onSelect: (key2, option) => handleSelect(item, option),
              onUpdateShow: handleDropdownUpdateShow,
              style: vue.normalizeStyle(item.dropdownStyles.value),
              "menu-props": () => ({
                role: "menu",
                style: { fontFamily: props.uiFontFamily }
              }),
              "node-props": (option) => getDropdownAttributes(option, item)
            }, {
              default: vue.withCtx(() => [
                vue.createVNode(vue.unref(NTooltip), {
                  trigger: "hover",
                  disabled: !item.tooltip?.value,
                  "content-style": { fontFamily: props.uiFontFamily }
                }, {
                  trigger: vue.withCtx(() => [
                    vue.createVNode(ToolbarButton, {
                      "toolbar-item": item,
                      disabled: item.disabled.value,
                      onTextSubmit: ($event) => handleToolbarButtonTextSubmit(item, $event),
                      onButtonClick: ($event) => handleToolbarButtonClick(item)
                    }, null, 8, ["toolbar-item", "disabled", "onTextSubmit", "onButtonClick"])
                  ]),
                  default: vue.withCtx(() => [
                    vue.createBaseVNode("div", null, [
                      vue.createTextVNode(vue.toDisplayString(item.tooltip) + " ", 1),
                      item.disabled.value ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_2$2, "(disabled)")) : vue.createCommentVNode("", true)
                    ])
                  ]),
                  _: 2
                }, 1032, ["disabled", "content-style"])
              ]),
              _: 2
            }, 1032, ["options", "trigger", "show", "content-style", "class", "onSelect", "style", "menu-props", "node-props"])) : isButton(item) ? (vue.openBlock(), vue.createBlock(vue.unref(NTooltip), {
              key: 2,
              trigger: "hover",
              class: "sd-editor-toolbar-tooltip",
              "content-style": { fontFamily: props.uiFontFamily }
            }, {
              trigger: vue.withCtx(() => [
                vue.createVNode(ToolbarButton, {
                  "toolbar-item": item,
                  "is-overflow-item": __props.fromOverflow,
                  onTextSubmit: ($event) => handleToolbarButtonTextSubmit(item, $event),
                  onButtonClick: ($event) => handleToolbarButtonClick(item)
                }, null, 8, ["toolbar-item", "is-overflow-item", "onTextSubmit", "onButtonClick"])
              ]),
              default: vue.withCtx(() => [
                item.tooltip ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_3$1, [
                  vue.createTextVNode(vue.toDisplayString(item.tooltip) + " ", 1),
                  item.disabled.value ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_4$1, "(disabled)")) : vue.createCommentVNode("", true)
                ])) : vue.createCommentVNode("", true)
              ]),
              _: 2
            }, 1032, ["content-style"])) : vue.createCommentVNode("", true),
            isOverflow(item) && __props.overflowItems.length ? (vue.openBlock(), vue.createBlock(OverflowMenu, {
              key: 3,
              "toolbar-item": item,
              onButtonClick: ($event) => handleToolbarButtonClick(item),
              "overflow-items": __props.overflowItems,
              onClose: closeDropdowns
            }, null, 8, ["toolbar-item", "onButtonClick", "overflow-items"])) : vue.createCommentVNode("", true)
          ], 42, _hoisted_1$6);
        }), 128))
      ], 36);
    };
  }
};
const ButtonGroup = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__scopeId", "data-v-3d5db06f"]]);
const DEFAULT_UI_FONT_FAMILY = "Arial, Helvetica, sans-serif";
const _sfc_main$8 = {
  __name: "Toolbar",
  emits: ["command", "toggle", "select"],
  setup(__props, { emit: __emit }) {
    const { proxy } = vue.getCurrentInstance();
    let toolbarKey = vue.ref(1);
    const uiFontFamily = vue.computed(() => {
      const configured = proxy?.$toolbar?.config?.uiDisplayFallbackFont;
      if (typeof configured === "string" && configured.trim()) {
        return configured.trim();
      }
      return DEFAULT_UI_FONT_FAMILY;
    });
    const showLeftSide = proxy.$toolbar.config?.toolbarGroups?.includes("left");
    const showRightSide = proxy.$toolbar.config?.toolbarGroups?.includes("right");
    const excludeButtonsList = proxy.$toolbar.config?.toolbarButtonsExclude || [];
    const getFilteredItems = (position) => {
      return proxy.$toolbar.getToolbarItemByGroup(position).filter((item) => !excludeButtonsList.includes(item.name.value));
    };
    vue.onMounted(() => {
      window.addEventListener("resize", onResizeThrottled);
      window.addEventListener("keydown", onKeyDown);
    });
    vue.onDeactivated(() => {
      window.removeEventListener("resize", onResizeThrottled);
      window.removeEventListener("keydown", onKeyDown);
    });
    const onKeyDown = async (e) => {
      if (e.metaKey && e.key === "f") {
        const searchItem = proxy.$toolbar.getToolbarItemByName("search");
        if (searchItem) {
          e.preventDefault();
          searchItem.expand.value = true;
          await vue.nextTick();
          if (searchItem.inputRef.value) {
            searchItem.inputRef.value.focus();
          }
        }
      }
    };
    const onWindowResized = async () => {
      await proxy.$toolbar.onToolbarResize();
      toolbarKey.value += 1;
    };
    const onResizeThrottled = throttle(onWindowResized, 300);
    const handleCommand = ({ item, argument, option }) => {
      proxy.$toolbar.emitCommand({ item, argument, option });
    };
    const restoreSelection2 = () => {
      proxy.$toolbar.activeEditor?.commands?.restoreSelection();
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: "superdoc-toolbar",
        key: vue.unref(toolbarKey),
        role: "toolbar",
        "aria-label": "Toolbar",
        "data-editor-ui-surface": ""
      }, [
        vue.createVNode(vue.unref(NConfigProvider), {
          abstract: "",
          "preflight-style-disabled": ""
        }, {
          default: vue.withCtx(() => [
            vue.unref(showLeftSide) ? (vue.openBlock(), vue.createBlock(ButtonGroup, {
              key: 0,
              tabindex: "0",
              "toolbar-items": getFilteredItems("left"),
              "ui-font-family": uiFontFamily.value,
              position: "left",
              onCommand: handleCommand,
              onItemClicked: restoreSelection2,
              class: "superdoc-toolbar-group-side"
            }, null, 8, ["toolbar-items", "ui-font-family"])) : vue.createCommentVNode("", true),
            vue.createVNode(ButtonGroup, {
              tabindex: "0",
              "toolbar-items": getFilteredItems("center"),
              "overflow-items": vue.unref(proxy).$toolbar.overflowItems,
              "ui-font-family": uiFontFamily.value,
              position: "center",
              onCommand: handleCommand,
              onItemClicked: restoreSelection2
            }, null, 8, ["toolbar-items", "overflow-items", "ui-font-family"]),
            vue.unref(showRightSide) ? (vue.openBlock(), vue.createBlock(ButtonGroup, {
              key: 1,
              tabindex: "0",
              "toolbar-items": getFilteredItems("right"),
              "ui-font-family": uiFontFamily.value,
              position: "right",
              onCommand: handleCommand,
              onItemClicked: restoreSelection2,
              class: "superdoc-toolbar-group-side"
            }, null, 8, ["toolbar-items", "ui-font-family"])) : vue.createCommentVNode("", true)
          ]),
          _: 1
        })
      ]);
    };
  }
};
const Toolbar = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__scopeId", "data-v-042a9556"]]);
const toolbarTexts = {
  bold: "Bold",
  fontFamily: "Font",
  ai: "AI text generation",
  fontSize: "Font size",
  italic: "Italic",
  underline: "Underline",
  highlight: "Highlight color",
  strikethrough: "Strikethrough",
  color: "Text color",
  search: "Search",
  link: "Link",
  image: "Image",
  table: "Insert table",
  tableActions: "Table options",
  addRowBefore: "Insert row above",
  addRowAfter: "Insert row below",
  addColumnBefore: "Insert column left",
  addColumnAfter: "Insert column right",
  deleteRow: "Delete row",
  deleteColumn: "Delete column",
  deleteTable: "Delete table",
  removeBorders: "Remove borders",
  mergeCells: "Merge cells",
  splitCell: "Split cell",
  fixTables: "Fix tables",
  textAlign: "Alignment",
  bulletList: "Bullet list",
  numberedList: "Numbered list",
  indentLeft: "Left indent",
  indentRight: "Right indent",
  zoom: "Zoom",
  undo: "Undo",
  redo: "Redo",
  trackChanges: "Track Changes",
  trackChangesAccept: "Accept changes under selection",
  trackChangesReject: "Reject changes under selection",
  trackChangesOriginal: "Toggle Show Original",
  trackChangesFinal: "Toggle Show Final",
  clearFormatting: "Clear formatting",
  copyFormat: "Format painter",
  lineHeight: "Line height",
  formatText: "Format text",
  ruler: "Show or hide ruler",
  pageBreak: "Insert page break",
  documentEditingMode: "Editing",
  documentSuggestingMode: "Suggesting",
  documentViewingMode: "Viewing",
  documentEditingModeDescription: "Edit document directly",
  documentSuggestingModeDescription: "Edits become suggestions",
  documentViewingModeDescription: "View clean version of document only",
  linkedStyles: "Linked styles"
};
const toolbarTextsRu = {
  bold: "",
  fontFamily: "",
  ai: "AI  ",
  fontSize: " ",
  italic: "",
  underline: "",
  highlight: " ",
  strikethrough: "",
  color: " ",
  search: "",
  link: "",
  image: "",
  table: " ",
  tableActions: " ",
  addRowBefore: "  ",
  addRowAfter: "  ",
  addColumnBefore: "  ",
  addColumnAfter: "  ",
  deleteRow: " ",
  deleteColumn: " ",
  deleteTable: " ",
  removeBorders: " ",
  mergeCells: " ",
  splitCell: " ",
  fixTables: " ",
  textAlign: "",
  bulletList: " ",
  numberedList: " ",
  indentLeft: " ",
  indentRight: " ",
  zoom: "",
  undo: "",
  redo: "",
  trackChanges: " ",
  trackChangesAccept: "   ",
  trackChangesReject: "   ",
  trackChangesOriginal: " ",
  trackChangesFinal: " ",
  clearFormatting: " ",
  copyFormat: " ",
  lineHeight: " ",
  formatText: " ",
  ruler: "   ",
  pageBreak: "  ",
  documentEditingMode: "",
  documentSuggestingMode: "",
  documentViewingMode: "",
  documentEditingModeDescription: "  ",
  documentSuggestingModeDescription: "  ",
  documentViewingModeDescription: "   ",
  linkedStyles: " "
};
const isOffValue = (value) => {
  if (value == null) return false;
  const normalized = String(value).toLowerCase();
  return normalized === "0" || normalized === "false" || normalized === "off";
};
const negationChecks = {
  bold: (attrs = {}) => isOffValue(attrs.value),
  italic: (attrs = {}) => isOffValue(attrs.value),
  strike: (attrs = {}) => isOffValue(attrs.value),
  underline: (attrs = {}) => {
    const type = attrs.underlineType ?? attrs.value;
    if (type == null) return false;
    const normalized = String(type).toLowerCase();
    return normalized === "none" || isOffValue(normalized);
  },
  color: (attrs = {}) => {
    const value = attrs.color;
    if (value == null) return true;
    return String(value).toLowerCase() === "inherit";
  },
  highlight: (attrs = {}) => {
    const value = attrs.color;
    if (value == null) return true;
    const normalized = String(value).toLowerCase();
    return normalized === "transparent" || normalized === "none";
  }
};
const isNegatedMark = (name, attrs = {}) => {
  const checker = negationChecks[name];
  if (typeof checker !== "function") return false;
  return Boolean(checker(attrs));
};
class SuperToolbar extends eventemitter3.EventEmitter {
  /**
   * Mark toggle names used to identify mark commands that need special handling
   * when the editor is not focused.
   * @type {Set<string>}
   * @private
   */
  static #MARK_TOGGLE_NAMES = /* @__PURE__ */ new Set([
    "bold",
    "italic",
    "underline",
    "strike",
    "highlight",
    "color",
    "fontSize",
    "fontFamily"
  ]);
  /**
   * Default configuration for the toolbar
   * @type {ToolbarConfig}
   */
  config = {
    selector: null,
    toolbarGroups: ["left", "center", "right"],
    role: "editor",
    icons: { ...toolbarIcons },
    locale: "ru",
    texts: { ...toolbarTextsRu },
    fonts: null,
    hideButtons: true,
    responsiveToContainer: false,
    mode: "docx",
    excludeItems: [],
    groups: null,
    editor: null,
    aiApiKey: null,
    aiEndpoint: null,
    customButtons: []
  };
  /**
   * Creates a new SuperToolbar instance
   * @param {ToolbarConfig} config - The configuration for the toolbar
   * @returns {void}
   */
  constructor(config) {
    super();
    this.config = { ...this.config, ...config };
    this.toolbarItems = [];
    this.overflowItems = [];
    this.documentMode = config.documentMode || "editing";
    this.isDev = config.isDev || false;
    this.superdoc = config.superdoc;
    this.role = config.role || "editor";
    this.toolbarContainer = null;
    if (this.config.editor) {
      this.config.mode = this.config.editor.options.mode;
    }
    this.config.icons = {
      ...toolbarIcons,
      ...config.icons
    };
    const defaultTexts = this.config.locale === "ru" ? toolbarTextsRu : toolbarTexts;
    this.config.texts = {
      ...defaultTexts,
      ...config.texts
    };
    this.config.hideButtons = config.hideButtons ?? true;
    this.config.responsiveToContainer = config.responsiveToContainer ?? false;
    this.pendingMarkCommands = [];
    this.stickyStoredMarks = null;
    this._boundEditorHandlers = {
      transaction: null,
      selectionUpdate: null,
      focus: null
    };
    this._restoreFocusTimeoutId = null;
    if (!this.config.selector && this.config.element) {
      this.config.selector = this.config.element;
    }
    this.toolbarContainer = this.findElementBySelector(this.config.selector);
    if (this.toolbarContainer) {
      const uiFontFamily = (this.config?.uiDisplayFallbackFont || "").toString().trim() || "Arial, Helvetica, sans-serif";
      this.toolbarContainer.style.setProperty("--sd-ui-font-family", uiFontFamily);
    }
    this.#initToolbarGroups();
    this.#makeToolbarItems({
      superToolbar: this,
      icons: this.config.icons,
      texts: this.config.texts,
      fonts: this.config.fonts,
      hideButtons: this.config.hideButtons,
      isDev: config.isDev
    });
    if (this.config.selector && !this.toolbarContainer) {
      return;
    }
    this.app = vue.createApp(Toolbar);
    this.app.directive("click-outside", vClickOutside);
    this.app.config.globalProperties.$toolbar = this;
    if (this.toolbarContainer) {
      this.toolbar = this.app.mount(this.toolbarContainer);
    }
    this.activeEditor = config.editor || null;
    this.updateToolbarState();
  }
  findElementBySelector(selector) {
    let el = null;
    if (selector) {
      if (selector.startsWith("#") || selector.startsWith(".")) {
        el = document.querySelector(selector);
      } else {
        el = document.getElementById(selector);
      }
      if (!el) {
        return null;
      }
    }
    return el;
  }
  /**
   * Initiate toolbar groups
   * @private
   * @returns {void}
   */
  #initToolbarGroups() {
    if (this.config.groups && !Array.isArray(this.config.groups) && Object.keys(this.config.groups).length) {
      this.config.toolbarGroups = Object.keys(this.config.groups);
    }
  }
  /**
   * Custom commands that override default behavior
   * @private
   * @type {Object.<string, function(CommandItem): void>}
   */
  #interceptedCommands = {
    /**
     * Handles zoom level changes
     * @param {Object} params - Command parameters
     * @param {CommandItem} params.item - The command item
     * @param {string|number} params.argument - The zoom level (percentage)
     * @returns {void}
     */
    setZoom: ({ item, argument }) => {
      if (!argument) return;
      item.onActivate({ zoom: argument });
      this.emit("superdoc-command", { item, argument });
      this.superdoc.superdocStore.activeZoom = parseInt(argument, 10);
    },
    /**
     * Sets the document mode
     * @param {Object} params - Command parameters
     * @param {CommandItem} params.item - The command item
     * @param {string} params.argument - The document mode to set
     * @returns {void}
     */
    setDocumentMode: ({ item, argument }) => {
      if (!argument) return;
      this.emit("superdoc-command", { item, argument });
    },
    /**
     * Sets the font size for text
     * @param {Object} params - Command parameters
     * @param {CommandItem} params.item - The command item
     * @param {string|number} params.argument - The font size to set
     * @returns {void}
     */
    setFontSize: ({ item, argument }) => {
      if (this.#isFieldAnnotationSelection() && argument) {
        this.activeEditor?.commands.setFieldAnnotationsFontSize(argument, true);
        this.updateToolbarState();
        return;
      }
      this.#runCommandWithArgumentOnly({ item, argument }, () => {
        this.activeEditor?.commands.setFieldAnnotationsFontSize(argument, true);
      });
    },
    /**
     * Sets the font family for text
     * @param {Object} params - Command parameters
     * @param {CommandItem} params.item - The command item
     * @param {string} params.argument - The font family to set
     * @returns {void}
     */
    setFontFamily: ({ item, argument }) => {
      if (this.#isFieldAnnotationSelection() && argument) {
        this.activeEditor?.commands.setFieldAnnotationsFontFamily(argument, true);
        this.updateToolbarState();
        return;
      }
      this.#runCommandWithArgumentOnly({ item, argument }, () => {
        this.activeEditor?.commands.setFieldAnnotationsFontFamily(argument, true);
      });
    },
    /**
     * Sets the text color
     * @param {Object} params - Command parameters
     * @param {CommandItem} params.item - The command item
     * @param {string} params.argument - The color to set
     * @returns {void}
     */
    setColor: ({ argument }) => {
      if (!argument || !this.activeEditor) return;
      const isNone = argument === "none";
      const value = isNone ? "inherit" : argument;
      if (this.activeEditor?.commands?.setColor) this.activeEditor.commands.setColor(value);
      const argValue = isNone ? null : argument;
      this.activeEditor?.commands.setFieldAnnotationsTextColor(argValue, true);
      this.updateToolbarState();
    },
    /**
     * Sets the highlight color for text
     * @param {Object} params - Command parameters
     * @param {CommandItem} params.item - The command item
     * @param {string} params.argument - The highlight color to set
     * @returns {void}
     */
    setHighlight: ({ argument }) => {
      if (!argument || !this.activeEditor) return;
      const inlineColor = argument !== "none" ? argument : "transparent";
      if (this.activeEditor?.commands?.setHighlight) this.activeEditor.commands.setHighlight(inlineColor);
      const argValue = argument !== "none" ? argument : null;
      this.activeEditor?.commands.setFieldAnnotationsTextHighlight(argValue, true);
      this.activeEditor?.commands.setCellBackground(argValue);
      this.updateToolbarState();
    },
    /**
     * Toggles the ruler visibility
     * @returns {void}
     */
    toggleRuler: () => {
      this.superdoc.toggleRuler();
      this.updateToolbarState();
    },
    /**
     * Initiates the image upload process
     * @async
     * @returns {Promise<void>}
     */
    startImageUpload: async () => {
      try {
        let open = getFileOpener();
        let result = await open();
        if (!result?.file) {
          return;
        }
        const { size: size2, file } = await checkAndProcessImage({
          file: result.file,
          getMaxContentSize: () => this.activeEditor.getMaxContentSize()
        });
        if (!file) {
          return;
        }
        const id = {};
        replaceSelectionWithImagePlaceholder({
          view: this.activeEditor.view,
          editorOptions: this.activeEditor.options,
          id
        });
        await uploadAndInsertImage({
          editor: this.activeEditor,
          view: this.activeEditor.view,
          file,
          size: size2,
          id
        });
      } catch (error) {
        const err = new Error("[super-toolbar ] Image upload failed");
        this.emit("exception", { error: err, editor: this.activeEditor, originalError: error });
        console.error(err, error);
      }
    },
    /**
     * Increases text indentation or list level
     * @param {Object} params - Command parameters
     * @param {CommandItem} params.item - The command item
     * @param {*} params.argument - Command arguments
     * @returns {void}
     */
    increaseTextIndent: ({ item, argument }) => {
      let command2 = item.command;
      if (this.activeEditor.commands.increaseListIndent?.()) {
        return true;
      }
      if (command2 in this.activeEditor.commands) {
        this.activeEditor.commands[command2](argument);
      }
    },
    /**
     * Decreases text indentation or list level
     * @param {Object} params - Command parameters
     * @param {CommandItem} params.item - The command item
     * @param {*} params.argument - Command arguments
     * @returns {boolean}
     */
    decreaseTextIndent: ({ item, argument }) => {
      let command2 = item.command;
      if (this.activeEditor.commands.decreaseListIndent?.()) {
        return true;
      }
      if (command2 in this.activeEditor.commands) {
        this.activeEditor.commands[command2](argument);
      }
    },
    /**
     * Toggles bold formatting for text
     * @param {Object} params - Command parameters
     * @param {CommandItem} params.item - The command item
     * @param {*} params.argument - Command arguments
     * @returns {void}
     */
    toggleBold: ({ item, argument }) => {
      if (this.#isFieldAnnotationSelection()) {
        this.activeEditor?.commands.toggleFieldAnnotationsFormat("bold", true);
        this.updateToolbarState();
        return;
      }
      let command2 = item.command;
      if (command2 in this.activeEditor.commands) {
        this.activeEditor.commands[command2](argument);
        this.activeEditor.commands.toggleFieldAnnotationsFormat("bold", true);
      }
      this.updateToolbarState();
    },
    /**
     * Toggles italic formatting for text
     * @param {Object} params - Command parameters
     * @param {CommandItem} params.item - The command item
     * @param {*} params.argument - Command arguments
     * @returns {void}
     */
    toggleItalic: ({ item, argument }) => {
      if (this.#isFieldAnnotationSelection()) {
        this.activeEditor?.commands.toggleFieldAnnotationsFormat("italic", true);
        this.updateToolbarState();
        return;
      }
      let command2 = item.command;
      if (command2 in this.activeEditor.commands) {
        this.activeEditor.commands[command2](argument);
        this.activeEditor.commands.toggleFieldAnnotationsFormat("italic", true);
      }
      this.updateToolbarState();
    },
    /**
     * Toggles underline formatting for text
     * @param {Object} params - Command parameters
     * @param {CommandItem} params.item - The command item
     * @param {*} params.argument - Command arguments
     * @returns {void}
     */
    toggleUnderline: ({ item, argument }) => {
      if (this.#isFieldAnnotationSelection()) {
        this.activeEditor?.commands.toggleFieldAnnotationsFormat("underline", true);
        this.updateToolbarState();
        return;
      }
      let command2 = item.command;
      if (command2 in this.activeEditor.commands) {
        this.activeEditor.commands[command2](argument);
        this.activeEditor.commands.toggleFieldAnnotationsFormat("underline", true);
      }
      this.updateToolbarState();
    },
    /**
     * Toggles link formatting and updates cursor position
     * @param {Object} params - Command parameters
     * @param {CommandItem} params.item - The command item
     * @param {*} params.argument - Command arguments
     * @returns {void}
     */
    toggleLink: ({ item, argument }) => {
      let command2 = item.command;
      if (command2 in this.activeEditor.commands) {
        this.activeEditor.commands[command2](argument);
        const { view } = this.activeEditor;
        let { selection } = view.state;
        if (this.activeEditor.options.isHeaderOrFooter) {
          selection = this.activeEditor.options.lastSelection;
        }
        const endPos = selection.$to.pos;
        const newSelection = new TextSelection(view.state.doc.resolve(endPos));
        const tr = view.state.tr.setSelection(newSelection);
        const state = view.state.apply(tr);
        view.updateState(state);
        if (!this.activeEditor.options.isHeaderOrFooter) {
          setTimeout(() => {
            view.focus();
          }, 100);
        }
      }
      this.updateToolbarState();
    },
    /**
     * Inserts a table into the document
     * @param {Object} params - Command parameters
     * @param {CommandItem} params.item - The command item
     * @param {Object} params.argument - Table configuration
     * @returns {void}
     */
    insertTable: ({ item, argument }) => {
      this.#runCommandWithArgumentOnly({ item, argument });
    },
    /**
     * Executes a table-related command
     * @param {Object} params - Command parameters
     * @param {Object} params.argument - The table command and its parameters
     * @param {string} params.argument.command - The specific table command to execute
     * @returns {void}
     */
    executeTableCommand: ({ argument }) => {
      if (!argument) return;
      let command2 = argument.command;
      if (command2 in this.activeEditor.commands) {
        this.activeEditor.commands[command2](argument);
      }
      this.updateToolbarState();
    }
  };
  /**
   * Log debug information to the console
   * @param {...*} args - Arguments to log
   * @returns {void}
   */
  log(...args) {
    console.debug("[ super-toolbar]", ...args);
  }
  /**
   * Set the zoom level
   * @param {number} percent_int - The zoom percentage as an integer
   * @returns {void}
   */
  setZoom(percent_int) {
    const allItems = [...this.toolbarItems, ...this.overflowItems];
    const item = allItems.find((item2) => item2.name.value === "zoom");
    this.#interceptedCommands.setZoom({ item, argument: percent_int });
  }
  /**
   * The toolbar expects an active Super Editor instance.
   * Removes listeners from the previous editor (if any) before attaching to the new one.
   * @param {Object|null} editor - The editor instance to attach to the toolbar, or null to detach
   * @returns {void}
   */
  setActiveEditor(editor) {
    if (this.activeEditor && this._boundEditorHandlers.transaction) {
      this.activeEditor.off("transaction", this._boundEditorHandlers.transaction);
      this.activeEditor.off("selectionUpdate", this._boundEditorHandlers.selectionUpdate);
      this.activeEditor.off("focus", this._boundEditorHandlers.focus);
      this._boundEditorHandlers.transaction = null;
      this._boundEditorHandlers.selectionUpdate = null;
      this._boundEditorHandlers.focus = null;
    }
    this.activeEditor = editor;
    if (editor) {
      this._boundEditorHandlers.transaction = this.onEditorTransaction.bind(this);
      this._boundEditorHandlers.selectionUpdate = this.onEditorSelectionUpdate.bind(this);
      this._boundEditorHandlers.focus = this.onEditorFocus.bind(this);
      this.activeEditor.on("transaction", this._boundEditorHandlers.transaction);
      this.activeEditor.on("selectionUpdate", this._boundEditorHandlers.selectionUpdate);
      this.activeEditor.on("focus", this._boundEditorHandlers.focus);
    }
  }
  /**
   * Get toolbar items by group name
   * @param {string} groupName - The name of the group
   * @returns {ToolbarItem[]} An array of toolbar items in the specified group
   */
  getToolbarItemByGroup(groupName) {
    return this.toolbarItems.filter((item) => (item.group?.value || "center") === groupName);
  }
  /**
   * Get a toolbar item by name
   * @param {string} name - The name of the toolbar item
   * @returns {ToolbarItem|undefined} The toolbar item with the specified name or undefined if not found
   */
  getToolbarItemByName(name) {
    return this.toolbarItems.find((item) => item.name.value === name);
  }
  /**
   * Create toolbar items based on configuration
   * @private
   * @param {SuperToolbar} options.superToolbar - The toolbar instance
   * @param {Object} options.icons - Icons to use for toolbar items
   * @param {Object} options.texts - Texts to use for toolbar items
   * @param {Array} options.fonts - Fonts for the toolbar item
   * @param {boolean} options.isDev - Whether in development mode
   * @returns {void}
   */
  #makeToolbarItems({ superToolbar, icons: icons2, texts, fonts, hideButtons, isDev = false } = {}) {
    const documentWidth = document.documentElement.clientWidth;
    const containerWidth = this.toolbarContainer?.offsetWidth ?? 0;
    const availableWidth = this.config.responsiveToContainer ? containerWidth : documentWidth;
    const { defaultItems, overflowItems } = makeDefaultItems({
      superToolbar,
      toolbarIcons: icons2,
      toolbarTexts: texts,
      toolbarFonts: fonts,
      hideButtons,
      availableWidth,
      role: this.role,
      isDev
    });
    const customItems = this.config.customButtons || [];
    if (customItems.length) {
      defaultItems.push(...customItems.map((item) => useToolbarItem({ ...item })));
    }
    let allConfigItems = [
      ...defaultItems.map((item) => item.name.value),
      ...overflowItems.map((item) => item.name.value)
    ];
    if (this.config.groups) allConfigItems = Object.values(this.config.groups).flatMap((item) => item);
    const filteredItems = defaultItems.filter((item) => allConfigItems.includes(item.name.value)).filter((item) => !this.config.excludeItems.includes(item.name.value));
    this.toolbarItems = filteredItems;
    this.overflowItems = overflowItems.filter((item) => allConfigItems.includes(item.name.value));
  }
  /**
   * Initialize default fonts from the editor
   * @private
   * @returns {void}
   */
  #initDefaultFonts() {
    if (!this.activeEditor || !this.activeEditor.converter) return;
    const { typeface = "Arial", fontSizePt = 12 } = this.activeEditor.converter.getDocumentDefaultStyles() ?? {};
    const fontSizeItem = this.toolbarItems.find((item) => item.name.value === "fontSize");
    if (fontSizeItem) fontSizeItem.defaultLabel.value = fontSizePt;
    const fontFamilyItem = this.toolbarItems.find((item) => item.name.value === "fontFamily");
    if (fontFamilyItem) fontFamilyItem.defaultLabel.value = typeface;
  }
  /**
   * Update highlight color options based on document colors
   * @private
   * @returns {void}
   */
  #updateHighlightColors() {
    if (!this.activeEditor || !this.activeEditor.converter) return;
    if (!this.activeEditor.converter.docHiglightColors.size) return;
    const highlightItem = this.toolbarItems.find((item) => item.name.value === "highlight");
    if (!highlightItem) return;
    const pickerColorOptions = getAvailableColorOptions();
    const perChunk = 7;
    const result = Array.from(this.activeEditor.converter.docHiglightColors).reduce((resultArray, item, index2) => {
      const chunkIndex = Math.floor(index2 / perChunk);
      if (!resultArray[chunkIndex]) {
        resultArray[chunkIndex] = [];
      }
      if (!pickerColorOptions.includes(item)) resultArray[chunkIndex].push(makeColorOption(item));
      return resultArray;
    }, []);
    const option = {
      key: "color",
      type: "render",
      render: () => renderColorOptions(this, highlightItem, result, true)
    };
    highlightItem.nestedOptions.value = [option];
  }
  /**
   * Update the toolbar state based on the current editor state
   * Updates active/inactive state of all toolbar items
   * @returns {void}
   */
  updateToolbarState() {
    this.#updateToolbarHistory();
    this.#initDefaultFonts();
    this.#updateHighlightColors();
    if (!this.activeEditor || this.documentMode === "viewing") {
      this.#deactivateAll();
      return;
    }
    const { state } = this.activeEditor;
    if (!state) {
      this.#deactivateAll();
      return;
    }
    const selection = state.selection;
    const selectionTrackedChanges = this.#enrichTrackedChanges(
      collectTrackedChanges({ state, from: selection.from, to: selection.to })
    );
    const hasTrackedChanges = selectionTrackedChanges.length > 0;
    const hasValidSelection = hasTrackedChanges;
    const canAcceptTrackedChanges = hasValidSelection && isTrackedChangeActionAllowed({
      editor: this.activeEditor,
      action: "accept",
      trackedChanges: selectionTrackedChanges
    });
    const canRejectTrackedChanges = hasValidSelection && isTrackedChangeActionAllowed({
      editor: this.activeEditor,
      action: "reject",
      trackedChanges: selectionTrackedChanges
    });
    const marks = getActiveFormatting(this.activeEditor);
    const inTable = isInTable$1(this.activeEditor.state);
    const paragraphParent = superEditor_converter.findParentNode((n) => n.type.name === "paragraph")(selection);
    const paragraphProps = paragraphParent ? superEditor_converter.calculateResolvedParagraphProperties(
      this.activeEditor,
      paragraphParent.node,
      state.doc.resolve(paragraphParent.pos)
    ) : null;
    this.toolbarItems.forEach((item) => {
      item.resetDisabled();
      if (item.name.value === "undo") {
        item.setDisabled(this.undoDepth === 0);
      }
      if (item.name.value === "redo") {
        item.setDisabled(this.redoDepth === 0);
      }
      if (item.name.value === "acceptTrackedChangeBySelection") {
        item.setDisabled(!canAcceptTrackedChanges);
      }
      if (item.name.value === "rejectTrackedChangeOnSelection") {
        item.setDisabled(!canRejectTrackedChanges);
      }
      if (item.name.value === "linkedStyles") {
        if (this.activeEditor && !getQuickFormatList(this.activeEditor).length) {
          return item.deactivate();
        } else {
          return item.activate({ styleId: paragraphProps?.styleId || null });
        }
      }
      const rawActiveMark = marks.find((mark) => mark.name === item.name.value);
      const markNegated = rawActiveMark ? isNegatedMark(rawActiveMark.name, rawActiveMark.attrs) : false;
      const activeMark = markNegated ? null : rawActiveMark;
      if (activeMark) {
        if (activeMark.name === "fontSize") {
          const fontSizes = marks.filter((i) => i.name === "fontSize").map((i) => i.attrs.fontSize);
          const isMultiple = [...new Set(fontSizes)].length > 1;
          item.activate(activeMark.attrs, isMultiple);
        } else {
          item.activate(activeMark.attrs);
        }
      } else {
        item.deactivate();
      }
      if (!activeMark && !markNegated && paragraphParent && paragraphProps?.styleId) {
        const markToStyleMap = {
          fontSize: "font-size",
          fontFamily: "font-family",
          bold: "bold"
        };
        const linkedStyles = this.activeEditor.converter?.linkedStyles.find(
          (style2) => style2.id === paragraphProps.styleId
        );
        if (linkedStyles && linkedStyles.definition && linkedStyles.definition.styles && markToStyleMap[item.name.value] in linkedStyles.definition.styles) {
          const linkedStylesItem = linkedStyles.definition.styles[markToStyleMap[item.name.value]];
          const value = {
            [item.name.value]: linkedStylesItem
          };
          item.activate(value);
        }
      }
      if (item.name.value === "textAlign" && paragraphProps?.justification) {
        item.activate({ textAlign: paragraphProps.justification });
      }
      if (item.name.value === "lineHeight") {
        if (paragraphProps?.spacing) {
          item.selectedValue.value = helpers$1.twipsToLines(paragraphProps.spacing.line);
        } else {
          item.selectedValue.value = "";
        }
      }
      if (item.name.value === "tableActions") {
        item.disabled.value = !inTable;
      }
      const listParent = superEditor_converter.isList(paragraphParent?.node) ? paragraphParent.node : null;
      if (listParent) {
        const numberingType = listParent.attrs.listRendering.numberingType;
        if (item.name.value === "list" && numberingType === "bullet") {
          item.activate();
        } else if (item.name.value === "numberedlist" && numberingType !== "bullet") {
          item.activate();
        }
      }
      if (item.name.value === "ruler") {
        if (this.superdoc?.config?.rulers) {
          item.activate();
        } else {
          item.deactivate();
        }
      }
    });
  }
  /**
   * Handler for toolbar resize events
   * @returns {void}
   */
  onToolbarResize = () => {
    this.#makeToolbarItems({
      superToolbar: this,
      icons: this.config.icons,
      texts: this.config.texts,
      fonts: this.config.fonts,
      hideButtons: this.config.hideButtons,
      isDev: this.isDev
    });
    if (this.role === "viewer") {
      this.#deactivateAll();
    }
    this.updateToolbarState();
  };
  /**
   * Deactivate all toolbar items
   * @private
   * @returns {void}
   */
  #deactivateAll() {
    this.activeEditor = null;
    this.toolbarItems.forEach((item) => {
      const { allowWithoutEditor } = item;
      if (allowWithoutEditor.value) return;
      item.setDisabled(true);
    });
  }
  /**
   * Update undo/redo history state in the toolbar
   * @private
   * @returns {void}
   */
  #updateToolbarHistory() {
    if (!this.activeEditor?.state) return;
    try {
      if (this.activeEditor.options.ydoc) {
        const undoManager = yUndoPluginKey.getState(this.activeEditor.state)?.undoManager;
        this.undoDepth = undoManager?.undoStack.length || 0;
        this.redoDepth = undoManager?.redoStack.length || 0;
      } else {
        this.undoDepth = undoDepth(this.activeEditor.state);
        this.redoDepth = redoDepth(this.activeEditor.state);
      }
    } catch {
      this.undoDepth = 0;
      this.redoDepth = 0;
    }
  }
  #enrichTrackedChanges(trackedChanges = []) {
    if (!trackedChanges?.length) return trackedChanges;
    const store = this.superdoc?.commentsStore;
    if (!store?.getComment) return trackedChanges;
    return trackedChanges.map((change) => {
      const commentId = change.id;
      if (!commentId) return change;
      const storeComment = store.getComment(commentId);
      if (!storeComment) return change;
      const comment = typeof storeComment.getValues === "function" ? storeComment.getValues() : storeComment;
      return { ...change, comment };
    });
  }
  /**
   * React to editor transactions. Might want to debounce this.
   * @param {Object} params - Transaction parameters
   * @param {Object} params.transaction - The transaction object
   * @returns {void}
   */
  onEditorTransaction({ transaction }) {
    if (!transaction.docChanged && !transaction.selectionSet) return;
    this.updateToolbarState();
  }
  /**
   * Main handler for toolbar commands
   * @param {CommandItem} params - Command parameters
   * @param {ToolbarItem} params.item - An instance of the useToolbarItem composable
   * @param {*} [params.argument] - The argument passed to the command
   * @returns {*} The result of the executed command, undefined if no result is returned
   */
  emitCommand({ item, argument, option }) {
    const hasFocusFn = this.activeEditor?.view?.hasFocus;
    const wasFocused = Boolean(typeof hasFocusFn === "function" && hasFocusFn.call(this.activeEditor.view));
    const { command: command2 } = item;
    const isMarkToggle = this.isMarkToggle(item);
    const shouldRestoreFocus = Boolean(item?.restoreEditorFocus);
    const hasArgument = argument !== null && argument !== void 0;
    const isDropdownOpen = item?.type === "dropdown" && !hasArgument;
    const isFontCommand = item?.command === "setFontFamily" || item?.command === "setFontSize";
    if (isDropdownOpen && isFontCommand) {
      return;
    }
    if (!wasFocused && isMarkToggle) {
      this.pendingMarkCommands.push({ command: command2, argument, item });
      item?.activate?.();
      if (this.activeEditor && !this.activeEditor.options.isHeaderOrFooter) {
        this.activeEditor.focus();
      }
      return;
    }
    if (this.activeEditor && !this.activeEditor.options.isHeaderOrFooter) {
      this.activeEditor.focus();
    }
    if (!command2) {
      return;
    }
    if (command2 in this.#interceptedCommands) {
      const result = this.#interceptedCommands[command2]({ item, argument });
      if (isMarkToggle) this.#syncStickyMarksFromState();
      return result;
    }
    if (this.activeEditor && this.activeEditor.commands && command2 in this.activeEditor.commands) {
      this.activeEditor.commands[command2](argument);
    } else if (typeof command2 === "function") {
      command2({ item, argument, option });
    } else {
      const error = new Error(`[super-toolbar ] Command not found: ${command2}`);
      this.emit("exception", { error, editor: this.activeEditor });
      throw error;
    }
    if (isMarkToggle) this.#syncStickyMarksFromState();
    this.updateToolbarState();
    if (shouldRestoreFocus && this.activeEditor && !this.activeEditor.options.isHeaderOrFooter) {
      this._restoreFocusTimeoutId = setTimeout(() => {
        this._restoreFocusTimeoutId = null;
        if (!this.activeEditor || this.activeEditor.options.isHeaderOrFooter) return;
        this.activeEditor.focus();
      }, 0);
    }
  }
  /**
   * Processes and executes pending mark commands when editor selection updates.
   * This is triggered by the editor's 'selectionUpdate' event after focus is restored.
   * Clears the pending queue after execution.
   * @returns {void}
   */
  onEditorSelectionUpdate() {
    if (!this.activeEditor) return;
    if (this.pendingMarkCommands.length) {
      const pending = this.pendingMarkCommands;
      this.pendingMarkCommands = [];
      pending.forEach(({ command: command2, argument, item }) => {
        if (!command2) return;
        try {
          if (command2 in this.#interceptedCommands) {
            this.#interceptedCommands[command2]({ item, argument });
          } else if (this.activeEditor.commands && command2 in this.activeEditor.commands) {
            this.activeEditor.commands[command2](argument);
          }
          this.#ensureStoredMarksForMarkToggle({ command: command2, argument });
        } catch (error) {
          const err = new Error(`[super-toolbar ] Failed to execute pending command: ${command2}`);
          this.emit("exception", { error: err, editor: this.activeEditor, originalError: error });
          console.error(err, error);
        }
      });
      this.#syncStickyMarksFromState();
      this.updateToolbarState();
      return;
    }
    const restored = this.#restoreStickyMarksIfNeeded();
    if (restored) this.updateToolbarState();
  }
  /**
   * Handles editor focus events by flushing any pending mark commands.
   * This is triggered by the editor's 'focus' event.
   * @returns {void}
   */
  onEditorFocus() {
    if (this.pendingMarkCommands.length) {
      this.onEditorSelectionUpdate();
      return;
    }
    const restored = this.#restoreStickyMarksIfNeeded();
    if (restored) this.updateToolbarState();
  }
  /**
   * Determines if a toolbar item represents a mark toggle command.
   * Mark toggles include text formatting commands like bold, italic, underline, etc.
   * @param {ToolbarItem} item - The toolbar item to check
   * @returns {boolean} True if the item is a mark toggle, false otherwise
   */
  isMarkToggle(item) {
    const name = item?.name?.value;
    return SuperToolbar.#MARK_TOGGLE_NAMES.has(name);
  }
  /**
   * Run a command that requires an argument
   * @private
   * @param {CommandItem} params - Command parameters
   * @param {ToolbarItem} params.item - The toolbar item
   * @param {*} params.argument - The argument for the command
   * @param {boolean} params.noArgumentCallback - Whether to call callback even if argument === 'none'
   * @param {Function} [callback] - Optional callback to run after the command
   * @returns {void}
   */
  #runCommandWithArgumentOnly({ item, argument, noArgumentCallback = false }, callback) {
    if (!argument || !this.activeEditor) return;
    let command2 = item.command;
    const noArgumentCommand = item.noArgumentCommand;
    if (argument === "none" && this.activeEditor && this.activeEditor.commands && noArgumentCommand in this.activeEditor.commands) {
      this.activeEditor.commands[noArgumentCommand]();
      if (typeof callback === "function" && noArgumentCallback) callback(argument);
      this.updateToolbarState();
      return;
    }
    if (this.activeEditor && this.activeEditor.commands && command2 in this.activeEditor.commands) {
      this.activeEditor.commands[command2](argument);
      if (typeof callback === "function") callback(argument);
      this.updateToolbarState();
    }
  }
  /**
   * Capture stored marks when a mark toggle is used on an empty selection
   * so they can be re-applied after focus/selection changes.
   * @private
   * @returns {void}
   */
  #syncStickyMarksFromState() {
    if (!this.activeEditor) return;
    const { selection, storedMarks } = this.activeEditor.state || {};
    if (!selection?.empty) return;
    this.stickyStoredMarks = storedMarks?.length ? [...storedMarks] : null;
  }
  /**
   * Re-apply stored marks captured from toolbar toggles when the current
   * selection is empty and unformatted.
   * @private
   * @returns {boolean} True if marks were restored
   */
  #restoreStickyMarksIfNeeded() {
    if (!this.activeEditor) return false;
    if (!this.stickyStoredMarks?.length) return false;
    const { state, view } = this.activeEditor;
    const { selection, storedMarks } = state || {};
    if (!selection?.empty) return false;
    if (storedMarks?.length) return false;
    if (!view?.dispatch || !state?.tr) return false;
    const hasActiveMarkToggle = getActiveFormatting(this.activeEditor).some(
      (mark) => SuperToolbar.#MARK_TOGGLE_NAMES.has(mark.name)
    );
    if (hasActiveMarkToggle) return false;
    const tr = state.tr.setStoredMarks(this.stickyStoredMarks);
    view.dispatch(tr);
    return true;
  }
  /**
   * Fallback to ensure stored marks exist for mark toggles when executed off-focus.
   * Helps cases where a command doesn't set storedMarks (e.g., font size from toolbar before focus).
   * @private
   * @param {Object} params
   * @param {string} params.command
   * @param {*} params.argument
   * @returns {void}
   */
  #ensureStoredMarksForMarkToggle({ command: command2, argument }) {
    if (!this.activeEditor) return;
    if (!this.activeEditor.state?.selection?.empty) return;
    if (this.activeEditor.state?.storedMarks?.length) return;
    if (command2 !== "setFontSize") return;
    const { state, view } = this.activeEditor;
    const textStyleMark = state.schema?.marks?.textStyle;
    if (!textStyleMark || !view?.dispatch || !state?.tr) return;
    const [value, unit] = parseSizeUnit(argument ?? "");
    if (Number.isNaN(value)) return;
    const clamped = Math.min(96, Math.max(8, Number(value)));
    const resolvedUnit = unit || "pt";
    const mark = textStyleMark.create({ fontSize: `${clamped}${resolvedUnit}` });
    const tr = state.tr.setStoredMarks([mark]);
    view.dispatch(tr);
  }
  #isFieldAnnotationSelection() {
    const selection = this.activeEditor?.state?.selection;
    return selection instanceof superEditor_converter.NodeSelection && selection?.node?.type?.name === "fieldAnnotation";
  }
  /**
   * Cleans up resources when the toolbar is destroyed.
   * Clears any pending timeouts to prevent callbacks firing after unmount.
   * @returns {void}
   */
  destroy() {
    if (this._restoreFocusTimeoutId !== null) {
      clearTimeout(this._restoreFocusTimeoutId);
      this._restoreFocusTimeoutId = null;
    }
  }
}
const onMarginClickCursorChange = (event, editor) => {
  const y2 = event.clientY;
  const x = event.clientX;
  const { view } = editor;
  const editorRect = view.dom.getBoundingClientRect();
  let coords = {
    left: 0,
    top: y2
  };
  let isRightMargin = false;
  if (x > editorRect.right) {
    coords.left = editorRect.left + editorRect.width - 1;
    isRightMargin = true;
  } else if (x < editorRect.left) {
    coords.left = editorRect.left;
  }
  const pos = view.posAtCoords(coords)?.pos;
  if (pos) {
    let cursorPos = pos;
    if (isRightMargin) {
      const $pos = view.state.doc.resolve(pos);
      const charOffset = $pos.textOffset;
      const node = view.state.doc.nodeAt(pos);
      const text = node?.text;
      const charAtPos = text?.charAt(charOffset);
      cursorPos = node?.isText && charAtPos !== " " ? pos - 1 : pos;
    }
    const transaction = view.state.tr.setSelection(superEditor_converter.TextSelection.create(view.state.doc, cursorPos));
    view.dispatch(transaction);
    view.focus();
  }
};
const checkNodeSpecificClicks = (editor, event, popoverControls) => {
  if (!editor) return;
  const state = editor.state;
  if (!state) return;
  const surface = getEditorSurfaceElement(editor);
  if (!surface) return;
  if (selectionHasNodeOrMark(state, "link", { requireEnds: true })) {
    popoverControls.component = LinkInput;
    const surfaceRect = surface.getBoundingClientRect();
    if (!surfaceRect) return;
    popoverControls.position = {
      left: `${event.clientX - surfaceRect.left}px`,
      top: `${event.clientY - surfaceRect.top + 15}px`
    };
    popoverControls.props = {
      showInput: true
    };
    popoverControls.visible = true;
  }
};
function selectionHasNodeOrMark(state, name, options = {}) {
  const { requireEnds = false } = options;
  const $from = state.selection.$from;
  const $to = state.selection.$to;
  if (requireEnds) {
    for (let d = $from.depth; d > 0; d--) {
      if ($from.node(d).type.name === name) {
        return true;
      }
    }
    for (let d = $to.depth; d > 0; d--) {
      if ($to.node(d).type.name === name) {
        return true;
      }
    }
  } else {
    for (let d = $from.depth; d > 0; d--) {
      if ($from.node(d).type.name === name) {
        return true;
      }
    }
  }
  const markType = state.schema.marks[name];
  if (markType) {
    const { from: from3, to, empty: empty2 } = state.selection;
    if (requireEnds) {
      const fromMarks = markType.isInSet($from.marks());
      const toMarks = markType.isInSet($to.marks());
      if (fromMarks || toMarks) {
        return true;
      }
      if (empty2 && markType.isInSet(state.storedMarks || $from.marks())) {
        return true;
      }
    } else {
      if (empty2) {
        if (markType.isInSet(state.storedMarks || $from.marks())) {
          return true;
        }
      } else {
        let hasMark = false;
        state.doc.nodesBetween(from3, to, (node) => {
          if (markType.isInSet(node.marks)) {
            hasMark = true;
            return false;
          }
        });
        if (hasMark) return true;
      }
    }
  }
  return false;
}
function moveCursorToMouseEvent(event, editor) {
  if (!editor) return;
  const state = editor.state;
  if (!state) return;
  const coords = { left: event.clientX, top: event.clientY };
  const result = editor.posAtCoords?.(coords);
  if (typeof result?.pos === "number") {
    const tr = state.tr.setSelection(superEditor_converter.TextSelection.create(state.doc, result.pos));
    if (typeof editor.dispatch === "function") {
      editor.dispatch(tr);
    }
    editor.focus?.();
  }
}
const ICONS = {
  addRowBefore: plusIconSvg,
  addRowAfter: plusIconSvg,
  addColumnBefore: plusIconSvg,
  addColumnAfter: plusIconSvg,
  deleteRow: trashIconSvg,
  deleteColumn: trashIconSvg,
  deleteTable: trashIconSvg,
  deleteBorders: borderNoneIconSvg,
  mergeCells: arrowsToDotIconSvg,
  splitCell: arrowsLeftRightIconSvg,
  fixTables: wrenchIconSvg,
  ai: magicWandIcon,
  link: linkIconSvg,
  table: tableIconSvg,
  cut: scissorsIconSvg,
  copy: copyIconSvg,
  paste: pasteIconSvg,
  addDocumentSection: plusIconSvg,
  removeDocumentSection: trashIconSvg,
  trackChangesAccept: checkIconSvg$1,
  trackChangesReject: xmarkIconSvg
};
const TEXTS = {
  addRowBefore: "  ",
  addRowAfter: "  ",
  addColumnBefore: "  ",
  addColumnAfter: "  ",
  deleteRow: " ",
  deleteColumn: " ",
  deleteTable: " ",
  removeBorders: " ",
  mergeCells: " ",
  splitCell: " ",
  fixTables: " ",
  insertText: " ",
  replaceText: " ",
  insertLink: " ",
  insertTable: " ",
  cut: "",
  copy: "",
  paste: "",
  removeDocumentSection: " ",
  createDocumentSection: " ",
  trackChangesAccept: " ",
  trackChangesReject: " "
};
const tableActionsOptions = [
  {
    label: TEXTS.addRowBefore,
    command: "addRowBefore",
    icon: ICONS.addRowBefore,
    props: {
      "data-item": "btn-tableActions-option",
      ariaLabel: "Add row before"
    }
  },
  {
    label: TEXTS.addRowAfter,
    command: "addRowAfter",
    icon: ICONS.addRowAfter,
    props: {
      "data-item": "btn-tableActions-option",
      ariaLabel: "Add row after"
    }
  },
  {
    label: TEXTS.addColumnBefore,
    command: "addColumnBefore",
    icon: ICONS.addColumnBefore,
    props: {
      "data-item": "btn-tableActions-option",
      ariaLabel: "Add column before"
    }
  },
  {
    label: TEXTS.addColumnAfter,
    command: "addColumnAfter",
    icon: ICONS.addColumnAfter,
    bottomBorder: true,
    props: {
      "data-item": "btn-tableActions-option",
      ariaLabel: "Add column after"
    }
  },
  {
    label: TEXTS.deleteRow,
    command: "deleteRow",
    icon: ICONS.deleteRow,
    props: {
      "data-item": "btn-tableActions-option",
      ariaLabel: "Delete row"
    }
  },
  {
    label: TEXTS.deleteColumn,
    command: "deleteColumn",
    icon: ICONS.deleteColumn,
    props: {
      "data-item": "btn-tableActions-option",
      ariaLabel: "Delete column"
    }
  },
  {
    label: TEXTS.deleteTable,
    command: "deleteTable",
    icon: ICONS.deleteTable,
    props: {
      "data-item": "btn-tableActions-option",
      ariaLabel: "Delete table"
    }
  },
  {
    label: TEXTS.removeBorders,
    command: "deleteCellAndTableBorders",
    icon: ICONS.deleteBorders,
    bottomBorder: true,
    props: {
      "data-item": "btn-tableActions-option",
      ariaLabel: "Delete cell and table borders"
    }
  },
  {
    label: TEXTS.mergeCells,
    command: "mergeCells",
    icon: ICONS.mergeCells,
    props: {
      "data-item": "btn-tableActions-option",
      ariaLabel: "Merge cells"
    }
  },
  {
    label: TEXTS.splitCell,
    command: "splitCell",
    icon: ICONS.splitCell,
    props: {
      "data-item": "btn-tableActions-option",
      ariaLabel: "Split cells"
    }
  },
  {
    label: TEXTS.fixTables,
    command: "fixTables",
    icon: ICONS.fixTables,
    props: {
      "data-item": "btn-tableActions-option",
      ariaLabel: "Fix tables"
    }
  }
];
const TRIGGERS = {
  slash: "slash",
  click: "click"
};
const getPropsByItemId = (itemId, props) => {
  const editor = props.editor;
  const baseProps = {
    editor: vue.markRaw(props.editor)
  };
  switch (itemId) {
    case "insert-text":
      const { state } = editor.view;
      const { from: from3, to, empty: empty2 } = state.selection;
      const selectedText = !empty2 ? state.doc.textBetween(from3, to) : "";
      return {
        ...baseProps,
        selectedText,
        handleClose: props.closePopover || (() => null),
        apiKey: editor.options?.aiApiKey,
        endpoint: editor.options?.aiEndpoint
      };
    case "insert-link":
      return baseProps;
    case "insert-table":
      return {
        ...baseProps,
        onSelect: ({ rows, cols }) => {
          editor.commands.insertTable({ rows, cols });
          props.closePopover();
        }
      };
    case "edit-table":
      return {
        ...baseProps,
        options: tableActionsOptions,
        onSelect: ({ command: command2 }) => {
          if (editor.commands[command2]) {
            editor.commands[command2]();
          }
          props.closePopover();
        }
      };
    case "copy":
    case "paste":
      return {
        ...baseProps
        // These actions don't need additional props
      };
    default:
      return baseProps;
  }
};
async function getEditorContext(editor, event) {
  if (!editor) return null;
  const state = editor.state;
  if (!state) return null;
  const { from: from3, to, empty: empty2 } = state.selection;
  const selectedText = !empty2 ? state.doc.textBetween(from3, to) : "";
  let pos = null;
  let node = null;
  if (event && typeof event.clientX === "number" && typeof event.clientY === "number") {
    const coords = { left: event.clientX, top: event.clientY };
    const hit = editor.posAtCoords?.(coords);
    if (typeof hit?.pos === "number") {
      pos = hit.pos;
      node = state.doc.nodeAt(pos);
    }
  }
  if (pos === null && typeof from3 === "number") {
    pos = from3;
    node = state.doc.nodeAt(pos);
  }
  const clipboardContent = {
    html: null,
    text: null,
    hasContent: true,
    // Assume clipboard might have content - we'll check on paste
    raw: null
  };
  const structureFromResolvedPos = pos !== null ? getStructureFromResolvedPos(state, pos) : null;
  const isInTable2 = structureFromResolvedPos?.isInTable ?? selectionHasNodeOrMark(state, "table", { requireEnds: true });
  const isInList = structureFromResolvedPos?.isInList ?? selectionIncludesListParagraph(state);
  const isInSectionNode = structureFromResolvedPos?.isInSectionNode ?? selectionHasNodeOrMark(state, "documentSection", { requireEnds: true });
  const currentNodeType = node?.type?.name || null;
  const activeMarks = [];
  let trackedChangeId = null;
  if (event && pos !== null) {
    const $pos = state.doc.resolve(pos);
    const processMark = (mark) => {
      if (!activeMarks.includes(mark.type.name)) {
        activeMarks.push(mark.type.name);
      }
      if (!trackedChangeId && (mark.type.name === "trackInsert" || mark.type.name === "trackDelete" || mark.type.name === "trackFormat")) {
        trackedChangeId = mark.attrs.id;
      }
    };
    $pos.marks().forEach(processMark);
    const nodeBefore = $pos.nodeBefore;
    const nodeAfter = $pos.nodeAfter;
    if (nodeBefore?.marks) {
      nodeBefore.marks.forEach(processMark);
    }
    if (nodeAfter?.marks) {
      nodeAfter.marks.forEach(processMark);
    }
    state.storedMarks?.forEach(processMark);
  } else {
    state.storedMarks?.forEach((mark) => activeMarks.push(mark.type.name));
    state.selection.$head.marks().forEach((mark) => activeMarks.push(mark.type.name));
  }
  const isTrackedChange = activeMarks.includes("trackInsert") || activeMarks.includes("trackDelete") || activeMarks.includes("trackFormat");
  const trackedChanges = event && pos !== null ? collectTrackedChangesForContext({ state, pos, trackedChangeId }) : collectTrackedChanges({ state, from: from3, to });
  const cursorCoords = pos !== null ? editor.coordsAtPos?.(pos) : null;
  const cursorPosition = cursorCoords ? {
    x: cursorCoords.left,
    y: cursorCoords.top
  } : event ? { x: event.clientX, y: event.clientY } : null;
  return {
    selectedText,
    hasSelection: !empty2,
    selectionStart: from3,
    selectionEnd: to,
    isInTable: isInTable2,
    isInList,
    isInSectionNode,
    currentNodeType,
    activeMarks,
    isTrackedChange,
    trackedChangeId,
    documentMode: editor.options?.documentMode || "editing",
    canUndo: computeCanUndo(editor, state),
    canRedo: computeCanRedo(editor, state),
    isEditable: editor.isEditable,
    clipboardContent,
    cursorPosition,
    pos,
    node,
    event,
    trigger: event ? "click" : "slash",
    editor,
    trackedChanges
  };
}
function computeCanUndo(editor, state) {
  if (typeof editor?.can === "function") {
    try {
      const can = editor.can();
      if (can && typeof can.undo === "function") {
        return !!can.undo();
      }
    } catch (error) {
      console.warn("[SlashMenu] Unable to determine undo availability via editor.can():", error);
    }
  }
  if (isCollaborationEnabled(editor)) {
    try {
      const undoManager = yUndoPluginKey.getState(state)?.undoManager;
      return !!undoManager && undoManager.undoStack.length > 0;
    } catch (error) {
      console.warn("[SlashMenu] Unable to determine undo availability via y-prosemirror:", error);
    }
  }
  try {
    return undoDepth(state) > 0;
  } catch (error) {
    console.warn("[SlashMenu] Unable to determine undo availability via history plugin:", error);
    return false;
  }
}
function computeCanRedo(editor, state) {
  if (typeof editor?.can === "function") {
    try {
      const can = editor.can();
      if (can && typeof can.redo === "function") {
        return !!can.redo();
      }
    } catch (error) {
      console.warn("[SlashMenu] Unable to determine redo availability via editor.can():", error);
    }
  }
  if (isCollaborationEnabled(editor)) {
    try {
      const undoManager = yUndoPluginKey.getState(state)?.undoManager;
      return !!undoManager && undoManager.redoStack.length > 0;
    } catch (error) {
      console.warn("[SlashMenu] Unable to determine redo availability via y-prosemirror:", error);
    }
  }
  try {
    return redoDepth(state) > 0;
  } catch (error) {
    console.warn("[SlashMenu] Unable to determine redo availability via history plugin:", error);
    return false;
  }
}
function isCollaborationEnabled(editor) {
  return Boolean(editor?.options?.collaborationProvider && editor?.options?.ydoc);
}
function selectionIncludesListParagraph(state) {
  const { $from, $to, from: from3, to } = state.selection;
  const hasListInResolvedPos = ($pos) => {
    for (let depth = $pos.depth; depth > 0; depth--) {
      if (superEditor_converter.isList($pos.node(depth))) {
        return true;
      }
    }
    return false;
  };
  if (hasListInResolvedPos($from) || hasListInResolvedPos($to)) {
    return true;
  }
  let found = false;
  state.doc.nodesBetween(from3, to, (node) => {
    if (superEditor_converter.isList(node)) {
      found = true;
      return false;
    }
    return true;
  });
  return found;
}
function getStructureFromResolvedPos(state, pos) {
  try {
    const $pos = state.doc.resolve(pos);
    let isInList = false;
    let isInTable2 = false;
    let isInSectionNode = false;
    for (let depth = $pos.depth; depth > 0; depth--) {
      const node = $pos.node(depth);
      const name = node.type.name;
      if (!isInList && superEditor_converter.isList(node)) {
        isInList = true;
      }
      if (!isInTable2 && (name === "table" || name === "tableRow" || name === "tableCell" || name === "tableHeader")) {
        isInTable2 = true;
      }
      if (!isInSectionNode && name === "documentSection") {
        isInSectionNode = true;
      }
      if (isInList && isInTable2 && isInSectionNode) {
        break;
      }
    }
    return {
      isInTable: isInTable2,
      isInList,
      isInSectionNode
    };
  } catch (error) {
    console.warn("[SlashMenu] Unable to resolve position for structural context:", error);
    return null;
  }
}
const isModuleEnabled = (editorOptions, moduleName) => {
  switch (moduleName) {
    case "ai":
      return !!editorOptions?.isAiEnabled;
    default:
      return true;
  }
};
const shouldShowItem = (item, context) => {
  if (typeof item.showWhen === "function") {
    try {
      return Boolean(item.showWhen(context));
    } catch (error) {
      console.warn("[SlashMenu] showWhen error for item", item.id, ":", error);
      return false;
    }
  }
  return true;
};
const canPerformTrackedChange = (context, action) => {
  if (!context?.editor) return true;
  return isTrackedChangeActionAllowed({
    editor: context.editor,
    action,
    trackedChanges: context.trackedChanges ?? []
  });
};
function getItems(context, customItems = [], includeDefaultItems = true) {
  const { selectedText, editor } = context;
  if (arguments.length === 1 && editor?.options?.slashMenuConfig) {
    customItems = editor.options.slashMenuConfig.items || editor.options.slashMenuConfig.customItems || [];
    includeDefaultItems = editor.options.slashMenuConfig.includeDefaultItems !== false;
  }
  const enhancedContext = {
    ...context,
    isInTable: context.isInTable ?? false,
    isInSectionNode: context.isInSectionNode ?? false,
    isTrackedChange: context.isTrackedChange ?? false,
    clipboardContent: context.clipboardContent ?? { hasContent: false },
    selectedText: context.selectedText ?? "",
    hasSelection: context.hasSelection ?? Boolean(context.selectedText)
  };
  const defaultSections = [
    {
      id: "ai-content",
      isDefault: true,
      items: [
        {
          id: "insert-text",
          label: selectedText ? TEXTS.replaceText : TEXTS.insertText,
          icon: ICONS.ai,
          component: AIWriter,
          isDefault: true,
          action: (editor2) => {
            if (editor2?.commands && typeof editor2.commands?.insertAiMark === "function") {
              editor2.commands.insertAiMark();
            }
          },
          showWhen: (context2) => {
            const { trigger: trigger2 } = context2;
            const allowedTriggers = [TRIGGERS.slash, TRIGGERS.click];
            return allowedTriggers.includes(trigger2) && isModuleEnabled(context2.editor?.options, "ai");
          }
        }
      ]
    },
    {
      id: "track-changes",
      isDefault: true,
      items: [
        {
          id: "track-changes-accept",
          icon: ICONS.trackChangesAccept,
          label: TEXTS.trackChangesAccept,
          isDefault: true,
          action: (editor2, context2) => {
            if (context2?.trackedChangeId) {
              editor2.commands.acceptTrackedChangeById(context2.trackedChangeId);
            } else {
              editor2.commands.acceptTrackedChangeBySelection();
            }
          },
          showWhen: (context2) => {
            const { trigger: trigger2, isTrackedChange } = context2;
            return trigger2 === TRIGGERS.click && isTrackedChange && canPerformTrackedChange(context2, "accept");
          }
        },
        {
          id: "track-changes-reject",
          label: TEXTS.trackChangesReject,
          icon: ICONS.trackChangesReject,
          isDefault: true,
          action: (editor2, context2) => {
            if (context2?.trackedChangeId) {
              editor2.commands.rejectTrackedChangeById(context2.trackedChangeId);
            } else {
              editor2.commands.rejectTrackedChangeOnSelection();
            }
          },
          showWhen: (context2) => {
            const { trigger: trigger2, isTrackedChange } = context2;
            return trigger2 === TRIGGERS.click && isTrackedChange && canPerformTrackedChange(context2, "reject");
          }
        }
      ]
    },
    {
      id: "document-sections",
      isDefault: true,
      items: [
        {
          id: "insert-document-section",
          label: TEXTS.createDocumentSection,
          icon: ICONS.addDocumentSection,
          isDefault: true,
          action: (editor2) => {
            editor2.commands.createDocumentSection();
          },
          // TODO: Temporarily disabled - restore original: `return trigger === TRIGGERS.click;`
          showWhen: () => {
            return false;
          }
        },
        {
          id: "remove-section",
          label: TEXTS.removeDocumentSection,
          icon: ICONS.removeDocumentSection,
          isDefault: true,
          action: (editor2) => {
            editor2.commands.removeSectionAtSelection();
          },
          showWhen: (context2) => {
            const { trigger: trigger2, isInSectionNode } = context2;
            return trigger2 === TRIGGERS.click && isInSectionNode;
          }
        }
      ]
    },
    {
      id: "general",
      isDefault: true,
      items: [
        {
          id: "insert-link",
          label: TEXTS.insertLink,
          icon: ICONS.link,
          component: LinkInput,
          isDefault: true,
          showWhen: (context2) => {
            const { trigger: trigger2 } = context2;
            return trigger2 === TRIGGERS.click;
          }
        },
        {
          id: "insert-table",
          label: TEXTS.insertTable,
          icon: ICONS.table,
          component: TableGrid,
          isDefault: true,
          showWhen: (context2) => {
            const { trigger: trigger2, isInTable: isInTable2 } = context2;
            const allowedTriggers = [TRIGGERS.slash, TRIGGERS.click];
            return allowedTriggers.includes(trigger2) && !isInTable2;
          }
        },
        // Flatten table actions
        ...tableActionsOptions.map((option) => ({
          id: option.command,
          label: option.label,
          icon: option.icon,
          isDefault: true,
          action: (editor2) => {
            if (editor2.commands[option.command]) {
              editor2.commands[option.command]();
            }
          },
          showWhen: (context2) => {
            const { trigger: trigger2, isInTable: isInTable2 } = context2;
            const allowedTriggers = [TRIGGERS.slash, TRIGGERS.click];
            return allowedTriggers.includes(trigger2) && isInTable2;
          }
        }))
      ]
    },
    {
      id: "clipboard",
      isDefault: true,
      items: [
        {
          id: "cut",
          label: TEXTS.cut,
          icon: ICONS.cut,
          isDefault: true,
          action: (editor2) => {
            editor2.focus?.();
            document.execCommand("cut");
          },
          showWhen: (context2) => {
            const { trigger: trigger2, selectedText: selectedText2 } = context2;
            return trigger2 === TRIGGERS.click && selectedText2;
          }
        },
        {
          id: "copy",
          label: TEXTS.copy,
          icon: ICONS.copy,
          isDefault: true,
          action: (editor2) => {
            editor2.focus?.();
            document.execCommand("copy");
          },
          showWhen: (context2) => {
            const { trigger: trigger2, selectedText: selectedText2 } = context2;
            return trigger2 === TRIGGERS.click && selectedText2;
          }
        },
        {
          id: "paste",
          label: TEXTS.paste,
          icon: ICONS.paste,
          isDefault: true,
          action: (editor2) => {
            const editorDom = editor2.view?.dom;
            if (editorDom) {
              editorDom.focus();
              const success = document.execCommand("paste");
              if (!success) {
                console.warn("[Paste] execCommand paste failed - clipboard may be empty or inaccessible");
              }
            }
          },
          showWhen: (context2) => {
            const { trigger: trigger2 } = context2;
            const allowedTriggers = [TRIGGERS.click, TRIGGERS.slash];
            return allowedTriggers.includes(trigger2);
          }
        }
      ]
    }
  ];
  let allSections = [];
  if (includeDefaultItems) {
    allSections = [...defaultSections];
  }
  if (customItems.length > 0) {
    customItems.forEach((customSection) => {
      const existingSectionIndex = allSections.findIndex((section) => section.id === customSection.id);
      if (existingSectionIndex !== -1) {
        allSections[existingSectionIndex].items = [
          ...allSections[existingSectionIndex].items,
          ...customSection.items.map((item) => ({ ...item, isDefault: false }))
        ];
      } else {
        allSections.push({
          ...customSection,
          isDefault: false,
          items: customSection.items.map((item) => ({ ...item, isDefault: false }))
        });
      }
    });
  }
  if (editor?.options?.slashMenuConfig?.menuProvider) {
    try {
      allSections = editor.options.slashMenuConfig.menuProvider(enhancedContext, allSections) || allSections;
    } catch (error) {
      console.warn("[SlashMenu] menuProvider error:", error);
    }
  }
  const filteredSections = allSections.map((section) => {
    const filteredItems = section.items.filter((item) => shouldShowItem(item, enhancedContext));
    return {
      ...section,
      items: filteredItems
    };
  }).filter((section) => section.items.length > 0);
  return filteredSections;
}
const _hoisted_1$5 = { class: "slash-menu-items" };
const _hoisted_2$1 = {
  key: 0,
  class: "slash-menu-divider",
  tabindex: "0"
};
const _hoisted_3 = ["onClick"];
const _hoisted_4 = ["innerHTML"];
const _sfc_main$7 = {
  __name: "SlashMenu",
  props: {
    editor: {
      type: Object,
      required: true
    },
    openPopover: {
      type: Function,
      required: true
    },
    closePopover: {
      type: Function,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const searchInput = vue.ref(null);
    const searchQuery = vue.ref("");
    const isOpen = vue.ref(false);
    const menuPosition = vue.ref({ left: "0px", top: "0px" });
    const menuRef = vue.ref(null);
    const sections = vue.ref([]);
    const selectedId = vue.ref(null);
    const currentContext = vue.ref(null);
    const handleEditorUpdate = () => {
      if (!props.editor?.isEditable && isOpen.value) {
        closeMenu({ restoreCursor: false });
      }
    };
    const flattenedItems = vue.computed(() => {
      const items = [];
      sections.value.forEach((section) => {
        section.items.forEach((item) => {
          items.push(item);
        });
      });
      return items;
    });
    const filteredItems = vue.computed(() => {
      if (!searchQuery.value) {
        return flattenedItems.value;
      }
      return flattenedItems.value.filter((item) => item.label?.toLowerCase().includes(searchQuery.value.toLowerCase()));
    });
    const filteredSections = vue.computed(() => {
      if (!searchQuery.value) {
        return sections.value;
      }
      return [
        {
          id: "search-results",
          items: filteredItems.value
        }
      ];
    });
    vue.watch(isOpen, (open) => {
      if (open) {
        vue.nextTick(() => {
          if (searchInput.value) {
            searchInput.value.focus({ preventScroll: true });
          }
        });
      }
    });
    vue.watch(flattenedItems, (newItems) => {
      if (newItems.length > 0) {
        selectedId.value = newItems[0].id;
      }
    });
    const customItemRefs = /* @__PURE__ */ new Map();
    const setCustomItemRef = (el, item) => {
      if (el) {
        customItemRefs.set(item.id, { element: el, item });
        vue.nextTick(() => {
          renderCustomItem(item.id);
        });
      }
    };
    const defaultRender = (context) => {
      const item = context.item || context.currentItem;
      const container = document.createElement("div");
      container.className = "slash-menu-default-content";
      if (item.icon) {
        const iconSpan = document.createElement("span");
        iconSpan.className = "slash-menu-item-icon";
        iconSpan.innerHTML = item.icon;
        container.appendChild(iconSpan);
      }
      const labelSpan = document.createElement("span");
      labelSpan.textContent = item.label;
      container.appendChild(labelSpan);
      return container;
    };
    const renderCustomItem = async (itemId) => {
      const refData = customItemRefs.get(itemId);
      if (!refData || refData.element.hasCustomContent) return;
      const { element, item } = refData;
      try {
        if (!currentContext.value) {
          currentContext.value = await getEditorContext(props.editor);
        }
        const contextWithItem = { ...currentContext.value, currentItem: item };
        const renderFunction = item.render || defaultRender;
        const customElement = renderFunction(contextWithItem);
        if (customElement instanceof HTMLElement) {
          element.innerHTML = "";
          element.appendChild(customElement);
          element.hasCustomContent = true;
        }
      } catch (error) {
        console.warn(`[SlashMenu] Error rendering custom item ${itemId}:`, error);
        const fallbackElement = defaultRender({ ...currentContext.value || {}, currentItem: item });
        element.innerHTML = "";
        element.appendChild(fallbackElement);
        element.hasCustomContent = true;
      }
    };
    const cleanupCustomItems = () => {
      customItemRefs.forEach((refData) => {
        if (refData.element) {
          refData.element.hasCustomContent = false;
        }
      });
      customItemRefs.clear();
    };
    const handleGlobalKeyDown = (event) => {
      if (event.key === "Escape" && isOpen.value) {
        event.preventDefault();
        event.stopPropagation();
        closeMenu();
        props.editor?.focus?.();
        return;
      }
      if (isOpen.value && (event.target === searchInput.value || menuRef.value && menuRef.value.contains(event.target))) {
        const currentItems = filteredItems.value;
        const currentIndex = currentItems.findIndex((item) => item.id === selectedId.value);
        switch (event.key) {
          case "ArrowDown": {
            event.preventDefault();
            if (currentIndex < currentItems.length - 1) {
              selectedId.value = currentItems[currentIndex + 1].id;
            }
            break;
          }
          case "ArrowUp": {
            event.preventDefault();
            if (currentIndex > 0) {
              selectedId.value = currentItems[currentIndex - 1].id;
            }
            break;
          }
          case "Enter": {
            event.preventDefault();
            const selectedItem = currentItems.find((item) => item.id === selectedId.value);
            if (selectedItem) {
              executeCommand(selectedItem);
            }
            break;
          }
        }
      }
    };
    const handleGlobalOutsideClick = (event) => {
      if (isOpen.value && menuRef.value && !menuRef.value.contains(event.target)) {
        const isCtrlClickOnMac = event.ctrlKey && isMacOS();
        const isLeftClick = event.button === 0 && !isCtrlClickOnMac;
        if (isLeftClick) {
          moveCursorToMouseEvent(event, props.editor);
        }
        closeMenu({ restoreCursor: false });
      }
    };
    const shouldHandleContextMenu = (event) => {
      const readOnly = !props.editor?.isEditable;
      const contextMenuDisabled = props.editor?.options?.disableContextMenu;
      const bypass = shouldBypassContextMenu(event);
      return !readOnly && !contextMenuDisabled && !bypass;
    };
    const handleRightClickCapture = (event) => {
      try {
        if (shouldHandleContextMenu(event)) {
          event[SLASH_MENU_HANDLED_FLAG] = true;
        }
      } catch (error) {
        console.warn("[SlashMenu] Error in capture phase context menu handler:", error);
      }
    };
    const handleRightClick = async (event) => {
      if (!shouldHandleContextMenu(event)) {
        return;
      }
      event.preventDefault();
      const editorState = props.editor?.state;
      const hasRangeSelection = editorState?.selection?.from !== editorState?.selection?.to;
      let isClickInsideSelection = false;
      if (hasRangeSelection && Number.isFinite(event.clientX) && Number.isFinite(event.clientY)) {
        const hit = props.editor?.posAtCoords?.({ left: event.clientX, top: event.clientY });
        if (typeof hit?.pos === "number") {
          const { from: from3, to } = editorState.selection;
          isClickInsideSelection = hit.pos >= from3 && hit.pos <= to;
        }
      }
      if (!isClickInsideSelection) {
        moveCursorToMouseEvent(event, props.editor);
      }
      try {
        const context = await getEditorContext(props.editor, event);
        currentContext.value = context;
        sections.value = getItems({ ...context, trigger: "click" });
        selectedId.value = flattenedItems.value[0]?.id || null;
        searchQuery.value = "";
        const currentState = props.editor.state;
        if (!currentState) return;
        props.editor.dispatch(
          currentState.tr.setMeta(SlashMenuPluginKey, {
            type: "open",
            pos: context?.pos ?? currentState.selection.from,
            clientX: event.clientX,
            clientY: event.clientY
          })
        );
      } catch (error) {
        console.error("[SlashMenu] Error opening context menu:", error);
      }
    };
    const executeCommand = async (item) => {
      if (props.editor) {
        item.action ? await item.action(props.editor, currentContext.value) : null;
        if (item.component) {
          const menuElement = menuRef.value;
          const componentProps = getPropsByItemId(item.id, props);
          let popoverPosition = { left: menuPosition.value.left, top: menuPosition.value.top };
          if (menuElement) {
            const menuRect = menuElement.getBoundingClientRect();
            const container = menuElement.closest(".super-editor");
            if (container) {
              const containerRect = container.getBoundingClientRect();
              popoverPosition = {
                left: `${menuRect.left - containerRect.left}px`,
                top: `${menuRect.top - containerRect.top}px`
              };
            }
          }
          props.openPopover(vue.markRaw(item.component), componentProps, popoverPosition);
          closeMenu({ restoreCursor: false });
        } else {
          const shouldRestoreCursor = item.id !== "paste";
          closeMenu({ restoreCursor: shouldRestoreCursor });
        }
      }
    };
    const closeMenu = (options = { restoreCursor: true }) => {
      if (!props.editor) return;
      const state = props.editor.state;
      if (!state) return;
      const pluginState = SlashMenuPluginKey.getState(state);
      const anchorPos = pluginState?.anchorPos;
      props.editor.dispatch(state.tr.setMeta(SlashMenuPluginKey, { type: "close" }));
      if (options.restoreCursor && anchorPos !== null && anchorPos !== void 0) {
        const tr = props.editor.state.tr.setSelection(
          props.editor.state.selection.constructor.near(props.editor.state.doc.resolve(anchorPos))
        );
        props.editor.dispatch(tr);
        props.editor.focus?.();
      }
      cleanupCustomItems();
      currentContext.value = null;
      isOpen.value = false;
      searchQuery.value = "";
      sections.value = [];
    };
    let contextMenuTarget = null;
    let slashMenuOpenHandler = null;
    let slashMenuCloseHandler = null;
    vue.onMounted(() => {
      if (!props.editor) return;
      document.addEventListener("keydown", handleGlobalKeyDown);
      document.addEventListener("pointerdown", handleGlobalOutsideClick);
      props.editor.on("update", handleEditorUpdate);
      slashMenuOpenHandler = async (event) => {
        const readOnly = !props.editor?.isEditable;
        if (readOnly) return;
        isOpen.value = true;
        menuPosition.value = event.menuPosition;
        searchQuery.value = "";
        if (!currentContext.value) {
          const context = await getEditorContext(props.editor);
          currentContext.value = context;
          sections.value = getItems({ ...context, trigger: "slash" });
          selectedId.value = flattenedItems.value[0]?.id || null;
        } else if (sections.value.length === 0) {
          const trigger2 = currentContext.value.event?.type === "contextmenu" ? "click" : "slash";
          sections.value = getItems({ ...currentContext.value, trigger: trigger2 });
          selectedId.value = flattenedItems.value[0]?.id || null;
        }
      };
      props.editor.on("slashMenu:open", slashMenuOpenHandler);
      contextMenuTarget = getEditorSurfaceElement(props.editor);
      if (contextMenuTarget) {
        contextMenuTarget.addEventListener("contextmenu", handleRightClickCapture, true);
        contextMenuTarget.addEventListener("contextmenu", handleRightClick);
      }
      slashMenuCloseHandler = () => {
        cleanupCustomItems();
        isOpen.value = false;
        searchQuery.value = "";
        currentContext.value = null;
      };
      props.editor.on("slashMenu:close", slashMenuCloseHandler);
    });
    vue.onBeforeUnmount(() => {
      document.removeEventListener("keydown", handleGlobalKeyDown);
      document.removeEventListener("pointerdown", handleGlobalOutsideClick);
      cleanupCustomItems();
      if (props.editor) {
        try {
          if (slashMenuOpenHandler) {
            props.editor.off("slashMenu:open", slashMenuOpenHandler);
          }
          if (slashMenuCloseHandler) {
            props.editor.off("slashMenu:close", slashMenuCloseHandler);
          }
          props.editor.off("update", handleEditorUpdate);
          contextMenuTarget?.removeEventListener("contextmenu", handleRightClickCapture, true);
          contextMenuTarget?.removeEventListener("contextmenu", handleRightClick);
        } catch (error) {
          console.warn("[SlashMenu] Error during cleanup:", error);
        }
      }
    });
    return (_ctx, _cache) => {
      return isOpen.value ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        ref_key: "menuRef",
        ref: menuRef,
        class: "slash-menu",
        style: vue.normalizeStyle(menuPosition.value),
        onPointerdown: _cache[2] || (_cache[2] = vue.withModifiers(() => {
        }, ["stop"]))
      }, [
        vue.withDirectives(vue.createBaseVNode("input", {
          ref_key: "searchInput",
          ref: searchInput,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchQuery.value = $event),
          type: "text",
          class: "slash-menu-hidden-input",
          onKeydown: [
            handleGlobalKeyDown,
            _cache[1] || (_cache[1] = vue.withModifiers(() => {
            }, ["stop"]))
          ]
        }, null, 544), [
          [vue.vModelText, searchQuery.value]
        ]),
        vue.createBaseVNode("div", _hoisted_1$5, [
          (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(filteredSections.value, (section, sectionIndex) => {
            return vue.openBlock(), vue.createElementBlock(vue.Fragment, {
              key: section.id
            }, [
              sectionIndex > 0 && section.items.length > 0 ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$1)) : vue.createCommentVNode("", true),
              (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(section.items, (item) => {
                return vue.openBlock(), vue.createElementBlock("div", {
                  key: item.id,
                  class: vue.normalizeClass(["slash-menu-item", { "is-selected": item.id === selectedId.value }]),
                  onClick: ($event) => executeCommand(item)
                }, [
                  vue.createBaseVNode("div", {
                    ref_for: true,
                    ref: (el) => setCustomItemRef(el, item),
                    class: "slash-menu-custom-item"
                  }, [
                    !item.render ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
                      item.icon ? (vue.openBlock(), vue.createElementBlock("span", {
                        key: 0,
                        class: "slash-menu-item-icon",
                        innerHTML: item.icon
                      }, null, 8, _hoisted_4)) : vue.createCommentVNode("", true),
                      vue.createBaseVNode("span", null, vue.toDisplayString(item.label), 1)
                    ], 64)) : vue.createCommentVNode("", true)
                  ], 512)
                ], 10, _hoisted_3);
              }), 128))
            ], 64);
          }), 128))
        ])
      ], 36)) : vue.createCommentVNode("", true);
    };
  }
};
const _hoisted_1$4 = {
  key: 0,
  class: "numbering"
};
const MIN_WIDTH = 200;
const PPI = 96;
const alignment = "flex-end";
const _sfc_main$6 = {
  __name: "Ruler",
  props: {
    orientation: {
      type: String,
      default: "horizontal"
    },
    length: {
      type: Number,
      default: 0
    },
    editor: {
      type: Object,
      required: true
    }
  },
  emits: ["margin-change"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const props = __props;
    const ruler = vue.ref(null);
    const rulerDefinition = vue.ref(null);
    const rulerHandleOriginalColor = vue.ref("#CCCCCC");
    const rulerHandleActiveColor = vue.ref("#2563EB66");
    const pageSize = vue.ref(null);
    const pageMargins = vue.ref(null);
    const currentSectionIndex = vue.ref(0);
    const isDragging = vue.ref(false);
    const currentHandle = vue.ref(null);
    const leftHandle = vue.reactive({ side: "left", x: 0 });
    const rightHandle = vue.reactive({ side: "right", x: 0 });
    const showVerticalIndicator = vue.ref(false);
    const initialX = vue.ref(0);
    let offsetX = 0;
    let selectionUpdateHandler = null;
    let zoomChangeHandler = null;
    const currentZoom = vue.ref(1);
    const getPresentationEditor = () => {
      const editor = props.editor;
      if (!editor) return null;
      if (typeof editor.zoom === "number" && typeof editor.setZoom === "function") {
        return editor;
      }
      if (editor.presentationEditor) {
        return editor.presentationEditor;
      }
      return null;
    };
    const updateRulerForCurrentSection = () => {
      if (!props.editor || props.editor.options?.mode !== "docx") {
        return;
      }
      const presentationEditor = getPresentationEditor();
      let docSize, docMargins, sectionIndex;
      if (presentationEditor && typeof presentationEditor.getCurrentSectionPageStyles === "function") {
        const sectionStyles = presentationEditor.getCurrentSectionPageStyles();
        docSize = sectionStyles.pageSize;
        docMargins = sectionStyles.pageMargins;
        sectionIndex = sectionStyles.sectionIndex;
      } else {
        const styles = props.editor.getPageStyles();
        docSize = styles.pageSize ?? { width: 8.5, height: 11 };
        docMargins = styles.pageMargins ?? { left: 1, right: 1, top: 1, bottom: 1 };
        sectionIndex = 0;
      }
      if (pageSize.value && currentSectionIndex.value === sectionIndex) {
        return;
      }
      currentSectionIndex.value = sectionIndex;
      pageSize.value = docSize;
      pageMargins.value = docMargins;
      const definition = generateRulerDefinition({
        pageSize: { width: docSize.width, height: docSize.height },
        pageMargins: {
          left: docMargins.left,
          right: docMargins.right,
          top: docMargins.top ?? 1,
          bottom: docMargins.bottom ?? 1
        }
      });
      leftHandle.x = definition.leftMarginPx;
      rightHandle.x = definition.rightMarginPx;
      rulerDefinition.value = definition;
    };
    const getTickStyle = vue.computed(() => (tick) => {
      const zoom = currentZoom.value;
      return {
        position: "absolute",
        left: `${tick.x * zoom}px`,
        bottom: "0",
        width: "1px",
        height: tick.height,
        backgroundColor: "#666",
        pointerEvents: "none"
      };
    });
    const getHandlePosition = vue.computed(() => (side) => {
      const handle = side === "left" ? leftHandle : rightHandle;
      const zoom = currentZoom.value;
      return {
        left: `${handle.x * zoom}px`
      };
    });
    const getVerticalIndicatorStyle = vue.computed(() => {
      if (!ruler.value) {
        return { left: "0px", minHeight: "100%" };
      }
      const zoom = currentZoom.value;
      const parentElement = ruler.value.parentElement;
      const editor = parentElement?.querySelector(".super-editor") ?? document.querySelector(".super-editor");
      if (!editor) return { left: `${currentHandle.value.x * zoom}px`, minHeight: "100%" };
      const editorBounds = editor.getBoundingClientRect();
      return {
        left: `${currentHandle.value.x * zoom}px`,
        minHeight: `${editorBounds.height}px`
      };
    });
    const screenToLocalX = (screenX) => {
      if (!ruler.value) return screenX;
      const rulerRect = ruler.value.getBoundingClientRect();
      const zoom = currentZoom.value;
      return (screenX - rulerRect.left) / zoom;
    };
    const handleMouseDown2 = (event) => {
      isDragging.value = true;
      setRulerHandleActive();
      const itemId = event.currentTarget.id;
      currentHandle.value = itemId === "left-margin-handle" ? leftHandle : rightHandle;
      initialX.value = currentHandle.value.x;
      const localX = screenToLocalX(event.clientX);
      offsetX = localX - currentHandle.value.x;
      showVerticalIndicator.value = true;
    };
    const handleMouseMove2 = (event) => {
      if (!isDragging.value || !pageSize.value) return;
      const localX = screenToLocalX(event.clientX);
      const newLeft = localX - offsetX;
      const pageWidthPx = pageSize.value.width * PPI;
      const otherHandleX = currentHandle.value.side === "left" ? rightHandle.x : leftHandle.x;
      currentHandle.value.x = clampHandlePosition(newLeft, currentHandle.value.side, otherHandleX, pageWidthPx, MIN_WIDTH);
    };
    const handleMouseUp = () => {
      isDragging.value = false;
      showVerticalIndicator.value = false;
      setRulerHandleInactive();
      if (currentHandle.value && currentHandle.value.x !== initialX.value) {
        const marginValue = getNewMarginValue();
        emit("margin-change", {
          side: currentHandle.value.side,
          value: marginValue,
          sectionIndex: currentSectionIndex.value
        });
      }
    };
    const setRulerHandleActive = () => {
      rulerHandleOriginalColor.value = rulerHandleActiveColor.value;
    };
    const setRulerHandleInactive = () => {
      rulerHandleOriginalColor.value = "#CCC";
    };
    const getNewMarginValue = () => {
      if (!pageSize.value) return 0;
      const pageWidthPx = pageSize.value.width * PPI;
      return calculateMarginFromHandle(currentHandle.value.x, currentHandle.value.side, pageWidthPx, PPI);
    };
    const wrapperStyle = vue.computed(() => {
      const width = rulerDefinition.value?.widthPx ?? pageSize.value?.width * PPI ?? 816;
      const zoom = currentZoom.value;
      const scaledWidth = width * zoom;
      return {
        width: `${scaledWidth}px`,
        minWidth: `${scaledWidth}px`,
        height: "25px",
        overflow: "visible",
        flexShrink: 0
      };
    });
    const rulerStyle = vue.computed(() => {
      const width = rulerDefinition.value?.widthPx ?? pageSize.value?.width * PPI ?? 816;
      const zoom = currentZoom.value;
      const scaledWidth = width * zoom;
      return {
        width: `${scaledWidth}px`,
        height: "25px"
      };
    });
    const getStyleVars = vue.computed(() => {
      return {
        "--alignment": alignment,
        "--ruler-handle-color": rulerHandleOriginalColor.value,
        "--ruler-handle-active-color": rulerHandleActiveColor.value
      };
    });
    const handleSelectionUpdate = () => {
      if (isDragging.value) return;
      updateRulerForCurrentSection();
    };
    const handleZoomChange = ({ zoom }) => {
      currentZoom.value = zoom;
    };
    const initializeZoom = () => {
      const presentationEditor = getPresentationEditor();
      if (presentationEditor && typeof presentationEditor.zoom === "number") {
        currentZoom.value = presentationEditor.zoom;
      } else {
        currentZoom.value = 1;
      }
    };
    const setupEditorListeners = () => {
      if (!props.editor) return;
      selectionUpdateHandler = handleSelectionUpdate;
      props.editor.on("selectionUpdate", selectionUpdateHandler);
      const presentationEditor = getPresentationEditor();
      if (presentationEditor) {
        zoomChangeHandler = handleZoomChange;
        presentationEditor.on("zoomChange", zoomChangeHandler);
        initializeZoom();
      }
    };
    const cleanupEditorListeners = () => {
      if (props.editor && selectionUpdateHandler) {
        props.editor.off("selectionUpdate", selectionUpdateHandler);
        selectionUpdateHandler = null;
      }
      const presentationEditor = getPresentationEditor();
      if (presentationEditor && zoomChangeHandler) {
        presentationEditor.off("zoomChange", zoomChangeHandler);
        zoomChangeHandler = null;
      }
    };
    const getPresentationEditorFrom = (editor) => {
      if (!editor) return null;
      if (typeof editor.zoom === "number" && typeof editor.setZoom === "function") {
        return editor;
      }
      return editor.presentationEditor ?? null;
    };
    vue.watch(
      () => props.editor,
      (newEditor, oldEditor) => {
        if (oldEditor) {
          if (selectionUpdateHandler) {
            oldEditor.off("selectionUpdate", selectionUpdateHandler);
          }
          const oldPresentationEditor = getPresentationEditorFrom(oldEditor);
          if (oldPresentationEditor && zoomChangeHandler) {
            oldPresentationEditor.off("zoomChange", zoomChangeHandler);
          }
        }
        if (zoomChangeHandler && !oldEditor) {
          zoomChangeHandler = null;
        }
        if (newEditor) {
          setupEditorListeners();
          updateRulerForCurrentSection();
        }
      }
    );
    vue.onMounted(() => {
      updateRulerForCurrentSection();
      setupEditorListeners();
      window.addEventListener("mousemove", handleMouseMove2);
      window.addEventListener("mouseup", handleMouseUp);
    });
    vue.onUnmounted(() => {
      cleanupEditorListeners();
      window.removeEventListener("mousemove", handleMouseMove2);
      window.removeEventListener("mouseup", handleMouseUp);
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: "ruler-wrapper",
        style: vue.normalizeStyle([wrapperStyle.value, getStyleVars.value])
      }, [
        vue.createBaseVNode("div", {
          class: "ruler",
          ref_key: "ruler",
          ref: ruler,
          style: vue.normalizeStyle(rulerStyle.value)
        }, [
          vue.createBaseVNode("div", {
            class: "margin-handle handle-left",
            id: "left-margin-handle",
            onMousedown: handleMouseDown2,
            style: vue.normalizeStyle(getHandlePosition.value("left"))
          }, null, 36),
          vue.createBaseVNode("div", {
            class: "margin-handle handle-right",
            id: "right-margin-handle",
            onMousedown: handleMouseDown2,
            style: vue.normalizeStyle(getHandlePosition.value("right"))
          }, null, 36),
          showVerticalIndicator.value ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 0,
            class: "vertical-indicator",
            style: vue.normalizeStyle(getVerticalIndicatorStyle.value)
          }, null, 4)) : vue.createCommentVNode("", true),
          rulerDefinition.value ? (vue.openBlock(true), vue.createElementBlock(vue.Fragment, { key: 1 }, vue.renderList(rulerDefinition.value.ticks, (tick, index2) => {
            return vue.openBlock(), vue.createElementBlock("div", {
              key: index2,
              class: vue.normalizeClass(["ruler-tick", `ruler-tick--${tick.size}`]),
              style: vue.normalizeStyle(getTickStyle.value(tick))
            }, [
              tick.label !== void 0 ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_1$4, vue.toDisplayString(tick.label), 1)) : vue.createCommentVNode("", true)
            ], 6);
          }), 128)) : vue.createCommentVNode("", true)
        ], 4)
      ], 4);
    };
  }
};
const Ruler = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-9face03e"]]);
const _sfc_main$5 = {
  __name: "GenericPopover",
  props: {
    editor: { type: Object, required: true },
    styles: { type: Object, default: () => ({}) },
    visible: { type: Boolean, default: false },
    position: { type: Object, default: () => ({ left: "0px", top: "0px" }) }
  },
  emits: ["close"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const popover = vue.ref(null);
    function handleClickOutside2(event) {
      if (popover.value && !popover.value.contains(event.target)) {
        emit("close");
      }
      moveCursorToMouseEvent(event, props.editor);
    }
    function handleEscape(event) {
      if (event.key === "Escape") {
        emit("close");
      }
    }
    vue.watch(
      () => props.visible,
      (val) => {
        if (val) {
          document.addEventListener("pointerdown", handleClickOutside2);
          document.addEventListener("keydown", handleEscape);
        } else {
          document.removeEventListener("pointerdown", handleClickOutside2);
          document.removeEventListener("keydown", handleEscape);
        }
      }
    );
    vue.onMounted(() => {
      if (props.visible) {
        document.addEventListener("pointerdown", handleClickOutside2);
        document.addEventListener("keydown", handleEscape);
      }
    });
    vue.onBeforeUnmount(() => {
      document.removeEventListener("pointerdown", handleClickOutside2);
      document.removeEventListener("keydown", handleEscape);
    });
    const derivedStyles = vue.computed(() => ({
      left: props.position.left,
      top: props.position.top,
      ...props.styles
    }));
    return (_ctx, _cache) => {
      return __props.visible ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: "generic-popover",
        style: vue.normalizeStyle(derivedStyles.value),
        ref_key: "popover",
        ref: popover,
        onPointerdown: _cache[0] || (_cache[0] = vue.withModifiers(() => {
        }, ["stop"])),
        onClick: _cache[1] || (_cache[1] = vue.withModifiers(() => {
        }, ["stop"]))
      }, [
        vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 36)) : vue.createCommentVNode("", true);
    };
  }
};
const GenericPopover = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-22601496"]]);
const _hoisted_1$3 = ["data-boundary-index", "data-boundary-type", "onMousedown"];
const RESIZE_HANDLE_WIDTH_PX = 9;
const RESIZE_HANDLE_OFFSET_PX = 4;
const DRAG_OVERLAY_EXTENSION_PX = 1e3;
const MIN_DRAG_OVERLAY_WIDTH_PX = 2e3;
const THROTTLE_INTERVAL_MS = 16;
const MIN_RESIZE_DELTA_PX = 1;
const _sfc_main$4 = {
  __name: "TableResizeOverlay",
  props: {
    /** Editor instance for dispatching transactions */
    editor: {
      type: Object,
      required: true
    },
    /** Show or hide the overlay */
    visible: {
      type: Boolean,
      default: false
    },
    /** Table fragment element containing data-table-boundaries */
    tableElement: {
      type: Object,
      default: null
    }
  },
  emits: ["resize-start", "resize-move", "resize-end", "resize-success", "resize-error"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const overlayRect = vue.ref(null);
    const tableMetadata = vue.ref(null);
    const getZoom = () => {
      const editor = props.editor;
      if (editor && typeof editor.zoom === "number") {
        return editor.zoom;
      }
      if (editor?.presentationEditor && typeof editor.presentationEditor.zoom === "number") {
        return editor.presentationEditor.zoom;
      }
      console.warn(
        "[TableResizeOverlay] getZoom: Unable to retrieve zoom from editor instance, using fallback value of 1. This may indicate the editor is not fully initialized or is not a PresentationEditor instance. Table resize handles may be misaligned."
      );
      return 1;
    };
    const dragState = vue.ref(null);
    const forcedCleanup = vue.ref(false);
    let rafId = null;
    let isUnmounted = false;
    function startOverlayTracking() {
      if (rafId !== null) return;
      const step = () => {
        updateOverlayRect();
        rafId = requestAnimationFrame(step);
      };
      rafId = requestAnimationFrame(step);
    }
    function stopOverlayTracking() {
      if (rafId !== null) {
        cancelAnimationFrame(rafId);
        rafId = null;
      }
    }
    const overlayStyle = vue.computed(() => {
      if (!overlayRect.value || !props.tableElement) return {};
      const rect = overlayRect.value;
      let overlayWidth = rect.width;
      if (dragState.value) {
        overlayWidth = Math.max(rect.width + DRAG_OVERLAY_EXTENSION_PX, MIN_DRAG_OVERLAY_WIDTH_PX);
      }
      return {
        position: "absolute",
        left: `${rect.left}px`,
        top: `${rect.top}px`,
        width: `${overlayWidth}px`,
        height: `${rect.height}px`,
        pointerEvents: dragState.value ? "auto" : "none",
        zIndex: 10
      };
    });
    function updateOverlayRect() {
      if (!props.tableElement) {
        overlayRect.value = null;
        return;
      }
      const parent = props.tableElement.offsetParent;
      const tableRect = props.tableElement.getBoundingClientRect();
      if (tableRect.width === 0 || tableRect.height === 0) {
        overlayRect.value = null;
        return;
      }
      if (parent) {
        const parentRect = parent.getBoundingClientRect();
        const left2 = tableRect.left - parentRect.left + (parent.scrollLeft || 0);
        const top2 = tableRect.top - parentRect.top + (parent.scrollTop || 0);
        overlayRect.value = {
          left: left2,
          top: top2,
          width: tableRect.width,
          height: tableRect.height
        };
      } else {
        overlayRect.value = {
          left: props.tableElement.offsetLeft,
          top: props.tableElement.offsetTop,
          width: tableRect.width,
          height: tableRect.height
        };
      }
    }
    const resizableBoundaries = vue.computed(() => {
      if (!tableMetadata.value?.columns) {
        return [];
      }
      const columns = tableMetadata.value.columns;
      const boundaries = [];
      for (let i = 0; i < columns.length - 1; i++) {
        const col = columns[i];
        const nextCol = columns[i + 1];
        boundaries.push({
          ...col,
          index: i,
          x: nextCol.x,
          type: "inner"
        });
      }
      const lastCol = columns[columns.length - 1];
      boundaries.push({
        ...lastCol,
        index: columns.length - 1,
        x: lastCol.x + lastCol.w,
        type: "right-edge"
      });
      return boundaries;
    });
    function getBoundarySegments(boundary) {
      if (boundary.type === "right-edge") {
        return [{ y: 0, h: null }];
      }
      const segmentsData = tableMetadata.value?.segments;
      if (!segmentsData || !Array.isArray(segmentsData)) {
        return [{ y: 0, h: null }];
      }
      const boundaryColIndex = boundary.index + 1;
      const colSegments = segmentsData[boundaryColIndex];
      if (!colSegments || colSegments.length === 0) {
        return [];
      }
      return colSegments.filter((seg) => seg && typeof seg === "object").map((seg) => ({
        y: typeof seg.y === "number" ? seg.y : 0,
        h: seg.h !== null && typeof seg.h === "number" ? seg.h : null
      }));
    }
    function getSegmentHandleStyle(boundary, segment) {
      const zoom = getZoom();
      const scaledX = boundary.x * zoom;
      const scaledY = segment.y != null ? segment.y * zoom : null;
      const scaledH = segment.h != null ? segment.h * zoom : null;
      return {
        position: "absolute",
        left: `${scaledX}px`,
        top: scaledY != null ? `${scaledY}px` : "0",
        width: `${RESIZE_HANDLE_WIDTH_PX}px`,
        height: scaledH != null ? `${scaledH}px` : "100%",
        transform: `translateX(-${RESIZE_HANDLE_OFFSET_PX}px)`,
        cursor: "col-resize",
        pointerEvents: "auto"
      };
    }
    const guidelineStyle = vue.computed(() => {
      if (!dragState.value || !tableMetadata.value) return { display: "none" };
      const initialBoundary = resizableBoundaries.value[dragState.value.resizableBoundaryIndex];
      if (!initialBoundary) return { display: "none" };
      const zoom = getZoom();
      const newX = (initialBoundary.x + dragState.value.constrainedDelta) * zoom;
      return {
        position: "absolute",
        left: `${newX}px`,
        top: "0",
        width: "2px",
        height: "100%",
        backgroundColor: "#4A90E2",
        pointerEvents: "none",
        zIndex: 20
      };
    });
    function parseTableMetadata() {
      if (!props.tableElement) {
        tableMetadata.value = null;
        return;
      }
      try {
        const boundariesAttr = props.tableElement.getAttribute("data-table-boundaries");
        if (!boundariesAttr) {
          tableMetadata.value = null;
          return;
        }
        const parsed = JSON.parse(boundariesAttr);
        if (!parsed || typeof parsed !== "object" || !Array.isArray(parsed.columns)) {
          tableMetadata.value = null;
          return;
        }
        const validatedColumns = parsed.columns.filter((col) => {
          return typeof col === "object" && Number.isFinite(col.i) && col.i >= 0 && Number.isFinite(col.x) && col.x >= 0 && Number.isFinite(col.w) && col.w > 0 && Number.isFinite(col.min) && col.min > 0 && (col.r === 0 || col.r === 1);
        }).map((col) => ({
          i: col.i,
          x: Math.max(0, col.x),
          w: Math.max(1, col.w),
          min: Math.max(1, col.min),
          r: col.r
        }));
        if (validatedColumns.length === 0) {
          tableMetadata.value = null;
          emit("resize-error", {
            error: "Table metadata is corrupted or empty after validation",
            rawMetadata: boundariesAttr
          });
          return;
        }
        const segments = Array.isArray(parsed.segments) ? parsed.segments : void 0;
        tableMetadata.value = { columns: validatedColumns, segments };
      } catch (error) {
        tableMetadata.value = null;
        emit("resize-error", {
          error: error instanceof Error ? error.message : "Failed to parse table boundaries",
          rawMetadata: props.tableElement?.getAttribute("data-table-boundaries")
        });
      }
    }
    function onHandleMouseDown(event, resizableBoundaryIndex) {
      event.preventDefault();
      event.stopPropagation();
      if (!tableMetadata.value?.columns) return;
      const boundary = resizableBoundaries.value[resizableBoundaryIndex];
      if (!boundary) return;
      const columns = tableMetadata.value.columns;
      const isRightEdge = boundary.type === "right-edge";
      const leftColumn = columns[boundary.index];
      const rightColumn = isRightEdge ? null : columns[boundary.index + 1];
      dragState.value = {
        columnIndex: boundary.index,
        resizableBoundaryIndex,
        isRightEdge,
        initialX: event.clientX,
        initialWidths: columns.map((col) => col.w),
        leftColumn: {
          width: leftColumn.w,
          minWidth: leftColumn.min
        },
        rightColumn: rightColumn ? {
          width: rightColumn.w,
          minWidth: rightColumn.min
        } : null,
        constrainedDelta: 0
      };
      if (!props.editor?.view?.dom) {
        emit("resize-error", { error: "Editor view not available" });
        dragState.value = null;
        return;
      }
      const pmView = props.editor.view.dom;
      pmView.style.pointerEvents = "none";
      try {
        document.addEventListener("mousemove", onDocumentMouseMove2);
        document.addEventListener("mouseup", onDocumentMouseUp);
        emit("resize-start", {
          columnIndex: boundary.index,
          isRightEdge,
          initialWidths: dragState.value.initialWidths
        });
      } catch (error) {
        document.removeEventListener("mousemove", onDocumentMouseMove2);
        document.removeEventListener("mouseup", onDocumentMouseUp);
        pmView.style.pointerEvents = "auto";
        dragState.value = null;
        emit("resize-error", { error: error instanceof Error ? error.message : String(error) });
      }
    }
    function throttle2(func, limit) {
      let inThrottle;
      let timeoutId = null;
      const throttled = function(...args) {
        if (!inThrottle) {
          func.apply(this, args);
          inThrottle = true;
          timeoutId = setTimeout(() => {
            inThrottle = false;
            timeoutId = null;
          }, limit);
        }
      };
      const cancel = () => {
        if (timeoutId !== null) {
          clearTimeout(timeoutId);
          timeoutId = null;
          inThrottle = false;
        }
      };
      return { throttled, cancel };
    }
    const mouseMoveThrottle = throttle2((event) => {
      if (isUnmounted || !dragState.value) return;
      const zoom = getZoom();
      const screenDelta = event.clientX - dragState.value.initialX;
      const delta = screenDelta / zoom;
      const minDelta = -(dragState.value.leftColumn.width - dragState.value.leftColumn.minWidth);
      let maxDelta;
      if (dragState.value.isRightEdge) {
        const tableRect = props.tableElement.getBoundingClientRect();
        const pageEl = props.tableElement.closest(".superdoc-page");
        if (pageEl) {
          const pageRect = pageEl.getBoundingClientRect();
          const tableLeftInPage = tableRect.left - pageRect.left;
          const rightMargin = tableLeftInPage;
          const maxRightPosition = pageRect.right - rightMargin;
          const availableSpace = (maxRightPosition - tableRect.right) / zoom;
          maxDelta = Math.max(0, availableSpace);
        } else {
          maxDelta = Infinity;
        }
      } else {
        maxDelta = dragState.value.rightColumn.width - dragState.value.rightColumn.minWidth;
      }
      const constrainedDelta = Math.max(minDelta, Math.min(maxDelta, delta));
      dragState.value.constrainedDelta = constrainedDelta;
      emit("resize-move", {
        columnIndex: dragState.value.columnIndex,
        delta: constrainedDelta
      });
    }, THROTTLE_INTERVAL_MS);
    const onDocumentMouseMove2 = mouseMoveThrottle.throttled;
    function onDocumentMouseUp(event) {
      if (!dragState.value) return;
      const finalDelta = dragState.value.constrainedDelta;
      const columnIndex = dragState.value.columnIndex;
      const initialWidths = dragState.value.initialWidths;
      const isRightEdge = dragState.value.isRightEdge;
      const newWidths = [...initialWidths];
      newWidths[columnIndex] = initialWidths[columnIndex] + finalDelta;
      if (!isRightEdge) {
        newWidths[columnIndex + 1] = initialWidths[columnIndex + 1] - finalDelta;
      }
      document.removeEventListener("mousemove", onDocumentMouseMove2);
      document.removeEventListener("mouseup", onDocumentMouseUp);
      if (props.editor?.view?.dom) {
        const pmView = props.editor.view.dom;
        pmView.style.pointerEvents = "auto";
      }
      if (!forcedCleanup.value && Math.abs(finalDelta) > MIN_RESIZE_DELTA_PX) {
        dispatchResizeTransaction(columnIndex, newWidths);
        emit("resize-end", {
          columnIndex,
          finalWidths: newWidths,
          delta: finalDelta
        });
      }
      dragState.value = null;
    }
    function dispatchResizeTransaction(columnIndex, newWidths) {
      if (!props.editor?.view || !props.tableElement) {
        return;
      }
      try {
        const { state, dispatch } = props.editor.view;
        const tr = state.tr;
        const tablePos = findTablePosition(state, props.tableElement);
        if (tablePos === null) {
          emit("resize-error", {
            columnIndex,
            error: "Table position not found in document"
          });
          return;
        }
        const tableNode = state.doc.nodeAt(tablePos);
        if (!tableNode || tableNode.type.name !== "table") {
          emit("resize-error", {
            columnIndex,
            error: "Invalid table node at position"
          });
          return;
        }
        const gridTwips = newWidths.map((w) => helpers$1.pixelsToTwips(w));
        const newGrid = gridTwips.map((twips) => ({ col: twips }));
        const totalWidthTwips = gridTwips.reduce((sum, w) => sum + w, 0);
        const newAttrs = {
          ...tableNode.attrs,
          grid: newGrid,
          tableWidth: totalWidthTwips,
          userEdited: true
        };
        tr.setNodeMarkup(tablePos, null, newAttrs);
        const affectedColumns = [columnIndex, columnIndex + 1];
        updateCellColwidths(tr, tableNode, tablePos, affectedColumns, newWidths);
        dispatch(tr);
        const blockId = props.tableElement?.getAttribute("data-sd-block-id");
        if (blockId && blockId.trim()) {
          measureCache.invalidate([blockId]);
        }
        emit("resize-success", { columnIndex, newWidths });
      } catch (error) {
        emit("resize-error", {
          columnIndex,
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
    function findTablePosition(state, tableElement) {
      const pmElement = tableElement.querySelector("[data-pm-start]");
      if (!pmElement) {
        return null;
      }
      const pmStartAttr = pmElement.getAttribute("data-pm-start");
      if (!pmStartAttr) {
        return null;
      }
      const pmStart = parseInt(pmStartAttr, 10);
      if (!Number.isFinite(pmStart)) {
        return null;
      }
      let tablePos = null;
      state.doc.descendants((node, pos) => {
        if (node.type.name === "table") {
          const tableEnd = pos + node.nodeSize;
          if (pmStart >= pos && pmStart < tableEnd) {
            tablePos = pos;
            return false;
          }
        }
      });
      return tablePos;
    }
    function updateCellColwidths(tr, tableNode, tablePos, affectedColumns, newWidths) {
      let currentCol = 0;
      tableNode.descendants((node, pos, parent) => {
        if (node.type.name === "tableRow") {
          currentCol = 0;
          return true;
        }
        if (node.type.name === "tableCell" || node.type.name === "tableHeader") {
          const { colspan = 1 } = node.attrs;
          const cellAffectsColumns = affectedColumns.some(
            (affectedCol) => affectedCol >= currentCol && affectedCol < currentCol + colspan
          );
          if (cellAffectsColumns) {
            const absolutePos = tablePos + 1 + pos;
            const newColwidth = [];
            for (let i = 0; i < colspan; i++) {
              const colIndex = currentCol + i;
              const width = newWidths[colIndex];
              if (width !== void 0 && width > 0) {
                newColwidth.push(width);
              }
            }
            if (newColwidth.length > 0) {
              tr.setNodeMarkup(absolutePos, null, {
                ...node.attrs,
                colwidth: newColwidth
              });
            }
          }
          currentCol += colspan;
          return false;
        }
        return true;
      });
    }
    vue.watch(
      () => props.tableElement,
      () => {
        parseTableMetadata();
        updateOverlayRect();
        if (props.visible && props.tableElement) {
          startOverlayTracking();
        } else if (!props.tableElement) {
          stopOverlayTracking();
        }
      },
      { immediate: true }
    );
    vue.watch(
      () => props.visible,
      (visible) => {
        if (visible) {
          parseTableMetadata();
          updateOverlayRect();
          startOverlayTracking();
        } else {
          stopOverlayTracking();
          if (dragState.value) {
            forcedCleanup.value = true;
            onDocumentMouseUp(new MouseEvent("mouseup"));
            forcedCleanup.value = false;
          }
        }
      }
    );
    vue.onMounted(() => {
      window.addEventListener("scroll", updateOverlayRect, true);
      window.addEventListener("resize", updateOverlayRect);
      updateOverlayRect();
    });
    vue.onBeforeUnmount(() => {
      isUnmounted = true;
      mouseMoveThrottle.cancel();
      stopOverlayTracking();
      if (dragState.value) {
        document.removeEventListener("mousemove", onDocumentMouseMove2);
        document.removeEventListener("mouseup", onDocumentMouseUp);
        if (props.editor?.view?.dom) {
          props.editor.view.dom.style.pointerEvents = "auto";
        }
      }
      window.removeEventListener("scroll", updateOverlayRect, true);
      window.removeEventListener("resize", updateOverlayRect);
    });
    return (_ctx, _cache) => {
      return __props.visible && tableMetadata.value ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: "superdoc-table-resize-overlay",
        style: vue.normalizeStyle(overlayStyle.value),
        onMousedown: _cache[0] || (_cache[0] = vue.withModifiers(() => {
        }, ["stop"]))
      }, [
        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(resizableBoundaries.value, (boundary, resizableBoundaryIndex) => {
          return vue.openBlock(), vue.createElementBlock(vue.Fragment, {
            key: `boundary-${resizableBoundaryIndex}`
          }, [
            (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(getBoundarySegments(boundary), (segment, segmentIndex) => {
              return vue.openBlock(), vue.createElementBlock("div", {
                key: `handle-${boundary.type}-${boundary.index}-${segmentIndex}`,
                class: vue.normalizeClass(["resize-handle", {
                  "resize-handle--active": dragState.value && dragState.value.resizableBoundaryIndex === resizableBoundaryIndex,
                  "resize-handle--edge": boundary.type === "right-edge"
                }]),
                "data-boundary-index": resizableBoundaryIndex,
                "data-boundary-type": boundary.type,
                style: vue.normalizeStyle(getSegmentHandleStyle(boundary, segment)),
                onMousedown: ($event) => onHandleMouseDown($event, resizableBoundaryIndex)
              }, null, 46, _hoisted_1$3);
            }), 128))
          ], 64);
        }), 128)),
        dragState.value ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: "resize-guideline",
          style: vue.normalizeStyle(guidelineStyle.value)
        }, null, 4)) : vue.createCommentVNode("", true)
      ], 36)) : vue.createCommentVNode("", true);
    };
  }
};
const TableResizeOverlay = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["__scopeId", "data-v-033805f0"]]);
const _hoisted_1$2 = ["data-handle-position", "onMousedown"];
const OVERLAY_EXPANSION_PX = 2e3;
const RESIZE_HANDLE_SIZE_PX = 12;
const MOUSE_MOVE_THROTTLE_MS = 16;
const DIMENSION_CHANGE_THRESHOLD_PX = 1;
const Z_INDEX_OVERLAY = 10;
const Z_INDEX_HANDLE = 15;
const Z_INDEX_GUIDELINE = 20;
const _sfc_main$3 = {
  __name: "ImageResizeOverlay",
  props: {
    /** Editor instance for dispatching transactions */
    editor: {
      type: Object,
      required: true
    },
    /** Show or hide the overlay */
    visible: {
      type: Boolean,
      default: false
    },
    /** Image fragment element containing data-image-metadata */
    imageElement: {
      type: Object,
      default: null
    }
  },
  emits: ["resize-start", "resize-move", "resize-end", "resize-success", "resize-error"],
  setup(__props, { emit: __emit }) {
    vue.useCssVars((_ctx) => ({
      "v410b9c0c": RESIZE_HANDLE_SIZE_PX + "px",
      "v190a595a": Z_INDEX_HANDLE
    }));
    function isValidEditor(editor) {
      return editor && typeof editor === "object" && editor.view && typeof editor.view === "object" && editor.view.dom instanceof HTMLElement && editor.view.state && typeof editor.view.dispatch === "function";
    }
    const props = __props;
    const emit = __emit;
    const imageMetadata = vue.ref(null);
    const dragState = vue.ref(null);
    const forcedCleanup = vue.ref(false);
    const overlayStyle = vue.computed(() => {
      if (!props.imageElement || !props.imageElement.isConnected) return {};
      const imageRect = props.imageElement.getBoundingClientRect();
      const wrapper = props.imageElement.closest(".super-editor");
      if (!wrapper) {
        return {
          position: "absolute",
          left: `${props.imageElement.offsetLeft}px`,
          top: `${props.imageElement.offsetTop}px`,
          width: `${imageRect.width}px`,
          height: `${imageRect.height}px`,
          pointerEvents: dragState.value ? "auto" : "none",
          zIndex: Z_INDEX_OVERLAY
        };
      }
      const wrapperRect = wrapper.getBoundingClientRect();
      const scrollLeft = wrapper.scrollLeft || 0;
      const scrollTop = wrapper.scrollTop || 0;
      const relativeLeft = imageRect.left - wrapperRect.left + scrollLeft;
      const relativeTop = imageRect.top - wrapperRect.top + scrollTop;
      let overlayWidth = imageRect.width;
      let overlayHeight = imageRect.height;
      let offsetX = 0;
      let offsetY = 0;
      if (dragState.value) {
        const expansion = OVERLAY_EXPANSION_PX;
        overlayWidth = imageRect.width + expansion * 2;
        overlayHeight = imageRect.height + expansion * 2;
        offsetX = -expansion;
        offsetY = -expansion;
      }
      return {
        position: "absolute",
        left: `${relativeLeft + offsetX}px`,
        top: `${relativeTop + offsetY}px`,
        width: `${overlayWidth}px`,
        height: `${overlayHeight}px`,
        pointerEvents: dragState.value ? "auto" : "none",
        zIndex: Z_INDEX_OVERLAY
      };
    });
    const resizeHandles = vue.computed(() => {
      if (!imageMetadata.value || !props.imageElement) {
        return [];
      }
      const rect = props.imageElement.getBoundingClientRect();
      const width = rect.width;
      const height = rect.height;
      const handleSize = RESIZE_HANDLE_SIZE_PX;
      const offset2 = handleSize / 2;
      const expansion = dragState.value ? OVERLAY_EXPANSION_PX : 0;
      return [
        {
          position: "nw",
          style: {
            left: `${expansion - offset2}px`,
            top: `${expansion - offset2}px`,
            cursor: "nwse-resize"
          }
        },
        {
          position: "ne",
          style: {
            left: `${expansion + width - offset2}px`,
            top: `${expansion - offset2}px`,
            cursor: "nesw-resize"
          }
        },
        {
          position: "sw",
          style: {
            left: `${expansion - offset2}px`,
            top: `${expansion + height - offset2}px`,
            cursor: "nesw-resize"
          }
        },
        {
          position: "se",
          style: {
            left: `${expansion + width - offset2}px`,
            top: `${expansion + height - offset2}px`,
            cursor: "nwse-resize"
          }
        }
      ];
    });
    const guidelineStyle = vue.computed(() => {
      if (!dragState.value || !props.imageElement) {
        return { display: "none" };
      }
      const expansion = OVERLAY_EXPANSION_PX;
      return {
        position: "absolute",
        left: `${expansion}px`,
        top: `${expansion}px`,
        width: `${dragState.value.constrainedWidth}px`,
        height: `${dragState.value.constrainedHeight}px`,
        border: "2px solid #4A90E2",
        pointerEvents: "none",
        zIndex: Z_INDEX_GUIDELINE,
        boxSizing: "border-box"
      };
    });
    function parseImageMetadata() {
      if (!props.imageElement || !props.imageElement.isConnected) {
        imageMetadata.value = null;
        return;
      }
      try {
        const metadataAttr = props.imageElement.getAttribute("data-image-metadata");
        if (!metadataAttr) {
          imageMetadata.value = null;
          return;
        }
        const parsed = JSON.parse(metadataAttr);
        if (!parsed || typeof parsed !== "object") {
          imageMetadata.value = null;
          return;
        }
        const required = [
          "originalWidth",
          "originalHeight",
          "maxWidth",
          "maxHeight",
          "aspectRatio",
          "minWidth",
          "minHeight"
        ];
        for (const field of required) {
          if (!Number.isFinite(parsed[field]) || parsed[field] <= 0) {
            console.warn(`[ImageResizeOverlay] Invalid or missing metadata field: ${field}`);
            imageMetadata.value = null;
            return;
          }
        }
        imageMetadata.value = parsed;
      } catch (error) {
        imageMetadata.value = null;
        emit("resize-error", {
          error: error instanceof Error ? error.message : "Failed to parse image metadata",
          rawMetadata: props.imageElement?.getAttribute("data-image-metadata")
        });
      }
    }
    function onHandleMouseDown(event, handlePosition) {
      event.preventDefault();
      event.stopPropagation();
      if (!isValidEditor(props.editor) || !imageMetadata.value || !props.imageElement) return;
      const rect = props.imageElement.getBoundingClientRect();
      dragState.value = {
        handle: handlePosition,
        initialX: event.clientX,
        initialY: event.clientY,
        initialWidth: rect.width,
        initialHeight: rect.height,
        aspectRatio: imageMetadata.value.aspectRatio,
        constrainedWidth: rect.width,
        constrainedHeight: rect.height
      };
      const pmView = props.editor.view.dom;
      pmView.style.pointerEvents = "none";
      document.addEventListener("mousemove", onDocumentMouseMove2);
      document.addEventListener("mouseup", onDocumentMouseUp);
      document.addEventListener("keydown", onEscapeKey);
      emit("resize-start", {
        blockId: props.imageElement.getAttribute("data-sd-block-id"),
        initialWidth: rect.width,
        initialHeight: rect.height
      });
    }
    function throttle2(func, limit) {
      let inThrottle;
      let timeoutId = null;
      const throttled = function(...args) {
        if (!inThrottle) {
          func.apply(this, args);
          inThrottle = true;
          timeoutId = setTimeout(() => {
            inThrottle = false;
            timeoutId = null;
          }, limit);
        }
      };
      const cancel = () => {
        if (timeoutId !== null) {
          clearTimeout(timeoutId);
          timeoutId = null;
          inThrottle = false;
        }
      };
      return { throttled, cancel };
    }
    const mouseMoveThrottle = throttle2((event) => {
      if (!dragState.value || !imageMetadata.value) return;
      let deltaX = event.clientX - dragState.value.initialX;
      let deltaY = event.clientY - dragState.value.initialY;
      const handle = dragState.value.handle;
      if (handle === "nw") {
        deltaX = -deltaX;
        deltaY = -deltaY;
      } else if (handle === "ne") {
        deltaY = -deltaY;
      } else if (handle === "sw") {
        deltaX = -deltaX;
      }
      const scaleX = (dragState.value.initialWidth + deltaX) / dragState.value.initialWidth;
      const scaleY = (dragState.value.initialHeight + deltaY) / dragState.value.initialHeight;
      const scale = Math.max(scaleX, scaleY);
      let newWidth = dragState.value.initialWidth * scale;
      let newHeight = dragState.value.initialHeight * scale;
      const minWidth = imageMetadata.value.minWidth;
      const minHeight = imageMetadata.value.minHeight;
      const maxWidth = imageMetadata.value.maxWidth;
      const maxHeight = imageMetadata.value.maxHeight;
      if (newWidth < minWidth) {
        newWidth = minWidth;
        newHeight = newWidth / dragState.value.aspectRatio;
      }
      if (newHeight < minHeight) {
        newHeight = minHeight;
        newWidth = newHeight * dragState.value.aspectRatio;
      }
      if (newWidth > maxWidth) {
        newWidth = maxWidth;
        newHeight = newWidth / dragState.value.aspectRatio;
      }
      if (newHeight > maxHeight) {
        newHeight = maxHeight;
        newWidth = newHeight * dragState.value.aspectRatio;
      }
      dragState.value.constrainedWidth = newWidth;
      dragState.value.constrainedHeight = newHeight;
      emit("resize-move", {
        blockId: props.imageElement.getAttribute("data-sd-block-id"),
        width: newWidth,
        height: newHeight
      });
    }, MOUSE_MOVE_THROTTLE_MS);
    const onDocumentMouseMove2 = mouseMoveThrottle.throttled;
    function onEscapeKey(event) {
      if (event.key === "Escape" && dragState.value) {
        forcedCleanup.value = true;
        onDocumentMouseUp(new MouseEvent("mouseup"));
        forcedCleanup.value = false;
      }
    }
    function onDocumentMouseUp(event) {
      if (!dragState.value) return;
      const finalWidth = dragState.value.constrainedWidth;
      const finalHeight = dragState.value.constrainedHeight;
      const blockId = props.imageElement?.getAttribute("data-sd-block-id");
      document.removeEventListener("mousemove", onDocumentMouseMove2);
      document.removeEventListener("mouseup", onDocumentMouseUp);
      document.removeEventListener("keydown", onEscapeKey);
      if (props.editor?.view) {
        const pmView = props.editor.view.dom;
        if (pmView && pmView.style) {
          pmView.style.pointerEvents = "auto";
        }
      }
      const widthDelta = Math.abs(finalWidth - dragState.value.initialWidth);
      const heightDelta = Math.abs(finalHeight - dragState.value.initialHeight);
      if (!forcedCleanup.value && (widthDelta > DIMENSION_CHANGE_THRESHOLD_PX || heightDelta > DIMENSION_CHANGE_THRESHOLD_PX)) {
        dispatchResizeTransaction(blockId, finalWidth, finalHeight);
        emit("resize-end", {
          blockId,
          finalWidth,
          finalHeight
        });
      }
      dragState.value = null;
    }
    function dispatchResizeTransaction(blockId, newWidth, newHeight) {
      if (!isValidEditor(props.editor) || !props.imageElement) {
        return;
      }
      if (!Number.isFinite(newWidth) || !Number.isFinite(newHeight) || newWidth <= 0 || newHeight <= 0) {
        emit("resize-error", {
          blockId,
          error: "Invalid dimensions: width and height must be positive finite numbers"
        });
        return;
      }
      try {
        const { state, dispatch } = props.editor.view;
        const tr = state.tr;
        const pmStartAttr = props.imageElement.getAttribute("data-pm-start");
        if (!pmStartAttr) {
          emit("resize-error", {
            blockId,
            error: "Image position marker (data-pm-start) not found"
          });
          return;
        }
        const imagePos = parseInt(pmStartAttr, 10);
        if (!Number.isFinite(imagePos) || imagePos < 0) {
          emit("resize-error", {
            blockId,
            error: "Invalid image position marker"
          });
          return;
        }
        const imageNode = state.doc.nodeAt(imagePos);
        if (!imageNode || imageNode.type.name !== "image") {
          emit("resize-error", {
            blockId,
            error: "Invalid image node at position"
          });
          return;
        }
        const newAttrs = {
          ...imageNode.attrs,
          size: {
            width: Math.round(newWidth),
            height: Math.round(newHeight)
          }
        };
        tr.setNodeMarkup(imagePos, null, newAttrs);
        dispatch(tr);
        if (blockId && blockId.trim()) {
          measureCache.invalidate([blockId]);
        }
        emit("resize-success", { blockId, newWidth, newHeight });
      } catch (error) {
        emit("resize-error", {
          blockId,
          error: error instanceof Error ? error.message : String(error)
        });
      }
    }
    vue.watch(
      () => props.imageElement,
      () => {
        parseImageMetadata();
      },
      { immediate: true }
    );
    vue.watch(
      () => props.visible,
      (visible) => {
        if (visible) {
          parseImageMetadata();
        } else {
          if (dragState.value) {
            forcedCleanup.value = true;
            onDocumentMouseUp(new MouseEvent("mouseup"));
            forcedCleanup.value = false;
          }
        }
      }
    );
    vue.onBeforeUnmount(() => {
      mouseMoveThrottle.cancel();
      if (dragState.value) {
        document.removeEventListener("mousemove", onDocumentMouseMove2);
        document.removeEventListener("mouseup", onDocumentMouseUp);
        document.removeEventListener("keydown", onEscapeKey);
        if (props.editor?.view?.dom) {
          props.editor.view.dom.style.pointerEvents = "auto";
        }
      }
    });
    return (_ctx, _cache) => {
      return __props.visible && imageMetadata.value ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: "superdoc-image-resize-overlay",
        style: vue.normalizeStyle(overlayStyle.value),
        onMousedown: _cache[0] || (_cache[0] = vue.withModifiers(() => {
        }, ["stop"]))
      }, [
        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(resizeHandles.value, (handle) => {
          return vue.openBlock(), vue.createElementBlock("div", {
            key: handle.position,
            class: vue.normalizeClass(["resize-handle", {
              "resize-handle--active": dragState.value && dragState.value.handle === handle.position,
              [`resize-handle--${handle.position}`]: true
            }]),
            style: vue.normalizeStyle(handle.style),
            "data-handle-position": handle.position,
            onMousedown: ($event) => onHandleMouseDown($event, handle.position)
          }, null, 46, _hoisted_1$2);
        }), 128)),
        dragState.value ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: "resize-guideline",
          style: vue.normalizeStyle(guidelineStyle.value)
        }, null, 4)) : vue.createCommentVNode("", true)
      ], 36)) : vue.createCommentVNode("", true);
    };
  }
};
const ImageResizeOverlay = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-3ddf7f34"]]);
const LINK_CLICK_DEBOUNCE_MS = 300;
const CURSOR_UPDATE_TIMEOUT_MS = 10;
const _sfc_main$2 = {
  __name: "LinkClickHandler",
  props: {
    editor: {
      type: Object,
      required: true
    },
    openPopover: {
      type: Function,
      required: true
    },
    closePopover: {
      type: Function,
      required: true
    },
    popoverVisible: {
      type: Boolean,
      default: false
    }
  },
  setup(__props) {
    const props = __props;
    let lastLinkClickTime = 0;
    const handleLinkClick = (event) => {
      const detail = event?.detail ?? {};
      const linkElement = detail.element;
      const now = Date.now();
      if (now - lastLinkClickTime < LINK_CLICK_DEBOUNCE_MS) {
        return;
      }
      lastLinkClickTime = now;
      if (props.popoverVisible) {
        props.closePopover();
        return;
      }
      if (!props.editor || !props.editor.state) {
        return;
      }
      const surface = getEditorSurfaceElement(props.editor);
      if (!surface) {
        return;
      }
      const pmStart = linkElement?.dataset?.pmStart;
      if (pmStart != null) {
        const pos = parseInt(pmStart, 10);
        const state = props.editor.state;
        const doc2 = state.doc;
        if (!isNaN(pos) && pos >= 0 && pos <= doc2.content.size) {
          const tr = state.tr.setSelection(superEditor_converter.TextSelection.create(doc2, pos));
          props.editor.dispatch(tr);
        } else {
          console.warn(`Invalid PM position from data-pm-start: ${pmStart}, falling back to coordinate-based positioning`);
          moveCursorToMouseEvent(detail, props.editor);
        }
      } else {
        moveCursorToMouseEvent(detail, props.editor);
      }
      setTimeout(() => {
        const currentState = props.editor.state;
        const $from = currentState.selection.$from;
        const linkMarkType = currentState.schema.marks.link;
        const nodeAfter = $from.nodeAfter;
        const nodeBefore = $from.nodeBefore;
        const marksOnNodeAfter = nodeAfter?.marks || [];
        const marksOnNodeBefore = nodeBefore?.marks || [];
        const linkOnNodeAfter = linkMarkType && marksOnNodeAfter.some((m2) => m2.type === linkMarkType);
        const linkOnNodeBefore = linkMarkType && marksOnNodeBefore.some((m2) => m2.type === linkMarkType);
        const hasLinkAdjacent = linkOnNodeAfter || linkOnNodeBefore;
        const hasLink = selectionHasNodeOrMark(currentState, "link", { requireEnds: true });
        if (hasLink || hasLinkAdjacent) {
          const surfaceRect = surface.getBoundingClientRect();
          if (!surfaceRect) return;
          props.openPopover(
            vue.markRaw(LinkInput),
            {
              showInput: true,
              editor: props.editor,
              closePopover: props.closePopover
            },
            {
              left: `${detail.clientX - surfaceRect.left}px`,
              top: `${detail.clientY - surfaceRect.top + 15}px`
            }
          );
        }
      }, CURSOR_UPDATE_TIMEOUT_MS);
    };
    let surfaceElement = null;
    vue.onMounted(() => {
      if (!props.editor) return;
      surfaceElement = getEditorSurfaceElement(props.editor);
      if (surfaceElement) {
        surfaceElement.addEventListener("superdoc-link-click", handleLinkClick);
      }
    });
    vue.onBeforeUnmount(() => {
      if (surfaceElement) {
        surfaceElement.removeEventListener("superdoc-link-click", handleLinkClick);
      }
    });
    return (_ctx, _cache) => {
      return null;
    };
  }
};
function adjustPaginationBreaks(editorElem, editor) {
  if (!editorElem.value || !editor?.value?.options?.scale || isHeadless(editor)) return;
  const zoom = editor.value.options.scale;
  const bounds = editorElem.value.getBoundingClientRect();
  const breakNodes = editorElem.value.querySelectorAll(".pagination-break-wrapper");
  let firstLeft;
  breakNodes.forEach((node) => {
    const nodeBounds = node.getBoundingClientRect();
    const left2 = (nodeBounds.left - bounds.left) / zoom * -1 + 1;
    if (!firstLeft) firstLeft = left2;
    if (left2 !== firstLeft) {
      const diff = left2 - firstLeft;
      node.style.transform = `translateX(${diff}px)`;
    }
  });
}
const _hoisted_1$1 = {
  key: 2,
  class: "placeholder-editor"
};
const _hoisted_2 = { class: "placeholder-title" };
const DOCX = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
const TABLE_RESIZE_HOVER_THRESHOLD = 8;
const TABLE_RESIZE_THROTTLE_MS = 16;
const _sfc_main$1 = /* @__PURE__ */ vue.defineComponent({
  __name: "SuperEditor",
  props: {
    documentId: {
      type: String,
      required: false
    },
    fileSource: {
      type: [File, Blob],
      required: false
    },
    state: {
      type: Object,
      required: false,
      default: () => null
    },
    options: {
      type: Object,
      required: false,
      default: () => ({})
    }
  },
  emits: ["editor-ready", "editor-click", "editor-keydown", "comments-loaded", "selection-update"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const props = __props;
    const editorReady = vue.ref(false);
    const editor = vue.shallowRef(null);
    const activeEditor = vue.computed(() => {
      if (editor.value && "editor" in editor.value && editor.value.editor) {
        return editor.value.editor;
      }
      return editor.value;
    });
    const contextMenuDisabled = vue.computed(() => {
      const active = activeEditor.value;
      return active?.options ? Boolean(active.options.disableContextMenu) : Boolean(props.options.disableContextMenu);
    });
    const isWebLayout = vue.computed(() => {
      return props.options.viewOptions?.layout === "web";
    });
    const rulersVisible = vue.ref(Boolean(props.options.rulers));
    const currentZoom = vue.ref(1);
    let zoomChangeHandler = null;
    vue.watch(
      () => props.options,
      (newOptions) => {
        const rulers = newOptions?.rulers;
        if (rulers && typeof rulers === "object" && "value" in rulers) {
          rulersVisible.value = Boolean(rulers.value);
        } else {
          rulersVisible.value = Boolean(rulers);
        }
      },
      { immediate: true, deep: true }
    );
    vue.watch(
      () => props.options?.rulerContainer,
      () => {
        vue.nextTick(() => {
          syncRulerOffset();
          setupRulerObservers();
        });
      },
      { immediate: true }
    );
    vue.watch(
      rulersVisible,
      (visible) => {
        vue.nextTick(() => {
          if (visible) {
            syncRulerOffset();
            setupRulerObservers();
          } else {
            rulerHostStyle.value = {};
            cleanupRulerObservers();
          }
        });
      },
      { immediate: true }
    );
    const containerStyle = vue.computed(() => {
      if (isWebLayout.value) {
        return {};
      }
      let maxWidth = 8.5 * 96;
      const ed = editor.value;
      if (ed && "getPages" in ed && typeof ed.getPages === "function") {
        const pages = ed.getPages();
        if (Array.isArray(pages) && pages.length > 0) {
          for (const page of pages) {
            if (page.size && typeof page.size.w === "number" && page.size.w > 0) {
              maxWidth = Math.max(maxWidth, page.size.w);
            }
          }
        }
      }
      if (maxWidth === 8.5 * 96 && ed && "getPageStyles" in ed && typeof ed.getPageStyles === "function") {
        const styles = ed.getPageStyles();
        if (styles && typeof styles === "object" && styles.pageSize && typeof styles.pageSize === "object" && typeof styles.pageSize.width === "number" && styles.pageSize.width > 0) {
          maxWidth = styles.pageSize.width * 96;
        }
      }
      const scaledWidth = maxWidth * currentZoom.value;
      return {
        minWidth: `${scaledWidth}px`
      };
    });
    const rulerHostStyle = vue.ref({});
    const rulerContainerEl = vue.ref(null);
    let editorResizeObserver = null;
    let rulerContainerResizeObserver = null;
    let layoutUpdatedHandler = null;
    const resolveRulerContainer = () => {
      const container = props.options?.rulerContainer;
      if (!container) return null;
      if (typeof container === "string") {
        const doc2 = editorWrapper.value?.ownerDocument ?? document;
        return doc2.querySelector(container);
      }
      return container instanceof HTMLElement ? container : null;
    };
    const getViewportRect2 = () => {
      const host = editorWrapper.value;
      if (!host) return null;
      const viewport2 = host.querySelector(".presentation-editor__viewport");
      const target = viewport2 ?? host;
      return target.getBoundingClientRect();
    };
    const syncRulerOffset = () => {
      if (!rulersVisible.value) {
        rulerHostStyle.value = {};
        return;
      }
      rulerContainerEl.value = resolveRulerContainer();
      if (!rulerContainerEl.value) {
        rulerHostStyle.value = {};
        return;
      }
      const viewportRect = getViewportRect2();
      if (!viewportRect) return;
      const hostRect = rulerContainerEl.value.getBoundingClientRect();
      const paddingLeft = Math.max(0, viewportRect.left - hostRect.left);
      const paddingRight = Math.max(0, hostRect.right - viewportRect.right);
      rulerHostStyle.value = {
        paddingLeft: `${paddingLeft}px`,
        paddingRight: `${paddingRight}px`
      };
    };
    const cleanupRulerObservers = () => {
      if (editorResizeObserver) {
        editorResizeObserver.disconnect();
        editorResizeObserver = null;
      }
      if (rulerContainerResizeObserver) {
        rulerContainerResizeObserver.disconnect();
        rulerContainerResizeObserver = null;
      }
    };
    const setupRulerObservers = () => {
      cleanupRulerObservers();
      if (typeof ResizeObserver === "undefined") return;
      const viewportHost = editorWrapper.value;
      const rulerHost = resolveRulerContainer();
      if (viewportHost) {
        editorResizeObserver = new ResizeObserver(() => syncRulerOffset());
        editorResizeObserver.observe(viewportHost);
      }
      if (rulerHost) {
        rulerContainerResizeObserver = new ResizeObserver(() => syncRulerOffset());
        rulerContainerResizeObserver.observe(rulerHost);
      }
    };
    const message = useMessage();
    const editorWrapper = vue.ref(null);
    const editorElem = vue.ref(null);
    const fileSource = vue.ref(null);
    const popoverControls = vue.reactive({
      visible: false,
      position: { left: "0px", top: "0px" },
      component: null,
      props: {}
    });
    const closePopover = () => {
      popoverControls.visible = false;
      popoverControls.component = null;
      popoverControls.props = {};
      activeEditor.value?.view?.focus();
    };
    const openPopover = (component, props2, position) => {
      popoverControls.component = component;
      popoverControls.props = props2;
      popoverControls.position = position;
      popoverControls.visible = true;
    };
    const tableResizeState = vue.reactive({
      visible: false,
      tableElement: null
    });
    const imageResizeState = vue.reactive({
      visible: false,
      imageElement: null,
      blockId: null
    });
    const selectedImageState = vue.reactive({
      element: null,
      blockId: null,
      pmStart: null
    });
    const getEditorZoom = () => {
      const active = activeEditor.value;
      if (active && typeof active.zoom === "number") {
        return active.zoom;
      }
      if (active?.presentationEditor && typeof active.presentationEditor.zoom === "number") {
        return active.presentationEditor.zoom;
      }
      console.warn(
        "[SuperEditor] getEditorZoom: Unable to retrieve zoom from editor instance, using fallback value of 1. This may indicate the editor is not fully initialized or is not a PresentationEditor instance."
      );
      return 1;
    };
    let lastUpdateTableResizeTimestamp = 0;
    const isNearColumnBoundary = (event, tableElement) => {
      if (!event || typeof event.clientX !== "number" || typeof event.clientY !== "number") {
        console.warn("[isNearColumnBoundary] Invalid event: missing clientX or clientY", event);
        return false;
      }
      if (!tableElement || !(tableElement instanceof HTMLElement)) {
        console.warn("[isNearColumnBoundary] Invalid tableElement: not an HTMLElement", tableElement);
        return false;
      }
      const boundariesAttr = tableElement.getAttribute("data-table-boundaries");
      if (!boundariesAttr) return false;
      try {
        const metadata = JSON.parse(boundariesAttr);
        if (!metadata.columns || !Array.isArray(metadata.columns)) return false;
        const zoom = getEditorZoom();
        const tableRect = tableElement.getBoundingClientRect();
        const mouseXScreen = event.clientX - tableRect.left;
        const mouseYScreen = event.clientY - tableRect.top;
        for (let i = 0; i < metadata.columns.length; i++) {
          const col = metadata.columns[i];
          if (!col || typeof col !== "object") {
            console.warn(`[isNearColumnBoundary] Invalid column at index ${i}: not an object`, col);
            continue;
          }
          if (typeof col.x !== "number" || !Number.isFinite(col.x)) {
            console.warn(`[isNearColumnBoundary] Invalid column.x at index ${i}:`, col.x);
            continue;
          }
          if (typeof col.w !== "number" || !Number.isFinite(col.w) || col.w <= 0) {
            console.warn(`[isNearColumnBoundary] Invalid column.w at index ${i}:`, col.w);
            continue;
          }
          const boundaryXScreen = (col.x + col.w) * zoom;
          if (Math.abs(mouseXScreen - boundaryXScreen) <= TABLE_RESIZE_HOVER_THRESHOLD) {
            const segmentColIndex = i + 1;
            const segments = metadata.segments?.[segmentColIndex];
            if (!segments || segments.length === 0) {
              if (i === metadata.columns.length - 1) return true;
              continue;
            }
            for (const seg of segments) {
              const segTopScreen = (seg.y || 0) * zoom;
              const segBottomScreen = seg.h != null ? segTopScreen + seg.h * zoom : tableRect.height;
              if (mouseYScreen >= segTopScreen && mouseYScreen <= segBottomScreen) {
                return true;
              }
            }
          }
        }
        if (Math.abs(mouseXScreen) <= TABLE_RESIZE_HOVER_THRESHOLD) {
          return true;
        }
        return false;
      } catch (e) {
        console.warn("[isNearColumnBoundary] Failed to parse table boundary metadata:", e);
        return false;
      }
    };
    const updateTableResizeOverlay = (event) => {
      const now = Date.now();
      if (now - lastUpdateTableResizeTimestamp < TABLE_RESIZE_THROTTLE_MS) {
        return;
      }
      lastUpdateTableResizeTimestamp = now;
      if (!editorElem.value) return;
      let target = event.target;
      while (target && target !== editorElem.value) {
        if (target.classList?.contains("superdoc-table-resize-overlay")) {
          return;
        }
        if (target.classList?.contains("superdoc-table-fragment") && target.hasAttribute("data-table-boundaries")) {
          if (isNearColumnBoundary(event, target)) {
            tableResizeState.visible = true;
            tableResizeState.tableElement = target;
          } else {
            tableResizeState.visible = false;
            tableResizeState.tableElement = null;
          }
          return;
        }
        target = target.parentElement;
      }
      tableResizeState.visible = false;
      tableResizeState.tableElement = null;
    };
    const hideTableResizeOverlay = () => {
      tableResizeState.visible = false;
      tableResizeState.tableElement = null;
    };
    const updateImageResizeOverlay = (event) => {
      if (!editorElem.value) return;
      if (!(event.target instanceof Element)) {
        imageResizeState.visible = false;
        imageResizeState.imageElement = null;
        imageResizeState.blockId = null;
        return;
      }
      let target = event.target;
      while (target && target !== document.body) {
        if (target.classList?.contains("superdoc-image-resize-overlay") || target.closest?.(".superdoc-image-resize-overlay")) {
          return;
        }
        if (target.classList?.contains("superdoc-image-fragment") && target.hasAttribute("data-image-metadata")) {
          imageResizeState.visible = true;
          imageResizeState.imageElement = target;
          imageResizeState.blockId = target.getAttribute("data-sd-block-id");
          return;
        }
        if (target.classList?.contains("superdoc-inline-image") && target.hasAttribute("data-image-metadata")) {
          imageResizeState.visible = true;
          imageResizeState.imageElement = target;
          imageResizeState.blockId = target.getAttribute("data-pm-start");
          return;
        }
        target = target.parentElement;
      }
      imageResizeState.visible = false;
      imageResizeState.imageElement = null;
      imageResizeState.blockId = null;
    };
    const hideImageResizeOverlay = () => {
      imageResizeState.visible = false;
      imageResizeState.imageElement = null;
      imageResizeState.blockId = null;
    };
    const clearSelectedImage = () => {
      if (selectedImageState.element?.classList?.contains("superdoc-image-selected")) {
        selectedImageState.element.classList.remove("superdoc-image-selected");
      }
      selectedImageState.element = null;
      selectedImageState.blockId = null;
      selectedImageState.pmStart = null;
    };
    const setSelectedImage = (element, blockId, pmStart) => {
      if (selectedImageState.element && selectedImageState.element !== element) {
        selectedImageState.element.classList.remove("superdoc-image-selected");
      }
      if (element && element.classList) {
        element.classList.add("superdoc-image-selected");
        selectedImageState.element = element;
        selectedImageState.blockId = blockId ?? null;
        selectedImageState.pmStart = typeof pmStart === "number" ? pmStart : null;
      } else {
        clearSelectedImage();
      }
    };
    const handleOverlayUpdates = (event) => {
      updateTableResizeOverlay(event);
      updateImageResizeOverlay(event);
    };
    const handleOverlayHide = () => {
      hideTableResizeOverlay();
      hideImageResizeOverlay();
    };
    let dataPollTimeout;
    const stopPolling = () => {
      clearTimeout(dataPollTimeout);
    };
    const pollForMetaMapData = (ydoc, retries = 10, interval = 500) => {
      const metaMap = ydoc.getMap("meta");
      const checkData = () => {
        const docx = metaMap.get("docx");
        if (docx) {
          stopPolling();
          initEditor({ content: docx });
        } else if (retries > 0) {
          dataPollTimeout = setTimeout(checkData, interval);
          retries--;
        } else {
          console.warn("Failed to load docx data from meta map.");
        }
      };
      checkData();
    };
    const setDefaultBlankFile = async () => {
      fileSource.value = await getFileObject(blankDocx.BlankDOCX, "blank.docx", DOCX);
    };
    const loadNewFileData = async () => {
      if (!fileSource.value) {
        fileSource.value = props.fileSource;
      }
      if (!fileSource.value || fileSource.value.type !== DOCX) {
        await setDefaultBlankFile();
      }
      try {
        const [docx, media, mediaFiles, fonts] = await Editor.loadXmlData(fileSource.value);
        return { content: docx, media, mediaFiles, fonts };
      } catch (err) {
        console.debug("[SuperDoc] Error loading file:", err);
        if (typeof props.options.onException === "function") {
          props.options.onException({ error: err, editor: null });
        }
      }
    };
    const initializeData = async () => {
      if (props.fileSource) {
        let fileData = await loadNewFileData();
        if (!fileData) {
          message.error("Unable to load the file. Please verify the .docx is valid and not password protected.");
          await setDefaultBlankFile();
          fileData = await loadNewFileData();
        }
        return initEditor(fileData);
      } else if (props.options.ydoc && props.options.collaborationProvider) {
        delete props.options.content;
        const ydoc = props.options.ydoc;
        const provider = props.options.collaborationProvider;
        const waitForSync = () => {
          if (provider.isSynced || provider.synced) return Promise.resolve();
          return new Promise((resolve) => {
            const onSync = (synced) => {
              if (synced === false) return;
              provider.off("synced", onSync);
              provider.off("sync", onSync);
              resolve();
            };
            provider.on("synced", onSync);
            provider.on("sync", onSync);
          });
        };
        waitForSync().then(async () => {
          const metaMap = ydoc.getMap("meta");
          if (metaMap.has("docx")) {
            pollForMetaMapData(ydoc);
          } else {
            props.options.isNewFile = true;
            const fileData = await loadNewFileData();
            if (fileData) initEditor(fileData);
          }
        });
      }
    };
    const getExtensions = () => getStarterExtensions();
    const initEditor = async ({ content, media = {}, mediaFiles = {}, fonts = {} } = {}) => {
      if (!editorElem.value) return;
      const { editorCtor, ...editorOptions } = props.options || {};
      const EditorCtor = editorCtor ?? Editor;
      clearSelectedImage();
      editor.value = new EditorCtor({
        mode: "docx",
        element: editorElem.value,
        fileSource: fileSource.value,
        extensions: getExtensions(),
        documentId: props.documentId,
        content,
        media,
        mediaFiles,
        fonts,
        ...editorOptions
      });
      emit("editor-ready", {
        editor: activeEditor.value,
        presentationEditor: editor.value instanceof PresentationEditor ? editor.value : null
      });
      if (editor.value instanceof PresentationEditor) {
        const presentationEditor = editor.value;
        presentationEditor.on("imageSelected", ({ element, blockId, pmStart }) => {
          setSelectedImage(element, blockId ?? null, pmStart);
        });
        presentationEditor.on("imageDeselected", () => {
          clearSelectedImage();
        });
        layoutUpdatedHandler = () => {
          if (imageResizeState.visible && imageResizeState.blockId) {
            const escapedBlockId = CSS.escape(imageResizeState.blockId);
            const newElement = editorElem.value?.querySelector(
              `.superdoc-image-fragment[data-sd-block-id="${escapedBlockId}"]`
            );
            if (newElement) {
              imageResizeState.imageElement = newElement;
            } else {
              imageResizeState.visible = false;
              imageResizeState.imageElement = null;
              imageResizeState.blockId = null;
            }
          }
          if (selectedImageState.blockId) {
            const escapedBlockId = CSS.escape(selectedImageState.blockId);
            const refreshed = editorElem.value?.querySelector(
              `.superdoc-image-fragment[data-sd-block-id="${escapedBlockId}"]`
            );
            if (refreshed) {
              setSelectedImage(refreshed, selectedImageState.blockId, selectedImageState.pmStart);
            } else {
              if (selectedImageState.pmStart != null) {
                const pmSelector = `.superdoc-image-fragment[data-pm-start="${selectedImageState.pmStart}"], .superdoc-inline-image[data-pm-start="${selectedImageState.pmStart}"]`;
                const pmElement = editorElem.value?.querySelector(pmSelector);
                if (pmElement) {
                  setSelectedImage(pmElement, selectedImageState.blockId, selectedImageState.pmStart);
                  return;
                }
              }
              clearSelectedImage();
            }
          }
          vue.nextTick(() => syncRulerOffset());
        };
        presentationEditor.on("layoutUpdated", layoutUpdatedHandler);
        zoomChangeHandler = ({ zoom }) => {
          currentZoom.value = zoom;
          vue.nextTick(() => syncRulerOffset());
        };
        presentationEditor.on("zoomChange", zoomChangeHandler);
        if (typeof presentationEditor.zoom === "number") {
          currentZoom.value = presentationEditor.zoom;
          vue.nextTick(() => syncRulerOffset());
        }
      }
      editor.value.on("paginationUpdate", () => {
        const base2 = activeEditor.value;
        if (isHeadless(base2)) return;
        const paginationTarget = editor.value?.editor ? { value: base2 } : editor;
        adjustPaginationBreaks(editorElem, paginationTarget);
      });
      editor.value.on("collaborationReady", () => {
        setTimeout(() => {
          editorReady.value = true;
        }, 150);
      });
    };
    const handleSuperEditorKeydown = (event) => {
      if ((event.metaKey || event.ctrlKey) && event.altKey && event.shiftKey) {
        if (event.code === "KeyM") {
          const toolbar = document.querySelector(".superdoc-toolbar");
          if (toolbar) {
            toolbar.setAttribute("tabindex", "0");
            toolbar.focus();
          }
        }
      }
      if ((event.metaKey || event.ctrlKey) && !event.shiftKey && !event.altKey && (event.key === "k" || event.key === "K")) {
        event.preventDefault();
        const base2 = activeEditor.value;
        if (!base2) return;
        const view = base2.view;
        const { state } = view;
        const container = editorWrapper.value;
        if (!container) return;
        const containerRect = container.getBoundingClientRect();
        const cursorCoords = view.coordsAtPos(state.selection.head);
        const left2 = `${cursorCoords.left - containerRect.left}px`;
        const top2 = `${cursorCoords.bottom - containerRect.top + 6}px`;
        openPopover(vue.markRaw(LinkInput), {}, { left: left2, top: top2 });
      }
      emit("editor-keydown", { editor: activeEditor.value });
    };
    const handleSuperEditorClick = (event) => {
      emit("editor-click", { editor: activeEditor.value });
      let pmElement = editorElem.value?.querySelector(".ProseMirror");
      const base2 = activeEditor.value;
      if (!pmElement || !base2) {
        return;
      }
      let isInsideEditor = pmElement.contains(event.target);
      if (!isInsideEditor && base2.isEditable) {
        base2.view?.focus();
      }
      if (isInsideEditor && base2.isEditable) {
        checkNodeSpecificClicks(base2, event, popoverControls);
      }
      updateTableResizeOverlay(event);
    };
    vue.onMounted(() => {
      initializeData();
      if (props.options?.suppressSkeletonLoader || !props.options?.collaborationProvider) editorReady.value = true;
      window.addEventListener("resize", syncRulerOffset, { passive: true });
      vue.nextTick(() => {
        syncRulerOffset();
        setupRulerObservers();
      });
    });
    const handleMarginClick = (event) => {
      if (event.button !== 0) {
        return;
      }
      if (event.ctrlKey && isMacOS()) {
        return;
      }
      const target = event.target;
      if (target?.classList?.contains("ProseMirror")) return;
      if (target?.closest?.(".presentation-editor, .superdoc-layout")) {
        return;
      }
      onMarginClickCursorChange(event, activeEditor.value);
    };
    const handleMarginChange = ({ side, value }) => {
      const base2 = activeEditor.value;
      if (!base2) return;
      const payload = side === "left" ? { leftInches: value } : side === "right" ? { rightInches: value } : side === "top" ? { topInches: value } : side === "bottom" ? { bottomInches: value } : {};
      const didUpdateSection = typeof base2.commands?.setSectionPageMarginsAtSelection === "function" ? base2.commands.setSectionPageMarginsAtSelection(payload) : false;
      if (!didUpdateSection) {
        const pageStyles2 = base2.getPageStyles();
        const { pageMargins } = pageStyles2;
        const update = { ...pageMargins, [side]: value };
        base2?.updatePageStyle({ pageMargins: update });
      }
    };
    vue.onBeforeUnmount(() => {
      stopPolling();
      clearSelectedImage();
      if (editor.value instanceof PresentationEditor && zoomChangeHandler) {
        editor.value.off("zoomChange", zoomChangeHandler);
        zoomChangeHandler = null;
      }
      if (editor.value instanceof PresentationEditor && layoutUpdatedHandler) {
        editor.value.off("layoutUpdated", layoutUpdatedHandler);
        layoutUpdatedHandler = null;
      }
      cleanupRulerObservers();
      window.removeEventListener("resize", syncRulerOffset);
      editor.value?.destroy();
      editor.value = null;
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: vue.normalizeClass(["super-editor-container", { "web-layout": isWebLayout.value }]),
        style: vue.normalizeStyle(containerStyle.value)
      }, [
        __props.options.rulerContainer && rulersVisible.value && !!activeEditor.value ? (vue.openBlock(), vue.createBlock(vue.Teleport, {
          key: 0,
          to: __props.options.rulerContainer
        }, [
          vue.createBaseVNode("div", {
            class: "ruler-host",
            style: vue.normalizeStyle(rulerHostStyle.value)
          }, [
            vue.createVNode(Ruler, {
              class: "ruler superdoc-ruler",
              editor: activeEditor.value,
              onMarginChange: handleMarginChange
            }, null, 8, ["editor"])
          ], 4)
        ], 8, ["to"])) : rulersVisible.value && !!activeEditor.value ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 1,
          class: "ruler-host",
          style: vue.normalizeStyle(rulerHostStyle.value)
        }, [
          vue.createVNode(Ruler, {
            class: "ruler",
            editor: activeEditor.value,
            onMarginChange: handleMarginChange
          }, null, 8, ["editor"])
        ], 4)) : vue.createCommentVNode("", true),
        vue.createBaseVNode("div", {
          class: "super-editor",
          ref_key: "editorWrapper",
          ref: editorWrapper,
          onKeydown: handleSuperEditorKeydown,
          onClick: handleSuperEditorClick,
          onMousedown: handleMarginClick,
          onMousemove: handleOverlayUpdates,
          onMouseleave: handleOverlayHide
        }, [
          vue.createBaseVNode("div", {
            ref_key: "editorElem",
            ref: editorElem,
            class: "editor-element super-editor__element",
            role: "presentation"
          }, null, 512),
          !contextMenuDisabled.value && editorReady.value && activeEditor.value ? (vue.openBlock(), vue.createBlock(_sfc_main$7, {
            key: 0,
            editor: activeEditor.value,
            popoverControls,
            openPopover,
            closePopover
          }, null, 8, ["editor", "popoverControls"])) : vue.createCommentVNode("", true),
          editorReady.value && activeEditor.value ? (vue.openBlock(), vue.createBlock(_sfc_main$2, {
            key: 1,
            editor: activeEditor.value,
            openPopover,
            closePopover,
            popoverVisible: popoverControls.visible
          }, null, 8, ["editor", "popoverVisible"])) : vue.createCommentVNode("", true),
          editorReady.value && activeEditor.value ? (vue.openBlock(), vue.createBlock(TableResizeOverlay, {
            key: 2,
            editor: activeEditor.value,
            visible: tableResizeState.visible,
            tableElement: tableResizeState.tableElement
          }, null, 8, ["editor", "visible", "tableElement"])) : vue.createCommentVNode("", true),
          editorReady.value && activeEditor.value ? (vue.openBlock(), vue.createBlock(ImageResizeOverlay, {
            key: 3,
            editor: activeEditor.value,
            visible: imageResizeState.visible,
            imageElement: imageResizeState.imageElement
          }, null, 8, ["editor", "visible", "imageElement"])) : vue.createCommentVNode("", true)
        ], 544),
        !editorReady.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$1, [
          vue.createBaseVNode("div", _hoisted_2, [
            vue.createVNode(vue.unref(NSkeleton), {
              text: "",
              style: { "width": "60%" }
            })
          ]),
          vue.createVNode(vue.unref(NSkeleton), {
            text: "",
            repeat: 6
          }),
          vue.createVNode(vue.unref(NSkeleton), {
            text: "",
            style: { "width": "60%" }
          }),
          vue.createVNode(vue.unref(NSkeleton), {
            text: "",
            repeat: 6,
            style: { "width": "30%", "display": "block", "margin": "20px" }
          }),
          vue.createVNode(vue.unref(NSkeleton), {
            text: "",
            style: { "width": "60%" }
          }),
          vue.createVNode(vue.unref(NSkeleton), {
            text: "",
            repeat: 5
          }),
          vue.createVNode(vue.unref(NSkeleton), {
            text: "",
            style: { "width": "30%" }
          }),
          vue.createVNode(vue.unref(NSkeleton), {
            text: "",
            style: { "margin-top": "50px" }
          }),
          vue.createVNode(vue.unref(NSkeleton), {
            text: "",
            repeat: 6
          }),
          vue.createVNode(vue.unref(NSkeleton), {
            text: "",
            style: { "width": "70%" }
          })
        ])) : vue.createCommentVNode("", true),
        activeEditor.value ? (vue.openBlock(), vue.createBlock(GenericPopover, {
          key: 3,
          editor: activeEditor.value,
          visible: popoverControls.visible,
          position: popoverControls.position,
          onClose: closePopover
        }, {
          default: vue.withCtx(() => [
            (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(popoverControls.component), vue.normalizeProps(vue.guardReactiveProps({ ...popoverControls.props, editor: activeEditor.value, closePopover })), null, 16))
          ]),
          _: 1
        }, 8, ["editor", "visible", "position"])) : vue.createCommentVNode("", true)
      ], 6);
    };
  }
});
const SuperEditor = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-95e47413"]]);
const _hoisted_1 = ["innerHTML"];
const _sfc_main = {
  __name: "SuperInput",
  props: {
    modelValue: {
      type: String
    },
    placeholder: {
      type: String,
      required: false,
      default: "Type something..."
    },
    options: {
      type: Object,
      required: false,
      default: () => ({})
    },
    users: {
      type: Array,
      required: false,
      default: () => []
    }
  },
  emits: ["update:modelValue", "focus", "blur"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const props = __props;
    const editor = vue.shallowRef();
    const editorElem = vue.ref(null);
    const isFocused = vue.ref(false);
    const onTransaction = ({ editor: editor2, transaction }) => {
      const contents = editor2.getHTML();
      emit("update:modelValue", contents);
    };
    const onFocus = ({ editor: editor2, transaction }) => {
      isFocused.value = true;
      updateUsersState();
      emit("focus", { editor: editor2, transaction });
    };
    const onBlur = ({ editor: editor2, transaction }) => {
      isFocused.value = false;
      emit("blur", { editor: editor2, transaction });
    };
    const initEditor = async () => {
      Placeholder.options.placeholder = props.placeholder || "Type something...";
      props.options.onTransaction = onTransaction;
      props.options.onFocus = onFocus;
      props.options.onBlur = onBlur;
      editor.value = new Editor({
        mode: "text",
        content: document.getElementById("currentContent"),
        element: editorElem.value,
        extensions: getRichTextExtensions(),
        users: props.users,
        ...props.options
      });
    };
    const handleFocus = () => {
      isFocused.value = true;
      editor.value?.view?.focus();
    };
    const updateUsersState = () => {
      editor.value?.setOptions({ users: props.users });
    };
    vue.onMounted(() => {
      initEditor();
    });
    vue.onBeforeUnmount(() => {
      editor.value?.destroy();
      editor.value = null;
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: vue.normalizeClass(["super-editor super-input", { "super-input-active": isFocused.value }]),
        onClick: vue.withModifiers(handleFocus, ["stop", "prevent"])
      }, [
        vue.createBaseVNode("div", {
          id: "currentContent",
          style: { "display": "none" },
          innerHTML: __props.modelValue
        }, null, 8, _hoisted_1),
        vue.createBaseVNode("div", {
          ref_key: "editorElem",
          ref: editorElem,
          class: "editor-element super-editor__element"
        }, null, 512)
      ], 2);
    };
  }
};
const SuperInput = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-a1482023"]]);
const Extensions = {
  Node: Node$1,
  Attribute,
  Extension,
  Mark,
  //
  Plugin: superEditor_converter.Plugin,
  PluginKey: superEditor_converter.PluginKey,
  Decoration,
  DecorationSet
};
exports.AIWriter = AIWriter;
exports.AnnotatorHelpers = AnnotatorHelpers;
exports.BIT8 = BIT8;
exports.BITS7 = BITS7;
exports.CommentsPluginKey = CommentsPluginKey;
exports.Editor = Editor;
exports.Extensions = Extensions;
exports.MAX_SAFE_INTEGER = MAX_SAFE_INTEGER$2;
exports.Mark = Mark;
exports.NConfigProvider = NConfigProvider;
exports.NDropdown = NDropdown;
exports.Node = Node$1;
exports.PresentationEditor = PresentationEditor;
exports.SectionHelpers = SectionHelpers;
exports.SuperEditor = SuperEditor;
exports.SuperInput = SuperInput;
exports.SuperToolbar = SuperToolbar;
exports.Toolbar = Toolbar;
exports.TrackChangesBasePluginKey = TrackChangesBasePluginKey;
exports._export_sfc = _export_sfc;
exports._sfc_main = _sfc_main$7;
exports.c = c$1;
exports.cB = cB;
exports.cE = cE;
exports.cM = cM;
exports.cNotM = cNotM;
exports.call = call;
exports.caretDownIconSvg = caretDownIconSvg;
exports.changeColor = changeColor;
exports.checkIconSvg = checkIconSvg$1;
exports.commentIconSvg = commentIconSvg;
exports.comments_module_events = comments_module_events;
exports.commonVariables = commonVariables$2;
exports.configProviderInjectionKey = configProviderInjectionKey;
exports.create = create$1;
exports.create$1 = create;
exports.create$2 = create$2;
exports.createEncoder = createEncoder;
exports.createId = createId;
exports.createInjectionKey = createInjectionKey;
exports.createKey = createKey;
exports.createUint8ArrayFromArrayBuffer = createUint8ArrayFromArrayBuffer;
exports.cssrAnchorMetaName = cssrAnchorMetaName;
exports.derived = derived;
exports.ellipsisVerticalSvg = ellipsisVerticalSvg;
exports.equalityDeep = equalityDeep;
exports.fadeInTransition = fadeInTransition;
exports.floor = floor;
exports.from = from2;
exports.fromBase64 = fromBase64;
exports.getActiveFormatting = getActiveFormatting;
exports.getAllowedImageDimensions = getAllowedImageDimensions;
exports.getFileObject = getFileObject;
exports.getMarksFromSelection = getMarksFromSelection;
exports.getRichTextExtensions = getRichTextExtensions;
exports.getStarterExtensions = getStarterExtensions;
exports.getTrackChanges = getTrackChanges;
exports.globalStyle = globalStyle;
exports.helpers = helpers;
exports.index = index$1;
exports.index$1 = index;
exports.insideModal = insideModal;
exports.insidePopover = insidePopover;
exports.isMounted = isMounted;
exports.isNode = isNode;
exports.length = length$1;
exports.map = map$1;
exports.messageApiInjectionKey = messageApiInjectionKey;
exports.messageProviderInjectionKey = messageProviderInjectionKey;
exports.min = min$1;
exports.offChange = offChange;
exports.on = on;
exports.onChange = onChange;
exports.pow = pow;
exports.pxfy = pxfy;
exports.render = render;
exports.resolveWrappedSlot = resolveWrappedSlot;
exports.setIfUndefined = setIfUndefined;
exports.throwError = throwError;
exports.toBase64 = toBase64;
exports.toString = toString;
exports.toUint8Array = toUint8Array;
exports.useCompitable = useCompitable;
exports.useConfig = useConfig;
exports.useMemo = useMemo;
exports.useMergedState = useMergedState;
exports.useRtl = useRtl;
exports.useSsrAdapter = useSsrAdapter;
exports.useTheme = useTheme;
exports.useThemeClass = useThemeClass;
exports.vClickOutside = vClickOutside;
exports.varStorage = varStorage;
exports.warnOnce = warnOnce;
exports.writeVarString = writeVarString;
exports.writeVarUint = writeVarUint;
exports.writeVarUint8Array = writeVarUint8Array;
exports.xmarkIconSvg = xmarkIconSvg;

var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _a, _CommandService_instances, dispatchWithFallback_fn, _b, _DocxExporter_instances, generate_xml_as_list_fn, replaceSpecialCharacters_fn, generateXml_fn, _SuperConverter_instances, generateDocumentHash_fn, exportNumberingFile_fn, prepareCommentsXmlFilesForExport_fn, exportProcessHeadersFooters_fn, exportProcessNewRelationships_fn, exportProcessMediaFiles_fn;
function getExtensionConfigField(extension, field, context = { name: "" }) {
  const fieldValue = extension.config[field];
  if (typeof fieldValue === "function") {
    const boundValue = fieldValue.bind({ ...context });
    return boundValue;
  }
  return fieldValue;
}
function callOrGet(value, context = null, ...props) {
  if (typeof value === "function") {
    const fn = value;
    if (context) return fn.bind(context)(...props);
    return fn(...props);
  }
  return value;
}
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s = buffer2[offset + i];
  i += d2;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d2, nBits -= 8) {
  }
  m2 = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i], i += d2, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m2 ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m2 * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e, m2, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m2 = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m2 = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i] = m2 & 255, i += d2, m2 /= 256, mLen -= 8) {
  }
  e = e << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i] = e & 255, i += d2, e /= 256, eLen -= 8) {
  }
  buffer2[offset + i - d2] |= s * 128;
};
(function(exports$1) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports$1.Buffer = Buffer3;
  exports$1.SlowBuffer = SlowBuffer;
  exports$1.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports$1.kMaxLength = K_MAX_LENGTH;
  const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
  Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new GlobalUint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer3.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this)) return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer3.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this)) return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new GlobalUint8Array(length);
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function Buffer3(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer3.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (GlobalArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer3.from(valueOf, encodingOrOffset, length);
    }
    const b2 = fromObject(value);
    if (b2) return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer3.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer3.prototype, GlobalUint8Array.prototype);
  Object.setPrototypeOf(Buffer3, GlobalUint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer3.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer3.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer3.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer3.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, GlobalUint8Array)) {
      const copy2 = new GlobalUint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new GlobalUint8Array(array);
    } else if (length === void 0) {
      buf = new GlobalUint8Array(array, byteOffset);
    } else {
      buf = new GlobalUint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer3.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer3.alloc(+length);
  }
  Buffer3.isBuffer = function isBuffer(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer3.prototype;
  };
  Buffer3.compare = function compare(a, b2) {
    if (isInstance(a, GlobalUint8Array)) a = Buffer3.from(a, a.offset, a.byteLength);
    if (isInstance(b2, GlobalUint8Array)) b2 = Buffer3.from(b2, b2.offset, b2.byteLength);
    if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b2)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a === b2) return 0;
    let x2 = a.length;
    let y2 = b2.length;
    for (let i = 0, len = Math.min(x2, y2); i < len; ++i) {
      if (a[i] !== b2[i]) {
        x2 = a[i];
        y2 = b2[i];
        break;
      }
    }
    if (x2 < y2) return -1;
    if (y2 < x2) return 1;
    return 0;
  };
  Buffer3.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer3.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer3.alloc(0);
    }
    let i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    const buffer2 = Buffer3.allocUnsafe(length);
    let pos = 0;
    for (i = 0; i < list.length; ++i) {
      let buf = list[i];
      if (isInstance(buf, GlobalUint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);
          buf.copy(buffer2, pos);
        } else {
          GlobalUint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer3.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer3.isBuffer(string)) {
      return string.length;
    }
    if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
      );
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.prototype._isBuffer = true;
  function swap(b2, n, m2) {
    const i = b2[n];
    b2[n] = b2[m2];
    b2[m2] = i;
  }
  Buffer3.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer3.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer3.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer3.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
  Buffer3.prototype.equals = function equals(b2) {
    if (!Buffer3.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
    if (this === b2) return true;
    return Buffer3.compare(this, b2) === 0;
  };
  Buffer3.prototype.inspect = function inspect() {
    let str = "";
    const max2 = exports$1.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max2) str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
  }
  Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, GlobalUint8Array)) {
      target = Buffer3.from(target, target.offset, target.byteLength);
    }
    if (!Buffer3.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x2 = thisEnd - thisStart;
    let y2 = end - start;
    const len = Math.min(x2, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x2 = thisCopy[i];
        y2 = targetCopy[i];
        break;
      }
    }
    if (x2 < y2) return -1;
    if (y2 < x2) return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir) return -1;
      else byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer3.from(val, encoding);
    }
    if (Buffer3.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof GlobalUint8Array.prototype.indexOf === "function") {
        if (dir) {
          return GlobalUint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return GlobalUint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    let i;
    if (dir) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found2 = true;
        for (let j2 = 0; j2 < valLength; j2++) {
          if (read(arr, i + j2) !== read(val, j2)) {
            found2 = false;
            break;
          }
        }
        if (found2) return i;
      }
    }
    return -1;
  }
  Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i;
    for (i = 0; i < length; ++i) {
      const parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer3.prototype.write = function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer3.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while (i < end) {
      const firstByte = buf[i];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for (let i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer3.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer3.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let i = byteLength3;
    let mul = 1;
    let val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max2, min2) {
    if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max2 || value < min2) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
  }
  Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max2, min2) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
    if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      GlobalUint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len;
  };
  Buffer3.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }
    return this;
  };
  const errors = {};
  function E2(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E2(
    "ERR_INVALID_ARG_TYPE",
    function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E2(
    "ERR_OUT_OF_RANGE",
    function(str, range2, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range2}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min2, max2, buf, offset, byteLength3) {
    if (value > max2 || value < min2) {
      const n = typeof min2 === "bigint" ? "n" : "";
      let range2;
      {
        if (min2 === 0 || min2 === BigInt(0)) {
          range2 = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
        } else {
          range2 = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
        }
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range2, value);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length, type2) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type2);
      throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(
      "offset",
      `>= ${0} and <= ${length}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i;
    for (i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isInstance(obj, type2) {
    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = (function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet[i] + alphabet[j2];
      }
    }
    return table;
  })();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
const Buffer2 = buffer.Buffer;
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs$2(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var sax = {};
var events = { exports: {} };
var hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events.exports;
  hasRequiredEvents = 1;
  var R = typeof Reflect === "object" ? Reflect : null;
  var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  };
  var ReflectOwnKeys;
  if (R && typeof R.ownKeys === "function") {
    ReflectOwnKeys = R.ownKeys;
  } else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
    };
  } else {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target);
    };
  }
  function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
  }
  var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
    return value !== value;
  };
  function EventEmitter() {
    EventEmitter.init.call(this);
  }
  events.exports = EventEmitter;
  events.exports.once = once;
  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.prototype._events = void 0;
  EventEmitter.prototype._eventsCount = 0;
  EventEmitter.prototype._maxListeners = void 0;
  var defaultMaxListeners = 10;
  function checkListener(listener) {
    if (typeof listener !== "function") {
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
    }
  }
  Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
      }
      defaultMaxListeners = arg;
    }
  });
  EventEmitter.init = function() {
    if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || void 0;
  };
  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
    }
    this._maxListeners = n;
    return this;
  };
  function _getMaxListeners(that) {
    if (that._maxListeners === void 0)
      return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }
  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
  };
  EventEmitter.prototype.emit = function emit(type2) {
    var args = [];
    for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
    var doError = type2 === "error";
    var events2 = this._events;
    if (events2 !== void 0)
      doError = doError && events2.error === void 0;
    else if (!doError)
      return false;
    if (doError) {
      var er;
      if (args.length > 0)
        er = args[0];
      if (er instanceof Error) {
        throw er;
      }
      var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
      err.context = er;
      throw err;
    }
    var handler2 = events2[type2];
    if (handler2 === void 0)
      return false;
    if (typeof handler2 === "function") {
      ReflectApply(handler2, this, args);
    } else {
      var len = handler2.length;
      var listeners = arrayClone(handler2, len);
      for (var i = 0; i < len; ++i)
        ReflectApply(listeners[i], this, args);
    }
    return true;
  };
  function _addListener(target, type2, listener, prepend) {
    var m2;
    var events2;
    var existing;
    checkListener(listener);
    events2 = target._events;
    if (events2 === void 0) {
      events2 = target._events = /* @__PURE__ */ Object.create(null);
      target._eventsCount = 0;
    } else {
      if (events2.newListener !== void 0) {
        target.emit(
          "newListener",
          type2,
          listener.listener ? listener.listener : listener
        );
        events2 = target._events;
      }
      existing = events2[type2];
    }
    if (existing === void 0) {
      existing = events2[type2] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events2[type2] = prepend ? [listener, existing] : [existing, listener];
      } else if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
      m2 = _getMaxListeners(target);
      if (m2 > 0 && existing.length > m2 && !existing.warned) {
        existing.warned = true;
        var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w2.name = "MaxListenersExceededWarning";
        w2.emitter = target;
        w2.type = type2;
        w2.count = existing.length;
        ProcessEmitWarning(w2);
      }
    }
    return target;
  }
  EventEmitter.prototype.addListener = function addListener(type2, listener) {
    return _addListener(this, type2, listener, false);
  };
  EventEmitter.prototype.on = EventEmitter.prototype.addListener;
  EventEmitter.prototype.prependListener = function prependListener(type2, listener) {
    return _addListener(this, type2, listener, true);
  };
  function onceWrapper() {
    if (!this.fired) {
      this.target.removeListener(this.type, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0)
        return this.listener.call(this.target);
      return this.listener.apply(this.target, arguments);
    }
  }
  function _onceWrap(target, type2, listener) {
    var state2 = { fired: false, wrapFn: void 0, target, type: type2, listener };
    var wrapped = onceWrapper.bind(state2);
    wrapped.listener = listener;
    state2.wrapFn = wrapped;
    return wrapped;
  }
  EventEmitter.prototype.once = function once2(type2, listener) {
    checkListener(listener);
    this.on(type2, _onceWrap(this, type2, listener));
    return this;
  };
  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
    checkListener(listener);
    this.prependListener(type2, _onceWrap(this, type2, listener));
    return this;
  };
  EventEmitter.prototype.removeListener = function removeListener(type2, listener) {
    var list, events2, position, i, originalListener;
    checkListener(listener);
    events2 = this._events;
    if (events2 === void 0)
      return this;
    list = events2[type2];
    if (list === void 0)
      return this;
    if (list === listener || list.listener === listener) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else {
        delete events2[type2];
        if (events2.removeListener)
          this.emit("removeListener", type2, list.listener || listener);
      }
    } else if (typeof list !== "function") {
      position = -1;
      for (i = list.length - 1; i >= 0; i--) {
        if (list[i] === listener || list[i].listener === listener) {
          originalListener = list[i].listener;
          position = i;
          break;
        }
      }
      if (position < 0)
        return this;
      if (position === 0)
        list.shift();
      else {
        spliceOne(list, position);
      }
      if (list.length === 1)
        events2[type2] = list[0];
      if (events2.removeListener !== void 0)
        this.emit("removeListener", type2, originalListener || listener);
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type2) {
    var listeners, events2, i;
    events2 = this._events;
    if (events2 === void 0)
      return this;
    if (events2.removeListener === void 0) {
      if (arguments.length === 0) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      } else if (events2[type2] !== void 0) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else
          delete events2[type2];
      }
      return this;
    }
    if (arguments.length === 0) {
      var keys2 = Object.keys(events2);
      var key;
      for (i = 0; i < keys2.length; ++i) {
        key = keys2[i];
        if (key === "removeListener") continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners("removeListener");
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
      return this;
    }
    listeners = events2[type2];
    if (typeof listeners === "function") {
      this.removeListener(type2, listeners);
    } else if (listeners !== void 0) {
      for (i = listeners.length - 1; i >= 0; i--) {
        this.removeListener(type2, listeners[i]);
      }
    }
    return this;
  };
  function _listeners(target, type2, unwrap) {
    var events2 = target._events;
    if (events2 === void 0)
      return [];
    var evlistener = events2[type2];
    if (evlistener === void 0)
      return [];
    if (typeof evlistener === "function")
      return unwrap ? [evlistener.listener || evlistener] : [evlistener];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
  }
  EventEmitter.prototype.listeners = function listeners(type2) {
    return _listeners(this, type2, true);
  };
  EventEmitter.prototype.rawListeners = function rawListeners(type2) {
    return _listeners(this, type2, false);
  };
  EventEmitter.listenerCount = function(emitter, type2) {
    if (typeof emitter.listenerCount === "function") {
      return emitter.listenerCount(type2);
    } else {
      return listenerCount.call(emitter, type2);
    }
  };
  EventEmitter.prototype.listenerCount = listenerCount;
  function listenerCount(type2) {
    var events2 = this._events;
    if (events2 !== void 0) {
      var evlistener = events2[type2];
      if (typeof evlistener === "function") {
        return 1;
      } else if (evlistener !== void 0) {
        return evlistener.length;
      }
    }
    return 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
  };
  function arrayClone(arr, n) {
    var copy2 = new Array(n);
    for (var i = 0; i < n; ++i)
      copy2[i] = arr[i];
    return copy2;
  }
  function spliceOne(list, index2) {
    for (; index2 + 1 < list.length; index2++)
      list[index2] = list[index2 + 1];
    list.pop();
  }
  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  }
  function once(emitter, name) {
    return new Promise(function(resolve, reject) {
      function errorListener(err) {
        emitter.removeListener(name, resolver);
        reject(err);
      }
      function resolver() {
        if (typeof emitter.removeListener === "function") {
          emitter.removeListener("error", errorListener);
        }
        resolve([].slice.call(arguments));
      }
      eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
      if (name !== "error") {
        addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
      }
    });
  }
  function addErrorHandlerIfEventEmitter(emitter, handler2, flags) {
    if (typeof emitter.on === "function") {
      eventTargetAgnosticAddListener(emitter, "error", handler2, flags);
    }
  }
  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
      if (flags.once) {
        emitter.once(name, listener);
      } else {
        emitter.on(name, listener);
      }
    } else if (typeof emitter.addEventListener === "function") {
      emitter.addEventListener(name, function wrapListener(arg) {
        if (flags.once) {
          emitter.removeEventListener(name, wrapListener);
        }
        listener(arg);
      });
    } else {
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
    }
  }
  return events.exports;
}
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
function getDefaultExportFromCjs$1(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var browser$1 = { exports: {} };
var process = browser$1.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
  return [];
};
process.binding = function(name) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(dir) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser$1.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(browserExports);
var streamBrowser;
var hasRequiredStreamBrowser;
function requireStreamBrowser() {
  if (hasRequiredStreamBrowser) return streamBrowser;
  hasRequiredStreamBrowser = 1;
  streamBrowser = requireEvents().EventEmitter;
  return streamBrowser;
}
var dist = {};
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  (function(exports$1) {
    Object.defineProperties(exports$1, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
    var buffer2 = {};
    var base64Js2 = {};
    base64Js2.byteLength = byteLength2;
    base64Js2.toByteArray = toByteArray2;
    base64Js2.fromByteArray = fromByteArray2;
    var lookup2 = [];
    var revLookup2 = [];
    var Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i = 0, len = code2.length; i < len; ++i) {
      lookup2[i] = code2[i];
      revLookup2[code2.charCodeAt(i)] = i;
    }
    revLookup2["-".charCodeAt(0)] = 62;
    revLookup2["_".charCodeAt(0)] = 63;
    function getLens2(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength2(b64) {
      var lens = getLens2(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength2(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray2(b64) {
      var tmp;
      var lens = getLens2(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr2(_byteLength2(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup2[b64.charCodeAt(i2)] << 18 | revLookup2[b64.charCodeAt(i2 + 1)] << 12 | revLookup2[b64.charCodeAt(i2 + 2)] << 6 | revLookup2[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup2[b64.charCodeAt(i2)] << 2 | revLookup2[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup2[b64.charCodeAt(i2)] << 10 | revLookup2[b64.charCodeAt(i2 + 1)] << 4 | revLookup2[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase642(num) {
      return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
    }
    function encodeChunk2(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase642(tmp));
      }
      return output.join("");
    }
    function fromByteArray2(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk2(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup2[tmp >> 2] + lookup2[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup2[tmp >> 10] + lookup2[tmp >> 4 & 63] + lookup2[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
    var ieee7542 = {};
    ieee7542.read = function(buffer3, offset, isLE, mLen, nBytes) {
      var e, m2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i2 = isLE ? nBytes - 1 : 0;
      var d2 = isLE ? -1 : 1;
      var s = buffer3[offset + i2];
      i2 += d2;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer3[offset + i2], i2 += d2, nBits -= 8) {
      }
      m2 = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m2 = m2 * 256 + buffer3[offset + i2], i2 += d2, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m2 ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m2 = m2 + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m2 * Math.pow(2, e - mLen);
    };
    ieee7542.write = function(buffer3, value, offset, isLE, mLen, nBytes) {
      var e, m2, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i2 = isLE ? 0 : nBytes - 1;
      var d2 = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m2 = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m2 = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m2 = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer3[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
      }
      e = e << mLen | m2;
      eLen += mLen;
      for (; eLen > 0; buffer3[offset + i2] = e & 255, i2 += d2, e /= 256, eLen -= 8) {
      }
      buffer3[offset + i2 - d2] |= s * 128;
    };
    (function(exports$12) {
      const base64 = base64Js2;
      const ieee754$1 = ieee7542;
      const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports$12.Buffer = Buffer4;
      exports$12.SlowBuffer = SlowBuffer;
      exports$12.INSPECT_MAX_BYTES = 50;
      const K_MAX_LENGTH = 2147483647;
      exports$12.kMaxLength = K_MAX_LENGTH;
      const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
      Buffer4.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer4.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new GlobalUint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer4.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer4.isBuffer(this)) return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer4.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer4.isBuffer(this)) return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new GlobalUint8Array(length);
        Object.setPrototypeOf(buf, Buffer4.prototype);
        return buf;
      }
      function Buffer4(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer4.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (GlobalArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer4.from(valueOf, encodingOrOffset, length);
        }
        const b2 = fromObject(value);
        if (b2) return b2;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer4.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer4.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer4.prototype, GlobalUint8Array.prototype);
      Object.setPrototypeOf(Buffer4, GlobalUint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer4.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer4.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer4.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer4.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength3(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i2 = 0; i2 < length; i2 += 1) {
          buf[i2] = array[i2] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, GlobalUint8Array)) {
          const copy2 = new GlobalUint8Array(arrayView);
          return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new GlobalUint8Array(array);
        } else if (length === void 0) {
          buf = new GlobalUint8Array(array, byteOffset);
        } else {
          buf = new GlobalUint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer4.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer4.isBuffer(obj)) {
          const len2 = checked(obj.length) | 0;
          const buf = createBuffer(len2);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len2);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer4.alloc(+length);
      }
      Buffer4.isBuffer = function isBuffer(b2) {
        return b2 != null && b2._isBuffer === true && b2 !== Buffer4.prototype;
      };
      Buffer4.compare = function compare(a, b2) {
        if (isInstance(a, GlobalUint8Array)) a = Buffer4.from(a, a.offset, a.byteLength);
        if (isInstance(b2, GlobalUint8Array)) b2 = Buffer4.from(b2, b2.offset, b2.byteLength);
        if (!Buffer4.isBuffer(a) || !Buffer4.isBuffer(b2)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b2) return 0;
        let x2 = a.length;
        let y2 = b2.length;
        for (let i2 = 0, len2 = Math.min(x2, y2); i2 < len2; ++i2) {
          if (a[i2] !== b2[i2]) {
            x2 = a[i2];
            y2 = b2[i2];
            break;
          }
        }
        if (x2 < y2) return -1;
        if (y2 < x2) return 1;
        return 0;
      };
      Buffer4.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer4.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer4.alloc(0);
        }
        let i2;
        if (length === void 0) {
          length = 0;
          for (i2 = 0; i2 < list.length; ++i2) {
            length += list[i2].length;
          }
        }
        const buffer3 = Buffer4.allocUnsafe(length);
        let pos = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          let buf = list[i2];
          if (isInstance(buf, GlobalUint8Array)) {
            if (pos + buf.length > buffer3.length) {
              if (!Buffer4.isBuffer(buf)) buf = Buffer4.from(buf);
              buf.copy(buffer3, pos);
            } else {
              GlobalUint8Array.prototype.set.call(
                buffer3,
                buf,
                pos
              );
            }
          } else if (!Buffer4.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer3, pos);
          }
          pos += buf.length;
        }
        return buffer3;
      };
      function byteLength3(string, encoding) {
        if (Buffer4.isBuffer(string)) {
          return string.length;
        }
        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len2 = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len2 === 0) return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len2;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len2 * 2;
            case "hex":
              return len2 >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer4.byteLength = byteLength3;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding) encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer4.prototype._isBuffer = true;
      function swap(b2, n, m2) {
        const i2 = b2[n];
        b2[n] = b2[m2];
        b2[m2] = i2;
      }
      Buffer4.prototype.swap16 = function swap16() {
        const len2 = this.length;
        if (len2 % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i2 = 0; i2 < len2; i2 += 2) {
          swap(this, i2, i2 + 1);
        }
        return this;
      };
      Buffer4.prototype.swap32 = function swap32() {
        const len2 = this.length;
        if (len2 % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i2 = 0; i2 < len2; i2 += 4) {
          swap(this, i2, i2 + 3);
          swap(this, i2 + 1, i2 + 2);
        }
        return this;
      };
      Buffer4.prototype.swap64 = function swap64() {
        const len2 = this.length;
        if (len2 % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i2 = 0; i2 < len2; i2 += 8) {
          swap(this, i2, i2 + 7);
          swap(this, i2 + 1, i2 + 6);
          swap(this, i2 + 2, i2 + 5);
          swap(this, i2 + 3, i2 + 4);
        }
        return this;
      };
      Buffer4.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0) return "";
        if (arguments.length === 0) return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer4.prototype.toLocaleString = Buffer4.prototype.toString;
      Buffer4.prototype.equals = function equals(b2) {
        if (!Buffer4.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
        if (this === b2) return true;
        return Buffer4.compare(this, b2) === 0;
      };
      Buffer4.prototype.inspect = function inspect() {
        let str = "";
        const max2 = exports$12.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max2) str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer4.prototype[customInspectSymbol] = Buffer4.prototype.inspect;
      }
      Buffer4.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, GlobalUint8Array)) {
          target = Buffer4.from(target, target.offset, target.byteLength);
        }
        if (!Buffer4.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target) return 0;
        let x2 = thisEnd - thisStart;
        let y2 = end - start;
        const len2 = Math.min(x2, y2);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i2 = 0; i2 < len2; ++i2) {
          if (thisCopy[i2] !== targetCopy[i2]) {
            x2 = thisCopy[i2];
            y2 = targetCopy[i2];
            break;
          }
        }
        if (x2 < y2) return -1;
        if (y2 < x2) return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer3, val, byteOffset, encoding, dir) {
        if (buffer3.length === 0) return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer3.length - 1;
        }
        if (byteOffset < 0) byteOffset = buffer3.length + byteOffset;
        if (byteOffset >= buffer3.length) {
          if (dir) return -1;
          else byteOffset = buffer3.length - 1;
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0;
          else return -1;
        }
        if (typeof val === "string") {
          val = Buffer4.from(val, encoding);
        }
        if (Buffer4.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer3, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof GlobalUint8Array.prototype.indexOf === "function") {
            if (dir) {
              return GlobalUint8Array.prototype.indexOf.call(buffer3, val, byteOffset);
            } else {
              return GlobalUint8Array.prototype.lastIndexOf.call(buffer3, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer3, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i3) {
          if (indexSize === 1) {
            return buf[i3];
          } else {
            return buf.readUInt16BE(i3 * indexSize);
          }
        }
        let i2;
        if (dir) {
          let foundIndex = -1;
          for (i2 = byteOffset; i2 < arrLength; i2++) {
            if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
              if (foundIndex === -1) foundIndex = i2;
              if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1) i2 -= i2 - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
          for (i2 = byteOffset; i2 >= 0; i2--) {
            let found2 = true;
            for (let j2 = 0; j2 < valLength; j2++) {
              if (read(arr, i2 + j2) !== read(val, j2)) {
                found2 = false;
                break;
              }
            }
            if (found2) return i2;
          }
        }
        return -1;
      }
      Buffer4.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer4.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer4.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i2;
        for (i2 = 0; i2 < length; ++i2) {
          const parsed = parseInt(string.substr(i2 * 2, 2), 16);
          if (numberIsNaN(parsed)) return i2;
          buf[offset + i2] = parsed;
        }
        return i2;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer4.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0) encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining) length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding) encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer4.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i2 = start;
        while (i2 < end) {
          const firstByte = buf[i2];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i2 + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i2 + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i2 + 1];
                thirdByte = buf[i2 + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i2 + 1];
                thirdByte = buf[i2 + 2];
                fourthByte = buf[i2 + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i2 += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      const MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len2 = codePoints.length;
        if (len2 <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i2 = 0;
        while (i2 < len2) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i2 = start; i2 < end; ++i2) {
          ret += String.fromCharCode(buf[i2] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i2 = start; i2 < end; ++i2) {
          ret += String.fromCharCode(buf[i2]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len2 = buf.length;
        if (!start || start < 0) start = 0;
        if (!end || end < 0 || end > len2) end = len2;
        let out = "";
        for (let i2 = start; i2 < end; ++i2) {
          out += hexSliceLookupTable[buf[i2]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
          res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
        }
        return res;
      }
      Buffer4.prototype.slice = function slice(start, end) {
        const len2 = this.length;
        start = ~~start;
        end = end === void 0 ? len2 : ~~end;
        if (start < 0) {
          start += len2;
          if (start < 0) start = 0;
        } else if (start > len2) {
          start = len2;
        }
        if (end < 0) {
          end += len2;
          if (end < 0) end = 0;
        } else if (end > len2) {
          end = len2;
        }
        if (end < start) end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer4.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
        if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer4.prototype.readUintLE = Buffer4.prototype.readUIntLE = function readUIntLE(offset, byteLength4, noAssert) {
        offset = offset >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength4, this.length);
        let val = this[offset];
        let mul = 1;
        let i2 = 0;
        while (++i2 < byteLength4 && (mul *= 256)) {
          val += this[offset + i2] * mul;
        }
        return val;
      };
      Buffer4.prototype.readUintBE = Buffer4.prototype.readUIntBE = function readUIntBE(offset, byteLength4, noAssert) {
        offset = offset >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength4, this.length);
        }
        let val = this[offset + --byteLength4];
        let mul = 1;
        while (byteLength4 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength4] * mul;
        }
        return val;
      };
      Buffer4.prototype.readUint8 = Buffer4.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer4.prototype.readUint16LE = Buffer4.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer4.prototype.readUint16BE = Buffer4.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer4.prototype.readUint32LE = Buffer4.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer4.prototype.readUint32BE = Buffer4.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer4.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer4.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer4.prototype.readIntLE = function readIntLE(offset, byteLength4, noAssert) {
        offset = offset >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength4, this.length);
        let val = this[offset];
        let mul = 1;
        let i2 = 0;
        while (++i2 < byteLength4 && (mul *= 256)) {
          val += this[offset + i2] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength4);
        return val;
      };
      Buffer4.prototype.readIntBE = function readIntBE(offset, byteLength4, noAssert) {
        offset = offset >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength4, this.length);
        let i2 = byteLength4;
        let mul = 1;
        let val = this[offset + --i2];
        while (i2 > 0 && (mul *= 256)) {
          val += this[offset + --i2] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength4);
        return val;
      };
      Buffer4.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128)) return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer4.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer4.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer4.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer4.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer4.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer4.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer4.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754$1.read(this, offset, true, 23, 4);
      };
      Buffer4.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754$1.read(this, offset, false, 23, 4);
      };
      Buffer4.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754$1.read(this, offset, true, 52, 8);
      };
      Buffer4.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754$1.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max2, min2) {
        if (!Buffer4.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max2 || value < min2) throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
      }
      Buffer4.prototype.writeUintLE = Buffer4.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength4, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength4) - 1;
          checkInt(this, value, offset, byteLength4, maxBytes, 0);
        }
        let mul = 1;
        let i2 = 0;
        this[offset] = value & 255;
        while (++i2 < byteLength4 && (mul *= 256)) {
          this[offset + i2] = value / mul & 255;
        }
        return offset + byteLength4;
      };
      Buffer4.prototype.writeUintBE = Buffer4.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength4, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength4) - 1;
          checkInt(this, value, offset, byteLength4, maxBytes, 0);
        }
        let i2 = byteLength4 - 1;
        let mul = 1;
        this[offset + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          this[offset + i2] = value / mul & 255;
        }
        return offset + byteLength4;
      };
      Buffer4.prototype.writeUint8 = Buffer4.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer4.prototype.writeUint16LE = Buffer4.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer4.prototype.writeUint16BE = Buffer4.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer4.prototype.writeUint32LE = Buffer4.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer4.prototype.writeUint32BE = Buffer4.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min2, max2) {
        checkIntBI(value, min2, max2, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min2, max2) {
        checkIntBI(value, min2, max2, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer4.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer4.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer4.prototype.writeIntLE = function writeIntLE(value, offset, byteLength4, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength4 - 1);
          checkInt(this, value, offset, byteLength4, limit - 1, -limit);
        }
        let i2 = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i2 < byteLength4 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
            sub = 1;
          }
          this[offset + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength4;
      };
      Buffer4.prototype.writeIntBE = function writeIntBE(value, offset, byteLength4, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength4 - 1);
          checkInt(this, value, offset, byteLength4, limit - 1, -limit);
        }
        let i2 = byteLength4 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
            sub = 1;
          }
          this[offset + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength4;
      };
      Buffer4.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
        if (value < 0) value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer4.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer4.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer4.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer4.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0) value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer4.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer4.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max2, min2) {
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
        if (offset < 0) throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4);
        }
        ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer4.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer4.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8);
        }
        ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer4.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer4.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer4.prototype.copy = function copy2(target, targetStart, start, end) {
        if (!Buffer4.isBuffer(target)) throw new TypeError("argument should be a Buffer");
        if (!start) start = 0;
        if (!end && end !== 0) end = this.length;
        if (targetStart >= target.length) targetStart = target.length;
        if (!targetStart) targetStart = 0;
        if (end > 0 && end < start) end = start;
        if (end === start) return 0;
        if (target.length === 0 || this.length === 0) return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
        if (end < 0) throw new RangeError("sourceEnd out of bounds");
        if (end > this.length) end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len2 = end - start;
        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          GlobalUint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len2;
      };
      Buffer4.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code3 = val.charCodeAt(0);
            if (encoding === "utf8" && code3 < 128 || encoding === "latin1") {
              val = code3;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val) val = 0;
        let i2;
        if (typeof val === "number") {
          for (i2 = start; i2 < end; ++i2) {
            this[i2] = val;
          }
        } else {
          const bytes = Buffer4.isBuffer(val) ? val : Buffer4.from(val, encoding);
          const len2 = bytes.length;
          if (len2 === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i2 = 0; i2 < end - start; ++i2) {
            this[i2 + start] = bytes[i2 % len2];
          }
        }
        return this;
      };
      const errors = {};
      function E2(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E2(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E2(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E2(
        "ERR_OUT_OF_RANGE",
        function(str, range2, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range2}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i2 = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i2 >= start + 4; i2 -= 3) {
          res = `_${val.slice(i2 - 3, i2)}${res}`;
        }
        return `${val.slice(0, i2)}${res}`;
      }
      function checkBounds(buf, offset, byteLength4) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength4] === void 0) {
          boundsError(offset, buf.length - (byteLength4 + 1));
        }
      }
      function checkIntBI(value, min2, max2, buf, offset, byteLength4) {
        if (value > max2 || value < min2) {
          const n = typeof min2 === "bigint" ? "n" : "";
          let range2;
          {
            if (min2 === 0 || min2 === BigInt(0)) {
              range2 = `>= 0${n} and < 2${n} ** ${(byteLength4 + 1) * 8}${n}`;
            } else {
              range2 = `>= -(2${n} ** ${(byteLength4 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength4 + 1) * 8 - 1}${n}`;
            }
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range2, value);
        }
        checkBounds(buf, offset, byteLength4);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type2) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type2);
          throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          "offset",
          `>= ${0} and <= ${length}`,
          value
        );
      }
      const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2) return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i2 = 0; i2 < length; ++i2) {
          codePoint = string.charCodeAt(i2);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              } else if (i2 + 1 === length) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i2 = 0; i2 < str.length; ++i2) {
          byteArray.push(str.charCodeAt(i2) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i2 = 0; i2 < str.length; ++i2) {
          if ((units -= 2) < 0) break;
          c = str.charCodeAt(i2);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i2;
        for (i2 = 0; i2 < length; ++i2) {
          if (i2 + offset >= dst.length || i2 >= src.length) break;
          dst[i2 + offset] = src[i2];
        }
        return i2;
      }
      function isInstance(obj, type2) {
        return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      const hexSliceLookupTable = (function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i2 = 0; i2 < 16; ++i2) {
          const i16 = i2 * 16;
          for (let j2 = 0; j2 < 16; ++j2) {
            table[i16 + j2] = alphabet[i2] + alphabet[j2];
          }
        }
        return table;
      })();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    })(buffer2);
    const Buffer3 = buffer2.Buffer;
    exports$1.Blob = buffer2.Blob;
    exports$1.BlobOptions = buffer2.BlobOptions;
    exports$1.Buffer = buffer2.Buffer;
    exports$1.File = buffer2.File;
    exports$1.FileOptions = buffer2.FileOptions;
    exports$1.INSPECT_MAX_BYTES = buffer2.INSPECT_MAX_BYTES;
    exports$1.SlowBuffer = buffer2.SlowBuffer;
    exports$1.TranscodeEncoding = buffer2.TranscodeEncoding;
    exports$1.atob = buffer2.atob;
    exports$1.btoa = buffer2.btoa;
    exports$1.constants = buffer2.constants;
    exports$1.default = Buffer3;
    exports$1.isAscii = buffer2.isAscii;
    exports$1.isUtf8 = buffer2.isUtf8;
    exports$1.kMaxLength = buffer2.kMaxLength;
    exports$1.kStringMaxLength = buffer2.kStringMaxLength;
    exports$1.resolveObjectURL = buffer2.resolveObjectURL;
    exports$1.transcode = buffer2.transcode;
  })(dist);
  return dist;
}
var util = {};
var types = {};
var shams$1;
var hasRequiredShams$1;
function requireShams$1() {
  if (hasRequiredShams$1) return shams$1;
  hasRequiredShams$1 = 1;
  shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _2 in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams$1;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var hasSymbols2 = requireShams$1();
  shams = function hasToStringTagShams() {
    return hasSymbols2() && !!Symbol.toStringTag;
  };
  return shams;
}
var esObjectAtoms;
var hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  if (hasRequiredEsObjectAtoms) return esObjectAtoms;
  hasRequiredEsObjectAtoms = 1;
  esObjectAtoms = Object;
  return esObjectAtoms;
}
var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
  if (hasRequiredEsErrors) return esErrors;
  hasRequiredEsErrors = 1;
  esErrors = Error;
  return esErrors;
}
var _eval;
var hasRequired_eval;
function require_eval() {
  if (hasRequired_eval) return _eval;
  hasRequired_eval = 1;
  _eval = EvalError;
  return _eval;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  range = RangeError;
  return range;
}
var ref;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  ref = ReferenceError;
  return ref;
}
var syntax;
var hasRequiredSyntax;
function requireSyntax() {
  if (hasRequiredSyntax) return syntax;
  hasRequiredSyntax = 1;
  syntax = SyntaxError;
  return syntax;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  type = TypeError;
  return type;
}
var uri;
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  uri = URIError;
  return uri;
}
var abs;
var hasRequiredAbs;
function requireAbs() {
  if (hasRequiredAbs) return abs;
  hasRequiredAbs = 1;
  abs = Math.abs;
  return abs;
}
var floor;
var hasRequiredFloor;
function requireFloor() {
  if (hasRequiredFloor) return floor;
  hasRequiredFloor = 1;
  floor = Math.floor;
  return floor;
}
var max;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max;
  hasRequiredMax = 1;
  max = Math.max;
  return max;
}
var min;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin) return min;
  hasRequiredMin = 1;
  min = Math.min;
  return min;
}
var pow;
var hasRequiredPow;
function requirePow() {
  if (hasRequiredPow) return pow;
  hasRequiredPow = 1;
  pow = Math.pow;
  return pow;
}
var round;
var hasRequiredRound;
function requireRound() {
  if (hasRequiredRound) return round;
  hasRequiredRound = 1;
  round = Math.round;
  return round;
}
var _isNaN;
var hasRequired_isNaN;
function require_isNaN() {
  if (hasRequired_isNaN) return _isNaN;
  hasRequired_isNaN = 1;
  _isNaN = Number.isNaN || function isNaN2(a) {
    return a !== a;
  };
  return _isNaN;
}
var sign;
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign;
  hasRequiredSign = 1;
  var $isNaN = /* @__PURE__ */ require_isNaN();
  sign = function sign2(number) {
    if ($isNaN(number) || number === 0) {
      return number;
    }
    return number < 0 ? -1 : 1;
  };
  return sign;
}
var gOPD;
var hasRequiredGOPD;
function requireGOPD() {
  if (hasRequiredGOPD) return gOPD;
  hasRequiredGOPD = 1;
  gOPD = Object.getOwnPropertyDescriptor;
  return gOPD;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var $gOPD = /* @__PURE__ */ requireGOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  esDefineProperty = $defineProperty;
  return esDefineProperty;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams$1();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  Object_getPrototypeOf = $Object.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b2) {
    var arr = [];
    for (var i = 0; i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j2 = 0; j2 < b2.length; j2 += 1) {
      arr[j2 + a.length] = b2[j2];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i = offset, j2 = 0; i < arrLike.length; i += 1, j2 += 1) {
      arr[j2] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0; i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation = function bind2(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var bind2 = requireFunctionBind();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var $reflectApply = requireReflectApply();
  actualApply = $reflectApply || bind2.call($call, $apply);
  return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind2 = requireFunctionBind();
  var $TypeError = /* @__PURE__ */ requireType();
  var $call = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind2, $call, args);
  };
  return callBindApplyHelpers;
}
var get;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var callBind2 = requireCallBindApplyHelpers();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  get = desc && typeof desc.get === "function" ? callBind2([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object(value));
    }
  ) : false;
  return get;
}
var getProto;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = /* @__PURE__ */ requireGet();
  getProto = reflectGetProto ? function getProto2(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto2(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto2(O) {
    return getDunderProto(O);
  } : null;
  return getProto;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind2 = requireFunctionBind();
  hasown = bind2.call(call, $hasOwn);
  return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  var $Error = /* @__PURE__ */ requireEsErrors();
  var $EvalError = /* @__PURE__ */ require_eval();
  var $RangeError = /* @__PURE__ */ requireRange();
  var $ReferenceError = /* @__PURE__ */ requireRef();
  var $SyntaxError = /* @__PURE__ */ requireSyntax();
  var $TypeError = /* @__PURE__ */ requireType();
  var $URIError = /* @__PURE__ */ requireUri();
  var abs2 = /* @__PURE__ */ requireAbs();
  var floor2 = /* @__PURE__ */ requireFloor();
  var max2 = /* @__PURE__ */ requireMax();
  var min2 = /* @__PURE__ */ requireMin();
  var pow2 = /* @__PURE__ */ requirePow();
  var round2 = /* @__PURE__ */ requireRound();
  var sign2 = /* @__PURE__ */ requireSign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = /* @__PURE__ */ requireGopd();
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? (function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  })() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var getProto2 = requireGetProto();
  var $ObjectGPO = requireObject_getPrototypeOf();
  var $ReflectGPO = requireReflect_getPrototypeOf();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1 : getProto2(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs2,
    "%Math.floor%": floor2,
    "%Math.max%": max2,
    "%Math.min%": min2,
    "%Math.pow%": pow2,
    "%Math.round%": round2,
    "%Math.sign%": sign2,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto2) {
    try {
      null.error;
    } catch (e) {
      var errorProto = getProto2(getProto2(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto2) {
        value = getProto2(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind2 = requireFunctionBind();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var $concat = bind2.call($call, Array.prototype.concat);
  var $spliceApply = bind2.call($apply, Array.prototype.splice);
  var $replace = bind2.call($call, String.prototype.replace);
  var $strSlice = bind2.call($call, String.prototype.slice);
  var $exec = bind2.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void undefined$1;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBindBasic = requireCallBindApplyHelpers();
  var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
  callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = (
      /** @type {(this: unknown, ...args: unknown[]) => unknown} */
      GetIntrinsic(name, !!allowMissing)
    );
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBindBasic(
        /** @type {const} */
        [intrinsic]
      );
    }
    return intrinsic;
  };
  return callBound;
}
var isArguments;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments;
  hasRequiredIsArguments = 1;
  var hasToStringTag = requireShams()();
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var $toString = callBound2("Object.prototype.toString");
  var isStandardArguments = function isArguments2(value) {
    if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
      return false;
    }
    return $toString(value) === "[object Arguments]";
  };
  var isLegacyArguments = function isArguments2(value) {
    if (isStandardArguments(value)) {
      return true;
    }
    return value !== null && typeof value === "object" && "length" in value && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && "callee" in value && $toString(value.callee) === "[object Function]";
  };
  var supportsStandardArguments = (function() {
    return isStandardArguments(arguments);
  })();
  isStandardArguments.isLegacyArguments = isLegacyArguments;
  isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  return isArguments;
}
var isRegex;
var hasRequiredIsRegex;
function requireIsRegex() {
  if (hasRequiredIsRegex) return isRegex;
  hasRequiredIsRegex = 1;
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var hasToStringTag = requireShams()();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var fn;
  if (hasToStringTag) {
    var $exec = callBound2("RegExp.prototype.exec");
    var isRegexMarker = {};
    var throwRegexMarker = function() {
      throw isRegexMarker;
    };
    var badStringifier = {
      toString: throwRegexMarker,
      valueOf: throwRegexMarker
    };
    if (typeof Symbol.toPrimitive === "symbol") {
      badStringifier[Symbol.toPrimitive] = throwRegexMarker;
    }
    fn = function isRegex2(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      var descriptor = (
        /** @type {NonNullable<typeof gOPD>} */
        gOPD2(
          /** @type {{ lastIndex?: unknown }} */
          value,
          "lastIndex"
        )
      );
      var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, "value");
      if (!hasLastIndexDataProperty) {
        return false;
      }
      try {
        $exec(
          value,
          /** @type {string} */
          /** @type {unknown} */
          badStringifier
        );
      } catch (e) {
        return e === isRegexMarker;
      }
    };
  } else {
    var $toString = callBound2("Object.prototype.toString");
    var regexClass = "[object RegExp]";
    fn = function isRegex2(value) {
      if (!value || typeof value !== "object" && typeof value !== "function") {
        return false;
      }
      return $toString(value) === regexClass;
    };
  }
  isRegex = fn;
  return isRegex;
}
var safeRegexTest;
var hasRequiredSafeRegexTest;
function requireSafeRegexTest() {
  if (hasRequiredSafeRegexTest) return safeRegexTest;
  hasRequiredSafeRegexTest = 1;
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var isRegex2 = requireIsRegex();
  var $exec = callBound2("RegExp.prototype.exec");
  var $TypeError = /* @__PURE__ */ requireType();
  safeRegexTest = function regexTester(regex) {
    if (!isRegex2(regex)) {
      throw new $TypeError("`regex` must be a RegExp");
    }
    return function test(s) {
      return $exec(regex, s) !== null;
    };
  };
  return safeRegexTest;
}
var generatorFunction;
var hasRequiredGeneratorFunction;
function requireGeneratorFunction() {
  if (hasRequiredGeneratorFunction) return generatorFunction;
  hasRequiredGeneratorFunction = 1;
  const cached = (
    /** @type {GeneratorFunctionConstructor} */
    function* () {
    }.constructor
  );
  generatorFunction = () => cached;
  return generatorFunction;
}
var isGeneratorFunction;
var hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var safeRegexTest2 = /* @__PURE__ */ requireSafeRegexTest();
  var isFnRegex = safeRegexTest2(/^\s*(?:function)?\*/);
  var hasToStringTag = requireShams()();
  var getProto2 = requireGetProto();
  var toStr = callBound2("Object.prototype.toString");
  var fnToStr = callBound2("Function.prototype.toString");
  var getGeneratorFunction = /* @__PURE__ */ requireGeneratorFunction();
  isGeneratorFunction = function isGeneratorFunction2(fn) {
    if (typeof fn !== "function") {
      return false;
    }
    if (isFnRegex(fnToStr(fn))) {
      return true;
    }
    if (!hasToStringTag) {
      var str = toStr(fn);
      return str === "[object GeneratorFunction]";
    }
    if (!getProto2) {
      return false;
    }
    var GeneratorFunction = getGeneratorFunction();
    return GeneratorFunction && getProto2(fn) === GeneratorFunction.prototype;
  };
  return isGeneratorFunction;
}
var isCallable;
var hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var fnToStr = Function.prototype.toString;
  var reflectApply2 = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
  var badArrayLike;
  var isCallableMarker;
  if (typeof reflectApply2 === "function" && typeof Object.defineProperty === "function") {
    try {
      badArrayLike = Object.defineProperty({}, "length", {
        get: function() {
          throw isCallableMarker;
        }
      });
      isCallableMarker = {};
      reflectApply2(function() {
        throw 42;
      }, null, badArrayLike);
    } catch (_2) {
      if (_2 !== isCallableMarker) {
        reflectApply2 = null;
      }
    }
  } else {
    reflectApply2 = null;
  }
  var constructorRegex = /^\s*class\b/;
  var isES6ClassFn = function isES6ClassFunction(value) {
    try {
      var fnStr = fnToStr.call(value);
      return constructorRegex.test(fnStr);
    } catch (e) {
      return false;
    }
  };
  var tryFunctionObject = function tryFunctionToStr(value) {
    try {
      if (isES6ClassFn(value)) {
        return false;
      }
      fnToStr.call(value);
      return true;
    } catch (e) {
      return false;
    }
  };
  var toStr = Object.prototype.toString;
  var objectClass = "[object Object]";
  var fnClass = "[object Function]";
  var genClass = "[object GeneratorFunction]";
  var ddaClass = "[object HTMLAllCollection]";
  var ddaClass2 = "[object HTML document.all class]";
  var ddaClass3 = "[object HTMLCollection]";
  var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
  var isIE68 = !(0 in [,]);
  var isDDA = function isDocumentDotAll() {
    return false;
  };
  if (typeof document === "object") {
    var all = document.all;
    if (toStr.call(all) === toStr.call(document.all)) {
      isDDA = function isDocumentDotAll(value) {
        if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
          try {
            var str = toStr.call(value);
            return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
          } catch (e) {
          }
        }
        return false;
      };
    }
  }
  isCallable = reflectApply2 ? function isCallable2(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    try {
      reflectApply2(value, null, badArrayLike);
    } catch (e) {
      if (e !== isCallableMarker) {
        return false;
      }
    }
    return !isES6ClassFn(value) && tryFunctionObject(value);
  } : function isCallable2(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    if (hasToStringTag) {
      return tryFunctionObject(value);
    }
    if (isES6ClassFn(value)) {
      return false;
    }
    var strClass = toStr.call(value);
    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
      return false;
    }
    return tryFunctionObject(value);
  };
  return isCallable;
}
var forEach;
var hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach) return forEach;
  hasRequiredForEach = 1;
  var isCallable2 = requireIsCallable();
  var toStr = Object.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var forEachArray = function forEachArray2(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
      if (hasOwnProperty.call(array, i)) {
        if (receiver == null) {
          iterator(array[i], i, array);
        } else {
          iterator.call(receiver, array[i], i, array);
        }
      }
    }
  };
  var forEachString = function forEachString2(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
      if (receiver == null) {
        iterator(string.charAt(i), i, string);
      } else {
        iterator.call(receiver, string.charAt(i), i, string);
      }
    }
  };
  var forEachObject = function forEachObject2(object, iterator, receiver) {
    for (var k2 in object) {
      if (hasOwnProperty.call(object, k2)) {
        if (receiver == null) {
          iterator(object[k2], k2, object);
        } else {
          iterator.call(receiver, object[k2], k2, object);
        }
      }
    }
  };
  function isArray(x2) {
    return toStr.call(x2) === "[object Array]";
  }
  forEach = function forEach2(list, iterator, thisArg) {
    if (!isCallable2(iterator)) {
      throw new TypeError("iterator must be a function");
    }
    var receiver;
    if (arguments.length >= 3) {
      receiver = thisArg;
    }
    if (isArray(list)) {
      forEachArray(list, iterator, receiver);
    } else if (typeof list === "string") {
      forEachString(list, iterator, receiver);
    } else {
      forEachObject(list, iterator, receiver);
    }
  };
  return forEach;
}
var possibleTypedArrayNames;
var hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
  if (hasRequiredPossibleTypedArrayNames) return possibleTypedArrayNames;
  hasRequiredPossibleTypedArrayNames = 1;
  possibleTypedArrayNames = [
    "Float16Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ];
  return possibleTypedArrayNames;
}
var availableTypedArrays;
var hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var possibleNames = /* @__PURE__ */ requirePossibleTypedArrayNames();
  var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  availableTypedArrays = function availableTypedArrays2() {
    var out = [];
    for (var i = 0; i < possibleNames.length; i++) {
      if (typeof g[possibleNames[i]] === "function") {
        out[out.length] = possibleNames[i];
      }
    }
    return out;
  };
  return availableTypedArrays;
}
var callBind = { exports: {} };
var defineDataProperty;
var hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var $SyntaxError = /* @__PURE__ */ requireSyntax();
  var $TypeError = /* @__PURE__ */ requireType();
  var gopd2 = /* @__PURE__ */ requireGopd();
  defineDataProperty = function defineDataProperty2(obj, property, value) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new $TypeError("`obj` must be an object or a function`");
    }
    if (typeof property !== "string" && typeof property !== "symbol") {
      throw new $TypeError("`property` must be a string or a symbol`");
    }
    if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
      throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
      throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
      throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
      throw new $TypeError("`loose`, if provided, must be a boolean");
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    var desc = !!gopd2 && gopd2(obj, property);
    if ($defineProperty) {
      $defineProperty(obj, property, {
        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
        value,
        writable: nonWritable === null && desc ? desc.writable : !nonWritable
      });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
      obj[property] = value;
    } else {
      throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    }
  };
  return defineDataProperty;
}
var hasPropertyDescriptors_1;
var hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var hasPropertyDescriptors = function hasPropertyDescriptors2() {
    return !!$defineProperty;
  };
  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    if (!$defineProperty) {
      return null;
    }
    try {
      return $defineProperty([], "length", { value: 1 }).length !== 1;
    } catch (e) {
      return true;
    }
  };
  hasPropertyDescriptors_1 = hasPropertyDescriptors;
  return hasPropertyDescriptors_1;
}
var setFunctionLength;
var hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var define = /* @__PURE__ */ requireDefineDataProperty();
  var hasDescriptors = /* @__PURE__ */ requireHasPropertyDescriptors()();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var $TypeError = /* @__PURE__ */ requireType();
  var $floor = GetIntrinsic("%Math.floor%");
  setFunctionLength = function setFunctionLength2(fn, length) {
    if (typeof fn !== "function") {
      throw new $TypeError("`fn` is not a function");
    }
    if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
      throw new $TypeError("`length` must be a positive 32-bit integer");
    }
    var loose = arguments.length > 2 && !!arguments[2];
    var functionLengthIsConfigurable = true;
    var functionLengthIsWritable = true;
    if ("length" in fn && gOPD2) {
      var desc = gOPD2(fn, "length");
      if (desc && !desc.configurable) {
        functionLengthIsConfigurable = false;
      }
      if (desc && !desc.writable) {
        functionLengthIsWritable = false;
      }
    }
    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
      if (hasDescriptors) {
        define(
          /** @type {Parameters<define>[0]} */
          fn,
          "length",
          length,
          true,
          true
        );
      } else {
        define(
          /** @type {Parameters<define>[0]} */
          fn,
          "length",
          length
        );
      }
    }
    return fn;
  };
  return setFunctionLength;
}
var applyBind;
var hasRequiredApplyBind;
function requireApplyBind() {
  if (hasRequiredApplyBind) return applyBind;
  hasRequiredApplyBind = 1;
  var bind2 = requireFunctionBind();
  var $apply = requireFunctionApply();
  var actualApply2 = requireActualApply();
  applyBind = function applyBind2() {
    return actualApply2(bind2, $apply, arguments);
  };
  return applyBind;
}
var hasRequiredCallBind;
function requireCallBind() {
  if (hasRequiredCallBind) return callBind.exports;
  hasRequiredCallBind = 1;
  (function(module) {
    var setFunctionLength2 = /* @__PURE__ */ requireSetFunctionLength();
    var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
    var callBindBasic = requireCallBindApplyHelpers();
    var applyBind2 = requireApplyBind();
    module.exports = function callBind2(originalFunction) {
      var func = callBindBasic(arguments);
      var adjustedLength = originalFunction.length - (arguments.length - 1);
      return setFunctionLength2(
        func,
        1 + (adjustedLength > 0 ? adjustedLength : 0),
        true
      );
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind2 });
    } else {
      module.exports.apply = applyBind2;
    }
  })(callBind);
  return callBind.exports;
}
var whichTypedArray;
var hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray) return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var forEach2 = requireForEach();
  var availableTypedArrays2 = /* @__PURE__ */ requireAvailableTypedArrays();
  var callBind2 = requireCallBind();
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var getProto2 = requireGetProto();
  var $toString = callBound2("Object.prototype.toString");
  var hasToStringTag = requireShams()();
  var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  var typedArrays = availableTypedArrays2();
  var $slice = callBound2("String.prototype.slice");
  var $indexOf = callBound2("Array.prototype.indexOf", true) || function indexOf(array, value) {
    for (var i = 0; i < array.length; i += 1) {
      if (array[i] === value) {
        return i;
      }
    }
    return -1;
  };
  var cache = { __proto__: null };
  if (hasToStringTag && gOPD2 && getProto2) {
    forEach2(typedArrays, function(typedArray) {
      var arr = new g[typedArray]();
      if (Symbol.toStringTag in arr && getProto2) {
        var proto = getProto2(arr);
        var descriptor = gOPD2(proto, Symbol.toStringTag);
        if (!descriptor && proto) {
          var superProto = getProto2(proto);
          descriptor = gOPD2(superProto, Symbol.toStringTag);
        }
        cache["$" + typedArray] = callBind2(descriptor.get);
      }
    });
  } else {
    forEach2(typedArrays, function(typedArray) {
      var arr = new g[typedArray]();
      var fn = arr.slice || arr.set;
      if (fn) {
        cache[
          /** @type {`$${import('.').TypedArrayName}`} */
          "$" + typedArray
        ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
        // @ts-expect-error TODO FIXME
        callBind2(fn);
      }
    });
  }
  var tryTypedArrays = function tryAllTypedArrays(value) {
    var found2 = false;
    forEach2(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      cache,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(getter, typedArray) {
        if (!found2) {
          try {
            if ("$" + getter(value) === typedArray) {
              found2 = /** @type {import('.').TypedArrayName} */
              $slice(typedArray, 1);
            }
          } catch (e) {
          }
        }
      }
    );
    return found2;
  };
  var trySlices = function tryAllSlices(value) {
    var found2 = false;
    forEach2(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      cache,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(getter, name) {
        if (!found2) {
          try {
            getter(value);
            found2 = /** @type {import('.').TypedArrayName} */
            $slice(name, 1);
          } catch (e) {
          }
        }
      }
    );
    return found2;
  };
  whichTypedArray = function whichTypedArray2(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    if (!hasToStringTag) {
      var tag = $slice($toString(value), 8, -1);
      if ($indexOf(typedArrays, tag) > -1) {
        return tag;
      }
      if (tag !== "Object") {
        return false;
      }
      return trySlices(value);
    }
    if (!gOPD2) {
      return null;
    }
    return tryTypedArrays(value);
  };
  return whichTypedArray;
}
var isTypedArray;
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var whichTypedArray2 = /* @__PURE__ */ requireWhichTypedArray();
  isTypedArray = function isTypedArray2(value) {
    return !!whichTypedArray2(value);
  };
  return isTypedArray;
}
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  (function(exports$1) {
    var isArgumentsObject = /* @__PURE__ */ requireIsArguments();
    var isGeneratorFunction2 = requireIsGeneratorFunction();
    var whichTypedArray2 = /* @__PURE__ */ requireWhichTypedArray();
    var isTypedArray2 = /* @__PURE__ */ requireIsTypedArray();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    if (SymbolSupported) {
      var symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports$1.isArgumentsObject = isArgumentsObject;
    exports$1.isGeneratorFunction = isGeneratorFunction2;
    exports$1.isTypedArray = isTypedArray2;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports$1.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray2(value) || isDataView(value);
    }
    exports$1.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray2(value) === "Uint8Array";
    }
    exports$1.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray2(value) === "Uint8ClampedArray";
    }
    exports$1.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray2(value) === "Uint16Array";
    }
    exports$1.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray2(value) === "Uint32Array";
    }
    exports$1.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray2(value) === "Int8Array";
    }
    exports$1.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray2(value) === "Int16Array";
    }
    exports$1.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray2(value) === "Int32Array";
    }
    exports$1.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray2(value) === "Float32Array";
    }
    exports$1.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray2(value) === "Float64Array";
    }
    exports$1.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray2(value) === "BigInt64Array";
    }
    exports$1.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray2(value) === "BigUint64Array";
    }
    exports$1.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports$1.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports$1.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports$1.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports$1.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports$1.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports$1.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports$1.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports$1.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports$1.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports$1.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports$1.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports$1.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports$1.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports$1.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports$1.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports$1.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports$1.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports$1.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports$1.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports$1, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  })(types);
  return types;
}
var isBufferBrowser;
var hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  if (hasRequiredIsBufferBrowser) return isBufferBrowser;
  hasRequiredIsBufferBrowser = 1;
  isBufferBrowser = function isBuffer(arg) {
    return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
  };
  return isBufferBrowser;
}
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  (function(exports$1) {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys2 = Object.keys(obj);
      var descriptors = {};
      for (var i = 0; i < keys2.length; i++) {
        descriptors[keys2[i]] = Object.getOwnPropertyDescriptor(obj, keys2[i]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports$1.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(" ");
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x3) {
        if (x3 === "%%") return "%";
        if (i >= len) return x3;
        switch (x3) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_2) {
              return "[Circular]";
            }
          default:
            return x3;
        }
      });
      for (var x2 = args[i]; i < len; x2 = args[++i]) {
        if (isNull(x2) || !isObject2(x2)) {
          str += " " + x2;
        } else {
          str += " " + inspect(x2);
        }
      }
      return str;
    };
    exports$1.deprecate = function(fn, msg) {
      if (typeof process$1 !== "undefined" && process$1.noDeprecation === true) {
        return fn;
      }
      if (typeof process$1 === "undefined") {
        return function() {
          return exports$1.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process$1.throwDeprecation) {
            throw new Error(msg);
          } else if (process$1.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var debugEnv = process$1.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    exports$1.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process$1.pid;
          debugs[set] = function() {
            var msg = exports$1.format.apply(exports$1, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports$1._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports$1.inspect = inspect;
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports$1.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys2 = Object.keys(value);
      var visibleKeys = arrayToHash(keys2);
      if (ctx.showHidden) {
        keys2 = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys2.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp2(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = "", array = false, braces = ["{", "}"];
      if (isArray(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n = value.name ? ": " + value.name : "";
        base = " [Function" + n + "]";
      }
      if (isRegExp2(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = " " + formatError(value);
      }
      if (keys2.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp2(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
      } else {
        output = keys2.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
      var output = [];
      for (var i = 0, l3 = value.length; i < l3; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i),
            true
          ));
        } else {
          output.push("");
        }
      }
      keys2.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key,
            true
          ));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, -1);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function(prev, cur) {
        if (cur.indexOf("\n") >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }
    exports$1.types = requireTypes();
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports$1.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports$1.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports$1.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports$1.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports$1.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports$1.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports$1.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports$1.isUndefined = isUndefined;
    function isRegExp2(re2) {
      return isObject2(re2) && objectToString(re2) === "[object RegExp]";
    }
    exports$1.isRegExp = isRegExp2;
    exports$1.types.isRegExp = isRegExp2;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports$1.isObject = isObject2;
    function isDate(d2) {
      return isObject2(d2) && objectToString(d2) === "[object Date]";
    }
    exports$1.isDate = isDate;
    exports$1.types.isDate = isDate;
    function isError(e) {
      return isObject2(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports$1.isError = isError;
    exports$1.types.isNativeError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports$1.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports$1.isPrimitive = isPrimitive;
    exports$1.isBuffer = requireIsBufferBrowser();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d2 = /* @__PURE__ */ new Date();
      var time = [
        pad(d2.getHours()),
        pad(d2.getMinutes()),
        pad(d2.getSeconds())
      ].join(":");
      return [d2.getDate(), months[d2.getMonth()], time].join(" ");
    }
    exports$1.log = function() {
      console.log("%s - %s", timestamp(), exports$1.format.apply(exports$1, arguments));
    };
    exports$1.inherits = requireInherits_browser();
    exports$1._extend = function(origin, add) {
      if (!add || !isObject2(add)) return origin;
      var keys2 = Object.keys(add);
      var i = keys2.length;
      while (i--) {
        origin[keys2[i]] = add[keys2[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports$1.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original)
      );
    };
    exports$1.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            process$1.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            process$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports$1.callbackify = callbackify;
  })(util);
  return util;
}
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(input);
  }
  var _require = requireDist(), Buffer3 = _require.Buffer;
  var _require2 = requireUtil(), inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer3.prototype.copy.call(src, target, offset);
  }
  buffer_list = /* @__PURE__ */ (function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v2) {
        var entry = {
          data: v2,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v2) {
        var entry = {
          data: v2,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join2(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) ret += s + p.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0) return Buffer3.alloc(0);
        var ret = Buffer3.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length) ret += str;
          else ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer3.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value(_2, options) {
        return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  })();
  return buffer_list;
}
var destroy_1;
var hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process$1.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process$1.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process$1.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose) return;
    if (self2._readableState && !self2._readableState.emitClose) return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit("error", err);
  }
  destroy_1 = {
    destroy,
    undestroy,
    errorOrDestroy
  };
  return destroy_1;
}
var errorsBrowser = {};
var hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var codes = {};
  function createErrorType(code2, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    var NodeError = /* @__PURE__ */ (function(_Base) {
      _inheritsLoose(NodeError2, _Base);
      function NodeError2(arg1, arg2, arg3) {
        return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
      }
      return NodeError2;
    })(Base);
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code2;
    codes[code2] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      var len = expected.length;
      expected = expected.map(function(i) {
        return String(i);
      });
      if (len > 2) {
        return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
      } else if (len === 2) {
        return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
      } else {
        return "of ".concat(thing, " ").concat(expected[0]);
      }
    } else {
      return "of ".concat(thing, " ").concat(String(expected));
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(0, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    var determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    var msg;
    if (endsWith(name, " argument")) {
      msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    } else {
      var type2 = includes(name, ".") ? "property" : "argument";
      msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    }
    msg += ". Received type ".concat(typeof actual);
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  errorsBrowser.codes = codes;
  return errorsBrowser;
}
var state;
var hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var ERR_INVALID_OPT_VALUE = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state2, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state2.objectMode ? 16 : 16 * 1024;
  }
  state = {
    getHighWaterMark
  };
  return state;
}
var browser;
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  browser = deprecate;
  function deprecate(fn, msg) {
    if (config2("noDeprecation")) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (config2("throwDeprecation")) {
          throw new Error(msg);
        } else if (config2("traceDeprecation")) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  }
  function config2(name) {
    try {
      if (!commonjsGlobal.localStorage) return false;
    } catch (_2) {
      return false;
    }
    var val = commonjsGlobal.localStorage[name];
    if (null == val) return false;
    return String(val).toLowerCase() === "true";
  }
  return browser;
}
var _stream_writable;
var hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  _stream_writable = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: requireBrowser()
  };
  var Stream = requireStreamBrowser();
  var Buffer3 = requireDist().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer3.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  requireInherits_browser()(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream, er);
    process$1.nextTick(cb, er);
  }
  function validChunk(stream, state2, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process$1.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer3.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer3.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (state2.destroyed) state2.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev) stream._writev(chunk, state2.onwrite);
    else stream._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream, state2, sync, er, cb) {
    --state2.pendingcb;
    if (sync) {
      process$1.nextTick(cb, er);
      process$1.nextTick(finishMaybe, stream, state2);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream, er) {
    var state2 = stream._writableState;
    var sync = state2.sync;
    var cb = state2.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream, state2, sync, er, cb);
    else {
      var finished = needFinish(state2) || stream.destroyed;
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream, state2);
      }
      if (sync) {
        process$1.nextTick(afterWrite, stream, state2, finished, cb);
      } else {
        afterWrite(stream, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream, state2, finished, cb) {
    if (!finished) onwriteDrain(stream, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream, state2);
  }
  function onwriteDrain(stream, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l3 = state2.bufferedRequestCount;
      var buffer2 = new Array(l3);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream, state2) {
    stream._final(function(err) {
      state2.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state2.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state2);
    });
  }
  function prefinish(stream, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream._final === "function" && !state2.destroyed) {
        state2.pendingcb++;
        state2.finalCalled = true;
        process$1.nextTick(callFinal, stream, state2);
      } else {
        state2.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream.emit("finish");
        if (state2.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state2, cb) {
    state2.ending = true;
    finishMaybe(stream, state2);
    if (cb) {
      if (state2.finished) process$1.nextTick(cb);
      else stream.once("finish", cb);
    }
    state2.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return _stream_writable;
}
var _stream_duplex;
var hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var objectKeys = Object.keys || function(obj) {
    var keys3 = [];
    for (var key in obj) keys3.push(key);
    return keys3;
  };
  _stream_duplex = Duplex;
  var Readable = require_stream_readable();
  var Writable = require_stream_writable();
  requireInherits_browser()(Duplex, Readable);
  {
    var keys2 = objectKeys(Writable.prototype);
    for (var v2 = 0; v2 < keys2.length; v2++) {
      var method = keys2[v2];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false) this.readable = false;
      if (options.writable === false) this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended) return;
    process$1.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return _stream_duplex;
}
var string_decoder = {};
var safeBuffer = { exports: {} };
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function(module, exports$1) {
    var buffer2 = requireDist();
    var Buffer3 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports$1);
      exports$1.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer3(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var Buffer3 = requireSafeBuffer().Buffer;
  var isEncoding = Buffer3.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer3.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer3.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0) return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j2 = buf.length - 1;
    if (j2 < i) return 0;
    var nb = utf8CheckByte(buf[j2]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j2 < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j2]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j2 < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j2]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder;
}
var endOfStream;
var hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var ERR_STREAM_PREMATURE_CLOSE = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop2() {
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts, callback) {
    if (typeof opts === "function") return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once(callback || noop2);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream.writable) onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable) callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable) callback.call(stream);
    };
    var onerror = function onerror2(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest2() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req) onrequest();
      else stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req) stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  endOfStream = eos;
  return endOfStream;
}
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var finished = requireEndOfStream();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    process$1.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process$1.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve = iterator[kLastResolve];
      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  async_iterator = createReadableStreamAsyncIterator;
  return async_iterator;
}
var fromBrowser;
var hasRequiredFromBrowser;
function requireFromBrowser() {
  if (hasRequiredFromBrowser) return fromBrowser;
  hasRequiredFromBrowser = 1;
  fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return fromBrowser;
}
var _stream_readable;
var hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  _stream_readable = Readable;
  var Duplex;
  Readable.ReadableState = ReadableState;
  requireEvents().EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream = requireStreamBrowser();
  var Buffer3 = requireDist().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer3.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = requireUtil();
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug2() {
    };
  }
  var BufferList = requireBuffer_list();
  var destroyImpl = requireDestroy();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  requireInherits_browser()(Readable, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!(this instanceof Readable)) return new Readable(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer3.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state2 = stream._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else addChunk(stream, state2, chunk, true);
        } else if (state2.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state2.destroyed) {
          return false;
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream, state2, chunk, false);
            else maybeReadMore(stream, state2);
          } else {
            addChunk(stream, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
        maybeReadMore(stream, state2);
      }
    }
    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
  }
  function addChunk(stream, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      state2.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
      debug("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = state2.length <= state2.highWaterMark;
      n = 0;
    } else {
      state2.length -= n;
      state2.awaitDrain = 0;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state2) {
    debug("onEofChunk");
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    if (state2.sync) {
      emitReadable(stream);
    } else {
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        state2.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state2 = stream._readableState;
    debug("emitReadable", state2.needReadable, state2.emittedReadable);
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      process$1.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state2 = stream._readableState;
    debug("emitReadable_", state2.destroyed, state2.length, state2.ended);
    if (!state2.destroyed && (state2.length || state2.ended)) {
      stream.emit("readable");
      state2.emittedReadable = false;
    }
    state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      process$1.nextTick(maybeReadMore_, stream, state2);
    }
  }
  function maybeReadMore_(stream, state2) {
    while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
      var len = state2.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state2.length)
        break;
    }
    state2.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) process$1.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state2.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state2 = src._readableState;
      debug("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state2.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
        hasUnpiped: false
      });
      return this;
    }
    var index2 = indexOf(state2.pipes, dest);
    if (index2 === -1) return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state2 = this._readableState;
    if (ev === "data") {
      state2.readableListening = this.listenerCount("readable") > 0;
      if (state2.flowing !== false) this.resume();
    } else if (ev === "readable") {
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.flowing = false;
        state2.emittedReadable = false;
        debug("on readable", state2.length, state2.reading);
        if (state2.length) {
          emitReadable(this);
        } else if (!state2.reading) {
          process$1.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state2 = self2._readableState;
    state2.readableListening = self2.listenerCount("readable") > 0;
    if (state2.resumeScheduled && !state2.paused) {
      state2.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug("resume");
      state2.flowing = !state2.readableListening;
      resume(this, state2);
    }
    state2.paused = false;
    return this;
  };
  function resume(stream, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      process$1.nextTick(resume_, stream, state2);
    }
  }
  function resume_(stream, state2) {
    debug("resume", state2.reading);
    if (!state2.reading) {
      stream.read(0);
    }
    state2.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state2.flowing && !state2.reading) stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state2 = stream._readableState;
    debug("flow", state2.flowing);
    while (state2.flowing && stream.read() !== null) ;
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === void 0 && typeof stream[i] === "function") {
        this[i] = /* @__PURE__ */ (function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        })(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = requireAsync_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.flowing;
    },
    set: function set(state2) {
      if (this._readableState) {
        this._readableState.flowing = state2;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.length;
    }
  });
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.first();
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = state2.buffer.consume(n, state2.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state2 = stream._readableState;
    debug("endReadable", state2.endEmitted);
    if (!state2.endEmitted) {
      state2.ended = true;
      process$1.nextTick(endReadableNT, state2, stream);
    }
  }
  function endReadableNT(state2, stream) {
    debug("endReadableNT", state2.endEmitted, state2.length);
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state2.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from === void 0) {
        from = requireFromBrowser();
      }
      return from(Readable, iterable, opts);
    };
  }
  function indexOf(xs, x2) {
    for (var i = 0, l3 = xs.length; i < l3; i++) {
      if (xs[i] === x2) return i;
    }
    return -1;
  }
  return _stream_readable;
}
var _stream_transform;
var hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1;
  _stream_transform = Transform2;
  var _require$codes = requireErrorsBrowser().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require_stream_duplex();
  requireInherits_browser()(Transform2, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform2(options) {
    if (!(this instanceof Transform2)) return new Transform2(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform2.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform2.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform2.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform2.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform2.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough;
var hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1;
  _stream_passthrough = PassThrough;
  var Transform2 = require_stream_transform();
  requireInherits_browser()(PassThrough, Transform2);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform2.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough;
}
var pipeline_1;
var hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var eos;
  function once(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = requireErrorsBrowser().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop2(err) {
    if (err) throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === void 0) eos = requireEndOfStream();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err) return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed) return;
      if (destroyed) return;
      destroyed = true;
      if (isRequest(stream)) return stream.abort();
      if (typeof stream.destroy === "function") return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length) return noop2;
    if (typeof streams[streams.length - 1] !== "function") return noop2;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error) error = err;
        if (err) destroys.forEach(call);
        if (reading) return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  pipeline_1 = pipeline;
  return pipeline_1;
}
var streamBrowserify;
var hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify) return streamBrowserify;
  hasRequiredStreamBrowserify = 1;
  streamBrowserify = Stream;
  var EE = requireEvents().EventEmitter;
  var inherits = requireInherits_browser();
  inherits(Stream, EE);
  Stream.Readable = require_stream_readable();
  Stream.Writable = require_stream_writable();
  Stream.Duplex = require_stream_duplex();
  Stream.Transform = require_stream_transform();
  Stream.PassThrough = require_stream_passthrough();
  Stream.finished = requireEndOfStream();
  Stream.pipeline = requirePipeline();
  Stream.Stream = Stream;
  function Stream() {
    EE.call(this);
  }
  Stream.prototype.pipe = function(dest, options) {
    var source = this;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on("end", onend);
      source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd) return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd) return;
      didOnEnd = true;
      if (typeof dest.destroy === "function") dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this, "error") === 0) {
        throw er;
      }
    }
    source.on("error", onerror);
    dest.on("error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
  return streamBrowserify;
}
var hasRequiredSax;
function requireSax() {
  if (hasRequiredSax) return sax;
  hasRequiredSax = 1;
  (function(exports$1) {
    (function(sax2) {
      sax2.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax2.SAXParser = SAXParser;
      sax2.SAXStream = SAXStream;
      sax2.createStream = createStream;
      sax2.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax2.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S2.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        if (parser.opt.unquotedAttributeValues === void 0) {
          parser.opt.unquotedAttributeValues = !strict;
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F2() {
          }
          F2.prototype = o;
          var newf = new F2();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l3 = buffers.length; i < l3; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m2 = sax2.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m2 + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l3 = buffers.length; i < l3; i++) {
          parser[buffers[i]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream;
      try {
        Stream = requireStreamBrowserify().Stream;
      } catch (ex) {
        Stream = function() {
        };
      }
      if (!Stream) Stream = function() {
      };
      var streamWraps = sax2.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me2 = this;
        this._parser.onend = function() {
          me2.emit("end");
        };
        this._parser.onerror = function(er) {
          me2.emit("error", er);
          me2._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me2, "on" + ev, {
            get: function() {
              return me2._parser["on" + ev];
            },
            set: function(h) {
              if (!h) {
                me2.removeAllListeners(ev);
                me2._parser["on" + ev] = h;
                return h;
              }
              me2.on(ev, h);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer2 === "function" && typeof Buffer2.isBuffer === "function" && Buffer2.isBuffer(data)) {
          if (!this._decoder) {
            var SD = requireString_decoder().StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler2) {
        var me2 = this;
        if (!me2._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me2._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me2.emit.apply(me2, args);
          };
        }
        return Stream.prototype.on.call(me2, ev, handler2);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S2 = 0;
      sax2.STATE = {
        BEGIN: S2++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S2++,
        // leading whitespace
        TEXT: S2++,
        // general stuff
        TEXT_ENTITY: S2++,
        // &amp and such.
        OPEN_WAKA: S2++,
        // <
        SGML_DECL: S2++,
        // <!BLARG
        SGML_DECL_QUOTED: S2++,
        // <!BLARG foo "bar
        DOCTYPE: S2++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S2++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S2++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S2++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S2++,
        // <!-
        COMMENT: S2++,
        // <!--
        COMMENT_ENDING: S2++,
        // <!-- blah -
        COMMENT_ENDED: S2++,
        // <!-- blah --
        CDATA: S2++,
        // <![CDATA[ something
        CDATA_ENDING: S2++,
        // ]
        CDATA_ENDING_2: S2++,
        // ]]
        PROC_INST: S2++,
        // <?hi
        PROC_INST_BODY: S2++,
        // <?hi there
        PROC_INST_ENDING: S2++,
        // <?hi "there" ?
        OPEN_TAG: S2++,
        // <strong
        OPEN_TAG_SLASH: S2++,
        // <strong /
        ATTRIB: S2++,
        // <a
        ATTRIB_NAME: S2++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S2++,
        // <a foo _
        ATTRIB_VALUE: S2++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S2++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S2++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S2++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S2++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S2++,
        // <foo bar=&quot
        CLOSE_TAG: S2++,
        // </a
        CLOSE_TAG_SAW_WHITE: S2++,
        // </a   >
        SCRIPT: S2++,
        // <script> ...
        SCRIPT_ENDING: S2++
        // <script> ... <
      };
      sax2.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      };
      sax2.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      };
      Object.keys(sax2.ENTITIES).forEach(function(key) {
        var e = sax2.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax2.ENTITIES[key] = s2;
      });
      for (var s in sax2.STATE) {
        sax2.STATE[sax2.STATE[s]] = s;
      }
      S2 = sax2.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot)
          strictFail(parser, "Unclosed root tag");
        if (parser.state !== S2.BEGIN && parser.state !== S2.BEGIN_WHITESPACE && parser.state !== S2.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(
              parser,
              "Unbound namespace prefix: " + JSON.stringify(parser.tagName)
            );
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0, l3 = parser.attribList.length; i < l3; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri2 = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri: uri2
            };
            if (prefix && prefix !== "xmlns" && !uri2) {
              strictFail(
                parser,
                "Unbound namespace prefix: " + JSON.stringify(prefix)
              );
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S2.SCRIPT;
          } else {
            parser.state = S2.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S2.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S2.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close2 = parser.tags[t];
          if (close2.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S2.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x2 = {};
          for (var i in tag.ns) {
            x2[i] = tag.ns[i];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S2.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity || num < 0 || num > 1114111) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S2.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S2.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S2.BEGIN:
              parser.state = S2.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S2.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S2.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S2.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S2.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S2.SCRIPT:
              if (c === "<") {
                parser.state = S2.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S2.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S2.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S2.SCRIPT;
              }
              continue;
            case S2.OPEN_WAKA:
              if (c === "!") {
                parser.state = S2.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c)) ;
              else if (isMatch(nameStart, c)) {
                parser.state = S2.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S2.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S2.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S2.TEXT;
              }
              continue;
            case S2.SGML_DECL:
              if (parser.sgmlDecl + c === "--") {
                parser.state = S2.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
                continue;
              }
              if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
                parser.state = S2.DOCTYPE_DTD;
                parser.doctype += "<!" + parser.sgmlDecl + c;
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S2.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S2.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S2.TEXT;
              } else if (isQuote(c)) {
                parser.state = S2.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S2.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S2.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S2.DOCTYPE:
              if (c === ">") {
                parser.state = S2.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S2.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S2.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S2.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S2.DOCTYPE;
              }
              continue;
            case S2.DOCTYPE_DTD:
              if (c === "]") {
                parser.doctype += c;
                parser.state = S2.DOCTYPE;
              } else if (c === "<") {
                parser.state = S2.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else if (isQuote(c)) {
                parser.doctype += c;
                parser.state = S2.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              } else {
                parser.doctype += c;
              }
              continue;
            case S2.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S2.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S2.COMMENT:
              if (c === "-") {
                parser.state = S2.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S2.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S2.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S2.COMMENT;
              }
              continue;
            case S2.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S2.COMMENT;
              } else if (parser.doctype && parser.doctype !== true) {
                parser.state = S2.DOCTYPE_DTD;
              } else {
                parser.state = S2.TEXT;
              }
              continue;
            case S2.CDATA:
              var starti = i - 1;
              while (c && c !== "]") {
                c = charAt(chunk, i++);
                if (c && parser.trackPosition) {
                  parser.position++;
                  if (c === "\n") {
                    parser.line++;
                    parser.column = 0;
                  } else {
                    parser.column++;
                  }
                }
              }
              parser.cdata += chunk.substring(starti, i - 1);
              if (c === "]") {
                parser.state = S2.CDATA_ENDING;
              }
              continue;
            case S2.CDATA_ENDING:
              if (c === "]") {
                parser.state = S2.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S2.CDATA;
              }
              continue;
            case S2.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S2.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S2.CDATA;
              }
              continue;
            case S2.PROC_INST:
              if (c === "?") {
                parser.state = S2.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser.state = S2.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S2.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S2.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S2.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S2.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S2.PROC_INST_BODY;
              }
              continue;
            case S2.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S2.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S2.ATTRIB;
                }
              }
              continue;
            case S2.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(
                  parser,
                  "Forward-slash in opening tag not followed by >"
                );
                parser.state = S2.ATTRIB;
              }
              continue;
            case S2.ATTRIB:
              if (isWhitespace(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S2.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S2.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S2.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) {
                parser.state = S2.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S2.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S2.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S2.ATTRIB;
                }
              }
              continue;
            case S2.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S2.ATTRIB_VALUE_QUOTED;
              } else {
                if (!parser.opt.unquotedAttributeValues) {
                  error(parser, "Unquoted attribute value");
                }
                parser.state = S2.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S2.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S2.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S2.ATTRIB_VALUE_CLOSED;
              continue;
            case S2.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser.state = S2.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S2.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S2.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S2.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S2.ATTRIB;
              }
              continue;
            case S2.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S2.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S2.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S2.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S2.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S2.TEXT_ENTITY:
            case S2.ATTRIB_VALUE_ENTITY_Q:
            case S2.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer2;
              switch (parser.state) {
                case S2.TEXT_ENTITY:
                  returnState = S2.TEXT;
                  buffer2 = "textNode";
                  break;
                case S2.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S2.ATTRIB_VALUE_QUOTED;
                  buffer2 = "attribValue";
                  break;
                case S2.ATTRIB_VALUE_ENTITY_U:
                  returnState = S2.ATTRIB_VALUE_UNQUOTED;
                  buffer2 = "attribValue";
                  break;
              }
              if (c === ";") {
                var parsedEntity = parseEntity(parser);
                if (parser.opt.unparsedEntities && !Object.values(sax2.XML_ENTITIES).includes(parsedEntity)) {
                  parser.entity = "";
                  parser.state = returnState;
                  parser.write(parsedEntity);
                } else {
                  parser[buffer2] += parsedEntity;
                  parser.entity = "";
                  parser.state = returnState;
                }
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer2] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default: {
              throw new Error(parser, "Unknown state: " + parser.state);
            }
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor2 = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index2 = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index2 < length) {
              var codePoint = Number(arguments[index2]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor2(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index2 + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(exports$1);
  })(sax);
  return sax;
}
var arrayHelper;
var hasRequiredArrayHelper;
function requireArrayHelper() {
  if (hasRequiredArrayHelper) return arrayHelper;
  hasRequiredArrayHelper = 1;
  arrayHelper = {
    isArray: function(value) {
      if (Array.isArray) {
        return Array.isArray(value);
      }
      return Object.prototype.toString.call(value) === "[object Array]";
    }
  };
  return arrayHelper;
}
var optionsHelper;
var hasRequiredOptionsHelper;
function requireOptionsHelper() {
  if (hasRequiredOptionsHelper) return optionsHelper;
  hasRequiredOptionsHelper = 1;
  var isArray = requireArrayHelper().isArray;
  optionsHelper = {
    copyOptions: function(options) {
      var key, copy2 = {};
      for (key in options) {
        if (options.hasOwnProperty(key)) {
          copy2[key] = options[key];
        }
      }
      return copy2;
    },
    ensureFlagExists: function(item, options) {
      if (!(item in options) || typeof options[item] !== "boolean") {
        options[item] = false;
      }
    },
    ensureSpacesExists: function(options) {
      if (!("spaces" in options) || typeof options.spaces !== "number" && typeof options.spaces !== "string") {
        options.spaces = 0;
      }
    },
    ensureAlwaysArrayExists: function(options) {
      if (!("alwaysArray" in options) || typeof options.alwaysArray !== "boolean" && !isArray(options.alwaysArray)) {
        options.alwaysArray = false;
      }
    },
    ensureKeyExists: function(key, options) {
      if (!(key + "Key" in options) || typeof options[key + "Key"] !== "string") {
        options[key + "Key"] = options.compact ? "_" + key : key;
      }
    },
    checkFnExists: function(key, options) {
      return key + "Fn" in options;
    }
  };
  return optionsHelper;
}
var xml2js;
var hasRequiredXml2js;
function requireXml2js() {
  if (hasRequiredXml2js) return xml2js;
  hasRequiredXml2js = 1;
  var sax2 = requireSax();
  var helper = requireOptionsHelper();
  var isArray = requireArrayHelper().isArray;
  var options;
  var currentElement;
  function validateOptions(userOptions) {
    options = helper.copyOptions(userOptions);
    helper.ensureFlagExists("ignoreDeclaration", options);
    helper.ensureFlagExists("ignoreInstruction", options);
    helper.ensureFlagExists("ignoreAttributes", options);
    helper.ensureFlagExists("ignoreText", options);
    helper.ensureFlagExists("ignoreComment", options);
    helper.ensureFlagExists("ignoreCdata", options);
    helper.ensureFlagExists("ignoreDoctype", options);
    helper.ensureFlagExists("compact", options);
    helper.ensureFlagExists("alwaysChildren", options);
    helper.ensureFlagExists("addParent", options);
    helper.ensureFlagExists("trim", options);
    helper.ensureFlagExists("nativeType", options);
    helper.ensureFlagExists("nativeTypeAttributes", options);
    helper.ensureFlagExists("sanitize", options);
    helper.ensureFlagExists("instructionHasAttributes", options);
    helper.ensureFlagExists("captureSpacesBetweenElements", options);
    helper.ensureAlwaysArrayExists(options);
    helper.ensureKeyExists("declaration", options);
    helper.ensureKeyExists("instruction", options);
    helper.ensureKeyExists("attributes", options);
    helper.ensureKeyExists("text", options);
    helper.ensureKeyExists("comment", options);
    helper.ensureKeyExists("cdata", options);
    helper.ensureKeyExists("doctype", options);
    helper.ensureKeyExists("type", options);
    helper.ensureKeyExists("name", options);
    helper.ensureKeyExists("elements", options);
    helper.ensureKeyExists("parent", options);
    helper.checkFnExists("doctype", options);
    helper.checkFnExists("instruction", options);
    helper.checkFnExists("cdata", options);
    helper.checkFnExists("comment", options);
    helper.checkFnExists("text", options);
    helper.checkFnExists("instructionName", options);
    helper.checkFnExists("elementName", options);
    helper.checkFnExists("attributeName", options);
    helper.checkFnExists("attributeValue", options);
    helper.checkFnExists("attributes", options);
    return options;
  }
  function nativeType(value) {
    var nValue = Number(value);
    if (!isNaN(nValue)) {
      return nValue;
    }
    var bValue = value.toLowerCase();
    if (bValue === "true") {
      return true;
    } else if (bValue === "false") {
      return false;
    }
    return value;
  }
  function addField(type2, value) {
    var key;
    if (options.compact) {
      if (!currentElement[options[type2 + "Key"]] && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(options[type2 + "Key"]) !== -1 : options.alwaysArray)) {
        currentElement[options[type2 + "Key"]] = [];
      }
      if (currentElement[options[type2 + "Key"]] && !isArray(currentElement[options[type2 + "Key"]])) {
        currentElement[options[type2 + "Key"]] = [currentElement[options[type2 + "Key"]]];
      }
      if (type2 + "Fn" in options && typeof value === "string") {
        value = options[type2 + "Fn"](value, currentElement);
      }
      if (type2 === "instruction" && ("instructionFn" in options || "instructionNameFn" in options)) {
        for (key in value) {
          if (value.hasOwnProperty(key)) {
            if ("instructionFn" in options) {
              value[key] = options.instructionFn(value[key], key, currentElement);
            } else {
              var temp = value[key];
              delete value[key];
              value[options.instructionNameFn(key, temp, currentElement)] = temp;
            }
          }
        }
      }
      if (isArray(currentElement[options[type2 + "Key"]])) {
        currentElement[options[type2 + "Key"]].push(value);
      } else {
        currentElement[options[type2 + "Key"]] = value;
      }
    } else {
      if (!currentElement[options.elementsKey]) {
        currentElement[options.elementsKey] = [];
      }
      var element = {};
      element[options.typeKey] = type2;
      if (type2 === "instruction") {
        for (key in value) {
          if (value.hasOwnProperty(key)) {
            break;
          }
        }
        element[options.nameKey] = "instructionNameFn" in options ? options.instructionNameFn(key, value, currentElement) : key;
        if (options.instructionHasAttributes) {
          element[options.attributesKey] = value[key][options.attributesKey];
          if ("instructionFn" in options) {
            element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement);
          }
        } else {
          if ("instructionFn" in options) {
            value[key] = options.instructionFn(value[key], key, currentElement);
          }
          element[options.instructionKey] = value[key];
        }
      } else {
        if (type2 + "Fn" in options) {
          value = options[type2 + "Fn"](value, currentElement);
        }
        element[options[type2 + "Key"]] = value;
      }
      if (options.addParent) {
        element[options.parentKey] = currentElement;
      }
      currentElement[options.elementsKey].push(element);
    }
  }
  function manipulateAttributes(attributes) {
    if ("attributesFn" in options && attributes) {
      attributes = options.attributesFn(attributes, currentElement);
    }
    if ((options.trim || "attributeValueFn" in options || "attributeNameFn" in options || options.nativeTypeAttributes) && attributes) {
      var key;
      for (key in attributes) {
        if (attributes.hasOwnProperty(key)) {
          if (options.trim) attributes[key] = attributes[key].trim();
          if (options.nativeTypeAttributes) {
            attributes[key] = nativeType(attributes[key]);
          }
          if ("attributeValueFn" in options) attributes[key] = options.attributeValueFn(attributes[key], key, currentElement);
          if ("attributeNameFn" in options) {
            var temp = attributes[key];
            delete attributes[key];
            attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;
          }
        }
      }
    }
    return attributes;
  }
  function onInstruction(instruction) {
    var attributes = {};
    if (instruction.body && (instruction.name.toLowerCase() === "xml" || options.instructionHasAttributes)) {
      var attrsRegExp = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g;
      var match;
      while ((match = attrsRegExp.exec(instruction.body)) !== null) {
        attributes[match[1]] = match[2] || match[3] || match[4];
      }
      attributes = manipulateAttributes(attributes);
    }
    if (instruction.name.toLowerCase() === "xml") {
      if (options.ignoreDeclaration) {
        return;
      }
      currentElement[options.declarationKey] = {};
      if (Object.keys(attributes).length) {
        currentElement[options.declarationKey][options.attributesKey] = attributes;
      }
      if (options.addParent) {
        currentElement[options.declarationKey][options.parentKey] = currentElement;
      }
    } else {
      if (options.ignoreInstruction) {
        return;
      }
      if (options.trim) {
        instruction.body = instruction.body.trim();
      }
      var value = {};
      if (options.instructionHasAttributes && Object.keys(attributes).length) {
        value[instruction.name] = {};
        value[instruction.name][options.attributesKey] = attributes;
      } else {
        value[instruction.name] = instruction.body;
      }
      addField("instruction", value);
    }
  }
  function onStartElement(name, attributes) {
    var element;
    if (typeof name === "object") {
      attributes = name.attributes;
      name = name.name;
    }
    attributes = manipulateAttributes(attributes);
    if ("elementNameFn" in options) {
      name = options.elementNameFn(name, currentElement);
    }
    if (options.compact) {
      element = {};
      if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
        element[options.attributesKey] = {};
        var key;
        for (key in attributes) {
          if (attributes.hasOwnProperty(key)) {
            element[options.attributesKey][key] = attributes[key];
          }
        }
      }
      if (!(name in currentElement) && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)) {
        currentElement[name] = [];
      }
      if (currentElement[name] && !isArray(currentElement[name])) {
        currentElement[name] = [currentElement[name]];
      }
      if (isArray(currentElement[name])) {
        currentElement[name].push(element);
      } else {
        currentElement[name] = element;
      }
    } else {
      if (!currentElement[options.elementsKey]) {
        currentElement[options.elementsKey] = [];
      }
      element = {};
      element[options.typeKey] = "element";
      element[options.nameKey] = name;
      if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
        element[options.attributesKey] = attributes;
      }
      if (options.alwaysChildren) {
        element[options.elementsKey] = [];
      }
      currentElement[options.elementsKey].push(element);
    }
    element[options.parentKey] = currentElement;
    currentElement = element;
  }
  function onText(text) {
    if (options.ignoreText) {
      return;
    }
    if (!text.trim() && !options.captureSpacesBetweenElements) {
      return;
    }
    if (options.trim) {
      text = text.trim();
    }
    if (options.nativeType) {
      text = nativeType(text);
    }
    if (options.sanitize) {
      text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    addField("text", text);
  }
  function onComment(comment) {
    if (options.ignoreComment) {
      return;
    }
    if (options.trim) {
      comment = comment.trim();
    }
    addField("comment", comment);
  }
  function onEndElement(name) {
    var parentElement = currentElement[options.parentKey];
    if (!options.addParent) {
      delete currentElement[options.parentKey];
    }
    currentElement = parentElement;
  }
  function onCdata(cdata) {
    if (options.ignoreCdata) {
      return;
    }
    if (options.trim) {
      cdata = cdata.trim();
    }
    addField("cdata", cdata);
  }
  function onDoctype(doctype) {
    if (options.ignoreDoctype) {
      return;
    }
    doctype = doctype.replace(/^ /, "");
    if (options.trim) {
      doctype = doctype.trim();
    }
    addField("doctype", doctype);
  }
  function onError(error) {
    error.note = error;
  }
  xml2js = function(xml, userOptions) {
    var parser = sax2.parser(true, {});
    var result = {};
    currentElement = result;
    options = validateOptions(userOptions);
    {
      parser.opt = { strictEntities: true };
      parser.onopentag = onStartElement;
      parser.ontext = onText;
      parser.oncomment = onComment;
      parser.onclosetag = onEndElement;
      parser.onerror = onError;
      parser.oncdata = onCdata;
      parser.ondoctype = onDoctype;
      parser.onprocessinginstruction = onInstruction;
    }
    {
      parser.write(xml).close();
    }
    if (result[options.elementsKey]) {
      var temp = result[options.elementsKey];
      delete result[options.elementsKey];
      result[options.elementsKey] = temp;
      delete result.text;
    }
    return result;
  };
  return xml2js;
}
var xml2json;
var hasRequiredXml2json;
function requireXml2json() {
  if (hasRequiredXml2json) return xml2json;
  hasRequiredXml2json = 1;
  var helper = requireOptionsHelper();
  var xml2js2 = requireXml2js();
  function validateOptions(userOptions) {
    var options = helper.copyOptions(userOptions);
    helper.ensureSpacesExists(options);
    return options;
  }
  xml2json = function(xml, userOptions) {
    var options, js, json, parentKey;
    options = validateOptions(userOptions);
    js = xml2js2(xml, options);
    parentKey = "compact" in options && options.compact ? "_parent" : "parent";
    if ("addParent" in options && options.addParent) {
      json = JSON.stringify(js, function(k2, v2) {
        return k2 === parentKey ? "_" : v2;
      }, options.spaces);
    } else {
      json = JSON.stringify(js, null, options.spaces);
    }
    return json.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  };
  return xml2json;
}
var js2xml;
var hasRequiredJs2xml;
function requireJs2xml() {
  if (hasRequiredJs2xml) return js2xml;
  hasRequiredJs2xml = 1;
  var helper = requireOptionsHelper();
  var isArray = requireArrayHelper().isArray;
  var currentElement, currentElementName;
  function validateOptions(userOptions) {
    var options = helper.copyOptions(userOptions);
    helper.ensureFlagExists("ignoreDeclaration", options);
    helper.ensureFlagExists("ignoreInstruction", options);
    helper.ensureFlagExists("ignoreAttributes", options);
    helper.ensureFlagExists("ignoreText", options);
    helper.ensureFlagExists("ignoreComment", options);
    helper.ensureFlagExists("ignoreCdata", options);
    helper.ensureFlagExists("ignoreDoctype", options);
    helper.ensureFlagExists("compact", options);
    helper.ensureFlagExists("indentText", options);
    helper.ensureFlagExists("indentCdata", options);
    helper.ensureFlagExists("indentAttributes", options);
    helper.ensureFlagExists("indentInstruction", options);
    helper.ensureFlagExists("fullTagEmptyElement", options);
    helper.ensureFlagExists("noQuotesForNativeAttributes", options);
    helper.ensureSpacesExists(options);
    if (typeof options.spaces === "number") {
      options.spaces = Array(options.spaces + 1).join(" ");
    }
    helper.ensureKeyExists("declaration", options);
    helper.ensureKeyExists("instruction", options);
    helper.ensureKeyExists("attributes", options);
    helper.ensureKeyExists("text", options);
    helper.ensureKeyExists("comment", options);
    helper.ensureKeyExists("cdata", options);
    helper.ensureKeyExists("doctype", options);
    helper.ensureKeyExists("type", options);
    helper.ensureKeyExists("name", options);
    helper.ensureKeyExists("elements", options);
    helper.checkFnExists("doctype", options);
    helper.checkFnExists("instruction", options);
    helper.checkFnExists("cdata", options);
    helper.checkFnExists("comment", options);
    helper.checkFnExists("text", options);
    helper.checkFnExists("instructionName", options);
    helper.checkFnExists("elementName", options);
    helper.checkFnExists("attributeName", options);
    helper.checkFnExists("attributeValue", options);
    helper.checkFnExists("attributes", options);
    helper.checkFnExists("fullTagEmptyElement", options);
    return options;
  }
  function writeIndentation(options, depth, firstLine) {
    return (!firstLine && options.spaces ? "\n" : "") + Array(depth + 1).join(options.spaces);
  }
  function writeAttributes(attributes, options, depth) {
    if (options.ignoreAttributes) {
      return "";
    }
    if ("attributesFn" in options) {
      attributes = options.attributesFn(attributes, currentElementName, currentElement);
    }
    var key, attr, attrName, quote, result = [];
    for (key in attributes) {
      if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== void 0) {
        quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== "string" ? "" : '"';
        attr = "" + attributes[key];
        attr = attr.replace(/"/g, "&quot;");
        attrName = "attributeNameFn" in options ? options.attributeNameFn(key, attr, currentElementName, currentElement) : key;
        result.push(options.spaces && options.indentAttributes ? writeIndentation(options, depth + 1, false) : " ");
        result.push(attrName + "=" + quote + ("attributeValueFn" in options ? options.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote);
      }
    }
    if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) {
      result.push(writeIndentation(options, depth, false));
    }
    return result.join("");
  }
  function writeDeclaration(declaration, options, depth) {
    currentElement = declaration;
    currentElementName = "xml";
    return options.ignoreDeclaration ? "" : "<?xml" + writeAttributes(declaration[options.attributesKey], options, depth) + "?>";
  }
  function writeInstruction(instruction, options, depth) {
    if (options.ignoreInstruction) {
      return "";
    }
    var key;
    for (key in instruction) {
      if (instruction.hasOwnProperty(key)) {
        break;
      }
    }
    var instructionName = "instructionNameFn" in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;
    if (typeof instruction[key] === "object") {
      currentElement = instruction;
      currentElementName = instructionName;
      return "<?" + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + "?>";
    } else {
      var instructionValue = instruction[key] ? instruction[key] : "";
      if ("instructionFn" in options) instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement);
      return "<?" + instructionName + (instructionValue ? " " + instructionValue : "") + "?>";
    }
  }
  function writeComment(comment, options) {
    return options.ignoreComment ? "" : "<!--" + ("commentFn" in options ? options.commentFn(comment, currentElementName, currentElement) : comment) + "-->";
  }
  function writeCdata(cdata, options) {
    return options.ignoreCdata ? "" : "<![CDATA[" + ("cdataFn" in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata.replace("]]>", "]]]]><![CDATA[>")) + "]]>";
  }
  function writeDoctype(doctype, options) {
    return options.ignoreDoctype ? "" : "<!DOCTYPE " + ("doctypeFn" in options ? options.doctypeFn(doctype, currentElementName, currentElement) : doctype) + ">";
  }
  function writeText(text, options) {
    if (options.ignoreText) return "";
    text = "" + text;
    text = text.replace(/&amp;/g, "&");
    text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    return "textFn" in options ? options.textFn(text, currentElementName, currentElement) : text;
  }
  function hasContent(element, options) {
    var i;
    if (element.elements && element.elements.length) {
      for (i = 0; i < element.elements.length; ++i) {
        switch (element.elements[i][options.typeKey]) {
          case "text":
            if (options.indentText) {
              return true;
            }
            break;
          // skip to next key
          case "cdata":
            if (options.indentCdata) {
              return true;
            }
            break;
          // skip to next key
          case "instruction":
            if (options.indentInstruction) {
              return true;
            }
            break;
          // skip to next key
          case "doctype":
          case "comment":
          case "element":
            return true;
          default:
            return true;
        }
      }
    }
    return false;
  }
  function writeElement(element, options, depth) {
    currentElement = element;
    currentElementName = element.name;
    var xml = [], elementName = "elementNameFn" in options ? options.elementNameFn(element.name, element) : element.name;
    xml.push("<" + elementName);
    if (element[options.attributesKey]) {
      xml.push(writeAttributes(element[options.attributesKey], options, depth));
    }
    var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey]["xml:space"] === "preserve";
    if (!withClosingTag) {
      if ("fullTagEmptyElementFn" in options) {
        withClosingTag = options.fullTagEmptyElementFn(element.name, element);
      } else {
        withClosingTag = options.fullTagEmptyElement;
      }
    }
    if (withClosingTag) {
      xml.push(">");
      if (element[options.elementsKey] && element[options.elementsKey].length) {
        xml.push(writeElements(element[options.elementsKey], options, depth + 1));
        currentElement = element;
        currentElementName = element.name;
      }
      xml.push(options.spaces && hasContent(element, options) ? "\n" + Array(depth + 1).join(options.spaces) : "");
      xml.push("</" + elementName + ">");
    } else {
      xml.push("/>");
    }
    return xml.join("");
  }
  function writeElements(elements, options, depth, firstLine) {
    return elements.reduce(function(xml, element) {
      var indent = writeIndentation(options, depth, firstLine && !xml);
      switch (element.type) {
        case "element":
          return xml + indent + writeElement(element, options, depth);
        case "comment":
          return xml + indent + writeComment(element[options.commentKey], options);
        case "doctype":
          return xml + indent + writeDoctype(element[options.doctypeKey], options);
        case "cdata":
          return xml + (options.indentCdata ? indent : "") + writeCdata(element[options.cdataKey], options);
        case "text":
          return xml + (options.indentText ? indent : "") + writeText(element[options.textKey], options);
        case "instruction":
          var instruction = {};
          instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey];
          return xml + (options.indentInstruction ? indent : "") + writeInstruction(instruction, options, depth);
      }
    }, "");
  }
  function hasContentCompact(element, options, anyContent) {
    var key;
    for (key in element) {
      if (element.hasOwnProperty(key)) {
        switch (key) {
          case options.parentKey:
          case options.attributesKey:
            break;
          // skip to next key
          case options.textKey:
            if (options.indentText || anyContent) {
              return true;
            }
            break;
          // skip to next key
          case options.cdataKey:
            if (options.indentCdata || anyContent) {
              return true;
            }
            break;
          // skip to next key
          case options.instructionKey:
            if (options.indentInstruction || anyContent) {
              return true;
            }
            break;
          // skip to next key
          case options.doctypeKey:
          case options.commentKey:
            return true;
          default:
            return true;
        }
      }
    }
    return false;
  }
  function writeElementCompact(element, name, options, depth, indent) {
    currentElement = element;
    currentElementName = name;
    var elementName = "elementNameFn" in options ? options.elementNameFn(name, element) : name;
    if (typeof element === "undefined" || element === null || element === "") {
      return "fullTagEmptyElementFn" in options && options.fullTagEmptyElementFn(name, element) || options.fullTagEmptyElement ? "<" + elementName + "></" + elementName + ">" : "<" + elementName + "/>";
    }
    var xml = [];
    if (name) {
      xml.push("<" + elementName);
      if (typeof element !== "object") {
        xml.push(">" + writeText(element, options) + "</" + elementName + ">");
        return xml.join("");
      }
      if (element[options.attributesKey]) {
        xml.push(writeAttributes(element[options.attributesKey], options, depth));
      }
      var withClosingTag = hasContentCompact(element, options, true) || element[options.attributesKey] && element[options.attributesKey]["xml:space"] === "preserve";
      if (!withClosingTag) {
        if ("fullTagEmptyElementFn" in options) {
          withClosingTag = options.fullTagEmptyElementFn(name, element);
        } else {
          withClosingTag = options.fullTagEmptyElement;
        }
      }
      if (withClosingTag) {
        xml.push(">");
      } else {
        xml.push("/>");
        return xml.join("");
      }
    }
    xml.push(writeElementsCompact(element, options, depth + 1, false));
    currentElement = element;
    currentElementName = name;
    if (name) {
      xml.push((indent ? writeIndentation(options, depth, false) : "") + "</" + elementName + ">");
    }
    return xml.join("");
  }
  function writeElementsCompact(element, options, depth, firstLine) {
    var i, key, nodes, xml = [];
    for (key in element) {
      if (element.hasOwnProperty(key)) {
        nodes = isArray(element[key]) ? element[key] : [element[key]];
        for (i = 0; i < nodes.length; ++i) {
          switch (key) {
            case options.declarationKey:
              xml.push(writeDeclaration(nodes[i], options, depth));
              break;
            case options.instructionKey:
              xml.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : "") + writeInstruction(nodes[i], options, depth));
              break;
            case options.attributesKey:
            case options.parentKey:
              break;
            // skip
            case options.textKey:
              xml.push((options.indentText ? writeIndentation(options, depth, firstLine) : "") + writeText(nodes[i], options));
              break;
            case options.cdataKey:
              xml.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : "") + writeCdata(nodes[i], options));
              break;
            case options.doctypeKey:
              xml.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i], options));
              break;
            case options.commentKey:
              xml.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i], options));
              break;
            default:
              xml.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i], key, options, depth, hasContentCompact(nodes[i], options)));
          }
          firstLine = firstLine && !xml.length;
        }
      }
    }
    return xml.join("");
  }
  js2xml = function(js, options) {
    options = validateOptions(options);
    var xml = [];
    currentElement = js;
    currentElementName = "_root_";
    if (options.compact) {
      xml.push(writeElementsCompact(js, options, 0, true));
    } else {
      if (js[options.declarationKey]) {
        xml.push(writeDeclaration(js[options.declarationKey], options, 0));
      }
      if (js[options.elementsKey] && js[options.elementsKey].length) {
        xml.push(writeElements(js[options.elementsKey], options, 0, !xml.length));
      }
    }
    return xml.join("");
  };
  return js2xml;
}
var json2xml;
var hasRequiredJson2xml;
function requireJson2xml() {
  if (hasRequiredJson2xml) return json2xml;
  hasRequiredJson2xml = 1;
  var js2xml2 = requireJs2xml();
  json2xml = function(json, options) {
    if (json instanceof Buffer2) {
      json = json.toString();
    }
    var js = null;
    if (typeof json === "string") {
      try {
        js = JSON.parse(json);
      } catch (e) {
        throw new Error("The JSON structure is invalid");
      }
    } else {
      js = json;
    }
    return js2xml2(js, options);
  };
  return json2xml;
}
var lib;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  var xml2js2 = requireXml2js();
  var xml2json2 = requireXml2json();
  var js2xml2 = requireJs2xml();
  var json2xml2 = requireJson2xml();
  lib = {
    xml2js: xml2js2,
    xml2json: xml2json2,
    js2xml: js2xml2,
    json2xml: json2xml2
  };
  return lib;
}
var libExports = requireLib();
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = {
  randomUUID
};
function v4(options, buf, offset) {
  if (native.randomUUID && true && !options) {
    return native.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify(rnds);
}
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
const CRC_TABLE = new Int32Array([
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
]);
function ensureBuffer(input) {
  if (Buffer2.isBuffer(input)) {
    return input;
  }
  if (typeof input === "number") {
    return Buffer2.alloc(input);
  } else if (typeof input === "string") {
    return Buffer2.from(input);
  } else {
    throw new Error("input must be buffer, number, or string, received " + typeof input);
  }
}
function bufferizeInt(num) {
  const tmp = ensureBuffer(4);
  tmp.writeInt32BE(num, 0);
  return tmp;
}
function _crc32(buf, previous) {
  buf = ensureBuffer(buf);
  if (Buffer2.isBuffer(previous)) {
    previous = previous.readUInt32BE(0);
  }
  let crc = ~~previous ^ -1;
  for (var n = 0; n < buf.length; n++) {
    crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
  }
  return crc ^ -1;
}
function crc32() {
  return bufferizeInt(_crc32.apply(null, arguments));
}
crc32.signed = function() {
  return _crc32.apply(null, arguments);
};
crc32.unsigned = function() {
  return _crc32.apply(null, arguments) >>> 0;
};
var bufferCrc32 = crc32;
const index = /* @__PURE__ */ getDefaultExportFromCjs(bufferCrc32);
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
const isMacOS = () => {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
};
const isIOS = () => {
  if (typeof navigator === "undefined") return false;
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(
    navigator.platform
  );
};
const isRegExp = (value) => {
  return Object.prototype.toString.call(value) === "[object RegExp]";
};
function objectIncludes(obj1, obj2, options = { strict: true }) {
  const keys2 = Object.keys(obj2);
  if (!keys2.length) return true;
  return keys2.every((key) => {
    if (options.strict) return obj2[key] === obj1[key];
    if (isRegExp(obj2[key])) return obj2[key].test(obj1[key]);
    return obj2[key] === obj1[key];
  });
}
function deleteProps(obj, propOrProps) {
  const props = typeof propOrProps === "string" ? [propOrProps] : propOrProps;
  const removeNested = (target, pathParts, index2 = 0) => {
    if (!target || typeof target !== "object") {
      return false;
    }
    const key = pathParts[index2];
    const isLast = index2 === pathParts.length - 1;
    if (!(key in target)) {
      return Object.keys(target).length === 0;
    }
    if (isLast) {
      delete target[key];
    } else {
      const shouldDeleteChild = removeNested(target[key], pathParts, index2 + 1);
      if (shouldDeleteChild) {
        delete target[key];
      }
    }
    return Object.keys(target).length === 0;
  };
  const clonedObj = JSON.parse(JSON.stringify(obj));
  props.forEach((propPath) => {
    if (!propPath.includes(".")) {
      delete clonedObj[propPath];
      return;
    }
    removeNested(clonedObj, propPath.split("."));
  });
  return Object.entries(clonedObj).reduce((acc, [key, value]) => {
    if (value == null) {
      return acc;
    }
    if (typeof value === "object" && Object.keys(value).length === 0) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
}
const CSS_DIMENSION_REGEX = /[\d-.]+(\w+)$/;
const DOM_SIZE_UNITS = ["px", "rem", "em", "in", "q", "mm", "cm", "pt", "pc", "vh", "vw", "vmin", "vmax"];
function parseSizeUnit(val = "0") {
  const length = val.toString() || "0";
  const value = Number.parseFloat(length);
  const match = length.match(CSS_DIMENSION_REGEX);
  const unit = (match?.[1] ?? "").toLowerCase();
  return [value, DOM_SIZE_UNITS.includes(unit) ? unit : null];
}
function minMax(value = 0, min2 = 0, max2 = 0) {
  return Math.min(Math.max(value, min2), max2);
}
function OrderedMap(content) {
  this.content = content;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key) return i;
    return -1;
  },
  // :: (string)  ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  // :: (string, any, ?string)  OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self2 = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self2.find(key), content = self2.content.slice();
    if (found2 == -1) {
      content.push(newKey || key, value);
    } else {
      content[found2 + 1] = value;
      if (newKey) content[found2] = newKey;
    }
    return new OrderedMap(content);
  },
  // :: (string)  OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1) return this;
    var content = this.content.slice();
    content.splice(found2, 2);
    return new OrderedMap(content);
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content);
  },
  // :: (string, string, any)  OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found2 = without.find(place);
    content.splice(found2 == -1 ? content.length : found2, 0, key, value);
    return new OrderedMap(content);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map) {
    map = OrderedMap.from(map);
    if (!map.size) return this;
    return new OrderedMap(map.content.concat(this.subtract(map).content));
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map) {
    map = OrderedMap.from(map);
    if (!map.size) return this;
    return new OrderedMap(this.subtract(map).content.concat(map.content));
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map) {
    var result = this;
    map = OrderedMap.from(map);
    for (var i = 0; i < map.content.length; i += 2)
      result = result.remove(map.content[i]);
    return result;
  },
  // :: ()  Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var result = {};
    this.forEach(function(key, value) {
      result[key] = value;
    });
    return result;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap) return value;
  var content = [];
  if (value) for (var prop in value) content.push(prop, value[prop]);
  return new OrderedMap(content);
};
function findDiffStart(a, b2, pos) {
  for (let i = 0; ; i++) {
    if (i == a.childCount || i == b2.childCount)
      return a.childCount == b2.childCount ? null : pos;
    let childA = a.child(i), childB = b2.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j2 = 0; childA.text[j2] == childB.text[j2]; j2++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a, b2, posA, posB) {
  for (let iA = a.childCount, iB = b2.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a.child(--iA), childB = b2.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size;
    posB -= size;
  }
}
class Fragment {
  /**
  @internal
  */
  constructor(content, size) {
    this.content = content;
    this.size = size || 0;
    if (size == null)
      for (let i = 0; i < content.length; i++)
        this.size += content[i].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(from, to, f, nodeStart = 0, parent) {
    for (let i = 0, pos = 0; pos < to; i++) {
      let child = this.content[i], end = pos + child.nodeSize;
      if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
        let start = pos + 1;
        child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);
      }
      pos = end;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(f) {
    this.nodesBetween(0, this.size, f);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(from, to, blockSeparator, leafText) {
    let text = "", first = true;
    this.nodesBetween(from, to, (node, pos) => {
      let nodeText = node.isText ? node.text.slice(Math.max(from, pos) - pos, to - pos) : !node.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : "";
      if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {
        if (first)
          first = false;
        else
          text += blockSeparator;
      }
      text += nodeText;
    }, 0);
    return text;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;
    if (last.isText && last.sameMarkup(first)) {
      content[content.length - 1] = last.withText(last.text + first.text);
      i = 1;
    }
    for (; i < other.content.length; i++)
      content.push(other.content[i]);
    return new Fragment(content, this.size + other.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(from, to = this.size) {
    if (from == 0 && to == this.size)
      return this;
    let result = [], size = 0;
    if (to > from)
      for (let i = 0, pos = 0; pos < to; i++) {
        let child = this.content[i], end = pos + child.nodeSize;
        if (end > from) {
          if (pos < from || end > to) {
            if (child.isText)
              child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));
            else
              child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size += child.nodeSize;
        }
        pos = end;
      }
    return new Fragment(result, size);
  }
  /**
  @internal
  */
  cutByIndex(from, to) {
    if (from == to)
      return Fragment.empty;
    if (from == 0 && to == this.content.length)
      return this;
    return new Fragment(this.content.slice(from, to));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(index2, node) {
    let current = this.content[index2];
    if (current == node)
      return this;
    let copy2 = this.content.slice();
    let size = this.size + node.nodeSize - current.nodeSize;
    copy2[index2] = node;
    return new Fragment(copy2, size);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(node) {
    return new Fragment([node].concat(this.content), this.size + node.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(node) {
    return new Fragment(this.content.concat(node), this.size + node.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i = 0; i < this.content.length; i++)
      if (!this.content[i].eq(other.content[i]))
        return false;
    return true;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(index2) {
    let found2 = this.content[index2];
    if (!found2)
      throw new RangeError("Index " + index2 + " out of range for " + this);
    return found2;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index2) {
    return this.content[index2] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    for (let i = 0, p = 0; i < this.content.length; i++) {
      let child = this.content[i];
      f(child, p, i);
      p += child.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(other, pos = 0) {
    return findDiffStart(this, other, pos);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd(this, other, pos, otherPos);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(pos) {
    if (pos == 0)
      return retIndex(0, pos);
    if (pos == this.size)
      return retIndex(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i = 0, curPos = 0; ; i++) {
      let cur = this.child(i), end = curPos + cur.nodeSize;
      if (end >= pos) {
        if (end == pos)
          return retIndex(i + 1, end);
        return retIndex(i, curPos);
      }
      curPos = end;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((n) => n.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(schema, value) {
    if (!value)
      return Fragment.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Fragment(value.map(schema.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(array) {
    if (!array.length)
      return Fragment.empty;
    let joined, size = 0;
    for (let i = 0; i < array.length; i++) {
      let node = array[i];
      size += node.nodeSize;
      if (i && node.isText && array[i - 1].sameMarkup(node)) {
        if (!joined)
          joined = array.slice(0, i);
        joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);
      } else if (joined) {
        joined.push(node);
      }
    }
    return new Fragment(joined || array, size);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(nodes) {
    if (!nodes)
      return Fragment.empty;
    if (nodes instanceof Fragment)
      return nodes;
    if (Array.isArray(nodes))
      return this.fromArray(nodes);
    if (nodes.attrs)
      return new Fragment([nodes], nodes.nodeSize);
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
Fragment.empty = new Fragment([], 0);
const found = { index: 0, offset: 0 };
function retIndex(index2, offset) {
  found.index = index2;
  found.offset = offset;
  return found;
}
function compareDeep(a, b2) {
  if (a === b2)
    return true;
  if (!(a && typeof a == "object") || !(b2 && typeof b2 == "object"))
    return false;
  let array = Array.isArray(a);
  if (Array.isArray(b2) != array)
    return false;
  if (array) {
    if (a.length != b2.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!compareDeep(a[i], b2[i]))
        return false;
  } else {
    for (let p in a)
      if (!(p in b2) || !compareDeep(a[p], b2[p]))
        return false;
    for (let p in b2)
      if (!(p in a))
        return false;
  }
  return true;
}
class Mark {
  /**
  @internal
  */
  constructor(type2, attrs) {
    this.type = type2;
    this.attrs = attrs;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(set) {
    let copy2, placed = false;
    for (let i = 0; i < set.length; i++) {
      let other = set[i];
      if (this.eq(other))
        return set;
      if (this.type.excludes(other.type)) {
        if (!copy2)
          copy2 = set.slice(0, i);
      } else if (other.type.excludes(this.type)) {
        return set;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy2)
            copy2 = set.slice(0, i);
          copy2.push(this);
          placed = true;
        }
        if (copy2)
          copy2.push(other);
      }
    }
    if (!copy2)
      copy2 = set.slice();
    if (!placed)
      copy2.push(this);
    return copy2;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return set.slice(0, i).concat(set.slice(i + 1));
    return set;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return true;
    return false;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(other) {
    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _2 in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let type2 = schema.marks[json.type];
    if (!type2)
      throw new RangeError(`There is no mark type ${json.type} in this schema`);
    let mark = type2.create(json.attrs);
    type2.checkAttrs(mark.attrs);
    return mark;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(a, b2) {
    if (a == b2)
      return true;
    if (a.length != b2.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!a[i].eq(b2[i]))
        return false;
    return true;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(marks) {
    if (!marks || Array.isArray(marks) && marks.length == 0)
      return Mark.none;
    if (marks instanceof Mark)
      return [marks];
    let copy2 = marks.slice();
    copy2.sort((a, b2) => a.type.rank - b2.type.rank);
    return copy2;
  }
}
Mark.none = [];
class ReplaceError extends Error {
}
class Slice {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragmenti.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(content, openStart, openEnd) {
    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(pos, fragment) {
    let content = insertInto(this.content, pos + this.openStart, fragment);
    return content && new Slice(content, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(from, to) {
    return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let json = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json.openStart = this.openStart;
    if (this.openEnd > 0)
      json.openEnd = this.openEnd;
    return json;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      return Slice.empty;
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(fragment, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
      openStart++;
    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
      openEnd++;
    return new Slice(fragment, openStart, openEnd);
  }
}
Slice.empty = new Slice(Fragment.empty, 0, 0);
function removeRange(content, from, to) {
  let { index: index2, offset } = content.findIndex(from), child = content.maybeChild(index2);
  let { index: indexTo, offset: offsetTo } = content.findIndex(to);
  if (offset == from || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content.cut(0, from).append(content.cut(to));
  }
  if (index2 != indexTo)
    throw new RangeError("Removing non-flat range");
  return content.replaceChild(index2, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));
}
function insertInto(content, dist2, insert, parent) {
  let { index: index2, offset } = content.findIndex(dist2), child = content.maybeChild(index2);
  if (offset == dist2 || child.isText) {
    if (parent && !parent.canReplace(index2, index2, insert))
      return null;
    return content.cut(0, dist2).append(insert).append(content.cut(dist2));
  }
  let inner = insertInto(child.content, dist2 - offset - 1, insert, child);
  return inner && content.replaceChild(index2, child.copy(inner));
}
function replace($from, $to, slice) {
  if (slice.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice, 0);
}
function replaceOuter($from, $to, slice, depth) {
  let index2 = $from.index(depth), node = $from.node(depth);
  if (index2 == $to.index(depth) && depth < $from.depth - slice.openStart) {
    let inner = replaceOuter($from, $to, slice, depth + 1);
    return node.copy(node.content.replaceChild(index2, inner));
  } else if (!slice.content.size) {
    return close(node, replaceTwoWay($from, $to, depth));
  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));
  } else {
    let { start, end } = prepareSliceForReplace(slice, $from);
    return close(node, replaceThreeWay($from, start, end, $to, depth));
  }
}
function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
}
function joinable$1($before, $after, depth) {
  let node = $before.node(depth);
  checkJoin(node, $after.node(depth));
  return node;
}
function addNode(child, target) {
  let last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last]))
    target[last] = child.withText(target[last].text + child.text);
  else
    target.push(child);
}
function addRange($start, $end, depth, target) {
  let node = ($end || $start).node(depth);
  let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (let i = startIndex; i < endIndex; i++)
    addNode(node.child(i), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}
function close(node, content) {
  node.type.checkContent(content);
  return node.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable$1($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable$1($end, $to, depth + 1);
  let content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function replaceTwoWay($from, $to, depth) {
  let content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    let type2 = joinable$1($from, $to, depth + 1);
    addNode(close(type2, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function prepareSliceForReplace(slice, $along) {
  let extra = $along.depth - slice.openStart, parent = $along.node(extra);
  let node = parent.copy(slice.content);
  for (let i = extra - 1; i >= 0; i--)
    node = $along.node(i).copy(Fragment.from(node));
  return {
    start: node.resolveNoCache(slice.openStart + extra),
    end: node.resolveNoCache(node.content.size - slice.openEnd - extra)
  };
}
class ResolvedPos {
  /**
  @internal
  */
  constructor(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(val) {
    if (val == null)
      return this.depth;
    if (val < 0)
      return this.depth + val;
    return val;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parenttext nodes are flat in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position before the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position after the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let parent = this.parent, index2 = this.index(this.depth);
    if (index2 == parent.childCount)
      return null;
    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index2);
    return dOff ? parent.child(index2).cut(dOff) : child;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let index2 = this.index(this.depth);
    let dOff = this.pos - this.path[this.path.length - 1];
    if (dOff)
      return this.parent.child(index2).cut(0, dOff);
    return index2 == 0 ? null : this.parent.child(index2 - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(index2, depth) {
    depth = this.resolveDepth(depth);
    let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (let i = 0; i < index2; i++)
      pos += node.child(i).nodeSize;
    return pos;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let parent = this.parent, index2 = this.index();
    if (parent.content.size == 0)
      return Mark.none;
    if (this.textOffset)
      return parent.child(index2).marks;
    let main = parent.maybeChild(index2 - 1), other = parent.maybeChild(index2);
    if (!main) {
      let tmp = main;
      main = other;
      other = tmp;
    }
    let marks = main.marks;
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross($end) {
    let after = this.parent.maybeChild(this.index());
    if (!after || !after.isInline)
      return null;
    let marks = after.marks, next = $end.parent.maybeChild($end.index());
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(pos) {
    for (let depth = this.depth; depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos)
        return depth;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(other = this, pred) {
    if (other.pos < this.pos)
      return other.blockRange(this);
    for (let d2 = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d2 >= 0; d2--)
      if (other.pos <= this.end(d2) && (!pred || pred(this.node(d2))))
        return new NodeRange(this, other, d2);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(other) {
    return other.pos > this.pos ? other : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(other) {
    return other.pos < this.pos ? other : this;
  }
  /**
  @internal
  */
  toString() {
    let str = "";
    for (let i = 1; i <= this.depth; i++)
      str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
    return str + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(doc2, pos) {
    if (!(pos >= 0 && pos <= doc2.content.size))
      throw new RangeError("Position " + pos + " out of range");
    let path = [];
    let start = 0, parentOffset = pos;
    for (let node = doc2; ; ) {
      let { index: index2, offset } = node.content.findIndex(parentOffset);
      let rem = parentOffset - offset;
      path.push(node, index2, start + offset);
      if (!rem)
        break;
      node = node.child(index2);
      if (node.isText)
        break;
      parentOffset = rem - 1;
      start += offset + 1;
    }
    return new ResolvedPos(pos, path, parentOffset);
  }
  /**
  @internal
  */
  static resolveCached(doc2, pos) {
    let cache = resolveCache.get(doc2);
    if (cache) {
      for (let i = 0; i < cache.elts.length; i++) {
        let elt = cache.elts[i];
        if (elt.pos == pos)
          return elt;
      }
    } else {
      resolveCache.set(doc2, cache = new ResolveCache());
    }
    let result = cache.elts[cache.i] = ResolvedPos.resolve(doc2, pos);
    cache.i = (cache.i + 1) % resolveCacheSize;
    return result;
  }
}
class ResolveCache {
  constructor() {
    this.elts = [];
    this.i = 0;
  }
}
const resolveCacheSize = 12, resolveCache = /* @__PURE__ */ new WeakMap();
class NodeRange {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const emptyAttrs = /* @__PURE__ */ Object.create(null);
let Node$1 = class Node2 {
  /**
  @internal
  */
  constructor(type2, attrs, content, marks = Mark.none) {
    this.type = type2;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content || Fragment.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(index2) {
    return this.content.child(index2);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index2) {
    return this.content.maybeChild(index2);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    this.content.forEach(f);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(from, to, f, startPos = 0) {
    this.content.nodesBetween(from, to, f, startPos, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(f) {
    this.nodesBetween(0, this.content.size, f);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.
  */
  textBetween(from, to, blockSeparator, leafText) {
    return this.content.textBetween(from, to, blockSeparator, leafText);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(type2, attrs, marks) {
    return this.type == type2 && compareDeep(this.attrs, attrs || type2.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(content = null) {
    if (content == this.content)
      return this;
    return new Node2(this.type, this.attrs, content, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(marks) {
    return marks == this.marks ? this : new Node2(this.type, this.attrs, this.content, marks);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(from, to = this.content.size) {
    if (from == 0 && to == this.content.size)
      return this;
    return this.copy(this.content.cut(from, to));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(from, to = this.content.size, includeParents = false) {
    if (from == to)
      return Slice.empty;
    let $from = this.resolve(from), $to = this.resolve(to);
    let depth = includeParents ? 0 : $from.sharedDepth(to);
    let start = $from.start(depth), node = $from.node(depth);
    let content = node.content.cut($from.pos - start, $to.pos - start);
    return new Slice(content, $from.depth - depth, $to.depth - depth);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(from, to, slice) {
    return replace(this.resolve(from), this.resolve(to), slice);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(pos) {
    for (let node = this; ; ) {
      let { index: index2, offset } = node.content.findIndex(pos);
      node = node.maybeChild(index2);
      if (!node)
        return null;
      if (offset == pos || node.isText)
        return node;
      pos -= offset + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(pos) {
    let { index: index2, offset } = this.content.findIndex(pos);
    return { node: this.content.maybeChild(index2), index: index2, offset };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(pos) {
    if (pos == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: index2, offset } = this.content.findIndex(pos);
    if (offset < pos)
      return { node: this.content.child(index2), index: index2, offset };
    let node = this.content.child(index2 - 1);
    return { node, index: index2 - 1, offset: offset - node.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(pos) {
    return ResolvedPos.resolveCached(this, pos);
  }
  /**
  @internal
  */
  resolveNoCache(pos) {
    return ResolvedPos.resolve(this, pos);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(from, to, type2) {
    let found2 = false;
    if (to > from)
      this.nodesBetween(from, to, (node) => {
        if (type2.isInSet(node.marks))
          found2 = true;
        return !found2;
      });
    return found2;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let name = this.type.name;
    if (this.content.size)
      name += "(" + this.content.toStringInner() + ")";
    return wrapMarks(this.marks, name);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(index2) {
    let match = this.type.contentMatch.matchFragment(this.content, 0, index2);
    if (!match)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return match;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {
    let one = this.contentMatchAt(from).matchFragment(replacement, start, end);
    let two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd)
      return false;
    for (let i = start; i < end; i++)
      if (!this.type.allowsMarks(replacement.child(i).marks))
        return false;
    return true;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(from, to, type2, marks) {
    if (marks && !this.type.allowsMarks(marks))
      return false;
    let start = this.contentMatchAt(from).matchType(type2);
    let end = start && start.matchFragment(this.content, to);
    return end ? end.validEnd : false;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(other) {
    if (other.content.size)
      return this.canReplace(this.childCount, this.childCount, other.content);
    else
      return this.type.compatibleContent(other.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    this.type.checkAttrs(this.attrs);
    let copy2 = Mark.none;
    for (let i = 0; i < this.marks.length; i++) {
      let mark = this.marks[i];
      mark.type.checkAttrs(mark.attrs);
      copy2 = mark.addToSet(copy2);
    }
    if (!Mark.sameSet(copy2, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m2) => m2.type.name)}`);
    this.content.forEach((node) => node.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _2 in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map((n) => n.toJSON());
    return obj;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Node.fromJSON");
    let marks = void 0;
    if (json.marks) {
      if (!Array.isArray(json.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      marks = json.marks.map(schema.markFromJSON);
    }
    if (json.type == "text") {
      if (typeof json.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return schema.text(json.text, marks);
    }
    let content = Fragment.fromJSON(schema, json.content);
    let node = schema.nodeType(json.type).create(json.attrs, content, marks);
    node.type.checkAttrs(node.attrs);
    return node;
  }
};
Node$1.prototype.text = void 0;
class TextNode extends Node$1 {
  /**
  @internal
  */
  constructor(type2, attrs, content, marks) {
    super(type2, attrs, null, marks);
    if (!content)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = content;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    return wrapMarks(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(from, to) {
    return this.text.slice(from, to);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(marks) {
    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);
  }
  withText(text) {
    if (text == this.text)
      return this;
    return new TextNode(this.type, this.attrs, text, this.marks);
  }
  cut(from = 0, to = this.text.length) {
    if (from == 0 && to == this.text.length)
      return this;
    return this.withText(this.text.slice(from, to));
  }
  eq(other) {
    return this.sameMarkup(other) && this.text == other.text;
  }
  toJSON() {
    let base = super.toJSON();
    base.text = this.text;
    return base;
  }
}
function wrapMarks(marks, str) {
  for (let i = marks.length - 1; i >= 0; i--)
    str = marks[i].type.name + "(" + str + ")";
  return str;
}
class ContentMatch {
  /**
  @internal
  */
  constructor(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(string, nodeTypes) {
    let stream = new TokenStream(string, nodeTypes);
    if (stream.next == null)
      return ContentMatch.empty;
    let expr = parseExpr(stream);
    if (stream.next)
      stream.err("Unexpected trailing text");
    let match = dfa(nfa(expr));
    checkForDeadEnds(match, stream);
    return match;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(type2) {
    for (let i = 0; i < this.next.length; i++)
      if (this.next[i].type == type2)
        return this.next[i].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(frag, start = 0, end = frag.childCount) {
    let cur = this;
    for (let i = start; cur && i < end; i++)
      cur = cur.matchType(frag.child(i).type);
    return cur;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let i = 0; i < this.next.length; i++) {
      let { type: type2 } = this.next[i];
      if (!(type2.isText || type2.hasRequiredAttrs()))
        return type2;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(other) {
    for (let i = 0; i < this.next.length; i++)
      for (let j2 = 0; j2 < other.next.length; j2++)
        if (this.next[i].type == other.next[j2].type)
          return true;
    return false;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(after, toEnd = false, startIndex = 0) {
    let seen = [this];
    function search(match, types2) {
      let finished = match.matchFragment(after, startIndex);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment.from(types2.map((tp) => tp.createAndFill()));
      for (let i = 0; i < match.next.length; i++) {
        let { type: type2, next } = match.next[i];
        if (!(type2.isText || type2.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
          seen.push(next);
          let found2 = search(next, types2.concat(type2));
          if (found2)
            return found2;
        }
      }
      return null;
    }
    return search(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(target) {
    for (let i = 0; i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == target)
        return this.wrapCache[i + 1];
    let computed = this.computeWrapping(target);
    this.wrapCache.push(target, computed);
    return computed;
  }
  /**
  @internal
  */
  computeWrapping(target) {
    let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      let current = active.shift(), match = current.match;
      if (match.matchType(target)) {
        let result = [];
        for (let obj = current; obj.type; obj = obj.via)
          result.push(obj.type);
        return result.reverse();
      }
      for (let i = 0; i < match.next.length; i++) {
        let { type: type2, next } = match.next[i];
        if (!type2.isLeaf && !type2.hasRequiredAttrs() && !(type2.name in seen) && (!current.type || next.validEnd)) {
          active.push({ match: type2.contentMatch, type: type2, via: current });
          seen[type2.name] = true;
        }
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(n) {
    if (n >= this.next.length)
      throw new RangeError(`There's no ${n}th edge in this content match`);
    return this.next[n];
  }
  /**
  @internal
  */
  toString() {
    let seen = [];
    function scan(m2) {
      seen.push(m2);
      for (let i = 0; i < m2.next.length; i++)
        if (seen.indexOf(m2.next[i].next) == -1)
          scan(m2.next[i].next);
    }
    scan(this);
    return seen.map((m2, i) => {
      let out = i + (m2.validEnd ? "*" : " ") + " ";
      for (let i2 = 0; i2 < m2.next.length; i2++)
        out += (i2 ? ", " : "") + m2.next[i2].type.name + "->" + seen.indexOf(m2.next[i2].next);
      return out;
    }).join("\n");
  }
}
ContentMatch.empty = new ContentMatch(true);
class TokenStream {
  constructor(string, nodeTypes) {
    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "")
      this.tokens.pop();
    if (this.tokens[0] == "")
      this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(tok) {
    return this.next == tok && (this.pos++ || true);
  }
  err(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  }
}
function parseExpr(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  let expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  let result = Number(stream.next);
  stream.pos++;
  return result;
}
function parseExprRange(stream, expr) {
  let min2 = parseNum(stream), max2 = min2;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max2 = parseNum(stream);
    else
      max2 = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min: min2, max: max2, expr };
}
function resolveName(stream, name) {
  let types2 = stream.nodeTypes, type2 = types2[name];
  if (type2)
    return [type2];
  let result = [];
  for (let typeName in types2) {
    let type3 = types2[typeName];
    if (type3.isInGroup(name))
      result.push(type3);
  }
  if (result.length == 0)
    stream.err("No node type or group '" + name + "' found");
  return result;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName(stream, stream.next).map((type2) => {
      if (stream.inline == null)
        stream.inline = type2.isInline;
      else if (stream.inline != type2.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type2 };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  let nfa2 = [[]];
  connect(compile(expr, 0), node());
  return nfa2;
  function node() {
    return nfa2.push([]) - 1;
  }
  function edge(from, to, term) {
    let edge2 = { term, to };
    nfa2[from].push(edge2);
    return edge2;
  }
  function connect(edges, to) {
    edges.forEach((edge2) => edge2.to = to);
  }
  function compile(expr2, from) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from)), []);
    } else if (expr2.type == "seq") {
      for (let i = 0; ; i++) {
        let next = compile(expr2.exprs[i], from);
        if (i == expr2.exprs.length - 1)
          return next;
        connect(next, from = node());
      }
    } else if (expr2.type == "star") {
      let loop = node();
      edge(from, loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "plus") {
      let loop = node();
      connect(compile(expr2.expr, from), loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "opt") {
      return [edge(from)].concat(compile(expr2.expr, from));
    } else if (expr2.type == "range") {
      let cur = from;
      for (let i = 0; i < expr2.min; i++) {
        let next = node();
        connect(compile(expr2.expr, cur), next);
        cur = next;
      }
      if (expr2.max == -1) {
        connect(compile(expr2.expr, cur), cur);
      } else {
        for (let i = expr2.min; i < expr2.max; i++) {
          let next = node();
          edge(cur, next);
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a, b2) {
  return b2 - a;
}
function nullFrom(nfa2, node) {
  let result = [];
  scan(node);
  return result.sort(cmp);
  function scan(node2) {
    let edges = nfa2[node2];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result.push(node2);
    for (let i = 0; i < edges.length; i++) {
      let { term, to } = edges[i];
      if (!term && result.indexOf(to) == -1)
        scan(to);
    }
  }
}
function dfa(nfa2) {
  let labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node) => {
      nfa2[node].forEach(({ term, to }) => {
        if (!term)
          return;
        let set;
        for (let i = 0; i < out.length; i++)
          if (out[i][0] == term)
            set = out[i][1];
        nullFrom(nfa2, to).forEach((node2) => {
          if (!set)
            out.push([term, set = []]);
          if (set.indexOf(node2) == -1)
            set.push(node2);
        });
      });
    });
    let state2 = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (let i = 0; i < out.length; i++) {
      let states2 = out[i][1].sort(cmp);
      state2.next.push({ type: out[i][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state2;
  }
}
function checkForDeadEnds(match, stream) {
  for (let i = 0, work = [match]; i < work.length; i++) {
    let state2 = work[i], dead = !state2.validEnd, nodes = [];
    for (let j2 = 0; j2 < state2.next.length; j2++) {
      let { type: type2, next } = state2.next[j2];
      nodes.push(type2.name);
      if (dead && !(type2.isText || type2.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next) == -1)
        work.push(next);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs) {
  let defaults = /* @__PURE__ */ Object.create(null);
  for (let attrName in attrs) {
    let attr = attrs[attrName];
    if (!attr.hasDefault)
      return null;
    defaults[attrName] = attr.default;
  }
  return defaults;
}
function computeAttrs(attrs, value) {
  let built = /* @__PURE__ */ Object.create(null);
  for (let name in attrs) {
    let given = value && value[name];
    if (given === void 0) {
      let attr = attrs[name];
      if (attr.hasDefault)
        given = attr.default;
      else
        throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function checkAttrs(attrs, values, type2, name) {
  for (let name2 in values)
    if (!(name2 in attrs))
      throw new RangeError(`Unsupported attribute ${name2} for ${type2} of type ${name2}`);
  for (let name2 in attrs) {
    let attr = attrs[name2];
    if (attr.validate)
      attr.validate(values[name2]);
  }
}
function initAttrs(typeName, attrs) {
  let result = /* @__PURE__ */ Object.create(null);
  if (attrs)
    for (let name in attrs)
      result[name] = new Attribute(typeName, name, attrs[name]);
  return result;
}
class NodeType {
  /**
  @internal
  */
  constructor(name, schema, spec) {
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(name, spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ContentMatch.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(group) {
    return this.groups.indexOf(group) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let n in this.attrs)
      if (this.attrs[n].isRequired)
        return true;
    return false;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(attrs) {
    if (!attrs && this.defaultAttrs)
      return this.defaultAttrs;
    else
      return computeAttrs(this.attrs, attrs);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(attrs = null, content, marks) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node$1(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(attrs = null, content, marks) {
    content = Fragment.from(content);
    this.checkContent(content);
    return new Node$1(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(attrs = null, content, marks) {
    attrs = this.computeAttrs(attrs);
    content = Fragment.from(content);
    if (content.size) {
      let before = this.contentMatch.fillBefore(content);
      if (!before)
        return null;
      content = before.append(content);
    }
    let matched = this.contentMatch.matchFragment(content);
    let after = matched && matched.fillBefore(Fragment.empty, true);
    if (!after)
      return null;
    return new Node$1(this, attrs, content.append(after), Mark.setFrom(marks));
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(content) {
    let result = this.contentMatch.matchFragment(content);
    if (!result || !result.validEnd)
      return false;
    for (let i = 0; i < content.childCount; i++)
      if (!this.allowsMarks(content.child(i).marks))
        return false;
    return true;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(content) {
    if (!this.validContent(content))
      throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(attrs) {
    checkAttrs(this.attrs, attrs, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(marks) {
    if (this.markSet == null)
      return true;
    for (let i = 0; i < marks.length; i++)
      if (!this.allowsMarkType(marks[i].type))
        return false;
    return true;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(marks) {
    if (this.markSet == null)
      return marks;
    let copy2;
    for (let i = 0; i < marks.length; i++) {
      if (!this.allowsMarkType(marks[i].type)) {
        if (!copy2)
          copy2 = marks.slice(0, i);
      } else if (copy2) {
        copy2.push(marks[i]);
      }
    }
    return !copy2 ? marks : copy2.length ? copy2 : Mark.none;
  }
  /**
  @internal
  */
  static compile(nodes, schema) {
    let result = /* @__PURE__ */ Object.create(null);
    nodes.forEach((name, spec) => result[name] = new NodeType(name, schema, spec));
    let topType = schema.spec.topNode || "doc";
    if (!result[topType])
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    if (!result.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let _2 in result.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return result;
  }
}
function validateType(typeName, attrName, type2) {
  let types2 = type2.split("|");
  return (value) => {
    let name = value === null ? "null" : typeof value;
    if (types2.indexOf(name) < 0)
      throw new RangeError(`Expected value of type ${types2} for attribute ${attrName} on type ${typeName}, got ${name}`);
  };
}
class Attribute {
  constructor(typeName, attrName, options) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this.default = options.default;
    this.validate = typeof options.validate == "string" ? validateType(typeName, attrName, options.validate) : options.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class MarkType {
  /**
  @internal
  */
  constructor(name, rank, schema, spec) {
    this.name = name;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(name, spec.attrs);
    this.excluded = null;
    let defaults = defaultAttrs(this.attrs);
    this.instance = defaults ? new Mark(this, defaults) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(attrs = null) {
    if (!attrs && this.instance)
      return this.instance;
    return new Mark(this, computeAttrs(this.attrs, attrs));
  }
  /**
  @internal
  */
  static compile(marks, schema) {
    let result = /* @__PURE__ */ Object.create(null), rank = 0;
    marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec));
    return result;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(set) {
    for (var i = 0; i < set.length; i++)
      if (set[i].type == this) {
        set = set.slice(0, i).concat(set.slice(i + 1));
        i--;
      }
    return set;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (set[i].type == this)
        return set[i];
  }
  /**
  @internal
  */
  checkAttrs(attrs) {
    checkAttrs(this.attrs, attrs, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(other) {
    return this.excluded.indexOf(other) > -1;
  }
}
let Schema$1 = class Schema {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(spec) {
    this.linebreakReplacement = null;
    this.cached = /* @__PURE__ */ Object.create(null);
    let instanceSpec = this.spec = {};
    for (let prop in spec)
      instanceSpec[prop] = spec[prop];
    instanceSpec.nodes = OrderedMap.from(spec.nodes), instanceSpec.marks = OrderedMap.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    let contentExprCache = /* @__PURE__ */ Object.create(null);
    for (let prop in this.nodes) {
      if (prop in this.marks)
        throw new RangeError(prop + " can not be both a node and a mark");
      let type2 = this.nodes[prop], contentExpr = type2.spec.content || "", markExpr = type2.spec.marks;
      type2.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type2.inlineContent = type2.contentMatch.inlineContent;
      if (type2.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!type2.isInline || !type2.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = type2;
      }
      type2.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type2.inlineContent ? [] : null;
    }
    for (let prop in this.marks) {
      let type2 = this.marks[prop], excl = type2.spec.excludes;
      type2.excluded = excl == null ? [type2] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }
    this.nodeFromJSON = (json) => Node$1.fromJSON(this, json);
    this.markFromJSON = (json) => Mark.fromJSON(this, json);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(type2, attrs = null, content, marks) {
    if (typeof type2 == "string")
      type2 = this.nodeType(type2);
    else if (!(type2 instanceof NodeType))
      throw new RangeError("Invalid node type: " + type2);
    else if (type2.schema != this)
      throw new RangeError("Node type from different schema used (" + type2.name + ")");
    return type2.createChecked(attrs, content, marks);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(text, marks) {
    let type2 = this.nodes.text;
    return new TextNode(type2, type2.defaultAttrs, text, Mark.setFrom(marks));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(type2, attrs) {
    if (typeof type2 == "string")
      type2 = this.marks[type2];
    return type2.create(attrs);
  }
  /**
  @internal
  */
  nodeType(name) {
    let found2 = this.nodes[name];
    if (!found2)
      throw new RangeError("Unknown node type: " + name);
    return found2;
  }
};
function gatherMarks(schema, marks) {
  let found2 = [];
  for (let i = 0; i < marks.length; i++) {
    let name = marks[i], mark = schema.marks[name], ok = mark;
    if (mark) {
      found2.push(mark);
    } else {
      for (let prop in schema.marks) {
        let mark2 = schema.marks[prop];
        if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
          found2.push(ok = mark2);
      }
    }
    if (!ok)
      throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
  }
  return found2;
}
function isTagRule(rule) {
  return rule.tag != null;
}
function isStyleRule(rule) {
  return rule.style != null;
}
let DOMParser$1 = class DOMParser2 {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(schema, rules) {
    this.schema = schema;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    let matchedStyles = this.matchedStyles = [];
    rules.forEach((rule) => {
      if (isTagRule(rule)) {
        this.tags.push(rule);
      } else if (isStyleRule(rule)) {
        let prop = /[^=]*/.exec(rule.style)[0];
        if (matchedStyles.indexOf(prop) < 0)
          matchedStyles.push(prop);
        this.styles.push(rule);
      }
    });
    this.normalizeLists = !this.tags.some((r) => {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
        return false;
      let node = schema.nodes[r.node];
      return node.contentMatch.matchType(node);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(dom, options = {}) {
    let context = new ParseContext(this, options, false);
    context.addAll(dom, Mark.none, options.from, options.to);
    return context.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(dom, options = {}) {
    let context = new ParseContext(this, options, true);
    context.addAll(dom, Mark.none, options.from, options.to);
    return Slice.maxOpen(context.finish());
  }
  /**
  @internal
  */
  matchTag(dom, context, after) {
    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
      let rule = this.tags[i];
      if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          let result = rule.getAttrs(dom);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(prop, value, context, after) {
    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
      let rule = this.styles[i], style = rule.style;
      if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value))
        continue;
      if (rule.getAttrs) {
        let result = rule.getAttrs(value);
        if (result === false)
          continue;
        rule.attrs = result || void 0;
      }
      return rule;
    }
  }
  /**
  @internal
  */
  static schemaRules(schema) {
    let result = [];
    function insert(rule) {
      let priority = rule.priority == null ? 50 : rule.priority, i = 0;
      for (; i < result.length; i++) {
        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
        if (nextPriority < priority)
          break;
      }
      result.splice(i, 0, rule);
    }
    for (let name in schema.marks) {
      let rules = schema.marks[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark))
            rule.mark = name;
        });
    }
    for (let name in schema.nodes) {
      let rules = schema.nodes[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark))
            rule.node = name;
        });
    }
    return result;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).
  */
  static fromSchema(schema) {
    return schema.cached.domParser || (schema.cached.domParser = new DOMParser2(schema, DOMParser2.schemaRules(schema)));
  }
};
const blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
const ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
const listTags = { ol: true, ul: true };
const OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;
function wsOptionsFor(type2, preserveWhitespace, base) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type2 && type2.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;
}
class NodeContext {
  constructor(type2, attrs, marks, solid, match, options) {
    this.type = type2;
    this.attrs = attrs;
    this.marks = marks;
    this.solid = solid;
    this.options = options;
    this.content = [];
    this.activeMarks = Mark.none;
    this.match = match || (options & OPT_OPEN_LEFT ? null : type2.contentMatch);
  }
  findWrapping(node) {
    if (!this.match) {
      if (!this.type)
        return [];
      let fill = this.type.contentMatch.fillBefore(Fragment.from(node));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        let start = this.type.contentMatch, wrap2;
        if (wrap2 = start.findWrapping(node.type)) {
          this.match = start;
          return wrap2;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node.type);
  }
  finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      let last = this.content[this.content.length - 1], m2;
      if (last && last.isText && (m2 = /[ \t\r\n\u000c]+$/.exec(last.text))) {
        let text = last;
        if (last.text.length == m2[0].length)
          this.content.pop();
        else
          this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m2[0].length));
      }
    }
    let content = Fragment.from(this.content);
    if (!openEnd && this.match)
      content = content.append(this.match.fillBefore(Fragment.empty, true));
    return this.type ? this.type.create(this.attrs, content, this.marks) : content;
  }
  inlineContext(node) {
    if (this.type)
      return this.type.inlineContent;
    if (this.content.length)
      return this.content[0].isInline;
    return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());
  }
}
class ParseContext {
  constructor(parser, options, isOpen) {
    this.parser = parser;
    this.options = options;
    this.isOpen = isOpen;
    this.open = 0;
    this.localPreserveWS = false;
    let topNode = options.topNode, topContext;
    let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode)
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
    else if (isOpen)
      topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);
    else
      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options.findPositions;
    this.needsBlock = false;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(dom, marks) {
    if (dom.nodeType == 3)
      this.addTextNode(dom, marks);
    else if (dom.nodeType == 1)
      this.addElement(dom, marks);
  }
  addTextNode(dom, marks) {
    let value = dom.nodeValue;
    let top = this.top, preserveWS = top.options & OPT_PRESERVE_WS_FULL ? "full" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;
    let { schema } = this.parser;
    if (preserveWS === "full" || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!preserveWS) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          let nodeBefore = top.content[top.content.length - 1];
          let domNodeBefore = dom.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            value = value.slice(1);
        }
      } else if (preserveWS === "full") {
        value = value.replace(/\r\n?/g, "\n");
      } else if (schema.linebreakReplacement && /[\r\n]/.test(value) && this.top.findWrapping(schema.linebreakReplacement.create())) {
        let lines = value.split(/\r?\n|\r/);
        for (let i = 0; i < lines.length; i++) {
          if (i)
            this.insertNode(schema.linebreakReplacement.create(), marks, true);
          if (lines[i])
            this.insertNode(schema.text(lines[i]), marks, !/\S/.test(lines[i]));
        }
        value = "";
      } else {
        value = value.replace(/\r?\n|\r/g, " ");
      }
      if (value)
        this.insertNode(schema.text(value), marks, !/\S/.test(value));
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(dom, marks, matchAfter) {
    let outerWS = this.localPreserveWS, top = this.top;
    if (dom.tagName == "PRE" || /pre/.test(dom.style && dom.style.whiteSpace))
      this.localPreserveWS = true;
    let name = dom.nodeName.toLowerCase(), ruleID;
    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
      normalizeList(dom);
    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
    out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
      this.findInside(dom);
      this.ignoreFallback(dom, marks);
    } else if (!rule || rule.skip || rule.closeParent) {
      if (rule && rule.closeParent)
        this.open = Math.max(0, this.open - 1);
      else if (rule && rule.skip.nodeType)
        dom = rule.skip;
      let sync, oldNeedsBlock = this.needsBlock;
      if (blockTags.hasOwnProperty(name)) {
        if (top.content.length && top.content[0].isInline && this.open) {
          this.open--;
          top = this.top;
        }
        sync = true;
        if (!top.type)
          this.needsBlock = true;
      } else if (!dom.firstChild) {
        this.leafFallback(dom, marks);
        break out;
      }
      let innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);
      if (innerMarks)
        this.addAll(dom, innerMarks);
      if (sync)
        this.sync(top);
      this.needsBlock = oldNeedsBlock;
    } else {
      let innerMarks = this.readStyles(dom, marks);
      if (innerMarks)
        this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : void 0);
    }
    this.localPreserveWS = outerWS;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(dom, marks) {
    if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
      this.addTextNode(dom.ownerDocument.createTextNode("\n"), marks);
  }
  // Called for ignored nodes
  ignoreFallback(dom, marks) {
    if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
      this.findPlace(this.parser.schema.text("-"), marks, true);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(dom, marks) {
    let styles = dom.style;
    if (styles && styles.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let name = this.parser.matchedStyles[i], value = styles.getPropertyValue(name);
        if (value)
          for (let after = void 0; ; ) {
            let rule = this.parser.matchStyle(name, value, this, after);
            if (!rule)
              break;
            if (rule.ignore)
              return null;
            if (rule.clearMark)
              marks = marks.filter((m2) => !rule.clearMark(m2));
            else
              marks = marks.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));
            if (rule.consuming === false)
              after = rule;
            else
              break;
          }
      }
    return marks;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(dom, rule, marks, continueAfter) {
    let sync, nodeType;
    if (rule.node) {
      nodeType = this.parser.schema.nodes[rule.node];
      if (!nodeType.isLeaf) {
        let inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);
        if (inner) {
          sync = true;
          marks = inner;
        }
      } else if (!this.insertNode(nodeType.create(rule.attrs), marks, dom.nodeName == "BR")) {
        this.leafFallback(dom, marks);
      }
    } else {
      let markType = this.parser.schema.marks[rule.mark];
      marks = marks.concat(markType.create(rule.attrs));
    }
    let startIn = this.top;
    if (nodeType && nodeType.isLeaf) {
      this.findInside(dom);
    } else if (continueAfter) {
      this.addElement(dom, marks, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach((node) => this.insertNode(node, marks, false));
    } else {
      let contentDOM = dom;
      if (typeof rule.contentElement == "string")
        contentDOM = dom.querySelector(rule.contentElement);
      else if (typeof rule.contentElement == "function")
        contentDOM = rule.contentElement(dom);
      else if (rule.contentElement)
        contentDOM = rule.contentElement;
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM, marks);
      this.findAround(dom, contentDOM, false);
    }
    if (sync && this.sync(startIn))
      this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(parent, marks, startIndex, endIndex) {
    let index2 = startIndex || 0;
    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index2) {
      this.findAtPoint(parent, index2);
      this.addDOM(dom, marks);
    }
    this.findAtPoint(parent, index2);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(node, marks, cautious) {
    let route, sync;
    for (let depth = this.open, penalty = 0; depth >= 0; depth--) {
      let cx = this.nodes[depth];
      let found2 = cx.findWrapping(node);
      if (found2 && (!route || route.length > found2.length + penalty)) {
        route = found2;
        sync = cx;
        if (!found2.length)
          break;
      }
      if (cx.solid) {
        if (cautious)
          break;
        penalty += 2;
      }
    }
    if (!route)
      return null;
    this.sync(sync);
    for (let i = 0; i < route.length; i++)
      marks = this.enterInner(route[i], null, marks, false);
    return marks;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(node, marks, cautious) {
    if (node.isInline && this.needsBlock && !this.top.type) {
      let block = this.textblockFromContext();
      if (block)
        marks = this.enterInner(block, null, marks);
    }
    let innerMarks = this.findPlace(node, marks, cautious);
    if (innerMarks) {
      this.closeExtra();
      let top = this.top;
      if (top.match)
        top.match = top.match.matchType(node.type);
      let nodeMarks = Mark.none;
      for (let m2 of innerMarks.concat(node.marks))
        if (top.type ? top.type.allowsMarkType(m2.type) : markMayApply(m2.type, node.type))
          nodeMarks = m2.addToSet(nodeMarks);
      top.content.push(node.mark(nodeMarks));
      return true;
    }
    return false;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(type2, attrs, marks, preserveWS) {
    let innerMarks = this.findPlace(type2.create(attrs), marks, false);
    if (innerMarks)
      innerMarks = this.enterInner(type2, attrs, marks, true, preserveWS);
    return innerMarks;
  }
  // Open a node of the given type
  enterInner(type2, attrs, marks, solid = false, preserveWS) {
    this.closeExtra();
    let top = this.top;
    top.match = top.match && top.match.matchType(type2);
    let options = wsOptionsFor(type2, preserveWS, top.options);
    if (top.options & OPT_OPEN_LEFT && top.content.length == 0)
      options |= OPT_OPEN_LEFT;
    let applyMarks = Mark.none;
    marks = marks.filter((m2) => {
      if (top.type ? top.type.allowsMarkType(m2.type) : markMayApply(m2.type, type2)) {
        applyMarks = m2.addToSet(applyMarks);
        return false;
      }
      return true;
    });
    this.nodes.push(new NodeContext(type2, attrs, applyMarks, solid, null, options));
    this.open++;
    return marks;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(openEnd = false) {
    let i = this.nodes.length - 1;
    if (i > this.open) {
      for (; i > this.open; i--)
        this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(to) {
    for (let i = this.open; i >= 0; i--) {
      if (this.nodes[i] == to) {
        this.open = i;
        return true;
      } else if (this.localPreserveWS) {
        this.nodes[i].options |= OPT_PRESERVE_WS;
      }
    }
    return false;
  }
  get currentPos() {
    this.closeExtra();
    let pos = 0;
    for (let i = this.open; i >= 0; i--) {
      let content = this.nodes[i].content;
      for (let j2 = content.length - 1; j2 >= 0; j2--)
        pos += content[j2].nodeSize;
      if (i)
        pos++;
    }
    return pos;
  }
  findAtPoint(parent, offset) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset)
          this.find[i].pos = this.currentPos;
      }
  }
  findInside(parent) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
          this.find[i].pos = this.currentPos;
      }
  }
  findAround(parent, content, before) {
    if (parent != content && this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          let pos = content.compareDocumentPosition(this.find[i].node);
          if (pos & (before ? 2 : 4))
            this.find[i].pos = this.currentPos;
        }
      }
  }
  findInText(textNode) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode)
          this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
  }
  // Determines whether the given context string matches this context.
  matchesContext(context) {
    if (context.indexOf("|") > -1)
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    let parts = context.split("/");
    let option = this.options.context;
    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
    let match = (i, depth) => {
      for (; i >= 0; i--) {
        let part = parts[i];
        if (part == "") {
          if (i == parts.length - 1 || i == 0)
            continue;
          for (; depth >= minDepth; depth--)
            if (match(i - 1, depth))
              return true;
          return false;
        } else {
          let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
          if (!next || next.name != part && !next.isInGroup(part))
            return false;
          depth--;
        }
      }
      return true;
    };
    return match(parts.length - 1, this.open);
  }
  textblockFromContext() {
    let $context = this.options.context;
    if ($context)
      for (let d2 = $context.depth; d2 >= 0; d2--) {
        let deflt = $context.node(d2).contentMatchAt($context.indexAfter(d2)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs)
          return deflt;
      }
    for (let name in this.parser.schema.nodes) {
      let type2 = this.parser.schema.nodes[name];
      if (type2.isTextblock && type2.defaultAttrs)
        return type2;
    }
  }
}
function normalizeList(dom) {
  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function copy(obj) {
  let copy2 = {};
  for (let prop in obj)
    copy2[prop] = obj[prop];
  return copy2;
}
function markMayApply(markType, nodeType) {
  let nodes = nodeType.schema.nodes;
  for (let name in nodes) {
    let parent = nodes[name];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen = [], scan = (match) => {
      seen.push(match);
      for (let i = 0; i < match.edgeCount; i++) {
        let { type: type2, next } = match.edge(i);
        if (type2 == nodeType)
          return true;
        if (seen.indexOf(next) < 0 && scan(next))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}
class DOMSerializer {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(nodes, marks) {
    this.nodes = nodes;
    this.marks = marks;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(fragment, options = {}, target) {
    if (!target)
      target = doc(options).createDocumentFragment();
    let top = target, active = [];
    fragment.forEach((node) => {
      if (active.length || node.marks.length) {
        let keep = 0, rendered = 0;
        while (keep < active.length && rendered < node.marks.length) {
          let next = node.marks[rendered];
          if (!this.marks[next.type.name]) {
            rendered++;
            continue;
          }
          if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
            break;
          keep++;
          rendered++;
        }
        while (keep < active.length)
          top = active.pop()[1];
        while (rendered < node.marks.length) {
          let add = node.marks[rendered++];
          let markDOM = this.serializeMark(add, node.isInline, options);
          if (markDOM) {
            active.push([add, top]);
            top.appendChild(markDOM.dom);
            top = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top.appendChild(this.serializeNodeInner(node, options));
    });
    return target;
  }
  /**
  @internal
  */
  serializeNodeInner(node, options) {
    let { dom, contentDOM } = renderSpec(doc(options), this.nodes[node.type.name](node), null, node.attrs);
    if (contentDOM) {
      if (node.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(node.content, options, contentDOM);
    }
    return dom;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(node, options = {}) {
    let dom = this.serializeNodeInner(node, options);
    for (let i = node.marks.length - 1; i >= 0; i--) {
      let wrap2 = this.serializeMark(node.marks[i], node.isInline, options);
      if (wrap2) {
        (wrap2.contentDOM || wrap2.dom).appendChild(dom);
        dom = wrap2.dom;
      }
    }
    return dom;
  }
  /**
  @internal
  */
  serializeMark(mark, inline, options = {}) {
    let toDOM = this.marks[mark.type.name];
    return toDOM && renderSpec(doc(options), toDOM(mark, inline), null, mark.attrs);
  }
  static renderSpec(doc2, structure, xmlNS = null, blockArraysIn) {
    return renderSpec(doc2, structure, xmlNS, blockArraysIn);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(schema) {
    return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(schema) {
    let result = gatherToDOM(schema.nodes);
    if (!result.text)
      result.text = (node) => node.text;
    return result;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(schema) {
    return gatherToDOM(schema.marks);
  }
}
function gatherToDOM(obj) {
  let result = {};
  for (let name in obj) {
    let toDOM = obj[name].spec.toDOM;
    if (toDOM)
      result[name] = toDOM;
  }
  return result;
}
function doc(options) {
  return options.document || window.document;
}
const suspiciousAttributeCache = /* @__PURE__ */ new WeakMap();
function suspiciousAttributes(attrs) {
  let value = suspiciousAttributeCache.get(attrs);
  if (value === void 0)
    suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));
  return value;
}
function suspiciousAttributesInner(attrs) {
  let result = null;
  function scan(value) {
    if (value && typeof value == "object") {
      if (Array.isArray(value)) {
        if (typeof value[0] == "string") {
          if (!result)
            result = [];
          result.push(value);
        } else {
          for (let i = 0; i < value.length; i++)
            scan(value[i]);
        }
      } else {
        for (let prop in value)
          scan(value[prop]);
      }
    }
  }
  scan(attrs);
  return result;
}
function renderSpec(doc2, structure, xmlNS, blockArraysIn) {
  if (typeof structure == "string")
    return { dom: doc2.createTextNode(structure) };
  if (structure.nodeType != null)
    return { dom: structure };
  if (structure.dom && structure.dom.nodeType != null)
    return structure;
  let tagName = structure[0], suspicious;
  if (typeof tagName != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let space = tagName.indexOf(" ");
  if (space > 0) {
    xmlNS = tagName.slice(0, space);
    tagName = tagName.slice(space + 1);
  }
  let contentDOM;
  let dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
  let attrs = structure[1], start = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start = 2;
    for (let name in attrs)
      if (attrs[name] != null) {
        let space2 = name.indexOf(" ");
        if (space2 > 0)
          dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);
        else if (name == "style" && dom.style)
          dom.style.cssText = attrs[name];
        else
          dom.setAttribute(name, attrs[name]);
      }
  }
  for (let i = start; i < structure.length; i++) {
    let child = structure[i];
    if (child === 0) {
      if (i < structure.length - 1 || i > start)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom, contentDOM: dom };
    } else {
      let { dom: inner, contentDOM: innerContent } = renderSpec(doc2, child, xmlNS, blockArraysIn);
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM)
          throw new RangeError("Multiple content holes");
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
}
const PIXELS_PER_INCH = 96;
function inchesToTwips(inches) {
  if (inches == null) return;
  if (typeof inches === "string") inches = parseFloat(inches);
  return Math.round(Number(inches) * 1440);
}
function twipsToInches(twips) {
  if (twips == null) return;
  const value = Number(twips);
  if (Number.isNaN(value)) return;
  return value / 1440;
}
function twipsToPixels(twips) {
  if (twips == null) return;
  const inches = twipsToInches(twips);
  return inchesToPixels(inches);
}
function pixelsToTwips(pixels) {
  const inches = pixelsToInches(pixels);
  return inchesToTwips(inches);
}
function inchesToPixels(inches) {
  if (inches == null) return;
  const pixels = inches * PIXELS_PER_INCH;
  return Math.round(pixels * 1e3) / 1e3;
}
function pixelsToInches(pixels) {
  if (pixels == null) return;
  const inches = Number(pixels) / PIXELS_PER_INCH;
  return inches;
}
function twipsToLines(twips) {
  if (twips == null) return;
  return twips / 240;
}
function linesToTwips(lines) {
  if (lines == null) return;
  return lines * 240;
}
function halfPointToPoints(halfPoints) {
  if (halfPoints == null) return;
  return Math.round(halfPoints) / 2;
}
function emuToPixels(emu) {
  if (emu == null) return;
  if (typeof emu === "string") emu = parseFloat(emu);
  const pixels = emu * PIXELS_PER_INCH / 914400;
  return Math.round(pixels);
}
function pixelsToEmu(px) {
  if (px == null) return;
  if (typeof px === "string") px = parseFloat(px);
  return Math.round(px * 9525);
}
function eighthPointsToPixels(eighthPoints) {
  if (eighthPoints == null) return;
  const points = parseFloat(eighthPoints) / 8;
  const pixels = points * 1.3333;
  return pixels;
}
function pointsToTwips(points) {
  if (points == null) return;
  return points * 20;
}
function pixelsToEightPoints(pixels) {
  if (pixels == null) return;
  return Math.round(pixels * 6);
}
function twipsToPt(twips) {
  if (twips == null) return;
  return twips / 20;
}
function ptToTwips(pt) {
  if (pt == null) return;
  return pt * 20;
}
function rotToDegrees(rot) {
  if (rot == null) return;
  return rot / 6e4;
}
function degreesToRot(degrees) {
  if (degrees == null) return;
  return degrees * 6e4;
}
function pixelsToPolygonUnits(pixels) {
  if (pixels == null) return;
  const pu = pixels * PIXELS_PER_INCH;
  return Math.round(pu);
}
function polygonUnitsToPixels(pu) {
  if (pu == null) return;
  const pixels = Number(pu) / PIXELS_PER_INCH;
  return Math.round(pixels * 1e3) / 1e3;
}
function polygonToObj(polygonNode) {
  if (!polygonNode) return null;
  const points = [];
  polygonNode.elements.forEach((element) => {
    if (["wp:start", "wp:lineTo"].includes(element.name)) {
      const { x: x2, y: y2 } = element.attributes;
      points.push([polygonUnitsToPixels(x2), polygonUnitsToPixels(y2)]);
    }
  });
  if (points.length > 1) {
    const firstPoint = points[0];
    const lastPoint = points[points.length - 1];
    if (firstPoint[0] === lastPoint[0] && firstPoint[1] === lastPoint[1]) {
      points.pop();
    }
  }
  return points;
}
function objToPolygon(points) {
  if (!points || !Array.isArray(points)) return null;
  const polygonNode = {
    name: "wp:wrapPolygon",
    type: "wp:wrapPolygon",
    attributes: {
      edited: "0"
    },
    elements: []
  };
  points.forEach((point, index2) => {
    const [x2, y2] = point;
    const tagName = index2 === 0 ? "wp:start" : "wp:lineTo";
    const pointNode = {
      name: tagName,
      type: tagName,
      attributes: {
        x: pixelsToPolygonUnits(x2),
        y: pixelsToPolygonUnits(y2)
      }
    };
    polygonNode.elements.push(pointNode);
  });
  if (points.length > 0) {
    const [startX, startY] = points[0];
    const closePointNode = {
      name: "wp:lineTo",
      type: "wp:lineTo",
      attributes: {
        x: pixelsToPolygonUnits(startX),
        y: pixelsToPolygonUnits(startY)
      }
    };
    polygonNode.elements.push(closePointNode);
  }
  return polygonNode;
}
const REMOTE_RESOURCE_PATTERN = /^https?:|^blob:|^file:/i;
const DATA_URI_PATTERN = /^data:/i;
const getArrayBufferFromUrl = async (input) => {
  if (input == null) {
    return new ArrayBuffer(0);
  }
  if (input instanceof ArrayBuffer) {
    return input;
  }
  if (ArrayBuffer.isView(input)) {
    const view = input;
    return view.buffer.slice(view.byteOffset, view.byteOffset + view.byteLength);
  }
  if (typeof Blob !== "undefined" && input instanceof Blob) {
    return await input.arrayBuffer();
  }
  if (typeof input !== "string") {
    throw new TypeError("Unsupported media input type");
  }
  const trimmed = input.trim();
  const shouldFetchRemote = REMOTE_RESOURCE_PATTERN.test(trimmed);
  const isDataUri = DATA_URI_PATTERN.test(trimmed);
  if (shouldFetchRemote) {
    if (typeof fetch !== "function") {
      throw new Error(`Fetch API is not available to retrieve media: ${trimmed}`);
    }
    const response = await fetch(trimmed);
    if (!response.ok) {
      throw new Error(`Fetch failed: ${response.status} ${response.statusText}`);
    }
    return await response.arrayBuffer();
  }
  const base64Payload = isDataUri ? trimmed.split(",", 2)[1] : trimmed.replace(/\s/g, "");
  try {
    if (typeof globalThis.atob === "function") {
      const binary = globalThis.atob(base64Payload);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes.buffer;
    }
  } catch (err) {
    console.warn("atob failed, falling back to Buffer:", err);
  }
  const buf = Buffer2.from(base64Payload, "base64");
  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
};
const getContentTypesFromXml = (contentTypesXml) => {
  try {
    const result = libExports.xml2js(contentTypesXml, { compact: false });
    const types2 = result?.elements?.[0]?.elements || [];
    return types2.filter((el) => el?.name === "Default").map((el) => el.attributes?.Extension).filter(Boolean);
  } catch (err) {
    console.warn("[super-editor] Failed to parse [Content_Types].xml", err);
    return [];
  }
};
const resolveOpcTargetPath = (target, baseDir = "word") => {
  if (!target) return null;
  if (target.includes("://")) return null;
  if (target.startsWith("/")) {
    return target.slice(1);
  }
  const segments = `${baseDir}/${target}`.split("/");
  const resolved = [];
  for (const seg of segments) {
    if (seg === "..") {
      resolved.pop();
    } else if (seg !== "." && seg !== "") {
      resolved.push(seg);
    }
  }
  return resolved.join("/");
};
const DOCX_HIGHLIGHT_KEYWORD_MAP = /* @__PURE__ */ new Map([
  ["yellow", "FFFF00"],
  ["green", "00FF00"],
  ["blue", "0000FF"],
  ["cyan", "00FFFF"],
  ["magenta", "FF00FF"],
  ["red", "FF0000"],
  ["darkYellow", "808000"],
  ["darkGreen", "008000"],
  ["darkBlue", "000080"],
  ["darkCyan", "008080"],
  ["darkMagenta", "800080"],
  ["darkGray", "808080"],
  ["darkRed", "800000"],
  ["lightGray", "C0C0C0"],
  ["black", "000000"],
  ["white", "FFFFFF"]
]);
const normalizeHexColor = (hex) => {
  if (!hex) return null;
  let value = hex.replace("#", "").trim();
  if (!value) return null;
  value = value.toUpperCase();
  if (value.length === 3)
    value = value.split("").map((c) => c + c).join("");
  if (value.length === 8) value = value.slice(0, 6);
  return value;
};
const getHexColorFromDocxSystem = (docxColor) => {
  const hex = DOCX_HIGHLIGHT_KEYWORD_MAP.get(docxColor);
  return hex ? `#${hex}` : null;
};
const getDocxHighlightKeywordFromHex = (hexColor) => {
  if (!hexColor) return null;
  if (DOCX_HIGHLIGHT_KEYWORD_MAP.has(hexColor)) return hexColor;
  const normalized = normalizeHexColor(hexColor);
  if (!normalized) return null;
  for (const [keyword, hex] of DOCX_HIGHLIGHT_KEYWORD_MAP.entries()) {
    if (hex === normalized) return keyword;
  }
  return null;
};
function isValidHexColor(color) {
  if (!color || typeof color !== "string") return false;
  switch (color.length) {
    case 3:
      return /^[0-9A-F]{3}$/i.test(color);
    case 6:
      return /^[0-9A-F]{6}$/i.test(color);
    case 8:
      return /^[0-9A-F]{8}$/i.test(color);
    default:
      return false;
  }
}
const componentToHex = (val) => {
  const a = Number(val).toString(16);
  return a.length === 1 ? "0" + a : a;
};
const rgbToHex = (rgb) => {
  return "#" + rgb.match(/\d+/g).map(componentToHex).join("");
};
const DEFAULT_SHADING_FOREGROUND_COLOR = "#000000";
const hexToRgb = (hex) => {
  const normalized = normalizeHexColor(hex);
  if (!normalized) return null;
  return {
    r: Number.parseInt(normalized.slice(0, 2), 16),
    g: Number.parseInt(normalized.slice(2, 4), 16),
    b: Number.parseInt(normalized.slice(4, 6), 16)
  };
};
const clamp01 = (value) => {
  if (!Number.isFinite(value)) return 0;
  return Math.min(1, Math.max(0, value));
};
const blendHexColors = (backgroundHex, foregroundHex, foregroundRatio) => {
  const background = hexToRgb(backgroundHex);
  const foreground = hexToRgb(foregroundHex);
  if (!background || !foreground) return null;
  const ratio = clamp01(foregroundRatio);
  const r = Math.round(background.r * (1 - ratio) + foreground.r * ratio);
  const g = Math.round(background.g * (1 - ratio) + foreground.g * ratio);
  const b2 = Math.round(background.b * (1 - ratio) + foreground.b * ratio);
  const toByte = (n) => n.toString(16).padStart(2, "0").toUpperCase();
  return `${toByte(r)}${toByte(g)}${toByte(b2)}`;
};
const resolveShadingFillColor = (shading) => {
  if (!shading || typeof shading !== "object") return null;
  const fill = normalizeHexColor(shading.fill);
  if (!fill) return null;
  const val = typeof shading.val === "string" ? shading.val.trim().toLowerCase() : "";
  const pctMatch = val.match(/^pct(\d{1,3})$/);
  if (!pctMatch) return fill;
  const pct = Number.parseInt(pctMatch[1], 10);
  if (!Number.isFinite(pct) || pct < 0 || pct > 100) return fill;
  const foreground = normalizeHexColor(shading.color) ?? DEFAULT_SHADING_FOREGROUND_COLOR;
  return blendHexColors(fill, foreground, pct / 100) ?? fill;
};
const deobfuscateFont = (arrayBuffer, guidHex) => {
  const dta = new Uint8Array(arrayBuffer);
  const guidStr = guidHex.replace(/[-{}]/g, "");
  if (guidStr.length !== 32) {
    console.error("Invalid GUID");
    return;
  }
  const guidBytes = new Uint8Array(16);
  for (let i = 0, j2 = 0; i < 32; i += 2, j2++) {
    const hexByte = guidStr[i] + guidStr[i + 1];
    guidBytes[j2] = parseInt(hexByte, 16);
  }
  for (let i = 0; i < 32; i++) {
    const gi = 15 - i % 16;
    dta[i] ^= guidBytes[gi];
  }
  return dta.buffer;
};
function convertSizeToCSS(value, type2) {
  if (typeof value === "string" && value.endsWith("%")) {
    type2 = "pct";
  }
  if (value === null || value === void 0) {
    value = 0;
  }
  switch (type2) {
    case "dxa":
    case null:
    case void 0:
      return `${twipsToPixels(value)}px`;
    case "nil":
      return "0";
    case "auto":
      return null;
    case "pct":
      let percent;
      if (typeof value === "number") {
        percent = value * 0.02;
      } else {
        if (value.endsWith("%")) {
          percent = parseFloat(value.slice(0, -1));
        } else {
          percent = parseFloat(value) * 0.02;
        }
      }
      return `${percent}%`;
    default:
      return null;
  }
}
const DEFAULT_DOCX_DEFS = {
  "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
  "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
  "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
  "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
  "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
  "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
  "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
  "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
  "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
  "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
  "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
  "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
  "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
  "xmlns:o": "urn:schemas-microsoft-com:office:office",
  "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
  "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
  "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
  "xmlns:v": "urn:schemas-microsoft-com:vml",
  "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
  "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
  "xmlns:a": "http://schemas.openxmlformats.org/drawingml/2006/main",
  "xmlns:pic": "http://schemas.openxmlformats.org/drawingml/2006/picture",
  "xmlns:c": "http://schemas.openxmlformats.org/drawingml/2006/chart",
  "xmlns:dgm": "http://schemas.openxmlformats.org/drawingml/2006/diagram",
  "xmlns:lc": "http://schemas.openxmlformats.org/drawingml/2006/lockedCanvas",
  "xmlns:w10": "urn:schemas-microsoft-com:office:word",
  "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
  "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
  "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
  "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
  "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
  "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
  "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
  "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
  "xmlns:w16sdtfl": "http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock",
  "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
  "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
  "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
  "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
  "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
  "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl w16du wp14"
};
const DEFAULT_CUSTOM_XML = {
  elements: [
    {
      type: "element",
      name: "Properties",
      attributes: {
        xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
        "xmlns:vt": "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"
      },
      elements: []
    }
  ]
};
const COMMENT_REF = {
  type: "element",
  name: "w:r",
  elements: [
    {
      type: "element",
      name: "w:rPr",
      elements: [
        {
          type: "element",
          name: "w:rStyle",
          attributes: {
            "w:val": "CommentReference"
          }
        }
      ]
    },
    {
      type: "element",
      name: "w:annotationRef"
    }
  ]
};
const DEFAULT_LINKED_STYLES = {
  Normal: {
    type: "element",
    name: "w:style",
    attributes: {
      "w:type": "paragraph",
      "w:default": "1",
      "w:styleId": "Normal"
    },
    elements: [
      {
        type: "element",
        name: "w:name",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:qFormat"
      }
    ]
  },
  Title: {
    type: "element",
    name: "w:style",
    attributes: {
      "w:type": "paragraph",
      "w:styleId": "Title"
    },
    elements: [
      {
        type: "element",
        name: "w:name",
        attributes: {
          "w:val": "Title"
        }
      },
      {
        type: "element",
        name: "w:basedOn",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:next",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:link",
        attributes: {
          "w:val": "TitleChar"
        }
      },
      {
        type: "element",
        name: "w:uiPriority",
        attributes: {
          "w:val": "10"
        }
      },
      {
        type: "element",
        name: "w:qFormat"
      },
      {
        type: "element",
        name: "w:rsid",
        attributes: {
          "w:val": "00B72667"
        }
      },
      {
        type: "element",
        name: "w:pPr",
        elements: [
          {
            type: "element",
            name: "w:spacing",
            attributes: {
              "w:after": "80"
            }
          },
          {
            type: "element",
            name: "w:contextualSpacing"
          }
        ]
      },
      {
        type: "element",
        name: "w:rPr",
        elements: [
          {
            type: "element",
            name: "w:rFonts",
            attributes: {
              "w:asciiTheme": "majorHAnsi",
              "w:eastAsiaTheme": "majorEastAsia",
              "w:hAnsiTheme": "majorHAnsi",
              "w:cstheme": "majorBidi"
            }
          },
          {
            type: "element",
            name: "w:spacing",
            attributes: {
              "w:val": "-10"
            }
          },
          {
            type: "element",
            name: "w:kern",
            attributes: {
              "w:val": "28"
            }
          },
          {
            type: "element",
            name: "w:sz",
            attributes: {
              "w:val": "56"
            }
          },
          {
            type: "element",
            name: "w:szCs",
            attributes: {
              "w:val": "56"
            }
          }
        ]
      }
    ]
  },
  Subtitle: {
    type: "element",
    name: "w:style",
    attributes: {
      "w:type": "paragraph",
      "w:styleId": "Subtitle"
    },
    elements: [
      {
        type: "element",
        name: "w:name",
        attributes: {
          "w:val": "Subtitle"
        }
      },
      {
        type: "element",
        name: "w:basedOn",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:next",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:link",
        attributes: {
          "w:val": "SubtitleChar"
        }
      },
      {
        type: "element",
        name: "w:uiPriority",
        attributes: {
          "w:val": "11"
        }
      },
      {
        type: "element",
        name: "w:qFormat"
      },
      {
        type: "element",
        name: "w:rsid",
        attributes: {
          "w:val": "00B72667"
        }
      },
      {
        type: "element",
        name: "w:pPr",
        elements: [
          {
            type: "element",
            name: "w:numPr",
            elements: [
              {
                type: "element",
                name: "w:ilvl",
                attributes: {
                  "w:val": "1"
                }
              }
            ]
          },
          {
            type: "element",
            name: "w:spacing",
            attributes: {
              "w:after": "160"
            }
          }
        ]
      },
      {
        type: "element",
        name: "w:rPr",
        elements: [
          {
            type: "element",
            name: "w:rFonts",
            attributes: {
              "w:asciiTheme": "minorHAnsi",
              "w:eastAsiaTheme": "majorEastAsia",
              "w:hAnsiTheme": "minorHAnsi",
              "w:cstheme": "majorBidi"
            }
          },
          {
            type: "element",
            name: "w:color",
            attributes: {
              "w:val": "595959",
              "w:themeColor": "text1",
              "w:themeTint": "A6"
            }
          },
          {
            type: "element",
            name: "w:spacing",
            attributes: {
              "w:val": "15"
            }
          },
          {
            type: "element",
            name: "w:sz",
            attributes: {
              "w:val": "28"
            }
          },
          {
            type: "element",
            name: "w:szCs",
            attributes: {
              "w:val": "28"
            }
          }
        ]
      }
    ]
  },
  Heading1: {
    type: "element",
    name: "w:style",
    attributes: {
      "w:type": "paragraph",
      "w:styleId": "Heading1"
    },
    elements: [
      {
        type: "element",
        name: "w:name",
        attributes: {
          "w:val": "heading 1"
        }
      },
      {
        type: "element",
        name: "w:basedOn",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:next",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:link",
        attributes: {
          "w:val": "Heading1Char"
        }
      },
      {
        type: "element",
        name: "w:uiPriority",
        attributes: {
          "w:val": "9"
        }
      },
      {
        type: "element",
        name: "w:qFormat"
      },
      {
        type: "element",
        name: "w:rsid",
        attributes: {
          "w:val": "00233D7B"
        }
      },
      {
        type: "element",
        name: "w:pPr",
        elements: [
          {
            type: "element",
            name: "w:keepNext"
          },
          {
            type: "element",
            name: "w:keepLines"
          },
          {
            type: "element",
            name: "w:spacing",
            attributes: {
              "w:before": "360",
              "w:after": "80"
            }
          },
          {
            type: "element",
            name: "w:outlineLvl",
            attributes: {
              "w:val": "0"
            }
          }
        ]
      },
      {
        type: "element",
        name: "w:rPr",
        elements: [
          {
            type: "element",
            name: "w:rFonts",
            attributes: {
              "w:asciiTheme": "majorHAnsi",
              "w:eastAsiaTheme": "majorEastAsia",
              "w:hAnsiTheme": "majorHAnsi",
              "w:cstheme": "majorBidi"
            }
          },
          {
            type: "element",
            name: "w:color",
            attributes: {
              "w:val": "0F4761",
              "w:themeColor": "accent1",
              "w:themeShade": "BF"
            }
          },
          {
            type: "element",
            name: "w:sz",
            attributes: {
              "w:val": "40"
            }
          },
          {
            type: "element",
            name: "w:szCs",
            attributes: {
              "w:val": "40"
            }
          }
        ]
      }
    ]
  },
  Heading2: {
    type: "element",
    name: "w:style",
    attributes: {
      "w:type": "paragraph",
      "w:styleId": "Heading2"
    },
    elements: [
      {
        type: "element",
        name: "w:name",
        attributes: {
          "w:val": "heading 2"
        }
      },
      {
        type: "element",
        name: "w:basedOn",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:next",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:link",
        attributes: {
          "w:val": "Heading2Char"
        }
      },
      {
        type: "element",
        name: "w:uiPriority",
        attributes: {
          "w:val": "9"
        }
      },
      {
        type: "element",
        name: "w:semiHidden"
      },
      {
        type: "element",
        name: "w:unhideWhenUsed"
      },
      {
        type: "element",
        name: "w:qFormat"
      },
      {
        type: "element",
        name: "w:rsid",
        attributes: {
          "w:val": "00233D7B"
        }
      },
      {
        type: "element",
        name: "w:pPr",
        elements: [
          {
            type: "element",
            name: "w:keepNext"
          },
          {
            type: "element",
            name: "w:keepLines"
          },
          {
            type: "element",
            name: "w:spacing",
            attributes: {
              "w:before": "160",
              "w:after": "80"
            }
          },
          {
            type: "element",
            name: "w:outlineLvl",
            attributes: {
              "w:val": "1"
            }
          }
        ]
      },
      {
        type: "element",
        name: "w:rPr",
        elements: [
          {
            type: "element",
            name: "w:rFonts",
            attributes: {
              "w:asciiTheme": "majorHAnsi",
              "w:eastAsiaTheme": "majorEastAsia",
              "w:hAnsiTheme": "majorHAnsi",
              "w:cstheme": "majorBidi"
            }
          },
          {
            type: "element",
            name: "w:color",
            attributes: {
              "w:val": "0F4761",
              "w:themeColor": "accent1",
              "w:themeShade": "BF"
            }
          },
          {
            type: "element",
            name: "w:sz",
            attributes: {
              "w:val": "32"
            }
          },
          {
            type: "element",
            name: "w:szCs",
            attributes: {
              "w:val": "32"
            }
          }
        ]
      }
    ]
  },
  Heading3: {
    type: "element",
    name: "w:style",
    attributes: {
      "w:type": "paragraph",
      "w:styleId": "Heading3"
    },
    elements: [
      {
        type: "element",
        name: "w:name",
        attributes: {
          "w:val": "heading 3"
        }
      },
      {
        type: "element",
        name: "w:basedOn",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:next",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:link",
        attributes: {
          "w:val": "Heading3Char"
        }
      },
      {
        type: "element",
        name: "w:uiPriority",
        attributes: {
          "w:val": "9"
        }
      },
      {
        type: "element",
        name: "w:semiHidden"
      },
      {
        type: "element",
        name: "w:unhideWhenUsed"
      },
      {
        type: "element",
        name: "w:qFormat"
      },
      {
        type: "element",
        name: "w:rsid",
        attributes: {
          "w:val": "00233D7B"
        }
      },
      {
        type: "element",
        name: "w:pPr",
        elements: [
          {
            type: "element",
            name: "w:keepNext"
          },
          {
            type: "element",
            name: "w:keepLines"
          },
          {
            type: "element",
            name: "w:spacing",
            attributes: {
              "w:before": "160",
              "w:after": "80"
            }
          },
          {
            type: "element",
            name: "w:outlineLvl",
            attributes: {
              "w:val": "2"
            }
          }
        ]
      },
      {
        type: "element",
        name: "w:rPr",
        elements: [
          {
            type: "element",
            name: "w:rFonts",
            attributes: {
              "w:eastAsiaTheme": "majorEastAsia",
              "w:cstheme": "majorBidi"
            }
          },
          {
            type: "element",
            name: "w:color",
            attributes: {
              "w:val": "0F4761",
              "w:themeColor": "accent1",
              "w:themeShade": "BF"
            }
          },
          {
            type: "element",
            name: "w:sz",
            attributes: {
              "w:val": "28"
            }
          },
          {
            type: "element",
            name: "w:szCs",
            attributes: {
              "w:val": "28"
            }
          }
        ]
      }
    ]
  }
};
const COMMENTS_XML_DEF = {
  declaration: {
    attributes: {
      version: "1.0",
      encoding: "UTF-8",
      standalone: "yes"
    }
  },
  elements: [
    {
      type: "element",
      name: "w:comments",
      attributes: {
        "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
        "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
        "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
        "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
        "xmlns:o": "urn:schemas-microsoft-com:office:office",
        "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
        "xmlns:v": "urn:schemas-microsoft-com:vml",
        "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        "xmlns:w10": "urn:schemas-microsoft-com:office:word",
        "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
        "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
        "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
        "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
        "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
        "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
        "xmlns:w16sdtfl": "http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock",
        "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
        "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
        "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl w16du wp14"
      },
      elements: []
    }
  ]
};
const FOOTNOTES_XML_DEF = {
  declaration: {
    attributes: {
      version: "1.0",
      encoding: "UTF-8",
      standalone: "yes"
    }
  },
  elements: [
    {
      type: "element",
      name: "w:footnotes",
      attributes: {
        "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
        "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
        "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
        "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
        "xmlns:o": "urn:schemas-microsoft-com:office:office",
        "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
        "xmlns:v": "urn:schemas-microsoft-com:vml",
        "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        "xmlns:w10": "urn:schemas-microsoft-com:office:word",
        "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
        "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
        "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
        "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
        "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
        "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
        "xmlns:w16sdtfl": "http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock",
        "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
        "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
        "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl w16du wp14"
      },
      elements: []
    }
  ]
};
const COMMENTS_EXTENDED_XML_DEF = {
  declaration: {
    attributes: {
      version: "1.0",
      encoding: "UTF-8",
      standalone: "yes"
    }
  },
  elements: [
    {
      type: "element",
      name: "w15:commentsEx",
      attributes: {
        "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
        "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
        "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
        "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
        "xmlns:o": "urn:schemas-microsoft-com:office:office",
        "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
        "xmlns:v": "urn:schemas-microsoft-com:vml",
        "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        "xmlns:w10": "urn:schemas-microsoft-com:office:word",
        "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
        "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
        "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
        "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
        "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
        "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
        "xmlns:w16sdtfl": "http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock",
        "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
        "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
        "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl w16du wp14"
      },
      elements: []
    }
  ]
};
const COMMENTS_EXTENSIBLE_XML_DEF = {
  declaration: {
    attributes: {
      version: "1.0",
      encoding: "UTF-8",
      standalone: "yes"
    }
  },
  elements: [
    {
      type: "element",
      name: "w16cex:commentsExtensible",
      attributes: {
        "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
        "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        "xmlns:cr": "http://schemas.microsoft.com/office/comments/2020/reactions",
        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
        "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
        "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
        "xmlns:o": "urn:schemas-microsoft-com:office:office",
        "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
        "xmlns:v": "urn:schemas-microsoft-com:vml",
        "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        "xmlns:w10": "urn:schemas-microsoft-com:office:word",
        "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
        "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
        "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
        "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
        "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
        "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
        "xmlns:w16sdtfl": "http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock",
        "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
        "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
        "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl cr w16du wp14"
      },
      elements: []
    }
  ]
};
const COMMENTS_IDS_XML_DEF = {
  declaration: {
    attributes: {
      version: "1.0",
      encoding: "UTF-8",
      standalone: "yes"
    }
  },
  elements: [
    {
      type: "element",
      name: "w16cid:commentsIds",
      attributes: {
        "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
        "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
        "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
        "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
        "xmlns:o": "urn:schemas-microsoft-com:office:office",
        "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
        "xmlns:v": "urn:schemas-microsoft-com:vml",
        "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        "xmlns:w10": "urn:schemas-microsoft-com:office:word",
        "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
        "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
        "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
        "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
        "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
        "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
        "xmlns:w16sdtfl": "http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock",
        "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
        "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
        "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl w16du wp14"
      },
      elements: []
    }
  ]
};
const DOCUMENT_RELS_XML_DEF = {
  elements: [
    {
      type: "element",
      name: "Relationships",
      attributes: {
        xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
      },
      elements: [
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId8",
            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable",
            Target: "fontTable.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId3",
            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings",
            Target: "webSettings.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId7",
            Type: "http://schemas.microsoft.com/office/2018/08/relationships/commentsExtensible",
            Target: "commentsExtensible.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId2",
            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings",
            Target: "settings.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId1",
            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
            Target: "styles.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId6",
            Type: "http://schemas.microsoft.com/office/2016/09/relationships/commentsIds",
            Target: "commentsIds.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId5",
            Type: "http://schemas.microsoft.com/office/2011/relationships/commentsExtended",
            Target: "commentsExtended.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId10",
            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
            Target: "theme/theme1.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId4",
            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
            Target: "comments.xml"
          }
        }
        // {
        //     "type": "element",
        //     "name": "Relationship",
        //     "attributes": {
        //         "Id": "rId9",
        //         "Type": "http://schemas.microsoft.com/office/2011/relationships/people",
        //         "Target": "people.xml"
        //     }
        // }
      ]
    }
  ]
};
const CONTENT_TYPES = {
  declaration: {
    attributes: {
      version: "1.0",
      encoding: "UTF-8",
      standalone: "yes"
    }
  },
  elements: [
    {
      type: "element",
      name: "Types",
      attributes: {
        xmlns: "http://schemas.openxmlformats.org/package/2006/content-types"
      },
      elements: [
        {
          type: "element",
          name: "Default",
          attributes: {
            Extension: "rels",
            ContentType: "application/vnd.openxmlformats-package.relationships+xml"
          }
        },
        {
          type: "element",
          name: "Default",
          attributes: {
            Extension: "xml",
            ContentType: "application/xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/document.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/styles.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/settings.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/webSettings.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.webSettings+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/comments.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/commentsExtended.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.commentsExtended+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/commentsIds.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.commentsIds+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/commentsExtensible.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.commentsExtensible+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/fontTable.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/people.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.people+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/theme/theme1.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.theme+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/docProps/core.xml",
            ContentType: "application/vnd.openxmlformats-package.core-properties+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/docProps/app.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.extended-properties+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/numbering.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml"
          }
        }
      ]
    }
  ]
};
const COMMENTS_XML_DEFINITIONS = {
  COMMENTS_XML_DEF,
  COMMENTS_EXTENDED_XML_DEF,
  COMMENTS_EXTENSIBLE_XML_DEF,
  COMMENTS_IDS_XML_DEF,
  DOCUMENT_RELS_XML_DEF,
  CONTENT_TYPES
};
function translateChildNodes(params) {
  const { content: nodes } = params.node;
  if (!nodes) return [];
  const translatedNodes = [];
  const hyperlinkGroup = [];
  let index2 = 0;
  while (index2 < nodes.length) {
    const node = nodes[index2];
    const linkMark = _isLinkNode(node);
    if (linkMark) {
      hyperlinkGroup.push(node);
      const nextNode = index2 + 1 < nodes.length ? nodes[index2 + 1] : null;
      const nextIsLink = _isLinkNode(nextNode, linkMark);
      if (nextIsLink) {
        index2++;
        continue;
      } else {
        let translatedLinkGroup = exportSchemaToJson({
          ...params,
          node: hyperlinkGroup[0],
          extraParams: { ...params.extraParams || {}, hyperlinkGroup: hyperlinkGroup.slice() }
        });
        if (translatedLinkGroup instanceof Array) translatedNodes.push(...translatedLinkGroup);
        else translatedNodes.push(translatedLinkGroup);
        hyperlinkGroup.length = 0;
        index2++;
        continue;
      }
    }
    let translatedNode = exportSchemaToJson({ ...params, node });
    if (translatedNode instanceof Array) translatedNodes.push(...translatedNode);
    else translatedNodes.push(translatedNode);
    index2++;
  }
  return translatedNodes.filter((n) => n);
}
function _isLinkNode(node, referenceMark = null) {
  if (!node || !node.marks && !node.attrs?.marksAsAttrs) return null;
  const marks = node.marks || node.attrs.marksAsAttrs;
  const linkMark = marks.find((mark) => mark.type === "link");
  if (!linkMark) return null;
  if (referenceMark) {
    return _isSameLinkMark(linkMark.attrs, referenceMark.attrs) ? linkMark : null;
  }
  return linkMark;
}
function _isSameLinkMark(attrsA, attrsB) {
  for (let key of ["anchor", "docLocation", "history", "href", "rId", "target"]) {
    if (attrsA[key] != attrsB[key]) {
      return false;
    }
  }
  return true;
}
const baseNumbering = {
  declaration: {
    attributes: {
      version: "1.0",
      encoding: "UTF-8",
      standalone: "yes"
    }
  },
  elements: [
    {
      type: "element",
      name: "w:numbering",
      attributes: {
        "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
        "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
        "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
        "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
        "xmlns:o": "urn:schemas-microsoft-com:office:office",
        "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
        "xmlns:v": "urn:schemas-microsoft-com:vml",
        "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        "xmlns:w10": "urn:schemas-microsoft-com:office:word",
        "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
        "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
        "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
        "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
        "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
        "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
        "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
        "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
        "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16du wp14"
      },
      elements: [
        {
          type: "element",
          name: "w:abstractNum",
          attributes: {
            "w:abstractNumId": "0",
            "w15:restartNumberingAfterBreak": "0"
          },
          elements: [
            {
              type: "element",
              name: "w:nsid",
              attributes: {
                "w:val": "16126B07"
              }
            },
            {
              type: "element",
              name: "w:multiLevelType",
              attributes: {
                "w:val": "hybridMultilevel"
              }
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "0",
                "w:tplc": "04090001"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": ""
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "720",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Symbol",
                        "w:hAnsi": "Symbol",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "1",
                "w:tplc": "04090003",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "o"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "1440",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Courier New",
                        "w:hAnsi": "Courier New",
                        "w:cs": "Courier New",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "2",
                "w:tplc": "04090005",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": ""
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "2160",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Wingdings",
                        "w:hAnsi": "Wingdings",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "3",
                "w:tplc": "04090001",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": ""
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "2880",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Symbol",
                        "w:hAnsi": "Symbol",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "4",
                "w:tplc": "04090003",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "o"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "3600",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Courier New",
                        "w:hAnsi": "Courier New",
                        "w:cs": "Courier New",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "5",
                "w:tplc": "04090005",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": ""
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "4320",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Wingdings",
                        "w:hAnsi": "Wingdings",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "6",
                "w:tplc": "04090001",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": ""
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "5040",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Symbol",
                        "w:hAnsi": "Symbol",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "7",
                "w:tplc": "04090003",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "o"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "5760",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Courier New",
                        "w:hAnsi": "Courier New",
                        "w:cs": "Courier New",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "8",
                "w:tplc": "04090005",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": ""
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "6480",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Wingdings",
                        "w:hAnsi": "Wingdings",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          type: "element",
          name: "w:abstractNum",
          attributes: {
            "w:abstractNumId": "1",
            "w15:restartNumberingAfterBreak": "0"
          },
          elements: [
            {
              type: "element",
              name: "w:nsid",
              attributes: {
                "w:val": "587013BA"
              }
            },
            {
              type: "element",
              name: "w:multiLevelType",
              attributes: {
                "w:val": "hybridMultilevel"
              }
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "0",
                "w:tplc": "0409000F"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "decimal"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%1."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "720",
                        "w:hanging": "360"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "1",
                "w:tplc": "04090019",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "lowerLetter"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%2."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "1440",
                        "w:hanging": "360"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "2",
                "w:tplc": "0409001B",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "lowerRoman"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%3."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "right"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "2160",
                        "w:hanging": "180"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "3",
                "w:tplc": "0409000F",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "decimal"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%4."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "2880",
                        "w:hanging": "360"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "4",
                "w:tplc": "04090019",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "lowerLetter"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%5."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "3600",
                        "w:hanging": "360"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "5",
                "w:tplc": "0409001B",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "lowerRoman"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%6."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "right"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "4320",
                        "w:hanging": "180"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "6",
                "w:tplc": "0409000F",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "decimal"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%7."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "5040",
                        "w:hanging": "360"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "7",
                "w:tplc": "04090019",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "lowerLetter"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%8."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "5760",
                        "w:hanging": "360"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "8",
                "w:tplc": "0409001B",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "lowerRoman"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%9."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "right"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "6480",
                        "w:hanging": "180"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          type: "element",
          name: "w:num",
          attributes: {
            "w:numId": "1",
            "w16cid:durableId": "100147962"
          },
          elements: [
            {
              type: "element",
              name: "w:abstractNumId",
              attributes: {
                "w:val": "0"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:num",
          attributes: {
            "w:numId": "2",
            "w16cid:durableId": "485517411"
          },
          elements: [
            {
              type: "element",
              name: "w:abstractNumId",
              attributes: {
                "w:val": "1"
              }
            }
          ]
        }
      ]
    }
  ]
};
const TranslatorTypes = Object.freeze({
  NODE: "node",
  ATTRIBUTE: "attribute"
});
const _NodeTranslator = class _NodeTranslator {
  /**
   * @param {string} xmlName
   * @param {SuperDocNodeOrKeyName} sdNodeOrKeyName
   * @param {NodeTranslatorEncodeFn} encode
   * @param {NodeTranslatorDecodeFn} decode
   * @param {number} [priority]
   * @param {MatchesEncodeFn} [matchesEncode]
   * @param {MatchesDecodeFn} [matchesDecode]
   * @param {AttrConfig[]} [attributes]
   */
  constructor(xmlName, sdNodeOrKeyName, encode2, decode2, priority, matchesEncode, matchesDecode, attributes) {
    /** @type {string} */
    __publicField(this, "xmlName");
    /** @type {SuperDocNodeOrKeyName} */
    __publicField(this, "sdNodeOrKeyName");
    /** @type {number} */
    __publicField(this, "priority");
    /** @type {NodeTranslatorEncodeFn} */
    __publicField(this, "encodeFn");
    /** @type {NodeTranslatorDecodeFn} */
    __publicField(this, "decodeFn");
    /** @type {MatchesEncodeFn} */
    __publicField(this, "matchesEncode");
    /** @type {MatchesDecodeFn} */
    __publicField(this, "matchesDecode");
    /** @type {AttrConfig[]} */
    __publicField(this, "attributes");
    this.xmlName = xmlName;
    this.sdNodeOrKeyName = sdNodeOrKeyName;
    this.encodeFn = encode2;
    this.decodeFn = decode2;
    this.attributes = attributes || [];
    this.priority = typeof priority === "number" ? priority : 0;
    this.matchesEncode = typeof matchesEncode === "function" ? matchesEncode : () => true;
    this.matchesDecode = typeof matchesDecode === "function" ? matchesDecode : () => true;
  }
  /**
   * Encode the attributes for the node.
   * @param {SCEncoderConfig} params
   * @returns {Object} Encoded attributes object.
   */
  encodeAttributes(params) {
    const { nodes = [] } = params || {};
    const node = nodes[0];
    const { attributes = {} } = node || {};
    const encodedAttrs = {};
    this.attributes.forEach(({ sdName, encode: encode2 }) => {
      if (!encode2) return;
      const encodedAttr = encode2(attributes);
      if (encodedAttr !== void 0 && encodedAttr !== null) {
        encodedAttrs[sdName] = encodedAttr;
      }
    });
    return encodedAttrs;
  }
  /**
   * Decode the attributes for the node.
   * @param {SCDecoderConfig} params
   * @returns {Object} Decoded attributes object.
   */
  decodeAttributes(params) {
    const { node } = params || {};
    const { attrs = {} } = node || {};
    const decodedAttrs = {};
    this.attributes.forEach(({ xmlName, decode: decode2 }) => {
      if (!decode2) return;
      const decodedAttr = decode2(attrs);
      if (decodedAttr !== void 0 && decodedAttr !== null) {
        decodedAttrs[xmlName] = decodedAttr;
      }
    });
    return decodedAttrs;
  }
  /**
   * Decode the attributes for the node.
   * @param {SCDecoderConfig} params
   * @returns {Object} Decoded attributes object.
   */
  decode(params) {
    const decodedAttrs = this.decodeAttributes(params);
    return this.decodeFn ? this.decodeFn.call(this, params, decodedAttrs) : void 0;
  }
  /**
   * Encode the attributes for the node.
   * @param {SCEncoderConfig} params
   * @returns {Object} Encoded attributes object.
   */
  encode(params) {
    const encodedAttrs = this.encodeAttributes(params);
    return this.encodeFn ? this.encodeFn.call(this, params, encodedAttrs) : void 0;
  }
  /**
   * Create a new NodeTranslator instance from a configuration object.
   * @param {NodeTranslatorConfig} config - The configuration object.
   * @returns {NodeTranslator} The created NodeTranslator instance.
   */
  static from(config2) {
    const { xmlName, sdNodeOrKeyName, encode: encode2, decode: decode2, priority = 0, matchesEncode, matchesDecode, attributes } = config2;
    if (typeof encode2 !== "function" || !!decode2 && typeof decode2 !== "function") {
      throw new TypeError(`${xmlName}: encode/decode must be functions`);
    }
    const inst = new _NodeTranslator(
      xmlName,
      sdNodeOrKeyName,
      encode2,
      decode2,
      priority,
      matchesEncode,
      matchesDecode,
      attributes
    );
    return Object.freeze(inst);
  }
  /**
   * Convert the NodeTranslator instance to a string representation.
   * @returns {string} - The string representation of the NodeTranslator instance.
   */
  toString() {
    return `NodeTranslator(${this.xmlName}, priority=${this.priority})`;
  }
};
/** @type {typeof TranslatorTypes} */
__publicField(_NodeTranslator, "translatorTypes", TranslatorTypes);
let NodeTranslator = _NodeTranslator;
const encode$13 = (attributes) => {
  return attributes["w:type"];
};
const decode$15 = (attrs) => {
  const { lineBreakType } = attrs;
  return lineBreakType;
};
const attrConfig$B = Object.freeze({
  xmlName: "w:type",
  sdName: "lineBreakType",
  encode: encode$13,
  decode: decode$15
});
const encode$12 = (attributes) => {
  const xmlAttrValue = attributes["w:clear"];
  return xmlAttrValue;
};
const decode$14 = (attrs) => {
  const { clear } = attrs;
  return clear;
};
const attrConfig$A = Object.freeze({
  xmlName: "w:clear",
  sdName: "clear",
  encode: encode$12,
  decode: decode$14
});
const validXmlAttributes$j = [attrConfig$B, attrConfig$A];
const XML_NODE_NAME$v = "w:br";
const SD_NODE_NAME$p = "lineBreak";
const encode$11 = (_2, encodedAttrs) => {
  const isPageBreak = encodedAttrs?.lineBreakType === "page";
  const translated = {
    type: isPageBreak ? "hardBreak" : "lineBreak"
  };
  if (encodedAttrs) {
    translated.attrs = { ...encodedAttrs };
  }
  return translated;
};
const decode$13 = (params, decodedAttrs) => {
  const { node } = params;
  if (!node) return;
  const wBreak = { name: "w:br" };
  if (decodedAttrs) {
    wBreak.attributes = { ...decodedAttrs };
  }
  const isPageBreak = node.type === "hardBreak";
  if (isPageBreak && (!wBreak.attributes || !wBreak.attributes["w:type"])) {
    wBreak.attributes = { ...wBreak.attributes, "w:type": "page" };
  }
  const translated = {
    name: "w:r",
    elements: [wBreak]
  };
  return translated;
};
const config$u = {
  xmlName: XML_NODE_NAME$v,
  sdNodeOrKeyName: SD_NODE_NAME$p,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$11,
  decode: decode$13,
  attributes: validXmlAttributes$j
};
const translator$39 = NodeTranslator.from(config$u);
const encode$10 = (attributes) => attributes?.["w:val"];
const decode$12 = (attrs) => attrs?.highlight;
const attrConfig$z = Object.freeze({
  xmlName: "w:val",
  sdName: "highlight",
  encode: encode$10,
  decode: decode$12
});
const validXmlAttributes$i = [attrConfig$z];
const XML_NODE_NAME$u = "w:highlight";
const SD_ATTR_KEY$4 = "highlight";
const DISABLED_TOKENS = /* @__PURE__ */ new Set(["transparent", "none", "inherit"]);
const encode$$ = (params, encodedAttrs = {}) => {
  const { nodes } = params;
  const node = nodes?.[0];
  const value = encodedAttrs.highlight ?? node?.attributes?.["w:val"];
  return {
    type: "attr",
    xmlName: XML_NODE_NAME$u,
    sdNodeOrKeyName: SD_ATTR_KEY$4,
    attributes: { "w:val": value ?? null }
  };
};
const decode$11 = (params) => {
  const attrs = params?.node?.attrs || {};
  const highlightValue = attrs.highlight?.["w:val"] ?? attrs.highlight ?? attrs.color ?? null;
  if (!highlightValue) return void 0;
  const normalizedValue = String(highlightValue).trim().toLowerCase();
  if (!normalizedValue) return void 0;
  if (DISABLED_TOKENS.has(normalizedValue)) {
    return {
      name: XML_NODE_NAME$u,
      attributes: { "w:val": "none" }
    };
  }
  const keyword = getDocxHighlightKeywordFromHex(highlightValue);
  if (keyword) {
    return {
      name: XML_NODE_NAME$u,
      attributes: { "w:val": keyword }
    };
  }
  const fill = normalizeHexColor(highlightValue);
  if (!fill) return void 0;
  return {
    name: "w:shd",
    attributes: {
      "w:color": "auto",
      "w:val": "clear",
      "w:fill": fill
    }
  };
};
const config$t = {
  xmlName: XML_NODE_NAME$u,
  sdNodeOrKeyName: SD_ATTR_KEY$4,
  type: NodeTranslator.translatorTypes.ATTRIBUTE,
  encode: encode$$,
  decode: decode$11,
  attributes: validXmlAttributes$i
};
const translator$38 = NodeTranslator.from(config$t);
const encode$_ = (attributes) => {
  return attributes["w:val"];
};
const decode$10 = (attrs) => {
  const { tabType } = attrs || {};
  return tabType;
};
const attrConfig$y = Object.freeze({
  xmlName: "w:val",
  sdName: "tabType",
  encode: encode$_,
  decode: decode$10
});
const encode$Z = (attributes) => {
  return attributes["w:leader"];
};
const decode$$ = (attrs) => {
  const { leader } = attrs || {};
  return leader;
};
const attrConfig$x = Object.freeze({
  xmlName: "w:leader",
  sdName: "leader",
  encode: encode$Z,
  decode: decode$$
});
const encode$Y = (attributes) => {
  if (attributes["w:pos"] != null) return parseInt(attributes["w:pos"]);
  return null;
};
const decode$_ = (attrs) => {
  const { pos } = attrs || {};
  return pos?.toString();
};
const attrConfig$w = Object.freeze({
  xmlName: "w:pos",
  sdName: "pos",
  encode: encode$Y,
  decode: decode$_
});
const validXmlAttributes$h = [attrConfig$y, attrConfig$w, attrConfig$x];
const XML_NODE_NAME$t = "w:tab";
const SD_NODE_NAME$o = "tab";
const encode$X = (_2, encodedAttrs = {}) => {
  const translated = { type: "tab" };
  if (encodedAttrs) translated.attrs = { ...encodedAttrs };
  return translated;
};
function decode$Z(params, decodedAttrs = {}) {
  const { node } = params || {};
  if (!node) return;
  const wTab = { name: "w:tab", elements: [] };
  if (node.attrs?.["tab"]) {
    decodedAttrs = this.decodeAttributes({ ...params, node: { ...node, attrs: node.attrs["tab"] } }, decodedAttrs);
  }
  wTab.attributes = { ...decodedAttrs };
  if (params.extraParams?.skipRun) {
    return wTab;
  }
  const translated = {
    name: "w:r",
    elements: [wTab]
  };
  const { marks: nodeMarks = [] } = node;
  const outputMarks = processOutputMarks(nodeMarks);
  if (outputMarks.length) {
    translated.elements.unshift(generateRunProps(outputMarks));
  }
  return translated;
}
const config$s = {
  xmlName: XML_NODE_NAME$t,
  sdNodeOrKeyName: SD_NODE_NAME$o,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$X,
  decode: decode$Z,
  attributes: validXmlAttributes$h
};
const translator$37 = NodeTranslator.from(config$s);
const carbonCopy = (obj) => {
  if (!obj) return void 0;
  try {
    return JSON.parse(JSON.stringify(obj));
  } catch (e) {
    console.error("Error in carbonCopy", obj, e);
    return void 0;
  }
};
const mergeTextNodes = (nodes) => {
  if (!nodes || !Array.isArray(nodes)) {
    return nodes;
  }
  let mergedNodes = [];
  let prevTextNode = null;
  for (let node of nodes) {
    if (node.type === "text") {
      if (prevTextNode && canMergeTextNodes(prevTextNode, node)) {
        prevTextNode = {
          ...prevTextNode,
          text: prevTextNode.text += node.text
        };
      } else {
        if (prevTextNode) mergedNodes.push(prevTextNode);
        prevTextNode = { ...node };
      }
    } else {
      if (prevTextNode) {
        mergedNodes.push(prevTextNode);
        prevTextNode = null;
      }
      mergedNodes.push(node);
    }
  }
  if (prevTextNode) {
    mergedNodes.push(prevTextNode);
  }
  return mergedNodes;
};
const canMergeTextNodes = (nodeA, nodeB) => {
  if (!nodeA || !nodeB) return false;
  let marksA = nodeA.marks ?? [];
  let marksB = nodeB.marks ?? [];
  if (marksA.length !== marksB.length) {
    return false;
  }
  for (let i = 0; i < marksA.length; i++) {
    if (!marksA[i].attrs) marksA[i].attrs = {};
    if (!marksB[i].attrs) marksB[i].attrs = {};
    if (marksA[i].type !== marksB[i].type || Object.keys(marksA[i].attrs).length !== Object.keys(marksB[i].attrs).length || !areAttrsEqual(marksA[i].attrs, marksB[i].attrs)) {
      return false;
    }
  }
  return true;
};
const areAttrsEqual = (attrsA = {}, attrsB = {}) => {
  return objectIncludes(attrsA, attrsB);
};
const TrackInsertMarkName = "trackInsert";
const TrackDeleteMarkName = "trackDelete";
const TrackFormatMarkName = "trackFormat";
const generateV2HandlerEntity = (handlerName, translator2) => ({
  handlerName,
  handler: (params) => {
    const { nodes } = params;
    if (!translator2 || !translator2.xmlName) {
      return { nodes: [], consumed: 0 };
    }
    if (nodes.length === 0 || nodes[0].name !== translator2.xmlName) {
      return { nodes: [], consumed: 0 };
    }
    const result = translator2.encode(params);
    if (!result) return { nodes: [], consumed: 0 };
    return {
      nodes: Array.isArray(result) ? result : [result],
      consumed: 1
    };
  }
});
function createSingleAttrPropertyHandler(xmlName, sdName = null, attrName = "w:val", transformEncode = null, transformDecode = null) {
  if (!sdName) sdName = xmlName.split(":")[1];
  if (!transformEncode) transformEncode = (v2) => v2;
  if (!transformDecode) transformDecode = (v2) => v2;
  return {
    xmlName,
    sdNodeOrKeyName: sdName,
    encode: ({ nodes }) => {
      return transformEncode(nodes[0]?.attributes?.[attrName]) ?? void 0;
    },
    decode: ({ node }) => {
      const value = node.attrs?.[sdName] != null ? transformDecode(node.attrs[sdName]) : void 0;
      return value != null ? { name: xmlName, attributes: { [attrName]: value } } : void 0;
    }
  };
}
function createSingleBooleanPropertyHandler(xmlName, sdName = null) {
  if (!sdName) sdName = xmlName.split(":")[1];
  return {
    xmlName,
    sdNodeOrKeyName: sdName,
    encode: ({ nodes }) => parseBoolean(nodes[0].attributes?.["w:val"] ?? "1"),
    decode: ({ node }) => {
      if (node.attrs[sdName] == null) return void 0;
      return node.attrs[sdName] ? { attributes: {} } : { attributes: { "w:val": "0" } };
    }
  };
}
const createSingleIntegerPropertyHandler = (xmlName, sdName = null) => createSingleAttrPropertyHandler(xmlName, sdName, "w:val", parseInteger, integerToString);
function createMeasurementPropertyHandler(xmlName, sdName = null) {
  if (!sdName) sdName = xmlName.split(":")[1];
  return {
    xmlName,
    sdNodeOrKeyName: sdName,
    attributes: [
      createAttributeHandler("w:w", "value", parseInteger, integerToString),
      createAttributeHandler("w:type")
    ],
    encode: (_2, encodedAttrs) => {
      return encodedAttrs["value"] != null ? encodedAttrs : void 0;
    },
    decode: function({ node }) {
      const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs[sdName] || {} } });
      return decodedAttrs["w:w"] != null ? { attributes: decodedAttrs } : void 0;
    }
  };
}
function createBorderPropertyHandler(xmlName, sdName = null) {
  if (!sdName) sdName = xmlName.split(":")[1];
  return {
    xmlName,
    sdNodeOrKeyName: sdName,
    attributes: [
      createAttributeHandler(
        "w:val",
        "val",
        (v2) => v2 === "nil" ? "none" : v2,
        (v2) => v2 === "none" ? "nil" : v2
      ),
      createAttributeHandler(
        "w:color",
        "color",
        (v2) => {
          if (v2 === "auto") {
            return "auto";
          } else if (v2) {
            return `#${v2}`;
          } else {
            return void 0;
          }
        },
        (v2) => {
          if (v2) {
            return v2.replace("#", "");
          } else {
            return void 0;
          }
        }
      ),
      createAttributeHandler("w:themeColor"),
      createAttributeHandler("w:themeTint"),
      createAttributeHandler("w:themeShade"),
      createAttributeHandler("w:sz", "size", parseInteger, integerToString),
      createAttributeHandler("w:space", null, parseInteger, integerToString),
      createAttributeHandler("w:shadow", null, parseBoolean, booleanToString),
      createAttributeHandler("w:frame", null, parseBoolean, booleanToString)
    ],
    encode: (params, encodedAttrs) => {
      return Object.keys(encodedAttrs).length > 0 ? encodedAttrs : void 0;
    },
    decode: function({ node }, context) {
      const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs[sdName] || {} } });
      return Object.keys(decodedAttrs).length > 0 ? { attributes: decodedAttrs } : void 0;
    }
  };
}
const createAttributeHandler = (xmlName, sdName = null, transformEncode = null, transformDecode = null) => {
  if (!transformEncode) transformEncode = (v2) => v2;
  if (!transformDecode) transformDecode = (v2) => v2;
  if (!sdName) sdName = xmlName.split(":")[1];
  return {
    xmlName,
    sdName,
    encode: (attributes) => transformEncode(attributes[xmlName]),
    decode: (attributes) => transformDecode(attributes[sdName])
  };
};
const createIntegerAttributeHandler = (xmlName, sdName = null) => createAttributeHandler(xmlName, sdName, parseInteger, integerToString);
const createBooleanAttributeHandler = (xmlName, sdName = null) => createAttributeHandler(xmlName, sdName, parseBoolean, booleanToString);
function encodeProperties(params, translatorsByXmlName, asArray = false) {
  const node = params.nodes[0];
  if (!node?.elements || node.elements.length === 0) {
    return asArray ? [] : {};
  }
  const attributes = asArray ? [] : {};
  node.elements.forEach((el) => {
    const translator2 = translatorsByXmlName[el.name];
    if (translator2) {
      let encodedAttr = translator2.encode({ ...params, nodes: [el] });
      if (encodedAttr != null) {
        if (typeof encodedAttr === "object") {
          if ("attrs" in encodedAttr) {
            encodedAttr = encodedAttr.attrs;
          } else if ("attributes" in encodedAttr) {
            encodedAttr = encodedAttr.attributes;
          }
        }
        if (asArray) {
          attributes.push({ [translator2.sdNodeOrKeyName]: encodedAttr });
        } else {
          attributes[translator2.sdNodeOrKeyName] = encodedAttr;
        }
      }
    }
  });
  return attributes;
}
function decodeProperties(params, translatorsBySdName, properties) {
  if (!properties || typeof properties !== "object") {
    return [];
  }
  const elements = [];
  Object.keys(properties).forEach((key) => {
    const translator2 = translatorsBySdName[key];
    if (translator2) {
      const result = translator2.decode({ ...params, node: { attrs: { [key]: properties[key] } } });
      if (result != null) {
        result.name = translator2.xmlName;
        elements.push(result);
      }
    }
  });
  return elements;
}
function encodePropertiesByKey(xmlName, sdName, translator2, params, node, keyAttr) {
  const result = {};
  const elements = node.elements?.filter((el) => el.name === xmlName) || [];
  if (elements.length > 0) {
    const items = elements.map((el) => translator2.encode({ ...params, nodes: [el] })).filter(Boolean);
    if (items.length > 0) {
      result[sdName] = items.reduce((acc, item) => {
        if (item[keyAttr] != null) {
          acc[item[keyAttr]] = item;
        }
        return acc;
      }, {});
    }
  }
  return result;
}
function decodePropertiesByKey(xmlName, sdName, translator2, params, attrs) {
  const elements = [];
  if (attrs[sdName] != null) {
    Object.values(attrs[sdName]).forEach((item) => {
      const decoded = translator2.decode({
        ...params,
        node: { attrs: { [translator2.sdNodeOrKeyName]: item } }
      });
      if (decoded) {
        elements.push(decoded);
      }
    });
  }
  return elements;
}
function createNestedPropertiesTranslator(xmlName, sdName, propertyTranslators2, defaultEncodedAttrs = {}, attributeHandlers2 = []) {
  const propertyTranslatorsByXmlName2 = {};
  const propertyTranslatorsBySdName2 = {};
  propertyTranslators2.forEach((translator2) => {
    if (!translator2) return;
    propertyTranslatorsByXmlName2[translator2.xmlName] = translator2;
    propertyTranslatorsBySdName2[translator2.sdNodeOrKeyName] = translator2;
  });
  return {
    xmlName,
    sdNodeOrKeyName: sdName,
    type: NodeTranslator.translatorTypes.NODE,
    attributes: attributeHandlers2,
    encode: (params, encodedAttrs) => {
      const { nodes } = params;
      const node = nodes[0];
      const attributes = {
        ...defaultEncodedAttrs,
        ...encodedAttrs,
        ...encodeProperties({ ...params, nodes: [node] }, propertyTranslatorsByXmlName2)
      };
      return Object.keys(attributes).length > 0 ? attributes : void 0;
    },
    decode: function(params) {
      const decodedAttrs = this.decodeAttributes({ node: { ...params.node, attrs: params.node.attrs[sdName] || {} } });
      const currentValue = params.node.attrs?.[sdName];
      const elements = decodeProperties(params, propertyTranslatorsBySdName2, currentValue);
      if (elements.length === 0) {
        return void 0;
      }
      const newNode = {
        name: xmlName,
        type: "element",
        attributes: decodedAttrs,
        elements
      };
      return newNode;
    }
  };
}
function createNestedArrayPropertyHandler(xmlName, sdName = null, propertyTranslators2, extraParamsForDecode = {}) {
  if (!sdName) sdName = xmlName.split(":")[1];
  const propertyTranslatorsByXmlName2 = {};
  const propertyTranslatorsBySdName2 = {};
  propertyTranslators2.forEach((translator2) => {
    propertyTranslatorsByXmlName2[translator2.xmlName] = translator2;
    propertyTranslatorsBySdName2[translator2.sdNodeOrKeyName] = translator2;
  });
  return {
    xmlName,
    sdNodeOrKeyName: sdName,
    attributes: [],
    encode: (params) => {
      const { nodes } = params;
      const node = nodes[0];
      const content = encodeProperties({ ...params, nodes: [node] }, propertyTranslatorsByXmlName2, true);
      return content;
    },
    decode: (params) => {
      const arrayContainer = params.node.attrs?.[sdName] || [];
      if (!Array.isArray(arrayContainer) || arrayContainer.length === 0) {
        return void 0;
      }
      const elements = [];
      arrayContainer.forEach((item) => {
        const sdKey = Object.keys(item)[0];
        const childTranslator = propertyTranslatorsBySdName2[sdKey];
        if (childTranslator) {
          const result = childTranslator.decode({
            ...params,
            node: { type: sdKey, attrs: { [sdKey]: item[sdKey] } },
            extraParams: { ...params.extraParams, ...extraParamsForDecode }
          });
          if (result != null) {
            elements.push(result);
          }
        }
      });
      const newNode = {
        name: xmlName,
        attributes: {},
        elements: elements.flat()
      };
      return newNode;
    }
  };
}
const parseBoolean = (value) => value != null ? ["1", "true", "on", 1, true].includes(value) : void 0;
const booleanToString = (value) => value != null ? value ? "1" : "0" : void 0;
const parseInteger = (value) => {
  if (value == null) return void 0;
  const intValue = parseInt(value, 10);
  return isNaN(intValue) ? void 0 : intValue;
};
const integerToString = (value) => {
  const intValue = parseInteger(value);
  return intValue != void 0 ? String(intValue) : void 0;
};
const translator$36 = NodeTranslator.from(createSingleBooleanPropertyHandler("w:b", "bold"));
const translator$35 = NodeTranslator.from(createSingleBooleanPropertyHandler("w:bCs", "boldCs"));
const translator$34 = NodeTranslator.from(createBorderPropertyHandler("w:bdr", "borders"));
const translator$33 = NodeTranslator.from(createSingleBooleanPropertyHandler("w:i", "italic"));
const encode$W = (attributes) => attributes?.["w:val"];
const decode$Y = (attrs) => attrs?.underline;
const attrConfig$v = Object.freeze({
  xmlName: "w:val",
  sdName: "underline",
  encode: encode$W,
  decode: decode$Y
});
const encode$V = (attributes) => attributes?.["w:color"];
const decode$X = (attrs) => attrs?.color;
const attrConfig$u = Object.freeze({
  xmlName: "w:color",
  sdName: "color",
  encode: encode$V,
  decode: decode$X
});
const encode$U = (attributes) => attributes?.["w:themeColor"];
const decode$W = (attrs) => attrs?.themeColor;
const attrConfig$t = Object.freeze({
  xmlName: "w:themeColor",
  sdName: "themeColor",
  encode: encode$U,
  decode: decode$W
});
const encode$T = (attributes) => attributes?.["w:themeTint"];
const decode$V = (attrs) => attrs?.themeTint;
const attrConfig$s = Object.freeze({
  xmlName: "w:themeTint",
  sdName: "themeTint",
  encode: encode$T,
  decode: decode$V
});
const encode$S = (attributes) => attributes?.["w:themeShade"];
const decode$U = (attrs) => attrs?.themeShade;
const attrConfig$r = Object.freeze({
  xmlName: "w:themeShade",
  sdName: "themeShade",
  encode: encode$S,
  decode: decode$U
});
const validXmlAttributes$g = [attrConfig$v, attrConfig$u, attrConfig$t, attrConfig$s, attrConfig$r];
const XML_NODE_NAME$s = "w:u";
const SD_ATTR_KEY$3 = "underline";
const encode$R = (params, encodedAttrs = {}) => {
  const { nodes } = params;
  const node = nodes?.[0];
  const sourceAttrs = node?.attributes || {};
  const underlineType = encodedAttrs.underline ?? sourceAttrs["w:val"];
  const color = encodedAttrs.color ?? sourceAttrs["w:color"];
  const themeColor = encodedAttrs.themeColor ?? sourceAttrs["w:themeColor"];
  const themeTint = encodedAttrs.themeTint ?? sourceAttrs["w:themeTint"];
  const themeShade = encodedAttrs.themeShade ?? sourceAttrs["w:themeShade"];
  const attributes = { "w:val": underlineType ?? null };
  if (color !== void 0 && color !== null) attributes["w:color"] = color;
  if (themeColor !== void 0 && themeColor !== null) attributes["w:themeColor"] = themeColor;
  if (themeTint !== void 0 && themeTint !== null) attributes["w:themeTint"] = themeTint;
  if (themeShade !== void 0 && themeShade !== null) attributes["w:themeShade"] = themeShade;
  return {
    type: "attr",
    xmlName: XML_NODE_NAME$s,
    sdNodeOrKeyName: SD_ATTR_KEY$3,
    attributes
  };
};
const decode$T = (params) => {
  const attrs = params?.node?.attrs?.underline || params?.node?.attrs || {};
  const underlineType = attrs.underlineType ?? attrs.underline ?? attrs["w:val"] ?? null;
  const color = attrs.underlineColor ?? attrs.color ?? attrs["w:color"] ?? null;
  const themeColor = attrs.underlineThemeColor ?? attrs.themeColor ?? attrs["w:themeColor"] ?? null;
  const themeTint = attrs.underlineThemeTint ?? attrs.themeTint ?? attrs["w:themeTint"] ?? null;
  const themeShade = attrs.underlineThemeShade ?? attrs.themeShade ?? attrs["w:themeShade"] ?? null;
  if (!underlineType && !color && !themeColor && !themeTint && !themeShade) return void 0;
  const attributes = {};
  if (underlineType) attributes["w:val"] = underlineType;
  if (color) {
    const normalized = normalizeHexColor(color);
    if (normalized) attributes["w:color"] = normalized;
  }
  if (themeColor) attributes["w:themeColor"] = themeColor;
  if (themeTint) attributes["w:themeTint"] = themeTint;
  if (themeShade) attributes["w:themeShade"] = themeShade;
  return {
    name: XML_NODE_NAME$s,
    attributes
  };
};
const config$r = {
  xmlName: XML_NODE_NAME$s,
  sdNodeOrKeyName: SD_ATTR_KEY$3,
  type: NodeTranslator.translatorTypes.ATTRIBUTE,
  encode: encode$R,
  decode: decode$T,
  attributes: validXmlAttributes$g
};
const translator$32 = NodeTranslator.from(config$r);
const translator$31 = NodeTranslator.from(createSingleBooleanPropertyHandler("w:strike"));
const translator$30 = NodeTranslator.from(createSingleBooleanPropertyHandler("w:dstrike"));
const translator$2$ = NodeTranslator.from({
  xmlName: "w:color",
  sdNodeOrKeyName: "color",
  attributes: [
    createAttributeHandler("w:val"),
    createAttributeHandler("w:themeColor"),
    createAttributeHandler("w:themeTint"),
    createAttributeHandler("w:themeShade")
  ],
  encode: (_2, encodedAttrs) => {
    return encodedAttrs;
  },
  decode: function({ node }) {
    const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs["color"] || {} } });
    return Object.keys(decodedAttrs).length > 0 ? { attributes: decodedAttrs } : void 0;
  }
});
const translator$2_ = NodeTranslator.from({
  xmlName: "w:rFonts",
  sdNodeOrKeyName: "fontFamily",
  attributes: [
    createAttributeHandler("w:hint"),
    createAttributeHandler("w:ascii"),
    createAttributeHandler("w:hAnsi"),
    createAttributeHandler("w:eastAsia"),
    createAttributeHandler("w:cs"),
    createAttributeHandler("w:val"),
    createAttributeHandler("w:asciiTheme"),
    createAttributeHandler("w:hAnsiTheme"),
    createAttributeHandler("w:eastAsiaTheme"),
    createAttributeHandler("w:cstheme")
  ],
  encode: (params, encodedAttrs) => {
    if (params.inlineDocumentFonts) {
      const font = encodedAttrs["ascii"];
      if (font) {
        if (!params.inlineDocumentFonts.includes(font)) {
          params.inlineDocumentFonts.push(font);
        }
      }
    }
    return encodedAttrs;
  },
  decode: function({ node }) {
    const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs["fontFamily"] || {} } });
    return Object.keys(decodedAttrs).length > 0 ? { attributes: decodedAttrs } : void 0;
  }
});
const translator$2Z = NodeTranslator.from(createSingleAttrPropertyHandler("w:rStyle", "styleId"));
const translator$2Y = NodeTranslator.from(createSingleIntegerPropertyHandler("w:sz", "fontSize"));
const translator$2X = NodeTranslator.from(createSingleIntegerPropertyHandler("w:szCs", "fontSizeCs"));
const translator$2W = NodeTranslator.from({
  xmlName: "w:caps",
  sdNodeOrKeyName: "textTransform",
  encode: ({ nodes }) => parseBoolean(nodes[0].attributes?.["w:val"] ?? "1") ? "uppercase" : "none",
  decode: ({ node }) => node.attrs["textTransform"] != null ? { name: "w:caps", attributes: { "w:val": booleanToString(node.attrs["textTransform"] === "uppercase") } } : void 0
});
const translator$2V = NodeTranslator.from({
  xmlName: "w:shd",
  sdNodeOrKeyName: "shading",
  attributes: [
    "w:color",
    "w:fill",
    "w:themeColor",
    "w:themeFill",
    "w:themeFillShade",
    "w:themeFillTint",
    "w:themeShade",
    "w:themeTint",
    "w:val"
  ].map((attr) => createAttributeHandler(attr)),
  encode: (params, encodedAttrs) => {
    return Object.keys(encodedAttrs).length > 0 ? encodedAttrs : void 0;
  },
  decode: function({ node }, context) {
    const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs.shading || {} } });
    return Object.keys(decodedAttrs).length > 0 ? { attributes: decodedAttrs } : void 0;
  }
});
const translator$2U = NodeTranslator.from({
  xmlName: "w:lang",
  sdNodeOrKeyName: "lang",
  attributes: [createAttributeHandler("w:val"), createAttributeHandler("w:eastAsia"), createAttributeHandler("w:bidi")],
  encode: (_2, encodedAttrs) => {
    return encodedAttrs;
  },
  decode: function({ node }) {
    const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs["lang"] || {} } });
    return Object.keys(decodedAttrs).length > 0 ? { attributes: decodedAttrs } : void 0;
  }
});
const translator$2T = NodeTranslator.from(createSingleIntegerPropertyHandler("w:spacing", "letterSpacing"));
const translator$2S = NodeTranslator.from(createSingleAttrPropertyHandler("w:vertAlign"));
const translator$2R = NodeTranslator.from(createSingleBooleanPropertyHandler("w:smallCaps"));
const translator$2Q = NodeTranslator.from(createSingleBooleanPropertyHandler("w:snapToGrid"));
const translator$2P = NodeTranslator.from(createSingleBooleanPropertyHandler("w:emboss"));
const translator$2O = NodeTranslator.from(createSingleBooleanPropertyHandler("w:imprint"));
const translator$2N = NodeTranslator.from(createSingleBooleanPropertyHandler("w:noProof"));
const translator$2M = NodeTranslator.from(createSingleBooleanPropertyHandler("w:oMath"));
const translator$2L = NodeTranslator.from(createSingleBooleanPropertyHandler("w:outline"));
const translator$2K = NodeTranslator.from(createSingleBooleanPropertyHandler("w:shadow"));
const translator$2J = NodeTranslator.from(createSingleBooleanPropertyHandler("w:vanish"));
const translator$2I = NodeTranslator.from(createSingleBooleanPropertyHandler("w:specVanish"));
const translator$2H = NodeTranslator.from(createSingleAttrPropertyHandler("w:effect"));
const translator$2G = NodeTranslator.from(createSingleAttrPropertyHandler("w:em"));
const translator$2F = NodeTranslator.from(createSingleAttrPropertyHandler("w:w"));
const translator$2E = NodeTranslator.from(createSingleIntegerPropertyHandler("w:kern"));
const translator$2D = NodeTranslator.from(createSingleIntegerPropertyHandler("w:position"));
const translator$2C = NodeTranslator.from({
  xmlName: "w:fitText",
  sdNodeOrKeyName: "fitText",
  attributes: [createIntegerAttributeHandler("w:val"), createIntegerAttributeHandler("w:id")],
  encode: (_2, encodedAttrs) => {
    return encodedAttrs;
  },
  decode: function({ node }) {
    const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs["fitText"] || {} } });
    return Object.keys(decodedAttrs).length > 0 ? { attributes: decodedAttrs } : void 0;
  }
});
const translator$2B = NodeTranslator.from({
  xmlName: "w:eastAsianLayout",
  sdNodeOrKeyName: "eastAsianLayout",
  attributes: [
    createIntegerAttributeHandler("w:id"),
    createBooleanAttributeHandler("w:combine"),
    createAttributeHandler("w:combineBrackets"),
    createBooleanAttributeHandler("w:vert"),
    createBooleanAttributeHandler("w:vertCompress")
  ],
  encode: (_2, encodedAttrs) => {
    return encodedAttrs;
  },
  decode: function({ node }) {
    const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs["eastAsianLayout"] || {} } });
    return Object.keys(decodedAttrs).length > 0 ? { attributes: decodedAttrs } : void 0;
  }
});
const translator$2A = NodeTranslator.from(createSingleBooleanPropertyHandler("w:rtl"));
const translator$2z = NodeTranslator.from(createSingleBooleanPropertyHandler("w:cs"));
const translator$2y = NodeTranslator.from(createSingleBooleanPropertyHandler("w:iCs"));
const translator$2x = NodeTranslator.from(createSingleBooleanPropertyHandler("w:webHidden"));
const propertyTranslators$h = [
  translator$35,
  translator$36,
  translator$34,
  translator$2W,
  translator$2$,
  translator$2z,
  translator$30,
  translator$2B,
  translator$2H,
  translator$2G,
  translator$2P,
  translator$2C,
  translator$2_,
  translator$2X,
  translator$2Y,
  translator$38,
  translator$2O,
  translator$33,
  translator$2y,
  translator$2E,
  translator$2U,
  translator$2T,
  translator$2N,
  translator$2M,
  translator$2L,
  translator$2D,
  translator$2A,
  translator$2Z,
  translator$2K,
  translator$2V,
  translator$2R,
  translator$2Q,
  translator$2I,
  translator$31,
  translator$32,
  translator$2J,
  translator$2S,
  translator$2x,
  translator$2F
];
const translator$2w = NodeTranslator.from(
  createNestedPropertiesTranslator("w:rPr", "runProperties", propertyTranslators$h)
);
function getUnderlineCssString({ type: type2 = "single", color = null, thickness = null, approximate = true } = {}) {
  const parts = [];
  const add = (k2, v2) => {
    if (!v2) return;
    parts.push(`${k2}: ${v2}`);
  };
  const lower = String(type2 || "single").toLowerCase();
  if (lower === "none" || lower === "0") {
    add("text-decoration", "none");
    return parts.join("; ");
  }
  add("text-decoration-line", "underline");
  const HEAVY = thickness || "0.2em";
  const THICK = thickness || "0.15em";
  switch (lower) {
    case "single":
      break;
    case "double":
      add("text-decoration-style", "double");
      break;
    case "thick":
      add("text-decoration-thickness", THICK);
      break;
    case "dotted":
      add("text-decoration-style", "dotted");
      break;
    case "dash":
    case "dashed":
      add("text-decoration-style", "dashed");
      break;
    case "dotdash":
    case "dotdotdash":
    case "dashlong":
    case "dashlongheavy":
      if (approximate) {
        add("text-decoration-style", "dashed");
        if (lower.includes("heavy")) add("text-decoration-thickness", HEAVY);
      }
      break;
    case "dottedheavy":
      add("text-decoration-style", "dotted");
      add("text-decoration-thickness", HEAVY);
      break;
    case "dashedheavy":
      add("text-decoration-style", "dashed");
      add("text-decoration-thickness", HEAVY);
      break;
    case "wavy":
      add("text-decoration-style", "wavy");
      break;
    case "wavyheavy":
      add("text-decoration-style", "wavy");
      add("text-decoration-thickness", HEAVY);
      break;
    case "wavydouble":
      if (approximate) {
        add("text-decoration-style", "wavy");
        add("text-decoration-thickness", HEAVY);
      }
      break;
  }
  if (color) add("text-decoration-color", color);
  return parts.join("; ");
}
function combineProperties(propertiesArray, options = {}) {
  const { fullOverrideProps = [], specialHandling = {} } = options;
  if (!propertiesArray || propertiesArray.length === 0) {
    return {};
  }
  const merge = (target, source) => {
    const output = { ...target };
    if (isObject(target) && isObject(source)) {
      for (const key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          const handler2 = specialHandling[key];
          if (handler2 && typeof handler2 === "function") {
            output[key] = handler2(output, source);
          } else if (!fullOverrideProps.includes(key) && isObject(source[key])) {
            if (key in target && isObject(target[key])) {
              output[key] = merge(target[key], source[key]);
            } else {
              output[key] = source[key];
            }
          } else {
            output[key] = source[key];
          }
        }
      }
    }
    return output;
  };
  return propertiesArray.reduce((acc, current) => merge(acc, current ?? {}), {});
}
function isObject(item) {
  return item != null && typeof item === "object" && !Array.isArray(item);
}
function combineRunProperties(propertiesArray) {
  return combineProperties(propertiesArray, {
    fullOverrideProps: ["color"],
    specialHandling: {
      fontFamily: (target, source) => {
        const fontFamilySource = { ...source.fontFamily };
        const fontFamilyTarget = { ...target.fontFamily };
        if (fontFamilySource.asciiTheme != null) {
          delete fontFamilyTarget.ascii;
          delete fontFamilyTarget.asciiTheme;
        }
        if (fontFamilySource.ascii != null) {
          delete fontFamilyTarget.asciiTheme;
        }
        return { ...fontFamilyTarget, ...fontFamilySource };
      }
    }
  });
}
function combineIndentProperties(indentChain) {
  const indentOnly = indentChain.map((props) => props.indent != null ? { indent: props.indent } : {});
  return combineProperties(indentOnly, {
    specialHandling: {
      firstLine: (target, source) => {
        if (target.hanging != null && source.firstLine != null) {
          delete target.hanging;
        }
        return source.firstLine;
      },
      hanging: (target, source) => {
        if (target.firstLine != null && source.hanging != null) {
          delete target.firstLine;
        }
        return source.hanging;
      }
    }
  });
}
function resolveRunProperties(params, inlineRpr, resolvedPpr, tableInfo = null, isListNumber = false, numberingDefinedInline = false) {
  if (!params.translatedLinkedStyles?.styles) {
    return inlineRpr ?? {};
  }
  if (!inlineRpr) {
    inlineRpr = {};
  }
  const paragraphStyleId = resolvedPpr?.styleId;
  const paragraphStyleProps = resolveStyleChain("runProperties", params, paragraphStyleId);
  const defaultProps = params.translatedLinkedStyles.docDefaults?.runProperties ?? {};
  const normalStyleDef = params.translatedLinkedStyles.styles["Normal"];
  const normalProps = normalStyleDef?.runProperties ?? {};
  const tableStyleProps = tableInfo?.tableProperties?.tableStyleId ? resolveStyleChain("runProperties", params, tableInfo?.tableProperties?.tableStyleId) : {};
  const cellStyleProps = resolveCellStyles(
    "runProperties",
    tableInfo,
    params.translatedLinkedStyles
  );
  let runStyleProps = {};
  if (!paragraphStyleId?.startsWith("TOC")) {
    runStyleProps = inlineRpr?.styleId ? resolveStyleChain("runProperties", params, inlineRpr.styleId) : {};
  }
  let defaultsChain;
  if (!paragraphStyleId) {
    defaultsChain = [defaultProps, normalProps];
  } else {
    defaultsChain = [defaultProps];
  }
  let styleChain;
  if (isListNumber) {
    const numberingProperties = resolvedPpr?.numberingProperties;
    const numId = resolvedPpr?.numberingProperties?.numId;
    let numberingProps = {};
    if (numId != null && numId !== 0) {
      numberingProps = getNumberingProperties("runProperties", params, numberingProperties?.ilvl ?? 0, numId);
    }
    if (!numberingDefinedInline) {
      inlineRpr = {};
    }
    if (inlineRpr?.underline) {
      delete inlineRpr.underline;
    }
    styleChain = [
      ...defaultsChain,
      tableStyleProps,
      ...cellStyleProps,
      paragraphStyleProps,
      runStyleProps,
      inlineRpr,
      numberingProps
    ];
  } else {
    styleChain = [...defaultsChain, tableStyleProps, ...cellStyleProps, paragraphStyleProps, runStyleProps, inlineRpr];
  }
  const finalProps = combineRunProperties(styleChain);
  return finalProps;
}
function resolveParagraphProperties(params, inlineProps, tableInfo) {
  if (!inlineProps) {
    inlineProps = {};
  }
  if (!params.translatedLinkedStyles?.styles) {
    return inlineProps;
  }
  const defaultProps = params.translatedLinkedStyles.docDefaults?.paragraphProperties ?? {};
  const normalStyleDef = params.translatedLinkedStyles.styles["Normal"];
  const normalProps = normalStyleDef?.paragraphProperties ?? {};
  let styleId = inlineProps.styleId;
  let styleProps = inlineProps.styleId ? resolveStyleChain("paragraphProperties", params, inlineProps.styleId) : {};
  let numberingProps = {};
  const ilvl = inlineProps?.numberingProperties?.ilvl ?? styleProps?.numberingProperties?.ilvl;
  const numId = inlineProps?.numberingProperties?.numId ?? styleProps?.numberingProperties?.numId;
  let numberingDefinedInline = inlineProps?.numberingProperties?.numId != null;
  const isList2 = numId != null && numId !== 0;
  if (isList2) {
    const ilvlNum = ilvl != null ? ilvl : 0;
    numberingProps = getNumberingProperties("paragraphProperties", params, ilvlNum, numId);
    if (numberingProps.styleId) {
      styleId = numberingProps.styleId;
      styleProps = resolveStyleChain("paragraphProperties", params, styleId);
      inlineProps.styleId = styleId;
      const inlineNumProps = inlineProps.numberingProperties;
      if (styleProps.numberingProperties?.ilvl === inlineNumProps?.ilvl && styleProps.numberingProperties?.numId === inlineNumProps?.numId) {
        delete inlineProps.numberingProperties;
        numberingDefinedInline = false;
      }
    }
  }
  const tableProps = tableInfo?.tableProperties?.tableStyleId ? resolveStyleChain("paragraphProperties", params, tableInfo?.tableProperties?.tableStyleId) : {};
  const cellStyleProps = resolveCellStyles(
    "paragraphProperties",
    tableInfo,
    params.translatedLinkedStyles
  );
  let defaultsChain;
  if (!styleId) {
    defaultsChain = [defaultProps, normalProps];
  } else {
    defaultsChain = [defaultProps];
  }
  const propsChain = [...defaultsChain, tableProps, ...cellStyleProps, numberingProps, styleProps, inlineProps];
  let indentChain;
  if (isList2) {
    if (numberingDefinedInline) {
      indentChain = [...defaultsChain, styleProps, numberingProps, inlineProps];
    } else {
      styleProps = resolveStyleChain("paragraphProperties", params, styleId, false);
      indentChain = [...defaultsChain, numberingProps, styleProps, inlineProps];
    }
  } else {
    indentChain = [...defaultsChain, styleProps, inlineProps];
  }
  const finalProps = combineProperties(propsChain, {
    specialHandling: {
      tabStops: (target, source) => {
        if (target.tabStops != null && source.tabStops != null) {
          return [...target.tabStops, ...source.tabStops];
        }
        return source.tabStops;
      }
    }
  });
  const finalIndent = combineIndentProperties(indentChain);
  finalProps.indent = finalIndent.indent;
  return finalProps;
}
function resolveStyleChain(propertyType, params, styleId, followBasedOnChain = true) {
  if (!styleId) return {};
  const styleDef = params.translatedLinkedStyles?.styles?.[styleId];
  if (!styleDef) return {};
  const styleProps = styleDef[propertyType] ?? {};
  const basedOn = styleDef.basedOn;
  let styleChain = [styleProps];
  const seenStyles = /* @__PURE__ */ new Set();
  let nextBasedOn = basedOn;
  while (followBasedOnChain && nextBasedOn) {
    if (seenStyles.has(nextBasedOn)) {
      break;
    }
    seenStyles.add(basedOn);
    const basedOnStyleDef = params.translatedLinkedStyles?.styles?.[nextBasedOn];
    const basedOnProps = basedOnStyleDef?.[propertyType];
    if (basedOnProps && Object.keys(basedOnProps).length) {
      styleChain.push(basedOnProps);
    }
    nextBasedOn = basedOnStyleDef?.basedOn;
  }
  styleChain = styleChain.reverse();
  return combineProperties(styleChain);
}
function getNumberingProperties(propertyType, params, ilvl, numId, tries = 0) {
  const numbering = params.translatedNumbering;
  if (!numbering) return {};
  const { definitions, abstracts } = numbering;
  if (!definitions || !abstracts) return {};
  const propertiesChain = [];
  const numDefinition = definitions[String(numId)];
  if (!numDefinition) return {};
  const lvlOverride = numDefinition.lvlOverrides?.[String(ilvl)];
  const overrideProps = lvlOverride?.[propertyType];
  if (overrideProps) {
    propertiesChain.push(overrideProps);
  }
  const abstractNumId = numDefinition.abstractNumId;
  const listDefinitionForThisNumId = abstracts[String(abstractNumId)];
  if (!listDefinitionForThisNumId) return {};
  const numStyleLinkId = listDefinitionForThisNumId.numStyleLink ?? listDefinitionForThisNumId.styleLink;
  if (numStyleLinkId && tries < 1) {
    const styleDef = params.translatedLinkedStyles?.styles?.[numStyleLinkId];
    const styleProps = styleDef?.paragraphProperties;
    const numIdFromStyle = styleProps?.numberingProperties?.numId;
    if (numIdFromStyle) {
      return getNumberingProperties(propertyType, params, ilvl, numIdFromStyle, tries + 1);
    }
  }
  const levelDefinition = listDefinitionForThisNumId.levels?.[String(ilvl)];
  if (!levelDefinition) return {};
  const abstractProps = levelDefinition[propertyType];
  if (abstractProps != null) {
    if (levelDefinition?.styleId) {
      abstractProps.styleId = levelDefinition?.styleId;
    }
    propertiesChain.push(abstractProps);
  }
  propertiesChain.reverse();
  return combineProperties(propertiesChain);
}
function resolveDocxFontFamily(attributes, docx, toCssFontFamily) {
  if (!attributes || typeof attributes !== "object") return null;
  const ascii = attributes["w:ascii"] ?? attributes["ascii"] ?? attributes["eastAsia"];
  let themeAscii = attributes["w:asciiTheme"] ?? attributes["asciiTheme"];
  if (!ascii && attributes.hint === "default" || !ascii && !themeAscii) {
    themeAscii = "major";
  }
  let resolved = ascii;
  if (docx && themeAscii) {
    const theme = docx["word/theme/theme1.xml"];
    const themeElements = theme?.elements;
    if (themeElements?.length) {
      const topElement = themeElements[0];
      const topElementElements = topElement?.elements;
      const themeElementsNode = topElementElements?.find((el) => el.name === "a:themeElements");
      const themeElementsElements = themeElementsNode?.elements;
      const fontScheme = themeElementsElements?.find((el) => el.name === "a:fontScheme");
      const fontSchemeElements = fontScheme?.elements;
      const prefix = themeAscii.startsWith("minor") ? "minor" : "major";
      const font = fontSchemeElements?.find((el) => el.name === `a:${prefix}Font`);
      const fontElements = font?.elements;
      const latin = fontElements?.find((el) => el.name === "a:latin");
      const typeface = latin?.attributes?.typeface;
      resolved = typeface || resolved;
    }
  }
  if (!resolved) return null;
  if (toCssFontFamily) {
    return toCssFontFamily(resolved, docx ?? void 0);
  }
  return resolved;
}
function resolveCellStyles(propertyType, tableInfo, translatedLinkedStyles) {
  if (tableInfo == null || !tableInfo.tableProperties?.tableStyleId) {
    return [];
  }
  const cellStyleProps = [];
  if (tableInfo != null && tableInfo.tableProperties.tableStyleId) {
    const tableStyleDef = translatedLinkedStyles.styles[tableInfo.tableProperties.tableStyleId];
    const tableStylePropsDef = tableStyleDef?.tableProperties;
    const rowBandSize = tableStylePropsDef?.tableStyleRowBandSize ?? 1;
    const colBandSize = tableStylePropsDef?.tableStyleColBandSize ?? 1;
    const cellStyleTypes = determineCellStyleTypes(
      tableInfo.tableProperties?.tblLook,
      tableInfo.rowIndex,
      tableInfo.cellIndex,
      tableInfo.numRows,
      tableInfo.numCells,
      rowBandSize,
      colBandSize
    );
    cellStyleTypes.forEach((styleType) => {
      const typeProps = tableStyleDef?.tableStyleProperties?.[styleType]?.[propertyType];
      if (typeProps) {
        cellStyleProps.push(typeProps);
      }
    });
  }
  return cellStyleProps;
}
function determineCellStyleTypes(tblLook, rowIndex, cellIndex, numRows, numCells, rowBandSize = 1, colBandSize = 1) {
  const styleTypes = ["wholeTable"];
  const normalizedRowBandSize = rowBandSize > 0 ? rowBandSize : 1;
  const normalizedColBandSize = colBandSize > 0 ? colBandSize : 1;
  const rowGroup = Math.floor(rowIndex / normalizedRowBandSize);
  const colGroup = Math.floor(cellIndex / normalizedColBandSize);
  if (!tblLook?.noHBand) {
    if (rowGroup % 2 === 0) {
      styleTypes.push("band1Horz");
    } else {
      styleTypes.push("band2Horz");
    }
  }
  if (!tblLook?.noVBand) {
    if (colGroup % 2 === 0) {
      styleTypes.push("band1Vert");
    } else {
      styleTypes.push("band2Vert");
    }
  }
  if (tblLook?.firstRow && rowIndex === 0) {
    styleTypes.push("firstRow");
  }
  if (tblLook?.firstColumn && cellIndex === 0) {
    styleTypes.push("firstCol");
  }
  if (tblLook?.lastRow && numRows != null && numRows > 0 && rowIndex === numRows - 1) {
    styleTypes.push("lastRow");
  }
  if (tblLook?.lastColumn && numCells != null && numCells > 0 && cellIndex === numCells - 1) {
    styleTypes.push("lastCol");
  }
  if (rowIndex === 0 && cellIndex === 0) {
    styleTypes.push("nwCell");
  }
  if (rowIndex === 0 && numCells != null && numCells > 0 && cellIndex === numCells - 1) {
    styleTypes.push("neCell");
  }
  if (numRows != null && numRows > 0 && rowIndex === numRows - 1 && cellIndex === 0) {
    styleTypes.push("swCell");
  }
  if (numRows != null && numRows > 0 && numCells != null && numCells > 0 && rowIndex === numRows - 1 && cellIndex === numCells - 1) {
    styleTypes.push("seCell");
  }
  return styleTypes;
}
const getToCssFontFamily = () => {
  return SuperConverter.toCssFontFamily;
};
const SUBSCRIPT_SUPERSCRIPT_SCALE = 0.65;
function encodeMarksFromRPr(runProperties, docx) {
  const marks = [];
  const textStyleAttrs = {};
  let highlightColor = null;
  let hasHighlightTag = false;
  Object.keys(runProperties).forEach((key) => {
    const value = runProperties[key];
    switch (key) {
      case "strike":
      case "italic":
      case "bold":
        marks.push({ type: key, attrs: { value } });
        break;
      case "textTransform":
        textStyleAttrs[key] = value;
        break;
      case "color":
        if (!value.val) {
          textStyleAttrs[key] = null;
        } else if (value.val.toLowerCase() === "auto") {
          textStyleAttrs[key] = value.val;
        } else {
          textStyleAttrs[key] = `#${value["val"].replace("#", "").toUpperCase()}`;
        }
        break;
      case "underline":
        let underlineType = value["w:val"];
        if (!underlineType) {
          break;
        }
        let underlineColor = value["w:color"];
        if (underlineColor && underlineColor.toLowerCase() !== "auto" && !underlineColor.startsWith("#")) {
          underlineColor = `#${underlineColor}`;
        }
        marks.push({
          type: key,
          attrs: {
            underlineType,
            underlineColor
          }
        });
        break;
      case "styleId":
        textStyleAttrs[key] = value;
        break;
      case "fontSize":
        const points = halfPointToPoints(value);
        textStyleAttrs[key] = `${points}pt`;
        break;
      case "letterSpacing":
        const spacing = twipsToPt(value);
        textStyleAttrs[key] = `${spacing}pt`;
        break;
      case "fontFamily":
        const fontFamily = resolveDocxFontFamily(value, docx, getToCssFontFamily());
        textStyleAttrs[key] = fontFamily;
        const eastAsiaFamily = typeof value === "object" && value !== null ? value["eastAsia"] : void 0;
        if (eastAsiaFamily) {
          const eastAsiaCss = getFontFamilyValue$1({ "w:ascii": eastAsiaFamily }, docx);
          if (!fontFamily || eastAsiaCss !== textStyleAttrs.fontFamily) {
            textStyleAttrs.eastAsiaFontFamily = eastAsiaCss;
          }
        }
        break;
      case "highlight":
        const color = getHighLightValue$1(value);
        if (color) {
          hasHighlightTag = true;
          highlightColor = color;
        }
        break;
      case "shading": {
        if (hasHighlightTag) {
          break;
        }
        const fill = value["fill"];
        const shdVal = value["val"];
        if (fill && String(fill).toLowerCase() !== "auto") {
          highlightColor = `#${String(fill).replace("#", "")}`;
        } else if (typeof shdVal === "string") {
          const normalized = shdVal.toLowerCase();
          if (normalized === "clear" || normalized === "nil" || normalized === "none") {
            highlightColor = "transparent";
          }
        }
        break;
      }
      case "vertAlign": {
        if (value) {
          textStyleAttrs.vertAlign = value;
        }
        break;
      }
      case "position": {
        if (value != null && Number.isFinite(value)) {
          const points2 = halfPointToPoints(value);
          if (Number.isFinite(points2)) {
            textStyleAttrs.position = `${points2}pt`;
          }
        }
        break;
      }
    }
  });
  if (Object.keys(textStyleAttrs).length) {
    marks.push({ type: "textStyle", attrs: textStyleAttrs });
  }
  if (highlightColor) {
    marks.push({ type: "highlight", attrs: { color: highlightColor } });
  }
  return marks;
}
function encodeCSSFromPPr(paragraphProperties, hasPreviousParagraph, nextParagraphProps) {
  if (!paragraphProperties || typeof paragraphProperties !== "object") {
    return {};
  }
  let css = {};
  const { spacing, indent, borders, justification } = paragraphProperties;
  const nextStyleId = nextParagraphProps?.styleId;
  if (spacing) {
    const getEffectiveBefore = (nextSpacing, isListItem) => {
      if (!nextSpacing) return 0;
      if (nextSpacing.beforeAutospacing && isListItem) {
        return 0;
      }
      return nextSpacing.before || 0;
    };
    const isDropCap = Boolean(paragraphProperties.framePr?.dropCap);
    const spacingCopy = { ...spacing };
    if (hasPreviousParagraph) {
      delete spacingCopy.before;
    }
    if (isDropCap) {
      spacingCopy.line = linesToTwips(1);
      spacingCopy.lineRule = "auto";
      delete spacingCopy.after;
    } else {
      const nextBefore = getEffectiveBefore(
        nextParagraphProps?.spacing,
        Boolean(nextParagraphProps?.numberingProperties)
      );
      spacingCopy.after = Math.max(spacingCopy.after || 0, nextBefore);
      if (paragraphProperties.contextualSpacing && nextStyleId != null && nextStyleId === paragraphProperties.styleId) {
        spacingCopy.after -= paragraphProperties.spacing?.after || 0;
      }
      if (nextParagraphProps?.contextualSpacing && nextStyleId != null && nextStyleId === paragraphProperties.styleId) {
        spacingCopy.after -= nextBefore;
      }
      spacingCopy.after = Math.max(spacingCopy.after, 0);
    }
    const spacingStyle = getSpacingStyle(spacingCopy, Boolean(paragraphProperties.numberingProperties));
    css = { ...css, ...spacingStyle };
  }
  if (indent && typeof indent === "object") {
    const hasIndentValue = Object.values(indent).some((value) => value != null && Number(value) !== 0);
    if (hasIndentValue) {
      const { left, right, firstLine, hanging } = indent;
      if (left != null) {
        css["margin-left"] = `${twipsToPixels(left)}px`;
      }
      if (right != null) {
        css["margin-right"] = `${twipsToPixels(right)}px`;
      }
      if (firstLine != null && !hanging) {
        css["text-indent"] = `${twipsToPixels(firstLine)}px`;
      }
      if (firstLine != null && hanging != null) {
        css["text-indent"] = `${twipsToPixels(firstLine - hanging)}px`;
      }
      if (firstLine == null && hanging != null) {
        css["text-indent"] = `${twipsToPixels(-hanging)}px`;
      }
    }
  }
  if (borders && typeof borders === "object") {
    const sideOrder = ["top", "right", "bottom", "left"];
    const valToCss = {
      single: "solid",
      dashed: "dashed",
      dotted: "dotted",
      double: "double"
    };
    sideOrder.forEach((side) => {
      const b2 = borders[side];
      if (!b2) return;
      if (["nil", "none", void 0, null].includes(b2.val)) {
        css[`border-${side}`] = "none";
        return;
      }
      const width = b2.size != null ? `${eighthPointsToPixels(b2.size)}px` : "1px";
      const cssStyle = valToCss[b2.val] || "solid";
      const color = !b2.color || b2.color === "auto" ? "#000000" : `#${b2.color}`;
      css[`border-${side}`] = `${width} ${cssStyle} ${color}`;
      if (b2.space != null && side === "bottom") {
        css[`padding-bottom`] = `${eighthPointsToPixels(b2.space)}px`;
      }
    });
  }
  if (justification) {
    if (justification === "both") {
      css["text-align"] = "justify";
    } else {
      css["text-align"] = justification;
    }
  }
  return css;
}
function encodeCSSFromRPr(runProperties, docx) {
  if (!runProperties || typeof runProperties !== "object") {
    return {};
  }
  const css = {};
  const textDecorationLines = /* @__PURE__ */ new Set();
  let hasTextDecorationNone = false;
  let highlightColor = null;
  let hasHighlightTag = false;
  let verticalAlignValue;
  let fontSizeOverride;
  Object.keys(runProperties).forEach((key) => {
    const value = runProperties[key];
    switch (key) {
      case "bold": {
        const normalized = normalizeToggleValue(value);
        if (normalized === true) {
          css["font-weight"] = "bold";
        } else if (normalized === false) {
          css["font-weight"] = "normal";
        }
        break;
      }
      case "italic": {
        const normalized = normalizeToggleValue(value);
        if (normalized === true) {
          css["font-style"] = "italic";
        } else if (normalized === false) {
          css["font-style"] = "normal";
        }
        break;
      }
      case "strike": {
        const normalized = normalizeToggleValue(value);
        if (normalized === true) {
          addTextDecorationEntries(textDecorationLines, "line-through");
        } else if (normalized === false) {
          css["text-decoration"] = "none";
          hasTextDecorationNone = true;
        }
        break;
      }
      case "textTransform": {
        if (value != null) {
          css["text-transform"] = value;
        }
        break;
      }
      case "color": {
        const colorVal = value?.val;
        if (colorVal == null || colorVal === "") {
          break;
        }
        if (String(colorVal).toLowerCase() === "auto") {
          css["color"] = "auto";
        } else {
          css["color"] = `#${String(colorVal).replace("#", "").toUpperCase()}`;
        }
        break;
      }
      case "underline": {
        const underlineType = value?.["w:val"];
        if (!underlineType) break;
        let underlineColor = value?.["w:color"];
        if (underlineColor && typeof underlineColor === "string" && underlineColor.toLowerCase() !== "auto" && !underlineColor.startsWith("#")) {
          underlineColor = `#${underlineColor}`;
        }
        const underlineCssString = getUnderlineCssString({ type: underlineType, color: underlineColor });
        const underlineCss = parseCssDeclarations(underlineCssString);
        Object.entries(underlineCss).forEach(([prop, propValue]) => {
          if (!propValue) return;
          if (prop === "text-decoration") {
            css[prop] = propValue;
            if (propValue === "none") {
              hasTextDecorationNone = true;
            }
            return;
          }
          if (prop === "text-decoration-line") {
            addTextDecorationEntries(textDecorationLines, propValue);
            return;
          }
          css[prop] = propValue;
        });
        break;
      }
      case "fontSize": {
        if (value == null) break;
        const points = halfPointToPoints(value);
        if (Number.isFinite(points)) {
          css["font-size"] = `${points}pt`;
        }
        break;
      }
      case "letterSpacing": {
        if (value == null) break;
        const spacing = twipsToPt(value);
        if (Number.isFinite(spacing)) {
          css["letter-spacing"] = `${spacing}pt`;
        }
        break;
      }
      case "fontFamily": {
        if (!value) break;
        const fontFamily = resolveDocxFontFamily(value, docx, getToCssFontFamily());
        if (fontFamily) {
          css["font-family"] = fontFamily;
        }
        const eastAsiaFamily = typeof value === "object" && value !== null ? value["eastAsia"] : void 0;
        if (eastAsiaFamily) {
          const eastAsiaCss = getFontFamilyValue$1({ "w:ascii": eastAsiaFamily }, docx);
          if (eastAsiaCss && (!fontFamily || eastAsiaCss !== fontFamily)) {
            css["font-family"] = css["font-family"] || eastAsiaCss;
          }
        }
        break;
      }
      case "highlight": {
        const color = getHighLightValue$1(value);
        if (color) {
          hasHighlightTag = true;
          highlightColor = color;
        }
        break;
      }
      case "shading": {
        if (hasHighlightTag) {
          break;
        }
        const fill = value?.["fill"];
        const shdVal = value?.["val"];
        if (fill && String(fill).toLowerCase() !== "auto") {
          highlightColor = `#${String(fill).replace("#", "")}`;
        } else if (typeof shdVal === "string") {
          const normalized = shdVal.toLowerCase();
          if (normalized === "clear" || normalized === "nil" || normalized === "none") {
            highlightColor = "transparent";
          }
        }
        break;
      }
      case "vertAlign": {
        if (runProperties.position != null && Number.isFinite(runProperties.position)) {
          break;
        }
        if (value === "superscript" || value === "subscript") {
          verticalAlignValue = value === "superscript" ? "super" : "sub";
          if (runProperties.fontSize != null && Number.isFinite(runProperties.fontSize)) {
            const scaledPoints = halfPointToPoints(runProperties.fontSize * SUBSCRIPT_SUPERSCRIPT_SCALE);
            if (Number.isFinite(scaledPoints)) {
              fontSizeOverride = `${scaledPoints}pt`;
            }
          } else {
            fontSizeOverride = `${SUBSCRIPT_SUPERSCRIPT_SCALE * 100}%`;
          }
        } else if (value === "baseline") {
          verticalAlignValue = "baseline";
        }
        break;
      }
      case "position": {
        if (value != null && Number.isFinite(value)) {
          const points = halfPointToPoints(value);
          if (Number.isFinite(points)) {
            verticalAlignValue = `${points}pt`;
            fontSizeOverride = void 0;
          }
        }
        break;
      }
    }
  });
  if (!hasTextDecorationNone && textDecorationLines.size) {
    const combined = /* @__PURE__ */ new Set();
    addTextDecorationEntries(combined, css["text-decoration-line"]);
    textDecorationLines.forEach((entry) => combined.add(entry));
    css["text-decoration-line"] = Array.from(combined).join(" ");
  }
  if (highlightColor) {
    css["background-color"] = highlightColor;
    if (!("color" in css)) {
      css["color"] = "inherit";
    }
  }
  if (fontSizeOverride) {
    css["font-size"] = fontSizeOverride;
  }
  if (verticalAlignValue) {
    css["vertical-align"] = verticalAlignValue;
  }
  return css;
}
function decodeRPrFromMarks(marks) {
  const runProperties = {};
  if (!marks) {
    return runProperties;
  }
  marks.forEach((mark) => {
    const type2 = mark.type.name ?? mark.type;
    switch (type2) {
      case "strike":
      case "italic":
      case "bold":
        runProperties[type2] = mark.attrs.value !== "0" && mark.attrs.value !== false;
        break;
      case "underline": {
        const { underlineType, underlineColor } = mark.attrs;
        const underlineAttrs = {};
        if (underlineType) {
          underlineAttrs["w:val"] = underlineType;
        }
        if (underlineColor) {
          underlineAttrs["w:color"] = underlineColor.replace("#", "");
        }
        if (Object.keys(underlineAttrs).length > 0) {
          runProperties.underline = underlineAttrs;
        }
        break;
      }
      case "highlight":
        if (mark.attrs.color) {
          if (mark.attrs.color.toLowerCase() === "transparent") {
            runProperties.highlight = { "w:val": "none" };
          } else {
            runProperties.highlight = { "w:val": mark.attrs.color };
          }
        }
        break;
      case "textStyle":
        Object.keys(mark.attrs).forEach((attr) => {
          const value = mark.attrs[attr];
          switch (attr) {
            case "textTransform":
              if (value != null) {
                runProperties[attr] = value;
              }
              break;
            case "color":
              if (value != null) {
                runProperties.color = { val: value.replace("#", "") };
              }
              break;
            case "fontSize": {
              const points = parseFloat(value);
              if (!isNaN(points)) {
                runProperties.fontSize = points * 2;
              }
              break;
            }
            case "letterSpacing": {
              const ptValue = parseFloat(value);
              if (!isNaN(ptValue)) {
                runProperties.letterSpacing = ptToTwips(ptValue);
              }
              break;
            }
            case "fontFamily":
              if (value != null) {
                const cleanValue = value.split(",")[0].trim();
                const result = {};
                ["ascii", "eastAsia", "hAnsi", "cs"].forEach((attr2) => {
                  result[attr2] = cleanValue;
                });
                runProperties.fontFamily = result;
              }
              break;
            case "vertAlign":
              if (value != null) {
                runProperties.vertAlign = value;
              }
              break;
            case "position": {
              if (value != null) {
                const numeric = parseFloat(value);
                if (!isNaN(numeric)) {
                  runProperties.position = numeric * 2;
                }
              }
              break;
            }
          }
        });
        break;
    }
  });
  return runProperties;
}
function getFontFamilyValue$1(attributes, docx) {
  const ascii = attributes["w:ascii"] ?? attributes["ascii"];
  const themeAscii = attributes["w:asciiTheme"] ?? attributes["asciiTheme"];
  let resolved = ascii;
  if (docx && themeAscii) {
    const theme = docx["word/theme/theme1.xml"];
    if (theme?.elements?.length) {
      const { elements: topElements } = theme;
      const { elements } = topElements[0] || {};
      const themeElements = elements?.find((el) => el.name === "a:themeElements");
      const fontScheme = themeElements?.elements?.find((el) => el.name === "a:fontScheme");
      const prefix = themeAscii.startsWith("minor") ? "minor" : "major";
      const font = fontScheme?.elements?.find((el) => el.name === `a:${prefix}Font`);
      const latin = font?.elements?.find((el) => el.name === "a:latin");
      resolved = latin?.attributes?.typeface || resolved;
    }
  }
  if (!resolved) return null;
  return SuperConverter.toCssFontFamily(resolved, docx);
}
function getHighLightValue$1(attributes) {
  const fill = attributes["w:fill"];
  if (fill && fill !== "auto") return `#${fill}`;
  if (attributes?.["w:val"] === "none") return "transparent";
  if (isValidHexColor(attributes?.["w:val"])) return `#${attributes["w:val"]}`;
  return getHexColorFromDocxSystem(attributes?.["w:val"]) || null;
}
function normalizeToggleValue(value) {
  if (value == null) return null;
  if (typeof value === "boolean") return value;
  if (typeof value === "number") return value !== 0;
  if (typeof value === "string") {
    const normalized = value.toLowerCase();
    if (normalized === "0" || normalized === "false" || normalized === "off") return false;
    if (normalized === "1" || normalized === "true" || normalized === "on") return true;
  }
  return Boolean(value);
}
function parseCssDeclarations(cssString) {
  if (!cssString || typeof cssString !== "string") {
    return {};
  }
  return cssString.split(";").map((chunk) => chunk.trim()).filter(Boolean).reduce((acc, declaration) => {
    const separatorIndex = declaration.indexOf(":");
    if (separatorIndex === -1) return acc;
    const property = declaration.slice(0, separatorIndex).trim();
    const value = declaration.slice(separatorIndex + 1).trim();
    if (!property || !value) return acc;
    acc[property] = value;
    return acc;
  }, {});
}
function addTextDecorationEntries(targetSet, value) {
  if (!value) return;
  if (value instanceof Set) {
    value.forEach((entry) => addTextDecorationEntries(targetSet, entry));
    return;
  }
  String(value).split(/\s+/).map((entry) => entry.trim()).filter(Boolean).forEach((entry) => targetSet.add(entry));
}
const getSpacingStyle = (spacing, isListItem) => {
  let { before, after, line, lineRule, beforeAutospacing, afterAutospacing } = spacing;
  line = twipsToLines(line);
  if (line != null && line < 1) {
    line = 1;
  }
  if (lineRule === "exact" && line) {
    line = String(line);
  }
  before = twipsToPixels(before);
  if (beforeAutospacing) {
    if (isListItem) {
      before = 0;
    }
  }
  after = twipsToPixels(after);
  if (afterAutospacing) {
    if (isListItem) {
      after = 0;
    }
  }
  const css = {};
  if (before) {
    css["margin-top"] = `${before}px`;
  }
  if (after) {
    css["margin-bottom"] = `${after}px`;
  }
  if (line) {
    if (lineRule !== "atLeast" || line >= 1) {
      line = Math.max(line, 1);
      css["line-height"] = String(line);
    }
  }
  return css;
};
function parseMarks(property, unknownMarks = [], docx = null) {
  const marks = [];
  const seen = /* @__PURE__ */ new Set();
  property?.elements?.forEach((element) => {
    const marksForType = SuperConverter.markTypes.filter((mark) => mark.name === element.name);
    if (!marksForType.length) {
      const missingMarks = [
        "w:shd",
        "w:rStyle",
        "w:pStyle",
        "w:numPr",
        "w:outlineLvl",
        "w:bdr",
        "w:noProof",
        "w:contextualSpacing",
        "w:keepNext",
        "w:tabs",
        "w:keepLines"
      ];
      if (missingMarks.includes(element.name)) {
        unknownMarks.push(element.name);
      }
    }
    let filteredMarksForType = marksForType;
    if (element.name === "w:spacing") {
      const attrs = element.attributes || {};
      const hasLetterSpacing = attrs["w:val"];
      filteredMarksForType = marksForType.filter((m2) => {
        if (hasLetterSpacing) {
          return m2.type === "letterSpacing";
        }
        return m2.type === "lineHeight";
      });
    }
    filteredMarksForType.forEach((m2) => {
      if (!m2 || seen.has(m2.type)) return;
      seen.add(m2.type);
      const { attributes = {} } = element;
      const newMark = { type: m2.type };
      const exceptionMarks = ["w:b", "w:caps", "w:strike", "w:dstrike"];
      if ((attributes["w:val"] === "0" || attributes["w:val"] === "none") && !exceptionMarks.includes(m2.name)) {
        return;
      }
      const requiresValue = ["w:u"];
      if (requiresValue.includes(m2.name) && !attributes["w:val"]) {
        return;
      }
      if (m2.mark) newMark.type = m2.mark;
      if (m2.name === "w:caps") {
        newMark.attrs = {};
        if (attributes["w:val"] === "0") {
          newMark.attrs[m2.property] = "none";
        } else {
          newMark.attrs[m2.property] = "uppercase";
        }
        marks.push(newMark);
        return;
      }
      if (Object.keys(attributes).length) {
        const value = getMarkValue(m2.type, attributes, docx);
        if (value === null || value === void 0) return;
        newMark.attrs = {};
        newMark.attrs[m2.property] = value;
      }
      marks.push(newMark);
    });
  });
  return createImportMarks(marks);
}
function handleStyleChangeMarksV2(rPrChange, currentMarks, params) {
  if (!rPrChange) {
    return [];
  }
  const { attributes } = rPrChange;
  const mappedAttributes = {
    id: attributes["w:id"],
    date: attributes["w:date"],
    author: attributes["w:author"],
    authorEmail: attributes["w:authorEmail"]
  };
  let submarks = [];
  const rPr = rPrChange.elements?.find((el) => el.name === "w:rPr");
  if (rPr) {
    const runProperties = translator$2w.encode({ ...params, nodes: [rPr] });
    submarks = encodeMarksFromRPr(runProperties, params?.docx);
  }
  return [{ type: TrackFormatMarkName, attrs: { ...mappedAttributes, before: submarks, after: [...currentMarks] } }];
}
function handleStyleChangeMarks(rPr, currentMarks) {
  const styleChangeMark = rPr.elements?.find((el) => el.name === "w:rPrChange");
  if (!styleChangeMark) {
    return [];
  }
  const { attributes } = styleChangeMark;
  const mappedAttributes = {
    id: attributes["w:id"],
    date: attributes["w:date"],
    author: attributes["w:author"],
    authorEmail: attributes["w:authorEmail"]
  };
  const submarks = parseMarks(styleChangeMark);
  return [{ type: TrackFormatMarkName, attrs: { ...mappedAttributes, before: submarks, after: [...currentMarks] } }];
}
function createImportMarks(marks) {
  const textStyleMarksToCombine = marks.filter((mark) => mark.type === "textStyle");
  const remainingMarks = marks.filter((mark) => mark.type !== "textStyle");
  const combinedTextAttrs = {};
  if (textStyleMarksToCombine.length) {
    textStyleMarksToCombine.forEach((mark) => {
      const { attrs = {} } = mark;
      Object.keys(attrs).forEach((attr) => {
        combinedTextAttrs[attr] = attrs[attr];
      });
    });
  }
  const result = [...remainingMarks, { type: "textStyle", attrs: combinedTextAttrs }];
  return result;
}
function getMarkValue(markType, attributes, docx) {
  if (markType === "tabs") markType = "textIndent";
  const markValueMapper = {
    color: () => `#${attributes["w:val"]}`,
    fontSize: () => `${attributes["w:val"] / 2}pt`,
    textIndent: () => getIndentValue(attributes),
    fontFamily: () => getFontFamilyValue(attributes, docx),
    lineHeight: () => getLineHeightValue(attributes),
    letterSpacing: () => `${twipsToPt(attributes["w:val"])}pt`,
    textAlign: () => attributes["w:val"],
    link: () => attributes["href"],
    underline: () => attributes["w:val"],
    bold: () => attributes?.["w:val"] || null,
    italic: () => attributes?.["w:val"] || null,
    highlight: () => getHighLightValue(attributes),
    strike: () => getStrikeValue(attributes)
  };
  if (markType in markValueMapper) {
    return markValueMapper[markType]();
  }
}
function getFontFamilyValue(attributes, docx) {
  const ascii = attributes["w:ascii"] ?? attributes["ascii"];
  const themeAscii = attributes["w:asciiTheme"] ?? attributes["asciiTheme"];
  let resolved = ascii;
  if (docx && themeAscii) {
    const theme = docx["word/theme/theme1.xml"];
    if (theme?.elements?.length) {
      const { elements: topElements } = theme;
      const { elements } = topElements[0] || {};
      const themeElements = elements?.find((el) => el.name === "a:themeElements");
      const fontScheme = themeElements?.elements?.find((el) => el.name === "a:fontScheme");
      const prefix = themeAscii.startsWith("minor") ? "minor" : "major";
      const font = fontScheme?.elements?.find((el) => el.name === `a:${prefix}Font`);
      const latin = font?.elements?.find((el) => el.name === "a:latin");
      resolved = latin?.attributes?.typeface || resolved;
    }
  }
  if (!resolved) return null;
  return SuperConverter.toCssFontFamily(resolved, docx);
}
function getIndentValue(attributes) {
  let value = attributes["w:left"];
  if (!value) return null;
  return `${twipsToInches(value)}in`;
}
function getLineHeightValue(attributes) {
  const value = attributes["w:line"];
  const lineRule = attributes["w:lineRule"];
  if (!value || value === "0") return null;
  if (lineRule === "exact") return `${twipsToPt(value)}pt`;
  return `${twipsToLines(value)}`;
}
function getHighLightValue(attributes) {
  const fill = attributes["w:fill"];
  if (fill && fill !== "auto") return `#${fill}`;
  if (isValidHexColor(attributes?.["w:val"])) return `#${attributes["w:val"]}`;
  return getHexColorFromDocxSystem(attributes?.["w:val"]) || null;
}
function getStrikeValue(attributes) {
  const raw = attributes?.["w:val"];
  if (raw === void 0 || raw === null) return "1";
  const value = String(raw).trim().toLowerCase();
  if (value === "1" || value === "true" || value === "on") return "1";
  if (value === "0" || value === "false" || value === "off") return "0";
  return "1";
}
function parseProperties(node) {
  const marks = [];
  const unknownMarks = [];
  const { attributes = {}, elements = [] } = node;
  const { nodes, paragraphProperties = {}, runProperties = {} } = splitElementsAndProperties(elements);
  const hasRun = elements.find((element) => element.name === "w:r");
  if (hasRun) paragraphProperties.elements = paragraphProperties?.elements?.filter((el) => el.name !== "w:rPr");
  if (runProperties && runProperties?.elements?.length) {
    marks.push(...parseMarks(runProperties, unknownMarks));
  }
  if (paragraphProperties && paragraphProperties.elements?.length) {
    const disallowedParagraphProperties = ["w:u"];
    const filteredParagraphProperties = {
      ...paragraphProperties,
      elements: paragraphProperties.elements?.filter((el) => !disallowedParagraphProperties.includes(el.name))
    };
    marks.push(...parseMarks(filteredParagraphProperties, unknownMarks));
  }
  marks.push(...handleStyleChangeMarks(runProperties, marks));
  if (paragraphProperties && paragraphProperties.elements?.length) {
    attributes["paragraphProperties"] = paragraphProperties;
  }
  if (marks && node.name === "w:p") {
    marks.forEach((mark) => {
      const attrValue = Object.keys(mark.attrs ?? {})[0];
      if (attrValue) {
        const value = mark.attrs[attrValue];
        attributes[attrValue] = value;
      }
    });
  }
  return { elements: nodes, attributes, marks, unknownMarks };
}
function splitElementsAndProperties(elements) {
  const pPr = elements.find((el) => el.name === "w:pPr");
  const rPr = elements.find((el) => el.name === "w:rPr");
  const sectPr = elements.find((el) => el.name === "w:sectPr");
  const els = elements.filter((el) => el.name !== "w:pPr" && el.name !== "w:rPr" && el.name !== "w:sectPr");
  return {
    nodes: els,
    paragraphProperties: pPr,
    runProperties: rPr,
    sectionProperties: sectPr
  };
}
const SUPPORTED_ALTERNATE_CONTENT_REQUIRES = /* @__PURE__ */ new Set([
  "wps",
  "wpg",
  "wp14",
  "w14",
  "w15",
  "w16",
  "w16cex",
  "w16cid",
  "w16du",
  "w16sdtdh",
  "w16sdtfl",
  "w16se"
]);
const XML_NODE_NAME$r = "mc:AlternateContent";
const SD_NODE_NAME$n = [];
const validXmlAttributes$f = [];
function encode$Q(params) {
  const { nodeListHandler } = params;
  const { node } = params.extraParams;
  if (!node || !node.type) {
    return null;
  }
  const { branch, elements } = selectAlternateContentElements(node);
  if (!elements) {
    return null;
  }
  return nodeListHandler.handler({
    ...params,
    nodes: elements,
    path: buildPath(params.path, node, branch)
  });
}
function decode$S(params) {
  const { node } = params;
  const { drawingContent } = node.attrs;
  const drawing = {
    name: "w:drawing",
    elements: [...drawingContent ? [...drawingContent.elements || []] : []]
  };
  const choice = {
    name: "mc:Choice",
    attributes: { Requires: "wps" },
    elements: [drawing]
  };
  return {
    name: "mc:AlternateContent",
    elements: [choice]
  };
}
const config$q = {
  xmlName: XML_NODE_NAME$r,
  sdNodeOrKeyName: SD_NODE_NAME$n,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$Q,
  decode: decode$S,
  attributes: validXmlAttributes$f
};
function selectAlternateContentElements(node) {
  if (!node?.elements?.length) {
    return { branch: null, elements: null };
  }
  const choices = node.elements.filter((el) => el?.name === "mc:Choice");
  const fallback = node.elements.find((el) => el?.name === "mc:Fallback");
  const supportedChoice = choices.find((choice) => {
    const requiresAttr = choice?.attributes?.Requires || choice?.attributes?.requires;
    if (!requiresAttr) return false;
    return requiresAttr.split(/\s+/).filter(Boolean).some((namespace) => SUPPORTED_ALTERNATE_CONTENT_REQUIRES.has(namespace));
  });
  const branch = supportedChoice || fallback || choices[0] || null;
  const selectedElements = branch?.elements;
  if (!selectedElements) {
    return { branch, elements: null };
  }
  return {
    branch,
    elements: carbonCopy(selectedElements)
  };
}
const translator$2v = NodeTranslator.from(config$q);
function buildPath(existingPath = [], node, branch) {
  const path = [...existingPath];
  if (node) path.push(node);
  if (branch) path.push(branch);
  return path;
}
const translator$2u = NodeTranslator.from(createSingleBooleanPropertyHandler("w:adjustRightInd"));
const translator$2t = NodeTranslator.from(createSingleBooleanPropertyHandler("w:autoSpaceDE"));
const translator$2s = NodeTranslator.from(createSingleBooleanPropertyHandler("w:autoSpaceDN"));
const translator$2r = NodeTranslator.from(createSingleBooleanPropertyHandler("w:bidi", "rightToLeft"));
const translator$2q = NodeTranslator.from({
  xmlName: "w:cnfStyle",
  sdNodeOrKeyName: "cnfStyle",
  attributes: [
    "w:evenHBand",
    "w:evenVBand",
    "w:firstColumn",
    "w:firstRow",
    "w:firstRowFirstColumn",
    "w:firstRowLastColumn",
    "w:lastColumn",
    "w:lastRow",
    "w:lastRowFirstColumn",
    "w:lastRowLastColumn",
    "w:oddHBand",
    "w:oddVBand"
  ].map((attr) => createAttributeHandler(attr, null, parseBoolean, booleanToString)).concat([createAttributeHandler("w:val")]),
  encode: (_2, encodedAttrs) => {
    return Object.keys(encodedAttrs).length > 0 ? encodedAttrs : void 0;
  },
  decode: function({ node }) {
    if (!node.attrs?.cnfStyle) return;
    const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs.cnfStyle || {} } });
    return Object.keys(decodedAttrs).length > 0 ? { attributes: decodedAttrs } : void 0;
  }
});
const translator$2p = NodeTranslator.from(createSingleBooleanPropertyHandler("w:contextualSpacing"));
const translator$2o = NodeTranslator.from(createSingleAttrPropertyHandler("w:divId"));
const translator$2n = NodeTranslator.from({
  xmlName: "w:framePr",
  sdNodeOrKeyName: "framePr",
  attributes: [
    createBooleanAttributeHandler("w:anchorLock"),
    createAttributeHandler("w:dropCap"),
    createIntegerAttributeHandler("w:h"),
    createAttributeHandler("w:hAnchor"),
    createAttributeHandler("w:hRule"),
    createIntegerAttributeHandler("w:hSpace"),
    createIntegerAttributeHandler("w:lines"),
    createAttributeHandler("w:vAnchor"),
    createIntegerAttributeHandler("w:vSpace"),
    createIntegerAttributeHandler("w:w"),
    createAttributeHandler("w:wrap"),
    createIntegerAttributeHandler("w:x"),
    createAttributeHandler("w:xAlign"),
    createIntegerAttributeHandler("w:y"),
    createAttributeHandler("w:yAlign")
  ],
  encode: (_2, encodedAttrs) => {
    return encodedAttrs;
  },
  decode: function({ node }) {
    const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs["framePr"] || {} } });
    return Object.keys(decodedAttrs).length > 0 ? { attributes: decodedAttrs } : void 0;
  }
});
const translator$2m = NodeTranslator.from({
  xmlName: "w:ind",
  sdNodeOrKeyName: "indent",
  attributes: [
    createIntegerAttributeHandler("w:end"),
    createIntegerAttributeHandler("w:endChars"),
    createIntegerAttributeHandler("w:firstLine"),
    createIntegerAttributeHandler("w:firstLineChars"),
    createIntegerAttributeHandler("w:hanging"),
    createIntegerAttributeHandler("w:hangingChars"),
    createIntegerAttributeHandler("w:left"),
    createIntegerAttributeHandler("w:leftChars"),
    createIntegerAttributeHandler("w:right"),
    createIntegerAttributeHandler("w:rightChars"),
    createIntegerAttributeHandler("w:start"),
    createIntegerAttributeHandler("w:startChars")
  ],
  encode: (_2, encodedAttrs) => {
    return encodedAttrs;
  },
  decode: function({ node }) {
    const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs["indent"] || {} } });
    return Object.keys(decodedAttrs).length > 0 ? { attributes: decodedAttrs } : void 0;
  }
});
const translator$2l = NodeTranslator.from(createSingleAttrPropertyHandler("w:jc", "justification"));
const translator$2k = NodeTranslator.from(createSingleBooleanPropertyHandler("w:keepLines"));
const translator$2j = NodeTranslator.from(createSingleBooleanPropertyHandler("w:keepNext"));
const translator$2i = NodeTranslator.from(createSingleBooleanPropertyHandler("w:kinsoku"));
const translator$2h = NodeTranslator.from(createSingleBooleanPropertyHandler("w:mirrorIndents"));
const translator$2g = NodeTranslator.from(createSingleIntegerPropertyHandler("w:ilvl"));
const createTrackStyleMark = (marks) => {
  const trackStyleMark = marks.find((mark) => mark.type === "trackFormat");
  if (trackStyleMark) {
    return {
      type: "element",
      name: "w:rPrChange",
      attributes: {
        "w:id": trackStyleMark.attrs.id,
        "w:author": trackStyleMark.attrs.author,
        "w:authorEmail": trackStyleMark.attrs.authorEmail,
        "w:date": trackStyleMark.attrs.date
      },
      elements: trackStyleMark.attrs.before.map((mark) => processOutputMarks([mark])).filter((r) => r !== void 0)
    };
  }
  return void 0;
};
const XML_NODE_NAME$q = "w:ins";
const SD_ATTR_KEY$2 = "trackInsert";
const validXmlAttributes$e = [
  createAttributeHandler("w:id", "id"),
  createAttributeHandler("w:date", "date"),
  createAttributeHandler("w:author", "author"),
  createAttributeHandler("w:authorEmail", "authorEmail")
];
const encode$P = (params, encodedAttrs = {}) => {
  const { nodeListHandler, extraParams = {}, converter } = params;
  const { node } = extraParams;
  if (encodedAttrs.id && converter?.trackedChangeIdMap?.has(encodedAttrs.id)) {
    encodedAttrs.id = converter.trackedChangeIdMap.get(encodedAttrs.id);
  }
  const subs = nodeListHandler.handler({
    ...params,
    insideTrackChange: true,
    nodes: node.elements,
    path: [...params.path || [], node]
  });
  encodedAttrs.importedAuthor = `${encodedAttrs.author} (imported)`;
  if (converter?.documentOrigin) {
    encodedAttrs.origin = converter.documentOrigin;
  }
  subs.forEach((subElement) => {
    subElement.marks = [];
    if (subElement?.content?.[0]) {
      if (subElement.content[0].marks === void 0) {
        subElement.content[0].marks = [];
      }
      if (subElement.content[0].type === "text") {
        subElement.content[0].marks.push({ type: "trackInsert", attrs: encodedAttrs });
      }
    }
  });
  return subs;
};
function decode$R(params) {
  const { node } = params;
  if (!node || !node.type) {
    return null;
  }
  const trackingMarks = ["trackInsert", "trackFormat", "trackDelete"];
  const marks = node.marks;
  const trackedMark = marks.find((m2) => m2.type === "trackInsert");
  const trackStyleMark = createTrackStyleMark(marks);
  node.marks = marks.filter((m2) => !trackingMarks.includes(m2.type));
  if (trackStyleMark) {
    node.marks.push(trackStyleMark);
  }
  const translatedTextNode = exportSchemaToJson({ ...params, node });
  return {
    name: "w:ins",
    attributes: {
      "w:id": trackedMark.attrs.id,
      "w:author": trackedMark.attrs.author,
      "w:authorEmail": trackedMark.attrs.authorEmail,
      "w:date": trackedMark.attrs.date
    },
    elements: [translatedTextNode]
  };
}
const config$p = {
  xmlName: XML_NODE_NAME$q,
  sdNodeOrKeyName: SD_ATTR_KEY$2,
  type: NodeTranslator.translatorTypes.ATTRIBUTE,
  encode: encode$P,
  decode: decode$R,
  attributes: validXmlAttributes$e
};
const translator$2f = NodeTranslator.from(config$p);
const translator$2e = NodeTranslator.from(createSingleIntegerPropertyHandler("w:numId"));
const propertyTranslators$g = [translator$2v, translator$2g, translator$2f, translator$2e];
const translator$2d = NodeTranslator.from(
  createNestedPropertiesTranslator("w:numPr", "numberingProperties", propertyTranslators$g)
);
const translator$2c = NodeTranslator.from(
  createSingleAttrPropertyHandler("w:outlineLvl", "outlineLvl", "w:val", parseInteger, integerToString)
);
const translator$2b = NodeTranslator.from(createSingleBooleanPropertyHandler("w:overflowPunct"));
const translator$2a = NodeTranslator.from(createBorderPropertyHandler("w:bar"));
const translator$29 = NodeTranslator.from(createBorderPropertyHandler("w:between"));
const translator$28 = NodeTranslator.from(createBorderPropertyHandler("w:bottom"));
const translator$27 = NodeTranslator.from(createMeasurementPropertyHandler("w:bottom", "marginBottom"));
const translator$26 = NodeTranslator.from(createBorderPropertyHandler("w:left"));
const translator$25 = NodeTranslator.from(createMeasurementPropertyHandler("w:left", "marginLeft"));
const translator$24 = NodeTranslator.from(createBorderPropertyHandler("w:right"));
const translator$23 = NodeTranslator.from(createMeasurementPropertyHandler("w:right", "marginRight"));
const translator$22 = NodeTranslator.from(createBorderPropertyHandler("w:top"));
const translator$21 = NodeTranslator.from(createMeasurementPropertyHandler("w:top", "marginTop"));
const propertyTranslators$f = [
  translator$2v,
  translator$2a,
  translator$29,
  translator$28,
  translator$26,
  translator$24,
  translator$22
];
const translator$20 = NodeTranslator.from(
  createNestedPropertiesTranslator("w:pBdr", "borders", propertyTranslators$f)
);
const translator$1$ = NodeTranslator.from(createSingleAttrPropertyHandler("w:pStyle", "styleId"));
const translator$1_ = NodeTranslator.from(createSingleBooleanPropertyHandler("w:pageBreakBefore"));
const translator$1Z = NodeTranslator.from({
  xmlName: "w:spacing",
  sdNodeOrKeyName: "spacing",
  attributes: [
    createIntegerAttributeHandler("w:after"),
    createBooleanAttributeHandler("w:afterAutospacing"),
    createIntegerAttributeHandler("w:afterLines"),
    createIntegerAttributeHandler("w:before"),
    createBooleanAttributeHandler("w:beforeAutospacing"),
    createIntegerAttributeHandler("w:beforeLines"),
    createIntegerAttributeHandler("w:line"),
    createAttributeHandler("w:lineRule")
  ],
  encode: (_2, encodedAttrs) => {
    return encodedAttrs;
  },
  decode: function({ node }) {
    const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs["spacing"] || {} } });
    return Object.keys(decodedAttrs).length > 0 ? { attributes: decodedAttrs } : void 0;
  }
});
const translator$1Y = NodeTranslator.from(createSingleBooleanPropertyHandler("w:suppressAutoHyphens"));
const translator$1X = NodeTranslator.from(createSingleBooleanPropertyHandler("w:suppressLineNumbers"));
const translator$1W = NodeTranslator.from(createSingleBooleanPropertyHandler("w:suppressOverlap"));
const propertyTranslators$e = [translator$2v, translator$37];
const translator$1V = NodeTranslator.from(
  createNestedArrayPropertyHandler("w:tabs", "tabStops", propertyTranslators$e, { skipRun: true })
);
const translator$1U = NodeTranslator.from(createSingleAttrPropertyHandler("w:textAlignment"));
const translator$1T = NodeTranslator.from(createSingleAttrPropertyHandler("w:textDirection"));
const translator$1S = NodeTranslator.from(createSingleAttrPropertyHandler("w:textboxTightWrap"));
const translator$1R = NodeTranslator.from(createSingleBooleanPropertyHandler("w:topLinePunct"));
const translator$1Q = NodeTranslator.from(createSingleBooleanPropertyHandler("w:widowControl"));
const translator$1P = NodeTranslator.from(createSingleBooleanPropertyHandler("w:wordWrap"));
const propertyTranslators$d = [
  translator$2v,
  translator$2u,
  translator$2t,
  translator$2s,
  translator$2r,
  translator$2q,
  translator$2p,
  translator$2o,
  translator$2n,
  translator$2m,
  translator$2l,
  translator$2k,
  translator$2j,
  translator$2i,
  translator$2h,
  translator$2d,
  translator$2c,
  translator$2b,
  translator$20,
  translator$1$,
  translator$1_,
  translator$2V,
  translator$2Q,
  translator$1Z,
  translator$1Y,
  translator$1X,
  translator$1W,
  translator$1V,
  translator$1U,
  translator$1T,
  translator$1S,
  translator$1R,
  translator$1Q,
  translator$1P,
  translator$2w
];
const translator$1O = NodeTranslator.from(
  createNestedPropertiesTranslator("w:pPr", "paragraphProperties", propertyTranslators$d)
);
function getTableStyleId(path) {
  const tbl = path.find((ancestor) => ancestor.name === "w:tbl");
  if (!tbl) {
    return;
  }
  const tblPr = tbl.elements?.find((child) => child.name === "w:tblPr");
  if (!tblPr) {
    return;
  }
  const tblStyle = tblPr.elements?.find((child) => child.name === "w:tblStyle");
  if (!tblStyle) {
    return;
  }
  return tblStyle.attributes?.["w:val"];
}
const handleParagraphNode$1 = (params) => {
  const { nodes, nodeListHandler, filename } = params;
  const node = carbonCopy(nodes[0]);
  let schemaNode;
  const pPr = node.elements?.find((el) => el.name === "w:pPr");
  let inlineParagraphProperties = {};
  if (pPr) {
    inlineParagraphProperties = translator$1O.encode({ ...params, nodes: [pPr] }) || {};
  }
  getTableStyleId(params.path || []);
  const resolvedParagraphProperties = resolveParagraphProperties(params, inlineParagraphProperties, {});
  const { elements = [], attributes = {}, marks = [] } = parseProperties(node, params.docx);
  const childContent = [];
  if (elements.length) {
    const updatedElements = elements.map((el) => {
      if (!el.marks) el.marks = [];
      el.marks.push(...marks);
      return el;
    });
    const childParams = {
      ...params,
      nodes: updatedElements,
      extraParams: { ...params.extraParams, paragraphProperties: resolvedParagraphProperties },
      path: [...params.path || [], node]
    };
    const translatedChildren = nodeListHandler.handler(childParams);
    childContent.push(...translatedChildren);
  }
  schemaNode = {
    type: "paragraph",
    content: childContent,
    attrs: { ...attributes },
    marks: []
  };
  schemaNode.type = "paragraph";
  schemaNode.attrs.paragraphProperties = inlineParagraphProperties;
  schemaNode.attrs.rsidRDefault = node.attributes?.["w:rsidRDefault"];
  schemaNode.attrs.filename = filename;
  if (schemaNode && schemaNode.content) {
    schemaNode = {
      ...schemaNode,
      content: mergeTextNodes(schemaNode.content)
    };
  }
  const sectPr = pPr?.elements?.find((el) => el.name === "w:sectPr");
  if (sectPr) {
    schemaNode.attrs.paragraphProperties.sectPr = sectPr;
    schemaNode.attrs.pageBreakSource = "sectPr";
  }
  return schemaNode;
};
function generateParagraphProperties(params) {
  const { node } = params;
  const { attrs = {} } = node;
  const paragraphProperties = carbonCopy(attrs.paragraphProperties || {});
  let pPr = translator$1O.decode({ node: { ...node, attrs: { paragraphProperties } } });
  const sectPr = node.attrs?.paragraphProperties?.sectPr;
  if (sectPr) {
    if (!pPr) {
      pPr = {
        type: "element",
        name: "w:pPr",
        elements: []
      };
    }
    pPr.elements.push(sectPr);
  }
  return pPr;
}
function mergeConsecutiveTrackedChanges(elements) {
  if (!Array.isArray(elements) || elements.length === 0) return elements;
  const result = [];
  let i = 0;
  while (i < elements.length) {
    const current = elements[i];
    if (current?.name === "w:ins" || current?.name === "w:del") {
      const tcId = current.attributes?.["w:id"];
      const tcName = current.name;
      const mergedElements = [...current.elements || []];
      let j2 = i + 1;
      while (j2 < elements.length) {
        const next = elements[j2];
        if (next?.name === "w:commentRangeStart" || next?.name === "w:commentRangeEnd") {
          mergedElements.push(next);
          j2++;
          continue;
        }
        if (next?.name === "w:r") {
          const hasOnlyCommentRef = next.elements?.length === 1 && next.elements[0]?.name === "w:commentReference";
          if (hasOnlyCommentRef) {
            mergedElements.push(next);
            j2++;
            continue;
          }
        }
        if (next?.name === tcName && next.attributes?.["w:id"] === tcId) {
          mergedElements.push(...next.elements || []);
          j2++;
          continue;
        }
        break;
      }
      result.push({
        name: tcName,
        attributes: { ...current.attributes },
        elements: mergedElements
      });
      i = j2;
    } else {
      result.push(current);
      i++;
    }
  }
  return result;
}
function translateParagraphNode(params) {
  let elements = translateChildNodes(params);
  elements = mergeConsecutiveTrackedChanges(elements);
  const htmlAnnotationChild = elements.find((element) => element.name === "htmlAnnotation");
  if (htmlAnnotationChild) {
    return htmlAnnotationChild.elements;
  }
  const pPr = generateParagraphProperties(params);
  if (pPr) elements.unshift(pPr);
  let attributes = {};
  if (params.node.attrs?.rsidRDefault) {
    attributes["w:rsidRDefault"] = params.node.attrs.rsidRDefault;
  }
  const result = {
    name: "w:p",
    elements,
    attributes
  };
  return result;
}
const encode$O = (attributes) => {
  return attributes["w:rsidDel"];
};
const decode$Q = (attrs) => {
  return attrs.rsidDel;
};
const attrConfig$q = Object.freeze({
  xmlName: "w:rsidDel",
  sdName: "rsidDel",
  encode: encode$O,
  decode: decode$Q
});
const encode$N = (attributes) => {
  return attributes["w:rsidP"];
};
const decode$P = (attrs) => {
  return attrs.rsidP;
};
const attrConfig$p = Object.freeze({
  xmlName: "w:rsidP",
  sdName: "rsidP",
  encode: encode$N,
  decode: decode$P
});
const encode$M = (attributes) => {
  return attributes["w:rsidR"];
};
const decode$O = (attrs) => {
  return attrs.rsidR;
};
const attrConfig$o = Object.freeze({
  xmlName: "w:rsidR",
  sdName: "rsidR",
  encode: encode$M,
  decode: decode$O
});
const encode$L = (attributes) => {
  return attributes["w:rsidRPr"];
};
const decode$N = (attrs) => {
  return attrs.rsidRPr;
};
const attrConfig$n = Object.freeze({
  xmlName: "w:rsidRPr",
  sdName: "rsidRPr",
  encode: encode$L,
  decode: decode$N
});
const encode$K = (attributes) => {
  return attributes["w:rsidRDefault"];
};
const decode$M = (attrs) => {
  return attrs.rsidRDefault;
};
const attrConfig$m = Object.freeze({
  xmlName: "w:rsidRDefault",
  sdName: "rsidRDefault",
  encode: encode$K,
  decode: decode$M
});
const encode$J = (attributes) => {
  return attributes["w14:paraId"];
};
const decode$L = (attrs) => {
  return attrs.paraId;
};
const attrConfig$l = Object.freeze({
  xmlName: "w14:paraId",
  sdName: "paraId",
  encode: encode$J,
  decode: decode$L
});
const encode$I = (attributes) => {
  return attributes["w14:textId"];
};
const decode$K = (attrs) => {
  return attrs.textId;
};
const attrConfig$k = Object.freeze({
  xmlName: "w14:textId",
  sdName: "textId",
  encode: encode$I,
  decode: decode$K
});
const validXmlAttributes$d = [
  attrConfig$l,
  attrConfig$k,
  attrConfig$o,
  attrConfig$m,
  attrConfig$p,
  attrConfig$n,
  attrConfig$q
];
const XML_NODE_NAME$p = "w:p";
const SD_NODE_NAME$m = "paragraph";
const encode$H = (params, encodedAttrs = {}) => {
  const node = handleParagraphNode$1(params);
  if (!node) return void 0;
  if (encodedAttrs && Object.keys(encodedAttrs).length) {
    node.attrs = { ...node.attrs, ...encodedAttrs };
  }
  return node;
};
const decode$J = (params, decodedAttrs = {}) => {
  const translated = translateParagraphNode(params);
  if (!translated) return void 0;
  if (decodedAttrs && Object.keys(decodedAttrs).length) {
    translated.attributes = { ...translated.attributes || {}, ...decodedAttrs };
  }
  return translated;
};
const config$o = {
  xmlName: XML_NODE_NAME$p,
  sdNodeOrKeyName: SD_NODE_NAME$m,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$H,
  decode: decode$J,
  attributes: validXmlAttributes$d
};
const translator$1N = NodeTranslator.from(config$o);
const EAST_ASIAN_CHARACTER_REGEX = /[\u1100-\u11FF\u2E80-\u2EFF\u2F00-\u2FDF\u3040-\u30FF\u3100-\u312F\u3130-\u318F\u31A0-\u31BF\u3400-\u4DBF\u4E00-\u9FFF\uA960-\uA97F\uAC00-\uD7AF\uF900-\uFAFF\uFF00-\uFFEF]/u;
const containsEastAsianCharacters = (text) => EAST_ASIAN_CHARACTER_REGEX.test(text);
const resolveFontFamily = (textStyleAttrs, text) => {
  if (!text) return textStyleAttrs;
  const eastAsiaFont = textStyleAttrs?.eastAsiaFontFamily;
  if (!eastAsiaFont) return textStyleAttrs;
  const normalized = { ...textStyleAttrs };
  delete normalized.eastAsiaFontFamily;
  const shouldUseEastAsia = typeof text === "string" && containsEastAsianCharacters(text);
  if (!shouldUseEastAsia) return normalized;
  return { ...normalized, fontFamily: eastAsiaFont };
};
const cloneMark$1 = (mark) => {
  if (!mark || typeof mark !== "object") return mark;
  const cloned = { ...mark };
  if (mark.attrs && typeof mark.attrs === "object") {
    cloned.attrs = { ...mark.attrs };
    if (Array.isArray(mark.attrs.runProperties)) {
      cloned.attrs.runProperties = mark.attrs.runProperties.map((entry) => ({
        xmlName: entry?.xmlName,
        attributes: { ...entry?.attributes || {} }
      }));
    }
  }
  return cloned;
};
const cloneXmlNode = (nodeLike) => {
  if (!nodeLike || typeof nodeLike !== "object") return nodeLike;
  return {
    name: nodeLike.name,
    type: nodeLike.type,
    attributes: nodeLike.attributes ? { ...nodeLike.attributes } : void 0,
    elements: Array.isArray(nodeLike.elements) ? nodeLike.elements.map((el) => cloneXmlNode(el)) : void 0,
    text: nodeLike.text
  };
};
const applyRunPropertiesTemplate = (runNode, runPropertiesTemplate) => {
  if (!runNode || !runPropertiesTemplate) return;
  if (!Array.isArray(runNode.elements)) runNode.elements = [];
  let runProps = runNode.elements.find((el) => el?.name === "w:rPr");
  if (!runProps) {
    runProps = { name: "w:rPr", elements: [] };
    runNode.elements.unshift(runProps);
  }
  if (!Array.isArray(runProps.elements)) runProps.elements = [];
  if (runPropertiesTemplate.attributes) {
    runProps.attributes = {
      ...runProps.attributes || {},
      ...runPropertiesTemplate.attributes
    };
  }
  const isValidRunPropName = (name) => typeof name === "string" && name.includes(":");
  runProps.elements = runProps.elements.filter((entry) => isValidRunPropName(entry?.name));
  const existingNames = new Set(runProps.elements.map((el) => el?.name));
  (runPropertiesTemplate.elements || []).forEach((entry) => {
    if (!isValidRunPropName(entry?.name) || existingNames.has(entry.name)) return;
    runProps.elements.push(cloneXmlNode(entry));
    existingNames.add(entry.name);
  });
};
const cloneMark = (mark) => {
  if (!mark) return mark;
  return {
    ...mark,
    attrs: mark.attrs ? { ...mark.attrs } : void 0
  };
};
const cloneNode = (node) => {
  if (!node || typeof node !== "object") return node;
  const cloned = { ...node };
  if (node.marks) cloned.marks = node.marks.map((mark) => cloneMark(mark));
  if (node.content) cloned.content = node.content.map((child) => cloneNode(child));
  if (node.elements) cloned.elements = node.elements.map((el) => cloneNode(el));
  if (node.attributes) cloned.attributes = { ...node.attributes };
  return cloned;
};
const cloneRuns = (runs = []) => runs.map((run2) => cloneNode(run2));
const prepareRunTrackingContext = (node = {}) => {
  const marks = Array.isArray(node.marks) ? node.marks : [];
  const trackingMarks = marks.filter(
    (mark) => mark?.type === TrackInsertMarkName || mark?.type === TrackDeleteMarkName
  );
  if (!trackingMarks.length) {
    return { runNode: node, trackingMarksByType: /* @__PURE__ */ new Map() };
  }
  const trackingMarksByType = /* @__PURE__ */ new Map();
  trackingMarks.forEach((mark) => {
    if (mark?.type) trackingMarksByType.set(mark.type, cloneMark(mark));
  });
  const preservedMarks = marks.filter((mark) => mark?.type !== TrackInsertMarkName && mark?.type !== TrackDeleteMarkName).map((mark) => cloneMark(mark));
  const clonedContent = Array.isArray(node.content) ? node.content.map((child) => {
    const childClone = cloneNode(child);
    const childMarks = Array.isArray(childClone.marks) ? childClone.marks.slice() : [];
    trackingMarks.forEach((mark) => {
      childMarks.push(cloneMark(mark));
    });
    childClone.marks = childMarks;
    return childClone;
  }) : [];
  return {
    runNode: {
      ...cloneNode(node),
      marks: preservedMarks,
      content: clonedContent
    },
    trackingMarksByType
  };
};
const mapTrackingAttrs = (mark, attrMap) => {
  const source = mark?.attrs || {};
  const mapped = {};
  attrMap.forEach((targetKey, sourceKey) => {
    if (source[sourceKey] != null) mapped[targetKey] = source[sourceKey];
  });
  return mapped;
};
const renameTextElementsForDeletion = (node) => {
  if (!node || typeof node !== "object") return;
  if (node.name === "w:t") node.name = "w:delText";
  if (Array.isArray(node.elements)) node.elements.forEach(renameTextElementsForDeletion);
};
const ensureTrackedWrapper = (runs, trackingMarksByType = /* @__PURE__ */ new Map()) => {
  if (!Array.isArray(runs) || !runs.length) return runs;
  const firstRun = runs[0];
  if (firstRun?.name === "w:ins" || firstRun?.name === "w:del") {
    return runs;
  }
  if (!trackingMarksByType.size) return runs;
  if (trackingMarksByType.has(TrackInsertMarkName)) {
    const mark = trackingMarksByType.get(TrackInsertMarkName);
    const clonedRuns = cloneRuns(runs);
    const wrapper = {
      name: "w:ins",
      attributes: mapTrackingAttrs(
        mark,
        /* @__PURE__ */ new Map([
          ["id", "w:id"],
          ["author", "w:author"],
          ["authorEmail", "w:authorEmail"],
          ["date", "w:date"]
        ])
      ),
      elements: clonedRuns
    };
    return [wrapper];
  }
  if (trackingMarksByType.has(TrackDeleteMarkName)) {
    const mark = trackingMarksByType.get(TrackDeleteMarkName);
    const clonedRuns = cloneRuns(runs);
    clonedRuns.forEach(renameTextElementsForDeletion);
    const wrapper = {
      name: "w:del",
      attributes: mapTrackingAttrs(mark, /* @__PURE__ */ new Map([["id", "w:id"]])),
      elements: clonedRuns
    };
    return [wrapper];
  }
  return runs;
};
function generateDocxRandomId(length = 8) {
  const max2 = 2147483647;
  const value = Math.floor(Math.random() * (max2 + 1));
  return value.toString(16).padStart(length, "0").slice(0, length);
}
function generateRandomSigned32BitIntStrId() {
  const val = Math.floor(Math.random() * 2147483647);
  return val.toString();
}
function generateRandom32BitHex() {
  const val = Math.floor(Math.random() * 2147483647);
  return val.toString(16).toUpperCase().padStart(8, "0");
}
const XML_NODE_NAME$o = "w:hyperlink";
const SD_NODE_NAME$l = "link";
const _createAttributeHandler = (xmlName, sdName) => ({
  xmlName,
  sdName,
  encode: (attributes) => attributes[xmlName],
  decode: (attributes) => attributes[sdName]
});
const validXmlAttributes$c = [
  _createAttributeHandler("w:anchor", "anchor"),
  _createAttributeHandler("w:docLocation", "docLocation"),
  {
    xmlName: "w:history",
    sdName: "history",
    encode: (attributes) => attributes["w:history"] == null ? null : attributes["w:history"] === "1" || attributes["w:history"] === "true",
    decode: (attributes) => attributes["history"] == null ? null : attributes["history"] ? "1" : "0"
  },
  _createAttributeHandler("w:tooltip", "tooltip"),
  _createAttributeHandler("r:id", "rId"),
  _createAttributeHandler("w:tgtFrame", "target")
];
const encode$G = (params, encodedAttrs) => {
  const { nodes, docx, nodeListHandler } = params;
  const node = nodes[0];
  let href = _resolveHref(docx, encodedAttrs, params.filename);
  const linkMark = { type: "link", attrs: { ...encodedAttrs, href } };
  const referenceNodeTypes = ["sd:pageReference", "sd:autoPageNumber", "sd:totalPageNumber"];
  const contentNodes = node.elements.filter((el) => el.name === "w:r" || referenceNodeTypes.includes(el.name));
  contentNodes.forEach((contentNode) => {
    const existingMarks = Array.isArray(contentNode.marks) ? contentNode.marks : [];
    const marksWithoutLink = existingMarks.filter((mark) => mark?.type !== "link");
    contentNode.marks = [...marksWithoutLink, linkMark];
  });
  const updatedNode = nodeListHandler.handler({
    ...params,
    nodes: contentNodes,
    path: [...params.path || [], node]
  });
  return updatedNode;
};
const _resolveHref = (docx, encodedAttrs, filename) => {
  const currentFile = filename || "document.xml";
  let rels = docx?.[`word/_rels/${currentFile}.rels`];
  if (!rels) rels = docx?.["word/_rels/document.xml.rels"];
  const relationships = rels?.elements?.find((el) => el.name === "Relationships");
  const elements = relationships?.elements || [];
  const { rId, anchor } = encodedAttrs;
  let href;
  if (!rId && anchor) {
    href = `#${anchor}`;
  } else if (rId) {
    const rel = elements.find((el) => el.attributes?.["Id"] === rId) || {};
    const { attributes: relAttributes = {} } = rel;
    href = relAttributes["Target"];
  }
  return href;
};
function decode$I(params) {
  const { hyperlinkGroup = [params.node] } = params.extraParams || {};
  const node = hyperlinkGroup[0];
  const linkMark = node.marks.find((m2) => m2.type === "link");
  const linkAttrs = this.decodeAttributes({ ...params, node: linkMark });
  let { href: link, anchor } = linkMark.attrs;
  if (!linkAttrs["r:id"] && !anchor) {
    linkAttrs["r:id"] = _addNewLinkRelationship(params, link);
  }
  let contentNodes = [];
  hyperlinkGroup.forEach((linkNode) => {
    if ("marks" in linkNode) {
      linkNode.marks = linkNode.marks.filter((m2) => m2.type !== "link");
    } else {
      linkNode.attrs.marksAsAttrs = linkNode.attrs.marksAsAttrs.filter((m2) => m2.type !== "link");
    }
    const outputNode = exportSchemaToJson({ ...params, node: linkNode });
    if (outputNode) {
      if (outputNode instanceof Array) contentNodes.push(...outputNode);
      else contentNodes.push(outputNode);
    }
  });
  const newNode = {
    name: "w:hyperlink",
    type: "element",
    attributes: {
      ...linkAttrs
    },
    elements: contentNodes
  };
  return newNode;
}
function _addNewLinkRelationship(params, link) {
  let id = generateDocxRandomId();
  if (!params.relationships || !Array.isArray(params.relationships)) {
    params.relationships = [];
  }
  params.relationships.push({
    type: "element",
    name: "Relationship",
    attributes: {
      Id: `rId${id}`,
      Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
      Target: link,
      TargetMode: "External"
    }
  });
  return `rId${id}`;
}
const config$n = {
  xmlName: XML_NODE_NAME$o,
  sdNodeOrKeyName: SD_NODE_NAME$l,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$G,
  decode: decode$I,
  attributes: validXmlAttributes$c
};
const translator$1M = NodeTranslator.from(config$n);
const encode$F = (attributes) => {
  return attributes["w:rsidR"];
};
const decode$H = (attrs) => {
  return attrs.rsidR;
};
const attrConfig$j = Object.freeze({
  xmlName: "w:rsidR",
  sdName: "rsidR",
  encode: encode$F,
  decode: decode$H
});
const encode$E = (attributes) => {
  return attributes["w:rsidRPr"];
};
const decode$G = (attrs) => {
  return attrs.rsidRPr;
};
const attrConfig$i = Object.freeze({
  xmlName: "w:rsidRPr",
  sdName: "rsidRPr",
  encode: encode$E,
  decode: decode$G
});
const encode$D = (attributes) => {
  return attributes["w:rsidDel"];
};
const decode$F = (attrs) => {
  return attrs.rsidDel;
};
const attrConfig$h = Object.freeze({
  xmlName: "w:rsidDel",
  sdName: "rsidDel",
  encode: encode$D,
  decode: decode$F
});
const validXmlAttributes$b = [attrConfig$j, attrConfig$i, attrConfig$h];
const XML_NODE_NAME$n = "w:r";
const SD_KEY_NAME = "run";
const createRunNodeWithContent = (content, encodedAttrs, runLevelMarks, runProperties) => {
  const node = {
    type: SD_KEY_NAME,
    content,
    attrs: { ...encodedAttrs, runProperties }
  };
  if (runLevelMarks.length) {
    node.marks = runLevelMarks.map((mark) => cloneMark$1(mark));
  }
  return node;
};
const encode$C = (params, encodedAttrs = {}) => {
  const { nodes = [], nodeListHandler } = params || {};
  const runNode = nodes[0];
  if (!runNode) return void 0;
  const elements = Array.isArray(runNode.elements) ? runNode.elements : [];
  const rPrNode = elements.find((child) => child?.name === "w:rPr");
  const runProperties = rPrNode ? translator$2w.encode({ ...params, nodes: [rPrNode] }) : {};
  const paragraphProperties = params?.extraParams?.paragraphProperties || {};
  const resolvedRunProperties = resolveRunProperties(params, runProperties ?? {}, paragraphProperties);
  const marksResult = encodeMarksFromRPr(resolvedRunProperties, params?.docx);
  const marks = Array.isArray(marksResult) ? marksResult : [];
  const rPrChange = rPrNode?.elements?.find((el) => el.name === "w:rPrChange");
  const styleChangeMarks = handleStyleChangeMarksV2(rPrChange, marks, params) || [];
  let runLevelMarks = Array.isArray(runNode.marks) ? runNode.marks.map((mark) => cloneMark$1(mark)) : [];
  if (styleChangeMarks?.length) {
    runLevelMarks = [...runLevelMarks, ...styleChangeMarks.map((mark) => cloneMark$1(mark))];
  }
  const contentElements = rPrNode ? elements.filter((el) => el !== rPrNode) : elements;
  const childParams = { ...params, nodes: contentElements };
  const content = nodeListHandler?.handler(childParams) || [];
  const contentWithRunMarks = (Array.isArray(content) ? content : []).map((child) => {
    if (!child || typeof child !== "object") return child;
    if (child.type === "passthroughInline") {
      return { ...child, marks: [] };
    }
    const baseMarks = Array.isArray(child.marks) ? child.marks : [];
    let childMarks = [...marks, ...baseMarks, ...runLevelMarks].map((mark) => cloneMark$1(mark));
    const seenTypes = /* @__PURE__ */ new Set();
    let textStyleMark;
    childMarks = childMarks.filter((mark) => {
      if (!mark || !mark.type) return false;
      if (seenTypes.has(mark.type)) {
        if (mark.type === "textStyle") {
          textStyleMark.attrs = { ...textStyleMark.attrs || {}, ...mark.attrs || {} };
          textStyleMark.attrs = resolveFontFamily(textStyleMark.attrs, child?.text);
        }
        return false;
      }
      if (mark.type === "textStyle") {
        textStyleMark = mark;
      }
      seenTypes.add(mark.type);
      return true;
    });
    return { ...child, marks: childMarks };
  });
  const filtered = contentWithRunMarks.filter(Boolean);
  const containsBreakNodes = filtered.some((child) => child?.type === "lineBreak");
  if (!containsBreakNodes) {
    const defaultNode = createRunNodeWithContent(filtered, encodedAttrs, runLevelMarks, runProperties);
    return defaultNode;
  }
  const splitRuns = [];
  let currentChunk = [];
  const finalizeTextChunk = () => {
    if (!currentChunk.length) return;
    const chunkNode = createRunNodeWithContent(currentChunk, encodedAttrs, runLevelMarks, runProperties);
    if (chunkNode) splitRuns.push(chunkNode);
    currentChunk = [];
  };
  filtered.forEach((child) => {
    if (child?.type === "lineBreak") {
      finalizeTextChunk();
      const breakNode = createRunNodeWithContent([child], encodedAttrs, runLevelMarks, runProperties);
      if (breakNode) splitRuns.push(breakNode);
    } else {
      currentChunk.push(child);
    }
  });
  finalizeTextChunk();
  return splitRuns;
};
const decode$E = (params, decodedAttrs = {}) => {
  const { node } = params || {};
  if (!node) return void 0;
  const isLinkNode = node.marks?.some((m2) => m2.type === "link");
  if (isLinkNode) {
    const extraParams = {
      ...params.extraParams,
      linkProcessed: true
    };
    return translator$1M.decode({ ...params, extraParams });
  }
  const { runNode: runNodeForExport, trackingMarksByType } = prepareRunTrackingContext(node);
  const runAttrs = runNodeForExport.attrs || {};
  const runProperties = runAttrs.runProperties || {};
  const exportParams = {
    ...params,
    node: runNodeForExport,
    extraParams: { ...params?.extraParams, runProperties }
  };
  if (!exportParams.editor) {
    exportParams.editor = { extensionService: { extensions: [] } };
  }
  const childElements = translateChildNodes(exportParams) || [];
  let runPropertiesElement = translator$2w.decode({
    ...params,
    node: { attrs: { runProperties } }
  });
  const runPropsTemplate = runPropertiesElement ? cloneXmlNode(runPropertiesElement) : null;
  const applyBaseRunProps = (runNode) => applyRunPropertiesTemplate(runNode, runPropsTemplate);
  const replaceRunProps = (runNode) => {
    if (Array.isArray(runNode.elements)) {
      runNode.elements = runNode.elements.filter((el) => el?.name !== "w:rPr");
    } else {
      runNode.elements = [];
    }
    if (runPropsTemplate) {
      runNode.elements.unshift(cloneXmlNode(runPropsTemplate));
    }
  };
  const runs = [];
  childElements.forEach((child) => {
    if (!child) return;
    if (child.name === "w:r") {
      const clonedRun = cloneXmlNode(child);
      replaceRunProps(clonedRun);
      runs.push(clonedRun);
      return;
    }
    if (child.name === "w:hyperlink") {
      const hyperlinkClone = cloneXmlNode(child);
      if (Array.isArray(hyperlinkClone.elements)) {
        hyperlinkClone.elements.forEach((run2) => applyBaseRunProps(run2));
      }
      runs.push(hyperlinkClone);
      return;
    }
    if (child.name === "w:ins" || child.name === "w:del") {
      const trackedClone = cloneXmlNode(child);
      if (Array.isArray(trackedClone.elements)) {
        trackedClone.elements.forEach((element) => {
          if (element?.name === "w:r") replaceRunProps(element);
        });
      }
      runs.push(trackedClone);
      return;
    }
    if (child.name === "w:commentRangeStart" || child.name === "w:commentRangeEnd") {
      const commentRangeClone = cloneXmlNode(child);
      runs.push(commentRangeClone);
      return;
    }
    const runWrapper = { name: XML_NODE_NAME$n, elements: [] };
    applyBaseRunProps(runWrapper);
    if (!Array.isArray(runWrapper.elements)) runWrapper.elements = [];
    runWrapper.elements.push(cloneXmlNode(child));
    runs.push(runWrapper);
  });
  const trackedRuns = ensureTrackedWrapper(runs, trackingMarksByType);
  if (!trackedRuns.length) {
    const emptyRun = { name: XML_NODE_NAME$n, elements: [] };
    applyBaseRunProps(emptyRun);
    trackedRuns.push(emptyRun);
  }
  if (decodedAttrs && Object.keys(decodedAttrs).length) {
    trackedRuns.forEach((run2) => {
      run2.attributes = { ...run2.attributes || {}, ...decodedAttrs };
    });
  }
  if (trackedRuns.length === 1) {
    return trackedRuns[0];
  }
  return trackedRuns;
};
const config$m = {
  xmlName: XML_NODE_NAME$n,
  sdNodeOrKeyName: SD_KEY_NAME,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$C,
  decode: decode$E,
  attributes: validXmlAttributes$b
};
const translator$1L = NodeTranslator.from(config$m);
const translator$1K = NodeTranslator.from(createMeasurementPropertyHandler("w:tcW", "cellWidth"));
const translator$1J = NodeTranslator.from(
  createSingleAttrPropertyHandler(
    "w:gridSpan",
    null,
    "w:val",
    (v2) => parseInteger(v2) ?? void 0,
    (v2) => integerToString(v2)
  )
);
const translator$1I = NodeTranslator.from(
  createSingleAttrPropertyHandler("w:vMerge", null, "w:val", (val) => !val ? "continue" : val)
);
const translator$1H = NodeTranslator.from(createBorderPropertyHandler("w:end"));
const translator$1G = NodeTranslator.from(createMeasurementPropertyHandler("w:end", "marginEnd"));
const translator$1F = NodeTranslator.from(createBorderPropertyHandler("w:insideH"));
const translator$1E = NodeTranslator.from(createBorderPropertyHandler("w:insideV"));
const translator$1D = NodeTranslator.from(createBorderPropertyHandler("w:start"));
const translator$1C = NodeTranslator.from(createMeasurementPropertyHandler("w:start", "marginStart"));
const translator$1B = NodeTranslator.from(createSingleIntegerPropertyHandler("w:start"));
const translator$1A = NodeTranslator.from(createBorderPropertyHandler("w:tl2br"));
const translator$1z = NodeTranslator.from(createBorderPropertyHandler("w:tr2bl"));
const propertyTranslators$c = [
  translator$22,
  translator$1D,
  translator$26,
  translator$28,
  translator$1H,
  translator$24,
  translator$1F,
  translator$1E,
  translator$1A,
  translator$1z
];
const translator$1y = NodeTranslator.from(
  createNestedPropertiesTranslator("w:tcBorders", "borders", propertyTranslators$c)
);
const translator$1x = NodeTranslator.from(
  createSingleAttrPropertyHandler(
    "w:noWrap",
    null,
    "w:val",
    (v2) => parseBoolean(v2 ?? "true"),
    (v2) => booleanToString(v2)
  )
);
const propertyTranslators$b = [
  translator$27,
  translator$1G,
  translator$25,
  translator$23,
  translator$1C,
  translator$21
];
const translator$1w = NodeTranslator.from(
  createNestedPropertiesTranslator("w:tcMar", "cellMargins", propertyTranslators$b)
);
const translator$1v = NodeTranslator.from(
  createSingleAttrPropertyHandler(
    "w:tcFitText",
    null,
    "w:val",
    (v2) => parseBoolean(v2 ?? "true"),
    (v2) => booleanToString(v2)
  )
);
const translator$1u = NodeTranslator.from(createSingleAttrPropertyHandler("w:vAlign"));
const translator$1t = NodeTranslator.from(
  createSingleAttrPropertyHandler(
    "w:hideMark",
    null,
    "w:val",
    (v2) => parseBoolean(v2 ?? "true"),
    (v2) => booleanToString(v2)
  )
);
const translator$1s = NodeTranslator.from(createSingleAttrPropertyHandler("w:header"));
const translator$1r = NodeTranslator.from(
  createNestedArrayPropertyHandler("w:headers", "headers", [translator$1s])
);
const propertyTranslators$a = [
  translator$2q,
  translator$1K,
  translator$1J,
  translator$1I,
  translator$1y,
  translator$2V,
  translator$1x,
  translator$1w,
  translator$1T,
  translator$1v,
  translator$1u,
  translator$1t,
  translator$1r
];
const translator$1q = NodeTranslator.from(
  createNestedPropertiesTranslator("w:tcPr", "tableCellProperties", propertyTranslators$a)
);
function handleTableCellNode({
  params,
  node,
  table,
  row,
  tableProperties,
  rowBorders,
  baseTableBorders,
  tableLook,
  rowCnfStyle,
  columnIndex,
  columnWidth = null,
  allColumnWidths = [],
  rowIndex = 0,
  totalRows = 1,
  totalColumns,
  preferTableGridWidths = false,
  _referencedStyles
}) {
  const { nodeListHandler } = params;
  const attributes = {};
  const referencedStyles = _referencedStyles ?? { fontSize: null, fonts: {}, cellMargins: {} };
  const tcPr = node.elements.find((el) => el.name === "w:tcPr");
  const tableCellProperties = tcPr ? translator$1q.encode({ ...params, nodes: [tcPr] }) ?? {} : {};
  attributes["tableCellProperties"] = tableCellProperties;
  const effectiveTotalColumns = totalColumns ?? (allColumnWidths.length || 1);
  const effectiveTotalRows = totalRows ?? (table?.elements?.filter((el) => el.name === "w:tr").length || 1);
  const colspan = parseInt(tableCellProperties.gridSpan || 1, 10);
  const isFirstRow = rowIndex === 0;
  const isLastRow = rowIndex === effectiveTotalRows - 1;
  const isFirstColumn = columnIndex === 0;
  const isLastColumn = columnIndex + colspan >= effectiveTotalColumns;
  attributes["borders"] = processCellBorders({
    baseTableBorders,
    rowBorders,
    tableLook,
    rowCnfStyle,
    isFirstRow,
    isLastRow,
    isFirstColumn,
    isLastColumn,
    tableCellProperties,
    referencedStyles
  });
  if (colspan > 1) attributes["colspan"] = colspan;
  let width = null;
  if (!preferTableGridWidths) {
    width = tableCellProperties.cellWidth?.value ? twipsToPixels(tableCellProperties.cellWidth?.value) : null;
  }
  const widthType = tableCellProperties.cellWidth?.type;
  if (widthType) attributes["widthType"] = widthType;
  if (!width && columnWidth) width = columnWidth;
  if (width) {
    attributes["colwidth"] = [width];
    attributes["widthUnit"] = "px";
    const defaultColWidths = allColumnWidths;
    const hasDefaultColWidths = allColumnWidths && allColumnWidths.length > 0;
    if (colspan > 1 && hasDefaultColWidths) {
      let colwidth = [];
      for (let i = 0; i < colspan; i++) {
        let colwidthValue = defaultColWidths[columnIndex + i];
        let defaultColwidth = 100;
        if (typeof colwidthValue !== "undefined") {
          colwidth.push(colwidthValue);
        } else {
          colwidth.push(defaultColwidth);
        }
      }
      if (colwidth.length) {
        attributes["colwidth"] = [...colwidth];
      }
    }
  }
  const backgroundColor = resolveShadingFillColor(tableCellProperties.shading) ?? resolveShadingFillColor(tableProperties?.shading);
  const background = { color: backgroundColor };
  if (background.color) attributes["background"] = background;
  const verticalAlign = tableCellProperties.vAlign;
  if (verticalAlign) attributes["verticalAlign"] = verticalAlign;
  attributes.cellMargins = getTableCellMargins(tableCellProperties.cellMargins, referencedStyles);
  const { fontSize, fonts = {} } = referencedStyles;
  const fontFamily = fonts["ascii"];
  if (fontSize) attributes["fontSize"] = fontSize;
  if (fontFamily) attributes["fontFamily"] = fontFamily;
  if (tableCellProperties.vMerge === "restart") {
    const rows = table.elements.filter((el) => el.name === "w:tr");
    const currentRowIndex = rows.findIndex((r) => r === row);
    const remainingRows = rows.slice(currentRowIndex + 1);
    const cellsInRow = row.elements.filter((el) => el.name === "w:tc");
    let cellIndex = cellsInRow.findIndex((el) => el === node);
    let rowspan = 1;
    for (let remainingRow of remainingRows) {
      const firstCell = remainingRow.elements.findIndex((el) => el.name === "w:tc");
      const cellAtIndex = remainingRow.elements[firstCell + cellIndex];
      if (!cellAtIndex) break;
      const vMerge = getTableCellVMerge(cellAtIndex);
      if (!vMerge || vMerge === "restart") {
        break;
      }
      rowspan++;
      remainingRow.elements.splice(firstCell + cellIndex, 1);
    }
    attributes["rowspan"] = rowspan;
  }
  return {
    type: "tableCell",
    content: normalizeTableCellContent(
      nodeListHandler.handler({
        ...params,
        nodes: node.elements,
        path: [...params.path || [], node]
      }),
      params.editor
    ),
    attrs: attributes
  };
}
function normalizeTableCellContent(content, editor) {
  if (!Array.isArray(content) || content.length === 0) return content;
  const normalized = [];
  const pendingForNextBlock = [];
  const schema = editor?.schema;
  const cloneBlock = (node) => {
    if (!node) return node;
    const cloned = { ...node };
    if (Array.isArray(node.content)) {
      cloned.content = [...node.content];
    }
    return cloned;
  };
  const ensureArray = (node) => {
    if (!Array.isArray(node.content)) {
      node.content = [];
    }
    return node.content;
  };
  const isInlineNode = (node) => {
    if (!node || typeof node.type !== "string") return false;
    if (node.type === "text") return true;
    if (node.type === "bookmarkStart" || node.type === "bookmarkEnd") return true;
    const nodeType = schema?.nodes?.[node.type];
    if (nodeType) {
      if (typeof nodeType.isInline === "boolean") return nodeType.isInline;
      if (nodeType.spec?.group && typeof nodeType.spec.group === "string") {
        return nodeType.spec.group.split(" ").includes("inline");
      }
    }
    return false;
  };
  for (const node of content) {
    if (!node || typeof node.type !== "string") {
      normalized.push(node);
      continue;
    }
    if (!isInlineNode(node)) {
      const blockNode = cloneBlock(node);
      if (pendingForNextBlock.length) {
        const blockContent = ensureArray(blockNode);
        const leadingInline = pendingForNextBlock.splice(0);
        blockNode.content = [...leadingInline, ...blockContent];
      } else if (Array.isArray(blockNode.content)) {
        blockNode.content = [...blockNode.content];
      }
      normalized.push(blockNode);
      continue;
    }
    const targetIsNextBlock = node.type === "bookmarkStart" || normalized.length === 0;
    if (targetIsNextBlock) {
      pendingForNextBlock.push(node);
    } else {
      const lastIndex = normalized.length - 1;
      const lastNode = normalized[lastIndex];
      if (!lastNode || typeof lastNode.type !== "string" || isInlineNode(lastNode)) {
        pendingForNextBlock.push(node);
        continue;
      }
      const blockContent = ensureArray(lastNode);
      if (pendingForNextBlock.length) {
        blockContent.push(...pendingForNextBlock.splice(0));
      }
      blockContent.push(node);
    }
  }
  if (pendingForNextBlock.length) {
    if (normalized.length) {
      const lastIndex = normalized.length - 1;
      const lastNode = normalized[lastIndex];
      if (lastNode && typeof lastNode.type === "string" && !isInlineNode(lastNode)) {
        const blockContent = ensureArray(lastNode);
        blockContent.push(...pendingForNextBlock);
        pendingForNextBlock.length = 0;
      }
    }
    if (pendingForNextBlock.length) {
      normalized.push({
        type: "paragraph",
        attrs: {},
        content: [...pendingForNextBlock]
      });
      pendingForNextBlock.length = 0;
    }
  }
  return normalized;
}
const processInlineCellBorders = (borders, rowBorders) => {
  if (!borders) return null;
  return ["bottom", "top", "left", "right"].reduce((acc, direction) => {
    const borderAttrs = borders[direction];
    const rowBorderAttrs = rowBorders[direction];
    if (borderAttrs && borderAttrs["val"] !== "none") {
      const color = borderAttrs["color"];
      let size = borderAttrs["size"];
      if (size) size = eighthPointsToPixels(size);
      acc[direction] = { color, size, val: borderAttrs["val"] };
      return acc;
    }
    if (borderAttrs && borderAttrs["val"] === "none") {
      const border = Object.assign({}, rowBorderAttrs || {});
      border["val"] = "none";
      acc[direction] = border;
      return acc;
    }
    return acc;
  }, {});
};
const processCellBorders = ({
  baseTableBorders,
  rowBorders,
  tableLook,
  rowCnfStyle,
  isFirstRow,
  isLastRow,
  isFirstColumn,
  isLastColumn,
  tableCellProperties,
  referencedStyles
}) => {
  let cellBorders = {};
  if (baseTableBorders) {
    if (isFirstRow && baseTableBorders.top) {
      cellBorders.top = baseTableBorders.top;
    }
    if (isLastRow && baseTableBorders.bottom) {
      cellBorders.bottom = baseTableBorders.bottom;
    }
    if (isFirstColumn && baseTableBorders.left) {
      cellBorders.left = baseTableBorders.left;
    }
    if (isLastColumn && baseTableBorders.right) {
      cellBorders.right = baseTableBorders.right;
    }
  }
  if (rowBorders) {
    if (rowBorders.top?.val) {
      cellBorders.top = rowBorders.top;
    }
    if (rowBorders.bottom?.val) {
      cellBorders.bottom = rowBorders.bottom;
    }
    if (rowBorders.left?.val) {
      const applyLeftToAll = rowBorders.left.val === "none";
      if (applyLeftToAll || isFirstColumn) {
        cellBorders.left = rowBorders.left;
      }
    }
    if (rowBorders.right?.val) {
      const applyRightToAll = rowBorders.right.val === "none";
      if (applyRightToAll || isLastColumn) {
        cellBorders.right = rowBorders.right;
      }
    }
    if (!isLastRow && rowBorders.insideH) {
      cellBorders.bottom = rowBorders.insideH;
    }
    if (!isLastColumn && rowBorders.insideV) {
      cellBorders.right = rowBorders.insideV;
    }
  }
  const getStyleTableCellBorders = (styleVariant) => styleVariant?.tableCellProperties?.borders ?? null;
  const cellCnfStyle = tableCellProperties?.cnfStyle;
  const getFlag = (source, flag) => source && Object.prototype.hasOwnProperty.call(source, flag) ? source[flag] : void 0;
  const isStyleEnabled = (flag) => getFlag(cellCnfStyle, flag) ?? getFlag(rowCnfStyle, flag) ?? getFlag(tableLook, flag) ?? true;
  const applyStyleBorders = (styleVariant, allowedDirections) => {
    const styleBorders = getStyleTableCellBorders(styleVariant);
    if (!styleBorders) return;
    const filteredBorders = allowedDirections.reduce((acc, direction) => {
      if (styleBorders[direction]) acc[direction] = styleBorders[direction];
      return acc;
    }, {});
    const styleOverrides = processInlineCellBorders(filteredBorders, cellBorders);
    if (styleOverrides) cellBorders = Object.assign(cellBorders, styleOverrides);
  };
  if (isFirstRow && isStyleEnabled("firstRow")) applyStyleBorders(referencedStyles?.firstRow, ["top", "bottom"]);
  if (isLastRow && isStyleEnabled("lastRow")) applyStyleBorders(referencedStyles?.lastRow, ["top", "bottom"]);
  if (isFirstColumn && isStyleEnabled("firstColumn")) applyStyleBorders(referencedStyles?.firstCol, ["left", "right"]);
  if (isLastColumn && isStyleEnabled("lastColumn")) applyStyleBorders(referencedStyles?.lastCol, ["left", "right"]);
  const inlineBorders = processInlineCellBorders(tableCellProperties.borders, cellBorders);
  if (inlineBorders) cellBorders = Object.assign(cellBorders, inlineBorders);
  return cellBorders;
};
const getTableCellVMerge = (node) => {
  const tcPr = node.elements.find((el) => el.name === "w:tcPr");
  const vMerge = tcPr?.elements?.find((el) => el.name === "w:vMerge");
  if (!vMerge) return null;
  return vMerge.attributes?.["w:val"] || "continue";
};
const getTableCellMargins = (inlineMargins, referencedStyles) => {
  const { cellMargins = {} } = referencedStyles;
  return ["left", "right", "top", "bottom"].reduce((acc, direction) => {
    const key = `margin${direction.charAt(0).toUpperCase() + direction.slice(1)}`;
    const inlineValue = inlineMargins ? inlineMargins?.[key]?.value : null;
    const styleValue = cellMargins ? cellMargins[key] : null;
    if (inlineValue != null) {
      acc[direction] = twipsToPixels(inlineValue);
    } else if (styleValue == null) {
      acc[direction] = void 0;
    } else if (typeof styleValue === "object") {
      acc[direction] = twipsToPixels(styleValue.value);
    } else {
      acc[direction] = twipsToPixels(styleValue);
    }
    return acc;
  }, {});
};
function translateTableCell(params) {
  const elements = translateChildNodes({
    ...params,
    tableCell: params.node
  });
  const cellProps = generateTableCellProperties(params.node);
  elements.unshift(cellProps);
  return {
    name: "w:tc",
    elements
  };
}
function generateTableCellProperties(node) {
  const tableCellProperties = { ...node.attrs?.tableCellProperties || {} };
  const { attrs } = node;
  const { colwidth = [], cellWidthType = "dxa", widthUnit } = attrs;
  const colwidthSum = colwidth.reduce((acc, curr) => acc + curr, 0);
  const propertiesWidthPixels = twipsToPixels(tableCellProperties.cellWidth?.value);
  if (propertiesWidthPixels !== colwidthSum) {
    tableCellProperties["cellWidth"] = {
      value: widthUnit === "px" ? pixelsToTwips(colwidthSum) : inchesToTwips(colwidthSum),
      type: cellWidthType
    };
  }
  const { colspan } = attrs;
  if (colspan > 1 && tableCellProperties.gridSpan !== colspan) {
    tableCellProperties["gridSpan"] = colspan;
  } else if (!colspan || tableCellProperties?.gridSpan === 1) {
    delete tableCellProperties.gridSpan;
  }
  const { background = {} } = attrs;
  if (background?.color && tableCellProperties.shading?.fill !== background?.color) {
    tableCellProperties["shading"] = { fill: background.color };
  } else if (!background?.color && tableCellProperties?.shading?.fill) {
    delete tableCellProperties.shading;
  }
  const { cellMargins } = attrs;
  if (cellMargins) {
    ["left", "right", "top", "bottom"].forEach((side) => {
      const key = `margin${side.charAt(0).toUpperCase() + side.slice(1)}`;
      if (cellMargins[side] != null) {
        if (!tableCellProperties.cellMargins) tableCellProperties["cellMargins"] = {};
        let currentPropertyValuePixels = twipsToPixels(tableCellProperties.cellMargins?.[key]?.value);
        if (currentPropertyValuePixels !== cellMargins[side]) {
          tableCellProperties.cellMargins[key] = { value: pixelsToTwips(cellMargins[side]), type: "dxa" };
        }
      } else if (tableCellProperties?.cellMargins?.[key]) {
        delete tableCellProperties.cellMargins[key];
      }
    });
  }
  const { verticalAlign } = attrs;
  if (verticalAlign && verticalAlign !== tableCellProperties.vAlign) {
    tableCellProperties["vAlign"] = verticalAlign;
  } else if (!verticalAlign && tableCellProperties?.vAlign) {
    delete tableCellProperties.vAlign;
  }
  const { rowspan } = attrs;
  const hasExistingVMerge = tableCellProperties.vMerge != null;
  if (rowspan && rowspan > 1) {
    tableCellProperties["vMerge"] = "restart";
  } else if (attrs.continueMerge) {
    tableCellProperties["vMerge"] = "continue";
  } else if (!hasExistingVMerge) {
    delete tableCellProperties.vMerge;
  }
  const { borders = {} } = attrs;
  if (!!borders && Object.keys(borders).length) {
    ["top", "bottom", "left", "right"].forEach((side) => {
      if (borders[side]) {
        let currentPropertyValue = tableCellProperties.borders?.[side];
        let currentPropertySizePixels = eighthPointsToPixels(currentPropertyValue?.size);
        let color = borders[side].color;
        if (borders[side].color && color === "#000000") {
          color = "auto";
        }
        if (currentPropertySizePixels !== borders[side].size || currentPropertyValue?.color !== color || borders[side].val !== currentPropertyValue?.val) {
          if (!tableCellProperties.borders) tableCellProperties["borders"] = {};
          tableCellProperties.borders[side] = {
            size: pixelsToEightPoints(borders[side].size || 0),
            color,
            space: borders[side].space || 0,
            val: borders[side].val || "single"
          };
        }
      } else if (tableCellProperties.borders?.[side]) {
        delete tableCellProperties.borders[side];
      }
    });
  } else if (tableCellProperties?.borders) {
    delete tableCellProperties.borders;
  }
  const result = translator$1q.decode({ node: { ...node, attrs: { ...node.attrs, tableCellProperties } } });
  return result;
}
const XML_NODE_NAME$m = "w:tc";
const SD_NODE_NAME$k = "tableCell";
const validXmlAttributes$a = [];
function encode$B(params, encodedAttrs) {
  const {
    node,
    table,
    row,
    tableProperties,
    rowBorders,
    baseTableBorders,
    tableLook,
    rowCnfStyle,
    columnIndex,
    columnWidth,
    columnWidths: allColumnWidths,
    rowIndex,
    totalRows,
    totalColumns,
    preferTableGridWidths,
    _referencedStyles
  } = params.extraParams;
  const schemaNode = handleTableCellNode({
    params,
    node,
    table,
    row,
    tableProperties,
    rowBorders,
    baseTableBorders,
    tableLook,
    rowCnfStyle,
    columnIndex,
    columnWidth,
    allColumnWidths,
    rowIndex,
    totalRows,
    totalColumns,
    preferTableGridWidths,
    _referencedStyles
  });
  if (encodedAttrs && Object.keys(encodedAttrs).length) {
    schemaNode.attrs = { ...schemaNode.attrs, ...encodedAttrs };
  }
  return schemaNode;
}
function decode$D(params, decodedAttrs) {
  const translated = translateTableCell(params);
  if (decodedAttrs && Object.keys(decodedAttrs).length) {
    translated.attributes = { ...translated.attributes || {}, ...decodedAttrs };
  }
  return translated;
}
const config$l = {
  xmlName: XML_NODE_NAME$m,
  sdNodeOrKeyName: SD_NODE_NAME$k,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$B,
  decode: decode$D,
  attributes: validXmlAttributes$a
};
const translator$1p = NodeTranslator.from(config$l);
const propertyTranslators$9 = [
  translator$28,
  translator$1H,
  translator$1F,
  translator$1E,
  translator$26,
  translator$24,
  translator$1D,
  translator$22
];
const translator$1o = NodeTranslator.from(
  createNestedPropertiesTranslator("w:tblBorders", "borders", propertyTranslators$9)
);
const translator$1n = NodeTranslator.from({
  xmlName: "w:cantSplit",
  sdNodeOrKeyName: "cantSplit",
  encode: ({ nodes }) => ["1", "true"].includes(nodes[0].attributes?.["w:val"] ?? "1"),
  decode: ({ node }) => node.attrs?.cantSplit ? { attributes: {} } : void 0
});
const translator$1m = NodeTranslator.from(
  createSingleAttrPropertyHandler(
    "w:gridAfter",
    null,
    "w:val",
    (v2) => parseInteger(v2) ?? void 0,
    (v2) => integerToString(v2)
  )
);
const translator$1l = NodeTranslator.from(
  createSingleAttrPropertyHandler(
    "w:gridBefore",
    null,
    "w:val",
    (v2) => parseInteger(v2) ?? void 0,
    (v2) => integerToString(v2)
  )
);
const translator$1k = NodeTranslator.from(createSingleBooleanPropertyHandler("w:hidden"));
const translator$1j = NodeTranslator.from(createMeasurementPropertyHandler("w:tblCellSpacing", "tableCellSpacing"));
const translator$1i = NodeTranslator.from({
  xmlName: "w:tblHeader",
  sdNodeOrKeyName: "repeatHeader",
  encode: ({ nodes }) => parseBoolean(nodes[0].attributes?.["w:val"] ?? "1"),
  decode: ({ node }) => node.attrs.repeatHeader ? { attributes: {} } : void 0
});
const translator$1h = NodeTranslator.from({
  xmlName: "w:trHeight",
  sdNodeOrKeyName: "rowHeight",
  encode: ({ nodes }) => {
    const heightAttrs = {};
    const val = nodes[0].attributes["w:val"];
    if (val) {
      heightAttrs["value"] = parseInt(val, 10);
    }
    const rule = nodes[0].attributes["w:hRule"];
    if (rule) {
      heightAttrs["rule"] = rule;
    }
    return Object.keys(heightAttrs).length > 0 ? heightAttrs : void 0;
  },
  decode: ({ node }) => {
    if (!node.attrs?.rowHeight) return;
    const heightAttrs = {};
    if (typeof node.attrs.rowHeight.value === "number" && !isNaN(node.attrs.rowHeight.value)) {
      heightAttrs["w:val"] = String(node.attrs.rowHeight.value);
    }
    if (node.attrs.rowHeight.rule) {
      heightAttrs["w:hRule"] = node.attrs.rowHeight.rule;
    }
    return Object.keys(heightAttrs).length > 0 ? { attributes: heightAttrs } : void 0;
  }
});
const translator$1g = NodeTranslator.from(createMeasurementPropertyHandler("w:wAfter"));
const translator$1f = NodeTranslator.from(createMeasurementPropertyHandler("w:wBefore"));
const propertyTranslators$8 = [
  translator$1n,
  translator$2q,
  translator$2o,
  translator$1m,
  translator$1l,
  translator$1k,
  translator$2l,
  translator$1j,
  translator$1i,
  translator$1h,
  translator$1g,
  translator$1f
];
const translator$1e = NodeTranslator.from(
  createNestedPropertiesTranslator("w:trPr", "tableRowProperties", propertyTranslators$8, {
    cantSplit: false,
    hidden: false,
    repeatHeader: false
  })
);
const createPlaceholderCell = (gridWidth, reason) => {
  const safeWidth = Number.isFinite(gridWidth) ? gridWidth : 0;
  const noBorder = { val: "none", size: 0 };
  return {
    type: "tableCell",
    attrs: {
      colspan: 1,
      rowspan: 1,
      colwidth: [safeWidth],
      __placeholder: reason,
      borders: {
        top: { ...noBorder },
        right: { ...noBorder },
        bottom: { ...noBorder },
        left: { ...noBorder }
      }
    },
    content: [{ type: "paragraph", content: [] }]
  };
};
const advancePastRowSpans = (pendingRowSpans, startIndex, totalColumns) => {
  let index2 = startIndex;
  while (index2 < totalColumns && pendingRowSpans[index2] > 0) {
    pendingRowSpans[index2] -= 1;
    index2 += 1;
  }
  return index2;
};
const fillPlaceholderColumns = ({
  content,
  pendingRowSpans,
  currentIndex,
  targetIndex,
  totalColumns,
  gridColumnWidths,
  reason
}) => {
  let index2 = currentIndex;
  while (index2 < targetIndex && index2 < totalColumns) {
    if (pendingRowSpans[index2] > 0) {
      pendingRowSpans[index2] -= 1;
      index2 += 1;
      continue;
    }
    const width = Array.isArray(gridColumnWidths) ? gridColumnWidths[index2] ?? 0 : 0;
    content.push(createPlaceholderCell(width, reason));
    index2 += 1;
  }
  return index2;
};
const isPlaceholderCell = (cell) => {
  if (!cell) return false;
  if (cell.attrs?.__placeholder) return true;
  const widths = cell.attrs?.colwidth;
  if (Array.isArray(widths) && widths.length > 0) {
    const hasMeaningfulWidth = widths.some(
      (value) => typeof value === "number" && Number.isFinite(value) && Math.abs(value) > 1
    );
    if (!hasMeaningfulWidth) return true;
  }
  return false;
};
const XML_NODE_NAME$l = "w:tr";
const SD_NODE_NAME$j = "tableRow";
const validXmlAttributes$9 = ["w:rsidDel", "w:rsidR", "w:rsidRPr", "w:rsidTr", "w14:paraId", "w14:textId"].map(
  (xmlName) => createAttributeHandler(xmlName)
);
const getColspan$1 = (cell) => {
  const rawColspan = cell?.attrs?.colspan;
  const numericColspan = typeof rawColspan === "string" ? parseInt(rawColspan, 10) : rawColspan;
  return Number.isFinite(numericColspan) && numericColspan > 0 ? numericColspan : 1;
};
const encode$A = (params, encodedAttrs) => {
  const { row, tableLook } = params.extraParams;
  let tableRowProperties = {};
  const tPr = row.elements.find((el) => el.name === "w:trPr");
  if (tPr) {
    tableRowProperties = translator$1e.encode({
      ...params,
      nodes: [tPr]
    });
  }
  const gridBeforeRaw = tableRowProperties?.["gridBefore"];
  const safeGridBefore = typeof gridBeforeRaw === "number" && Number.isFinite(gridBeforeRaw) && gridBeforeRaw > 0 ? gridBeforeRaw : 0;
  encodedAttrs["tableRowProperties"] = Object.freeze(tableRowProperties);
  encodedAttrs["rowHeight"] = twipsToPixels(tableRowProperties["rowHeight"]?.value);
  encodedAttrs["cantSplit"] = tableRowProperties["cantSplit"];
  const rowCnfStyle = tableRowProperties?.cnfStyle;
  const baseBorders = params.extraParams?.tableBorders;
  const rowBorders = getRowBorders({
    params,
    row,
    baseBorders
  });
  const { columnWidths: gridColumnWidths, activeRowSpans = [] } = params.extraParams;
  const totalColumns = Array.isArray(gridColumnWidths) ? gridColumnWidths.length : 0;
  const pendingRowSpans = Array.isArray(activeRowSpans) ? activeRowSpans.slice() : [];
  while (pendingRowSpans.length < totalColumns) pendingRowSpans.push(0);
  const cellNodes = row.elements.filter((el) => el.name === "w:tc");
  const content = [];
  let currentColumnIndex = 0;
  const fillUntil = (target, reason) => {
    currentColumnIndex = fillPlaceholderColumns({
      content,
      pendingRowSpans,
      currentIndex: currentColumnIndex,
      targetIndex: target,
      totalColumns,
      gridColumnWidths,
      reason
    });
  };
  const skipOccupiedColumns = () => {
    currentColumnIndex = advancePastRowSpans(pendingRowSpans, currentColumnIndex, totalColumns);
  };
  fillUntil(safeGridBefore, "gridBefore");
  skipOccupiedColumns();
  cellNodes?.forEach((node) => {
    skipOccupiedColumns();
    const startColumn = currentColumnIndex;
    const columnWidth = gridColumnWidths?.[startColumn] || null;
    const result = translator$1p.encode({
      ...params,
      path: [...params.path || [], node],
      extraParams: {
        ...params.extraParams,
        rowBorders,
        baseTableBorders: baseBorders,
        tableLook,
        rowCnfStyle,
        node,
        columnIndex: startColumn,
        columnWidth
      }
    });
    if (result) {
      content.push(result);
      const colspan = Math.max(1, result.attrs?.colspan || 1);
      const rowspan = Math.max(1, result.attrs?.rowspan || 1);
      if (rowspan > 1) {
        for (let offset = 0; offset < colspan; offset += 1) {
          const target = startColumn + offset;
          if (target < pendingRowSpans.length) {
            pendingRowSpans[target] = Math.max(pendingRowSpans[target], rowspan - 1);
          }
        }
      }
      currentColumnIndex = startColumn + colspan;
    }
  });
  skipOccupiedColumns();
  fillUntil(totalColumns, "gridAfter");
  const newNode = {
    type: "tableRow",
    content,
    attrs: encodedAttrs
  };
  return newNode;
};
function getRowBorders({ params, row, baseBorders }) {
  const tblPrEx = row?.elements?.find?.((el) => el.name === "w:tblPrEx");
  const tblBorders = tblPrEx?.elements?.find?.((el) => el.name === "w:tblBorders");
  const rowBaseBorders = {};
  if (baseBorders?.insideV) {
    rowBaseBorders.insideV = baseBorders?.insideV;
  }
  if (baseBorders?.insideH) {
    rowBaseBorders.insideH = baseBorders?.insideH;
  }
  if (!tblBorders) {
    return rowBaseBorders;
  }
  const rawOverrides = translator$1o.encode({ ...params, nodes: [tblBorders] }) || {};
  const overrides = processRawTableBorders(rawOverrides);
  if (!Object.keys(overrides).length) {
    return rowBaseBorders;
  }
  const rowBorders = { ...rowBaseBorders, ...overrides };
  return rowBorders;
}
function processRawTableBorders(rawBorders) {
  const borders = {};
  Object.entries(rawBorders || {}).forEach(([name, attributes]) => {
    const attrs = {};
    const color = attributes?.color;
    const size = attributes?.size;
    const val = attributes?.val;
    if (color && color !== "auto") attrs.color = color.startsWith("#") ? color : `#${color}`;
    if (size != null && size !== "auto") attrs.size = eighthPointsToPixels(size);
    if (val) attrs.val = val;
    borders[name] = attrs;
  });
  return borders;
}
const decode$C = (params, decodedAttrs) => {
  const { node } = params;
  const cells = node.content || [];
  let leadingPlaceholders = 0;
  while (leadingPlaceholders < cells.length && isPlaceholderCell(cells[leadingPlaceholders])) {
    leadingPlaceholders += 1;
  }
  let trailingPlaceholders = 0;
  while (trailingPlaceholders < cells.length - leadingPlaceholders && isPlaceholderCell(cells[cells.length - 1 - trailingPlaceholders])) {
    trailingPlaceholders += 1;
  }
  const trimmedSlice = cells.slice(leadingPlaceholders, cells.length - trailingPlaceholders);
  const sanitizedCells = trimmedSlice.map((cell) => {
    if (cell?.attrs && "__placeholder" in cell.attrs) {
      const { __placeholder, ...rest } = cell.attrs;
      return { ...cell, attrs: rest };
    }
    return cell;
  });
  let trimmedContent = sanitizedCells.filter((_2, index2) => !isPlaceholderCell(trimmedSlice[index2]));
  const preferTableGrid = params.extraParams?.preferTableGrid === true;
  const totalColumns = params.extraParams?.totalColumns;
  if (preferTableGrid && typeof totalColumns === "number" && Number.isFinite(totalColumns) && totalColumns > 0) {
    const rawGridBefore = node.attrs?.tableRowProperties?.gridBefore;
    const numericGridBefore = typeof rawGridBefore === "string" ? parseInt(rawGridBefore, 10) : rawGridBefore;
    const safeGridBefore = Number.isFinite(numericGridBefore) && numericGridBefore > 0 ? numericGridBefore : 0;
    const effectiveGridBefore = leadingPlaceholders > 0 ? leadingPlaceholders : safeGridBefore;
    const availableColumns = Math.max(totalColumns - effectiveGridBefore, 0);
    let usedColumns = 0;
    const constrainedCells = [];
    for (const cell of trimmedContent) {
      const colspan = getColspan$1(cell);
      if (usedColumns + colspan > availableColumns) {
        break;
      }
      constrainedCells.push(cell);
      usedColumns += colspan;
    }
    trimmedContent = constrainedCells;
  }
  const translateParams = {
    ...params,
    node: { ...node, content: trimmedContent }
  };
  const elements = translateChildNodes(translateParams);
  if (node.attrs?.tableRowProperties) {
    const tableRowProperties = { ...node.attrs.tableRowProperties };
    if (leadingPlaceholders > 0) {
      tableRowProperties.gridBefore = leadingPlaceholders;
    }
    if (trailingPlaceholders > 0) {
      tableRowProperties.gridAfter = trailingPlaceholders;
    }
    if (node.attrs.rowHeight != null) {
      const rowHeightPixels = twipsToPixels(node.attrs.tableRowProperties["rowHeight"]?.value);
      if (rowHeightPixels !== node.attrs.rowHeight) {
        tableRowProperties["rowHeight"] = { value: String(pixelsToTwips(node.attrs["rowHeight"])) };
      }
    }
    tableRowProperties["cantSplit"] = node.attrs["cantSplit"];
    const trPr = translator$1e.decode({
      ...params,
      node: { ...node, attrs: { ...node.attrs, tableRowProperties } }
    });
    if (trPr) elements.unshift(trPr);
  }
  return {
    name: "w:tr",
    attributes: decodedAttrs || {},
    elements
  };
};
const config$k = {
  xmlName: XML_NODE_NAME$l,
  sdNodeOrKeyName: SD_NODE_NAME$j,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$A,
  decode: decode$C,
  attributes: validXmlAttributes$9
};
const translator$1d = NodeTranslator.from(config$k);
function parseTagValueJSON(json) {
  if (typeof json !== "string") {
    return {};
  }
  const trimmed = json.trim();
  if (!trimmed) {
    return {};
  }
  try {
    return JSON.parse(trimmed);
  } catch {
    return {};
  }
}
function handleAnnotationNode(params) {
  const { nodes } = params;
  if (nodes.length === 0 || nodes[0].name !== "w:sdt") {
    return null;
  }
  const node = nodes[0];
  const sdtPr = node.elements.find((el) => el.name === "w:sdtPr");
  const sdtContent = node.elements.find((el) => el.name === "w:sdtContent");
  const sdtId = sdtPr?.elements?.find((el) => el.name === "w:id");
  const alias = sdtPr?.elements.find((el) => el.name === "w:alias");
  const tag = sdtPr?.elements.find((el) => el.name === "w:tag");
  const tagValue = tag?.attributes["w:val"];
  const shouldProcessAsJson = tagValue?.startsWith("{") && tagValue?.endsWith("}");
  let attrs = {};
  const aliasLabel = getSafeString(alias?.attributes?.["w:val"]);
  if (shouldProcessAsJson) {
    const parsedAttrs = parseTagValueJSON(tagValue);
    attrs = {
      type: parsedAttrs.fieldTypeShort,
      fieldId: parsedAttrs.fieldId,
      displayLabel: parsedAttrs.displayLabel,
      defaultDisplayLabel: parsedAttrs.defaultDisplayLabel,
      fieldType: parsedAttrs.fieldType,
      fieldColor: parsedAttrs.fieldColor,
      multipleImage: parsedAttrs.fieldMultipleImage,
      fontFamily: parsedAttrs.fieldFontFamily,
      fontSize: parsedAttrs.fieldFontSize,
      textColor: parsedAttrs.fieldTextColor,
      textHighlight: parsedAttrs.fieldTextHighlight,
      hash: parsedAttrs.hash
    };
  } else {
    attrs = getAttrsFromElements({ sdtPr, tag, alias, sdtId });
  }
  const initialDisplayLabel = getSafeString(attrs.displayLabel);
  const extractedContent = getTextFromSdtContent(sdtContent);
  if (!attrs.defaultDisplayLabel) {
    if (initialDisplayLabel) {
      attrs.defaultDisplayLabel = initialDisplayLabel;
    } else if (aliasLabel) {
      attrs.defaultDisplayLabel = aliasLabel;
    }
  }
  const placeholderLabel = getPlaceholderLabel(attrs, aliasLabel);
  const placeholderText = ensurePlaceholderFormat(placeholderLabel);
  const isAnnotationsEnabled = Boolean(params.editor?.options?.annotations);
  const contentIsDistinct = shouldUseSdtContent(extractedContent, placeholderText);
  const shouldUseContent = !isAnnotationsEnabled && contentIsDistinct && (hasMoustache(extractedContent) || !placeholderText);
  if (contentIsDistinct) {
    attrs.displayLabel = extractedContent;
  } else if (!attrs.displayLabel && placeholderLabel) {
    attrs.displayLabel = placeholderLabel;
  }
  const { attrs: marksAsAttrs, marks } = parseAnnotationMarks(sdtContent);
  const allAttrs = { ...attrs, ...marksAsAttrs, ...sdtPr && { sdtPr } };
  if (!allAttrs.hash) allAttrs.hash = generateDocxRandomId(4);
  if (!attrs.fieldId || !attrs.type) {
    return null;
  }
  const textContent = shouldUseContent ? extractedContent : placeholderText;
  let result = {
    type: "text",
    text: textContent,
    attrs: allAttrs,
    marks
  };
  if (isAnnotationsEnabled) {
    result = {
      type: "fieldAnnotation",
      attrs: allAttrs
    };
  }
  return result;
}
const parseAnnotationMarks = (content = {}) => {
  let mainContent = content;
  const run2 = mainContent.elements?.find((el) => el.name === "w:r");
  const rPr = run2?.elements?.find((el) => el.name === "w:rPr");
  if (!rPr) return {};
  const unknownMarks = [];
  const marks = parseMarks(rPr, unknownMarks) || [];
  const marksWithFlatFontStyles = [];
  marks.forEach((mark) => {
    const { type: type2 } = mark;
    if (type2 === "textStyle") {
      const { attrs: attrs2 } = mark;
      Object.keys(attrs2).forEach((key) => {
        marksWithFlatFontStyles.push({ type: key, attrs: attrs2[key] });
      });
    } else {
      marksWithFlatFontStyles.push(mark);
    }
  });
  const attrs = {};
  marksWithFlatFontStyles?.forEach((mark) => {
    const { type: type2 } = mark;
    attrs[type2] = mark.attrs || true;
  });
  return {
    attrs,
    marks
  };
};
function getAttrsFromElements({ sdtPr, tag, alias, sdtId }) {
  const type2 = sdtPr?.elements.find((el) => el.name === "w:fieldTypeShort")?.attributes["w:val"];
  const fieldType = sdtPr?.elements.find((el) => el.name === "w:fieldType")?.attributes["w:val"];
  const fieldColor = sdtPr?.elements.find((el) => el.name === "w:fieldColor")?.attributes["w:val"];
  const isMultipleImage = sdtPr?.elements.find((el) => el.name === "w:fieldMultipleImage")?.attributes["w:val"];
  const fontFamily = sdtPr?.elements.find((el) => el.name === "w:fieldFontFamily")?.attributes["w:val"];
  const fontSize = sdtPr?.elements.find((el) => el.name === "w:fieldFontSize")?.attributes["w:val"];
  const textColor = sdtPr?.elements.find((el) => el.name === "w:fieldTextColor")?.attributes["w:val"];
  const textHighlight = sdtPr?.elements.find((el) => el.name === "w:fieldTextHighlight")?.attributes["w:val"];
  const attrs = {
    type: type2,
    fieldId: tag?.attributes["w:val"],
    displayLabel: alias?.attributes["w:val"],
    fieldType,
    fieldColor,
    multipleImage: isMultipleImage === "true",
    fontFamily: fontFamily !== "null" ? fontFamily : null,
    fontSize: fontSize !== "null" ? fontSize : null,
    textColor: textColor !== "null" ? textColor : null,
    textHighlight: textHighlight !== "null" ? textHighlight : null,
    sdtId: sdtId?.attributes["w:val"]
  };
  return attrs;
}
function getTextFromSdtContent(sdtContent) {
  if (!sdtContent?.elements?.length) return "";
  const chunks = [];
  collectTextChunks(sdtContent.elements, chunks);
  if (chunks.length && chunks[chunks.length - 1] === "\n") {
    chunks.pop();
  }
  const text = chunks.join("");
  return text.replace(/\u00a0/g, " ");
}
function getPlaceholderLabel(attrs, aliasValue) {
  const displayLabel = trimSafeString(attrs.displayLabel);
  if (displayLabel) return displayLabel;
  const defaultLabel = trimSafeString(attrs.defaultDisplayLabel);
  if (defaultLabel) return defaultLabel;
  return trimSafeString(aliasValue);
}
function shouldUseSdtContent(extractedContent, placeholderText) {
  const normalizedContent = normalizePlaceholderText(extractedContent);
  if (!normalizedContent) return false;
  const normalizedPlaceholder = normalizePlaceholderText(placeholderText);
  return normalizedContent !== normalizedPlaceholder;
}
function ensurePlaceholderFormat(label) {
  const trimmed = trimSafeString(label);
  if (!trimmed) return "";
  if (trimmed.startsWith("{{") && trimmed.endsWith("}}")) {
    return trimmed;
  }
  return `{{${trimmed}}}`;
}
function normalizePlaceholderText(value = "") {
  const trimmed = trimSafeString(value);
  if (!trimmed) return "";
  return stripPlaceholderBraces(trimmed).toLowerCase();
}
function stripPlaceholderBraces(value = "") {
  if (value.startsWith("{{") && value.endsWith("}}")) {
    return trimSafeString(value.slice(2, -2));
  }
  return value;
}
function hasMoustache(value = "") {
  return /\{\{\s*.+?\s*\}\}/.test(getSafeString(value));
}
function collectTextChunks(elements, chunks) {
  if (!elements) return;
  elements.forEach((element) => {
    if (!element) return;
    if (element.type === "text") {
      chunks.push(element.text || "");
      return;
    }
    if (element.name === "w:tab") {
      chunks.push("	");
      return;
    }
    if (element.name === "w:br") {
      chunks.push("\n");
      return;
    }
    const isParagraph = element.name === "w:p";
    const initialLength = chunks.length;
    if (element.elements?.length) {
      collectTextChunks(element.elements, chunks);
    }
    if (isParagraph && chunks.length > initialLength) {
      chunks.push("\n");
    }
  });
}
function getSafeString(value) {
  if (typeof value !== "string") return "";
  return value;
}
function trimSafeString(value) {
  return getSafeString(value).replace(/\u00a0/g, " ").trim();
}
function handleDocPartObj(params) {
  const { nodes } = params;
  if (nodes.length === 0 || nodes[0].name !== "w:sdt") {
    return null;
  }
  const node = nodes[0];
  const sdtPr = node.elements.find((el) => el.name === "w:sdtPr");
  const docPartObj = sdtPr?.elements.find((el) => el.name === "w:docPartObj");
  const docPartGallery = docPartObj?.elements.find((el) => el.name === "w:docPartGallery");
  const docPartGalleryType = docPartGallery?.attributes?.["w:val"] ?? null;
  const content = node?.elements.find((el) => el.name === "w:sdtContent");
  const handler2 = validGalleryTypeMap[docPartGalleryType] || genericDocPartHandler;
  const result = handler2({
    ...params,
    nodes: [content],
    extraParams: { ...params.extraParams || {}, sdtPr, docPartGalleryType }
  });
  return result;
}
const tableOfContentsHandler = (params) => {
  const node = params.nodes[0];
  const translatedContent = params.nodeListHandler.handler({
    ...params,
    nodes: node.elements,
    path: [...params.path || [], node]
  });
  const normalizedContent = normalizeDocPartContent(translatedContent);
  const sdtPr = params.extraParams.sdtPr;
  const id = sdtPr.elements?.find((el) => el.name === "w:id")?.attributes["w:val"] || "";
  const docPartObj = sdtPr?.elements.find((el) => el.name === "w:docPartObj");
  const docPartUnique = docPartObj?.elements.some((el) => el.name === "w:docPartUnique") ?? false;
  const result = {
    type: "documentPartObject",
    content: normalizedContent,
    attrs: {
      id,
      docPartGallery: "Table of Contents",
      docPartUnique,
      sdtPr
      // Passthrough for round-trip preservation
    }
  };
  return result;
};
const genericDocPartHandler = (params) => {
  const node = params.nodes[0];
  const translatedContent = params.nodeListHandler.handler({
    ...params,
    nodes: node.elements,
    path: [...params.path || [], node]
  });
  const sdtPr = params.extraParams.sdtPr;
  const docPartGalleryType = params.extraParams.docPartGalleryType;
  const id = sdtPr?.elements?.find((el) => el.name === "w:id")?.attributes["w:val"] || "";
  const docPartObj = sdtPr?.elements.find((el) => el.name === "w:docPartObj");
  const docPartGallery = docPartGalleryType ?? docPartObj?.elements?.find((el) => el.name === "w:docPartGallery")?.attributes?.["w:val"] ?? null;
  const docPartUnique = docPartObj?.elements.some((el) => el.name === "w:docPartUnique") ?? false;
  const result = {
    type: "documentPartObject",
    content: translatedContent,
    attrs: {
      id,
      docPartGallery,
      docPartUnique,
      sdtPr
      // Passthrough for round-trip preservation of all sdtPr elements
    }
  };
  return result;
};
const validGalleryTypeMap = {
  "Table of Contents": tableOfContentsHandler
};
const inlineNodeTypes = /* @__PURE__ */ new Set(["bookmarkStart", "bookmarkEnd"]);
const wrapInlineNode = (node) => ({
  type: "paragraph",
  content: [node]
});
const normalizeDocPartContent = (nodes = []) => {
  const normalized = [];
  nodes.forEach((node) => {
    if (inlineNodeTypes.has(node?.type)) {
      normalized.push(wrapInlineNode(node));
    } else {
      normalized.push(node);
    }
  });
  return normalized;
};
function handleDocumentSectionNode(params) {
  const { nodes, nodeListHandler } = params;
  if (nodes.length === 0 || nodes[0].name !== "w:sdt") {
    return null;
  }
  const node = nodes[0];
  const sdtPr = node.elements.find((el) => el.name === "w:sdtPr");
  const tag = sdtPr?.elements.find((el) => el.name === "w:tag");
  const tagValue = parseTagValueJSON(tag?.attributes?.["w:val"]);
  const idTag = sdtPr?.elements.find((el) => el.name === "w:id");
  const id = idTag?.attributes?.["w:val"] || tagValue.id || null;
  const titleTag = sdtPr?.elements.find((el) => el.name === "w:alias");
  const title = titleTag?.attributes?.["w:val"] || tagValue.title || null;
  const { description } = tagValue;
  const lockTag = sdtPr?.elements.find((el) => el.name === "w:lock");
  const lockValue = lockTag?.attributes?.["w:val"];
  const isLocked = lockValue === "sdtContentLocked";
  const sdtContent = node.elements.find((el) => el.name === "w:sdtContent");
  const translatedContent = nodeListHandler.handler({
    ...params,
    nodes: sdtContent?.elements,
    path: [...params.path || [], node]
  });
  const result = {
    type: "documentSection",
    content: translatedContent,
    attrs: {
      id,
      title,
      description,
      isLocked,
      ...sdtPr && { sdtPr }
      // Passthrough for round-trip preservation of unknown elements only if it exists
    }
  };
  return result;
}
function handleStructuredContentNode(params) {
  const { nodes, nodeListHandler } = params;
  if (nodes.length === 0 || nodes[0].name !== "w:sdt") {
    return null;
  }
  const node = nodes[0];
  const sdtPr = node.elements.find((el) => el.name === "w:sdtPr");
  const sdtContent = node.elements.find((el) => el.name === "w:sdtContent");
  const id = sdtPr?.elements?.find((el) => el.name === "w:id");
  const tag = sdtPr?.elements?.find((el) => el.name === "w:tag");
  const alias = sdtPr?.elements?.find((el) => el.name === "w:alias");
  if (!sdtContent) {
    return null;
  }
  const paragraph = sdtContent.elements?.find((el) => el.name === "w:p");
  const table = sdtContent.elements?.find((el) => el.name === "w:tbl");
  const { marks } = parseAnnotationMarks(sdtContent);
  const translatedContent = nodeListHandler.handler({
    ...params,
    nodes: sdtContent.elements,
    path: [...params.path || [], sdtContent]
  });
  const isBlockNode = paragraph || table;
  const sdtContentType = isBlockNode ? "structuredContentBlock" : "structuredContent";
  let result = {
    type: sdtContentType,
    content: translatedContent,
    marks,
    attrs: {
      id: id?.attributes?.["w:val"] || null,
      tag: tag?.attributes?.["w:val"] || null,
      alias: alias?.attributes?.["w:val"] || null,
      sdtPr
    }
  };
  return result;
}
function sdtNodeTypeStrategy(node) {
  const sdtContent = node.elements.find((el) => el.name === "w:sdtContent");
  const sdtPr = node.elements.find((el) => el.name === "w:sdtPr");
  const tag = sdtPr?.elements.find((el) => el.name === "w:tag");
  const tagValue = tag?.attributes?.["w:val"];
  const docPartObj = sdtPr?.elements.find((el) => el.name === "w:docPartObj");
  if (docPartObj) {
    return { type: "docPartObj", handler: handleDocPartObj };
  }
  if (tagValue) {
    const shouldProcessAsJson = tagValue.startsWith("{") && tagValue.endsWith("}");
    if (shouldProcessAsJson) {
      const parsedTag = parseTagValueJSON(tagValue);
      if (parsedTag.type === "documentSection") {
        return { type: "documentSection", handler: handleDocumentSectionNode };
      }
      if (parsedTag.fieldId && parsedTag.fieldTypeShort) {
        return { type: "fieldAnnotation", handler: handleAnnotationNode };
      }
    } else {
      const fieldTypeShort = sdtPr.elements.find((el) => el.name === "w:fieldTypeShort");
      const fieldTypeShortValue = fieldTypeShort?.attributes["w:val"];
      if (tagValue && fieldTypeShortValue) {
        return { type: "fieldAnnotation", handler: handleAnnotationNode };
      }
    }
  }
  if (sdtContent) {
    return { type: "structuredContent", handler: handleStructuredContentNode };
  }
  return { type: "unknown", handler: null };
}
const lower16 = 65535;
const factor16 = Math.pow(2, 16);
function makeRecover(index2, offset) {
  return index2 + offset * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
const DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;
class MapResult {
  /**
  @internal
  */
  constructor(pos, delInfo, recover) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
}
class StepMap {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && StepMap.empty)
      return StepMap.empty;
  }
  /**
  @internal
  */
  recover(value) {
    let diff = 0, index2 = recoverIndex(value);
    if (!this.inverted)
      for (let i = 0; i < index2; i++)
        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[index2 * 3] + diff + recoverOffset(value);
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  map(pos, assoc = 1) {
    return this._map(pos, assoc, true);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i] - (this.inverted ? diff : 0);
      if (start > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;
      if (pos <= end) {
        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
        let result = start + diff + (side < 0 ? 0 : newSize);
        if (simple)
          return result;
        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
        let del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != start : pos != end)
          del |= DEL_SIDE;
        return new MapResult(result, del, recover);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult(pos + diff, 0, null);
  }
  /**
  @internal
  */
  touches(pos, recover) {
    let diff = 0, index2 = recoverIndex(recover);
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i] - (this.inverted ? diff : 0);
      if (start > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], end = start + oldSize;
      if (pos <= end && i == index2 * 3)
        return true;
      diff += this.ranges[i + newIndex] - oldSize;
    }
    return false;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(f) {
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new StepMap(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(n) {
    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
  }
}
StepMap.empty = new StepMap([]);
class Mapping {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(maps, mirror, from = 0, to = maps ? maps.length : 0) {
    this.mirror = mirror;
    this.from = from;
    this.to = to;
    this._maps = maps || [];
    this.ownData = !(maps || mirror);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(from = 0, to = this.maps.length) {
    return new Mapping(this._maps, this.mirror, from, to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(map, mirrors) {
    if (!this.ownData) {
      this._maps = this._maps.slice();
      this.mirror = this.mirror && this.mirror.slice();
      this.ownData = true;
    }
    this.to = this._maps.push(map);
    if (mirrors != null)
      this.setMirror(this._maps.length - 1, mirrors);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(mapping) {
    for (let i = 0, startSize = this._maps.length; i < mapping._maps.length; i++) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping._maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(n) {
    if (this.mirror) {
      for (let i = 0; i < this.mirror.length; i++)
        if (this.mirror[i] == n)
          return this.mirror[i + (i % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(n, m2) {
    if (!this.mirror)
      this.mirror = [];
    this.mirror.push(n, m2);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(mapping) {
    for (let i = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i >= 0; i--) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping._maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let inverse = new Mapping();
    inverse.appendMappingInverted(this);
    return inverse;
  }
  /**
  Map a position through this mapping.
  */
  map(pos, assoc = 1) {
    if (this.mirror)
      return this._map(pos, assoc, true);
    for (let i = this.from; i < this.to; i++)
      pos = this._maps[i].map(pos, assoc);
    return pos;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let delInfo = 0;
    for (let i = this.from; i < this.to; i++) {
      let map = this._maps[i], result = map.mapResult(pos, assoc);
      if (result.recover != null) {
        let corr = this.getMirror(i);
        if (corr != null && corr > i && corr < this.to) {
          i = corr;
          pos = this._maps[corr].recover(result.recover);
          continue;
        }
      }
      delInfo |= result.delInfo;
      pos = result.pos;
    }
    return simple ? pos : new MapResult(pos, delInfo, null);
  }
}
const stepsByID = /* @__PURE__ */ Object.create(null);
class Step {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return StepMap.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(other) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(schema, json) {
    if (!json || !json.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let type2 = stepsByID[json.stepType];
    if (!type2)
      throw new RangeError(`No step type ${json.stepType} defined`);
    return type2.fromJSON(schema, json);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(id, stepClass) {
    if (id in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id);
    stepsByID[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass;
  }
}
class StepResult {
  /**
  @internal
  */
  constructor(doc2, failed) {
    this.doc = doc2;
    this.failed = failed;
  }
  /**
  Create a successful step result.
  */
  static ok(doc2) {
    return new StepResult(doc2, null);
  }
  /**
  Create a failed step result.
  */
  static fail(message) {
    return new StepResult(null, message);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(doc2, from, to, slice) {
    try {
      return StepResult.ok(doc2.replace(from, to, slice));
    } catch (e) {
      if (e instanceof ReplaceError)
        return StepResult.fail(e.message);
      throw e;
    }
  }
}
function mapFragment(fragment, f, parent) {
  let mapped = [];
  for (let i = 0; i < fragment.childCount; i++) {
    let child = fragment.child(i);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline)
      child = f(child, parent, i);
    mapped.push(child);
  }
  return Fragment.fromArray(mapped);
}
class AddMarkStep extends Step {
  /**
  Create a mark step.
  */
  constructor(from, to, mark) {
    super();
    this.from = from;
    this.to = to;
    this.mark = mark;
  }
  apply(doc2) {
    let oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice = new Slice(mapFragment(oldSlice.content, (node, parent2) => {
      if (!node.isAtom || !parent2.type.allowsMarkType(this.mark.type))
        return node;
      return node.mark(this.mark.addToSet(node.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deleted && to.deleted || from.pos >= to.pos)
      return null;
    return new AddMarkStep(from.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("addMark", AddMarkStep);
class RemoveMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(from, to, mark) {
    super();
    this.from = from;
    this.to = to;
    this.mark = mark;
  }
  apply(doc2) {
    let oldSlice = doc2.slice(this.from, this.to);
    let slice = new Slice(mapFragment(oldSlice.content, (node) => {
      return node.mark(this.mark.removeFromSet(node.marks));
    }, doc2), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deleted && to.deleted || from.pos >= to.pos)
      return null;
    return new RemoveMarkStep(from.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("removeMark", RemoveMarkStep);
class AddNodeMarkStep extends Step {
  /**
  Create a node mark step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (node) {
      let newSet = this.mark.addToSet(node.marks);
      if (newSet.length == node.marks.length) {
        for (let i = 0; i < node.marks.length; i++)
          if (!node.marks[i].isInSet(newSet))
            return new AddNodeMarkStep(this.pos, node.marks[i]);
        return new AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("addNodeMark", AddNodeMarkStep);
class RemoveNodeMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at mark step's position");
    let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  invert(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node || !this.mark.isInSet(node.marks))
      return this;
    return new AddNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
class ReplaceStep extends Step {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(from, to, slice, structure = false) {
    super();
    this.from = from;
    this.to = to;
    this.slice = slice;
    this.structure = structure;
  }
  apply(doc2) {
    if (this.structure && contentBetween(doc2, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content");
    return StepResult.fromReplace(doc2, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(doc2) {
    return new ReplaceStep(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
  }
  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deletedAcross && to.deletedAcross)
      return null;
    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice, this.structure);
  }
  merge(other) {
    if (!(other instanceof ReplaceStep) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep(other.from, this.to, slice, this.structure);
    } else {
      return null;
    }
  }
  toJSON() {
    let json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
  }
}
Step.jsonID("replace", ReplaceStep);
class ReplaceAroundStep extends Step {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(from, to, gapFrom, gapTo, slice, insert, structure = false) {
    super();
    this.from = from;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice;
    this.insert = insert;
    this.structure = structure;
  }
  apply(doc2) {
    if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let gap = doc2.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted)
      return StepResult.fail("Content does not fit in gap");
    return StepResult.fromReplace(doc2, this.from, this.to, inserted);
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(doc2) {
    let gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    let gapFrom = this.from == this.gapFrom ? from.pos : mapping.map(this.gapFrom, -1);
    let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);
    if (from.deletedAcross && to.deletedAcross || gapFrom < from.pos || gapTo > to.pos)
      return null;
    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
  }
}
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc2, from, to) {
  let $from = doc2.resolve(from), dist2 = to - from, depth = $from.depth;
  while (dist2 > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist2--;
  }
  if (dist2 > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist2 > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist2--;
    }
  }
  return false;
}
function addMark(tr, from, to, mark) {
  let removed = [], added = [];
  let removing, adding;
  tr.doc.nodesBetween(from, to, (node, pos, parent) => {
    if (!node.isInline)
      return;
    let marks = node.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);
      let newSet = mark.addToSet(marks);
      for (let i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start && removing.mark.eq(marks[i]))
            removing.to = end;
          else
            removed.push(removing = new RemoveMarkStep(start, end, marks[i]));
        }
      }
      if (adding && adding.to == start)
        adding.to = end;
      else
        added.push(adding = new AddMarkStep(start, end, mark));
    }
  });
  removed.forEach((s) => tr.step(s));
  added.forEach((s) => tr.step(s));
}
function removeMark(tr, from, to, mark) {
  let matched = [], step = 0;
  tr.doc.nodesBetween(from, to, (node, pos) => {
    if (!node.isInline)
      return;
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let set = node.marks, found2;
      while (found2 = mark.isInSet(set)) {
        (toRemove || (toRemove = [])).push(found2);
        set = found2.removeFromSet(set);
      }
    } else if (mark) {
      if (mark.isInSet(node.marks))
        toRemove = [mark];
    } else {
      toRemove = node.marks;
    }
    if (toRemove && toRemove.length) {
      let end = Math.min(pos + node.nodeSize, to);
      for (let i = 0; i < toRemove.length; i++) {
        let style = toRemove[i], found2;
        for (let j2 = 0; j2 < matched.length; j2++) {
          let m2 = matched[j2];
          if (m2.step == step - 1 && style.eq(matched[j2].style))
            found2 = m2;
        }
        if (found2) {
          found2.to = end;
          found2.step = step;
        } else {
          matched.push({ style, from: Math.max(pos, from), to: end, step });
        }
      }
    }
  });
  matched.forEach((m2) => tr.step(new RemoveMarkStep(m2.from, m2.to, m2.style)));
}
function clearIncompatible(tr, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {
  let node = tr.doc.nodeAt(pos);
  let replSteps = [], cur = pos + 1;
  for (let i = 0; i < node.childCount; i++) {
    let child = node.child(i), end = cur + child.nodeSize;
    let allowed = match.matchType(child.type);
    if (!allowed) {
      replSteps.push(new ReplaceStep(cur, end, Slice.empty));
    } else {
      match = allowed;
      for (let j2 = 0; j2 < child.marks.length; j2++)
        if (!parentType.allowsMarkType(child.marks[j2].type))
          tr.step(new RemoveMarkStep(cur, end, child.marks[j2]));
      if (clearNewlines && child.isText && parentType.whitespace != "pre") {
        let m2, newline = /\r?\n|\r/g, slice;
        while (m2 = newline.exec(child.text)) {
          if (!slice)
            slice = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
          replSteps.push(new ReplaceStep(cur + m2.index, cur + m2.index + m2[0].length, slice));
        }
      }
    }
    cur = end;
  }
  if (!match.validEnd) {
    let fill = match.fillBefore(Fragment.empty, true);
    tr.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i = replSteps.length - 1; i >= 0; i--)
    tr.step(replSteps[i]);
}
function canCut(node, start, end) {
  return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));
}
function liftTarget(range2) {
  let parent = range2.parent;
  let content = parent.content.cutByIndex(range2.startIndex, range2.endIndex);
  for (let depth = range2.depth, contentBefore = 0, contentAfter = 0; ; --depth) {
    let node = range2.$from.node(depth);
    let index2 = range2.$from.index(depth) + contentBefore, endIndex = range2.$to.indexAfter(depth) - contentAfter;
    if (depth < range2.depth && node.canReplace(index2, endIndex, content))
      return depth;
    if (depth == 0 || node.type.spec.isolating || !canCut(node, index2, endIndex))
      break;
    if (index2)
      contentBefore = 1;
    if (endIndex < node.childCount)
      contentAfter = 1;
  }
  return null;
}
function lift(tr, range2, target) {
  let { $from, $to, depth } = range2;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start = gapStart, end = gapEnd;
  let before = Fragment.empty, openStart = 0;
  for (let d2 = depth, splitting = false; d2 > target; d2--)
    if (splitting || $from.index(d2) > 0) {
      splitting = true;
      before = Fragment.from($from.node(d2).copy(before));
      openStart++;
    } else {
      start--;
    }
  let after = Fragment.empty, openEnd = 0;
  for (let d2 = depth, splitting = false; d2 > target; d2--)
    if (splitting || $to.after(d2 + 1) < $to.end(d2)) {
      splitting = true;
      after = Fragment.from($to.node(d2).copy(after));
      openEnd++;
    } else {
      end++;
    }
  tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
function wrap(tr, range2, wrappers) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--) {
    if (content.size) {
      let match = wrappers[i].type.contentMatch.matchFragment(content);
      if (!match || !match.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }
  let start = range2.start, end = range2.end;
  tr.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));
}
function setBlockType(tr, from, to, type2, attrs) {
  if (!type2.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr.steps.length;
  tr.doc.nodesBetween(from, to, (node, pos) => {
    let attrsHere = typeof attrs == "function" ? attrs(node) : attrs;
    if (node.isTextblock && !node.hasMarkup(type2, attrsHere) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type2)) {
      let convertNewlines = null;
      if (type2.schema.linebreakReplacement) {
        let pre = type2.whitespace == "pre", supportLinebreak = !!type2.contentMatch.matchType(type2.schema.linebreakReplacement);
        if (pre && !supportLinebreak)
          convertNewlines = false;
        else if (!pre && supportLinebreak)
          convertNewlines = true;
      }
      if (convertNewlines === false)
        replaceLinebreaks(tr, node, pos, mapFrom);
      clearIncompatible(tr, tr.mapping.slice(mapFrom).map(pos, 1), type2, void 0, convertNewlines === null);
      let mapping = tr.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);
      tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type2.create(attrsHere, null, node.marks)), 0, 0), 1, true));
      if (convertNewlines === true)
        replaceNewlines(tr, node, pos, mapFrom);
      return false;
    }
  });
}
function replaceNewlines(tr, node, pos, mapFrom) {
  node.forEach((child, offset) => {
    if (child.isText) {
      let m2, newline = /\r?\n|\r/g;
      while (m2 = newline.exec(child.text)) {
        let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset + m2.index);
        tr.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function replaceLinebreaks(tr, node, pos, mapFrom) {
  node.forEach((child, offset) => {
    if (child.type == child.type.schema.linebreakReplacement) {
      let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset);
      tr.replaceWith(start, start + 1, node.type.schema.text("\n"));
    }
  });
}
function canChangeType(doc2, pos, type2) {
  let $pos = doc2.resolve(pos), index2 = $pos.index();
  return $pos.parent.canReplaceWith(index2, index2 + 1, type2);
}
function setNodeMarkup(tr, pos, type2, attrs, marks) {
  let node = tr.doc.nodeAt(pos);
  if (!node)
    throw new RangeError("No node at given position");
  if (!type2)
    type2 = node.type;
  let newNode = type2.create(attrs, null, marks || node.marks);
  if (node.isLeaf)
    return tr.replaceWith(pos, pos + node.nodeSize, newNode);
  if (!type2.validContent(node.content))
    throw new RangeError("Invalid content for node type " + type2.name);
  tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
}
function canSplit(doc2, pos, depth = 1, typesAfter) {
  let $pos = doc2.resolve(pos), base = $pos.depth - depth;
  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (let d2 = $pos.depth - 1, i = depth - 2; d2 > base; d2--, i--) {
    let node = $pos.node(d2), index3 = $pos.index(d2);
    if (node.type.spec.isolating)
      return false;
    let rest = node.content.cutByIndex(index3, node.childCount);
    let overrideChild = typesAfter && typesAfter[i + 1];
    if (overrideChild)
      rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    let after = typesAfter && typesAfter[i] || node;
    if (!node.canReplace(index3 + 1, node.childCount) || !after.type.validContent(rest))
      return false;
  }
  let index2 = $pos.indexAfter(base);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base).canReplaceWith(index2, index2, baseType ? baseType.type : $pos.node(base + 1).type);
}
function split(tr, pos, depth = 1, typesAfter) {
  let $pos = tr.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
  for (let d2 = $pos.depth, e = $pos.depth - depth, i = depth - 1; d2 > e; d2--, i--) {
    before = Fragment.from($pos.node(d2).copy(before));
    let typeAfter = typesAfter && typesAfter[i];
    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d2).copy(after));
  }
  tr.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
function canJoin(doc2, pos) {
  let $pos = doc2.resolve(pos), index2 = $pos.index();
  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index2, index2 + 1);
}
function canAppendWithSubstitutedLinebreaks(a, b2) {
  if (!b2.content.size)
    a.type.compatibleContent(b2.type);
  let match = a.contentMatchAt(a.childCount);
  let { linebreakReplacement } = a.type.schema;
  for (let i = 0; i < b2.childCount; i++) {
    let child = b2.child(i);
    let type2 = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;
    match = match.matchType(type2);
    if (!match)
      return false;
    if (!a.type.allowsMarks(child.marks))
      return false;
  }
  return match.validEnd;
}
function joinable(a, b2) {
  return !!(a && b2 && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b2));
}
function joinPoint(doc2, pos, dir = -1) {
  let $pos = doc2.resolve(pos);
  for (let d2 = $pos.depth; ; d2--) {
    let before, after, index2 = $pos.index(d2);
    if (d2 == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d2 + 1);
      index2++;
      after = $pos.node(d2).maybeChild(index2);
    } else {
      before = $pos.node(d2).maybeChild(index2 - 1);
      after = $pos.node(d2 + 1);
    }
    if (before && !before.isTextblock && joinable(before, after) && $pos.node(d2).canReplace(index2, index2 + 1))
      return pos;
    if (d2 == 0)
      break;
    pos = dir < 0 ? $pos.before(d2) : $pos.after(d2);
  }
}
function join(tr, pos, depth) {
  let convertNewlines = null;
  let { linebreakReplacement } = tr.doc.type.schema;
  let $before = tr.doc.resolve(pos - depth), beforeType = $before.node().type;
  if (linebreakReplacement && beforeType.inlineContent) {
    let pre = beforeType.whitespace == "pre";
    let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);
    if (pre && !supportLinebreak)
      convertNewlines = false;
    else if (!pre && supportLinebreak)
      convertNewlines = true;
  }
  let mapFrom = tr.steps.length;
  if (convertNewlines === false) {
    let $after = tr.doc.resolve(pos + depth);
    replaceLinebreaks(tr, $after.node(), $after.before(), mapFrom);
  }
  if (beforeType.inlineContent)
    clearIncompatible(tr, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);
  let mapping = tr.mapping.slice(mapFrom), start = mapping.map(pos - depth);
  tr.step(new ReplaceStep(start, mapping.map(pos + depth, -1), Slice.empty, true));
  if (convertNewlines === true) {
    let $full = tr.doc.resolve(start);
    replaceNewlines(tr, $full.node(), $full.before(), tr.steps.length);
  }
  return tr;
}
function insertPoint(doc2, pos, nodeType) {
  let $pos = doc2.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d2 = $pos.depth - 1; d2 >= 0; d2--) {
      let index2 = $pos.index(d2);
      if ($pos.node(d2).canReplaceWith(index2, index2, nodeType))
        return $pos.before(d2 + 1);
      if (index2 > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d2 = $pos.depth - 1; d2 >= 0; d2--) {
      let index2 = $pos.indexAfter(d2);
      if ($pos.node(d2).canReplaceWith(index2, index2, nodeType))
        return $pos.after(d2 + 1);
      if (index2 < $pos.node(d2).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc2, pos, slice) {
  let $pos = doc2.resolve(pos);
  if (!slice.content.size)
    return pos;
  let content = slice.content;
  for (let i = 0; i < slice.openStart; i++)
    content = content.firstChild.content;
  for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {
    for (let d2 = $pos.depth; d2 >= 0; d2--) {
      let bias = d2 == $pos.depth ? 0 : $pos.pos <= ($pos.start(d2 + 1) + $pos.end(d2 + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d2) + (bias > 0 ? 1 : 0);
      let parent = $pos.node(d2), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d2 + 1) : $pos.after(d2 + 1);
    }
  }
  return null;
}
function replaceStep(doc2, from, to = from, slice = Slice.empty) {
  if (from == to && !slice.size)
    return null;
  let $from = doc2.resolve(from), $to = doc2.resolve(to);
  if (fitsTrivially($from, $to, slice))
    return new ReplaceStep(from, to, slice);
  return new Fitter($from, $to, slice).fit();
}
function fitsTrivially($from, $to, slice) {
  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);
}
class Fitter {
  constructor($from, $to, unplaced) {
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = Fragment.empty;
    for (let i = 0; i <= $from.depth; i++) {
      let node = $from.node(i);
      this.frontier.push({
        type: node.type,
        match: node.contentMatchAt($from.indexAfter(i))
      });
    }
    for (let i = $from.depth; i > 0; i--)
      this.placed = Fragment.from($from.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    while (this.unplaced.size) {
      let fit = this.findFittable();
      if (fit)
        this.placeNodes(fit);
      else
        this.openMore() || this.dropNode();
    }
    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to)
      return null;
    let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content.childCount == 1) {
      content = content.firstChild.content;
      openStart--;
      openEnd--;
    }
    let slice = new Slice(content, openStart, openEnd);
    if (moveInline > -1)
      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);
    if (slice.size || $from.pos != this.$to.pos)
      return new ReplaceStep($from.pos, $to.pos, slice);
    return null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let startDepth = this.unplaced.openStart;
    for (let cur = this.unplaced.content, d2 = 0, openEnd = this.unplaced.openEnd; d2 < startDepth; d2++) {
      let node = cur.firstChild;
      if (cur.childCount > 1)
        openEnd = 0;
      if (node.type.spec.isolating && openEnd <= d2) {
        startDepth = d2;
        break;
      }
      cur = node.content;
    }
    for (let pass = 1; pass <= 2; pass++) {
      for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        let fragment, parent = null;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        let first = fragment.firstChild;
        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          let { type: type2, match } = this.frontier[frontierDepth], wrap2, inject = null;
          if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false)) : parent && type2.compatibleContent(parent.type)))
            return { sliceDepth, frontierDepth, parent, inject };
          else if (pass == 2 && first && (wrap2 = match.findWrapping(first.type)))
            return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
          if (parent && match.matchType(parent.type))
            break;
        }
      }
    }
  }
  openMore() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf)
      return false;
    this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
    return true;
  }
  dropNode() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      let openAtEnd = content.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
    }
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
    while (this.depth > frontierDepth)
      this.closeFrontierNode();
    if (wrap2)
      for (let i = 0; i < wrap2.length; i++)
        this.openFrontierNode(wrap2[i]);
    let slice = this.unplaced, fragment = parent ? parent.content : slice.content;
    let openStart = slice.openStart - sliceDepth;
    let taken = 0, add = [];
    let { match, type: type2 } = this.frontier[frontierDepth];
    if (inject) {
      for (let i = 0; i < inject.childCount; i++)
        add.push(inject.child(i));
      match = match.matchFragment(inject);
    }
    let openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd);
    while (taken < fragment.childCount) {
      let next = fragment.child(taken), matches2 = match.matchType(next.type);
      if (!matches2)
        break;
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match = matches2;
        add.push(closeNodeStart(next.mark(type2.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    let toEnd = taken == fragment.childCount;
    if (!toEnd)
      openEndCount = -1;
    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));
    this.frontier[frontierDepth].match = match;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
      this.closeFrontierNode();
    for (let i = 0, cur = fragment; i < openEndCount; i++) {
      let node = cur.lastChild;
      this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });
      cur = node.content;
    }
    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let top = this.frontier[this.depth], level;
    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
      return -1;
    let { depth } = this.$to, after = this.$to.after(depth);
    while (depth > 1 && after == this.$to.end(--depth))
      ++after;
    return after;
  }
  findCloseLevel($to) {
    scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
      let { match, type: type2 } = this.frontier[i];
      let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
      let fit = contentAfterFits($to, i, type2, match, dropInner);
      if (!fit)
        continue;
      for (let d2 = i - 1; d2 >= 0; d2--) {
        let { match: match2, type: type3 } = this.frontier[d2];
        let matches2 = contentAfterFits($to, d2, type3, match2, true);
        if (!matches2 || matches2.childCount)
          continue scan;
      }
      return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
    }
  }
  close($to) {
    let close2 = this.findCloseLevel($to);
    if (!close2)
      return null;
    while (this.depth > close2.depth)
      this.closeFrontierNode();
    if (close2.fit.childCount)
      this.placed = addToFragment(this.placed, close2.depth, close2.fit);
    $to = close2.move;
    for (let d2 = close2.depth + 1; d2 <= $to.depth; d2++) {
      let node = $to.node(d2), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d2));
      this.openFrontierNode(node.type, node.attrs, add);
    }
    return $to;
  }
  openFrontierNode(type2, attrs = null, content) {
    let top = this.frontier[this.depth];
    top.match = top.match.matchType(type2);
    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type2.create(attrs, content)));
    this.frontier.push({ type: type2, match: type2.contentMatch });
  }
  closeFrontierNode() {
    let open = this.frontier.pop();
    let add = open.match.fillBefore(Fragment.empty, true);
    if (add.childCount)
      this.placed = addToFragment(this.placed, this.frontier.length, add);
  }
}
function dropFromFragment(fragment, depth, count) {
  if (depth == 0)
    return fragment.cutByIndex(count, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content) {
  if (depth == 0)
    return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}
function contentAt(fragment, depth) {
  for (let i = 0; i < depth; i++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node, openStart, openEnd) {
  if (openStart <= 0)
    return node;
  let frag = node.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
  }
  return node.copy(frag);
}
function contentAfterFits($to, depth, type2, match, open) {
  let node = $to.node(depth), index2 = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index2 == node.childCount && !type2.compatibleContent(node.type))
    return null;
  let fit = match.fillBefore(node.content, true, index2);
  return fit && !invalidMarks(type2, node.content, index2) ? fit : null;
}
function invalidMarks(type2, fragment, start) {
  for (let i = start; i < fragment.childCount; i++)
    if (!type2.allowsMarks(fragment.child(i).marks))
      return true;
  return false;
}
function definesContent(type2) {
  return type2.spec.defining || type2.spec.definingForContent;
}
function replaceRange(tr, from, to, slice) {
  if (!slice.size)
    return tr.deleteRange(from, to);
  let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);
  if (fitsTrivially($from, $to, slice))
    return tr.step(new ReplaceStep(from, to, slice));
  let targetDepths = coveredDepths($from, $to);
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d2 = $from.depth, pos = $from.pos - 1; d2 > 0; d2--, pos--) {
    let spec = $from.node(d2).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d2) > -1)
      preferredTarget = d2;
    else if ($from.before(d2) == pos)
      targetDepths.splice(1, 0, -d2);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice.openStart;
  for (let content = slice.content, i = 0; ; i++) {
    let node = content.firstChild;
    leftNodes.push(node);
    if (i == slice.openStart)
      break;
    content = node.content;
  }
  for (let d2 = preferredDepth - 1; d2 >= 0; d2--) {
    let leftNode = leftNodes[d2], def = definesContent(leftNode.type);
    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
      preferredDepth = d2;
    else if (def || !leftNode.type.isTextblock)
      break;
  }
  for (let j2 = slice.openStart; j2 >= 0; j2--) {
    let openDepth = (j2 + preferredDepth + 1) % (slice.openStart + 1);
    let insert = leftNodes[openDepth];
    if (!insert)
      continue;
    for (let i = 0; i < targetDepths.length; i++) {
      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index2 = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index2, index2, insert.type, insert.marks))
        return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));
    }
  }
  let startSteps = tr.steps.length;
  for (let i = targetDepths.length - 1; i >= 0; i--) {
    tr.replace(from, to, slice);
    if (tr.steps.length > startSteps)
      break;
    let depth = targetDepths[i];
    if (depth < 0)
      continue;
    from = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first = fragment.firstChild;
    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
  }
  if (depth > newOpen) {
    let match = parent.contentMatchAt(0);
    let start = match.fillBefore(fragment).append(fragment);
    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));
  }
  return fragment;
}
function replaceRangeWith(tr, from, to, node) {
  if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {
    let point = insertPoint(tr.doc, from, node.type);
    if (point != null)
      from = to = point;
  }
  tr.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0));
}
function deleteRange(tr, from, to) {
  let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);
  let covered = coveredDepths($from, $to);
  for (let i = 0; i < covered.length; i++) {
    let depth = covered[i], last = i == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr.delete($from.before(depth), $to.after(depth));
  }
  for (let d2 = 1; d2 <= $from.depth && d2 <= $to.depth; d2++) {
    if (from - $from.start(d2) == $from.depth - d2 && to > $from.end(d2) && $to.end(d2) - to != $to.depth - d2 && $from.start(d2 - 1) == $to.start(d2 - 1) && $from.node(d2 - 1).canReplace($from.index(d2 - 1), $to.index(d2 - 1)))
      return tr.delete($from.before(d2), to);
  }
  tr.delete(from, to);
}
function coveredDepths($from, $to) {
  let result = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d2 = minDepth; d2 >= 0; d2--) {
    let start = $from.start(d2);
    if (start < $from.pos - ($from.depth - d2) || $to.end(d2) > $to.pos + ($to.depth - d2) || $from.node(d2).type.spec.isolating || $to.node(d2).type.spec.isolating)
      break;
    if (start == $to.start(d2) || d2 == $from.depth && d2 == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d2 && $to.start(d2 - 1) == start - 1)
      result.push(d2);
  }
  return result;
}
class AttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(pos, attr, value) {
    super();
    this.pos = pos;
    this.attr = attr;
    this.value = value;
  }
  apply(doc2) {
    let node = doc2.nodeAt(this.pos);
    if (!node)
      return StepResult.fail("No node at attribute step's position");
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in node.attrs)
      attrs[name] = node.attrs[name];
    attrs[this.attr] = this.value;
    let updated = node.type.create(attrs, null, node.marks);
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc2) {
    return new AttrStep(this.pos, this.attr, doc2.nodeAt(this.pos).attrs[this.attr]);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number" || typeof json.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new AttrStep(json.pos, json.attr, json.value);
  }
}
Step.jsonID("attr", AttrStep);
class DocAttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(attr, value) {
    super();
    this.attr = attr;
    this.value = value;
  }
  apply(doc2) {
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in doc2.attrs)
      attrs[name] = doc2.attrs[name];
    attrs[this.attr] = this.value;
    let updated = doc2.type.create(attrs, doc2.content, doc2.marks);
    return StepResult.ok(updated);
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc2) {
    return new DocAttrStep(this.attr, doc2.attrs[this.attr]);
  }
  map(mapping) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new DocAttrStep(json.attr, json.value);
  }
}
Step.jsonID("docAttr", DocAttrStep);
let TransformError = class extends Error {
};
TransformError = function TransformError2(message) {
  let err = Error.call(this, message);
  err.__proto__ = TransformError2.prototype;
  return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
class Transform {
  /**
  Create a transform that starts with the given document.
  */
  constructor(doc2) {
    this.doc = doc2;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(step) {
    let result = this.maybeStep(step);
    if (result.failed)
      throw new TransformError(result.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(step) {
    let result = step.apply(this.doc);
    if (!result.failed)
      this.addStep(step, result.doc);
    return result;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(step, doc2) {
    this.docs.push(this.doc);
    this.steps.push(step);
    this.mapping.appendMap(step.getMap());
    this.doc = doc2;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(from, to = from, slice = Slice.empty) {
    let step = replaceStep(this.doc, from, to, slice);
    if (step)
      this.step(step);
    return this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(from, to, content) {
    return this.replace(from, to, new Slice(Fragment.from(content), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(from, to) {
    return this.replace(from, to, Slice.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(pos, content) {
    return this.replaceWith(pos, pos, content);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(from, to, slice) {
    replaceRange(this, from, to, slice);
    return this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(from, to, node) {
    replaceRangeWith(this, from, to, node);
    return this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(from, to) {
    deleteRange(this, from, to);
    return this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(range2, target) {
    lift(this, range2, target);
    return this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(pos, depth = 1) {
    join(this, pos, depth);
    return this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(range2, wrappers) {
    wrap(this, range2, wrappers);
    return this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(from, to = from, type2, attrs = null) {
    setBlockType(this, from, to, type2, attrs);
    return this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(pos, type2, attrs = null, marks) {
    setNodeMarkup(this, pos, type2, attrs, marks);
    return this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(pos, attr, value) {
    this.step(new AttrStep(pos, attr, value));
    return this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(attr, value) {
    this.step(new DocAttrStep(attr, value));
    return this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(pos, mark) {
    this.step(new AddNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(pos, mark) {
    let node = this.doc.nodeAt(pos);
    if (!node)
      throw new RangeError("No node at position " + pos);
    if (mark instanceof Mark) {
      if (mark.isInSet(node.marks))
        this.step(new RemoveNodeMarkStep(pos, mark));
    } else {
      let set = node.marks, found2, steps = [];
      while (found2 = mark.isInSet(set)) {
        steps.push(new RemoveNodeMarkStep(pos, found2));
        set = found2.removeFromSet(set);
      }
      for (let i = steps.length - 1; i >= 0; i--)
        this.step(steps[i]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(pos, depth = 1, typesAfter) {
    split(this, pos, depth, typesAfter);
    return this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(from, to, mark) {
    addMark(this, from, to, mark);
    return this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(from, to, mark) {
    removeMark(this, from, to, mark);
    return this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(pos, parentType, match) {
    clearIncompatible(this, pos, parentType, match);
    return this;
  }
}
const classesById = /* @__PURE__ */ Object.create(null);
class Selection {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++)
      if (ranges[i].$from.pos != ranges[i].$to.pos)
        return false;
    return true;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(tr, content = Slice.empty) {
    let lastNode = content.content.lastChild, lastParent = null;
    for (let i = 0; i < content.openEnd; i++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
      if (i == 0)
        selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(tr, node) {
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      let from = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i) {
        tr.deleteRange(from, to);
      } else {
        tr.replaceRangeWith(from, to, node);
        selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);
      }
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom($pos, dir, textOnly = false) {
    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(doc2) {
    return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(doc2) {
    return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(doc2, json) {
    if (!json || !json.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls = classesById[json.type];
    if (!cls)
      throw new RangeError(`No selection type ${json.type} defined`);
    return cls.fromJSON(doc2, json);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(id, selectionClass) {
    if (id in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id);
    classesById[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  }
}
Selection.prototype.visible = true;
class SelectionRange {
  /**
  Create a range.
  */
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
}
let warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
class TextSelection extends Selection {
  /**
  Construct a text selection between the given points.
  */
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc2, mapping) {
    let $head = doc2.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection.near($head);
    let $anchor = doc2.resolve(mapping.map(this.anchor));
    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr, content = Slice.empty) {
    super.replace(tr, content);
    if (content == Slice.empty) {
      let marks = this.$from.marksAcross(this.$to);
      if (marks)
        tr.ensureMarks(marks);
    }
  }
  eq(other) {
    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new TextSelection(doc2.resolve(json.anchor), doc2.resolve(json.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(doc2, anchor, head = anchor) {
    let $anchor = doc2.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new TextSelection($anchor, $head);
  }
}
Selection.jsonID("text", TextSelection);
class TextBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc2) {
    return TextSelection.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
  }
}
class NodeSelection extends Selection {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor($pos) {
    let node = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);
    super($pos, $end);
    this.node = node;
  }
  map(doc2, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc2.resolve(pos);
    if (deleted)
      return Selection.near($pos);
    return new NodeSelection($pos);
  }
  content() {
    return new Slice(Fragment.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof NodeSelection && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new NodeSelection(doc2.resolve(json.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(doc2, from) {
    return new NodeSelection(doc2.resolve(from));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(node) {
    return !node.isText && node.type.spec.selectable !== false;
  }
}
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
class NodeBookmark {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
  }
  resolve(doc2) {
    let $pos = doc2.resolve(this.anchor), node = $pos.nodeAfter;
    if (node && NodeSelection.isSelectable(node))
      return new NodeSelection($pos);
    return Selection.near($pos);
  }
}
class AllSelection extends Selection {
  /**
  Create an all-selection over the given document.
  */
  constructor(doc2) {
    super(doc2.resolve(0), doc2.resolve(doc2.content.size));
  }
  replace(tr, content = Slice.empty) {
    if (content == Slice.empty) {
      tr.delete(0, tr.doc.content.size);
      let sel = Selection.atStart(tr.doc);
      if (!sel.eq(tr.selection))
        tr.setSelection(sel);
    } else {
      super.replace(tr, content);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(doc2) {
    return new AllSelection(doc2);
  }
  map(doc2) {
    return new AllSelection(doc2);
  }
  eq(other) {
    return other instanceof AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
}
Selection.jsonID("all", AllSelection);
const AllBookmark = {
  map() {
    return this;
  },
  resolve(doc2) {
    return new AllSelection(doc2);
  }
};
function findSelectionIn(doc2, node, pos, index2, dir, text = false) {
  if (node.inlineContent)
    return TextSelection.create(doc2, pos);
  for (let i = index2 - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {
    let child = node.child(i);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc2, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner)
        return inner;
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc2, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd(tr, startLen, bias) {
  let last = tr.steps.length - 1;
  if (last < startLen)
    return;
  let step = tr.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  let map = tr.mapping.maps[last], end;
  map.forEach((_from, _to, _newFrom, newTo) => {
    if (end == null)
      end = newTo;
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
}
const UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;
class Transaction extends Transform {
  /**
  @internal
  */
  constructor(state2) {
    super(state2.doc);
    this.curSelectionFor = 0;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
    this.time = Date.now();
    this.curSelection = state2.selection;
    this.storedMarks = state2.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(marks) {
    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      this.setStoredMarks(marks);
    return this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0;
  }
  /**
  @internal
  */
  addStep(step, doc2) {
    super.addStep(step, doc2);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(time) {
    this.time = time;
    return this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(slice) {
    this.selection.replace(this, slice);
    return this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(node, inheritMarks = true) {
    let selection = this.selection;
    if (inheritMarks)
      node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
    selection.replaceWith(this, node);
    return this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    this.selection.replace(this);
    return this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(text, from, to) {
    let schema = this.doc.type.schema;
    if (from == null) {
      if (!text)
        return this.deleteSelection();
      return this.replaceSelectionWith(schema.text(text), true);
    } else {
      if (to == null)
        to = from;
      if (!text)
        return this.deleteRange(from, to);
      let marks = this.storedMarks;
      if (!marks) {
        let $from = this.doc.resolve(from);
        marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from, to, schema.text(text, marks));
      if (!this.selection.empty && this.selection.to == from + text.length)
        this.setSelection(Selection.near(this.selection.$to));
      return this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let _2 in this.meta)
      return false;
    return true;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0;
  }
}
function bind(f, self2) {
  return !self2 || !f ? f : f.bind(self2);
}
class FieldDesc {
  constructor(name, desc, self2) {
    this.name = name;
    this.init = bind(desc.init, self2);
    this.apply = bind(desc.apply, self2);
  }
}
const baseFields = [
  new FieldDesc("doc", {
    init(config2) {
      return config2.doc || config2.schema.topNodeType.createAndFill();
    },
    apply(tr) {
      return tr.doc;
    }
  }),
  new FieldDesc("selection", {
    init(config2, instance) {
      return config2.selection || Selection.atStart(instance.doc);
    },
    apply(tr) {
      return tr.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init(config2) {
      return config2.storedMarks || null;
    },
    apply(tr, _marks, _old, state2) {
      return state2.selection.$cursor ? tr.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr, prev) {
      return tr.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
class Configuration {
  constructor(schema, plugins) {
    this.schema = schema;
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */ Object.create(null);
    this.fields = baseFields.slice();
    if (plugins)
      plugins.forEach((plugin) => {
        if (this.pluginsByKey[plugin.key])
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
        this.plugins.push(plugin);
        this.pluginsByKey[plugin.key] = plugin;
        if (plugin.spec.state)
          this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
      });
  }
}
class EditorState {
  /**
  @internal
  */
  constructor(config2) {
    this.config = config2;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(tr) {
    return this.applyTransaction(tr).state;
  }
  /**
  @internal
  */
  filterTransaction(tr, ignore = -1) {
    for (let i = 0; i < this.config.plugins.length; i++)
      if (i != ignore) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))
          return false;
      }
    return true;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr))
      return { state: this, transactions: [] };
    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (; ; ) {
      let haveNew = false;
      for (let i = 0; i < this.config.plugins.length; i++) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.appendTransaction) {
          let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
          let tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
          if (tr && newState.filterTransaction(tr, i)) {
            tr.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (let j2 = 0; j2 < this.config.plugins.length; j2++)
                seen.push(j2 < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
            trs.push(tr);
            newState = newState.applyInner(tr);
            haveNew = true;
          }
          if (seen)
            seen[i] = { state: newState, n: trs.length };
        }
      }
      if (!haveNew)
        return { state: newState, transactions: trs };
    }
  }
  /**
  @internal
  */
  applyInner(tr) {
    if (!tr.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let newInstance = new EditorState(this.config), fields = this.config.fields;
    for (let i = 0; i < fields.length; i++) {
      let field = fields[i];
      newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
    }
    return newInstance;
  }
  /**
  Accessor that constructs and returns a new [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new Transaction(this);
  }
  /**
  Create a new state.
  */
  static create(config2) {
    let $config = new Configuration(config2.doc ? config2.doc.type.schema : config2.schema, config2.plugins);
    let instance = new EditorState($config);
    for (let i = 0; i < $config.fields.length; i++)
      instance[$config.fields[i].name] = $config.fields[i].init(config2, instance);
    return instance;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(config2) {
    let $config = new Configuration(this.schema, config2.plugins);
    let fields = $config.fields, instance = new EditorState($config);
    for (let i = 0; i < fields.length; i++) {
      let name = fields[i].name;
      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config2, instance);
    }
    return instance;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(pluginFields) {
    let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks)
      result.storedMarks = this.storedMarks.map((m2) => m2.toJSON());
    if (pluginFields && typeof pluginFields == "object")
      for (let prop in pluginFields) {
        if (prop == "doc" || prop == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let plugin = pluginFields[prop], state2 = plugin.spec.state;
        if (state2 && state2.toJSON)
          result[prop] = state2.toJSON.call(plugin, this[plugin.key]);
      }
    return result;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(config2, json, pluginFields) {
    if (!json)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!config2.schema)
      throw new RangeError("Required config field 'schema' missing");
    let $config = new Configuration(config2.schema, config2.plugins);
    let instance = new EditorState($config);
    $config.fields.forEach((field) => {
      if (field.name == "doc") {
        instance.doc = Node$1.fromJSON(config2.schema, json.doc);
      } else if (field.name == "selection") {
        instance.selection = Selection.fromJSON(instance.doc, json.selection);
      } else if (field.name == "storedMarks") {
        if (json.storedMarks)
          instance.storedMarks = json.storedMarks.map(config2.schema.markFromJSON);
      } else {
        if (pluginFields)
          for (let prop in pluginFields) {
            let plugin = pluginFields[prop], state2 = plugin.spec.state;
            if (plugin.key == field.name && state2 && state2.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance[field.name] = state2.fromJSON.call(plugin, config2, json[prop], instance);
              return;
            }
          }
        instance[field.name] = field.init(config2, instance);
      }
    });
    return instance;
  }
}
function bindProps(obj, self2, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self2);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self2, {});
    target[prop] = val;
  }
  return target;
}
class Plugin {
  /**
  Create a plugin.
  */
  constructor(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(state2) {
    return state2[this.key];
  }
}
const keys = /* @__PURE__ */ Object.create(null);
function createKey(name) {
  if (name in keys)
    return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}
class PluginKey {
  /**
  Create a plugin key.
  */
  constructor(name = "key") {
    this.key = createKey(name);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(state2) {
    return state2.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(state2) {
    return state2[this.key];
  }
}
function getThemeColor(name) {
  const colors = {
    accent1: "#5b9bd5",
    accent2: "#ed7d31",
    accent3: "#a5a5a5",
    accent4: "#ffc000",
    accent5: "#4472c4",
    accent6: "#70ad47",
    dk1: "#000000",
    lt1: "#ffffff",
    dk2: "#1f497d",
    lt2: "#eeece1",
    text1: "#000000",
    text2: "#1f497d",
    background1: "#ffffff",
    background2: "#eeece1",
    // Office XML shortcuts
    bg1: "#ffffff",
    bg2: "#eeece1"
  };
  return colors[name] ?? "#000000";
}
function applyColorModifier(hexColor, modifier, value) {
  const r = parseInt(hexColor.slice(1, 3), 16);
  const g = parseInt(hexColor.slice(3, 5), 16);
  const b2 = parseInt(hexColor.slice(5, 7), 16);
  const percent = parseInt(value) / 1e5;
  let newR, newG, newB;
  if (modifier === "shade" || modifier === "lumMod") {
    newR = r * percent;
    newG = g * percent;
    newB = b2 * percent;
  } else if (modifier === "tint") {
    newR = r + (255 - r) * percent;
    newG = g + (255 - g) * percent;
    newB = b2 + (255 - b2) * percent;
  } else if (modifier === "lumOff") {
    const offset = 255 * percent;
    newR = r + offset;
    newG = g + offset;
    newB = b2 + offset;
  } else {
    return hexColor;
  }
  const clamp = (n) => Math.max(0, Math.min(255, Math.round(n)));
  const toHex = (n) => n.toString(16).padStart(2, "0");
  newR = clamp(newR);
  newG = clamp(newG);
  newB = clamp(newB);
  const result = `#${toHex(newR)}${toHex(newG)}${toHex(newB)}`;
  return result;
}
function extractStrokeWidth(spPr) {
  const ln = spPr?.elements?.find((el) => el.name === "a:ln");
  const w2 = ln?.attributes?.["w"];
  if (!w2) return 1;
  const emu = typeof w2 === "string" ? parseFloat(w2) : w2;
  const STROKE_DPI = 72;
  return emu * STROKE_DPI / 914400;
}
function extractLineEnds(spPr) {
  const ln = spPr?.elements?.find((el) => el.name === "a:ln");
  if (!ln?.elements) return null;
  const parseEnd = (name) => {
    const end = ln.elements.find((el) => el.name === name);
    if (!end?.attributes) return null;
    const type2 = end.attributes?.["type"];
    if (!type2 || type2 === "none") return null;
    const width = end.attributes?.["w"];
    const length = end.attributes?.["len"];
    return { type: type2, width, length };
  };
  const head = parseEnd("a:headEnd");
  const tail = parseEnd("a:tailEnd");
  if (!head && !tail) return null;
  return { head: head ?? void 0, tail: tail ?? void 0 };
}
function extractStrokeColor(spPr, style) {
  const ln = spPr?.elements?.find((el) => el.name === "a:ln");
  if (ln) {
    const noFill = ln.elements?.find((el) => el.name === "a:noFill");
    if (noFill) return null;
    const solidFill = ln.elements?.find((el) => el.name === "a:solidFill");
    if (solidFill) {
      const schemeClr2 = solidFill.elements?.find((el) => el.name === "a:schemeClr");
      if (schemeClr2) {
        const themeName2 = schemeClr2.attributes?.["val"];
        let color2 = getThemeColor(themeName2);
        const modifiers2 = schemeClr2.elements || [];
        modifiers2.forEach((mod) => {
          if (mod.name === "a:shade") {
            color2 = applyColorModifier(color2, "shade", mod.attributes["val"]);
          } else if (mod.name === "a:tint") {
            color2 = applyColorModifier(color2, "tint", mod.attributes["val"]);
          } else if (mod.name === "a:lumMod") {
            color2 = applyColorModifier(color2, "lumMod", mod.attributes["val"]);
          }
        });
        return color2;
      }
      const srgbClr = solidFill.elements?.find((el) => el.name === "a:srgbClr");
      if (srgbClr) {
        return "#" + srgbClr.attributes?.["val"];
      }
    }
  }
  if (!style) return "#000000";
  const lnRef = style.elements?.find((el) => el.name === "a:lnRef");
  if (!lnRef) return "#000000";
  const schemeClr = lnRef.elements?.find((el) => el.name === "a:schemeClr");
  if (!schemeClr) return "#000000";
  const themeName = schemeClr.attributes?.["val"];
  let color = getThemeColor(themeName);
  const modifiers = schemeClr.elements || [];
  modifiers.forEach((mod) => {
    if (mod.name === "a:shade") {
      color = applyColorModifier(color, "shade", mod.attributes["val"]);
    } else if (mod.name === "a:tint") {
      color = applyColorModifier(color, "tint", mod.attributes["val"]);
    } else if (mod.name === "a:lumMod") {
      color = applyColorModifier(color, "lumMod", mod.attributes["val"]);
    } else if (mod.name === "a:lumOff") {
      color = applyColorModifier(color, "lumOff", mod.attributes["val"]);
    }
  });
  return color;
}
function extractFillColor(spPr, style) {
  const noFill = spPr?.elements?.find((el) => el.name === "a:noFill");
  if (noFill) return null;
  const solidFill = spPr?.elements?.find((el) => el.name === "a:solidFill");
  if (solidFill) {
    const schemeClr2 = solidFill.elements?.find((el) => el.name === "a:schemeClr");
    if (schemeClr2) {
      const themeName2 = schemeClr2.attributes?.["val"];
      let color2 = getThemeColor(themeName2);
      let alpha = null;
      const modifiers2 = schemeClr2.elements || [];
      modifiers2.forEach((mod) => {
        if (mod.name === "a:shade") {
          color2 = applyColorModifier(color2, "shade", mod.attributes["val"]);
        } else if (mod.name === "a:tint") {
          color2 = applyColorModifier(color2, "tint", mod.attributes["val"]);
        } else if (mod.name === "a:lumMod") {
          color2 = applyColorModifier(color2, "lumMod", mod.attributes["val"]);
        } else if (mod.name === "a:lumOff") {
          color2 = applyColorModifier(color2, "lumOff", mod.attributes["val"]);
        } else if (mod.name === "a:alpha") {
          alpha = parseInt(mod.attributes["val"]) / 1e5;
        }
      });
      if (alpha !== null && alpha < 1) {
        return { type: "solidWithAlpha", color: color2, alpha };
      }
      return color2;
    }
    const srgbClr = solidFill.elements?.find((el) => el.name === "a:srgbClr");
    if (srgbClr) {
      let alpha = null;
      const alphaEl = srgbClr.elements?.find((el) => el.name === "a:alpha");
      if (alphaEl) {
        alpha = parseInt(alphaEl.attributes?.["val"] || "100000", 10) / 1e5;
      }
      const color2 = "#" + srgbClr.attributes?.["val"];
      if (alpha !== null && alpha < 1) {
        return { type: "solidWithAlpha", color: color2, alpha };
      }
      return color2;
    }
  }
  const gradFill = spPr?.elements?.find((el) => el.name === "a:gradFill");
  if (gradFill) {
    return extractGradientFill(gradFill);
  }
  const blipFill = spPr?.elements?.find((el) => el.name === "a:blipFill");
  if (blipFill) {
    return "#cccccc";
  }
  if (!style) return "#5b9bd5";
  const fillRef = style.elements?.find((el) => el.name === "a:fillRef");
  if (!fillRef) return "#5b9bd5";
  const fillRefIdx = fillRef.attributes?.["idx"];
  if (fillRefIdx === "0") return null;
  const schemeClr = fillRef.elements?.find((el) => el.name === "a:schemeClr");
  if (!schemeClr) return "#5b9bd5";
  const themeName = schemeClr.attributes?.["val"];
  let color = getThemeColor(themeName);
  const modifiers = schemeClr.elements || [];
  modifiers.forEach((mod) => {
    if (mod.name === "a:shade") {
      color = applyColorModifier(color, "shade", mod.attributes["val"]);
    } else if (mod.name === "a:tint") {
      color = applyColorModifier(color, "tint", mod.attributes["val"]);
    } else if (mod.name === "a:lumMod") {
      color = applyColorModifier(color, "lumMod", mod.attributes["val"]);
    }
  });
  return color;
}
function extractGradientFill(gradFill) {
  const gradient = {
    type: "gradient",
    stops: [],
    angle: 0
  };
  const gsLst = gradFill.elements?.find((el) => el.name === "a:gsLst");
  if (gsLst) {
    const stops = gsLst.elements?.filter((el) => el.name === "a:gs") || [];
    gradient.stops = stops.map((stop) => {
      const pos = parseInt(stop.attributes?.["pos"] || "0", 10) / 1e5;
      const srgbClr = stop.elements?.find((el) => el.name === "a:srgbClr");
      let color = "#000000";
      let alpha = 1;
      if (srgbClr) {
        color = "#" + srgbClr.attributes?.["val"];
        const alphaEl = srgbClr.elements?.find((el) => el.name === "a:alpha");
        if (alphaEl) {
          alpha = parseInt(alphaEl.attributes?.["val"] || "100000", 10) / 1e5;
        }
      }
      return { position: pos, color, alpha };
    });
  }
  const lin = gradFill.elements?.find((el) => el.name === "a:lin");
  if (lin) {
    const ang = parseInt(lin.attributes?.["ang"] || "0", 10) / 6e4;
    gradient.angle = ang;
  }
  const path = gradFill.elements?.find((el) => el.name === "a:path");
  if (path) {
    gradient.gradientType = "radial";
    gradient.path = path.attributes?.["path"] || "circle";
  } else {
    gradient.gradientType = "linear";
  }
  return gradient;
}
class SVGFilters {
  flood(filter, resultId, color, opacity, _settings) {
    const floodElement = document.createElementNS("http://www.w3.org/2000/svg", "feFlood");
    if (resultId) {
      floodElement.setAttribute("id", resultId);
    }
    floodElement.setAttribute("flood-color", color);
    floodElement.setAttribute("flood-opacity", opacity.toString());
    filter.appendChild(floodElement);
  }
  composite(filter, resultId, in1, in2, _k1, _k2, _k3, _k4, _settings) {
    const compositeElement = document.createElementNS("http://www.w3.org/2000/svg", "feComposite");
    if (resultId) {
      compositeElement.setAttribute("id", resultId);
    }
    compositeElement.setAttribute("in", in1);
    compositeElement.setAttribute("in2", in2);
    filter.appendChild(compositeElement);
  }
}
class SVGPathBuilder {
  constructor() {
    this._path = "";
  }
  move(x2, y2) {
    this._path += ` M ${x2} ${y2}`;
  }
  path() {
    return this._path.substr(1);
  }
  line(pts) {
    pts.forEach((point) => {
      this._path += ` L ${point[0]} ${point[1]}`;
    });
  }
  curveC(x1, y1, x2, y2, x3, y3) {
    this._path += ` C ${x1} ${y1}, ${x2} ${y2}, ${x3} ${y3}`;
  }
  close() {
    this._path += ` Z`;
  }
}
class SVG {
  constructor(svg) {
    this.filters = new SVGFilters();
    this._defs = void 0;
    this._svg = svg;
  }
  svg(parent, x2, y2, width, height, settings) {
    const svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svgElement.setAttribute("x", x2.toString());
    svgElement.setAttribute("y", y2.toString());
    svgElement.setAttribute("width", width.toString());
    svgElement.setAttribute("height", height.toString());
    this._appendSettings(settings, svgElement);
    if (parent != null) {
      parent.appendChild(svgElement);
    } else {
      this._svg.appendChild(svgElement);
    }
    return svgElement;
  }
  image(parent, x2, y2, width, height, url, settings) {
    const imageElement = document.createElementNS("http://www.w3.org/2000/svg", "image");
    imageElement.setAttribute("x", x2.toString());
    imageElement.setAttribute("y", y2.toString());
    imageElement.setAttribute("width", width.toString());
    imageElement.setAttribute("height", height.toString());
    imageElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", url);
    this._appendSettings(settings, imageElement);
    parent.appendChild(imageElement);
    return imageElement;
  }
  rect(parent, x2, y2, width, height, rx, ry, settings) {
    const rectElement = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rectElement.setAttribute("x", x2.toString());
    rectElement.setAttribute("y", y2.toString());
    rectElement.setAttribute("width", width.toString());
    rectElement.setAttribute("height", height.toString());
    if (rx !== void 0) {
      if (rx instanceof Number) {
        rectElement.setAttribute("rx", rx.toString());
      } else if (rx instanceof Object) {
        this._appendSettings(rx, rectElement);
      }
    }
    if (ry !== void 0) {
      rectElement.setAttribute("ry", ry.toString());
    }
    this._appendSettings(settings, rectElement);
    parent.appendChild(rectElement);
    return rectElement;
  }
  line(parent, x1, y1, x2, y2, settings) {
    const lineElement = document.createElementNS("http://www.w3.org/2000/svg", "line");
    lineElement.setAttribute("x1", x1.toString());
    lineElement.setAttribute("y1", y1.toString());
    lineElement.setAttribute("x2", x2.toString());
    lineElement.setAttribute("y2", y2.toString());
    this._appendSettings(settings, lineElement);
    parent.appendChild(lineElement);
    return lineElement;
  }
  polygon(parent, points, settings) {
    const polygonElement = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    polygonElement.setAttribute("points", points.map((point) => point.join(",")).join(" "));
    this._appendSettings(settings, polygonElement);
    parent.appendChild(polygonElement);
    return polygonElement;
  }
  polyline(parent, points, settings) {
    const polylineElement = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
    polylineElement.setAttribute("points", points.map((point) => point.join(",")).join(" "));
    this._appendSettings(settings, polylineElement);
    parent.appendChild(polylineElement);
    return polylineElement;
  }
  ellipse(parent, cx, cy, rx, ry, settings) {
    const ellipseElement = document.createElementNS("http://www.w3.org/2000/svg", "ellipse");
    ellipseElement.setAttribute("cx", cx.toString());
    ellipseElement.setAttribute("cy", cy.toString());
    ellipseElement.setAttribute("rx", rx.toString());
    ellipseElement.setAttribute("ry", ry.toString());
    this._appendSettings(settings, ellipseElement);
    parent.appendChild(ellipseElement);
    return ellipseElement;
  }
  path(parent, builder, settings) {
    const pathElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
    pathElement.setAttribute("d", builder.path());
    this._appendSettings(settings, pathElement);
    parent.appendChild(pathElement);
    return pathElement;
  }
  text(parent, x2, y2, value, settings) {
    const textElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
    textElement.setAttribute("x", x2.toString());
    textElement.setAttribute("y", y2.toString());
    this._appendSettings(settings, textElement);
    const textNode = document.createTextNode(value);
    textElement.appendChild(textNode);
    parent.appendChild(textElement);
    return textElement;
  }
  filter(parent, id, x2, y2, width, height, settings) {
    const filterElement = document.createElementNS("http://www.w3.org/2000/svg", "filter");
    filterElement.setAttribute("x", x2.toString());
    filterElement.setAttribute("y", y2.toString());
    filterElement.setAttribute("width", width.toString());
    filterElement.setAttribute("height", height.toString());
    this._appendSettings(settings, filterElement);
    parent.appendChild(filterElement);
    return filterElement;
  }
  pattern(parent, resultId, x2, y2, width, height, settings) {
    const patternElement = document.createElementNS("http://www.w3.org/2000/svg", "pattern");
    if (resultId) {
      patternElement.setAttribute("id", resultId);
    }
    patternElement.setAttribute("x", x2.toString());
    patternElement.setAttribute("y", y2.toString());
    patternElement.setAttribute("width", width.toString());
    patternElement.setAttribute("height", height.toString());
    this._appendSettings(settings, patternElement);
    parent.appendChild(patternElement);
    return patternElement;
  }
  defs() {
    if (this._defs === void 0) {
      const defsElement = document.createElementNS("http://www.w3.org/2000/svg", "defs");
      this._svg.appendChild(defsElement);
      this._defs = defsElement;
    }
    return this._defs;
  }
  clipPath(parent, resultId, units, settings) {
    const clipElement = document.createElementNS("http://www.w3.org/2000/svg", "clipPath");
    if (resultId) {
      clipElement.setAttribute("id", resultId);
    }
    if (units === void 0) {
      units = "userSpaceOnUse";
    }
    clipElement.setAttribute("clipPathUnits", units);
    this._appendSettings(settings, clipElement);
    parent.appendChild(clipElement);
    return clipElement;
  }
  createPath() {
    return new SVGPathBuilder();
  }
  _appendSettings(settings, element) {
    if (settings !== void 0) {
      Object.keys(settings).forEach((key) => {
        element.setAttribute(key, settings[key]);
      });
    }
  }
}
class EMFJSError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, new.target.prototype);
  }
}
let isLoggingEnabled$1 = true;
function loggingEnabled$1(enabled) {
  isLoggingEnabled$1 = enabled;
}
let Helper$1 = (_a = class {
  static log(message) {
    if (isLoggingEnabled$1) {
      console.log(message);
    }
  }
  static _makeUniqueId(prefix) {
    return "EMFJS_" + prefix + this._uniqueId++;
  }
  static _writeUint32Val(uint8arr, pos, val) {
    uint8arr[pos++] = val & 255;
    uint8arr[pos++] = val >>> 8 & 255;
    uint8arr[pos++] = val >>> 16 & 255;
    uint8arr[pos++] = val >>> 24 & 255;
  }
  static _blobToBinary(blob) {
    let ret = "";
    const len = blob.length;
    for (let i = 0; i < len; i++) {
      ret += String.fromCharCode(blob[i]);
    }
    return ret;
  }
}, _a.GDI = {
  FormatSignature: {
    ENHMETA_SIGNATURE: 1179469088,
    EPS_SIGNATURE: 1179865157
  },
  BITMAPINFOHEADER_SIZE: 40,
  BITMAPCOREHEADER_SIZE: 12,
  RecordType: {
    EMR_POLYBEZIER: 2,
    EMR_POLYGON: 3,
    EMR_POLYLINE: 4,
    EMR_POLYBEZIERTO: 5,
    EMR_POLYLINETO: 6,
    EMR_POLYPOLYLINE: 7,
    EMR_POLYPOLYGON: 8,
    EMR_SETWINDOWEXTEX: 9,
    EMR_SETWINDOWORGEX: 10,
    EMR_SETVIEWPORTEXTEX: 11,
    EMR_SETVIEWPORTORGEX: 12,
    EMR_SETBRUSHORGEX: 13,
    EMR_EOF: 14,
    EMR_SETPIXELV: 15,
    EMR_SETMAPPERFLAGS: 16,
    EMR_SETMAPMODE: 17,
    EMR_SETBKMODE: 18,
    EMR_SETPOLYFILLMODE: 19,
    EMR_SETROP2: 20,
    EMR_SETSTRETCHBLTMODE: 21,
    EMR_SETTEXTALIGN: 22,
    EMR_SETCOLORADJUSTMENT: 23,
    EMR_SETTEXTCOLOR: 24,
    EMR_SETBKCOLOR: 25,
    EMR_OFFSETCLIPRGN: 26,
    EMR_MOVETOEX: 27,
    EMR_SETMETARGN: 28,
    EMR_EXCLUDECLIPRECT: 29,
    EMR_INTERSECTCLIPRECT: 30,
    EMR_SCALEVIEWPORTEXTEX: 31,
    EMR_SCALEWINDOWEXTEX: 32,
    EMR_SAVEDC: 33,
    EMR_RESTOREDC: 34,
    EMR_SETWORLDTRANSFORM: 35,
    EMR_MODIFYWORLDTRANSFORM: 36,
    EMR_SELECTOBJECT: 37,
    EMR_CREATEPEN: 38,
    EMR_CREATEBRUSHINDIRECT: 39,
    EMR_DELETEOBJECT: 40,
    EMR_ANGLEARC: 41,
    EMR_ELLIPSE: 42,
    EMR_RECTANGLE: 43,
    EMR_ROUNDRECT: 44,
    EMR_ARC: 45,
    EMR_CHORD: 46,
    EMR_PIE: 47,
    EMR_SELECTPALETTE: 48,
    EMR_CREATEPALETTE: 49,
    EMR_SETPALETTEENTRIES: 50,
    EMR_RESIZEPALETTE: 51,
    EMR_REALIZEPALETTE: 52,
    EMR_EXTFLOODFILL: 53,
    EMR_LINETO: 54,
    EMR_ARCTO: 55,
    EMR_POLYDRAW: 56,
    EMR_SETARCDIRECTION: 57,
    EMR_SETMITERLIMIT: 58,
    EMR_BEGINPATH: 59,
    EMR_ENDPATH: 60,
    EMR_CLOSEFIGURE: 61,
    EMR_FILLPATH: 62,
    EMR_STROKEANDFILLPATH: 63,
    EMR_STROKEPATH: 64,
    EMR_FLATTENPATH: 65,
    EMR_WIDENPATH: 66,
    EMR_SELECTCLIPPATH: 67,
    EMR_ABORTPATH: 68,
    EMR_COMMENT: 70,
    EMR_FILLRGN: 71,
    EMR_FRAMERGN: 72,
    EMR_INVERTRGN: 73,
    EMR_PAINTRGN: 74,
    EMR_EXTSELECTCLIPRGN: 75,
    EMR_BITBLT: 76,
    EMR_STRETCHBLT: 77,
    EMR_MASKBLT: 78,
    EMR_PLGBLT: 79,
    EMR_SETDIBITSTODEVICE: 80,
    EMR_STRETCHDIBITS: 81,
    EMR_EXTCREATEFONTINDIRECTW: 82,
    EMR_EXTTEXTOUTA: 83,
    EMR_EXTTEXTOUTW: 84,
    EMR_POLYBEZIER16: 85,
    EMR_POLYGON16: 86,
    EMR_POLYLINE16: 87,
    EMR_POLYBEZIERTO16: 88,
    EMR_POLYLINETO16: 89,
    EMR_POLYPOLYLINE16: 90,
    EMR_POLYPOLYGON16: 91,
    EMR_POLYDRAW16: 92,
    EMR_CREATEMONOBRUSH: 93,
    EMR_CREATEDIBPATTERNBRUSHPT: 94,
    EMR_EXTCREATEPEN: 95,
    EMR_POLYTEXTOUTA: 96,
    EMR_POLYTEXTOUTW: 97,
    EMR_SETICMMODE: 98,
    EMR_CREATECOLORSPACE: 99,
    EMR_SETCOLORSPACE: 100,
    EMR_DELETECOLORSPACE: 101,
    EMR_GLSRECORD: 102,
    EMR_GLSBOUNDEDRECORD: 103,
    EMR_PIXELFORMAT: 104,
    EMR_DRAWESCAPE: 105,
    EMR_EXTESCAPE: 106,
    EMR_SMALLTEXTOUT: 108,
    EMR_FORCEUFIMAPPING: 109,
    EMR_NAMEDESCAPE: 110,
    EMR_COLORCORRECTPALETTE: 111,
    EMR_SETICMPROFILEA: 112,
    EMR_SETICMPROFILEW: 113,
    EMR_ALPHABLEND: 114,
    EMR_SETLAYOUT: 115,
    EMR_TRANSPARENTBLT: 116,
    EMR_GRADIENTFILL: 118,
    EMR_SETLINKEDUFIS: 119,
    EMR_SETTEXTJUSTIFICATION: 120,
    EMR_COLORMATCHTOTARGETW: 121,
    EMR_CREATECOLORSPACEW: 122
  },
  MetafileEscapes: {
    NEWFRAME: 1,
    ABORTDOC: 2,
    NEXTBAND: 3,
    SETCOLORTABLE: 4,
    GETCOLORTABLE: 5,
    FLUSHOUT: 6,
    DRAFTMODE: 7,
    QUERYESCSUPPORT: 8,
    SETABORTPROC: 9,
    STARTDOC: 10,
    ENDDOC: 11,
    GETPHYSPAGESIZE: 12,
    GETPRINTINGOFFSET: 13,
    GETSCALINGFACTOR: 14,
    META_ESCAPE_ENHANCED_METAFILE: 15,
    SETPENWIDTH: 16,
    SETCOPYCOUNT: 17,
    SETPAPERSOURCE: 18,
    PASSTHROUGH: 19,
    GETTECHNOLOGY: 20,
    SETLINECAP: 21,
    SETLINEJOIN: 22,
    SETMITERLIMIT: 23,
    BANDINFO: 24,
    DRAWPATTERNRECT: 25,
    GETVECTORPENSIZE: 26,
    GETVECTORBRUSHSIZE: 27,
    ENABLEDUPLEX: 28,
    GETSETPAPERBINS: 29,
    GETSETPRINTORIENT: 30,
    ENUMPAPERBINS: 31,
    SETDIBSCALING: 32,
    EPSPRINTING: 33,
    ENUMPAPERMETRICS: 34,
    GETSETPAPERMETRICS: 35,
    POSTSCRIPT_DATA: 37,
    POSTSCRIPT_IGNORE: 38,
    GETDEVICEUNITS: 42,
    GETEXTENDEDTEXTMETRICS: 256,
    GETPAIRKERNTABLE: 258,
    EXTTEXTOUT: 512,
    GETFACENAME: 513,
    DOWNLOADFACE: 514,
    METAFILE_DRIVER: 2049,
    QUERYDIBSUPPORT: 3073,
    BEGIN_PATH: 4096,
    CLIP_TO_PATH: 4097,
    END_PATH: 4098,
    OPEN_CHANNEL: 4110,
    DOWNLOADHEADER: 4111,
    CLOSE_CHANNEL: 4112,
    POSTSCRIPT_PASSTHROUGH: 4115,
    ENCAPSULATED_POSTSCRIPT: 4116,
    POSTSCRIPT_IDENTIFY: 4117,
    POSTSCRIPT_INJECTION: 4118,
    CHECKJPEGFORMAT: 4119,
    CHECKPNGFORMAT: 4120,
    GET_PS_FEATURESETTING: 4121,
    MXDC_ESCAPE: 4122,
    SPCLPASSTHROUGH2: 4568
  },
  MapMode: {
    MM_TEXT: 1,
    MM_LOMETRIC: 2,
    MM_HIMETRIC: 3,
    MM_LOENGLISH: 4,
    MM_HIENGLISH: 5,
    MM_TWIPS: 6,
    MM_ISOTROPIC: 7,
    MM_ANISOTROPIC: 8
  },
  StretchMode: {
    BLACKONWHITE: 1,
    WHITEONBLACK: 2,
    COLORONCOLOR: 3,
    HALFTONE: 4
  },
  MixMode: {
    TRANSPARENT: 1,
    OPAQUE: 2
  },
  BrushStyle: {
    BS_SOLID: 0,
    BS_NULL: 1,
    BS_HATCHED: 2,
    BS_PATTERN: 3,
    BS_INDEXED: 4,
    BS_DIBPATTERN: 5,
    BS_DIBPATTERNPT: 6,
    BS_PATTERN8X8: 7,
    BS_DIBPATTERN8X8: 8,
    BS_MONOPATTERN: 9
  },
  PenStyle: {
    PS_COSMETIC: 0,
    PS_ENDCAP_ROUND: 0,
    PS_JOIN_ROUND: 0,
    PS_SOLID: 0,
    PS_DASH: 1,
    PS_DOT: 2,
    PS_DASHDOT: 3,
    PS_DASHDOTDOT: 4,
    PS_NULL: 5,
    PS_INSIDEFRAME: 6,
    PS_USERSTYLE: 7,
    PS_ALTERNATE: 8,
    PS_ENDCAP_SQUARE: 256,
    PS_ENDCAP_FLAT: 512,
    PS_JOIN_BEVEL: 4096,
    PS_JOIN_MITER: 8192,
    PS_GEOMETRIC: 65536
  },
  PolygonFillMode: {
    ALTERNATE: 1,
    WINDING: 2
  },
  BitmapCompression: {
    BI_RGB: 0,
    BI_RLE8: 1,
    BI_RLE4: 2,
    BI_BITFIELDS: 3,
    BI_JPEG: 4,
    BI_PNG: 5
  },
  RegionMode: {
    RGN_AND: 1,
    RGN_OR: 2,
    RGN_XOR: 3,
    RGN_DIFF: 4,
    RGN_COPY: 5
  },
  StockObject: {
    WHITE_BRUSH: 2147483648,
    LTGRAY_BRUSH: 2147483649,
    GRAY_BRUSH: 2147483650,
    DKGRAY_BRUSH: 2147483651,
    BLACK_BRUSH: 2147483652,
    NULL_BRUSH: 2147483653,
    WHITE_PEN: 2147483654,
    BLACK_PEN: 2147483655,
    NULL_PEN: 2147483656,
    OEM_FIXED_FONT: 2147483658,
    ANSI_FIXED_FONT: 2147483659,
    ANSI_VAR_FONT: 2147483660,
    SYSTEM_FONT: 2147483661,
    DEVICE_DEFAULT_FONT: 2147483662,
    DEFAULT_PALETTE: 2147483663,
    SYSTEM_FIXED_FONT: 2147483664,
    DEFAULT_GUI_FONT: 2147483665,
    DC_BRUSH: 2147483666,
    DC_PEN: 2147483667
  }
}, _a._uniqueId = 0, _a);
let Blob$2 = class Blob2 {
  constructor(blob, offset) {
    if (blob instanceof Blob2) {
      this.blob = blob.blob;
      this.data = blob.data;
      this.pos = offset || blob.pos;
    } else {
      this.blob = blob;
      this.data = new Uint8Array(blob);
      this.pos = offset || 0;
    }
  }
  eof() {
    return this.pos >= this.data.length;
  }
  seek(newpos) {
    if (newpos < 0 || newpos > this.data.length) {
      throw new EMFJSError("Invalid seek position");
    }
    this.pos = newpos;
  }
  skip(cnt) {
    const newPos = this.pos + cnt;
    if (newPos > this.data.length) {
      throw new EMFJSError("Unexpected end of file");
    }
    this.pos = newPos;
  }
  readBinary(cnt) {
    const end = this.pos + cnt;
    if (end > this.data.length) {
      throw new EMFJSError("Unexpected end of file");
    }
    let ret = "";
    while (cnt-- > 0) {
      ret += String.fromCharCode(this.data[this.pos++]);
    }
    return ret;
  }
  readInt8() {
    if (this.pos + 1 > this.data.length) {
      throw new EMFJSError("Unexpected end of file");
    }
    return this.data[this.pos++];
  }
  readUint8() {
    return this.readInt8() >>> 0;
  }
  readInt32() {
    if (this.pos + 4 > this.data.length) {
      throw new EMFJSError("Unexpected end of file");
    }
    let val = this.data[this.pos++];
    val |= this.data[this.pos++] << 8;
    val |= this.data[this.pos++] << 16;
    val |= this.data[this.pos++] << 24;
    return val;
  }
  readUint32() {
    return this.readInt32() >>> 0;
  }
  readUint16() {
    if (this.pos + 2 > this.data.length) {
      throw new EMFJSError("Unexpected end of file");
    }
    let val = this.data[this.pos++];
    val |= this.data[this.pos++] << 8;
    return val;
  }
  readInt16() {
    let val = this.readUint16();
    if (val > 32767) {
      val -= 65536;
    }
    return val;
  }
  readString(length) {
    if (this.pos + length > this.data.length) {
      throw new EMFJSError("Unexpected end of file");
    }
    let ret = "";
    for (let i = 0; i < length; i++) {
      ret += String.fromCharCode(this.data[this.pos++] >>> 0);
    }
    return ret;
  }
  readNullTermString(maxSize) {
    let ret = "";
    if (maxSize > 0) {
      maxSize--;
      for (let i = 0; i < maxSize; i++) {
        if (this.pos + i + 1 > this.data.length) {
          throw new EMFJSError("Unexpected end of file");
        }
        const byte = this.data[this.pos + i] >>> 0;
        if (byte === 0) {
          break;
        }
        ret += String.fromCharCode(byte);
      }
    }
    return ret;
  }
  readFixedSizeUnicodeString(fixedSizeChars) {
    let ret = "";
    for (let i = 0; i < fixedSizeChars; i++) {
      const charCode = this.readUint16();
      if (charCode === 0) {
        if (++i < fixedSizeChars) {
          this.skip((fixedSizeChars - i) * 2);
        }
        break;
      }
      ret += String.fromCharCode(charCode);
    }
    return ret;
  }
};
let PointS$1 = class PointS {
  constructor(reader, x2, y2) {
    if (reader != null) {
      this.x = reader.readInt16();
      this.y = reader.readInt16();
    } else {
      this.x = x2;
      this.y = y2;
    }
  }
  clone() {
    return new PointS(null, this.x, this.y);
  }
  toString() {
    return "{x: " + this.x + ", y: " + this.y + "}";
  }
};
class PointL {
  constructor(reader, x2, y2) {
    if (reader != null) {
      this.x = reader.readInt32();
      this.y = reader.readInt32();
    } else {
      this.x = x2;
      this.y = y2;
    }
  }
  clone() {
    return new PointL(null, this.x, this.y);
  }
  toString() {
    return "{x: " + this.x + ", y: " + this.y + "}";
  }
}
class RectL {
  constructor(reader, left, top, right, bottom) {
    if (reader != null) {
      this.left = reader.readInt32();
      this.top = reader.readInt32();
      this.right = reader.readInt32();
      this.bottom = reader.readInt32();
    } else {
      this.bottom = bottom;
      this.right = right;
      this.top = top;
      this.left = left;
    }
  }
  clone() {
    return new RectL(null, this.left, this.top, this.right, this.bottom);
  }
  toString() {
    return "{left: " + this.left + ", top: " + this.top + ", right: " + this.right + ", bottom: " + this.bottom + "}";
  }
  empty() {
    return this.left >= this.right || this.top >= this.bottom;
  }
  intersect(rectL) {
    if (this.empty() || rectL.empty()) {
      return null;
    }
    if (this.left >= rectL.right || this.top >= rectL.bottom || this.right <= rectL.left || this.bottom <= rectL.top) {
      return null;
    }
    return new RectL(
      null,
      Math.max(this.left, rectL.left),
      Math.max(this.top, rectL.top),
      Math.min(this.right, rectL.right),
      Math.min(this.bottom, rectL.bottom)
    );
  }
}
class SizeL {
  constructor(reader, cx, cy) {
    if (reader != null) {
      this.cx = reader.readUint32();
      this.cy = reader.readUint32();
    } else {
      this.cx = cx;
      this.cy = cy;
    }
  }
  clone() {
    return new SizeL(null, this.cx, this.cy);
  }
  toString() {
    return "{cx: " + this.cx + ", cy: " + this.cy + "}";
  }
}
let Obj$1 = class Obj {
  constructor(type2) {
    this.type = type2;
  }
  clone() {
    throw new EMFJSError("clone not implemented");
  }
  toString() {
    throw new EMFJSError("toString not implemented");
  }
};
let Region$1 = class Region extends Obj$1 {
  constructor(reader, copy2) {
    super("region");
    if (reader != null) {
      const hdrSize = reader.readUint32();
      if (hdrSize !== 32) {
        throw new EMFJSError("Invalid region header");
      }
      reader.skip(4);
      const rectCnt = reader.readUint32();
      const rgnSize = reader.readUint32();
      if (rectCnt * 16 !== rgnSize) {
        throw new EMFJSError("Invalid region data");
      }
      this.bounds = new RectL(reader);
      this.scans = [];
      let scanLine;
      for (let i = 0; i < rectCnt; i++) {
        const r = new RectL(reader);
        if (!!scanLine || scanLine.top !== r.top || scanLine.bottom !== r.bottom) {
          scanLine = new Scan$1(r);
          this.scans.push(scanLine);
        } else {
          scanLine.append(r);
        }
      }
      this._updateComplexity();
    } else if (copy2 != null) {
      this.bounds = copy2.bounds != null ? copy2.bounds.clone() : null;
      if (copy2.scans != null) {
        this.scans = [];
        for (let i = 0; i < copy2.scans.length; i++) {
          this.scans.push(copy2.scans[i].clone());
        }
      } else {
        this.scans = null;
      }
      this.complexity = copy2.complexity;
    } else {
      this.bounds = null;
      this.scans = null;
      this.complexity = 0;
    }
  }
  clone() {
    return new Region(null, this);
  }
  toString() {
    const _complexity = ["null", "simple", "complex"];
    return "{complexity: " + _complexity[this.complexity] + " bounds: " + (this.bounds != null ? this.bounds.toString() : "[none]") + " #scans: " + (this.scans != null ? this.scans.length : "[none]") + "}";
  }
  _updateComplexity() {
    if (this.bounds == null) {
      this.complexity = 0;
      this.scans = null;
    } else if (this.bounds.empty()) {
      this.complexity = 0;
      this.scans = null;
      this.bounds = null;
    } else if (this.scans == null) {
      this.complexity = 1;
    } else {
      this.complexity = 2;
      if (this.scans.length === 1) {
        const scan = this.scans[0];
        if (scan.top === this.bounds.top && scan.bottom === this.bounds.bottom && scan.scanlines.length === 1) {
          const scanline = scan.scanlines[0];
          if (scanline.left === this.bounds.left && scanline.right === this.bounds.right) {
            this.scans = null;
            this.complexity = 1;
          }
        }
      }
    }
  }
  subtract(rect) {
    Helper$1.log("[emf] Region " + this.toString() + " subtract " + rect.toString());
    if (this.bounds != null) {
      const isect = this.bounds.intersect(rect);
      if (isect != null) {
        if (this.scans == null) {
          this.scans = [];
          this.scans.push(
            new Scan$1(new RectL(null, this.bounds.left, this.bounds.top, this.bounds.right, this.bounds.bottom))
          );
          this.complexity = 2;
        }
        let si = 0;
        while (si < this.scans.length) {
          const scan = this.scans[si];
          if (scan.bottom >= rect.top) {
            const cloned = scan.clone();
            scan.bottom = rect.top - 1;
            cloned.top = rect.top;
            if (scan.top >= scan.bottom) {
              this.scans[si] = cloned;
            } else {
              Helper$1.log("[emf] Region split top scan " + si + " for substraction");
              this.scans.splice(++si, 0, cloned);
            }
            break;
          }
          si++;
        }
        const first = si;
        while (si < this.scans.length) {
          const scan = this.scans[si];
          if (scan.top > rect.bottom) {
            break;
          }
          if (scan.bottom > rect.bottom) {
            const cloned = scan.clone();
            scan.bottom = rect.bottom;
            cloned.top = rect.bottom + 1;
            if (scan.top >= scan.bottom) {
              this.scans[si] = cloned;
            } else {
              Helper$1.log("[emf] Region split bottom scan " + si + " for substraction");
              this.scans.splice(++si, 0, cloned);
            }
            break;
          }
          si++;
        }
        if (first < this.scans.length) {
          let last = si;
          si = first;
          while (si < last) {
            const scan = this.scans[si];
            if (!scan.subtract(rect.left, rect.right)) {
              Helper$1.log("[emf] Region remove now empty scan " + si + " due to subtraction");
              this.scans.splice(si, 1);
              last--;
              continue;
            }
            si++;
          }
        }
        if (this.scans != null) {
          let left;
          let top;
          let right;
          let bottom;
          const len = this.scans.length;
          for (let i = 0; i < len; i++) {
            const scan = this.scans[i];
            if (i === 0) {
              top = scan.top;
            }
            if (i === len - 1) {
              bottom = scan.bottom;
            }
            const slen = scan.scanlines.length;
            if (slen > 0) {
              let scanline = scan.scanlines[0];
              if (left == null || scanline.left < left) {
                left = scanline.left;
              }
              scanline = scan.scanlines[slen - 1];
              if (right == null || scanline.right > right) {
                right = scanline.right;
              }
            }
          }
          if (left != null && top != null && right != null && bottom != null) {
            this.bounds = new RectL(null, left, top, right, bottom);
            this._updateComplexity();
          } else {
            this.bounds = null;
            this.scans = null;
            this.complexity = 0;
          }
        } else {
          this._updateComplexity();
        }
      }
    }
    Helper$1.log("[emf] Region subtraction -> " + this.toString());
  }
  intersect(rect) {
    Helper$1.log("[emf] Region " + this.toString() + " intersect with " + rect.toString());
    if (this.bounds != null) {
      this.bounds = this.bounds.intersect(rect);
      if (this.bounds != null) {
        if (this.scans != null) {
          let si = 0;
          while (si < this.scans.length) {
            const scan = this.scans[si];
            if (scan.bottom < this.bounds.top) {
              si++;
            } else {
              break;
            }
          }
          if (si > 0) {
            Helper$1.log("[emf] Region remove " + si + " scans from top");
            this.scans.splice(0, si);
            if (this.scans.length > 0) {
              this.scans[0].top = this.bounds.top;
            }
          }
          si = 0;
          while (si < this.scans.length) {
            const scan = this.scans[si];
            if (scan.top > this.bounds.bottom) {
              Helper$1.log("[emf] Region remove " + (this.scans.length - si) + " scans from bottom");
              this.scans.splice(si, this.scans.length - si);
              break;
            }
            if (!scan.intersect(this.bounds.left, this.bounds.right)) {
              Helper$1.log("[emf] Region remove now empty scan " + si + " due to intersection");
              this.scans.splice(si, 1);
              continue;
            }
            si++;
          }
          if (this.scans.length > 0) {
            this.scans[this.scans.length - 1].bottom = this.bounds.bottom;
          }
          this._updateComplexity();
        }
      } else {
        this.scans = null;
        this.complexity = 0;
      }
    }
    Helper$1.log("[emf] Region intersection -> " + this.toString());
  }
  offset(offX, offY) {
    if (this.bounds != null) {
      this.bounds.left += offX;
      this.bounds.top += offY;
      this.bounds.right += offX;
      this.bounds.bottom += offY;
    }
    if (this.scans != null) {
      const slen = this.scans.length;
      for (let si = 0; si < slen; si++) {
        const scan = this.scans[si];
        scan.top += offY;
        scan.bottom += offY;
        const len = scan.scanlines.length;
        for (let i = 0; i < len; i++) {
          const scanline = scan.scanlines[i];
          scanline.left += offX;
          scanline.right += offX;
        }
      }
    }
  }
};
function CreateSimpleRegion$1(left, top, right, bottom) {
  const rgn = new Region$1(null, null);
  rgn.bounds = new RectL(null, left, top, right, bottom);
  rgn._updateComplexity();
  return rgn;
}
let Scan$1 = class Scan {
  constructor(r, copy2) {
    if (r != null) {
      this.top = r.top;
      this.bottom = r.bottom;
      this.scanlines = [{ left: r.left, right: r.right }];
    } else if (copy2 != null) {
      this.top = copy2.top;
      this.bottom = copy2.bottom;
      this.scanlines = [];
      for (let i = 0; i < copy2.scanlines.length; i++) {
        const scanline = copy2.scanlines[i];
        this.scanlines.push({ left: scanline.left, right: scanline.right });
      }
    }
  }
  clone() {
    return new Scan(null, this);
  }
  append(r) {
    this.scanlines.push({ left: r.left, right: r.right });
  }
  subtract(left, right) {
    let i;
    i = 0;
    while (i < this.scanlines.length) {
      const scanline = this.scanlines[i];
      if (scanline.left <= left) {
        if (scanline.right >= left) {
          scanline.right = left - 1;
          if (scanline.left >= scanline.right) {
            this.scanlines.splice(i, 1);
            continue;
          }
        }
        i++;
      } else {
        break;
      }
    }
    const first = i;
    let cnt = 0;
    while (i < this.scanlines.length) {
      const scanline = this.scanlines[i];
      if (scanline.right > right) {
        scanline.left = right;
        cnt = i - first;
        if (scanline.left >= scanline.right) {
          cnt++;
        }
        break;
      }
      i++;
    }
    if (cnt > 0 && first < this.scanlines.length) {
      this.scanlines.splice(first, cnt);
    }
    return this.scanlines.length > 0;
  }
  intersect(left, right) {
    for (let i = 0; i < this.scanlines.length; i++) {
      const scanline = this.scanlines[i];
      if (scanline.left >= left || scanline.right >= left) {
        if (i > 0) {
          this.scanlines.splice(0, i);
        }
        break;
      }
    }
    if (this.scanlines.length > 0) {
      let scanline = this.scanlines[0];
      if (scanline.left < left) {
        scanline.left = left;
      }
      for (let i = 0; i < this.scanlines.length; i++) {
        scanline = this.scanlines[i];
        if (scanline.left > right) {
          this.scanlines.splice(i, this.scanlines.length - i);
          break;
        }
      }
      if (this.scanlines.length > 0) {
        scanline = this.scanlines[this.scanlines.length - 1];
        if (scanline.right > right) {
          scanline.right = right;
        }
      }
    }
    return this.scanlines.length > 0;
  }
};
let BitmapCoreHeader$1 = class BitmapCoreHeader {
  constructor(reader, skipsize) {
    if (skipsize) {
      reader.skip(4);
    }
    this.width = reader.readUint16();
    this.height = reader.readUint16();
    this.planes = reader.readUint16();
    this.bitcount = reader.readUint16();
  }
  colors() {
    return this.bitcount <= 8 ? 1 << this.bitcount : 0;
  }
};
let BitmapInfoHeader$1 = class BitmapInfoHeader {
  constructor(reader, skipsize) {
    if (skipsize) {
      reader.skip(4);
    }
    this.width = reader.readInt32();
    this.height = reader.readInt32();
    this.planes = reader.readUint16();
    this.bitcount = reader.readUint16();
    this.compression = reader.readUint32();
    this.sizeimage = reader.readUint32();
    this.xpelspermeter = reader.readInt32();
    this.ypelspermeter = reader.readInt32();
    this.clrused = reader.readUint32();
    this.clrimportant = reader.readUint32();
  }
  colors() {
    if (this.clrused !== 0) {
      return this.clrused < 256 ? this.clrused : 256;
    } else {
      return this.bitcount > 8 ? 0 : 1 << this.bitcount;
    }
  }
};
let BitmapInfo$1 = class BitmapInfo {
  constructor(reader, usergb) {
    this._usergb = usergb;
    const hdrsize = reader.readUint32();
    this._infosize = hdrsize;
    if (hdrsize === Helper$1.GDI.BITMAPCOREHEADER_SIZE) {
      this._header = new BitmapCoreHeader$1(reader, false);
      this._infosize += this._header.colors() * (usergb ? 3 : 2);
    } else {
      this._header = new BitmapInfoHeader$1(reader, false);
      const masks = this._header.compression === Helper$1.GDI.BitmapCompression.BI_BITFIELDS ? 3 : 0;
      if (hdrsize <= Helper$1.GDI.BITMAPINFOHEADER_SIZE + masks * 4) {
        this._infosize = Helper$1.GDI.BITMAPINFOHEADER_SIZE + masks * 4;
      }
      this._infosize += this._header.colors() * (usergb ? 4 : 2);
    }
  }
  getWidth() {
    return this._header.width;
  }
  getHeight() {
    return Math.abs(this._header.height);
  }
  infosize() {
    return this._infosize;
  }
  header() {
    return this._header;
  }
};
let DIBitmap$1 = class DIBitmap {
  constructor(reader, bitmapInfo) {
    this._reader = reader;
    this._offset = reader.pos;
    this._location = bitmapInfo;
    this._info = new BitmapInfo$1(reader, true);
  }
  getWidth() {
    return this._info.getWidth();
  }
  getHeight() {
    return this._info.getHeight();
  }
  totalSize() {
    return this._location.header.size + this._location.data.size;
  }
  makeBitmapFileHeader() {
    const buf = new ArrayBuffer(14);
    const view = new Uint8Array(buf);
    view[0] = 66;
    view[1] = 77;
    Helper$1._writeUint32Val(view, 2, this.totalSize() + 14);
    Helper$1._writeUint32Val(view, 10, this._info.infosize() + 14);
    return Helper$1._blobToBinary(view);
  }
  base64ref() {
    const prevpos = this._reader.pos;
    this._reader.seek(this._offset);
    let mime = "image/bmp";
    const header = this._info.header();
    let data;
    if (header instanceof BitmapInfoHeader$1 && header.compression != null) {
      switch (header.compression) {
        case Helper$1.GDI.BitmapCompression.BI_JPEG:
          mime = "data:image/jpeg";
          break;
        case Helper$1.GDI.BitmapCompression.BI_PNG:
          mime = "data:image/png";
          break;
        default:
          data = this.makeBitmapFileHeader();
          break;
      }
    } else {
      data = this.makeBitmapFileHeader();
    }
    this._reader.seek(this._location.header.offset);
    if (data != null) {
      data += this._reader.readBinary(this._location.header.size);
    } else {
      data = this._reader.readBinary(this._location.header.size);
    }
    this._reader.seek(this._location.data.offset);
    data += this._reader.readBinary(this._location.data.size);
    const ref2 = "data:" + mime + ";base64," + btoa(data);
    this._reader.seek(prevpos);
    return ref2;
  }
};
let ColorRef$1 = class ColorRef {
  constructor(reader, r, g, b2) {
    if (reader != null) {
      this.r = reader.readUint8();
      this.g = reader.readUint8();
      this.b = reader.readUint8();
      reader.skip(1);
    } else {
      this.r = r;
      this.g = g;
      this.b = b2;
    }
  }
  clone() {
    return new ColorRef(null, this.r, this.g, this.b);
  }
  toHex() {
    const rgb = this.r << 16 | this.g << 8 | this.b;
    return (16777216 + rgb).toString(16).slice(1);
  }
  toString() {
    return "{r: " + this.r + ", g: " + this.g + ", b: " + this.b + "}";
  }
};
let Font$1 = class Font extends Obj$1 {
  constructor(reader, copy2) {
    super("font");
    if (reader != null) {
      this.height = reader.readInt32();
      this.width = reader.readInt32();
      this.escapement = reader.readInt32();
      this.orientation = reader.readInt32();
      this.weight = reader.readInt32();
      this.italic = reader.readUint8();
      this.underline = reader.readUint8();
      this.strikeout = reader.readUint8();
      this.charset = reader.readUint8();
      this.outprecision = reader.readUint8();
      this.clipprecision = reader.readUint8();
      this.quality = reader.readUint8();
      const pitchAndFamily = reader.readUint8();
      this.pitch = pitchAndFamily & 15;
      this.family = pitchAndFamily >> 6 & 3;
      const dataLength = copy2;
      const start = reader.pos;
      this.facename = reader.readFixedSizeUnicodeString(Math.min(dataLength - (reader.pos - start), 32));
    } else if (copy2 != null) {
      copy2 = copy2;
      this.height = copy2.height;
      this.width = copy2.width;
      this.escapement = copy2.escapement;
      this.orientation = copy2.orientation;
      this.weight = copy2.weight;
      this.italic = copy2.italic;
      this.underline = copy2.underline;
      this.strikeout = copy2.strikeout;
      this.charset = copy2.charset;
      this.outprecision = copy2.outprecision;
      this.clipprecision = copy2.clipprecision;
      this.quality = copy2.quality;
      this.pitch = copy2.pitch;
      this.family = copy2.family;
      this.facename = copy2.facename;
    } else {
      this.height = -80;
      this.width = 0;
      this.escapement = 0;
      this.orientation = 0;
      this.weight = 400;
      this.italic = 0;
      this.underline = 0;
      this.strikeout = 0;
      this.charset = 0;
      this.outprecision = 0;
      this.clipprecision = 0;
      this.quality = 0;
      this.pitch = 0;
      this.family = 0;
      this.facename = "Helvetica";
    }
  }
  clone() {
    return new Font(null, this);
  }
  toString() {
    return JSON.stringify(this);
  }
};
let Brush$1 = class Brush extends Obj$1 {
  constructor(reader, copy2) {
    super("brush");
    if (reader != null) {
      const start = reader.pos;
      this.style = reader.readUint32();
      switch (this.style) {
        case Helper$1.GDI.BrushStyle.BS_SOLID:
          this.color = new ColorRef$1(reader);
          break;
        case Helper$1.GDI.BrushStyle.BS_PATTERN:
          this.pattern = new DIBitmap$1(reader);
          break;
        case Helper$1.GDI.BrushStyle.BS_DIBPATTERNPT:
          this.dibpatternpt = new DIBitmap$1(reader);
          break;
        case Helper$1.GDI.BrushStyle.BS_HATCHED:
          this.color = new ColorRef$1(reader);
          this.hatchstyle = reader.readUint32();
          break;
      }
      reader.seek(start + 12);
    } else {
      this.style = copy2.style;
      switch (this.style) {
        case Helper$1.GDI.BrushStyle.BS_SOLID:
          this.color = copy2.color.clone();
          break;
        case Helper$1.GDI.BrushStyle.BS_PATTERN:
          this.pattern = copy2.pattern;
          break;
        case Helper$1.GDI.BrushStyle.BS_DIBPATTERNPT:
          this.dibpatternpt = copy2.dibpatternpt;
          break;
        case Helper$1.GDI.BrushStyle.BS_HATCHED:
          this.color = copy2.color.clone();
          this.hatchstyle = copy2.hatchstyle;
          break;
      }
    }
  }
  clone() {
    return new Brush(null, this);
  }
  toString() {
    let ret = "{style: " + this.style;
    switch (this.style) {
      case Helper$1.GDI.BrushStyle.BS_SOLID:
        ret += ", color: " + this.color.toString();
        break;
      case Helper$1.GDI.BrushStyle.BS_HATCHED:
        ret += ", color: " + this.color.toString() + ", hatchstyle: " + this.hatchstyle;
        break;
    }
    return ret + "}";
  }
};
let Pen$1 = class Pen extends Obj$1 {
  constructor(reader, style, width, color, brush) {
    super("pen");
    if (reader != null) {
      if (style != null) {
        this.style = reader.readUint32() & 255;
        this.width = reader.readUint32();
        this.brush = new Brush$1(reader);
        this.color = this.brush.color != null ? this.brush.color.clone() : new ColorRef$1(null, 0, 0, 0);
      } else {
        this.style = reader.readUint32() & 255;
        this.width = new PointL(reader).x;
        this.color = new ColorRef$1(reader);
      }
    } else {
      this.style = style;
      this.width = width;
      if (color != null) {
        this.color = color;
      }
      if (brush != null) {
        this.brush = brush;
      }
    }
  }
  clone() {
    return new Pen(
      null,
      this.style,
      this.width,
      this.color != null ? this.color.clone() : null,
      this.brush != null ? this.brush.clone() : null
    );
  }
  toString() {
    return "{style: " + this.style + ", width: " + this.width + ", color: " + (this.color != null ? this.color.toString() : "none") + "}";
  }
};
class EmfHeader {
  constructor(reader, headerSize) {
    const recordStart = reader.pos - 8;
    this.size = headerSize;
    this.bounds = new RectL(reader);
    this.frame = new RectL(reader);
    if (reader.readUint32() !== Helper$1.GDI.FormatSignature.ENHMETA_SIGNATURE) {
      throw new EMFJSError("Invalid header signature");
    }
    reader.skip(4);
    reader.skip(4);
    reader.skip(4);
    reader.skip(2);
    reader.skip(2);
    const descriptionLen = reader.readUint32();
    const descriptionOff = reader.readUint32();
    this.nPalEntries = reader.readUint32();
    this.refDevCx = reader.readUint32();
    this.refDevCy = reader.readUint32();
    this.refDevCxMm = reader.readUint32();
    this.refDevCyMm = reader.readUint32();
    let hdrSize = headerSize;
    if (descriptionLen > 0) {
      if (descriptionOff < 88) {
        throw new EMFJSError("Invalid header description offset");
      }
      hdrSize = descriptionOff + descriptionLen * 2;
      if (hdrSize > headerSize) {
        throw new EMFJSError("Invalid header description length");
      }
      const prevPos = reader.pos;
      reader.seek(recordStart + descriptionOff);
      this.description = reader.readFixedSizeUnicodeString(descriptionLen);
      reader.seek(prevPos);
    } else {
      this.description = "";
    }
    if (hdrSize >= 100) {
      const pixelFormatSize = reader.readUint32();
      const pixelFormatOff = reader.readUint32();
      const haveOpenGl = reader.readUint32();
      if (haveOpenGl !== 0) {
        throw new EMFJSError("OpenGL records are not yet supported");
      }
      if (pixelFormatOff !== 0) {
        if (pixelFormatOff < 100 || pixelFormatOff < hdrSize) {
          throw new EMFJSError("Invalid pixel format offset");
        }
        hdrSize = pixelFormatOff + pixelFormatSize;
        if (hdrSize > headerSize) {
          throw new EMFJSError("Invalid pixel format size");
        }
      }
      if (hdrSize >= 108) {
        this.displayDevCxUm = reader.readUint32();
        this.displayDevCyUm = reader.readUint32();
      }
    }
  }
  toString() {
    return "{bounds: " + this.bounds.toString() + ", frame: " + this.frame.toString() + ", description: " + this.description + "}";
  }
}
class EMFRecords {
  constructor(reader, first) {
    this._records = [];
    this._header = new EmfHeader(reader, first);
    let all = false;
    let curpos = first;
    main_loop: while (!all) {
      reader.seek(curpos);
      const type2 = reader.readUint32();
      const size = reader.readUint32();
      if (size < 8) {
        throw new EMFJSError("Invalid record size");
      }
      switch (type2) {
        case Helper$1.GDI.RecordType.EMR_EOF:
          all = true;
          break main_loop;
        case Helper$1.GDI.RecordType.EMR_SETMAPMODE: {
          const mapMode = reader.readInt32();
          this._records.push((gdi) => {
            gdi.setMapMode(mapMode);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_SETWINDOWORGEX: {
          const x2 = reader.readInt32();
          const y2 = reader.readInt32();
          this._records.push((gdi) => {
            gdi.setWindowOrgEx(x2, y2);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_SETWINDOWEXTEX: {
          const x2 = reader.readUint32();
          const y2 = reader.readUint32();
          this._records.push((gdi) => {
            gdi.setWindowExtEx(x2, y2);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_SETVIEWPORTORGEX: {
          const x2 = reader.readInt32();
          const y2 = reader.readInt32();
          this._records.push((gdi) => {
            gdi.setViewportOrgEx(x2, y2);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_SETVIEWPORTEXTEX: {
          const x2 = reader.readUint32();
          const y2 = reader.readUint32();
          this._records.push((gdi) => {
            gdi.setViewportExtEx(x2, y2);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_SAVEDC: {
          this._records.push((gdi) => {
            gdi.saveDC();
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_RESTOREDC: {
          const saved = reader.readInt32();
          this._records.push((gdi) => {
            gdi.restoreDC(saved);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_SETBKMODE: {
          const bkMode = reader.readUint32();
          this._records.push((gdi) => {
            gdi.setBkMode(bkMode);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_SETBKCOLOR: {
          const bkColor = new ColorRef$1(reader);
          this._records.push((gdi) => {
            gdi.setBkColor(bkColor);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_CREATEBRUSHINDIRECT: {
          const index2 = reader.readUint32();
          const brush = new Brush$1(reader);
          this._records.push((gdi) => {
            gdi.createBrush(index2, brush);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_CREATEPEN: {
          const index2 = reader.readUint32();
          const pen = new Pen$1(reader, null);
          this._records.push((gdi) => {
            gdi.createPen(index2, pen);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_EXTCREATEPEN: {
          const index2 = reader.readUint32();
          const offBmi = reader.readUint32();
          const cbBmi = reader.readUint32();
          const offBits = reader.readUint32();
          const cbBits = reader.readUint32();
          const pen = new Pen$1(reader, {
            header: {
              off: offBmi,
              size: cbBmi
            },
            data: {
              off: offBits,
              size: cbBits
            }
          });
          this._records.push((gdi) => {
            gdi.createPen(index2, pen);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_SELECTOBJECT: {
          const idx = reader.readUint32();
          this._records.push((gdi) => {
            gdi.selectObject(idx, null);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_DELETEOBJECT: {
          const idx = reader.readUint32();
          this._records.push((gdi) => {
            gdi.deleteObject(idx);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_RECTANGLE: {
          const rect = new RectL(reader);
          this._records.push((gdi) => {
            gdi.rectangle(rect, 0, 0);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_ROUNDRECT: {
          const rect = new RectL(reader);
          const corner = new SizeL(reader);
          this._records.push((gdi) => {
            gdi.rectangle(rect, corner.cx, corner.cy);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_LINETO: {
          const x2 = reader.readInt32();
          const y2 = reader.readInt32();
          this._records.push((gdi) => {
            gdi.lineTo(x2, y2);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_MOVETOEX: {
          const x2 = reader.readInt32();
          const y2 = reader.readInt32();
          this._records.push((gdi) => {
            gdi.moveToEx(x2, y2);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_POLYGON:
        case Helper$1.GDI.RecordType.EMR_POLYGON16: {
          const isSmall = type2 === Helper$1.GDI.RecordType.EMR_POLYGON16;
          const bounds = new RectL(reader);
          let cnt = reader.readUint32();
          const points = [];
          while (cnt > 0) {
            points.push(isSmall ? new PointS$1(reader) : new PointL(reader));
            cnt--;
          }
          this._records.push((gdi) => {
            gdi.polygon(points, bounds, true);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_POLYPOLYGON:
        case Helper$1.GDI.RecordType.EMR_POLYPOLYGON16: {
          const isSmall = type2 === Helper$1.GDI.RecordType.EMR_POLYPOLYGON16;
          const bounds = new RectL(reader);
          const polyCnt = reader.readUint32();
          reader.skip(4);
          const polygonsPtCnts = [];
          for (let i = 0; i < polyCnt; i++) {
            polygonsPtCnts.push(reader.readUint32());
          }
          const polygons = [];
          for (let i = 0; i < polyCnt; i++) {
            const ptCnt = polygonsPtCnts[i];
            const p = [];
            for (let ip = 0; ip < ptCnt; ip++) {
              p.push(isSmall ? new PointS$1(reader) : new PointL(reader));
            }
            polygons.push(p);
          }
          this._records.push((gdi) => {
            gdi.polyPolygon(polygons, bounds);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_SETPOLYFILLMODE: {
          const polyfillmode = reader.readUint32();
          this._records.push((gdi) => {
            gdi.setPolyFillMode(polyfillmode);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_POLYLINE16:
        case Helper$1.GDI.RecordType.EMR_POLYLINETO16: {
          const isLineTo = type2 === Helper$1.GDI.RecordType.EMR_POLYLINETO16;
          const bounds = new RectL(reader);
          let cnt = reader.readUint32();
          const points = [];
          while (cnt > 0) {
            points.push(new PointS$1(reader));
            cnt--;
          }
          this._records.push((gdi) => {
            gdi.polyline(isLineTo, points, bounds);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_POLYBEZIER:
        case Helper$1.GDI.RecordType.EMR_POLYBEZIERTO: {
          const isPolyBezierTo = type2 === Helper$1.GDI.RecordType.EMR_POLYBEZIERTO;
          const bounds = new RectL(reader);
          let cnt = reader.readUint32();
          const points = [];
          while (cnt > 0) {
            points.push(new PointL(reader));
            cnt--;
          }
          this._records.push((gdi) => {
            gdi.polybezier(isPolyBezierTo, points, bounds);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_POLYBEZIER16: {
          const bounds = new RectL(reader);
          const start = new PointL(reader);
          let cnt = reader.readUint32();
          const points = [start];
          while (cnt > 0) {
            points.push(new PointS$1(reader));
            cnt--;
          }
          this._records.push((gdi) => {
            gdi.polybezier(false, points, bounds);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_POLYBEZIERTO16: {
          const bounds = new RectL(reader);
          let cnt = reader.readUint32();
          const points = [];
          while (cnt > 0) {
            points.push(new PointS$1(reader));
            cnt--;
          }
          this._records.push((gdi) => {
            gdi.polybezier(true, points, bounds);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_SETTEXTALIGN: {
          const textAlign = reader.readUint32();
          this._records.push((gdi) => {
            gdi.setTextAlign(textAlign);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_SETSTRETCHBLTMODE: {
          const stretchMode = reader.readUint32();
          this._records.push((gdi) => {
            gdi.setStretchBltMode(stretchMode);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_SETBRUSHORGEX: {
          const origin = new PointL(reader);
          this._records.push((gdi) => {
            gdi.setBrushOrgEx(origin);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_BEGINPATH: {
          this._records.push((gdi) => {
            gdi.beginPath();
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_ENDPATH: {
          this._records.push((gdi) => {
            gdi.endPath();
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_ABORTPATH: {
          this._records.push((gdi) => {
            gdi.abortPath();
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_CLOSEFIGURE: {
          this._records.push((gdi) => {
            gdi.closeFigure();
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_FILLPATH: {
          const bounds = new RectL(reader);
          this._records.push((gdi) => {
            gdi.fillPath(bounds);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_STROKEPATH: {
          const bounds = new RectL(reader);
          this._records.push((gdi) => {
            gdi.strokePath(bounds);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_SELECTCLIPPATH: {
          const rgnMode = reader.readUint32();
          this._records.push((gdi) => {
            gdi.selectClipPath(rgnMode);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_EXTSELECTCLIPRGN: {
          reader.skip(4);
          const rgnMode = reader.readUint32();
          const region = rgnMode !== Helper$1.GDI.RegionMode.RGN_COPY ? new Region$1(reader) : null;
          this._records.push((gdi) => {
            gdi.selectClipRgn(rgnMode, region);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_OFFSETCLIPRGN: {
          const offset = new PointL(reader);
          this._records.push((gdi) => {
            gdi.offsetClipRgn(offset);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_SETMITERLIMIT: {
          const miterLimit = reader.readUint32();
          this._records.push((gdi) => {
            gdi.setMiterLimit(miterLimit);
          });
          break;
        }
        case Helper$1.GDI.RecordType.EMR_POLYLINE:
        case Helper$1.GDI.RecordType.EMR_POLYLINETO:
        case Helper$1.GDI.RecordType.EMR_POLYPOLYLINE:
        case Helper$1.GDI.RecordType.EMR_SETPIXELV:
        case Helper$1.GDI.RecordType.EMR_SETMAPPERFLAGS:
        case Helper$1.GDI.RecordType.EMR_SETROP2:
        case Helper$1.GDI.RecordType.EMR_SETCOLORADJUSTMENT:
        case Helper$1.GDI.RecordType.EMR_SETTEXTCOLOR:
        case Helper$1.GDI.RecordType.EMR_SETMETARGN:
        case Helper$1.GDI.RecordType.EMR_EXCLUDECLIPRECT:
        case Helper$1.GDI.RecordType.EMR_INTERSECTCLIPRECT:
        case Helper$1.GDI.RecordType.EMR_SCALEVIEWPORTEXTEX:
        case Helper$1.GDI.RecordType.EMR_SCALEWINDOWEXTEX:
        case Helper$1.GDI.RecordType.EMR_SETWORLDTRANSFORM:
        case Helper$1.GDI.RecordType.EMR_MODIFYWORLDTRANSFORM:
        case Helper$1.GDI.RecordType.EMR_ANGLEARC:
        case Helper$1.GDI.RecordType.EMR_ELLIPSE:
        case Helper$1.GDI.RecordType.EMR_ARC:
        case Helper$1.GDI.RecordType.EMR_CHORD:
        case Helper$1.GDI.RecordType.EMR_PIE:
        case Helper$1.GDI.RecordType.EMR_SELECTPALETTE:
        case Helper$1.GDI.RecordType.EMR_CREATEPALETTE:
        case Helper$1.GDI.RecordType.EMR_SETPALETTEENTRIES:
        case Helper$1.GDI.RecordType.EMR_RESIZEPALETTE:
        case Helper$1.GDI.RecordType.EMR_REALIZEPALETTE:
        case Helper$1.GDI.RecordType.EMR_EXTFLOODFILL:
        case Helper$1.GDI.RecordType.EMR_ARCTO:
        case Helper$1.GDI.RecordType.EMR_POLYDRAW:
        case Helper$1.GDI.RecordType.EMR_SETARCDIRECTION:
        case Helper$1.GDI.RecordType.EMR_STROKEANDFILLPATH:
        case Helper$1.GDI.RecordType.EMR_FLATTENPATH:
        case Helper$1.GDI.RecordType.EMR_WIDENPATH:
        case Helper$1.GDI.RecordType.EMR_COMMENT:
        case Helper$1.GDI.RecordType.EMR_FILLRGN:
        case Helper$1.GDI.RecordType.EMR_FRAMERGN:
        case Helper$1.GDI.RecordType.EMR_INVERTRGN:
        case Helper$1.GDI.RecordType.EMR_PAINTRGN:
        case Helper$1.GDI.RecordType.EMR_BITBLT:
        case Helper$1.GDI.RecordType.EMR_STRETCHBLT:
        case Helper$1.GDI.RecordType.EMR_MASKBLT:
        case Helper$1.GDI.RecordType.EMR_PLGBLT:
        case Helper$1.GDI.RecordType.EMR_SETDIBITSTODEVICE:
        case Helper$1.GDI.RecordType.EMR_STRETCHDIBITS:
        case Helper$1.GDI.RecordType.EMR_EXTCREATEFONTINDIRECTW:
        case Helper$1.GDI.RecordType.EMR_EXTTEXTOUTA:
        case Helper$1.GDI.RecordType.EMR_EXTTEXTOUTW:
        case Helper$1.GDI.RecordType.EMR_POLYPOLYLINE16:
        case Helper$1.GDI.RecordType.EMR_POLYDRAW16:
        case Helper$1.GDI.RecordType.EMR_CREATEMONOBRUSH:
        case Helper$1.GDI.RecordType.EMR_CREATEDIBPATTERNBRUSHPT:
        case Helper$1.GDI.RecordType.EMR_POLYTEXTOUTA:
        case Helper$1.GDI.RecordType.EMR_POLYTEXTOUTW:
        case Helper$1.GDI.RecordType.EMR_SETICMMODE:
        case Helper$1.GDI.RecordType.EMR_CREATECOLORSPACE:
        case Helper$1.GDI.RecordType.EMR_SETCOLORSPACE:
        case Helper$1.GDI.RecordType.EMR_DELETECOLORSPACE:
        case Helper$1.GDI.RecordType.EMR_GLSRECORD:
        case Helper$1.GDI.RecordType.EMR_GLSBOUNDEDRECORD:
        case Helper$1.GDI.RecordType.EMR_PIXELFORMAT:
        case Helper$1.GDI.RecordType.EMR_DRAWESCAPE:
        case Helper$1.GDI.RecordType.EMR_EXTESCAPE:
        case Helper$1.GDI.RecordType.EMR_SMALLTEXTOUT:
        case Helper$1.GDI.RecordType.EMR_FORCEUFIMAPPING:
        case Helper$1.GDI.RecordType.EMR_NAMEDESCAPE:
        case Helper$1.GDI.RecordType.EMR_COLORCORRECTPALETTE:
        case Helper$1.GDI.RecordType.EMR_SETICMPROFILEA:
        case Helper$1.GDI.RecordType.EMR_SETICMPROFILEW:
        case Helper$1.GDI.RecordType.EMR_ALPHABLEND:
        case Helper$1.GDI.RecordType.EMR_SETLAYOUT:
        case Helper$1.GDI.RecordType.EMR_TRANSPARENTBLT:
        case Helper$1.GDI.RecordType.EMR_GRADIENTFILL:
        case Helper$1.GDI.RecordType.EMR_SETLINKEDUFIS:
        case Helper$1.GDI.RecordType.EMR_SETTEXTJUSTIFICATION:
        case Helper$1.GDI.RecordType.EMR_COLORMATCHTOTARGETW:
        case Helper$1.GDI.RecordType.EMR_CREATECOLORSPACEW:
        default: {
          let recordName = "UNKNOWN";
          for (const name in Helper$1.GDI.RecordType) {
            const recordTypes = Helper$1.GDI.RecordType;
            if (recordTypes[name] === type2) {
              recordName = name;
              break;
            }
          }
          Helper$1.log(
            "[EMF] " + recordName + " record (0x" + type2.toString(16) + ") at offset 0x" + curpos.toString(16) + " with " + size + " bytes"
          );
          break;
        }
      }
      curpos += size;
    }
    if (!all) {
      throw new EMFJSError("Could not read all records");
    }
  }
  play(gdi) {
    const len = this._records.length;
    for (let i = 0; i < len; i++) {
      this._records[i](gdi);
    }
  }
}
class Path extends Obj$1 {
  constructor(svgPath, copy2) {
    super("path");
    if (svgPath != null) {
      this.svgPath = svgPath;
    } else {
      this.svgPath = copy2.svgPath;
    }
  }
  clone() {
    return new Path(null, this);
  }
  toString() {
    return "{[path]}";
  }
}
function createStockObjects() {
  const createSolidBrush = (r, g, b2) => {
    return new Brush$1(null, {
      style: Helper$1.GDI.BrushStyle.BS_SOLID,
      color: new ColorRef$1(null, r, g, b2)
    });
  };
  const createSolidPen = (r, g, b2) => {
    return new Pen$1(null, Helper$1.GDI.PenStyle.PS_SOLID, 1, new ColorRef$1(null, r, g, b2), null);
  };
  const stockObjs = {
    WHITE_BRUSH: createSolidBrush(255, 255, 255),
    LTGRAY_BRUSH: createSolidBrush(212, 208, 200),
    GRAY_BRUSH: createSolidBrush(128, 128, 128),
    DKGRAY_BRUSH: createSolidBrush(64, 64, 64),
    BLACK_BRUSH: createSolidBrush(0, 0, 0),
    NULL_BRUSH: new Brush$1(null, {
      style: Helper$1.GDI.BrushStyle.BS_NULL
    }),
    WHITE_PEN: createSolidPen(255, 255, 255),
    BLACK_PEN: createSolidPen(0, 0, 0),
    NULL_PEN: new Pen$1(null, Helper$1.GDI.PenStyle.PS_NULL, 0, null, null),
    OEM_FIXED_FONT: null,
    // TODO
    ANSI_FIXED_FONT: null,
    // TODO
    ANSI_VAR_FONT: null,
    // TODO
    SYSTEM_FONT: null,
    // TODO
    DEVICE_DEFAULT_FONT: null,
    // TODO
    DEFAULT_PALETTE: null,
    // TODO
    SYSTEM_FIXED_FONT: null,
    // TODO
    DEFAULT_GUI_FONT: null
    // TODO
  };
  const objs = {};
  for (const t in stockObjs) {
    const stockObjects = Helper$1.GDI.StockObject;
    const idx = stockObjects[t] - 2147483648;
    objs[idx.toString()] = stockObjs[t];
  }
  return objs;
}
const _StockObjects = createStockObjects();
let GDIContextState$1 = class GDIContextState {
  constructor(copy2, defObjects) {
    if (copy2 != null) {
      this._svggroup = copy2._svggroup;
      this._svgclipChanged = copy2._svgclipChanged;
      this._svgtextbkfilter = copy2._svgtextbkfilter;
      this.mapmode = copy2.mapmode;
      this.stretchmode = copy2.stretchmode;
      this.textalign = copy2.textalign;
      this.bkmode = copy2.bkmode;
      this.textcolor = copy2.textcolor.clone();
      this.bkcolor = copy2.bkcolor.clone();
      this.polyfillmode = copy2.polyfillmode;
      this.miterlimit = copy2.miterlimit;
      this.wx = copy2.wx;
      this.wy = copy2.wy;
      this.ww = copy2.ww;
      this.wh = copy2.wh;
      this.vx = copy2.vx;
      this.vy = copy2.vy;
      this.vw = copy2.vw;
      this.vh = copy2.vh;
      this.x = copy2.x;
      this.y = copy2.y;
      this.nextbrx = copy2.nextbrx;
      this.nextbry = copy2.nextbry;
      this.brx = copy2.brx;
      this.bry = copy2.bry;
      this.clip = copy2.clip;
      this.ownclip = false;
      this.selected = {};
      for (const type2 in copy2.selected) {
        this.selected[type2] = copy2.selected[type2];
      }
    } else {
      this._svggroup = null;
      this._svgclipChanged = false;
      this._svgtextbkfilter = null;
      this.mapmode = Helper$1.GDI.MapMode.MM_ANISOTROPIC;
      this.stretchmode = Helper$1.GDI.StretchMode.COLORONCOLOR;
      this.textalign = 0;
      this.bkmode = Helper$1.GDI.MixMode.OPAQUE;
      this.textcolor = new ColorRef$1(null, 0, 0, 0);
      this.bkcolor = new ColorRef$1(null, 255, 255, 255);
      this.polyfillmode = Helper$1.GDI.PolygonFillMode.ALTERNATE;
      this.miterlimit = 10;
      this.wx = 0;
      this.wy = 0;
      this.ww = 0;
      this.wh = 0;
      this.vx = 0;
      this.vy = 0;
      this.vw = 0;
      this.vh = 0;
      this.x = 0;
      this.y = 0;
      this.nextbrx = 0;
      this.nextbry = 0;
      this.brx = 0;
      this.bry = 0;
      this.clip = null;
      this.ownclip = false;
      this.selected = {};
      for (const type2 in defObjects) {
        const defObj = defObjects[type2];
        this.selected[type2] = defObj != null ? defObj.clone() : null;
      }
    }
  }
};
let GDIContext$1 = class GDIContext {
  constructor(svg) {
    this._svg = svg;
    this._svgdefs = null;
    this._svgPatterns = {};
    this._svgClipPaths = {};
    this._svgPath = null;
    this.defObjects = {
      brush: new Brush$1(null, {
        style: Helper$1.GDI.BrushStyle.BS_SOLID,
        color: new ColorRef$1(null, 0, 0, 0)
      }),
      pen: new Pen$1(null, Helper$1.GDI.PenStyle.PS_SOLID, 1, new ColorRef$1(null, 0, 0, 0), null),
      font: new Font$1(null, null),
      palette: null,
      region: null
    };
    this.state = new GDIContextState$1(null, this.defObjects);
    this.statestack = [this.state];
    this.objects = {};
  }
  setMapMode(mode) {
    Helper$1.log("[gdi] setMapMode: mode=" + mode);
    this.state.mapmode = mode;
    this.state._svggroup = null;
  }
  setWindowOrgEx(x2, y2) {
    Helper$1.log("[gdi] setWindowOrgEx: x=" + x2 + " y=" + y2);
    this.state.wx = x2;
    this.state.wy = y2;
    this.state._svggroup = null;
  }
  setWindowExtEx(x2, y2) {
    Helper$1.log("[gdi] setWindowExtEx: x=" + x2 + " y=" + y2);
    this.state.ww = x2;
    this.state.wh = y2;
    this.state._svggroup = null;
  }
  setViewportOrgEx(x2, y2) {
    Helper$1.log("[gdi] setViewportOrgEx: x=" + x2 + " y=" + y2);
    this.state.vx = x2;
    this.state.vy = y2;
    this.state._svggroup = null;
  }
  setViewportExtEx(x2, y2) {
    Helper$1.log("[gdi] setViewportExtEx: x=" + x2 + " y=" + y2);
    this.state.vw = x2;
    this.state.vh = y2;
    this.state._svggroup = null;
  }
  setBrushOrgEx(origin) {
    Helper$1.log("[gdi] setBrushOrgEx: x=" + origin.x + " y=" + origin.y);
    this.state.nextbrx = origin.x;
    this.state.nextbry = origin.y;
  }
  saveDC() {
    Helper$1.log("[gdi] saveDC");
    const prevstate = this.state;
    this.state = new GDIContextState$1(this.state);
    this.statestack.push(prevstate);
    this.state._svggroup = null;
  }
  restoreDC(saved) {
    Helper$1.log("[gdi] restoreDC: saved=" + saved);
    if (this.statestack.length > 1) {
      if (saved === -1) {
        this.state = this.statestack.pop();
      } else if (saved < -1) {
        throw new EMFJSError("restoreDC: relative restore not implemented");
      } else if (saved > 1) {
        throw new EMFJSError("restoreDC: absolute restore not implemented");
      }
    } else {
      throw new EMFJSError("No saved contexts");
    }
    this.state._svggroup = null;
  }
  setStretchBltMode(stretchMode) {
    Helper$1.log("[gdi] setStretchBltMode: stretchMode=" + stretchMode);
  }
  rectangle(rect, rw, rh) {
    Helper$1.log(
      "[gdi] rectangle: rect=" + rect.toString() + " with pen " + this.state.selected.pen.toString() + " and brush " + this.state.selected.brush.toString()
    );
    const bottom = this._todevY(rect.bottom);
    const right = this._todevX(rect.right);
    const top = this._todevY(rect.top);
    const left = this._todevX(rect.left);
    rw = this._todevH(rw);
    rh = this._todevH(rh);
    Helper$1.log(
      "[gdi] rectangle: TRANSLATED: bottom=" + bottom + " right=" + right + " top=" + top + " left=" + left + " rh=" + rh + " rw=" + rw
    );
    this._pushGroup();
    const opts = this._applyOpts(null, true, true, false);
    this._svg.rect(this.state._svggroup, left, top, right - left, bottom - top, rw / 2, rh / 2, opts);
  }
  lineTo(x2, y2) {
    Helper$1.log("[gdi] lineTo: x=" + x2 + " y=" + y2 + " with pen " + this.state.selected.pen.toString());
    const toX = this._todevX(x2);
    const toY = this._todevY(y2);
    const fromX = this._todevX(this.state.x);
    const fromY = this._todevY(this.state.y);
    this.state.x = x2;
    this.state.y = y2;
    Helper$1.log("[gdi] lineTo: TRANSLATED: toX=" + toX + " toY=" + toY + " fromX=" + fromX + " fromY=" + fromY);
    this._pushGroup();
    const opts = this._applyOpts(null, true, false, false);
    this._svg.line(this.state._svggroup, fromX, fromY, toX, toY, opts);
  }
  moveToEx(x2, y2) {
    Helper$1.log("[gdi] moveToEx: x=" + x2 + " y=" + y2);
    this.state.x = x2;
    this.state.y = y2;
    if (this._svgPath != null) {
      this._svgPath.move(this.state.x, this.state.y);
      Helper$1.log("[gdi] new path: " + this._svgPath.path());
    }
  }
  polygon(points, bounds, first) {
    Helper$1.log(
      "[gdi] polygon: points=" + points + " with pen " + this.state.selected.pen.toString() + " and brush " + this.state.selected.brush.toString()
    );
    const pts = [];
    for (let i = 0; i < points.length; i++) {
      const point = points[i];
      pts.push([this._todevX(point.x), this._todevY(point.y)]);
    }
    if (first) {
      this._pushGroup();
    }
    const opts = {
      "fill-rule": this.state.polyfillmode === Helper$1.GDI.PolygonFillMode.ALTERNATE ? "evenodd" : "nonzero"
    };
    this._applyOpts(opts, true, true, false);
    this._svg.polygon(this.state._svggroup, pts, opts);
  }
  polyPolygon(polygons, bounds) {
    Helper$1.log(
      "[gdi] polyPolygon: polygons.length=" + polygons.length + " with pen " + this.state.selected.pen.toString() + " and brush " + this.state.selected.brush.toString()
    );
    const cnt = polygons.length;
    for (let i = 0; i < cnt; i++) {
      this.polygon(polygons[i], bounds, i === 0);
    }
  }
  polyline(isLineTo, points, bounds) {
    Helper$1.log(
      "[gdi] polyline: isLineTo=" + isLineTo.toString() + ", points=" + points + ", bounds=" + bounds.toString() + " with pen " + this.state.selected.pen.toString()
    );
    const pts = [];
    for (let i = 0; i < points.length; i++) {
      const point = points[i];
      pts.push([this._todevX(point.x), this._todevY(point.y)]);
    }
    if (this._svgPath != null) {
      if (!isLineTo || pts.length === 0) {
        this._svgPath.move(this._todevX(this.state.x), this._todevY(this.state.y));
      } else {
        const firstPts = pts[0];
        this._svgPath.move(firstPts[0], firstPts[1]);
      }
      this._svgPath.line(pts);
      Helper$1.log("[gdi] new path: " + this._svgPath.path());
    } else {
      this._pushGroup();
      const opts = this._applyOpts(null, true, false, false);
      if (isLineTo && points.length > 0) {
        const firstPt = points[0];
        if (firstPt.x !== this.state.x || firstPt.y !== this.state.y) {
          pts.unshift([this._todevX(this.state.x), this._todevY(this.state.y)]);
        }
      }
      this._svg.polyline(this.state._svggroup, pts, opts);
    }
    if (points.length > 0) {
      const lastPt = points[points.length - 1];
      this.state.x = lastPt.x;
      this.state.y = lastPt.y;
    }
  }
  polybezier(isPolyBezierTo, points, bounds) {
    Helper$1.log(
      "[gdi] polybezier: isPolyBezierTo=" + isPolyBezierTo.toString() + ", points=" + points + ", bounds=" + bounds.toString() + " with pen " + this.state.selected.pen.toString()
    );
    const pts = [];
    for (let i = 0; i < points.length; i++) {
      const point = points[i];
      pts.push({ x: this._todevX(point.x), y: this._todevY(point.y) });
    }
    if (this._svgPath != null) {
      if (isPolyBezierTo && pts.length > 0) {
        const firstPts = pts[0];
        this._svgPath.move(firstPts.x, firstPts.y);
      } else {
        this._svgPath.move(this._todevX(this.state.x), this._todevY(this.state.y));
      }
      if (pts.length < (isPolyBezierTo ? 3 : 4)) {
        throw new EMFJSError("Not enough points to draw bezier");
      }
      for (let i = isPolyBezierTo ? 1 : 0; i + 3 <= pts.length; i += 3) {
        const cp1 = pts[i];
        const cp2 = pts[i + 1];
        const ep = pts[i + 2];
        this._svgPath.curveC(cp1.x, cp1.y, cp2.x, cp2.y, ep.x, ep.y);
      }
      Helper$1.log("[gdi] new path: " + this._svgPath.path());
    } else {
      throw new EMFJSError("polybezier not implemented (not a path)");
    }
    if (points.length > 0) {
      const lastPt = points[points.length - 1];
      this.state.x = lastPt.x;
      this.state.y = lastPt.y;
    }
  }
  selectClipPath(rgnMode) {
    Helper$1.log("[gdi] selectClipPath: rgnMode=0x" + rgnMode.toString(16));
  }
  selectClipRgn(rgnMode, region) {
    Helper$1.log("[gdi] selectClipRgn: rgnMode=0x" + rgnMode.toString(16));
    if (rgnMode === Helper$1.GDI.RegionMode.RGN_COPY) {
      this.state.selected.region = region;
      this.state.clip = null;
      this.state.ownclip = false;
    } else {
      if (region == null) {
        throw new EMFJSError("No clip region to select");
      }
      throw new EMFJSError("Not implemented: rgnMode=0x" + rgnMode.toString(16));
    }
    this.state._svgclipChanged = true;
  }
  offsetClipRgn(offset) {
    Helper$1.log("[gdi] offsetClipRgn: offset=" + offset.toString());
    this._getClipRgn().offset(offset.x, offset.y);
  }
  setTextAlign(textAlignmentMode) {
    Helper$1.log("[gdi] setTextAlign: textAlignmentMode=0x" + textAlignmentMode.toString(16));
    this.state.textalign = textAlignmentMode;
  }
  setMiterLimit(miterLimit) {
    Helper$1.log("[gdi] setMiterLimit: miterLimit=" + miterLimit);
    this.state.miterlimit = miterLimit;
  }
  setBkMode(bkMode) {
    Helper$1.log("[gdi] setBkMode: bkMode=0x" + bkMode.toString(16));
    this.state.bkmode = bkMode;
  }
  setBkColor(bkColor) {
    Helper$1.log("[gdi] setBkColor: bkColor=" + bkColor.toString());
    this.state.bkcolor = bkColor;
    this.state._svgtextbkfilter = null;
  }
  setPolyFillMode(polyFillMode) {
    Helper$1.log("[gdi] setPolyFillMode: polyFillMode=" + polyFillMode);
    this.state.polyfillmode = polyFillMode;
  }
  createBrush(index2, brush) {
    const idx = this._storeObject(brush, index2);
    Helper$1.log("[gdi] createBrush: brush=" + brush.toString() + " with handle " + idx);
  }
  createPen(index2, pen) {
    const idx = this._storeObject(pen, index2);
    Helper$1.log("[gdi] createPen: pen=" + pen.toString() + " width handle " + idx);
  }
  createPenEx(index2, pen) {
    const idx = this._storeObject(pen, index2);
    Helper$1.log("[gdi] createPenEx: pen=" + pen.toString() + " width handle " + idx);
  }
  selectObject(objIdx, checkType) {
    const obj = this._getObject(objIdx);
    if (obj != null && (checkType == null || obj.type === checkType)) {
      this._selectObject(obj);
      Helper$1.log(
        "[gdi] selectObject: objIdx=" + objIdx + (obj ? " selected " + obj.type + ": " + obj.toString() : "[invalid index]")
      );
    } else {
      Helper$1.log(
        "[gdi] selectObject: objIdx=" + objIdx + (obj ? " invalid object type: " + obj.type : "[invalid index]")
      );
    }
  }
  abortPath() {
    Helper$1.log("[gdi] abortPath");
    if (this._svgPath != null) {
      this._svgPath = null;
    }
  }
  beginPath() {
    Helper$1.log("[gdi] beginPath");
    if (this._svgPath != null) {
      this._svgPath = null;
    }
    this._svgPath = this._svg.createPath();
  }
  closeFigure() {
    Helper$1.log("[gdi] closeFigure");
    if (this._svgPath == null) {
      throw new EMFJSError("No path bracket: cannot close figure");
    }
    this._svgPath.close();
  }
  fillPath(bounds) {
    Helper$1.log("[gdi] fillPath");
    if (this.state.selected.path == null) {
      throw new EMFJSError("No path selected");
    }
    const selPath = this.state.selected.path;
    const opts = this._applyOpts(null, true, true, false);
    this._svg.path(this.state._svggroup, selPath.svgPath, opts);
    this._pushGroup();
    this.state.selected.path = null;
  }
  strokePath(bounds) {
    Helper$1.log("[gdi] strokePath");
    if (this.state.selected.path == null) {
      throw new EMFJSError("No path selected");
    }
    const selPath = this.state.selected.path;
    const opts = this._applyOpts({ fill: "none" }, true, false, false);
    this._svg.path(this.state._svggroup, selPath.svgPath, opts);
    this._pushGroup();
    this.state.selected.path = null;
  }
  endPath() {
    Helper$1.log("[gdi] endPath");
    if (this._svgPath == null) {
      throw new EMFJSError("No path bracket: cannot end path");
    }
    this._pushGroup();
    this._selectObject(new Path(this._svgPath));
    this._svgPath = null;
  }
  deleteObject(objIdx) {
    const ret = this._deleteObject(objIdx);
    Helper$1.log("[gdi] deleteObject: objIdx=" + objIdx + (ret ? " deleted object" : "[invalid index]"));
  }
  _pushGroup() {
    if (this.state._svggroup == null || this.state._svgclipChanged) {
      this.state._svgclipChanged = false;
      this.state._svgtextbkfilter = null;
      const settings = {
        viewBox: [this.state.vx, this.state.vy, this.state.vw, this.state.vh].join(" "),
        preserveAspectRatio: "none"
      };
      if (this.state.clip != null) {
        Helper$1.log(
          "[gdi] new svg x=" + this.state.vx + " y=" + this.state.vy + " width=" + this.state.vw + " height=" + this.state.vh + " with clipping"
        );
        settings["clip-path"] = "url(#" + this._getSvgClipPathForRegion(this.state.clip) + ")";
      } else {
        Helper$1.log(
          "[gdi] new svg x=" + this.state.vx + " y=" + this.state.vy + " width=" + this.state.vw + " height=" + this.state.vh + " without clipping"
        );
      }
      this.state._svggroup = this._svg.svg(
        this.state._svggroup,
        this.state.vx,
        this.state.vy,
        this.state.vw,
        this.state.vh,
        settings
      );
    }
  }
  _getStockObject(idx) {
    if (idx >= 2147483648 && idx <= 2147483665) {
      return _StockObjects[(idx - 2147483648).toString()];
    } else if (idx === Helper$1.GDI.StockObject.DC_BRUSH) {
      return this.state.selected.brush;
    } else if (idx === Helper$1.GDI.StockObject.DC_PEN) {
      return this.state.selected.pen;
    }
    return null;
  }
  _storeObject(obj, idx) {
    if (!idx) {
      idx = 0;
      while (this.objects[idx.toString()] != null && idx <= 65535) {
        idx++;
      }
      if (idx > 65535) {
        Helper$1.log("[gdi] Too many objects!");
        return -1;
      }
    }
    this.objects[idx.toString()] = obj;
    return idx;
  }
  _getObject(objIdx) {
    let obj = this.objects[objIdx.toString()];
    if (obj == null) {
      obj = this._getStockObject(objIdx);
      if (obj == null) {
        Helper$1.log("[gdi] No object with handle " + objIdx);
      }
    }
    return obj;
  }
  _getSvgDef() {
    if (this._svgdefs == null) {
      this._svgdefs = this._svg.defs();
    }
    return this._svgdefs;
  }
  _getSvgClipPathForRegion(region) {
    for (const existingId in this._svgClipPaths) {
      const rgn = this._svgClipPaths[existingId];
      if (rgn === region) {
        return existingId;
      }
    }
    const id = Helper$1._makeUniqueId("c");
    const sclip = this._svg.clipPath(this._getSvgDef(), id, "userSpaceOnUse");
    switch (region.complexity) {
      case 1:
        this._svg.rect(
          sclip,
          this._todevX(region.bounds.left),
          this._todevY(region.bounds.top),
          this._todevW(region.bounds.right - region.bounds.left),
          this._todevH(region.bounds.bottom - region.bounds.top),
          { fill: "black", "stroke-width": 0 }
        );
        break;
      case 2:
        for (let i = 0; i < region.scans.length; i++) {
          const scan = region.scans[i];
          for (let j2 = 0; j2 < scan.scanlines.length; j2++) {
            const scanline = scan.scanlines[j2];
            this._svg.rect(
              sclip,
              this._todevX(scanline.left),
              this._todevY(scan.top),
              this._todevW(scanline.right - scanline.left),
              this._todevH(scan.bottom - scan.top),
              { fill: "black", "stroke-width": 0 }
            );
          }
        }
        break;
    }
    this._svgClipPaths[id] = region;
    return id;
  }
  _getSvgPatternForBrush(brush) {
    for (const existingId in this._svgPatterns) {
      const pat = this._svgPatterns[existingId];
      if (pat === brush) {
        return existingId;
      }
    }
    let width;
    let height;
    let img;
    switch (brush.style) {
      case Helper$1.GDI.BrushStyle.BS_PATTERN:
        width = brush.pattern.getWidth();
        height = brush.pattern.getHeight();
        break;
      case Helper$1.GDI.BrushStyle.BS_DIBPATTERNPT:
        width = brush.dibpatternpt.getWidth();
        height = brush.dibpatternpt.getHeight();
        img = brush.dibpatternpt.base64ref();
        break;
      default:
        throw new EMFJSError("Invalid brush style");
    }
    const id = Helper$1._makeUniqueId("p");
    const spat = this._svg.pattern(this._getSvgDef(), id, this.state.brx, this.state.bry, width, height, {
      patternUnits: "userSpaceOnUse"
    });
    this._svg.image(spat, 0, 0, width, height, img);
    this._svgPatterns[id] = brush;
    return id;
  }
  _selectObject(obj) {
    this.state.selected[obj.type] = obj;
    switch (obj.type) {
      case "region":
        this.state._svgclipChanged = true;
        break;
      case "brush":
        this.state.brx = this.state.nextbrx;
        this.state.bry = this.state.nextbry;
        break;
    }
  }
  _deleteObject(objIdx) {
    const obj = this.objects[objIdx.toString()];
    if (obj != null) {
      for (let i = 0; i < this.statestack.length; i++) {
        const state2 = this.statestack[i];
        if (state2.selected[obj.type] === obj) {
          state2.selected[obj.type] = this.defObjects[obj.type].clone();
        }
      }
      delete this.objects[objIdx.toString()];
      return true;
    }
    Helper$1.log("[gdi] Cannot delete object with invalid handle " + objIdx);
    return false;
  }
  _getClipRgn() {
    if (this.state.clip != null) {
      if (!this.state.ownclip) {
        this.state.clip = this.state.clip.clone();
      }
    } else {
      if (this.state.selected.region != null) {
        this.state.clip = this.state.selected.region.clone();
      } else {
        this.state.clip = CreateSimpleRegion$1(
          this.state.wx,
          this.state.wy,
          this.state.wx + this.state.ww,
          this.state.wy + this.state.wh
        );
      }
    }
    this.state.ownclip = true;
    return this.state.clip;
  }
  _todevX(val) {
    return Math.floor((val - this.state.wx) * (this.state.vw / this.state.ww)) + this.state.vx;
  }
  _todevY(val) {
    return Math.floor((val - this.state.wy) * (this.state.vh / this.state.wh)) + this.state.vy;
  }
  _todevW(val) {
    return Math.floor(val * (this.state.vw / this.state.ww)) + this.state.vx;
  }
  _todevH(val) {
    return Math.floor(val * (this.state.vh / this.state.wh)) + this.state.vy;
  }
  _tologicalX(val) {
    return Math.floor((val - this.state.vx) / (this.state.vw / this.state.ww)) + this.state.wx;
  }
  _tologicalY(val) {
    return Math.floor((val - this.state.vy) / (this.state.vh / this.state.wh)) + this.state.wy;
  }
  _tologicalW(val) {
    return Math.floor(val / (this.state.vw / this.state.ww)) + this.state.wx;
  }
  _tologicalH(val) {
    return Math.floor(val / (this.state.vh / this.state.wh)) + this.state.wy;
  }
  _applyOpts(opts, usePen, useBrush, useFont) {
    if (opts == null) {
      opts = {};
    }
    if (usePen) {
      const pen = this.state.selected.pen;
      if (pen.style !== Helper$1.GDI.PenStyle.PS_NULL) {
        opts.stroke = "#" + pen.color.toHex();
        opts["stroke-width"] = pen.width;
        opts["stroke-miterlimit"] = this.state.miterlimit;
        opts["stroke-linecap"] = "round";
        const dotWidth = 1;
        opts["stroke-linejoin"] = "round";
        const dashWidth = opts["stroke-width"] * 4;
        const dotSpacing = opts["stroke-width"] * 2;
        switch (pen.style) {
          case Helper$1.GDI.PenStyle.PS_DASH:
            opts["stroke-dasharray"] = [dashWidth, dotSpacing].toString();
            break;
          case Helper$1.GDI.PenStyle.PS_DOT:
            opts["stroke-dasharray"] = [dotWidth, dotSpacing].toString();
            break;
          case Helper$1.GDI.PenStyle.PS_DASHDOT:
            opts["stroke-dasharray"] = [dashWidth, dotSpacing, dotWidth, dotSpacing].toString();
            break;
          case Helper$1.GDI.PenStyle.PS_DASHDOTDOT:
            opts["stroke-dasharray"] = [dashWidth, dotSpacing, dotWidth, dotSpacing, dotWidth, dotSpacing].toString();
            break;
        }
      }
    }
    if (useBrush) {
      const brush = this.state.selected.brush;
      switch (brush.style) {
        case Helper$1.GDI.BrushStyle.BS_SOLID:
          opts.fill = "#" + brush.color.toHex();
          break;
        case Helper$1.GDI.BrushStyle.BS_PATTERN:
        case Helper$1.GDI.BrushStyle.BS_DIBPATTERNPT:
          opts.fill = "url(#" + this._getSvgPatternForBrush(brush) + ")";
          break;
        case Helper$1.GDI.BrushStyle.BS_NULL:
          opts.fill = "none";
          break;
        default:
          Helper$1.log("[gdi] unsupported brush style: " + brush.style);
          opts.fill = "none";
          break;
      }
    }
    if (useFont) {
      const font = this.state.selected.font;
      opts["font-family"] = font.facename;
      opts["font-size"] = Math.abs(font.height);
      opts.fill = "#" + this.state.textcolor.toHex();
    }
    return opts;
  }
};
let Renderer$1 = class Renderer {
  constructor(blob) {
    this.parse(blob);
    Helper$1.log("EMFJS.Renderer instantiated");
  }
  render(info) {
    const svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this._render(new SVG(svgElement), info.mapMode, info.wExt, info.hExt, info.xExt, info.yExt);
    svgElement.setAttribute("viewBox", [0, 0, info.xExt, info.yExt].join(" "));
    svgElement.setAttribute("preserveAspectRatio", "none");
    svgElement.setAttribute("width", info.width);
    svgElement.setAttribute("height", info.height);
    return svgElement;
  }
  parse(blob) {
    this._img = null;
    const reader = new Blob$2(blob);
    const type2 = reader.readUint32();
    if (type2 !== 1) {
      throw new EMFJSError("Not an EMF file");
    }
    const size = reader.readUint32();
    if (size % 4 !== 0) {
      throw new EMFJSError("Not an EMF file");
    }
    this._img = new EMF(reader, size);
    if (this._img == null) {
      throw new EMFJSError("Format not recognized");
    }
  }
  _render(svg, mapMode, w2, h, xExt, yExt) {
    const gdi = new GDIContext$1(svg);
    gdi.setWindowExtEx(w2, h);
    gdi.setViewportExtEx(xExt, yExt);
    gdi.setMapMode(mapMode);
    Helper$1.log("[EMF] BEGIN RENDERING --->");
    this._img.render(gdi);
    Helper$1.log("[EMF] <--- DONE RENDERING");
  }
};
class EMF {
  constructor(reader, hdrsize) {
    this._hdrsize = hdrsize;
    this._records = new EMFRecords(reader, this._hdrsize);
  }
  render(gdi) {
    this._records.play(gdi);
  }
}
class WMFJSError extends Error {
  constructor(message) {
    super(message);
    Object.setPrototypeOf(this, new.target.prototype);
  }
}
let isLoggingEnabled = true;
function loggingEnabled(enabled) {
  isLoggingEnabled = enabled;
}
const _Helper = class _Helper {
  static log(message) {
    if (isLoggingEnabled) {
      console.log(message);
    }
  }
  static _makeUniqueId(prefix) {
    return "wmfjs_" + prefix + this._uniqueId++;
  }
  static _writeUint32Val(uint8arr, pos, val) {
    uint8arr[pos++] = val & 255;
    uint8arr[pos++] = val >>> 8 & 255;
    uint8arr[pos++] = val >>> 16 & 255;
    uint8arr[pos++] = val >>> 24 & 255;
  }
  static _blobToBinary(blob) {
    let ret = "";
    const len = blob.length;
    for (let i = 0; i < len; i++) {
      ret += String.fromCharCode(blob[i]);
    }
    return ret;
  }
};
_Helper.GDI = {
  METAHEADER_SIZE: 18,
  BITMAPINFOHEADER_SIZE: 40,
  BITMAPCOREHEADER_SIZE: 12,
  MetafileType: {
    MEMORYMETAFILE: 1,
    DISKMETAFILE: 2
  },
  MetafileVersion: {
    METAVERSION100: 256,
    METAVERSION300: 768
  },
  RecordType: {
    META_EOF: 0,
    META_REALIZEPALETTE: 53,
    META_SETPALENTRIES: 55,
    META_SETBKMODE: 258,
    META_SETMAPMODE: 259,
    META_SETROP2: 260,
    META_SETRELABS: 261,
    META_SETPOLYFILLMODE: 262,
    META_SETSTRETCHBLTMODE: 263,
    META_SETTEXTCHAREXTRA: 264,
    META_RESTOREDC: 295,
    META_RESIZEPALETTE: 313,
    META_DIBCREATEPATTERNBRUSH: 322,
    META_SETLAYOUT: 329,
    META_SETBKCOLOR: 513,
    META_SETTEXTCOLOR: 521,
    META_OFFSETVIEWPORTORG: 529,
    META_LINETO: 531,
    META_MOVETO: 532,
    META_OFFSETCLIPRGN: 544,
    META_FILLREGION: 552,
    META_SETMAPPERFLAGS: 561,
    META_SELECTPALETTE: 564,
    META_POLYGON: 804,
    META_POLYLINE: 805,
    META_SETTEXTJUSTIFICATION: 522,
    META_SETWINDOWORG: 523,
    META_SETWINDOWEXT: 524,
    META_SETVIEWPORTORG: 525,
    META_SETVIEWPORTEXT: 526,
    META_OFFSETWINDOWORG: 527,
    META_SCALEWINDOWEXT: 1040,
    META_SCALEVIEWPORTEXT: 1042,
    META_EXCLUDECLIPRECT: 1045,
    META_INTERSECTCLIPRECT: 1046,
    META_ELLIPSE: 1048,
    META_FLOODFILL: 1049,
    META_FRAMEREGION: 1065,
    META_ANIMATEPALETTE: 1078,
    META_TEXTOUT: 1313,
    META_POLYPOLYGON: 1336,
    META_EXTFLOODFILL: 1352,
    META_RECTANGLE: 1051,
    META_SETPIXEL: 1055,
    META_ROUNDRECT: 1564,
    META_PATBLT: 1565,
    META_SAVEDC: 30,
    META_PIE: 2074,
    META_STRETCHBLT: 2851,
    META_ESCAPE: 1574,
    META_INVERTREGION: 298,
    META_PAINTREGION: 299,
    META_SELECTCLIPREGION: 300,
    META_SELECTOBJECT: 301,
    META_SETTEXTALIGN: 302,
    META_ARC: 2071,
    META_CHORD: 2096,
    META_BITBLT: 2338,
    META_EXTTEXTOUT: 2610,
    META_SETDIBTODEV: 3379,
    META_DIBBITBLT: 2368,
    META_DIBSTRETCHBLT: 2881,
    META_STRETCHDIB: 3907,
    META_DELETEOBJECT: 496,
    META_CREATEPALETTE: 247,
    META_CREATEPATTERNBRUSH: 505,
    META_CREATEPENINDIRECT: 762,
    META_CREATEFONTINDIRECT: 763,
    META_CREATEBRUSHINDIRECT: 764,
    META_CREATEREGION: 1791
  },
  MetafileEscapes: {
    NEWFRAME: 1,
    ABORTDOC: 2,
    NEXTBAND: 3,
    SETCOLORTABLE: 4,
    GETCOLORTABLE: 5,
    FLUSHOUT: 6,
    DRAFTMODE: 7,
    QUERYESCSUPPORT: 8,
    SETABORTPROC: 9,
    STARTDOC: 10,
    ENDDOC: 11,
    GETPHYSPAGESIZE: 12,
    GETPRINTINGOFFSET: 13,
    GETSCALINGFACTOR: 14,
    META_ESCAPE_ENHANCED_METAFILE: 15,
    SETPENWIDTH: 16,
    SETCOPYCOUNT: 17,
    SETPAPERSOURCE: 18,
    PASSTHROUGH: 19,
    GETTECHNOLOGY: 20,
    SETLINECAP: 21,
    SETLINEJOIN: 22,
    SETMITERLIMIT: 23,
    BANDINFO: 24,
    DRAWPATTERNRECT: 25,
    GETVECTORPENSIZE: 26,
    GETVECTORBRUSHSIZE: 27,
    ENABLEDUPLEX: 28,
    GETSETPAPERBINS: 29,
    GETSETPRINTORIENT: 30,
    ENUMPAPERBINS: 31,
    SETDIBSCALING: 32,
    EPSPRINTING: 33,
    ENUMPAPERMETRICS: 34,
    GETSETPAPERMETRICS: 35,
    POSTSCRIPT_DATA: 37,
    POSTSCRIPT_IGNORE: 38,
    GETDEVICEUNITS: 42,
    GETEXTENDEDTEXTMETRICS: 256,
    GETPAIRKERNTABLE: 258,
    EXTTEXTOUT: 512,
    GETFACENAME: 513,
    DOWNLOADFACE: 514,
    METAFILE_DRIVER: 2049,
    QUERYDIBSUPPORT: 3073,
    BEGIN_PATH: 4096,
    CLIP_TO_PATH: 4097,
    END_PATH: 4098,
    OPEN_CHANNEL: 4110,
    DOWNLOADHEADER: 4111,
    CLOSE_CHANNEL: 4112,
    POSTSCRIPT_PASSTHROUGH: 4115,
    ENCAPSULATED_POSTSCRIPT: 4116,
    POSTSCRIPT_IDENTIFY: 4117,
    POSTSCRIPT_INJECTION: 4118,
    CHECKJPEGFORMAT: 4119,
    CHECKPNGFORMAT: 4120,
    GET_PS_FEATURESETTING: 4121,
    MXDC_ESCAPE: 4122,
    SPCLPASSTHROUGH2: 4568
  },
  MapMode: {
    MM_TEXT: 1,
    MM_LOMETRIC: 2,
    MM_HIMETRIC: 3,
    MM_LOENGLISH: 4,
    MM_HIENGLISH: 5,
    MM_TWIPS: 6,
    MM_ISOTROPIC: 7,
    MM_ANISOTROPIC: 8
  },
  StretchMode: {
    BLACKONWHITE: 1,
    WHITEONBLACK: 2,
    COLORONCOLOR: 3,
    HALFTONE: 4
  },
  TextAlignmentMode: {
    TA_UPDATECP: 1,
    TA_RIGHT: 2,
    TA_CENTER: 6,
    TA_BOTTOM: 8,
    TA_BASELINE: 24,
    TA_RTLREADING: 256
  },
  MixMode: {
    TRANSPARENT: 1,
    OPAQUE: 2
  },
  VerticalTextAlignmentMode: {
    VTA_BOTTOM: 2,
    VTA_CENTER: 6,
    VTA_LEFT: 8,
    VTA_BASELINE: 24
  },
  BrushStyle: {
    BS_SOLID: 0,
    BS_NULL: 1,
    BS_HATCHED: 2,
    BS_PATTERN: 3,
    BS_INDEXED: 4,
    BS_DIBPATTERN: 5,
    BS_DIBPATTERNPT: 6,
    BS_PATTERN8X8: 7,
    BS_DIBPATTERN8X8: 8,
    BS_MONOPATTERN: 9
  },
  PenStyle: {
    PS_SOLID: 0,
    PS_DASH: 1,
    PS_DOT: 2,
    PS_DASHDOT: 3,
    PS_DASHDOTDOT: 4,
    PS_NULL: 5,
    PS_INSIDEFRAME: 6,
    PS_USERSTYLE: 7,
    PS_ALTERNATE: 8,
    PS_ENDCAP_SQUARE: 256,
    PS_ENDCAP_FLAT: 512,
    PS_JOIN_BEVEL: 4096,
    PS_JOIN_MITER: 8192
  },
  PolyFillMode: {
    ALTERNATE: 1,
    WINDING: 2
  },
  ColorUsage: {
    DIB_RGB_COLORS: 0,
    DIB_PAL_COLORS: 1,
    DIB_PAL_INDICES: 2
  },
  PaletteEntryFlag: {
    PC_RESERVED: 1,
    PC_EXPLICIT: 2,
    PC_NOCOLLAPSE: 4
  },
  BitmapCompression: {
    BI_RGB: 0,
    BI_RLE8: 1,
    BI_RLE4: 2,
    BI_BITFIELDS: 3,
    BI_JPEG: 4,
    BI_PNG: 5
  }
};
_Helper._uniqueId = 0;
let Helper = _Helper;
let Blob$1 = class Blob3 {
  constructor(blob, offset) {
    if (blob instanceof Blob3) {
      this.blob = blob.blob;
      this.data = blob.data;
      this.pos = offset || blob.pos;
    } else {
      this.blob = blob;
      this.data = new Uint8Array(blob);
      this.pos = offset || 0;
    }
  }
  eof() {
    return this.pos >= this.data.length;
  }
  seek(newpos) {
    if (newpos < 0 || newpos > this.data.length) {
      throw new WMFJSError("Invalid seek position");
    }
    this.pos = newpos;
  }
  skip(cnt) {
    const newPos = this.pos + cnt;
    if (newPos > this.data.length) {
      throw new WMFJSError("Unexpected end of file");
    }
    this.pos = newPos;
  }
  readBinary(cnt) {
    const end = this.pos + cnt;
    if (end > this.data.length) {
      throw new WMFJSError("Unexpected end of file");
    }
    let ret = "";
    while (cnt-- > 0) {
      ret += String.fromCharCode(this.data[this.pos++]);
    }
    return ret;
  }
  readInt8() {
    if (this.pos + 1 > this.data.length) {
      throw new WMFJSError("Unexpected end of file");
    }
    return this.data[this.pos++];
  }
  readUint8() {
    return this.readInt8() >>> 0;
  }
  readInt32() {
    if (this.pos + 4 > this.data.length) {
      throw new WMFJSError("Unexpected end of file");
    }
    let val = this.data[this.pos++];
    val |= this.data[this.pos++] << 8;
    val |= this.data[this.pos++] << 16;
    val |= this.data[this.pos++] << 24;
    return val;
  }
  readUint32() {
    return this.readInt32() >>> 0;
  }
  readUint16() {
    if (this.pos + 2 > this.data.length) {
      throw new WMFJSError("Unexpected end of file");
    }
    let val = this.data[this.pos++];
    val |= this.data[this.pos++] << 8;
    return val;
  }
  readInt16() {
    let val = this.readUint16();
    if (val > 32767) {
      val -= 65536;
    }
    return val;
  }
  readString(length) {
    if (this.pos + length > this.data.length) {
      throw new WMFJSError("Unexpected end of file");
    }
    let ret = "";
    for (let i = 0; i < length; i++) {
      ret += String.fromCharCode(this.data[this.pos++] >>> 0);
    }
    return ret;
  }
  readNullTermString(maxSize) {
    let ret = "";
    if (maxSize > 0) {
      maxSize--;
      for (let i = 0; i < maxSize; i++) {
        if (this.pos + i + 1 > this.data.length) {
          throw new WMFJSError("Unexpected end of file");
        }
        const byte = this.data[this.pos + i] >>> 0;
        if (byte === 0) {
          break;
        }
        ret += String.fromCharCode(byte);
      }
    }
    return ret;
  }
};
class PointS2 {
  constructor(reader, x2, y2) {
    if (reader != null) {
      this.x = reader.readInt16();
      this.y = reader.readInt16();
    } else {
      this.x = x2;
      this.y = y2;
    }
  }
  clone() {
    return new PointS2(null, this.x, this.y);
  }
  toString() {
    return "{x: " + this.x + ", y: " + this.y + "}";
  }
}
class Rect {
  constructor(reader, left, top, right, bottom) {
    if (reader != null) {
      this.bottom = reader.readInt16();
      this.right = reader.readInt16();
      this.top = reader.readInt16();
      this.left = reader.readInt16();
    } else {
      this.bottom = bottom;
      this.right = right;
      this.top = top;
      this.left = left;
    }
  }
  clone() {
    return new Rect(null, this.left, this.top, this.right, this.bottom);
  }
  toString() {
    return "{left: " + this.left + ", top: " + this.top + ", right: " + this.right + ", bottom: " + this.bottom + "}";
  }
  empty() {
    return this.left >= this.right || this.top >= this.bottom;
  }
  intersect(rect) {
    if (this.empty() || rect.empty()) {
      return null;
    }
    if (this.left >= rect.right || this.top >= rect.bottom || this.right <= rect.left || this.bottom <= rect.top) {
      return null;
    }
    return new Rect(
      null,
      Math.max(this.left, rect.left),
      Math.max(this.top, rect.top),
      Math.min(this.right, rect.right),
      Math.min(this.bottom, rect.bottom)
    );
  }
}
class Obj2 {
  constructor(type2) {
    this.type = type2;
  }
  clone() {
    throw new WMFJSError("clone not implemented");
  }
  toString() {
    throw new WMFJSError("toString not implemented");
  }
}
class Region2 extends Obj2 {
  constructor(reader, copy2) {
    super("region");
    if (reader != null) {
      reader.skip(2);
      if (reader.readInt16() !== 6) {
        throw new WMFJSError("Invalid region identifier");
      }
      reader.skip(2);
      reader.readInt16();
      const scanCnt = reader.readInt16();
      reader.skip(2);
      const left = reader.readInt16();
      const top = reader.readInt16();
      const right = reader.readInt16();
      const bottom = reader.readInt16();
      this.bounds = new Rect(null, left, top, right, bottom);
      this.scans = [];
      for (let i = 0; i < scanCnt; i++) {
        this.scans.push(new Scan2(reader));
      }
      this._updateComplexity();
    } else if (copy2 != null) {
      this.bounds = copy2.bounds != null ? copy2.bounds.clone() : null;
      if (copy2.scans != null) {
        this.scans = [];
        for (let i = 0; i < copy2.scans.length; i++) {
          this.scans.push(copy2.scans[i].clone());
        }
      } else {
        this.scans = null;
      }
      this.complexity = copy2.complexity;
    } else {
      this.bounds = null;
      this.scans = null;
      this.complexity = 0;
    }
  }
  clone() {
    return new Region2(null, this);
  }
  toString() {
    const _complexity = ["null", "simple", "complex"];
    return "{complexity: " + _complexity[this.complexity] + " bounds: " + (this.bounds != null ? this.bounds.toString() : "[none]") + " #scans: " + (this.scans != null ? this.scans.length : "[none]") + "}";
  }
  _updateComplexity() {
    if (this.bounds == null) {
      this.complexity = 0;
      this.scans = null;
    } else if (this.bounds.empty()) {
      this.complexity = 0;
      this.scans = null;
      this.bounds = null;
    } else if (this.scans == null) {
      this.complexity = 1;
    } else {
      this.complexity = 2;
      if (this.scans.length === 1) {
        const scan = this.scans[0];
        if (scan.top === this.bounds.top && scan.bottom === this.bounds.bottom && scan.scanlines.length === 1) {
          const scanline = scan.scanlines[0];
          if (scanline.left === this.bounds.left && scanline.right === this.bounds.right) {
            this.scans = null;
            this.complexity = 1;
          }
        }
      }
    }
  }
  subtract(rect) {
    Helper.log("[wmf] Region " + this.toString() + " subtract " + rect.toString());
    if (this.bounds != null) {
      const isect = this.bounds.intersect(rect);
      if (isect != null) {
        if (this.scans == null) {
          this.scans = [];
          this.scans.push(
            new Scan2(null, null, this.bounds.top, this.bounds.bottom, [
              { left: this.bounds.left, right: this.bounds.right }
            ])
          );
          this.complexity = 2;
        }
        let si = 0;
        while (si < this.scans.length) {
          const scan = this.scans[si];
          if (scan.bottom >= rect.top) {
            const cloned = scan.clone();
            scan.bottom = rect.top - 1;
            cloned.top = rect.top;
            if (scan.top >= scan.bottom) {
              this.scans[si] = cloned;
            } else {
              Helper.log("[wmf] Region split top scan " + si + " for substraction");
              this.scans.splice(++si, 0, cloned);
            }
            break;
          }
          si++;
        }
        const first = si;
        while (si < this.scans.length) {
          const scan = this.scans[si];
          if (scan.top > rect.bottom) {
            break;
          }
          if (scan.bottom > rect.bottom) {
            const cloned = scan.clone();
            scan.bottom = rect.bottom;
            cloned.top = rect.bottom + 1;
            if (scan.top >= scan.bottom) {
              this.scans[si] = cloned;
            } else {
              Helper.log("[wmf] Region split bottom scan " + si + " for substraction");
              this.scans.splice(++si, 0, cloned);
            }
            break;
          }
          si++;
        }
        if (first < this.scans.length) {
          let last = si;
          si = first;
          while (si < last) {
            const scan = this.scans[si];
            if (!scan.subtract(rect.left, rect.right)) {
              Helper.log("[wmf] Region remove now empty scan " + si + " due to subtraction");
              this.scans.splice(si, 1);
              last--;
              continue;
            }
            si++;
          }
        }
        if (this.scans != null) {
          let left;
          let top;
          let right;
          let bottom;
          const len = this.scans.length;
          for (let i = 0; i < len; i++) {
            const scan = this.scans[i];
            if (i === 0) {
              top = scan.top;
            }
            if (i === len - 1) {
              bottom = scan.bottom;
            }
            const slen = scan.scanlines.length;
            if (slen > 0) {
              let scanline = scan.scanlines[0];
              if (left == null || scanline.left < left) {
                left = scanline.left;
              }
              scanline = scan.scanlines[slen - 1];
              if (right == null || scanline.right > right) {
                right = scanline.right;
              }
            }
          }
          if (left != null && top != null && right != null && bottom != null) {
            this.bounds = new Rect(null, left, top, right, bottom);
            this._updateComplexity();
          } else {
            this.bounds = null;
            this.scans = null;
            this.complexity = 0;
          }
        } else {
          this._updateComplexity();
        }
      }
    }
    Helper.log("[wmf] Region subtraction -> " + this.toString());
  }
  intersect(rect) {
    Helper.log("[wmf] Region " + this.toString() + " intersect with " + rect.toString());
    if (this.bounds != null) {
      this.bounds = this.bounds.intersect(rect);
      if (this.bounds != null) {
        if (this.scans != null) {
          let si = 0;
          while (si < this.scans.length) {
            const scan = this.scans[si];
            if (scan.bottom < this.bounds.top) {
              si++;
            } else {
              break;
            }
          }
          if (si > 0) {
            Helper.log("[wmf] Region remove " + si + " scans from top");
            this.scans.splice(0, si);
            if (this.scans.length > 0) {
              this.scans[0].top = this.bounds.top;
            }
          }
          si = 0;
          while (si < this.scans.length) {
            const scan = this.scans[si];
            if (scan.top > this.bounds.bottom) {
              Helper.log("[wmf] Region remove " + (this.scans.length - si) + " scans from bottom");
              this.scans.splice(si, this.scans.length - si);
              break;
            }
            if (!scan.intersect(this.bounds.left, this.bounds.right)) {
              Helper.log("[wmf] Region remove now empty scan " + si + " due to intersection");
              this.scans.splice(si, 1);
              continue;
            }
            si++;
          }
          if (this.scans.length > 0) {
            this.scans[this.scans.length - 1].bottom = this.bounds.bottom;
          }
          this._updateComplexity();
        }
      } else {
        this.scans = null;
        this.complexity = 0;
      }
    }
    Helper.log("[wmf] Region intersection -> " + this.toString());
  }
  offset(offX, offY) {
    if (this.bounds != null) {
      this.bounds.left += offX;
      this.bounds.top += offY;
      this.bounds.right += offX;
      this.bounds.bottom += offY;
    }
    if (this.scans != null) {
      const slen = this.scans.length;
      for (let si = 0; si < slen; si++) {
        const scan = this.scans[si];
        scan.top += offY;
        scan.bottom += offY;
        const len = scan.scanlines.length;
        for (let i = 0; i < len; i++) {
          const scanline = scan.scanlines[i];
          scanline.left += offX;
          scanline.right += offX;
        }
      }
    }
  }
}
function CreateSimpleRegion(left, top, right, bottom) {
  const rgn = new Region2(null, null);
  rgn.bounds = new Rect(null, left, top, right, bottom);
  rgn._updateComplexity();
  return rgn;
}
class Scan2 {
  constructor(reader, copy2, top, bottom, scanlines) {
    if (reader != null) {
      const cnt = reader.readUint16();
      this.top = reader.readUint16();
      this.bottom = reader.readUint16();
      this.scanlines = [];
      for (let i = 0; i < cnt; i++) {
        const left = reader.readUint16();
        const right = reader.readUint16();
        this.scanlines.push({ left, right });
      }
      reader.skip(2);
    } else if (copy2 != null) {
      this.top = copy2.top;
      this.bottom = copy2.bottom;
      this.scanlines = [];
      for (let i = 0; i < copy2.scanlines.length; i++) {
        const scanline = copy2.scanlines[i];
        this.scanlines.push({ left: scanline.left, right: scanline.right });
      }
    } else {
      this.top = top;
      this.bottom = bottom;
      this.scanlines = scanlines;
    }
  }
  clone() {
    return new Scan2(null, this);
  }
  subtract(left, right) {
    let i;
    i = 0;
    while (i < this.scanlines.length) {
      const scanline = this.scanlines[i];
      if (scanline.left <= left) {
        if (scanline.right >= left) {
          scanline.right = left - 1;
          if (scanline.left >= scanline.right) {
            this.scanlines.splice(i, 1);
            continue;
          }
        }
        i++;
      } else {
        break;
      }
    }
    const first = i;
    let cnt = 0;
    while (i < this.scanlines.length) {
      const scanline = this.scanlines[i];
      if (scanline.right > right) {
        scanline.left = right;
        cnt = i - first;
        if (scanline.left >= scanline.right) {
          cnt++;
        }
        break;
      }
      i++;
    }
    if (cnt > 0 && first < this.scanlines.length) {
      this.scanlines.splice(first, cnt);
    }
    return this.scanlines.length > 0;
  }
  intersect(left, right) {
    for (let i = 0; i < this.scanlines.length; i++) {
      const scanline = this.scanlines[i];
      if (scanline.left >= left || scanline.right >= left) {
        if (i > 0) {
          this.scanlines.splice(0, i);
        }
        break;
      }
    }
    if (this.scanlines.length > 0) {
      let scanline = this.scanlines[0];
      if (scanline.left < left) {
        scanline.left = left;
      }
      for (let i = 0; i < this.scanlines.length; i++) {
        scanline = this.scanlines[i];
        if (scanline.left > right) {
          this.scanlines.splice(i, this.scanlines.length - i);
          break;
        }
      }
      if (this.scanlines.length > 0) {
        scanline = this.scanlines[this.scanlines.length - 1];
        if (scanline.right > right) {
          scanline.right = right;
        }
      }
    }
    return this.scanlines.length > 0;
  }
  toString() {
    return "{ #scanlines: " + this.scanlines.length + "}";
  }
}
class BitmapCoreHeader2 {
  constructor(reader, skipsize) {
    if (skipsize) {
      reader.skip(4);
    }
    this.width = reader.readUint16();
    this.height = reader.readUint16();
    this.planes = reader.readUint16();
    this.bitcount = reader.readUint16();
  }
  colors() {
    return this.bitcount <= 8 ? 1 << this.bitcount : 0;
  }
}
class BitmapInfoHeader2 {
  constructor(reader, skipsize) {
    if (skipsize) {
      reader.skip(4);
    }
    this.width = reader.readInt32();
    this.height = reader.readInt32();
    this.planes = reader.readUint16();
    this.bitcount = reader.readUint16();
    this.compression = reader.readUint32();
    this.sizeimage = reader.readUint32();
    this.xpelspermeter = reader.readInt32();
    this.ypelspermeter = reader.readInt32();
    this.clrused = reader.readUint32();
    this.clrimportant = reader.readUint32();
  }
  colors() {
    if (this.clrused !== 0) {
      return this.clrused < 256 ? this.clrused : 256;
    } else {
      return this.bitcount > 8 ? 0 : 1 << this.bitcount;
    }
  }
}
class BitmapInfo2 {
  constructor(reader, usergb) {
    this._reader = reader;
    this._offset = reader.pos;
    this._usergb = usergb;
    const hdrsize = reader.readUint32();
    this._infosize = hdrsize;
    if (hdrsize === Helper.GDI.BITMAPCOREHEADER_SIZE) {
      this._header = new BitmapCoreHeader2(reader, false);
      this._infosize += this._header.colors() * (usergb ? 3 : 2);
    } else {
      this._header = new BitmapInfoHeader2(reader, false);
      const masks = this._header.compression === Helper.GDI.BitmapCompression.BI_BITFIELDS ? 3 : 0;
      if (hdrsize <= Helper.GDI.BITMAPINFOHEADER_SIZE + masks * 4) {
        this._infosize = Helper.GDI.BITMAPINFOHEADER_SIZE + masks * 4;
      }
      this._infosize += this._header.colors() * (usergb ? 4 : 2);
    }
  }
  getWidth() {
    return this._header.width;
  }
  getHeight() {
    return Math.abs(this._header.height);
  }
  infosize() {
    return this._infosize;
  }
  header() {
    return this._header;
  }
}
class DIBitmap2 {
  constructor(reader, size) {
    this._reader = reader;
    this._offset = reader.pos;
    this._size = size;
    this._info = new BitmapInfo2(reader, true);
  }
  getWidth() {
    return this._info.getWidth();
  }
  getHeight() {
    return this._info.getHeight();
  }
  base64ref() {
    const prevpos = this._reader.pos;
    this._reader.seek(this._offset);
    let mime = "image/bmp";
    const header = this._info.header();
    let data;
    if (header instanceof BitmapInfoHeader2 && header.compression != null) {
      switch (header.compression) {
        case Helper.GDI.BitmapCompression.BI_JPEG:
          mime = "data:image/jpeg";
          break;
        case Helper.GDI.BitmapCompression.BI_PNG:
          mime = "data:image/png";
          break;
        default:
          data = this.makeBitmapFileHeader();
          break;
      }
    } else {
      data = this.makeBitmapFileHeader();
    }
    if (data != null) {
      data += this._reader.readBinary(this._size);
    } else {
      data = this._reader.readBinary(this._size);
    }
    const ref2 = "data:" + mime + ";base64," + btoa(data);
    this._reader.seek(prevpos);
    return ref2;
  }
  makeBitmapFileHeader() {
    const buf = new ArrayBuffer(14);
    const view = new Uint8Array(buf);
    view[0] = 66;
    view[1] = 77;
    Helper._writeUint32Val(view, 2, this._size + 14);
    Helper._writeUint32Val(view, 10, this._info.infosize() + 14);
    return Helper._blobToBinary(view);
  }
}
class Bitmap16 {
  constructor(reader, size) {
    if (reader != null) {
      size = size;
      this._reader = reader;
      this._offset = reader.pos;
      this._size = size;
      this.type = reader.readInt16();
      this.width = reader.readInt16();
      this.height = reader.readInt16();
      this.widthBytes = reader.readInt16();
      this.planes = reader.readUint8();
      this.bitsPixel = reader.readUint8();
      this.bitsOffset = reader.pos;
      this.bitsSize = (this.width * this.bitsPixel + 15 >> 4 << 1) * this.height;
      if (this.bitsSize > size - 10) {
        throw new WMFJSError("Bitmap should have " + this.bitsSize + " bytes, but has " + (size - 10));
      }
    } else {
      const copy2 = size;
      this._reader = copy2._reader;
      this._offset = copy2._offset;
      this._size = copy2._size;
      this.type = copy2.type;
      this.width = copy2.width;
      this.height = copy2.height;
      this.widthBytes = copy2.widthBytes;
      this.planes = copy2.planes;
      this.bitsPixel = copy2.bitsPixel;
      this.bitsOffset = copy2.bitsOffset;
      this.bitsSize = copy2.bitsSize;
    }
  }
  getWidth() {
    return this.width;
  }
  getHeight() {
    return this.height;
  }
  clone() {
    return new Bitmap16(null, this);
  }
}
class PatternBitmap16 extends Bitmap16 {
  constructor(reader, size) {
    super(reader, size);
    if (reader != null) {
      this.bitsOffset += 22;
    }
  }
  clone() {
    return new PatternBitmap16(null, this);
  }
}
class ColorRef2 {
  constructor(reader, r, g, b2) {
    if (reader != null) {
      this.r = reader.readUint8();
      this.g = reader.readUint8();
      this.b = reader.readUint8();
      reader.skip(1);
    } else {
      this.r = r;
      this.g = g;
      this.b = b2;
    }
  }
  clone() {
    return new ColorRef2(null, this.r, this.g, this.b);
  }
  toHex() {
    const rgb = this.r << 16 | this.g << 8 | this.b;
    return (16777216 + rgb).toString(16).slice(1);
  }
  toString() {
    return "{r: " + this.r + ", g: " + this.g + ", b: " + this.b + "}";
  }
}
class Font2 extends Obj2 {
  constructor(reader, copy2) {
    super("font");
    if (reader != null) {
      this.height = reader.readInt16();
      this.width = reader.readInt16();
      this.escapement = reader.readInt16();
      this.orientation = reader.readInt16();
      this.weight = reader.readInt16();
      this.italic = reader.readUint8();
      this.underline = reader.readUint8();
      this.strikeout = reader.readUint8();
      this.charset = reader.readUint8();
      this.outprecision = reader.readUint8();
      this.clipprecision = reader.readUint8();
      this.quality = reader.readUint8();
      const pitchAndFamily = reader.readUint8();
      this.pitch = pitchAndFamily & 15;
      this.family = pitchAndFamily >> 6 & 3;
      const dataLength = copy2;
      const start = reader.pos;
      this.facename = reader.readNullTermString(Math.min(dataLength - (reader.pos - start), 32));
    } else if (copy2 != null) {
      copy2 = copy2;
      this.height = copy2.height;
      this.width = copy2.width;
      this.escapement = copy2.escapement;
      this.orientation = copy2.orientation;
      this.weight = copy2.weight;
      this.italic = copy2.italic;
      this.underline = copy2.underline;
      this.strikeout = copy2.strikeout;
      this.charset = copy2.charset;
      this.outprecision = copy2.outprecision;
      this.clipprecision = copy2.clipprecision;
      this.quality = copy2.quality;
      this.pitch = copy2.pitch;
      this.family = copy2.family;
      this.facename = copy2.facename;
    } else {
      this.height = -80;
      this.width = 0;
      this.escapement = 0;
      this.orientation = 0;
      this.weight = 400;
      this.italic = 0;
      this.underline = 0;
      this.strikeout = 0;
      this.charset = 0;
      this.outprecision = 0;
      this.clipprecision = 0;
      this.quality = 0;
      this.pitch = 0;
      this.family = 0;
      this.facename = "Helvetica";
    }
  }
  clone() {
    return new Font2(null, this);
  }
  toString() {
    return JSON.stringify(this);
  }
}
class Brush2 extends Obj2 {
  constructor(reader, copy2, forceDibPattern) {
    super("brush");
    if (reader != null) {
      const dataLength = copy2;
      const start = reader.pos;
      if (forceDibPattern === true || forceDibPattern === false) {
        this.style = reader.readUint16();
        if (forceDibPattern && this.style !== Helper.GDI.BrushStyle.BS_PATTERN) {
          this.style = Helper.GDI.BrushStyle.BS_DIBPATTERNPT;
        }
        switch (this.style) {
          case Helper.GDI.BrushStyle.BS_SOLID:
            this.color = new ColorRef2(reader);
            break;
          case Helper.GDI.BrushStyle.BS_PATTERN:
            reader.skip(forceDibPattern ? 2 : 6);
            this.pattern = new Bitmap16(reader, dataLength - (reader.pos - start));
            break;
          case Helper.GDI.BrushStyle.BS_DIBPATTERNPT:
            this.colorusage = forceDibPattern ? reader.readUint16() : reader.readUint32();
            if (!forceDibPattern) {
              reader.skip(2);
            }
            this.dibpatternpt = new DIBitmap2(reader, dataLength - (reader.pos - start));
            break;
          case Helper.GDI.BrushStyle.BS_HATCHED:
            this.color = new ColorRef2(reader);
            this.hatchstyle = reader.readUint16();
            break;
        }
      } else if (forceDibPattern instanceof PatternBitmap16) {
        this.style = Helper.GDI.BrushStyle.BS_PATTERN;
        this.pattern = forceDibPattern;
      }
    } else if (copy2 != null) {
      copy2 = copy2;
      this.style = copy2.style;
      switch (this.style) {
        case Helper.GDI.BrushStyle.BS_SOLID:
          this.color = copy2.color.clone();
          break;
        case Helper.GDI.BrushStyle.BS_PATTERN:
          this.pattern = copy2.pattern.clone();
          break;
        case Helper.GDI.BrushStyle.BS_DIBPATTERNPT:
          this.colorusage = copy2.colorusage;
          this.dibpatternpt = copy2.dibpatternpt;
          break;
        case Helper.GDI.BrushStyle.BS_HATCHED:
          this.color = copy2.color.clone();
          this.hatchstyle = copy2.hatchstyle;
          break;
      }
    }
  }
  clone() {
    return new Brush2(null, this);
  }
  toString() {
    let ret = "{style: " + this.style;
    switch (this.style) {
      case Helper.GDI.BrushStyle.BS_SOLID:
        ret += ", color: " + this.color.toString();
        break;
      case Helper.GDI.BrushStyle.BS_DIBPATTERNPT:
        ret += ", colorusage: " + this.colorusage;
        break;
      case Helper.GDI.BrushStyle.BS_HATCHED:
        ret += ", color: " + this.color.toString() + ", hatchstyle: " + this.hatchstyle;
        break;
    }
    return ret + "}";
  }
}
class Pen2 extends Obj2 {
  constructor(reader, style, width, color, linecap, join2) {
    super("pen");
    if (reader != null) {
      style = reader.readUint16();
      this.style = style & 255;
      this.width = new PointS2(reader);
      this.color = new ColorRef2(reader);
      this.linecap = style & (Helper.GDI.PenStyle.PS_ENDCAP_SQUARE | Helper.GDI.PenStyle.PS_ENDCAP_FLAT);
      this.join = style & (Helper.GDI.PenStyle.PS_JOIN_BEVEL | Helper.GDI.PenStyle.PS_JOIN_MITER);
    } else {
      this.style = style;
      this.width = width;
      this.color = color;
      this.linecap = linecap;
      this.join = join2;
    }
  }
  clone() {
    return new Pen2(null, this.style, this.width.clone(), this.color.clone(), this.linecap, this.join);
  }
  toString() {
    return "{style: " + this.style + ", width: " + this.width.toString() + ", color: " + this.color.toString() + ", linecap: " + this.linecap + ", join: " + this.join + "}";
  }
}
class PaletteEntry {
  constructor(reader, copy2) {
    if (reader != null) {
      this.flag = reader.readUint8();
      this.b = reader.readUint8();
      this.g = reader.readUint8();
      this.r = reader.readUint8();
    } else {
      this.flag = copy2.flag;
      this.b = copy2.b;
      this.g = copy2.g;
      this.r = copy2.r;
    }
  }
  clone() {
    return new PaletteEntry(null, this);
  }
}
class Palette extends Obj2 {
  constructor(reader, copy2) {
    super("palette");
    if (reader != null) {
      this.start = reader.readUint16();
      let cnt = reader.readUint16();
      this.entries = [];
      while (cnt > 0) {
        this.entries.push(new PaletteEntry(reader));
        cnt--;
      }
    } else {
      this.start = copy2.start;
      this.entries = [];
      const len = copy2.entries.length;
      for (let i = 0; i < len; i++) {
        this.entries.push(copy2.entries[i]);
      }
    }
  }
  clone() {
    return new Palette(null, this);
  }
  toString() {
    return "{ #entries: " + this.entries.length + "}";
  }
}
class GDIContextState2 {
  constructor(copy2, defObjects) {
    if (copy2 != null) {
      this._svggroup = copy2._svggroup;
      this._svgclipChanged = copy2._svgclipChanged;
      this._svgtextbkfilter = copy2._svgtextbkfilter;
      this.mapmode = copy2.mapmode;
      this.stretchmode = copy2.stretchmode;
      this.textalign = copy2.textalign;
      this.bkmode = copy2.bkmode;
      this.textcolor = copy2.textcolor.clone();
      this.bkcolor = copy2.bkcolor.clone();
      this.polyfillmode = copy2.polyfillmode;
      this.wx = copy2.wx;
      this.wy = copy2.wy;
      this.ww = copy2.ww;
      this.wh = copy2.wh;
      this.vx = copy2.vx;
      this.vy = copy2.vy;
      this.vw = copy2.vw;
      this.vh = copy2.vh;
      this.x = copy2.x;
      this.y = copy2.y;
      this.clip = copy2.clip;
      this.ownclip = false;
      this.selected = {};
      for (const type2 in copy2.selected) {
        this.selected[type2] = copy2.selected[type2];
      }
    } else {
      this._svggroup = null;
      this._svgclipChanged = false;
      this._svgtextbkfilter = null;
      this.mapmode = Helper.GDI.MapMode.MM_ANISOTROPIC;
      this.stretchmode = Helper.GDI.StretchMode.COLORONCOLOR;
      this.textalign = 0;
      this.bkmode = Helper.GDI.MixMode.OPAQUE;
      this.textcolor = new ColorRef2(null, 0, 0, 0);
      this.bkcolor = new ColorRef2(null, 255, 255, 255);
      this.polyfillmode = Helper.GDI.PolyFillMode.ALTERNATE;
      this.wx = 0;
      this.wy = 0;
      this.ww = 0;
      this.wh = 0;
      this.vx = 0;
      this.vy = 0;
      this.vw = 0;
      this.vh = 0;
      this.x = 0;
      this.y = 0;
      this.clip = null;
      this.ownclip = false;
      this.selected = {};
      for (const type2 in defObjects) {
        const defObj = defObjects[type2];
        this.selected[type2] = defObj != null ? defObj.clone() : null;
      }
    }
  }
}
class GDIContext2 {
  constructor(svg) {
    this._svg = svg;
    this._svgdefs = null;
    this._svgPatterns = {};
    this._svgClipPaths = {};
    this.defObjects = {
      brush: new Brush2(null, null),
      pen: new Pen2(null, Helper.GDI.PenStyle.PS_SOLID, new PointS2(null, 1, 1), new ColorRef2(null, 0, 0, 0), 0, 0),
      font: new Font2(null, null),
      palette: null,
      region: null
    };
    this.state = new GDIContextState2(null, this.defObjects);
    this.statestack = [this.state];
    this.objects = {};
  }
  setMapMode(mode) {
    Helper.log("[gdi] setMapMode: mode=" + mode);
    this.state.mapmode = mode;
    this.state._svggroup = null;
  }
  setWindowOrg(x2, y2) {
    Helper.log("[gdi] setWindowOrg: x=" + x2 + " y=" + y2);
    this.state.wx = x2;
    this.state.wy = y2;
    this.state._svggroup = null;
  }
  setWindowExt(x2, y2) {
    Helper.log("[gdi] setWindowExt: x=" + x2 + " y=" + y2);
    this.state.ww = x2;
    this.state.wh = y2;
    this.state._svggroup = null;
  }
  offsetWindowOrg(offX, offY) {
    Helper.log("[gdi] offsetWindowOrg: offX=" + offX + " offY=" + offY);
    this.state.wx += offX;
    this.state.wy += offY;
    this.state._svggroup = null;
  }
  setViewportOrg(x2, y2) {
    Helper.log("[gdi] setViewportOrg: x=" + x2 + " y=" + y2);
    this.state.vx = x2;
    this.state.vy = y2;
    this.state._svggroup = null;
  }
  setViewportExt(x2, y2) {
    Helper.log("[gdi] setViewportExt: x=" + x2 + " y=" + y2);
    this.state.vw = x2;
    this.state.vh = y2;
    this.state._svggroup = null;
  }
  offsetViewportOrg(offX, offY) {
    Helper.log("[gdi] offsetViewportOrg: offX=" + offX + " offY=" + offY);
    this.state.vx += offX;
    this.state.vy += offY;
    this.state._svggroup = null;
  }
  saveDC() {
    Helper.log("[gdi] saveDC");
    const prevstate = this.state;
    this.state = new GDIContextState2(this.state);
    this.statestack.push(prevstate);
    this.state._svggroup = null;
  }
  restoreDC(saved) {
    Helper.log("[gdi] restoreDC: saved=" + saved);
    if (this.statestack.length > 1) {
      if (saved === -1) {
        this.state = this.statestack.pop();
      } else if (saved < -1) {
        throw new WMFJSError("restoreDC: relative restore not implemented");
      } else if (saved > 1) {
        throw new WMFJSError("restoreDC: absolute restore not implemented");
      }
    } else {
      throw new WMFJSError("No saved contexts");
    }
    this.state._svggroup = null;
  }
  escape(func, blob, offset, count) {
    Helper.log("[gdi] escape: func=" + func + " offset=" + offset + " count=" + count);
  }
  setStretchBltMode(stretchMode) {
    Helper.log("[gdi] setStretchBltMode: stretchMode=" + stretchMode);
  }
  stretchDib(srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH, rasterOp, colorUsage, dib) {
    Helper.log(
      "[gdi] stretchDib: srcX=" + srcX + " srcY=" + srcY + " srcW=" + srcW + " srcH=" + srcH + " dstX=" + dstX + " dstY=" + dstY + " dstW=" + dstW + " dstH=" + dstH + " rasterOp=0x" + rasterOp.toString(16)
    );
    srcX = this._todevX(srcX);
    srcY = this._todevY(srcY);
    srcW = this._todevW(srcW);
    srcH = this._todevH(srcH);
    dstX = this._todevX(dstX);
    dstY = this._todevY(dstY);
    dstW = this._todevW(dstW);
    dstH = this._todevH(dstH);
    Helper.log(
      "[gdi] stretchDib: TRANSLATED: srcX=" + srcX + " srcY=" + srcY + " srcW=" + srcW + " srcH=" + srcH + " dstX=" + dstX + " dstY=" + dstY + " dstW=" + dstW + " dstH=" + dstH + " rasterOp=0x" + rasterOp.toString(16) + " colorUsage=0x" + colorUsage.toString(16)
    );
    this._pushGroup();
    this._svg.image(this.state._svggroup, dstX, dstY, dstW, dstH, dib.base64ref());
  }
  dibBits(srcX, srcY, dstX, dstY, width, height, rasterOp, dib) {
    Helper.log(
      "[gdi] stretchDibBits: srcX=" + srcX + " srcY=" + srcY + " dstX=" + dstX + " dstY=" + dstY + " width=" + width + " height=" + height + " rasterOp=0x" + rasterOp.toString(16)
    );
    srcX = this._todevX(srcX);
    srcY = this._todevY(srcY);
    dstX = this._todevX(dstX);
    dstY = this._todevY(dstY);
    width = this._todevW(width);
    height = this._todevH(height);
    Helper.log(
      "[gdi] dibBits: TRANSLATED: srcX=" + srcX + " srcY=" + srcY + NaN + dstX + " dstY=" + dstY + " width=" + width + " height=" + height + " rasterOp=0x" + rasterOp.toString(16)
    );
    this._pushGroup();
    this._svg.image(this.state._svggroup, dstX, dstY, width, height, dib.base64ref());
  }
  stretchDibBits(srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH, rasterOp, dib) {
    Helper.log(
      "[gdi] stretchDibBits: srcX=" + srcX + " srcY=" + srcY + " srcW=" + srcW + " srcH=" + srcH + " dstX=" + dstX + " dstY=" + dstY + " dstW=" + dstW + " dstH=" + dstH + " rasterOp=0x" + rasterOp.toString(16)
    );
    srcX = this._todevX(srcX);
    srcY = this._todevY(srcY);
    srcW = this._todevW(srcW);
    srcH = this._todevH(srcH);
    dstX = this._todevX(dstX);
    dstY = this._todevY(dstY);
    dstW = this._todevW(dstW);
    dstH = this._todevH(dstH);
    Helper.log(
      "[gdi] stretchDibBits: TRANSLATED: srcX=" + srcX + " srcY=" + srcY + " srcW=" + srcW + " srcH=" + srcH + " dstX=" + dstX + " dstY=" + dstY + " dstW=" + dstW + " dstH=" + dstH + " rasterOp=0x" + rasterOp.toString(16)
    );
    this._pushGroup();
    this._svg.image(this.state._svggroup, dstX, dstY, dstW, dstH, dib.base64ref());
  }
  rectangle(rect, rw, rh) {
    Helper.log(
      "[gdi] rectangle: rect=" + rect.toString() + " with pen " + this.state.selected.pen.toString() + " and brush " + this.state.selected.brush.toString()
    );
    const bottom = this._todevY(rect.bottom);
    const right = this._todevX(rect.right);
    const top = this._todevY(rect.top);
    const left = this._todevX(rect.left);
    rw = this._todevH(rw);
    rh = this._todevH(rh);
    Helper.log(
      "[gdi] rectangle: TRANSLATED: bottom=" + bottom + " right=" + right + " top=" + top + " left=" + left + " rh=" + rh + " rw=" + rw
    );
    this._pushGroup();
    const opts = this._applyOpts(null, true, true, false);
    this._svg.rect(this.state._svggroup, left, top, right - left, bottom - top, rw / 2, rh / 2, opts);
  }
  textOut(x2, y2, text) {
    Helper.log(
      "[gdi] textOut: x=" + x2 + " y=" + y2 + " text=" + text + " with font " + this.state.selected.font.toString()
    );
    x2 = this._todevX(x2);
    y2 = this._todevY(y2);
    Helper.log("[gdi] textOut: TRANSLATED: x=" + x2 + " y=" + y2);
    this._pushGroup();
    const opts = this._applyOpts(null, false, false, true);
    if (this.state.selected.font.escapement !== 0) {
      opts.transform = "rotate(" + [-this.state.selected.font.escapement / 10, x2, y2] + ")";
      opts.style = "dominant-baseline: middle; text-anchor: start;";
    }
    if (this.state.bkmode === Helper.GDI.MixMode.OPAQUE) {
      if (this.state._svgtextbkfilter == null) {
        const filterId = Helper._makeUniqueId("f");
        const filter = this._svg.filter(this._getSvgDef(), filterId, 0, 0, 1, 1);
        this._svg.filters.flood(filter, null, "#" + this.state.bkcolor.toHex(), 1);
        this._svg.filters.composite(filter, null, null, "SourceGraphic");
        this.state._svgtextbkfilter = filter;
      }
      opts.filter = "url(#" + this.state._svgtextbkfilter.id + ")";
    }
    this._svg.text(this.state._svggroup, x2, y2, text, opts);
  }
  extTextOut(x2, y2, text, fwOpts, rect, dx) {
    Helper.log(
      "[gdi] extTextOut: x=" + x2 + " y=" + y2 + " text=" + text + " with font " + this.state.selected.font.toString()
    );
    x2 = this._todevX(x2);
    y2 = this._todevY(y2);
    Helper.log("[gdi] extTextOut: TRANSLATED: x=" + x2 + " y=" + y2);
    this._pushGroup();
    const opts = this._applyOpts(null, false, false, true);
    if (this.state.selected.font.escapement !== 0) {
      opts.transform = "rotate(" + [-this.state.selected.font.escapement / 10, x2, y2] + ")";
      opts.style = "dominant-baseline: middle; text-anchor: start;";
    }
    if (this.state.bkmode === Helper.GDI.MixMode.OPAQUE) {
      if (this.state._svgtextbkfilter == null) {
        const filterId = Helper._makeUniqueId("f");
        const filter = this._svg.filter(this._getSvgDef(), filterId, 0, 0, 1, 1);
        this._svg.filters.flood(filter, null, "#" + this.state.bkcolor.toHex(), 1);
        this._svg.filters.composite(filter, null, null, "SourceGraphic");
        this.state._svgtextbkfilter = filter;
      }
      opts.filter = "url(#" + this.state._svgtextbkfilter.id + ")";
    }
    this._svg.text(this.state._svggroup, x2, y2, text, opts);
  }
  lineTo(x2, y2) {
    Helper.log("[gdi] lineTo: x=" + x2 + " y=" + y2 + " with pen " + this.state.selected.pen.toString());
    const toX = this._todevX(x2);
    const toY = this._todevY(y2);
    const fromX = this._todevX(this.state.x);
    const fromY = this._todevY(this.state.y);
    this.state.x = x2;
    this.state.y = y2;
    Helper.log("[gdi] lineTo: TRANSLATED: toX=" + toX + " toY=" + toY + " fromX=" + fromX + " fromY=" + fromY);
    this._pushGroup();
    const opts = this._applyOpts(null, true, false, false);
    this._svg.line(this.state._svggroup, fromX, fromY, toX, toY, opts);
  }
  moveTo(x2, y2) {
    Helper.log("[gdi] moveTo: x=" + x2 + " y=" + y2);
    this.state.x = x2;
    this.state.y = y2;
  }
  polygon(points, first) {
    Helper.log(
      "[gdi] polygon: points=" + points + " with pen " + this.state.selected.pen.toString() + " and brush " + this.state.selected.brush.toString()
    );
    const pts = [];
    for (let i = 0; i < points.length; i++) {
      const point = points[i];
      pts.push([this._todevX(point.x), this._todevY(point.y)]);
    }
    Helper.log("[gdi] polygon: TRANSLATED: pts=" + pts);
    if (first) {
      this._pushGroup();
    }
    const opts = {
      "fill-rule": this.state.polyfillmode === Helper.GDI.PolyFillMode.ALTERNATE ? "evenodd" : "nonzero"
    };
    this._applyOpts(opts, true, true, false);
    this._svg.polygon(this.state._svggroup, pts, opts);
  }
  polyPolygon(polygons) {
    Helper.log(
      "[gdi] polyPolygon: polygons.length=" + polygons.length + " with pen " + this.state.selected.pen.toString() + " and brush " + this.state.selected.brush.toString()
    );
    const cnt = polygons.length;
    for (let i = 0; i < cnt; i++) {
      this.polygon(polygons[i], i === 0);
    }
  }
  polyline(points) {
    Helper.log("[gdi] polyline: points=" + points + " with pen " + this.state.selected.pen.toString());
    const pts = [];
    for (let i = 0; i < points.length; i++) {
      const point = points[i];
      pts.push([this._todevX(point.x), this._todevY(point.y)]);
    }
    Helper.log("[gdi] polyline: TRANSLATED: pts=" + pts);
    this._pushGroup();
    const opts = this._applyOpts({ fill: "none" }, true, false, false);
    this._svg.polyline(this.state._svggroup, pts, opts);
  }
  ellipse(rect) {
    Helper.log(
      "[gdi] ellipse: rect=" + rect.toString() + " with pen " + this.state.selected.pen.toString() + " and brush " + this.state.selected.brush.toString()
    );
    const bottom = this._todevY(rect.bottom);
    const right = this._todevX(rect.right);
    const top = this._todevY(rect.top);
    const left = this._todevX(rect.left);
    Helper.log("[gdi] ellipse: TRANSLATED: bottom=" + bottom + " right=" + right + " top=" + top + " left=" + left);
    this._pushGroup();
    const width2 = (right - left) / 2;
    const height2 = (bottom - top) / 2;
    const opts = this._applyOpts(null, true, true, false);
    this._svg.ellipse(this.state._svggroup, left + width2, top + height2, width2, height2, opts);
  }
  excludeClipRect(rect) {
    Helper.log("[gdi] excludeClipRect: rect=" + rect.toString());
    this._getClipRgn().subtract(rect);
  }
  intersectClipRect(rect) {
    Helper.log("[gdi] intersectClipRect: rect=" + rect.toString());
    this._getClipRgn().intersect(rect);
  }
  offsetClipRgn(offX, offY) {
    Helper.log("[gdi] offsetClipRgn: offX=" + offX + " offY=" + offY);
    this._getClipRgn().offset(offX, offY);
  }
  setTextAlign(textAlignmentMode) {
    Helper.log("[gdi] setTextAlign: textAlignmentMode=0x" + textAlignmentMode.toString(16));
    this.state.textalign = textAlignmentMode;
  }
  setBkMode(bkMode) {
    Helper.log("[gdi] setBkMode: bkMode=0x" + bkMode.toString(16));
    this.state.bkmode = bkMode;
  }
  setTextColor(textColor) {
    Helper.log("[gdi] setTextColor: textColor=" + textColor.toString());
    this.state.textcolor = textColor;
  }
  setBkColor(bkColor) {
    Helper.log("[gdi] setBkColor: bkColor=" + bkColor.toString());
    this.state.bkcolor = bkColor;
    this.state._svgtextbkfilter = null;
  }
  setPolyFillMode(polyFillMode) {
    Helper.log("[gdi] setPolyFillMode: polyFillMode=" + polyFillMode);
    this.state.polyfillmode = polyFillMode;
  }
  createBrush(brush) {
    const idx = this._storeObject(brush);
    Helper.log("[gdi] createBrush: brush=" + brush.toString() + " with handle " + idx);
  }
  createFont(font) {
    const idx = this._storeObject(font);
    Helper.log("[gdi] createFont: font=" + font.toString() + " with handle " + idx);
  }
  createPen(pen) {
    const idx = this._storeObject(pen);
    Helper.log("[gdi] createPen: pen=" + pen.toString() + " width handle " + idx);
  }
  createPalette(palette) {
    const idx = this._storeObject(palette);
    Helper.log("[gdi] createPalette: palette=" + palette.toString() + " width handle " + idx);
  }
  createRegion(region) {
    const idx = this._storeObject(region);
    Helper.log("[gdi] createRegion: region=" + region.toString() + " width handle " + idx);
  }
  createPatternBrush(patternBrush) {
    const idx = this._storeObject(patternBrush);
    Helper.log("[gdi] createRegion: region=" + patternBrush.toString() + " width handle " + idx);
  }
  selectObject(objIdx, checkType) {
    const obj = this._getObject(objIdx);
    if (obj != null && (checkType == null || obj.type === checkType)) {
      this._selectObject(obj);
      Helper.log(
        "[gdi] selectObject: objIdx=" + objIdx + (obj ? " selected " + obj.type + ": " + obj.toString() : "[invalid index]")
      );
    } else {
      Helper.log(
        "[gdi] selectObject: objIdx=" + objIdx + (obj ? " invalid object type: " + obj.type : "[invalid index]")
      );
    }
  }
  deleteObject(objIdx) {
    const ret = this._deleteObject(objIdx);
    Helper.log("[gdi] deleteObject: objIdx=" + objIdx + (ret ? " deleted object" : "[invalid index]"));
  }
  _pushGroup() {
    if (this.state._svggroup == null || this.state._svgclipChanged) {
      this.state._svgclipChanged = false;
      this.state._svgtextbkfilter = null;
      const settings = {
        viewBox: [this.state.vx, this.state.vy, this.state.vw, this.state.vh].join(" "),
        preserveAspectRatio: "none"
      };
      if (this.state.clip != null) {
        Helper.log(
          "[gdi] new svg x=" + this.state.vx + " y=" + this.state.vy + " width=" + this.state.vw + " height=" + this.state.vh + " with clipping"
        );
        settings["clip-path"] = "url(#" + this._getSvgClipPathForRegion(this.state.clip) + ")";
      } else {
        Helper.log(
          "[gdi] new svg x=" + this.state.vx + " y=" + this.state.vy + " width=" + this.state.vw + " height=" + this.state.vh + " without clipping"
        );
      }
      this.state._svggroup = this._svg.svg(
        this.state._svggroup,
        this.state.vx,
        this.state.vy,
        this.state.vw,
        this.state.vh,
        settings
      );
    }
  }
  _storeObject(obj) {
    let i = 0;
    while (this.objects[i.toString()] != null && i <= 65535) {
      i++;
    }
    if (i > 65535) {
      Helper.log("[gdi] Too many objects!");
      return -1;
    }
    this.objects[i.toString()] = obj;
    return i;
  }
  _getObject(objIdx) {
    const obj = this.objects[objIdx.toString()];
    if (obj == null) {
      Helper.log("[gdi] No object with handle " + objIdx);
    }
    return obj;
  }
  _getSvgDef() {
    if (this._svgdefs == null) {
      this._svgdefs = this._svg.defs();
    }
    return this._svgdefs;
  }
  _getSvgClipPathForRegion(region) {
    for (const existingId in this._svgClipPaths) {
      const rgn = this._svgClipPaths[existingId];
      if (rgn === region) {
        return existingId;
      }
    }
    const id = Helper._makeUniqueId("c");
    const sclip = this._svg.clipPath(this._getSvgDef(), id, "userSpaceOnUse");
    switch (region.complexity) {
      case 1:
        this._svg.rect(
          sclip,
          this._todevX(region.bounds.left),
          this._todevY(region.bounds.top),
          this._todevW(region.bounds.right - region.bounds.left),
          this._todevH(region.bounds.bottom - region.bounds.top),
          { fill: "black", "stroke-width": 0 }
        );
        break;
      case 2:
        for (let i = 0; i < region.scans.length; i++) {
          const scan = region.scans[i];
          for (let j2 = 0; j2 < scan.scanlines.length; j2++) {
            const scanline = scan.scanlines[j2];
            this._svg.rect(
              sclip,
              this._todevX(scanline.left),
              this._todevY(scan.top),
              this._todevW(scanline.right - scanline.left),
              this._todevH(scan.bottom - scan.top),
              { fill: "black", "stroke-width": 0 }
            );
          }
        }
        break;
    }
    this._svgClipPaths[id] = region;
    return id;
  }
  _getSvgPatternForBrush(brush) {
    for (const existingId in this._svgPatterns) {
      const pat = this._svgPatterns[existingId];
      if (pat === brush) {
        return existingId;
      }
    }
    let width;
    let height;
    let img;
    switch (brush.style) {
      case Helper.GDI.BrushStyle.BS_PATTERN:
        width = brush.pattern.getWidth();
        height = brush.pattern.getHeight();
        break;
      case Helper.GDI.BrushStyle.BS_DIBPATTERNPT:
        width = brush.dibpatternpt.getWidth();
        height = brush.dibpatternpt.getHeight();
        img = brush.dibpatternpt.base64ref();
        break;
      default:
        throw new WMFJSError("Invalid brush style");
    }
    const id = Helper._makeUniqueId("p");
    const spat = this._svg.pattern(this._getSvgDef(), id, 0, 0, width, height, { patternUnits: "userSpaceOnUse" });
    this._svg.image(spat, 0, 0, width, height, img);
    this._svgPatterns[id] = brush;
    return id;
  }
  _selectObject(obj) {
    this.state.selected[obj.type] = obj;
    if (obj.type === "region") {
      this.state._svgclipChanged = true;
    }
  }
  _deleteObject(objIdx) {
    const obj = this.objects[objIdx.toString()];
    if (obj != null) {
      for (let i = 0; i < this.statestack.length; i++) {
        const state2 = this.statestack[i];
        if (state2.selected[obj.type] === obj) {
          state2.selected[obj.type] = this.defObjects[obj.type].clone();
        }
      }
      delete this.objects[objIdx.toString()];
      return true;
    }
    Helper.log("[gdi] Cannot delete object with invalid handle " + objIdx);
    return false;
  }
  _getClipRgn() {
    if (this.state.clip != null) {
      if (!this.state.ownclip) {
        this.state.clip = this.state.clip.clone();
      }
    } else {
      if (this.state.selected.region != null) {
        this.state.clip = this.state.selected.region.clone();
      } else {
        this.state.clip = CreateSimpleRegion(
          this.state.wx,
          this.state.wy,
          this.state.wx + this.state.ww,
          this.state.wy + this.state.wh
        );
      }
    }
    this.state.ownclip = true;
    return this.state.clip;
  }
  _todevX(val) {
    return Math.floor((val - this.state.wx) * (this.state.vw / this.state.ww)) + this.state.vx;
  }
  _todevY(val) {
    return Math.floor((val - this.state.wy) * (this.state.vh / this.state.wh)) + this.state.vy;
  }
  _todevW(val) {
    return Math.floor(val * (this.state.vw / this.state.ww)) + this.state.vx;
  }
  _todevH(val) {
    return Math.floor(val * (this.state.vh / this.state.wh)) + this.state.vy;
  }
  _tologicalX(val) {
    return Math.floor((val - this.state.vx) / (this.state.vw / this.state.ww)) + this.state.wx;
  }
  _tologicalY(val) {
    return Math.floor((val - this.state.vy) / (this.state.vh / this.state.wh)) + this.state.wy;
  }
  _tologicalW(val) {
    return Math.floor(val / (this.state.vw / this.state.ww)) + this.state.wx;
  }
  _tologicalH(val) {
    return Math.floor(val / (this.state.vh / this.state.wh)) + this.state.wy;
  }
  _applyOpts(opts, usePen, useBrush, useFont) {
    if (opts == null) {
      opts = {};
    }
    if (usePen) {
      const pen = this.state.selected.pen;
      if (pen.style !== Helper.GDI.PenStyle.PS_NULL) {
        opts.stroke = "#" + pen.color.toHex();
        opts["stroke-width"] = this._todevW(pen.width.x);
        let dotWidth;
        if ((pen.linecap & Helper.GDI.PenStyle.PS_ENDCAP_SQUARE) !== 0) {
          opts["stroke-linecap"] = "square";
          dotWidth = 1;
        } else if ((pen.linecap & Helper.GDI.PenStyle.PS_ENDCAP_FLAT) !== 0) {
          opts["stroke-linecap"] = "butt";
          dotWidth = opts["stroke-width"];
        } else {
          opts["stroke-linecap"] = "round";
          dotWidth = 1;
        }
        if ((pen.join & Helper.GDI.PenStyle.PS_JOIN_BEVEL) !== 0) {
          opts["stroke-linejoin"] = "bevel";
        } else if ((pen.join & Helper.GDI.PenStyle.PS_JOIN_MITER) !== 0) {
          opts["stroke-linejoin"] = "miter";
        } else {
          opts["stroke-linejoin"] = "round";
        }
        const dashWidth = opts["stroke-width"] * 4;
        const dotSpacing = opts["stroke-width"] * 2;
        switch (pen.style) {
          case Helper.GDI.PenStyle.PS_DASH:
            opts["stroke-dasharray"] = [dashWidth, dotSpacing].toString();
            break;
          case Helper.GDI.PenStyle.PS_DOT:
            opts["stroke-dasharray"] = [dotWidth, dotSpacing].toString();
            break;
          case Helper.GDI.PenStyle.PS_DASHDOT:
            opts["stroke-dasharray"] = [dashWidth, dotSpacing, dotWidth, dotSpacing].toString();
            break;
          case Helper.GDI.PenStyle.PS_DASHDOTDOT:
            opts["stroke-dasharray"] = [dashWidth, dotSpacing, dotWidth, dotSpacing, dotWidth, dotSpacing].toString();
            break;
        }
      }
    }
    if (useBrush) {
      const brush = this.state.selected.brush;
      switch (brush.style) {
        case Helper.GDI.BrushStyle.BS_SOLID:
          opts.fill = "#" + brush.color.toHex();
          break;
        case Helper.GDI.BrushStyle.BS_PATTERN:
        case Helper.GDI.BrushStyle.BS_DIBPATTERNPT:
          opts.fill = "url(#" + this._getSvgPatternForBrush(brush) + ")";
          break;
        case Helper.GDI.BrushStyle.BS_NULL:
          opts.fill = "none";
          break;
        default:
          Helper.log("[gdi] unsupported brush style: " + brush.style);
          opts.fill = "none";
          break;
      }
    }
    if (useFont) {
      const font = this.state.selected.font;
      opts["font-family"] = font.facename;
      opts["font-size"] = this._todevH(Math.abs(font.height));
      opts.fill = "#" + this.state.textcolor.toHex();
    }
    return opts;
  }
}
class WMFRecords {
  constructor(reader, first) {
    this._records = [];
    let all = false;
    let curpos = first;
    main_loop: while (!all) {
      reader.seek(curpos);
      const size = reader.readUint32();
      if (size < 3) {
        throw new WMFJSError("Invalid record size");
      }
      const type2 = reader.readUint16();
      switch (type2) {
        case Helper.GDI.RecordType.META_EOF:
          all = true;
          break main_loop;
        case Helper.GDI.RecordType.META_SETMAPMODE: {
          const mapMode = reader.readUint16();
          this._records.push((gdi) => {
            gdi.setMapMode(mapMode);
          });
          break;
        }
        case Helper.GDI.RecordType.META_SETWINDOWORG: {
          const y2 = reader.readInt16();
          const x2 = reader.readInt16();
          this._records.push((gdi) => {
            gdi.setWindowOrg(x2, y2);
          });
          break;
        }
        case Helper.GDI.RecordType.META_SETWINDOWEXT: {
          const y2 = reader.readInt16();
          const x2 = reader.readInt16();
          this._records.push((gdi) => {
            gdi.setWindowExt(x2, y2);
          });
          break;
        }
        case Helper.GDI.RecordType.META_OFFSETWINDOWORG: {
          const offY = reader.readInt16();
          const offX = reader.readInt16();
          this._records.push((gdi) => {
            gdi.offsetWindowOrg(offX, offY);
          });
          break;
        }
        case Helper.GDI.RecordType.META_SETVIEWPORTORG: {
          const y2 = reader.readInt16();
          const x2 = reader.readInt16();
          this._records.push((gdi) => {
            gdi.setViewportOrg(x2, y2);
          });
          break;
        }
        case Helper.GDI.RecordType.META_SETVIEWPORTEXT: {
          const y2 = reader.readInt16();
          const x2 = reader.readInt16();
          this._records.push((gdi) => {
            gdi.setViewportExt(x2, y2);
          });
          break;
        }
        case Helper.GDI.RecordType.META_OFFSETVIEWPORTORG: {
          const offY = reader.readInt16();
          const offX = reader.readInt16();
          this._records.push((gdi) => {
            gdi.offsetViewportOrg(offX, offY);
          });
          break;
        }
        case Helper.GDI.RecordType.META_SAVEDC: {
          this._records.push((gdi) => {
            gdi.saveDC();
          });
          break;
        }
        case Helper.GDI.RecordType.META_RESTOREDC: {
          const saved = reader.readInt16();
          this._records.push((gdi) => {
            gdi.restoreDC(saved);
          });
          break;
        }
        case Helper.GDI.RecordType.META_SETSTRETCHBLTMODE: {
          const stretchMode = reader.readUint16();
          this._records.push((gdi) => {
            gdi.setStretchBltMode(stretchMode);
          });
          break;
        }
        case Helper.GDI.RecordType.META_DIBBITBLT: {
          const haveSrcDib = (type2 >> 8) + 3 !== size;
          const rasterOp = reader.readUint16() | reader.readUint16() << 16;
          const srcY = reader.readInt16();
          const srcX = reader.readInt16();
          if (!haveSrcDib) {
            reader.skip(2);
          }
          const height = reader.readInt16();
          const width = reader.readInt16();
          const destY = reader.readInt16();
          const destX = reader.readInt16();
          if (haveSrcDib) {
            const datalength = size * 2 - (reader.pos - curpos);
            const dib = new DIBitmap2(reader, datalength);
            this._records.push((gdi) => {
              gdi.dibBits(srcX, srcY, destX, destY, width, height, rasterOp, dib);
            });
          }
          break;
        }
        case Helper.GDI.RecordType.META_DIBSTRETCHBLT: {
          const rasterOp = reader.readUint16() | reader.readUint16() << 16;
          const srcH = reader.readInt16();
          const srcW = reader.readInt16();
          const srcY = reader.readInt16();
          const srcX = reader.readInt16();
          const destH = reader.readInt16();
          const destW = reader.readInt16();
          const destY = reader.readInt16();
          const destX = reader.readInt16();
          const datalength = size * 2 - (reader.pos - curpos);
          const dib = new DIBitmap2(reader, datalength);
          this._records.push((gdi) => {
            gdi.stretchDibBits(srcX, srcY, srcW, srcH, destX, destY, destW, destH, rasterOp, dib);
          });
          break;
        }
        case Helper.GDI.RecordType.META_STRETCHDIB: {
          const rasterOp = reader.readUint16() | reader.readUint16() << 16;
          const colorUsage = reader.readInt16();
          const srcH = reader.readInt16();
          const srcW = reader.readInt16();
          const srcY = reader.readInt16();
          const srcX = reader.readInt16();
          const destH = reader.readInt16();
          const destW = reader.readInt16();
          const destY = reader.readInt16();
          const destX = reader.readInt16();
          const datalength = size * 2 - (reader.pos - curpos);
          const dib = new DIBitmap2(reader, datalength);
          this._records.push((gdi) => {
            gdi.stretchDib(srcX, srcY, srcW, srcH, destX, destY, destW, destH, rasterOp, colorUsage, dib);
          });
          break;
        }
        case Helper.GDI.RecordType.META_ESCAPE: {
          const func = reader.readUint16();
          const count = reader.readUint16();
          const offset = reader.pos;
          const blob = new Blob$1(reader, offset);
          this._records.push((gdi) => {
            gdi.escape(func, blob, offset, count);
          });
          break;
        }
        case Helper.GDI.RecordType.META_SETTEXTALIGN: {
          const textAlign = reader.readUint16();
          this._records.push((gdi) => {
            gdi.setTextAlign(textAlign);
          });
          break;
        }
        case Helper.GDI.RecordType.META_SETBKMODE: {
          const bkMode = reader.readUint16();
          this._records.push((gdi) => {
            gdi.setBkMode(bkMode);
          });
          break;
        }
        case Helper.GDI.RecordType.META_SETTEXTCOLOR: {
          const textColor = new ColorRef2(reader);
          this._records.push((gdi) => {
            gdi.setTextColor(textColor);
          });
          break;
        }
        case Helper.GDI.RecordType.META_SETBKCOLOR: {
          const bkColor = new ColorRef2(reader);
          this._records.push((gdi) => {
            gdi.setBkColor(bkColor);
          });
          break;
        }
        case Helper.GDI.RecordType.META_CREATEBRUSHINDIRECT: {
          const datalength = size * 2 - (reader.pos - curpos);
          const brush = new Brush2(reader, datalength, false);
          this._records.push((gdi) => {
            gdi.createBrush(brush);
          });
          break;
        }
        case Helper.GDI.RecordType.META_DIBCREATEPATTERNBRUSH: {
          const datalength = size * 2 - (reader.pos - curpos);
          const brush = new Brush2(reader, datalength, true);
          this._records.push((gdi) => {
            gdi.createBrush(brush);
          });
          break;
        }
        case Helper.GDI.RecordType.META_CREATEPENINDIRECT: {
          const pen = new Pen2(reader);
          this._records.push((gdi) => {
            gdi.createPen(pen);
          });
          break;
        }
        case Helper.GDI.RecordType.META_CREATEFONTINDIRECT: {
          const datalength = size * 2 - (reader.pos - curpos);
          const font = new Font2(reader, datalength);
          this._records.push((gdi) => {
            gdi.createFont(font);
          });
          break;
        }
        case Helper.GDI.RecordType.META_SELECTOBJECT: {
          const idx = reader.readUint16();
          this._records.push((gdi) => {
            gdi.selectObject(idx, null);
          });
          break;
        }
        case Helper.GDI.RecordType.META_SELECTPALETTE: {
          const idx = reader.readUint16();
          this._records.push((gdi) => {
            gdi.selectObject(idx, "palette");
          });
          break;
        }
        case Helper.GDI.RecordType.META_SELECTCLIPREGION: {
          const idx = reader.readUint16();
          this._records.push((gdi) => {
            gdi.selectObject(idx, "region");
          });
          break;
        }
        case Helper.GDI.RecordType.META_DELETEOBJECT: {
          const idx = reader.readUint16();
          this._records.push((gdi) => {
            gdi.deleteObject(idx);
          });
          break;
        }
        case Helper.GDI.RecordType.META_RECTANGLE: {
          const rect = new Rect(reader);
          this._records.push((gdi) => {
            gdi.rectangle(rect, 0, 0);
          });
          break;
        }
        case Helper.GDI.RecordType.META_ROUNDRECT: {
          const rh = reader.readInt16();
          const rw = reader.readInt16();
          const rect = new Rect(reader);
          this._records.push((gdi) => {
            gdi.rectangle(rect, rw, rh);
          });
          break;
        }
        case Helper.GDI.RecordType.META_LINETO: {
          const y2 = reader.readInt16();
          const x2 = reader.readInt16();
          this._records.push((gdi) => {
            gdi.lineTo(x2, y2);
          });
          break;
        }
        case Helper.GDI.RecordType.META_MOVETO: {
          const y2 = reader.readInt16();
          const x2 = reader.readInt16();
          this._records.push((gdi) => {
            gdi.moveTo(x2, y2);
          });
          break;
        }
        case Helper.GDI.RecordType.META_TEXTOUT: {
          const len = reader.readInt16();
          if (len > 0) {
            const text = reader.readString(len);
            reader.skip(len % 2);
            const y2 = reader.readInt16();
            const x2 = reader.readInt16();
            this._records.push((gdi) => {
              gdi.textOut(x2, y2, text);
            });
          }
          break;
        }
        case Helper.GDI.RecordType.META_EXTTEXTOUT: {
          const y2 = reader.readInt16();
          const x2 = reader.readInt16();
          const len = reader.readInt16();
          const fwOpts = reader.readUint16();
          let hasRect = null;
          let hasDx = null;
          if (size * 2 === 14 + len + len % 2) {
            hasRect = false;
            hasDx = false;
          }
          if (size * 2 === 14 + 8 + len + len % 2) {
            hasRect = true;
            hasDx = false;
          }
          if (size * 2 === 14 + len + len % 2 + len * 2) {
            hasRect = false;
            hasDx = true;
          }
          if (size * 2 === 14 + 8 + len + len % 2 + len * 2) {
            hasRect = true;
            hasDx = true;
          }
          const rect = hasRect ? new Rect(reader) : null;
          if (len > 0) {
            const text = reader.readString(len);
            reader.skip(len % 2);
            const dx = [];
            if (hasDx) {
              for (let i = 0; i < text.length; i++) {
                dx.push(reader.readInt16());
              }
            }
            this._records.push((gdi) => {
              gdi.extTextOut(x2, y2, text, fwOpts, rect, dx);
            });
          }
          break;
        }
        case Helper.GDI.RecordType.META_EXCLUDECLIPRECT: {
          const rect = new Rect(reader);
          this._records.push((gdi) => {
            gdi.excludeClipRect(rect);
          });
          break;
        }
        case Helper.GDI.RecordType.META_INTERSECTCLIPRECT: {
          const rect = new Rect(reader);
          this._records.push((gdi) => {
            gdi.intersectClipRect(rect);
          });
          break;
        }
        case Helper.GDI.RecordType.META_POLYGON: {
          let cnt = reader.readInt16();
          const points = [];
          while (cnt > 0) {
            points.push(new PointS2(reader));
            cnt--;
          }
          this._records.push((gdi) => {
            gdi.polygon(points, true);
          });
          break;
        }
        case Helper.GDI.RecordType.META_SETPOLYFILLMODE: {
          const polyfillmode = reader.readUint16();
          this._records.push((gdi) => {
            gdi.setPolyFillMode(polyfillmode);
          });
          break;
        }
        case Helper.GDI.RecordType.META_POLYPOLYGON: {
          const cnt = reader.readUint16();
          const polygonsPtCnts = [];
          for (let i = 0; i < cnt; i++) {
            polygonsPtCnts.push(reader.readUint16());
          }
          const polygons = [];
          for (let i = 0; i < cnt; i++) {
            const ptCnt = polygonsPtCnts[i];
            const p = [];
            for (let ip = 0; ip < ptCnt; ip++) {
              p.push(new PointS2(reader));
            }
            polygons.push(p);
          }
          this._records.push((gdi) => {
            gdi.polyPolygon(polygons);
          });
          break;
        }
        case Helper.GDI.RecordType.META_POLYLINE: {
          let cnt = reader.readInt16();
          const points = [];
          while (cnt > 0) {
            points.push(new PointS2(reader));
            cnt--;
          }
          this._records.push((gdi) => {
            gdi.polyline(points);
          });
          break;
        }
        case Helper.GDI.RecordType.META_ELLIPSE: {
          const rect = new Rect(reader);
          this._records.push((gdi) => {
            gdi.ellipse(rect);
          });
          break;
        }
        case Helper.GDI.RecordType.META_CREATEPALETTE: {
          const palette = new Palette(reader);
          this._records.push((gdi) => {
            gdi.createPalette(palette);
          });
          break;
        }
        case Helper.GDI.RecordType.META_CREATEREGION: {
          const region = new Region2(reader);
          this._records.push((gdi) => {
            gdi.createRegion(region);
          });
          break;
        }
        case Helper.GDI.RecordType.META_CREATEPATTERNBRUSH: {
          const datalength = size * 2 - (reader.pos - curpos);
          const patternBitmap = new PatternBitmap16(reader, datalength);
          const brush = new Brush2(reader, datalength, patternBitmap);
          this._records.push((gdi) => {
            gdi.createPatternBrush(brush);
          });
          break;
        }
        case Helper.GDI.RecordType.META_OFFSETCLIPRGN: {
          const offY = reader.readInt16();
          const offX = reader.readInt16();
          this._records.push((gdi) => {
            gdi.offsetClipRgn(offX, offY);
          });
          break;
        }
        case Helper.GDI.RecordType.META_REALIZEPALETTE:
        case Helper.GDI.RecordType.META_SETPALENTRIES:
        case Helper.GDI.RecordType.META_SETROP2:
        case Helper.GDI.RecordType.META_SETRELABS:
        case Helper.GDI.RecordType.META_SETTEXTCHAREXTRA:
        case Helper.GDI.RecordType.META_RESIZEPALETTE:
        case Helper.GDI.RecordType.META_SETLAYOUT:
        case Helper.GDI.RecordType.META_FILLREGION:
        case Helper.GDI.RecordType.META_SETMAPPERFLAGS:
        case Helper.GDI.RecordType.META_SETTEXTJUSTIFICATION:
        case Helper.GDI.RecordType.META_SCALEWINDOWEXT:
        case Helper.GDI.RecordType.META_SCALEVIEWPORTEXT:
        case Helper.GDI.RecordType.META_FLOODFILL:
        case Helper.GDI.RecordType.META_FRAMEREGION:
        case Helper.GDI.RecordType.META_ANIMATEPALETTE:
        case Helper.GDI.RecordType.META_EXTFLOODFILL:
        case Helper.GDI.RecordType.META_SETPIXEL:
        case Helper.GDI.RecordType.META_PATBLT:
        case Helper.GDI.RecordType.META_PIE:
        case Helper.GDI.RecordType.META_STRETCHBLT:
        case Helper.GDI.RecordType.META_INVERTREGION:
        case Helper.GDI.RecordType.META_PAINTREGION:
        case Helper.GDI.RecordType.META_ARC:
        case Helper.GDI.RecordType.META_CHORD:
        case Helper.GDI.RecordType.META_BITBLT:
        case Helper.GDI.RecordType.META_SETDIBTODEV:
        default: {
          let recordName = "UNKNOWN";
          for (const name in Helper.GDI.RecordType) {
            const recordTypes = Helper.GDI.RecordType;
            if (recordTypes[name] === type2) {
              recordName = name;
              break;
            }
          }
          Helper.log(
            "[WMF] " + recordName + " record (0x" + type2.toString(16) + ") at offset 0x" + curpos.toString(16) + " with " + size * 2 + " bytes"
          );
          break;
        }
      }
      curpos += size * 2;
    }
    if (!all) {
      throw new WMFJSError("Could not read all records");
    }
  }
  play(gdi) {
    const len = this._records.length;
    for (let i = 0; i < len; i++) {
      this._records[i](gdi);
    }
  }
}
class Renderer2 {
  constructor(blob) {
    this.parse(blob);
    Helper.log("WMFJS.Renderer instantiated");
  }
  render(info) {
    const svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    this._render(new SVG(svgElement), info.mapMode, info.xExt, info.yExt);
    svgElement.setAttribute("viewBox", [0, 0, info.xExt, info.yExt].join(" "));
    svgElement.setAttribute("preserveAspectRatio", "none");
    svgElement.setAttribute("width", info.width);
    svgElement.setAttribute("height", info.height);
    return svgElement;
  }
  parse(blob) {
    this._img = null;
    const reader = new Blob$1(blob);
    let type2;
    let size;
    let placable;
    let headerstart;
    const key = reader.readUint32();
    if (key === 2596720087) {
      placable = new WMFPlacable(reader);
      headerstart = reader.pos;
      type2 = reader.readUint16();
      size = reader.readUint16();
    } else {
      headerstart = 0;
      type2 = key & 65535;
      size = key >>> 16 & 65535;
    }
    switch (type2) {
      case Helper.GDI.MetafileType.MEMORYMETAFILE:
      case Helper.GDI.MetafileType.DISKMETAFILE:
        if (size === Helper.GDI.METAHEADER_SIZE / 2) {
          const version = reader.readUint16();
          switch (version) {
            case Helper.GDI.MetafileVersion.METAVERSION100:
            case Helper.GDI.MetafileVersion.METAVERSION300:
              this._img = new WMF(reader, placable, version, headerstart + size * 2);
              break;
          }
        }
        break;
    }
    if (this._img == null) {
      throw new WMFJSError("Format not recognized");
    }
  }
  _render(svg, mapMode, xExt, yExt) {
    const gdi = new GDIContext2(svg);
    gdi.setViewportExt(xExt, yExt);
    gdi.setMapMode(mapMode);
    Helper.log("[WMF] BEGIN RENDERING --->");
    this._img.render(gdi);
    Helper.log("[WMF] <--- DONE RENDERING");
  }
}
class WMFRect16 {
  constructor(reader) {
    this.left = reader.readInt16();
    this.top = reader.readInt16();
    this.right = reader.readInt16();
    this.bottom = reader.readInt16();
  }
  toString() {
    return "{left: " + this.left + ", top: " + this.top + ", right: " + this.right + ", bottom: " + this.bottom + "}";
  }
}
class WMFPlacable {
  constructor(reader) {
    reader.skip(2);
    this.boundingBox = new WMFRect16(reader);
    this.unitsPerInch = reader.readInt16();
    reader.skip(4);
    reader.skip(2);
    Helper.log("Got bounding box " + this.boundingBox + " and " + this.unitsPerInch + " units/inch");
  }
}
class WMF {
  constructor(reader, placable, version, hdrsize) {
    this._version = version;
    this._hdrsize = hdrsize;
    this._placable = placable;
    this._records = new WMFRecords(reader, this._hdrsize);
  }
  render(gdi) {
    this._records.play(gdi);
  }
}
loggingEnabled$1(false);
loggingEnabled(false);
let domEnvironment = null;
const setMetafileDomEnvironment = (env) => {
  domEnvironment = env || null;
};
function ensureDomEnvironment() {
  const hasDom = typeof document !== "undefined" && typeof XMLSerializer !== "undefined";
  if (hasDom) return true;
  const env = domEnvironment || {};
  const win = env.window || env.mockWindow || null;
  const doc2 = env.document || env.mockDocument || win?.document || null;
  if (win && doc2) {
    if (typeof globalThis.window === "undefined") globalThis.window = win;
    if (typeof globalThis.document === "undefined") globalThis.document = doc2;
    if (win.XMLSerializer && typeof globalThis.XMLSerializer === "undefined") {
      globalThis.XMLSerializer = win.XMLSerializer;
    }
    if (win.Node && typeof globalThis.Node === "undefined") {
      globalThis.Node = win.Node;
    }
    if (typeof globalThis.atob === "undefined" && typeof win.atob === "function") {
      globalThis.atob = win.atob.bind(win);
    }
    if (typeof globalThis.btoa === "undefined" && typeof win.btoa === "function") {
      globalThis.btoa = win.btoa.bind(win);
    }
  }
  return typeof document !== "undefined" && typeof XMLSerializer !== "undefined";
}
const MM_ANISOTROPIC = 8;
const EMF_SIGNATURE = 1179469088;
const EMF_PLUS_SIGNATURE = 726027589;
function base64ToArrayBuffer(data) {
  if (data instanceof ArrayBuffer) return data;
  if (ArrayBuffer.isView(data)) return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
  if (typeof data !== "string") {
    throw new Error("Unsupported data type for conversion to ArrayBuffer");
  }
  let base64 = data;
  if (data.startsWith("data:")) {
    const commaIndex = data.indexOf(",");
    if (commaIndex === -1) {
      throw new Error("Invalid data URI: missing base64 content");
    }
    base64 = data.substring(commaIndex + 1);
  }
  const binaryString = atob(base64);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes.buffer;
}
function uint8ToBase64(bytes) {
  const chunkSize = 32768;
  let binary = "";
  for (let i = 0; i < bytes.length; i += chunkSize) {
    const chunk = bytes.subarray(i, i + chunkSize);
    binary += String.fromCharCode.apply(null, chunk);
  }
  return btoa(binary);
}
function extractBitmapFromEmf(buffer2) {
  const view = new DataView(buffer2);
  if (view.byteLength < 120) return null;
  const type2 = view.getUint32(0, true);
  const headerSize = view.getUint32(4, true);
  if (type2 !== 1 || headerSize <= 0 || headerSize + 80 > view.byteLength) return null;
  const recordOffset = headerSize;
  const recordType = view.getUint32(recordOffset, true);
  if (recordType !== 81) return null;
  const recordSize = view.getUint32(recordOffset + 4, true);
  if (recordOffset + recordSize > view.byteLength) return null;
  const offBmi = view.getUint32(recordOffset + 48, true);
  const cbBmi = view.getUint32(recordOffset + 52, true);
  const offBits = view.getUint32(recordOffset + 56, true);
  const cbBits = view.getUint32(recordOffset + 60, true);
  if (!cbBmi || !cbBits) return null;
  const bmiStart = recordOffset + offBmi;
  const bitsStart = recordOffset + offBits;
  if (bitsStart + cbBits > view.byteLength || bmiStart + cbBmi > view.byteLength) return null;
  const bmpSize = 14 + cbBmi + cbBits;
  const bmpBytes = new Uint8Array(bmpSize);
  const bmpView = new DataView(bmpBytes.buffer);
  bmpView.setUint8(0, 66);
  bmpView.setUint8(1, 77);
  bmpView.setUint32(2, bmpSize, true);
  bmpView.setUint32(10, 14 + cbBmi, true);
  bmpBytes.set(new Uint8Array(buffer2, bmiStart, cbBmi), 14);
  bmpBytes.set(new Uint8Array(buffer2, bitsStart, cbBits), 14 + cbBmi);
  return { dataUri: `data:image/bmp;base64,${uint8ToBase64(bmpBytes)}`, format: "bmp" };
}
function svgToDataUri(svgElement) {
  const serializer = new XMLSerializer();
  const svgString = serializer.serializeToString(svgElement);
  const base64 = btoa(unescape(encodeURIComponent(svgString)));
  return `data:image/svg+xml;base64,${base64}`;
}
function getEmfDimensions(buffer2) {
  const view = new DataView(buffer2);
  const frameLeft = view.getInt32(24, true);
  const frameTop = view.getInt32(28, true);
  const frameRight = view.getInt32(32, true);
  const frameBottom = view.getInt32(36, true);
  const frameWidth = frameRight - frameLeft;
  const frameHeight = frameBottom - frameTop;
  const DPI = 96;
  const width = Math.round(frameWidth * DPI / 2540);
  const height = Math.round(frameHeight * DPI / 2540);
  const deviceWidth = view.getInt32(72, true);
  const deviceHeight = view.getInt32(76, true);
  return {
    width: width || 800,
    height: height || 600,
    xExt: frameWidth || deviceWidth || 800,
    yExt: frameHeight || deviceHeight || 600,
    wExt: frameWidth || deviceWidth || 800,
    hExt: frameHeight || deviceHeight || 600
  };
}
function isEmfPlus(buffer2) {
  const view = new DataView(buffer2);
  if (view.byteLength < 108) return false;
  const type2 = view.getUint32(0, true);
  const headerSize = view.getUint32(4, true);
  const signature = view.getUint32(40, true);
  if (type2 !== 1 || signature !== EMF_SIGNATURE || headerSize <= 0 || headerSize >= view.byteLength) return false;
  let offset = headerSize;
  for (let i = 0; i < 10; i++) {
    if (offset + 8 > view.byteLength) break;
    const recordType = view.getUint32(offset, true);
    const recordSize = view.getUint32(offset + 4, true);
    if (recordSize < 8 || offset + recordSize > view.byteLength) break;
    if (recordType === 70 && recordSize >= 20) {
      const identifier = view.getUint32(offset + 12, true);
      if (identifier === EMF_PLUS_SIGNATURE) return true;
    }
    offset += recordSize;
  }
  return false;
}
function isEmfHeader(buffer2) {
  if (buffer2.byteLength < 48) return false;
  const view = new DataView(buffer2);
  const type2 = view.getUint32(0, true);
  const signature = view.getUint32(40, true);
  return type2 === 1 && signature === EMF_SIGNATURE;
}
function createPlaceholder(params) {
  const width = Math.max(1, Math.round(params.width));
  const height = Math.max(1, Math.round(params.height));
  const label = params.label || "Unable to render image";
  const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" role="img" aria-label="${label}"><rect width="100%" height="100%" fill="#ffffff" stroke="#d9d9d9" stroke-width="1"/><text x="50%" y="50%" fill="#595959" font-family="sans-serif" font-size="${Math.max(
    8,
    Math.min(12, Math.floor(width / 30))
  )}" text-anchor="middle" dominant-baseline="middle">${label}</text></svg>`;
  const base64 = btoa(unescape(encodeURIComponent(svg)));
  return { dataUri: `data:image/svg+xml;base64,${base64}`, format: "svg" };
}
function getWmfDimensions(buffer2) {
  const view = new DataView(buffer2);
  const magic = view.getUint32(0, true);
  if (magic === 2596720087) {
    const left = view.getInt16(6, true);
    const top = view.getInt16(8, true);
    const right = view.getInt16(10, true);
    const bottom = view.getInt16(12, true);
    const unitsPerInch = view.getInt16(14, true) || 1440;
    const width = right - left;
    const height = bottom - top;
    const pixelWidth = Math.round(width * 96 / unitsPerInch);
    const pixelHeight = Math.round(height * 96 / unitsPerInch);
    return {
      width: pixelWidth || 400,
      height: pixelHeight || 400,
      xExt: width || 400,
      yExt: height || 400
    };
  }
  return {
    width: 400,
    height: 400,
    xExt: 400,
    yExt: 400
  };
}
function convertEmfToSvg(data, size = {}) {
  try {
    if (!ensureDomEnvironment()) {
      console.warn("EMF conversion requires browser environment with DOM support");
      return null;
    }
    const buffer2 = base64ToArrayBuffer(data);
    const bitmapResult = extractBitmapFromEmf(buffer2);
    if (bitmapResult) {
      return bitmapResult;
    }
    const dimensions = getEmfDimensions(buffer2);
    if (isEmfPlus(buffer2)) {
      return createPlaceholder({
        width: size.width || dimensions.width,
        height: size.height || dimensions.height,
        label: "Unable to render EMF+ image"
      });
    }
    const renderer = new Renderer$1(buffer2);
    const renderSettings = {
      width: String(size.width || dimensions.width) + "px",
      height: String(size.height || dimensions.height) + "px",
      wExt: dimensions.wExt,
      hExt: dimensions.hExt,
      xExt: dimensions.xExt,
      yExt: dimensions.yExt,
      mapMode: MM_ANISOTROPIC
    };
    const svgElement = renderer.render(renderSettings);
    if (!svgElement?.childNodes?.length) {
      return null;
    }
    return { dataUri: svgToDataUri(svgElement), format: "svg" };
  } catch (error) {
    console.warn("Failed to convert EMF to SVG:", error.message);
    return null;
  }
}
function convertWmfToSvg(data, size = {}) {
  try {
    if (!ensureDomEnvironment()) {
      console.warn("WMF conversion requires browser environment with DOM support");
      return null;
    }
    const buffer2 = base64ToArrayBuffer(data);
    if (isEmfHeader(buffer2)) {
      return convertEmfToSvg(data, size);
    }
    const dimensions = getWmfDimensions(buffer2);
    const renderer = new Renderer2(buffer2);
    const renderSettings = {
      width: String(size.width || dimensions.width) + "px",
      height: String(size.height || dimensions.height) + "px",
      xExt: dimensions.xExt,
      yExt: dimensions.yExt,
      mapMode: MM_ANISOTROPIC
    };
    const svgElement = renderer.render(renderSettings);
    if (!svgElement || !svgElement.childNodes?.length) return null;
    return { dataUri: svgToDataUri(svgElement), format: "svg" };
  } catch (error) {
    console.warn("Failed to convert WMF to SVG:", error.message);
    return null;
  }
}
function convertMetafileToSvg(dataUri, extension, size = {}) {
  const ext = extension?.toLowerCase();
  if (ext === "emf") {
    return convertEmfToSvg(dataUri, size);
  }
  if (ext === "wmf") {
    return convertWmfToSvg(dataUri, size);
  }
  console.warn(`Unsupported metafile extension: ${extension}`);
  return null;
}
function isMetafileExtension(extension) {
  const ext = extension?.toLowerCase();
  return ext === "emf" || ext === "wmf";
}
function preProcessPageInstruction(nodesToCombine, _instrText, fieldRunRPr = null) {
  const pageNumNode = {
    name: "sd:autoPageNumber",
    type: "element"
  };
  let foundContentRPr = false;
  nodesToCombine.forEach((n) => {
    const rPrNode = n.elements?.find((el) => el.name === "w:rPr");
    if (rPrNode) {
      pageNumNode.elements = [rPrNode];
      foundContentRPr = true;
    }
  });
  if (!foundContentRPr && fieldRunRPr && fieldRunRPr.name === "w:rPr") {
    pageNumNode.elements = [fieldRunRPr];
  }
  return [pageNumNode];
}
function preProcessNumPagesInstruction(nodesToCombine, _instrText, fieldRunRPr = null) {
  const totalPageNumNode = {
    name: "sd:totalPageNumber",
    type: "element"
  };
  let foundContentRPr = false;
  nodesToCombine.forEach((n) => {
    const rPrNode = n.elements?.find((el) => el.name === "w:rPr");
    if (rPrNode) {
      totalPageNumNode.elements = [rPrNode];
      foundContentRPr = true;
    }
  });
  if (!foundContentRPr && fieldRunRPr && fieldRunRPr.name === "w:rPr") {
    totalPageNumNode.elements = [fieldRunRPr];
  }
  return [totalPageNumNode];
}
function preProcessPageRefInstruction(nodesToCombine, instrText) {
  const pageRefNode = {
    name: "sd:pageReference",
    type: "element",
    attributes: {
      instruction: instrText
    },
    elements: nodesToCombine
  };
  return [pageRefNode];
}
function preProcessHyperlinkInstruction(nodesToCombine, instruction, docx) {
  const urlMatch = instruction.match(/HYPERLINK\s+"([^"]+)"/);
  let linkAttributes;
  if (urlMatch && urlMatch.length >= 2) {
    const url = urlMatch[1];
    const rels = docx["word/_rels/document.xml.rels"];
    const relationships = rels?.elements.find((el) => el.name === "Relationships");
    if (relationships) {
      const rId = generateDocxRandomId();
      relationships.elements.push({
        type: "element",
        name: "Relationship",
        attributes: {
          Id: rId,
          Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
          Target: url,
          TargetMode: "External"
        }
      });
      linkAttributes = { "r:id": rId };
    } else {
      linkAttributes = { "w:anchor": url };
    }
  } else {
    const availableSwitches = {
      "w:anchor": /(?:\\)?l "(?<value>[^"]+)"/,
      new_window: /(?:\\n|\n)/,
      "w:tgtFrame": /(?:\\t|\t) "(?<value>[^"]+)"/,
      "w:tooltip": /(?:\\)?o "(?<value>[^"]+)"/
    };
    const parsedSwitches = {};
    for (const [key, pattern] of Object.entries(availableSwitches)) {
      const match = instruction.match(pattern);
      if (match) {
        parsedSwitches[key] = match.groups?.value || true;
      }
    }
    if (parsedSwitches.new_window) {
      parsedSwitches["w:tgtFrame"] = "_blank";
      delete parsedSwitches.new_window;
    }
    linkAttributes = { ...parsedSwitches };
  }
  return [
    {
      name: "w:hyperlink",
      type: "element",
      attributes: linkAttributes,
      elements: nodesToCombine
    }
  ];
}
function preProcessTocInstruction(nodesToCombine, instrText) {
  return [
    {
      name: "sd:tableOfContents",
      type: "element",
      attributes: {
        instruction: instrText
      },
      elements: nodesToCombine
    }
  ];
}
function preProcessIndexInstruction(nodesToCombine, instrText, _docx, instructionTokens = null) {
  return [
    {
      name: "sd:index",
      type: "element",
      attributes: {
        instruction: instrText,
        ...instructionTokens ? { instructionTokens } : {}
      },
      elements: nodesToCombine
    }
  ];
}
function preProcessXeInstruction(nodesToCombine, instrText, _docx, instructionTokens = null) {
  return [
    {
      name: "sd:indexEntry",
      type: "element",
      attributes: {
        instruction: instrText,
        ...instructionTokens ? { instructionTokens } : {}
      },
      elements: nodesToCombine
    }
  ];
}
const getInstructionPreProcessor = (instruction) => {
  const instructionType = instruction.split(" ")[0];
  switch (instructionType) {
    case "PAGE":
      return preProcessPageInstruction;
    case "NUMPAGES":
      return preProcessNumPagesInstruction;
    case "PAGEREF":
      return preProcessPageRefInstruction;
    case "HYPERLINK":
      return preProcessHyperlinkInstruction;
    case "TOC":
      return preProcessTocInstruction;
    case "INDEX":
      return preProcessIndexInstruction;
    case "XE":
      return preProcessXeInstruction;
    default:
      return null;
  }
};
const SKIP_FIELD_PROCESSING_NODE_NAMES$1 = /* @__PURE__ */ new Set(["w:drawing", "w:pict"]);
const shouldSkipFieldProcessing$1 = (node) => SKIP_FIELD_PROCESSING_NODE_NAMES$1.has(node?.name);
const preProcessNodesForFldChar = (nodes = [], docx) => {
  const processedNodes = [];
  let collectedNodesStack = [];
  let rawCollectedNodesStack = [];
  let currentFieldStack = [];
  let unpairedEnd = null;
  let collecting = false;
  const finalizeField = () => {
    if (collecting) {
      const collectedNodes = collectedNodesStack.pop().filter((n) => n !== null);
      const rawCollectedNodes = rawCollectedNodesStack.pop().filter((n) => n !== null);
      const currentField = currentFieldStack.pop();
      const combinedResult = _processCombinedNodesForFldChar(
        collectedNodes,
        currentField.instrText.trim(),
        docx,
        currentField.instructionTokens
      );
      const outputNodes = combinedResult.handled ? combinedResult.nodes : rawCollectedNodes;
      if (collectedNodesStack.length === 0) {
        processedNodes.push(...outputNodes);
      } else {
        collectedNodesStack[collectedNodesStack.length - 1].push(...outputNodes);
        rawCollectedNodesStack[rawCollectedNodesStack.length - 1].push(...outputNodes);
      }
    } else {
      unpairedEnd = true;
    }
  };
  for (const node of nodes) {
    const rawNode = carbonCopy(node);
    collecting = collectedNodesStack.length > 0;
    if (shouldSkipFieldProcessing$1(node)) {
      if (collecting) {
        collectedNodesStack[collectedNodesStack.length - 1].push(node);
        rawCollectedNodesStack[collectedNodesStack.length - 1].push(rawNode);
      } else {
        processedNodes.push(node);
      }
      continue;
    }
    const fldCharEl = node.elements?.find((el) => el.name === "w:fldChar");
    const fldType = fldCharEl?.attributes?.["w:fldCharType"];
    const instrTextEl = node.elements?.find((el) => el.name === "w:instrText");
    if (node.name === "w:fldSimple") {
      const instr = node.attributes?.["w:instr"];
      if (typeof instr === "string") {
        const instructionType = instr.trim().split(" ")[0];
        const instructionPreProcessor = getInstructionPreProcessor(instructionType);
        if (instructionPreProcessor) {
          const processed = instructionPreProcessor(node.elements ?? [], instr, docx, null);
          if (collecting) {
            collectedNodesStack[collectedNodesStack.length - 1].push(...processed);
            rawCollectedNodesStack[rawCollectedNodesStack.length - 1].push(...processed);
          } else {
            processedNodes.push(...processed);
          }
          continue;
        }
      }
    }
    if (fldType === "begin") {
      collectedNodesStack.push([]);
      rawCollectedNodesStack.push([rawNode]);
      currentFieldStack.push({ instrText: "", instructionTokens: [], afterSeparate: false });
      continue;
    }
    if (collecting && currentFieldStack.length > 0) {
      const currentField = currentFieldStack[currentFieldStack.length - 1];
      if (!currentField.afterSeparate) {
        const instructionTokens = extractInstructionTokensFromNode(node);
        if (instructionTokens.length > 0) {
          rawCollectedNodesStack[rawCollectedNodesStack.length - 1].push(rawNode);
          currentField.instructionTokens.push(...instructionTokens);
          const instrTextValue = instrTextEl?.elements?.[0]?.text;
          if (instrTextValue != null) {
            currentField.instrText += `${instrTextValue} `;
          }
          if (instructionTokens.some((token) => token.type === "tab")) {
            currentField.instrText += "	";
          }
          continue;
        }
      }
    }
    if (fldType === "end") {
      if (collecting) {
        rawCollectedNodesStack[rawCollectedNodesStack.length - 1].push(rawNode);
      }
      finalizeField();
      continue;
    } else if (fldType === "separate") {
      if (collecting) {
        rawCollectedNodesStack[rawCollectedNodesStack.length - 1].push(rawNode);
        const currentField = currentFieldStack[currentFieldStack.length - 1];
        if (currentField) {
          currentField.afterSeparate = true;
        }
      }
      continue;
    }
    if (Array.isArray(node.elements)) {
      const childResult = preProcessNodesForFldChar(node.elements, docx);
      node.elements = childResult.processedNodes;
      if (childResult.unpairedBegin) {
        childResult.unpairedBegin.forEach((pendingField) => {
          currentFieldStack.push(pendingField.fieldInfo);
          collectedNodesStack.push([node]);
          rawCollectedNodesStack.push([rawNode]);
        });
      } else if (childResult.unpairedEnd) {
        collectedNodesStack[collectedNodesStack.length - 1].push(node);
        rawCollectedNodesStack[rawCollectedNodesStack.length - 1].push(rawNode);
        finalizeField();
      } else if (collecting) {
        collectedNodesStack[collectedNodesStack.length - 1].push(node);
        rawCollectedNodesStack[rawCollectedNodesStack.length - 1].push(rawNode);
      } else {
        processedNodes.push(node);
      }
    } else if (collecting) {
      collectedNodesStack[collectedNodesStack.length - 1].push(node);
      rawCollectedNodesStack[rawCollectedNodesStack.length - 1].push(rawNode);
    } else {
      processedNodes.push(node);
    }
  }
  let unpairedBegin = null;
  if (collectedNodesStack.length > 0) {
    unpairedBegin = [];
    for (let i = 0; i < collectedNodesStack.length; i++) {
      processedNodes.push(...collectedNodesStack[i].filter((n) => n !== null));
      unpairedBegin.push({
        nodes: collectedNodesStack[i],
        fieldInfo: currentFieldStack[i]
      });
    }
  }
  return { processedNodes, unpairedBegin, unpairedEnd };
};
const _processCombinedNodesForFldChar = (nodesToCombine = [], instrText, docx, instructionTokens) => {
  const instructionType = instrText.trim().split(" ")[0];
  const instructionPreProcessor = getInstructionPreProcessor(instructionType);
  if (instructionPreProcessor) {
    return { nodes: instructionPreProcessor(nodesToCombine, instrText, docx, instructionTokens), handled: true };
  }
  return { nodes: nodesToCombine, handled: false };
};
const extractInstructionTokensFromNode = (node) => {
  const elements = Array.isArray(node?.elements) ? node.elements : [];
  const tokens = [];
  elements.forEach((el) => {
    if (el?.name === "w:instrText") {
      const text = (el.elements || []).map((child) => typeof child?.text === "string" ? child.text : "").join("");
      tokens.push({ type: "text", text });
    }
    if (el?.name === "w:tab") {
      tokens.push({ type: "tab" });
    }
  });
  return tokens;
};
const SKIP_FIELD_PROCESSING_NODE_NAMES = /* @__PURE__ */ new Set(["w:drawing", "w:pict"]);
const shouldSkipFieldProcessing = (node) => SKIP_FIELD_PROCESSING_NODE_NAMES.has(node?.name);
const preProcessPageFieldsOnly = (nodes = [], depth = 0) => {
  const processedNodes = [];
  let i = 0;
  while (i < nodes.length) {
    const node = nodes[i];
    if (shouldSkipFieldProcessing(node)) {
      processedNodes.push(node);
      i++;
      continue;
    }
    const fldCharEl = node.elements?.find((el) => el.name === "w:fldChar");
    const fldType = fldCharEl?.attributes?.["w:fldCharType"];
    if (node.name === "w:fldSimple") {
      const instrAttr = node.attributes?.["w:instr"] || "";
      const fieldType = instrAttr.trim().split(/\s+/)[0];
      if (fieldType === "PAGE" || fieldType === "NUMPAGES") {
        const preprocessor = fieldType === "PAGE" ? preProcessPageInstruction : preProcessNumPagesInstruction;
        const contentNodes = node.elements || [];
        let fieldRunRPr = null;
        for (const child of contentNodes) {
          const rPr = child.elements?.find((el) => el.name === "w:rPr");
          if (rPr) {
            fieldRunRPr = rPr;
            break;
          }
        }
        const processedField = preprocessor(contentNodes, instrAttr.trim(), fieldRunRPr);
        processedNodes.push(...processedField);
        i++;
        continue;
      }
    }
    if (fldType === "begin") {
      const fieldInfo = scanFieldSequence(nodes, i);
      if (fieldInfo && (fieldInfo.fieldType === "PAGE" || fieldInfo.fieldType === "NUMPAGES")) {
        const preprocessor = fieldInfo.fieldType === "PAGE" ? preProcessPageInstruction : preProcessNumPagesInstruction;
        const contentNodes = fieldInfo.contentNodes;
        const processedField = preprocessor(contentNodes, fieldInfo.instrText, fieldInfo.fieldRunRPr);
        processedNodes.push(...processedField);
        i = fieldInfo.endIndex + 1;
        continue;
      } else {
        if (fieldInfo) {
          for (let j2 = i; j2 <= fieldInfo.endIndex; j2++) {
            const passNode = nodes[j2];
            if (Array.isArray(passNode.elements)) {
              const childResult = preProcessPageFieldsOnly(passNode.elements, depth + 1);
              passNode.elements = childResult.processedNodes;
            }
            processedNodes.push(passNode);
          }
          i = fieldInfo.endIndex + 1;
          continue;
        }
      }
    }
    if (Array.isArray(node.elements)) {
      const childResult = preProcessPageFieldsOnly(node.elements, depth + 1);
      node.elements = childResult.processedNodes;
    }
    processedNodes.push(node);
    i++;
  }
  return { processedNodes };
};
function scanFieldSequence(nodes, beginIndex) {
  let instrText = "";
  let separateIndex = -1;
  let endIndex = -1;
  const contentNodes = [];
  let fieldRunRPr = null;
  const beginNode = nodes[beginIndex];
  const beginRPr = beginNode.elements?.find((el) => el.name === "w:rPr");
  if (beginRPr && hasSignificantStyling(beginRPr)) {
    fieldRunRPr = beginRPr;
  }
  for (let i = beginIndex + 1; i < nodes.length; i++) {
    const node = nodes[i];
    const fldCharEl = node.elements?.find((el) => el.name === "w:fldChar");
    const fldType = fldCharEl?.attributes?.["w:fldCharType"];
    const instrTextEl = node.elements?.find((el) => el.name === "w:instrText");
    if (instrTextEl) {
      instrText += (instrTextEl.elements?.[0]?.text || "") + " ";
    }
    if (!fieldRunRPr || separateIndex === -1 && fldType !== "end") {
      const rPrNode = node.elements?.find((el) => el.name === "w:rPr");
      if (rPrNode && hasSignificantStyling(rPrNode)) {
        fieldRunRPr = rPrNode;
      }
    }
    if (fldType === "separate") {
      separateIndex = i;
    } else if (fldType === "end") {
      endIndex = i;
      break;
    } else if (separateIndex !== -1 && fldType !== "begin") {
      contentNodes.push(node);
    }
  }
  if (endIndex === -1) {
    return null;
  }
  const fieldType = instrText.trim().split(" ")[0];
  return {
    fieldType,
    instrText: instrText.trim(),
    contentNodes,
    fieldRunRPr,
    endIndex
  };
}
function hasSignificantStyling(rPrNode) {
  if (!rPrNode?.elements?.length) {
    return false;
  }
  const significantElements = [
    "w:rStyle",
    // Run style reference (Word commonly uses this for page number formatting)
    "w:rFonts",
    // Font family
    "w:sz",
    // Font size
    "w:szCs",
    // Complex script font size
    "w:b",
    // Bold
    "w:bCs",
    // Complex script bold
    "w:i",
    // Italic
    "w:iCs",
    // Complex script italic
    "w:u",
    // Underline
    "w:color",
    // Font color
    "w:highlight",
    // Highlight color
    "w:strike",
    // Strikethrough
    "w:dstrike",
    // Double strikethrough
    "w:caps",
    // All caps
    "w:smallCaps"
    // Small caps
  ];
  return rPrNode.elements.some((el) => significantElements.includes(el.name));
}
const HEADER_FOOTER_FILENAME_PATTERN = /^(header|footer)\d*\.xml$/i;
function collectTextBoxParagraphs(nodes, paragraphs = []) {
  if (!Array.isArray(nodes)) return paragraphs;
  nodes.forEach((node) => {
    if (!node) return;
    if (node.name === "w:p") {
      paragraphs.push(node);
      return;
    }
    if (Array.isArray(node.elements)) {
      collectTextBoxParagraphs(node.elements, paragraphs);
    }
  });
  return paragraphs;
}
function preProcessTextBoxContent(textBoxContent, params = {}) {
  if (!textBoxContent?.elements) return textBoxContent;
  const clone = carbonCopy(textBoxContent);
  const filename = typeof params.filename === "string" ? params.filename : "";
  const isHeaderFooter = HEADER_FOOTER_FILENAME_PATTERN.test(filename);
  if (isHeaderFooter) {
    const { processedNodes: processedNodes2 } = preProcessPageFieldsOnly(clone.elements);
    clone.elements = processedNodes2;
    return clone;
  }
  const { processedNodes } = preProcessNodesForFldChar(clone.elements, params.docx);
  clone.elements = processedNodes;
  return clone;
}
function halfPointsToPixels(halfPoints) {
  if (halfPoints == null) return void 0;
  const numeric = Number(halfPoints);
  if (!Number.isFinite(numeric)) return void 0;
  const points = numeric / 2;
  return Math.round(points * 96 / 72 * 1e3) / 1e3;
}
function resolveFontFamilyForTextBox(fontFamily, docx) {
  if (!fontFamily) return void 0;
  if (typeof fontFamily === "string") {
    return SuperConverter.toCssFontFamily(fontFamily, docx);
  }
  return resolveDocxFontFamily(fontFamily, docx, SuperConverter.toCssFontFamily);
}
function resolveParagraphPropertiesForTextBox(paragraph, params) {
  const pPr = paragraph.elements?.find((el) => el.name === "w:pPr");
  const inlineParagraphProperties = pPr ? translator$1O.encode({ ...params, nodes: [pPr] }) || {} : {};
  return resolveParagraphProperties(params, inlineParagraphProperties, false);
}
function extractRunFormatting(rPr, paragraphProperties, params) {
  const inlineRunProperties = rPr ? translator$2w.encode({ ...params, nodes: [rPr] }) || {} : {};
  const resolvedRunProperties = resolveRunProperties(params, inlineRunProperties, paragraphProperties || {});
  const formatting = {};
  if (resolvedRunProperties.bold) formatting.bold = true;
  if (resolvedRunProperties.italic) formatting.italic = true;
  const colorValue = resolvedRunProperties.color?.val ?? resolvedRunProperties.color?.["w:val"] ?? resolvedRunProperties.color?.["val"];
  if (colorValue && String(colorValue).toLowerCase() !== "auto") {
    formatting.color = String(colorValue).replace("#", "");
  }
  const fontSizePx = halfPointsToPixels(resolvedRunProperties.fontSize);
  if (fontSizePx) formatting.fontSize = fontSizePx;
  const fontFamily = resolveFontFamilyForTextBox(resolvedRunProperties.fontFamily, params.docx);
  if (fontFamily) formatting.fontFamily = fontFamily;
  return formatting;
}
function extractParagraphAlignment(paragraph) {
  const pPr = paragraph.elements?.find((el) => el.name === "w:pPr");
  const jc = pPr?.elements?.find((el) => el.name === "w:jc");
  if (!jc) return null;
  const jcVal = jc.attributes?.["val"] || jc.attributes?.["w:val"];
  if (jcVal === "left" || jcVal === "start") return "left";
  if (jcVal === "right" || jcVal === "end") return "right";
  if (jcVal === "center") return "center";
  return null;
}
function extractBodyPrProperties(bodyPr) {
  const bodyPrAttrs = bodyPr?.attributes || {};
  let verticalAlign = "center";
  const anchorAttr = bodyPrAttrs["anchor"];
  if (anchorAttr === "t") verticalAlign = "top";
  else if (anchorAttr === "ctr") verticalAlign = "center";
  else if (anchorAttr === "b") verticalAlign = "bottom";
  const EMU_TO_PX = 96 / 914400;
  const DEFAULT_HORIZONTAL_INSET_EMU = 91440;
  const DEFAULT_VERTICAL_INSET_EMU = 45720;
  const lIns = bodyPrAttrs["lIns"] != null ? parseFloat(bodyPrAttrs["lIns"]) : DEFAULT_HORIZONTAL_INSET_EMU;
  const tIns = bodyPrAttrs["tIns"] != null ? parseFloat(bodyPrAttrs["tIns"]) : DEFAULT_VERTICAL_INSET_EMU;
  const rIns = bodyPrAttrs["rIns"] != null ? parseFloat(bodyPrAttrs["rIns"]) : DEFAULT_HORIZONTAL_INSET_EMU;
  const bIns = bodyPrAttrs["bIns"] != null ? parseFloat(bodyPrAttrs["bIns"]) : DEFAULT_VERTICAL_INSET_EMU;
  const insets = {
    top: tIns * EMU_TO_PX,
    right: rIns * EMU_TO_PX,
    bottom: bIns * EMU_TO_PX,
    left: lIns * EMU_TO_PX
  };
  const wrap2 = bodyPrAttrs["wrap"] || "square";
  return { verticalAlign, insets, wrap: wrap2 };
}
const DRAWING_XML_TAG = "w:drawing";
const SHAPE_URI = "http://schemas.microsoft.com/office/word/2010/wordprocessingShape";
const GROUP_URI = "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup";
const normalizeTargetPath$1 = (targetPath = "") => {
  if (!targetPath) return targetPath;
  const trimmed = targetPath.replace(/^\/+/, "");
  if (trimmed.startsWith("word/")) return trimmed;
  if (trimmed.startsWith("media/")) return `word/${trimmed}`;
  return `word/${trimmed}`;
};
const DEFAULT_SHAPE_WIDTH = 100;
const DEFAULT_SHAPE_HEIGHT = 100;
const isDocPrHidden = (docPr) => {
  const hidden = docPr?.attributes?.hidden;
  if (hidden === true || hidden === 1) return true;
  if (hidden == null) return false;
  const normalized = String(hidden).toLowerCase();
  return normalized === "1" || normalized === "true";
};
const extractEffectExtent = (node) => {
  const effectExtent = node?.elements?.find((el) => el.name === "wp:effectExtent");
  if (!effectExtent?.attributes) return null;
  const sanitizeEmuValue = (value) => {
    if (value === null || value === void 0) return 0;
    const numeric = Number(value);
    return Number.isFinite(numeric) ? numeric : 0;
  };
  const left = emuToPixels(sanitizeEmuValue(effectExtent.attributes?.["l"]));
  const top = emuToPixels(sanitizeEmuValue(effectExtent.attributes?.["t"]));
  const right = emuToPixels(sanitizeEmuValue(effectExtent.attributes?.["r"]));
  const bottom = emuToPixels(sanitizeEmuValue(effectExtent.attributes?.["b"]));
  if (!left && !top && !right && !bottom) return null;
  return { left, top, right, bottom };
};
function handleImageNode(node, params, isAnchor) {
  if (!node) return null;
  const { docx, filename, converter } = params;
  const attributes = node?.attributes || {};
  const { order, originalChildren } = collectPreservedDrawingChildren(node);
  const padding = {
    top: emuToPixels(attributes?.["distT"]),
    bottom: emuToPixels(attributes?.["distB"]),
    left: emuToPixels(attributes?.["distL"]),
    right: emuToPixels(attributes?.["distR"])
  };
  const extent = node?.elements?.find((el) => el.name === "wp:extent");
  const size = {
    width: emuToPixels(extent?.attributes?.cx),
    height: emuToPixels(extent?.attributes?.cy)
  };
  let transformData = {};
  const effectExtent = node?.elements?.find((el) => el.name === "wp:effectExtent");
  if (effectExtent) {
    const sanitizeEmuValue = (value) => {
      if (value === null || value === void 0) return 0;
      const numeric = Number(value);
      return Number.isFinite(numeric) ? numeric : 0;
    };
    transformData.sizeExtension = {
      left: emuToPixels(sanitizeEmuValue(effectExtent.attributes?.["l"])),
      top: emuToPixels(sanitizeEmuValue(effectExtent.attributes?.["t"])),
      right: emuToPixels(sanitizeEmuValue(effectExtent.attributes?.["r"])),
      bottom: emuToPixels(sanitizeEmuValue(effectExtent.attributes?.["b"]))
    };
  }
  const positionHTag = node?.elements?.find((el) => el.name === "wp:positionH");
  const positionH = positionHTag?.elements?.find((el) => el.name === "wp:posOffset");
  const positionHValue = emuToPixels(positionH?.elements[0]?.text);
  const hRelativeFrom = positionHTag?.attributes?.relativeFrom;
  const alignH = positionHTag?.elements?.find((el) => el.name === "wp:align")?.elements?.[0]?.text;
  const positionVTag = node?.elements?.find((el) => el.name === "wp:positionV");
  const positionV = positionVTag?.elements?.find((el) => el.name === "wp:posOffset");
  const positionVValue = emuToPixels(positionV?.elements[0]?.text);
  const vRelativeFrom = positionVTag?.attributes?.relativeFrom;
  const alignV = positionVTag?.elements?.find((el) => el.name === "wp:align")?.elements?.[0]?.text;
  const marginOffset = {
    horizontal: positionHValue,
    top: positionVValue
  };
  const useSimplePos = attributes["simplePos"] === "1" || attributes["simplePos"] === 1 || attributes["simplePos"] === true;
  const simplePosNode = node?.elements?.find((el) => el.name === "wp:simplePos");
  const wrapNode = isAnchor ? node?.elements?.find(
    (el) => ["wp:wrapNone", "wp:wrapSquare", "wp:wrapThrough", "wp:wrapTight", "wp:wrapTopAndBottom"].includes(el.name)
  ) : null;
  const wrap2 = isAnchor ? { type: wrapNode?.name.slice(7) || "None", attrs: {} } : { type: "Inline" };
  switch (wrap2.type) {
    case "Square":
      if (wrapNode?.attributes?.wrapText) {
        wrap2.attrs.wrapText = wrapNode.attributes.wrapText;
      }
      if ("distB" in (wrapNode?.attributes || {})) {
        wrap2.attrs.distBottom = emuToPixels(wrapNode.attributes.distB);
      }
      if ("distL" in (wrapNode?.attributes || {})) {
        wrap2.attrs.distLeft = emuToPixels(wrapNode.attributes.distL);
      }
      if ("distR" in (wrapNode?.attributes || {})) {
        wrap2.attrs.distRight = emuToPixels(wrapNode.attributes.distR);
      }
      if ("distT" in (wrapNode?.attributes || {})) {
        wrap2.attrs.distTop = emuToPixels(wrapNode.attributes.distT);
      }
      break;
    case "Tight":
    case "Through": {
      if ("distL" in (wrapNode?.attributes || {})) {
        wrap2.attrs.distLeft = emuToPixels(wrapNode.attributes.distL);
      }
      if ("distR" in (wrapNode?.attributes || {})) {
        wrap2.attrs.distRight = emuToPixels(wrapNode.attributes.distR);
      }
      if ("distT" in (wrapNode?.attributes || {})) {
        wrap2.attrs.distTop = emuToPixels(wrapNode.attributes.distT);
      }
      if ("distB" in (wrapNode?.attributes || {})) {
        wrap2.attrs.distBottom = emuToPixels(wrapNode.attributes.distB);
      }
      if ("wrapText" in (wrapNode?.attributes || {})) {
        wrap2.attrs.wrapText = wrapNode.attributes.wrapText;
      }
      const polygon = wrapNode?.elements?.find((el) => el.name === "wp:wrapPolygon");
      if (polygon) {
        wrap2.attrs.polygon = polygonToObj(polygon);
        if (polygon.attributes?.edited !== void 0) {
          wrap2.attrs.polygonEdited = polygon.attributes.edited;
        }
      }
      break;
    }
    case "TopAndBottom":
      if ("distB" in (wrapNode?.attributes || {})) {
        wrap2.attrs.distBottom = emuToPixels(wrapNode.attributes.distB);
      }
      if ("distT" in (wrapNode?.attributes || {})) {
        wrap2.attrs.distTop = emuToPixels(wrapNode.attributes.distT);
      }
      break;
    case "None":
      wrap2.attrs.behindDoc = node.attributes?.behindDoc === "1";
      break;
  }
  const docPr = node.elements.find((el) => el.name === "wp:docPr");
  const isHidden = isDocPrHidden(docPr);
  let anchorData = null;
  if (hRelativeFrom || alignH || vRelativeFrom || alignV) {
    anchorData = {
      hRelativeFrom,
      vRelativeFrom,
      alignH,
      alignV
    };
  }
  const graphic = node.elements.find((el) => el.name === "a:graphic");
  const graphicData = graphic?.elements.find((el) => el.name === "a:graphicData");
  const { uri: uri2 } = graphicData?.attributes || {};
  if (!graphicData) {
    return null;
  }
  if (uri2 === SHAPE_URI) {
    const shapeMarginOffset = {
      left: positionHValue,
      horizontal: positionHValue,
      top: positionVValue
    };
    return handleShapeDrawing(
      params,
      node,
      graphicData,
      size,
      padding,
      shapeMarginOffset,
      anchorData,
      wrap2,
      isAnchor,
      isHidden
    );
  }
  if (uri2 === GROUP_URI) {
    const shapeMarginOffset = {
      left: positionHValue,
      horizontal: positionHValue,
      top: positionVValue
    };
    return handleShapeGroup(params, node, graphicData, size, padding, shapeMarginOffset, anchorData, wrap2, isHidden);
  }
  const picture = graphicData?.elements.find((el) => el.name === "pic:pic");
  if (!picture || !picture.elements) {
    return null;
  }
  const blipFill = picture.elements.find((el) => el.name === "pic:blipFill");
  const blip = blipFill?.elements.find((el) => el.name === "a:blip");
  if (!blip) {
    return null;
  }
  const stretch = blipFill?.elements?.find((el) => el.name === "a:stretch");
  const fillRect = stretch?.elements?.find((el) => el.name === "a:fillRect");
  const srcRect = blipFill?.elements?.find((el) => el.name === "a:srcRect");
  const srcRectAttrs = srcRect?.attributes || {};
  const srcRectHasNegativeValues = ["l", "t", "r", "b"].some((attr) => {
    const val = srcRectAttrs[attr];
    return val != null && parseFloat(val) < 0;
  });
  const shouldStretch = Boolean(stretch && fillRect);
  const shouldCover = shouldStretch && !srcRectHasNegativeValues;
  const spPr = picture.elements.find((el) => el.name === "pic:spPr");
  if (spPr) {
    const xfrm = spPr.elements.find((el) => el.name === "a:xfrm");
    if (xfrm?.attributes) {
      transformData = {
        ...transformData,
        rotation: rotToDegrees(xfrm.attributes["rot"]),
        verticalFlip: xfrm.attributes["flipV"] === "1",
        horizontalFlip: xfrm.attributes["flipH"] === "1"
      };
    }
  }
  const { attributes: blipAttributes = {} } = blip;
  const rEmbed = blipAttributes["r:embed"];
  if (!rEmbed) {
    return null;
  }
  const currentFile = filename || "document.xml";
  let rels = docx[`word/_rels/${currentFile}.rels`];
  if (!rels) rels = docx[`word/_rels/document.xml.rels`];
  const relationships = rels?.elements.find((el) => el.name === "Relationships");
  const { elements } = relationships || [];
  const rel = elements?.find((el) => el.attributes["Id"] === rEmbed);
  if (!rel) {
    return null;
  }
  const { attributes: relAttributes } = rel;
  const targetPath = relAttributes["Target"];
  const path = normalizeTargetPath$1(targetPath);
  const extension = path.substring(path.lastIndexOf(".") + 1);
  let finalSrc = path;
  let finalExtension = extension;
  let wasConverted = false;
  if (isMetafileExtension(extension)) {
    const mediaData = converter?.media?.[path];
    if (mediaData) {
      if (converter?.domEnvironment) {
        setMetafileDomEnvironment(converter.domEnvironment);
      }
      const conversionResult = convertMetafileToSvg(mediaData, extension, size);
      if (conversionResult?.dataUri) {
        finalSrc = conversionResult.dataUri;
        finalExtension = conversionResult.format || "svg";
        wasConverted = true;
      }
    }
  }
  const wrapValue = wrap2;
  const nodeAttrs = {
    // originalXml: carbonCopy(node),
    src: finalSrc,
    alt: isMetafileExtension(extension) && !wasConverted ? "Unable to render EMF/WMF image" : docPr?.attributes?.name || "Image",
    extension: finalExtension,
    // Store original path and extension for potential round-tripping
    ...wasConverted && { originalSrc: path, originalExtension: extension },
    id: docPr?.attributes?.id || "",
    title: docPr?.attributes?.descr || "Image",
    ...isHidden ? { hidden: true } : {},
    inline: true,
    // Always true; wrap.type controls actual layout behavior
    padding,
    marginOffset,
    size,
    anchorData,
    isAnchor,
    transformData,
    ...useSimplePos && {
      simplePos: {
        x: simplePosNode.attributes?.x,
        y: simplePosNode.attributes?.y
      }
    },
    wrap: wrapValue,
    ...wrap2.type === "Square" && wrap2.attrs.wrapText ? {
      wrapText: wrap2.attrs.wrapText
    } : {},
    wrapTopAndBottom: wrap2.type === "TopAndBottom",
    shouldCover,
    originalPadding: {
      distT: attributes["distT"],
      distB: attributes["distB"],
      distL: attributes["distL"],
      distR: attributes["distR"]
    },
    originalAttributes: node.attributes,
    rId: relAttributes["Id"],
    ...order.length ? { drawingChildOrder: order } : {},
    ...originalChildren.length ? { originalDrawingChildren: originalChildren } : {}
  };
  return {
    type: "image",
    attrs: nodeAttrs
  };
}
const handleShapeDrawing = (params, node, graphicData, size, padding, marginOffset, anchorData, wrap2, isAnchor, isHidden) => {
  const wsp = graphicData.elements.find((el) => el.name === "wps:wsp");
  const textBox = wsp.elements.find((el) => el.name === "wps:txbx");
  const textBoxContent = textBox?.elements?.find((el) => el.name === "w:txbxContent");
  const spPr = wsp.elements.find((el) => el.name === "wps:spPr");
  const prstGeom = spPr?.elements.find((el) => el.name === "a:prstGeom");
  const shapeType = prstGeom?.attributes["prst"];
  if (shapeType) {
    const result = getVectorShape({ params, node, graphicData, size, marginOffset, anchorData, wrap: wrap2, isAnchor });
    if (result?.attrs && isHidden) {
      result.attrs.hidden = true;
    }
    if (result) return result;
  }
  const fallbackType = textBoxContent ? "textbox" : "drawing";
  const placeholder = buildShapePlaceholder(node, size, padding, marginOffset, fallbackType);
  if (placeholder?.attrs && isHidden) {
    placeholder.attrs.hidden = true;
  }
  return placeholder;
};
function collectPreservedDrawingChildren(node) {
  const order = [];
  const original = [];
  if (!Array.isArray(node?.elements)) {
    return { order, originalChildren: original };
  }
  node.elements.forEach((child, index2) => {
    if (!child) return;
    const name = child.name ?? null;
    order.push(name);
    original.push({
      index: index2,
      xml: carbonCopy(child)
    });
  });
  return { order, originalChildren: original };
}
const handleShapeGroup = (params, node, graphicData, size, padding, marginOffset, anchorData, wrap2, isHidden) => {
  const wgp = graphicData.elements.find((el) => el.name === "wpg:wgp");
  if (!wgp) {
    const placeholder = buildShapePlaceholder(node, size, padding, marginOffset, "group");
    if (placeholder?.attrs && isHidden) {
      placeholder.attrs.hidden = true;
    }
    return placeholder;
  }
  const grpSpPr = wgp.elements.find((el) => el.name === "wpg:grpSpPr");
  const xfrm = grpSpPr?.elements?.find((el) => el.name === "a:xfrm");
  const groupTransform = {};
  if (xfrm) {
    const off = xfrm.elements?.find((el) => el.name === "a:off");
    const ext = xfrm.elements?.find((el) => el.name === "a:ext");
    const chOff = xfrm.elements?.find((el) => el.name === "a:chOff");
    const chExt = xfrm.elements?.find((el) => el.name === "a:chExt");
    if (off) {
      groupTransform.x = emuToPixels(off.attributes?.["x"] || 0);
      groupTransform.y = emuToPixels(off.attributes?.["y"] || 0);
    }
    if (ext) {
      groupTransform.width = emuToPixels(ext.attributes?.["cx"] || 0);
      groupTransform.height = emuToPixels(ext.attributes?.["cy"] || 0);
    }
    if (chOff) {
      groupTransform.childX = emuToPixels(chOff.attributes?.["x"] || 0);
      groupTransform.childY = emuToPixels(chOff.attributes?.["y"] || 0);
      groupTransform.childOriginXEmu = parseFloat(chOff.attributes?.["x"] || 0);
      groupTransform.childOriginYEmu = parseFloat(chOff.attributes?.["y"] || 0);
    }
    if (chExt) {
      groupTransform.childWidth = emuToPixels(chExt.attributes?.["cx"] || 0);
      groupTransform.childHeight = emuToPixels(chExt.attributes?.["cy"] || 0);
    }
  }
  const childShapes = wgp.elements.filter((el) => el.name === "wps:wsp");
  const childPictures = wgp.elements.filter((el) => el.name === "pic:pic");
  const shapes = childShapes.map((wsp) => {
    const spPr = wsp.elements?.find((el) => el.name === "wps:spPr");
    if (!spPr) return null;
    const prstGeom = spPr.elements?.find((el) => el.name === "a:prstGeom");
    const shapeKind = prstGeom?.attributes?.["prst"];
    const shapeXfrm = spPr.elements?.find((el) => el.name === "a:xfrm");
    const shapeOff = shapeXfrm?.elements?.find((el) => el.name === "a:off");
    const shapeExt = shapeXfrm?.elements?.find((el) => el.name === "a:ext");
    const rawX = shapeOff?.attributes?.["x"] ? parseFloat(shapeOff.attributes["x"]) : 0;
    const rawY = shapeOff?.attributes?.["y"] ? parseFloat(shapeOff.attributes["y"]) : 0;
    const rawWidth = shapeExt?.attributes?.["cx"] ? parseFloat(shapeExt.attributes["cx"]) : 914400;
    const rawHeight = shapeExt?.attributes?.["cy"] ? parseFloat(shapeExt.attributes["cy"]) : 914400;
    let x2, y2, width, height;
    if (groupTransform.childWidth && groupTransform.childHeight) {
      const scaleX = groupTransform.width / groupTransform.childWidth;
      const scaleY = groupTransform.height / groupTransform.childHeight;
      const childOriginX = groupTransform.childOriginXEmu || 0;
      const childOriginY = groupTransform.childOriginYEmu || 0;
      x2 = groupTransform.x + emuToPixels((rawX - childOriginX) * scaleX);
      y2 = groupTransform.y + emuToPixels((rawY - childOriginY) * scaleY);
      width = emuToPixels(rawWidth * scaleX);
      height = emuToPixels(rawHeight * scaleY);
    } else {
      x2 = emuToPixels(rawX);
      y2 = emuToPixels(rawY);
      width = emuToPixels(rawWidth);
      height = emuToPixels(rawHeight);
    }
    const rotation = shapeXfrm?.attributes?.["rot"] ? rotToDegrees(shapeXfrm.attributes["rot"]) : 0;
    const flipH = shapeXfrm?.attributes?.["flipH"] === "1";
    const flipV = shapeXfrm?.attributes?.["flipV"] === "1";
    const style = wsp.elements?.find((el) => el.name === "wps:style");
    const fillColor = extractFillColor(spPr, style);
    const strokeColor = extractStrokeColor(spPr, style);
    const strokeWidth = extractStrokeWidth(spPr);
    const lineEnds = extractLineEnds(spPr);
    const cNvPr = wsp.elements?.find((el) => el.name === "wps:cNvPr");
    const shapeId = cNvPr?.attributes?.["id"];
    const shapeName = cNvPr?.attributes?.["name"];
    const textBox = wsp.elements?.find((el) => el.name === "wps:txbx");
    const textBoxContent = textBox?.elements?.find((el) => el.name === "w:txbxContent");
    const bodyPr = wsp.elements?.find((el) => el.name === "wps:bodyPr");
    let textContent = null;
    if (textBoxContent) {
      textContent = extractTextFromTextBox(textBoxContent, bodyPr, params);
    }
    const textAlign = textContent?.horizontalAlign || "left";
    return {
      shapeType: "vectorShape",
      attrs: {
        kind: shapeKind,
        x: x2,
        y: y2,
        width,
        height,
        rotation,
        flipH,
        flipV,
        fillColor,
        strokeColor,
        strokeWidth,
        lineEnds,
        shapeId,
        shapeName,
        textContent,
        textAlign,
        textVerticalAlign: textContent?.verticalAlign,
        textInsets: textContent?.insets
      }
    };
  }).filter(Boolean);
  const pictures = childPictures.map((pic) => {
    const spPr = pic.elements?.find((el) => el.name === "pic:spPr");
    if (!spPr) return null;
    const xfrm2 = spPr.elements?.find((el) => el.name === "a:xfrm");
    const off = xfrm2?.elements?.find((el) => el.name === "a:off");
    const ext = xfrm2?.elements?.find((el) => el.name === "a:ext");
    const rawX = off?.attributes?.["x"] ? parseFloat(off.attributes["x"]) : 0;
    const rawY = off?.attributes?.["y"] ? parseFloat(off.attributes["y"]) : 0;
    const rawWidth = ext?.attributes?.["cx"] ? parseFloat(ext.attributes["cx"]) : 914400;
    const rawHeight = ext?.attributes?.["cy"] ? parseFloat(ext.attributes["cy"]) : 914400;
    let x2, y2, width, height;
    if (groupTransform.childWidth && groupTransform.childHeight) {
      const scaleX = groupTransform.width / groupTransform.childWidth;
      const scaleY = groupTransform.height / groupTransform.childHeight;
      const childOriginX = groupTransform.childOriginXEmu || 0;
      const childOriginY = groupTransform.childOriginYEmu || 0;
      x2 = groupTransform.x + emuToPixels((rawX - childOriginX) * scaleX);
      y2 = groupTransform.y + emuToPixels((rawY - childOriginY) * scaleY);
      width = emuToPixels(rawWidth * scaleX);
      height = emuToPixels(rawHeight * scaleY);
    } else {
      x2 = emuToPixels(rawX);
      y2 = emuToPixels(rawY);
      width = emuToPixels(rawWidth);
      height = emuToPixels(rawHeight);
    }
    const blipFill = pic.elements?.find((el) => el.name === "pic:blipFill");
    const blip = blipFill?.elements?.find((el) => el.name === "a:blip");
    if (!blip) return null;
    const rEmbed = blip.attributes?.["r:embed"];
    if (!rEmbed) return null;
    const currentFile = params.filename || "document.xml";
    let rels = params.docx[`word/_rels/${currentFile}.rels`];
    if (!rels) rels = params.docx[`word/_rels/document.xml.rels`];
    const relationships = rels?.elements.find((el) => el.name === "Relationships");
    const { elements } = relationships || [];
    const rel = elements?.find((el) => el.attributes["Id"] === rEmbed);
    if (!rel) return null;
    const targetPath = normalizeTargetPath$1(rel.attributes?.["Target"]);
    const path = targetPath;
    const nvPicPr = pic.elements?.find((el) => el.name === "pic:nvPicPr");
    const cNvPr = nvPicPr?.elements?.find((el) => el.name === "pic:cNvPr");
    const picId = cNvPr?.attributes?.["id"];
    const picName = cNvPr?.attributes?.["name"];
    return {
      shapeType: "image",
      attrs: {
        x: x2,
        y: y2,
        width,
        height,
        src: path,
        imageId: picId,
        imageName: picName
      }
    };
  }).filter(Boolean);
  const allShapes = [...pictures, ...shapes];
  const schemaAttrs = {};
  const drawingNode = params.nodes?.[0];
  if (drawingNode?.name === DRAWING_XML_TAG) {
    schemaAttrs.drawingContent = drawingNode;
  }
  const result = {
    type: "shapeGroup",
    attrs: {
      ...schemaAttrs,
      ...isHidden ? { hidden: true } : {},
      groupTransform,
      shapes: allShapes,
      size,
      padding,
      marginOffset,
      anchorData,
      wrap: wrap2,
      originalAttributes: node?.attributes
    }
  };
  return result;
};
function extractTextFromTextBox(textBoxContent, bodyPr, params = {}) {
  if (!textBoxContent || !textBoxContent.elements) return null;
  const processedContent = preProcessTextBoxContent(textBoxContent, params);
  const paragraphs = collectTextBoxParagraphs(processedContent?.elements || []);
  const textParts = [];
  let horizontalAlign = null;
  const appendFieldPart = (fieldType, node, paragraphProperties) => {
    const rPr = node?.elements?.find((el) => el.name === "w:rPr");
    const formatting = extractRunFormatting(rPr, paragraphProperties, params);
    textParts.push({ text: "", formatting, fieldType });
  };
  const handleRun = (run2, paragraphProperties) => {
    if (!run2?.elements) return false;
    const rPr = run2.elements.find((el) => el.name === "w:rPr");
    const formatting = extractRunFormatting(rPr, paragraphProperties, params);
    let hasText = false;
    run2.elements.forEach((el) => {
      if (el.name === "w:t" || el.name === "w:delText") {
        const textNode = el.elements?.find((n) => n.type === "text");
        if (textNode) {
          hasText = true;
          const cleanedText = typeof textNode.text === "string" ? textNode.text.replace(/\[\[sdspace\]\]/g, " ") : textNode.text;
          textParts.push({ text: cleanedText, formatting });
        }
      } else if (el.name === "w:tab") {
        hasText = true;
        textParts.push({ text: "	", formatting });
      } else if (el.name === "w:br") {
        hasText = true;
        textParts.push({ text: "\n", formatting: {}, isLineBreak: true });
      } else if (el.name === "sd:autoPageNumber") {
        hasText = true;
        appendFieldPart("PAGE", el, paragraphProperties);
      } else if (el.name === "sd:totalPageNumber") {
        hasText = true;
        appendFieldPart("NUMPAGES", el, paragraphProperties);
      }
    });
    return hasText;
  };
  const handleParagraphElement = (el, paragraphProperties) => {
    if (!el) return false;
    if (el.name === "w:r") {
      return handleRun(el, paragraphProperties);
    }
    if (el.name === "sd:autoPageNumber") {
      appendFieldPart("PAGE", el, paragraphProperties);
      return true;
    }
    if (el.name === "sd:totalPageNumber") {
      appendFieldPart("NUMPAGES", el, paragraphProperties);
      return true;
    }
    if ((el.name === "w:hyperlink" || el.name === "sd:pageReference") && Array.isArray(el.elements)) {
      let hasText = false;
      el.elements.forEach((child) => {
        if (handleParagraphElement(child, paragraphProperties)) {
          hasText = true;
        }
      });
      return hasText;
    }
    return false;
  };
  paragraphs.forEach((paragraph, paragraphIndex) => {
    const paragraphProperties = resolveParagraphPropertiesForTextBox(paragraph, params);
    if (!horizontalAlign) {
      horizontalAlign = extractParagraphAlignment(paragraph);
    }
    let paragraphHasText = false;
    const elements = paragraph.elements || [];
    elements.forEach((el) => {
      if (handleParagraphElement(el, paragraphProperties)) {
        paragraphHasText = true;
      }
    });
    if (paragraphIndex < paragraphs.length - 1) {
      textParts.push({
        text: "\n",
        formatting: {},
        isLineBreak: true,
        isEmptyParagraph: !paragraphHasText
      });
    }
  });
  if (textParts.length === 0) return null;
  const { verticalAlign, insets, wrap: wrap2 } = extractBodyPrProperties(bodyPr);
  return {
    parts: textParts,
    horizontalAlign: horizontalAlign || "left",
    verticalAlign,
    insets,
    wrap: wrap2
  };
}
const buildShapePlaceholder = (node, size, padding, marginOffset, shapeType) => {
  const attrs = {
    drawingContent: {
      name: DRAWING_XML_TAG,
      elements: [carbonCopy(node)]
    },
    attributes: {
      "data-shape-type": shapeType
    }
  };
  if (size && (Number.isFinite(size.width) || Number.isFinite(size.height))) {
    attrs.size = {
      ...Number.isFinite(size.width) ? { width: size.width } : {},
      ...Number.isFinite(size.height) ? { height: size.height } : {}
    };
  }
  if (padding) {
    const paddingData = {};
    if (Number.isFinite(padding.top)) paddingData["data-padding-top"] = padding.top;
    if (Number.isFinite(padding.right)) paddingData["data-padding-right"] = padding.right;
    if (Number.isFinite(padding.bottom)) paddingData["data-padding-bottom"] = padding.bottom;
    if (Number.isFinite(padding.left)) paddingData["data-padding-left"] = padding.left;
    if (Object.keys(paddingData).length) {
      attrs.attributes = {
        ...attrs.attributes,
        ...paddingData
      };
    }
  }
  if (marginOffset) {
    const offsetData = {};
    const horizontal = Number.isFinite(marginOffset.horizontal) ? marginOffset.horizontal : Number.isFinite(marginOffset.left) ? marginOffset.left : void 0;
    if (Number.isFinite(horizontal)) offsetData["data-offset-x"] = horizontal;
    if (Number.isFinite(marginOffset.top)) offsetData["data-offset-y"] = marginOffset.top;
    if (Object.keys(offsetData).length) {
      attrs.attributes = {
        ...attrs.attributes,
        ...offsetData
      };
    }
  }
  return {
    type: "contentBlock",
    attrs
  };
};
function getVectorShape({ params, node, graphicData, size, marginOffset, anchorData, wrap: wrap2, isAnchor }) {
  const schemaAttrs = {};
  const drawingNode = params.nodes?.[0];
  if (drawingNode?.name === "w:drawing") {
    schemaAttrs.drawingContent = drawingNode;
  }
  const wsp = graphicData.elements?.find((el) => el.name === "wps:wsp");
  if (!wsp) {
    return null;
  }
  const spPr = wsp.elements?.find((el) => el.name === "wps:spPr");
  if (!spPr) {
    return null;
  }
  const prstGeom = spPr.elements?.find((el) => el.name === "a:prstGeom");
  const shapeKind = prstGeom?.attributes?.["prst"];
  if (!shapeKind) {
    console.warn("Shape kind not found");
  }
  schemaAttrs.kind = shapeKind;
  const width = size?.width ?? DEFAULT_SHAPE_WIDTH;
  const height = size?.height ?? DEFAULT_SHAPE_HEIGHT;
  const xfrm = spPr.elements?.find((el) => el.name === "a:xfrm");
  const rotation = xfrm?.attributes?.["rot"] ? rotToDegrees(xfrm.attributes["rot"]) : 0;
  const flipH = xfrm?.attributes?.["flipH"] === "1";
  const flipV = xfrm?.attributes?.["flipV"] === "1";
  const style = wsp.elements?.find((el) => el.name === "wps:style");
  const fillColor = extractFillColor(spPr, style);
  const strokeColor = extractStrokeColor(spPr, style);
  const strokeWidth = extractStrokeWidth(spPr);
  const lineEnds = extractLineEnds(spPr);
  const effectExtent = extractEffectExtent(node);
  const textBox = wsp.elements?.find((el) => el.name === "wps:txbx");
  const textBoxContent = textBox?.elements?.find((el) => el.name === "w:txbxContent");
  const bodyPr = wsp.elements?.find((el) => el.name === "wps:bodyPr");
  let textContent = null;
  let textAlign = "left";
  if (textBoxContent) {
    textContent = extractTextFromTextBox(textBoxContent, bodyPr, params);
    textAlign = textContent?.horizontalAlign || "left";
  }
  return {
    type: "vectorShape",
    attrs: {
      ...schemaAttrs,
      width,
      height,
      rotation,
      flipH,
      flipV,
      fillColor,
      strokeColor,
      strokeWidth,
      lineEnds,
      effectExtent,
      marginOffset,
      anchorData,
      wrap: wrap2,
      isAnchor,
      textContent,
      textAlign,
      textVerticalAlign: textContent?.verticalAlign,
      textInsets: textContent?.insets,
      originalAttributes: node?.attributes
    }
  };
}
function handleAnchorNode(params) {
  const { node } = params.extraParams;
  if (node.name !== "wp:anchor") {
    return null;
  }
  return handleImageNode(node, params, true);
}
const sanitizeDocxMediaName = (value, fallback = "image") => {
  if (!value) return fallback;
  const sanitized = value.replace(/[^a-zA-Z0-9_-]/g, "_");
  return sanitized || fallback;
};
const getFallbackImageNameFromDataUri = (src = "", fallback = "image") => {
  if (!src || typeof src !== "string") return fallback;
  const [prefix] = src.split(";");
  const [, maybeType] = prefix.split("/");
  const extension = maybeType?.toLowerCase();
  return extension ? `${fallback}.${extension}` : fallback;
};
function createDocument(converter, schema, editor, { check = false } = {}) {
  const documentData = converter.getSchema(editor);
  if (documentData) {
    const documentNode = schema.nodeFromJSON(documentData);
    if (check) {
      documentNode.check();
    }
    return documentNode;
  }
  return schema.topNodeType.createAndFill();
}
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function cleanSchemaItem(schemaItem) {
  const entries = Object.entries(schemaItem).filter(([key, value]) => {
    if (key === "attrs" && isEmptyObject(value)) {
      return false;
    }
    return value !== null && value !== void 0;
  });
  return Object.fromEntries(entries);
}
function chainableEditorState(transaction, state2) {
  let { selection, doc: doc2, storedMarks } = transaction;
  return {
    ...state2,
    apply: state2.apply.bind(state2),
    applyTransaction: state2.applyTransaction.bind(state2),
    plugins: state2.plugins,
    schema: state2.schema,
    reconfigure: state2.reconfigure.bind(state2),
    toJSON: state2.toJSON.bind(state2),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc2;
    },
    get tr() {
      selection = transaction.selection;
      doc2 = transaction.doc;
      storedMarks = transaction.storedMarks;
      return transaction;
    }
  };
}
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}' in schema.`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}' in schema.`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
function defaultBlockAt(match) {
  for (let i = 0; i < match.edgeCount; i++) {
    const { type: type2 } = match.edge(i);
    if (type2.isTextblock && !type2.hasRequiredAttrs()) return type2;
  }
  return null;
}
const findParentNodeClosestToPos = ($pos, predicate) => {
  for (let i = $pos.depth; i > 0; i--) {
    const node = $pos.node(i);
    if (predicate(node)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node
      };
    }
  }
};
const findParentNode = (predicate) => {
  return ({ $from }) => findParentNodeClosestToPos($from, predicate);
};
const isList$1 = (name, extensions) => {
  const nodeExtensions = extensions.filter((e) => e.type === "node");
  const extension = nodeExtensions.find((i) => i.name === name);
  if (!extension) return false;
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrGet(getExtensionConfigField(extension, "group", context));
  if (typeof group !== "string") return false;
  return group.split(" ").includes("list");
};
function generateDocxListAttributes(listType) {
  const listTypesMap = {
    bulletList: 1,
    orderedList: 2
  };
  return {
    attributes: {
      parentAttributes: {
        "w14:paraId": generateDocxRandomId(),
        "w14:textId": generateDocxRandomId(),
        "w:rsidR": generateDocxRandomId(),
        "w:rsidRDefault": generateDocxRandomId(),
        "w:rsidP": generateDocxRandomId(),
        paragraphProperties: {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:pStyle",
              attributes: {
                "w:val": "ListParagraph"
              }
            },
            {
              type: "element",
              name: "w:numPr",
              elements: [
                {
                  type: "element",
                  name: "w:ilvl",
                  attributes: {
                    "w:val": "0"
                  }
                },
                {
                  type: "element",
                  name: "w:numId",
                  attributes: {
                    "w:val": listTypesMap[listType] || 0
                  }
                }
              ]
            }
          ]
        }
      }
    }
  };
}
const isTextSelection = (value) => {
  return value instanceof TextSelection;
};
function findMarkInSet(marks, type2, attrs = {}) {
  return marks.find((item) => {
    return item.type === type2 && objectIncludes(item.attrs, attrs);
  });
}
function isMarkInSet(marks, type2, attrs = {}) {
  return !!findMarkInSet(marks, type2, attrs);
}
function getMarkRange($pos, type2, attrs = {}) {
  if (!$pos || !type2) return;
  let start = $pos.parent.childAfter($pos.parentOffset);
  if ($pos.parentOffset === start.offset && start.offset !== 0) {
    start = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start.node) return;
  const mark = findMarkInSet([...start.node.marks], type2, attrs);
  if (!mark) return;
  let startIndex = start.index;
  let startPos = $pos.start() + start.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start.node.nodeSize;
  findMarkInSet([...start.node.marks], type2, attrs);
  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type2, attrs)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return { from: startPos, to: endPos };
}
function isMarkActive(state2, typeOrName, attrs = {}) {
  const { empty, ranges } = state2.selection;
  const type2 = typeOrName ? getMarkType(typeOrName, state2.schema) : null;
  if (empty) {
    return !!(state2.storedMarks || state2.selection.$from.marks()).filter((mark) => {
      if (!type2) return true;
      return type2.name === mark.type.name;
    }).find((mark) => objectIncludes(mark.attrs, attrs, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from = $from.pos;
    const to = $to.pos;
    state2.doc.nodesBetween(from, to, (node, pos) => {
      if (!node.isText && !node.marks.length) return;
      const relativeFrom = Math.max(from, pos);
      const relativeTo = Math.min(to, pos + node.nodeSize);
      const range3 = relativeTo - relativeFrom;
      selectionRange += range3;
      markRanges.push(
        ...node.marks.map((mark) => ({
          mark,
          from: relativeFrom,
          to: relativeTo
        }))
      );
    });
  });
  if (selectionRange === 0) return false;
  const matchedRange = markRanges.filter((markRange) => {
    if (!type2) return true;
    return type2.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attrs, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type2) return true;
    return markRange.mark.type !== type2 && markRange.mark.type.excludes(type2);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range2 = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range2 >= selectionRange;
}
function getMarksBetween(from, to, doc2) {
  const marks = [];
  if (from === to) {
    doc2.resolve(from).marks().forEach((mark) => {
      const $pos = doc2.resolve(from - 1);
      const range2 = getMarkRange($pos, mark.type);
      if (!range2) {
        return;
      }
      marks.push({
        mark,
        ...range2
      });
    });
  } else {
    doc2.nodesBetween(from, to, (node, pos) => {
      if (!node || node?.nodeSize === void 0) {
        return;
      }
      marks.push(
        ...node.marks.map((mark) => ({
          from: pos,
          to: pos + node.nodeSize,
          mark
        }))
      );
    });
  }
  return marks;
}
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) return "node";
  if (schema.marks[name]) return "mark";
  return null;
}
function isNodeActive(state2, typeOrName, attrs = {}) {
  const { from, to, empty } = state2.selection;
  const type2 = typeOrName ? getNodeType(typeOrName, state2.schema) : null;
  const nodeRanges = [];
  state2.doc.nodesBetween(from, to, (node, pos) => {
    if (node.isText) return;
    const relativeFrom = Math.max(from, pos);
    const relativeTo = Math.min(to, pos + node.nodeSize);
    nodeRanges.push({
      node,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type2) return true;
    return type2.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attrs, { strict: false }));
  if (empty) return !!matchedNodeRanges.length;
  const range2 = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range2 >= selectionRange;
}
function isActive(state2, name, attrs = {}) {
  if (!name) {
    return isNodeActive(state2, null, attrs) || isMarkActive(state2, null, attrs);
  }
  const schemaType = getSchemaTypeNameByName(name, state2.schema);
  if (schemaType === "node") {
    return isNodeActive(state2, name, attrs);
  }
  if (schemaType === "mark") {
    return isMarkActive(state2, name, attrs);
  }
  return false;
}
function getMarksFromSelection(state2) {
  const { from, to, empty } = state2.selection;
  const marks = [];
  if (empty) {
    if (state2.storedMarks) {
      marks.push(...state2.storedMarks);
    }
    marks.push(...state2.selection.$head.marks());
  } else {
    state2.doc.nodesBetween(from, to, (node) => {
      marks.push(...node.marks);
    });
  }
  return marks;
}
const findMark = (state2, markType, toArr = false) => {
  const { selection, doc: doc2 } = state2;
  const { $from, $to } = selection;
  const fromMark = $from.marks().find((mark) => mark.type === markType);
  const toMark = $to.marks().find((mark) => mark.type === markType);
  let markFound;
  const marksFound = [];
  doc2.nodesBetween($from.pos, $to.pos, (node, from) => {
    if (node.marks) {
      const actualMark = node.marks.find((mark) => mark.type === markType);
      if (actualMark) {
        markFound = {
          from,
          to: from + node.nodeSize,
          attrs: actualMark.attrs,
          contained: !fromMark || !toMark || fromMark === toMark
        };
        marksFound.push(markFound);
      }
    }
  });
  if (toArr) {
    return marksFound;
  }
  return markFound;
};
function getActiveFormatting(editor) {
  const { state: state2 } = editor;
  const { selection } = state2;
  const marks = getMarksFromSelection(state2);
  const markAttrs = selection.$head.parent.attrs.marksAttrs;
  const marksToProcess = marks.filter((mark) => !["textStyle", "link"].includes(mark.type.name)).map((mark) => ({ name: mark.type.name, attrs: mark.attrs }));
  const textStyleMarks = marks.filter((mark) => mark.type.name === "textStyle");
  marksToProcess.push(...textStyleMarks.flatMap(unwrapTextMarks));
  if (markAttrs) {
    const marksFromAttrs = markAttrs.filter((mark) => !["textStyle", "link"].includes(mark.type)).map((mark) => ({ name: mark.type, attrs: mark.attrs || {} }));
    const textStyleMarksFromAttrs = markAttrs.filter((mark) => mark.type === "textStyle");
    marksToProcess.push(...marksFromAttrs);
    marksToProcess.push(...textStyleMarksFromAttrs.flatMap(unwrapTextMarks));
  }
  const linkMarkType = state2.schema.marks["link"];
  const linkMark = findMark(state2, linkMarkType);
  if (linkMark) {
    let { from, to, attrs } = linkMark;
    if (selection.from >= from && selection.to <= to) {
      marksToProcess.push({ name: "link", attrs });
    }
  }
  const ignoreKeys = ["paragraphSpacing"];
  const attributes = getActiveAttributes(state2);
  Object.keys(attributes).forEach((key) => {
    if (ignoreKeys.includes(key)) return;
    const attrs = {};
    attrs[key] = attributes[key];
    marksToProcess.push({ name: key, attrs });
  });
  const textColor = marksToProcess.find((i) => i.name === "textColor");
  const textHightlight = marksToProcess.find((i) => i.name === "textHighlight");
  if (textColor) {
    marksToProcess.push({
      name: "color",
      attrs: { color: textColor.attrs?.textColor }
    });
  }
  if (textHightlight) {
    marksToProcess.push({
      name: "highlight",
      attrs: { color: textHightlight.attrs?.textHighlight }
    });
  }
  const hasPendingFormatting = !!editor.storage.formatCommands?.storedStyle;
  if (hasPendingFormatting) marksToProcess.push({ name: "copyFormat", attrs: true });
  return marksToProcess;
}
function unwrapTextMarks(textStyleMark) {
  const processedMarks = [];
  const { attrs } = textStyleMark;
  Object.keys(attrs).forEach((key) => {
    if (!attrs[key]) return;
    processedMarks.push({ name: key, attrs: { [key]: attrs[key] } });
  });
  return processedMarks;
}
function getActiveAttributes(state2) {
  try {
    const { from, to, empty } = state2.selection;
    const attributes = {};
    const getAttrs = (node) => {
      Object.keys(node.attrs).forEach((key) => {
        const value = node.attrs[key];
        if (value) {
          attributes[key] = value;
        }
      });
    };
    let start = from;
    let end = to;
    if (empty) state2.doc.nodesBetween(start, end + 1, (node) => getAttrs(node));
    else state2.doc.nodesBetween(from, to, (node) => getAttrs(node));
    return attributes;
  } catch {
    return {};
  }
}
function findChildren(node, predicate) {
  const nodesWithPos = [];
  node.descendants((child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos
      });
    }
  });
  return nodesWithPos;
}
function posToDOMRect(view, from, to) {
  const minPos = 0;
  const maxPos = view.state.doc.content.size;
  const resolvedFrom = minMax(from, minPos, maxPos);
  const resolvedEnd = minMax(to, minPos, maxPos);
  const start = view.coordsAtPos(resolvedFrom);
  const end = view.coordsAtPos(resolvedEnd, -1);
  const top = Math.min(start.top, end.top);
  const bottom = Math.max(start.bottom, end.bottom);
  const left = Math.min(start.left, end.left);
  const right = Math.max(start.right, end.right);
  const width = right - left;
  const height = bottom - top;
  const x2 = left;
  const y2 = top;
  const data = {
    top,
    bottom,
    left,
    right,
    width,
    height,
    x: x2,
    y: y2
  };
  return {
    ...data,
    toJSON: () => data
  };
}
const isInTable = (state2) => {
  const { $head } = state2.selection;
  for (let d2 = $head.depth; d2 > 0; d2 -= 1) {
    if ($head.node(d2).type?.spec?.tableRole === "row") {
      return true;
    }
  }
  return false;
};
function stripHtmlStyles(html, domDocument) {
  if (!html) return "";
  const win = domDocument?.defaultView ?? (typeof window !== "undefined" ? window : null);
  const DOMParserConstructor = win?.DOMParser ?? (typeof DOMParser !== "undefined" ? DOMParser : null);
  if (!DOMParserConstructor) {
    throw new Error(
      "[super-editor] HTML import requires a DOM. Provide { document } (e.g. from JSDOM), set DOM globals, or run in a browser environment."
    );
  }
  const parser = new DOMParserConstructor();
  const doc2 = parser.parseFromString(html, "text/html");
  const SUPPORTED_ATTRS = [
    "href",
    "src",
    "alt",
    "title",
    "colspan",
    "rowspan",
    "headers",
    "scope",
    "lang",
    "dir",
    "cite",
    "start",
    "type",
    "styleid"
  ];
  const cleanNode = (node) => {
    if (node.nodeType !== 1) return;
    if (node.nodeName.toLowerCase() === "span" && !node.children.length) {
      node.innerHTML = preserveSpaces(node.innerHTML);
    }
    [...node.attributes].forEach((attr) => {
      const name = attr.name.toLowerCase();
      if (name === "style") {
        const cleanedStyle = cleanStyle(attr.value);
        if (!cleanedStyle) {
          node.removeAttribute(attr.name);
        } else node.setAttribute(attr.name, cleanedStyle);
        return;
      }
      const shouldKeep = SUPPORTED_ATTRS.includes(name) || name.startsWith("data-");
      if (!shouldKeep) {
        node.removeAttribute(attr.name);
      }
    });
    [...node.children].forEach(cleanNode);
  };
  cleanNode(doc2.body);
  return doc2.body.innerHTML;
}
function cleanStyle(style) {
  if (!style) return "";
  const declarations = style.split(";").map((s) => s.trim()).filter(Boolean);
  const textAlign = declarations.find((d2) => d2.startsWith("text-align"));
  return textAlign ? `${textAlign};` : "";
}
function preserveSpaces(innerHtml) {
  return innerHtml.replace(/^\s+/, "&nbsp;").replace(/\s+$/, "&nbsp;");
}
const _CommandService = class _CommandService {
  /**
   * @param {import('./commands/types/index.js').CommandServiceOptions} props
   */
  constructor(props) {
    __privateAdd(this, _CommandService_instances);
    __publicField(this, "editor");
    __publicField(this, "rawCommands");
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionService.commands;
  }
  /**
   * Static method for creating a service.
   * @param {import('./commands/types/index.js').CommandServiceOptions} params for the constructor.
   * @returns {CommandService} New instance of CommandService
   */
  static create(params) {
    return new _CommandService(params);
  }
  /**
   * Get editor state.
   * @returns {import("prosemirror-state").EditorState} Editor state
   */
  get state() {
    return this.editor.state;
  }
  /**
   * Get all editor commands. Commands are executable methods that modify the editor state
   * via transactions. In headless mode (when view is unavailable), commands automatically
   * fall back to using editor.dispatch instead of view.dispatch.
   *
   * @returns {import('./commands/types/index.js').EditorCommands} Commands object containing all registered commands
   *
   * @example
   * // In mounted mode (with view)
   * editor.commands.insertText('hello'); // uses view.dispatch
   *
   * @example
   * // In headless mode (no view)
   * editor.commands.insertText('hello'); // falls back to editor.dispatch
   */
  get commands() {
    const { editor, state: state2 } = this;
    const { view } = editor;
    const { tr } = state2;
    const props = this.createProps(tr);
    const entries = Object.entries(this.rawCommands).map(([name, command]) => {
      const method = (...args) => {
        const fn = command(...args)(props);
        if (!tr.getMeta("preventDispatch")) {
          if (!__privateMethod(this, _CommandService_instances, dispatchWithFallback_fn).call(this, tr, { editor, view })) {
            return false;
          }
        }
        return fn;
      };
      return [name, method];
    });
    return (
      /** @type {import('./commands/types/index.js').EditorCommands} */
      Object.fromEntries(entries)
    );
  }
  /**
   * Create a chain of commands to call multiple commands at once.
   * @returns {(startTr?: Transaction, shouldDispatch?: boolean) => ChainableCommandObject} Function that creates a command chain
   */
  get chain() {
    return () => this.createChain();
  }
  /**
   * Check if a command or a chain of commands can be executed. Without executing it.
   * @returns {() => import('./commands/types/index.js').CanObject} Function that creates a can object
   */
  get can() {
    return () => this.createCan();
  }
  /**
   * Creates a chain of commands. Allows multiple commands to be executed in sequence
   * on the same transaction, with a single dispatch at the end. In headless mode,
   * the chain automatically falls back to using editor.dispatch instead of view.dispatch.
   *
   * @param {import("prosemirror-state").Transaction} [startTr] - Optional transaction to use as the starting point. If not provided, uses state.tr.
   * @param {boolean} [shouldDispatch=true] - Whether to dispatch the transaction when run() is called.
   * @returns {import('./commands/types/index.js').ChainableCommandObject} The command chain object with all commands and a run() method.
   *
   * @example
   * // Chain multiple commands in mounted mode
   * editor.chain()
   *   .insertText('hello')
   *   .selectAll()
   *   .run(); // dispatches once via view.dispatch
   *
   * @example
   * // Chain in headless mode
   * headlessEditor.chain()
   *   .insertText('hello')
   *   .run(); // falls back to editor.dispatch
   *
   * @example
   * // Chain without dispatching (for testing/validation)
   * const canExecute = editor.chain()
   *   .insertText('test')
   *   .run(); // returns boolean but doesn't dispatch
   */
  createChain(startTr, shouldDispatch = true) {
    const { editor, state: state2, rawCommands } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTr = !!startTr;
    const tr = startTr || state2.tr;
    const run2 = () => {
      if (!hasStartTr && shouldDispatch && !tr.getMeta("preventDispatch")) {
        if (!__privateMethod(this, _CommandService_instances, dispatchWithFallback_fn).call(this, tr, { editor, view })) {
          return false;
        }
      }
      return callbacks.every((cb) => cb === true);
    };
    const entries = Object.entries(rawCommands).map(([name, command]) => {
      const chainedCommand = (...args) => {
        const props = this.createProps(tr, shouldDispatch);
        const callback = command(...args)(props);
        callbacks.push(callback);
        return chain;
      };
      return [name, chainedCommand];
    });
    const chain = {
      ...Object.fromEntries(entries),
      run: run2
    };
    return chain;
  }
  /**
   * Creates a can check for commands.
   * @param {import("prosemirror-state").Transaction} [startTr] - Start transaction.
   * @returns {import('./commands/types/index.js').CanObject} The can object.
   */
  createCan(startTr) {
    const { rawCommands, state: state2 } = this;
    const dispatch = false;
    const tr = startTr || state2.tr;
    const props = this.createProps(tr, dispatch);
    const commands = Object.fromEntries(
      Object.entries(rawCommands).map(([name, command]) => {
        return [name, (...args) => command(...args)({ ...props, dispatch: void 0 })];
      })
    );
    const result = {
      ...commands,
      chain: () => this.createChain(tr, dispatch)
    };
    return (
      /** @type {import('./commands/types/index.js').CanObject} */
      result
    );
  }
  /**
   * Creates default props for the command method.
   * @param {import("prosemirror-state").Transaction} tr Transaction.
   * @param {boolean} shouldDispatch Check if should dispatch.
   * @returns {Object} Props object.
   */
  createProps(tr, shouldDispatch = true) {
    const { editor, state: state2, rawCommands } = this;
    const { view } = editor;
    const props = {
      tr,
      editor,
      view,
      state: chainableEditorState(tr, state2),
      // Commands check truthiness of `dispatch` to know if side effects are allowed.
      // Actual dispatching is handled by CommandService after command returns.
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr, shouldDispatch),
      can: () => this.createCan(tr),
      get commands() {
        return Object.fromEntries(
          Object.entries(rawCommands).map(([name, command]) => {
            return [name, (...args) => command(...args)(props)];
          })
        );
      }
    };
    return props;
  }
};
_CommandService_instances = new WeakSet();
/**
 * Private helper method to dispatch transactions with automatic fallback for headless mode.
 * Prefers view.dispatch when available (mounted editor), falls back to editor.dispatch
 * for headless mode. Includes validation checks and wraps errors with context.
 *
 * @param {import("prosemirror-state").Transaction} tr - The transaction to dispatch.
 * @param {Object} options - Dispatch options.
 * @param {Object} options.editor - The editor instance.
 * @param {Object} [options.view] - The editor view (may be null/undefined in headless mode).
 * @returns {boolean} True if dispatch succeeded, false if editor was destroyed or unavailable.
 *
 * @throws {Error} Throws wrapped error with context: `[CommandService] Dispatch failed: <original error message>`
 */
dispatchWithFallback_fn = function(tr, { editor, view }) {
  if (editor?.isDestroyed) {
    console.warn("[CommandService] Cannot dispatch: editor is destroyed");
    return false;
  }
  try {
    if (view && typeof view.dispatch === "function") {
      view.dispatch(tr);
    } else if (typeof editor?.dispatch === "function") {
      editor.dispatch(tr);
    } else {
      console.warn("[CommandService] No dispatch method available (editor may not be initialized)");
      return false;
    }
    return true;
  } catch (error) {
    const err = new Error(`[CommandService] Dispatch failed: ${error.message}`);
    err.cause = error;
    throw err;
  }
};
let CommandService = _CommandService;
function getHTMLFromFragment(fragment, schema, domDocument) {
  const resolvedDocument = domDocument ?? (typeof document !== "undefined" ? document : null);
  if (!resolvedDocument) {
    throw new Error(
      "[super-editor] getHTMLFromFragment() requires a DOM. Provide { document } (e.g. from JSDOM), set DOM globals, or run in a browser environment."
    );
  }
  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment, {
    document: resolvedDocument
  });
  const container = resolvedDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
const warnNoDOM = (feature = "This feature") => {
  console.warn(
    `[super-editor] ${feature} requires a DOM document. This environment has no DOM. Provide a DOM (e.g., JSDOM) and set globalThis.document or pass { document } to the editor.`
  );
};
const getTextContentFromNodes = ($from, maxMatch = 500) => {
  let textBefore = "";
  const sliceEndPos = $from.parentOffset;
  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index2) => {
    const chunk = node.type.spec.toText?.({
      node,
      pos,
      parent,
      index: index2
    }) || node.textContent || "%leaf%";
    textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));
  });
  return textBefore;
};
const handleDecimal = (path, lvlText) => generateNumbering(path, lvlText, numberToStringFormatter);
const handleRoman = (path, lvlText) => generateNumbering(path, lvlText, intToRoman);
const handleLowerRoman = (path, lvlText) => {
  const result = handleRoman(path, lvlText);
  return result ? result.toLowerCase() : null;
};
const handleAlpha = (path, lvlText) => generateNumbering(path, lvlText, intToAlpha);
const handleLowerAlpha = (path, lvlText) => {
  const result = handleAlpha(path, lvlText);
  return result ? result.toLowerCase() : null;
};
const handleOrdinal = (path, lvlText) => generateNumbering(path, lvlText, ordinalFormatter);
const handleCustom = (path, lvlText, customFormat) => generateFromCustom(path, lvlText, customFormat);
const handleJapaneseCounting = (path, lvlText) => generateNumbering(path, lvlText, intToJapaneseCounting);
const handleDecimalZero = (path, lvlText) => generateNumbering(path, lvlText, decimalZeroFormatter);
const listIndexMap = {
  decimal: handleDecimal,
  decimalZero: handleDecimalZero,
  lowerRoman: handleLowerRoman,
  upperRoman: handleRoman,
  lowerLetter: handleLowerAlpha,
  upperLetter: handleAlpha,
  ordinal: handleOrdinal,
  custom: handleCustom,
  japaneseCounting: handleJapaneseCounting
};
const generateOrderedListIndex = ({
  listLevel,
  lvlText,
  listNumberingType,
  customFormat
}) => {
  const handler2 = listIndexMap[listNumberingType];
  return handler2 ? handler2(listLevel, lvlText, customFormat) : null;
};
const createNumbering = (values, lvlText) => {
  return values.reduce((acc, value, index2) => {
    return Number(value) > 9 ? acc.replace(/^0/, "").replace(`%${index2 + 1}`, value) : acc.replace(`%${index2 + 1}`, value);
  }, lvlText);
};
const generateNumbering = (path, lvlText, formatter) => {
  const formattedValues = path.map((entry, idx) => formatter(entry, idx));
  return createNumbering(formattedValues, lvlText);
};
const ordinalFormatter = (value) => {
  const suffixes = ["th", "st", "nd", "rd"];
  const lastTwo = value % 100;
  const suffix = suffixes[(lastTwo - 20) % 10] || suffixes[lastTwo] || suffixes[0];
  return `${value}${suffix}`;
};
const decimalZeroFormatter = (value, idx) => {
  if (value >= 10 || idx === 0) return String(value);
  return `0${value}`;
};
const generateFromCustom = (path, lvlText, customFormat) => {
  if (customFormat.match(/(?:[0]+\d,\s){3}\.{3}/) == null) {
    return generateNumbering(path, lvlText, numberToStringFormatter);
  }
  const match = customFormat.match(/(\d+)/);
  if (!match) {
    throw new Error("Invalid format string: no numeric pattern found");
  }
  const digitCount = match[1].length;
  return generateNumbering(path, lvlText, (p) => String(p).padStart(digitCount, "0"));
};
const numberToStringFormatter = (value) => String(value);
const intToRoman = (num) => {
  const romanNumeralMap = [
    { value: 1e3, numeral: "M" },
    { value: 900, numeral: "CM" },
    { value: 500, numeral: "D" },
    { value: 400, numeral: "CD" },
    { value: 100, numeral: "C" },
    { value: 90, numeral: "XC" },
    { value: 50, numeral: "L" },
    { value: 40, numeral: "XL" },
    { value: 10, numeral: "X" },
    { value: 9, numeral: "IX" },
    { value: 5, numeral: "V" },
    { value: 4, numeral: "IV" },
    { value: 1, numeral: "I" }
  ];
  let result = "";
  let remaining = num;
  for (const { value, numeral } of romanNumeralMap) {
    while (remaining >= value) {
      result += numeral;
      remaining -= value;
    }
  }
  return result;
};
const intToAlpha = (num) => {
  let result = "";
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  let value = num;
  while (value > 0) {
    const index2 = (value - 1) % 26;
    result = alphabet[index2] + result;
    value = Math.floor((value - 1) / 26);
  }
  return result;
};
const intToJapaneseCounting = (num) => {
  const digits = ["", "", "", "", "", "", "", "", "", ""];
  const units = ["", "", "", ""];
  if (num === 0) return "";
  if (num < 10) return digits[num];
  let result = "";
  let tempNum = num;
  let unitIndex = 0;
  while (tempNum > 0) {
    const digit = tempNum % 10;
    if (digit !== 0) {
      const digitStr = digit === 1 && unitIndex > 0 ? "" : digits[digit];
      result = digitStr + (unitIndex > 0 ? units[unitIndex] : "") + result;
    } else if (result && tempNum > 0) {
      if (!result.startsWith("") && tempNum % 100 !== 0) {
        result = "" + result;
      }
    }
    tempNum = Math.floor(tempNum / 10);
    unitIndex += 1;
    if (unitIndex > 3) break;
  }
  if (num >= 10 && num < 20) {
    result = result.replace(/^/, "");
  }
  return result;
};
const normalizeChars = /* @__PURE__ */ new Set(["", "", "", "o", "", ""]);
const normalizeLvlTextChar = (lvlText) => {
  if (!lvlText || !normalizeChars.has(lvlText)) return lvlText;
  if (lvlText === "") return "";
  if (lvlText === "" || lvlText === "o") return "";
  if (lvlText === "" || lvlText === "") return "";
  if (lvlText === "") return "";
  return lvlText;
};
const docxNumberingCacheStore = /* @__PURE__ */ new WeakMap();
const NUMBERING_CACHE_KEY = "numbering-cache";
const LEVELS_MAP_KEY = Symbol("superdoc.numbering.levels");
const NUMBERING_CACHE_DOCX_KEY = Symbol("superdoc.numbering.docx");
const clearConverterCache = (converter) => {
  if (!converter) return;
  delete converter[NUMBERING_CACHE_KEY];
  delete converter[NUMBERING_CACHE_DOCX_KEY];
};
const setConverterCache = (converter, cache, docx) => {
  if (!converter) return;
  converter[NUMBERING_CACHE_KEY] = cache;
  if (docx && typeof docx === "object") {
    converter[NUMBERING_CACHE_DOCX_KEY] = docx;
  } else {
    delete converter[NUMBERING_CACHE_DOCX_KEY];
  }
};
const createEmptyCache = () => ({
  numToAbstractId: /* @__PURE__ */ new Map(),
  abstractById: /* @__PURE__ */ new Map(),
  templateById: /* @__PURE__ */ new Map(),
  numToDefinition: /* @__PURE__ */ new Map(),
  numNodesById: /* @__PURE__ */ new Map()
});
const ensureElementsArray = (docx) => {
  let numbering = docx?.["word/numbering.xml"];
  if (!numbering || !numbering.elements?.length || !numbering.elements[0].elements?.length) {
    numbering = baseNumbering;
  }
  return numbering?.elements?.[0]?.elements || [];
};
const buildNumberingCache = (docx) => {
  if (!docx || typeof docx !== "object") return createEmptyCache();
  const elements = ensureElementsArray(docx);
  if (!elements.length) return createEmptyCache();
  const numToAbstractId = /* @__PURE__ */ new Map();
  const abstractById = /* @__PURE__ */ new Map();
  const templateById = /* @__PURE__ */ new Map();
  const numToDefinition = /* @__PURE__ */ new Map();
  const numNodesById = /* @__PURE__ */ new Map();
  for (const element of elements) {
    if (element?.name === "w:abstractNum") {
      const abstractIdRaw = element.attributes?.["w:abstractNumId"];
      if (abstractIdRaw == null) continue;
      const abstractId = String(abstractIdRaw);
      abstractById.set(abstractId, element);
      const levelEntries = element.elements?.filter((child) => child.name === "w:lvl") || [];
      const levelsMap = /* @__PURE__ */ new Map();
      for (const lvl of levelEntries) {
        const rawLevel = lvl?.attributes?.["w:ilvl"];
        const parsedLevel = rawLevel == null ? 0 : Number(rawLevel);
        if (!Number.isNaN(parsedLevel) && !levelsMap.has(parsedLevel)) {
          levelsMap.set(parsedLevel, lvl);
        }
      }
      if (!Object.prototype.hasOwnProperty.call(element, LEVELS_MAP_KEY)) {
        Object.defineProperty(element, LEVELS_MAP_KEY, {
          value: levelsMap,
          enumerable: false,
          configurable: false,
          writable: false
        });
      }
      const templateTag = element.elements?.find((child) => child.name === "w:tmpl");
      const templateVal = templateTag?.attributes?.["w:val"];
      if (templateVal != null && levelsMap.size) {
        templateById.set(String(templateVal), element);
      }
    } else if (element?.name === "w:num") {
      const numIdRaw = element.attributes?.["w:numId"];
      if (numIdRaw == null) continue;
      const numId = String(numIdRaw);
      numNodesById.set(numId, element);
      const abstractRef = element.elements?.find((child) => child.name === "w:abstractNumId");
      const abstractVal = abstractRef?.attributes?.["w:val"];
      if (abstractVal != null) {
        numToAbstractId.set(numId, String(abstractVal));
      }
    }
  }
  for (const [numId, abstractId] of numToAbstractId.entries()) {
    const abstract = abstractById.get(abstractId);
    if (abstract) {
      numToDefinition.set(numId, abstract);
    }
  }
  return { numToAbstractId, abstractById, templateById, numToDefinition, numNodesById };
};
const ensureNumberingCache = (docx, converter) => {
  if (converter?.[NUMBERING_CACHE_KEY]) {
    const cachedDocx = converter[NUMBERING_CACHE_DOCX_KEY];
    if (docx && cachedDocx && cachedDocx !== docx) {
      clearConverterCache(converter);
    } else {
      return converter[NUMBERING_CACHE_KEY];
    }
  }
  if (!docx || typeof docx !== "object") return createEmptyCache();
  const existingCache = docxNumberingCacheStore.get(docx);
  if (existingCache) {
    setConverterCache(converter, existingCache, docx);
    return existingCache;
  }
  const cache = buildNumberingCache(docx);
  if (converter) {
    setConverterCache(converter, cache, docx);
  } else {
    docxNumberingCacheStore.set(docx, cache);
  }
  return cache;
};
const getNumIdFromTag = (tag) => {
  return tag?.elements?.find((el) => el.name === "w:numId")?.attributes["w:val"];
};
function getStyleTagFromStyleId(styleId, docx) {
  const styles = docx["word/styles.xml"];
  if (!styles) return {};
  const styleEls = styles.elements;
  const wStyles = styleEls.find((el) => el.name === "w:styles");
  const styleTags = wStyles.elements.filter((style) => style.name === "w:style");
  const styleDef = styleTags.find((tag) => tag.attributes["w:styleId"] === styleId);
  return styleDef;
}
const getListNumIdFromStyleRef = (styleId, docx) => {
  const styles = docx["word/styles.xml"];
  if (!styles) return null;
  const { elements } = styles;
  const styleTags = elements[0].elements.filter((style2) => style2.name === "w:style");
  const style = styleTags.find((tag) => tag.attributes["w:styleId"] === styleId) || {};
  const pPr = style?.elements?.find((style2) => style2.name === "w:pPr");
  if (!pPr) return null;
  let numPr = pPr?.elements?.find((style2) => style2.name === "w:numPr");
  if (!numPr) return null;
  let numIdTag = numPr?.elements?.find((style2) => style2.name === "w:numId") || {};
  let numId = getNumIdFromTag(numPr);
  let ilvlTag = numPr?.elements?.find((style2) => style2.name === "w:ilvl");
  let ilvl = ilvlTag?.attributes?.["w:val"];
  const basedOnTag = style?.elements?.find((style2) => style2.name === "w:basedOn");
  const basedOnId = basedOnTag?.attributes?.["w:val"];
  let loopCount = 0;
  while (numPr && !numId && loopCount < 10) {
    const basedOnStyle = styleTags.find((tag) => tag.attributes["w:styleId"] === basedOnId) || {};
    const basedOnPPr = basedOnStyle?.elements?.find((style2) => style2.name === "w:pPr");
    numPr = basedOnPPr?.elements?.find((style2) => style2.name === "w:numPr");
    numIdTag = numPr?.elements?.find((style2) => style2.name === "w:numId") || {};
    numId = numIdTag?.attributes?.["w:val"];
    if (!ilvlTag) {
      ilvlTag = numPr?.elements?.find((style2) => style2.name === "w:ilvl");
      ilvl = ilvlTag?.attributes?.["w:val"];
    }
    loopCount++;
  }
  return { numId, ilvl };
};
const getAbstractDefinition = (numId, docx, converter) => {
  const numberingXml = docx["word/numbering.xml"];
  if (!numberingXml) return {};
  if (numId == null) return void 0;
  const cache = ensureNumberingCache(docx, converter);
  const numKey = String(numId);
  let listDefinitionForThisNumId = cache.numToDefinition.get(numKey);
  if (!listDefinitionForThisNumId) {
    const abstractNumId = cache.numToAbstractId.get(numKey);
    if (abstractNumId) {
      listDefinitionForThisNumId = cache.abstractById.get(abstractNumId);
      if (listDefinitionForThisNumId) {
        cache.numToDefinition.set(numKey, listDefinitionForThisNumId);
      }
    }
  }
  const levelMap = listDefinitionForThisNumId ? listDefinitionForThisNumId[LEVELS_MAP_KEY] : null;
  const hasLevels = levelMap && levelMap.size > 0;
  if (!listDefinitionForThisNumId || !hasLevels) {
    const templateIdTag = listDefinitionForThisNumId?.elements?.find((el) => el.name === "w:tmpl");
    const templateId = templateIdTag?.attributes?.["w:val"];
    if (templateId) {
      const byTemplate = cache.templateById.get(String(templateId));
      if (byTemplate) listDefinitionForThisNumId = byTemplate;
    }
  }
  return listDefinitionForThisNumId;
};
const generateListPath$1 = (level, numId, styleId, levels, docx) => {
  const iLvl = Number(level);
  const path = [];
  if (iLvl > 0) {
    for (let i = iLvl; i >= 0; i--) {
      const { start: lvlStart } = getListLevelDefinitionTag(numId, i, styleId, docx);
      if (!levels[i]) levels[i] = Number(lvlStart) || 1;
      path.unshift(levels[i]);
    }
  }
  return path;
};
const getListLevelDefinitionTag = (numId, level, pStyleId, docx) => {
  if (pStyleId) {
    const { numId: numIdFromStyles, ilvl: iLvlFromStyles } = getListNumIdFromStyleRef(pStyleId, docx) || {};
    if (!numId && numIdFromStyles) numId = numIdFromStyles;
    if (!level && iLvlFromStyles) level = iLvlFromStyles ? parseInt(iLvlFromStyles) : null;
  }
  const listDefinitionForThisNumId = getAbstractDefinition(numId, docx);
  const currentLevel = getDefinitionForLevel(listDefinitionForThisNumId, level);
  const numStyleLink = listDefinitionForThisNumId?.elements?.find((style) => style.name === "w:numStyleLink");
  const numStyleLinkId = numStyleLink?.attributes["w:val"];
  if (numStyleLinkId) {
    const current = getListNumIdFromStyleRef(numStyleLinkId, docx);
    return getListLevelDefinitionTag(current.numId, level, null, docx);
  }
  const start = currentLevel?.elements?.find((style) => style.name === "w:start")?.attributes["w:val"];
  let numFmtTag = currentLevel?.elements?.find((style) => style.name === "w:numFmt");
  let numFmt = numFmtTag?.attributes["w:val"];
  if (!numFmt) {
    const altChoice = currentLevel?.elements.find((style) => style.name === "mc:AlternateContent");
    const choice = altChoice?.elements.find((style) => style.name === "mc:Choice");
    const choiceNumFmtTag = choice?.elements.find((style) => style.name === "w:numFmt");
    const choiceNumFmt = choiceNumFmtTag?.attributes["w:val"];
    if (choiceNumFmt) {
      numFmtTag = choiceNumFmtTag;
      numFmt = choiceNumFmt;
    }
  }
  let lvlText = currentLevel?.elements?.find((style) => style.name === "w:lvlText").attributes["w:val"];
  lvlText = normalizeLvlTextChar(lvlText);
  let customFormat;
  if (numFmt === "custom") customFormat = numFmtTag?.attributes?.["w:format"];
  const lvlJc = currentLevel?.elements?.find((style) => style.name === "w:lvlJc").attributes["w:val"];
  const pPr = currentLevel?.elements?.find((style) => style.name === "w:pPr");
  const rPr = currentLevel?.elements?.find((style) => style.name === "w:rPr");
  return { start, numFmt, lvlText, lvlJc, pPr, rPr, customFormat };
};
function getDefinitionForLevel(data, level) {
  if (!data) return void 0;
  const parsedLevel = Number(level);
  if (Number.isNaN(parsedLevel)) return void 0;
  const cachedLevels = data[LEVELS_MAP_KEY];
  if (cachedLevels?.has(parsedLevel)) {
    return cachedLevels.get(parsedLevel);
  }
  return data?.elements?.find((item) => Number(item.attributes?.["w:ilvl"]) === parsedLevel);
}
const docxNumberingHelpers = {
  generateListPath: generateListPath$1,
  normalizeLvlTextChar
};
const baseOrderedListDef = {
  type: "element",
  name: "w:abstractNum",
  attributes: {
    "w:abstractNumId": "1",
    "w15:restartNumberingAfterBreak": "0"
  },
  elements: [
    {
      type: "element",
      name: "w:multiLevelType",
      attributes: {
        "w:val": "hybridMultilevel"
      }
    },
    {
      type: "element",
      name: "w:tmpl",
      attributes: {
        "w:val": "EE6417C4"
      }
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "0",
        "w:tplc": "0409000F"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "decimal"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%1."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "720",
                "w:hanging": "360"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "1",
        "w:tplc": "04090019",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "lowerLetter"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%2."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "1440",
                "w:hanging": "360"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "2",
        "w:tplc": "0409001B",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "lowerRoman"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%3."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "right"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "2160",
                "w:hanging": "180"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "3",
        "w:tplc": "0409000F",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "decimal"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%4."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "2880",
                "w:hanging": "360"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "4",
        "w:tplc": "04090019",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "lowerLetter"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%5."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "3600",
                "w:hanging": "360"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "5",
        "w:tplc": "0409001B",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "lowerRoman"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%6."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "right"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "4320",
                "w:hanging": "180"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "6",
        "w:tplc": "0409000F",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "decimal"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%7."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "5040",
                "w:hanging": "360"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "7",
        "w:tplc": "04090019",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "lowerLetter"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%8."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "5760",
                "w:hanging": "360"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "8",
        "w:tplc": "0409001B",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "lowerRoman"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%9."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "right"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "6480",
                "w:hanging": "180"
              }
            }
          ]
        }
      ]
    }
  ]
};
const baseBulletList = {
  type: "element",
  name: "w:abstractNum",
  attributes: {
    "w:abstractNumId": "0",
    "w15:restartNumberingAfterBreak": "0"
  },
  elements: [
    {
      type: "element",
      name: "w:nsid",
      attributes: {
        "w:val": "16126B07"
      }
    },
    {
      type: "element",
      name: "w:multiLevelType",
      attributes: {
        "w:val": "hybridMultilevel"
      }
    },
    {
      type: "element",
      name: "w:tmpl",
      attributes: {
        "w:val": "51EC4E08"
      }
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "0",
        "w:tplc": "04090001"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": ""
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "720",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Symbol",
                "w:hAnsi": "Symbol",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "1",
        "w:tplc": "04090003",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": ""
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "1440",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Courier New",
                "w:hAnsi": "Courier New",
                "w:cs": "Courier New",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "2",
        "w:tplc": "04090005",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": ""
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "2160",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Wingdings",
                "w:hAnsi": "Wingdings",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "3",
        "w:tplc": "04090001",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": ""
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "2880",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Symbol",
                "w:hAnsi": "Symbol",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "4",
        "w:tplc": "04090003",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": ""
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "3600",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Courier New",
                "w:hAnsi": "Courier New",
                "w:cs": "Courier New",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "5",
        "w:tplc": "04090005",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": ""
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "4320",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Wingdings",
                "w:hAnsi": "Wingdings",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "6",
        "w:tplc": "04090001",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": ""
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "5040",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Symbol",
                "w:hAnsi": "Symbol",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "7",
        "w:tplc": "04090003",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "o"
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "5760",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Courier New",
                "w:hAnsi": "Courier New",
                "w:cs": "Courier New",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "8",
        "w:tplc": "04090005",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": ""
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "6480",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Wingdings",
                "w:hAnsi": "Wingdings",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    }
  ]
};
const resolvedParagraphPropertiesCache = /* @__PURE__ */ new WeakMap();
function getResolvedParagraphProperties(node) {
  return resolvedParagraphPropertiesCache.get(node);
}
function calculateResolvedParagraphProperties(editor, node, $pos) {
  if (!editor.converter) {
    return node.attrs.paragraphProperties || {};
  }
  const cached = getResolvedParagraphProperties(node);
  if (cached) {
    return cached;
  }
  const tableNode = findParentNodeClosestToPos($pos, (node2) => node2.type.name === "table");
  const tableStyleId = tableNode?.node.attrs.tableStyleId || null;
  const paragraphProperties = resolveParagraphProperties(
    {
      translatedNumbering: editor.converter.translatedNumbering,
      translatedLinkedStyles: editor.converter.translatedLinkedStyles
    },
    node.attrs.paragraphProperties || {},
    tableStyleId
  );
  resolvedParagraphPropertiesCache.set(node, paragraphProperties);
  return paragraphProperties;
}
const isList = (node) => !!node && node.type?.name === "paragraph" && getResolvedParagraphProperties(node)?.numberingProperties && node.attrs?.listRendering;
const changeListLevel = (delta, editor, tr) => {
  const { state: state2 } = editor;
  const { selection, doc: stateDoc } = state2;
  const listItemsInSelection = [];
  const seenPositions = /* @__PURE__ */ new Set();
  const doc2 = stateDoc ?? selection?.$from?.node?.(0);
  const collectListItem = (node, pos) => {
    if (isList(node) && !seenPositions.has(pos)) {
      listItemsInSelection.push({ node, pos });
      seenPositions.add(pos);
    }
  };
  const addEdgeNode = ($pos) => {
    if (!$pos) return;
    const parentNode = $pos.parent;
    if (parentNode.type.name !== "paragraph") return;
    const pos = typeof $pos.before === "function" ? $pos.before() : null;
    if (!parentNode || pos == null) return;
    collectListItem(parentNode, pos);
  };
  const ranges = selection?.ranges?.length && Array.isArray(selection.ranges) ? selection.ranges : selection?.$from && selection?.$to ? [{ $from: selection.$from, $to: selection.$to }] : [];
  for (const range2 of ranges) {
    if (!range2?.$from || !range2?.$to) continue;
    if (doc2?.nodesBetween) {
      doc2.nodesBetween(range2.$from.pos, range2.$to.pos, (node, pos) => collectListItem(node, pos));
    }
    addEdgeNode(range2.$from);
    addEdgeNode(range2.$to);
  }
  if (!listItemsInSelection.length && selection) {
    const currentItem = findParentNode(isList)(selection);
    if (!currentItem) return false;
    listItemsInSelection.push({ node: currentItem.node, pos: currentItem.pos });
  }
  const targets = [];
  let encounteredNegativeLevel = false;
  for (const item of listItemsInSelection) {
    const numberingProperties = getResolvedParagraphProperties(item.node)?.numberingProperties;
    if (!numberingProperties) continue;
    const currentLevel = Number.parseInt(numberingProperties.ilvl ?? 0, 10);
    const normalizedLevel = Number.isNaN(currentLevel) ? 0 : currentLevel;
    const newLevel = normalizedLevel + delta;
    if (newLevel < 0) {
      encounteredNegativeLevel = true;
      continue;
    }
    if (!ListHelpers.hasListDefinition(editor, numberingProperties.numId, newLevel)) {
      return false;
    }
    targets.push({
      node: item.node,
      pos: item.pos,
      numberingProperties: {
        ...numberingProperties,
        ilvl: newLevel
      }
    });
  }
  if (!targets.length) {
    return encounteredNegativeLevel ? true : false;
  }
  targets.sort((a, b2) => a.pos - b2.pos).forEach(({ numberingProperties, node, pos }) => {
    updateNumberingProperties(numberingProperties, node, pos, editor, tr);
  });
  return true;
};
function updateNumberingProperties(newNumberingProperties, paragraphNode, pos, editor, tr) {
  const newProperties = {
    ...paragraphNode.attrs.paragraphProperties || {},
    numberingProperties: newNumberingProperties ? { ...newNumberingProperties } : null
  };
  if (paragraphNode.attrs.paragraphProperties?.styleId === "ListParagraph") {
    newProperties.styleId = null;
  }
  if (newProperties.indent) {
    delete newProperties.indent;
  }
  const newAttrs = {
    ...paragraphNode.attrs,
    paragraphProperties: newProperties,
    numberingProperties: newProperties.numberingProperties
  };
  if (!newNumberingProperties) {
    newAttrs.listRendering = null;
  }
  tr.setNodeMarkup(pos, null, newAttrs);
}
const translator$1c = NodeTranslator.from(createSingleIntegerPropertyHandler("w:nsid"));
const translator$1b = NodeTranslator.from(createSingleIntegerPropertyHandler("w:tmpl"));
const translator$1a = NodeTranslator.from(createSingleAttrPropertyHandler("w:name"));
const translator$19 = NodeTranslator.from(createSingleAttrPropertyHandler("w:styleLink"));
const translator$18 = NodeTranslator.from(createSingleAttrPropertyHandler("w:numStyleLink"));
const translator$17 = NodeTranslator.from(createSingleAttrPropertyHandler("w:multiLevelType"));
const translator$16 = NodeTranslator.from(createSingleIntegerPropertyHandler("w:lvlPicBulletId"));
const translator$15 = NodeTranslator.from(createSingleBooleanPropertyHandler("w:isLgl"));
const translator$14 = NodeTranslator.from(createSingleAttrPropertyHandler("w:suff"));
const translator$13 = NodeTranslator.from(createSingleAttrPropertyHandler("w:lvlText"));
const translator$12 = NodeTranslator.from(createSingleAttrPropertyHandler("w:lvlJc"));
const translator$11 = NodeTranslator.from({
  xmlName: "w:numFmt",
  sdNodeOrKeyName: "numFmt",
  attributes: [createAttributeHandler("w:val"), createAttributeHandler("w:format")],
  encode: (_2, encodedAttrs) => {
    return encodedAttrs;
  },
  decode: function({ node }) {
    const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs["numFmt"] || {} } });
    return Object.keys(decodedAttrs).length > 0 ? { attributes: decodedAttrs } : void 0;
  }
});
const translator$10 = NodeTranslator.from({
  xmlName: "w:legacy",
  sdNodeOrKeyName: "legacy",
  attributes: [
    createBooleanAttributeHandler("w:legacy"),
    createIntegerAttributeHandler("w:legacySpace"),
    createIntegerAttributeHandler("w:legacyIndent")
  ],
  encode: (_2, encodedAttrs) => {
    return encodedAttrs;
  },
  decode: function({ node }) {
    const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs["legacy"] || {} } });
    return Object.keys(decodedAttrs).length > 0 ? { attributes: decodedAttrs } : void 0;
  }
});
const propertyTranslators$7 = [
  translator$1B,
  translator$16,
  translator$15,
  translator$1$,
  translator$14,
  translator$13,
  translator$12,
  translator$11,
  translator$10,
  translator$1O,
  translator$2w
];
const attributeHandlers$3 = [
  createIntegerAttributeHandler("w:ilvl"),
  createIntegerAttributeHandler("w:tplc"),
  createBooleanAttributeHandler("w:tentative")
];
const translator$$ = NodeTranslator.from(
  createNestedPropertiesTranslator("w:lvl", "lvl", propertyTranslators$7, {}, attributeHandlers$3)
);
const propertyTranslators$6 = [
  translator$1c,
  translator$1b,
  translator$1a,
  translator$19,
  translator$18,
  translator$17
];
const propertyTranslatorsByXmlName$2 = {};
const propertyTranslatorsBySdName$2 = {};
propertyTranslators$6.forEach((translator2) => {
  propertyTranslatorsByXmlName$2[translator2.xmlName] = translator2;
  propertyTranslatorsBySdName$2[translator2.sdNodeOrKeyName] = translator2;
});
const translator$_ = NodeTranslator.from({
  xmlName: "w:abstractNum",
  sdNodeOrKeyName: "abstractNum",
  type: NodeTranslator.translatorTypes.NODE,
  attributes: [createIntegerAttributeHandler("w:abstractNumId")],
  encode: (params, encodedAttrs) => {
    const { nodes } = params;
    const node = nodes[0];
    const result = {
      ...encodedAttrs,
      ...encodeProperties(params, propertyTranslatorsByXmlName$2),
      ...encodePropertiesByKey("w:lvl", "levels", translator$$, params, node, "ilvl")
    };
    return result;
  },
  decode: function(params) {
    const currentValue = params.node.attrs?.["abstractNum"];
    if (!currentValue) {
      return void 0;
    }
    const decodedAttrs = this.decodeAttributes({ node: { ...params.node, attrs: currentValue } });
    const elements = [
      ...decodeProperties(params, propertyTranslatorsBySdName$2, currentValue),
      ...decodePropertiesByKey("w:lvl", "levels", translator$$, params, currentValue)
    ];
    const newNode = {
      name: "w:abstractNum",
      type: "element",
      attributes: decodedAttrs,
      elements
    };
    return newNode;
  }
});
const translator$Z = NodeTranslator.from(createSingleIntegerPropertyHandler("w:abstractNumId"));
const translator$Y = NodeTranslator.from(createSingleIntegerPropertyHandler("w:startOverride"));
const propertyTranslators$5 = [translator$Y, translator$$];
const attributeHandlers$2 = [createIntegerAttributeHandler("w:ilvl")];
const translator$X = NodeTranslator.from(
  createNestedPropertiesTranslator("w:lvlOverride", "lvlOverride", propertyTranslators$5, {}, attributeHandlers$2)
);
const translator$W = NodeTranslator.from({
  xmlName: "w:num",
  sdNodeOrKeyName: "num",
  type: NodeTranslator.translatorTypes.NODE,
  attributes: [createIntegerAttributeHandler("w:numId")],
  encode: (params, encodedAttrs) => {
    const { nodes } = params;
    const node = nodes[0];
    const result = {
      ...encodedAttrs,
      ...encodeProperties(params, {
        "w:abstractNumId": translator$Z
      }),
      ...encodePropertiesByKey("w:lvlOverride", "lvlOverrides", translator$X, params, node, "ilvl")
    };
    return result;
  },
  decode: function(params) {
    const currentValue = params.node.attrs?.["num"];
    if (!currentValue) {
      return void 0;
    }
    const decodedAttrs = this.decodeAttributes({ node: { ...params.node, attrs: currentValue } });
    const elements = [
      ...decodeProperties(
        params,
        {
          abstractNumId: translator$Z
        },
        currentValue
      ),
      ...decodePropertiesByKey("w:lvlOverride", "lvlOverrides", translator$X, params, currentValue)
    ];
    const newNode = {
      name: "w:num",
      type: "element",
      attributes: decodedAttrs,
      elements
    };
    return newNode;
  }
});
const generateNewListDefinition = ({ numId, listType, level, start, text, fmt, editor, markerFontFamily }) => {
  if (typeof listType !== "string") listType = listType.name;
  const definition = listType === "orderedList" ? baseOrderedListDef : baseBulletList;
  const numbering = editor.converter.numbering;
  const newNumbering = { ...numbering };
  let skipAddingNewAbstract = false;
  let newAbstractId = getNewListId(editor, "abstracts");
  let newAbstractDef = JSON.parse(
    JSON.stringify({
      ...definition,
      attributes: {
        ...definition.attributes,
        "w:abstractNumId": String(newAbstractId)
      }
    })
  );
  if (level && start && text && fmt) {
    if (newNumbering.definitions[numId]) {
      const abstractId = newNumbering.definitions[numId]?.elements[0]?.attributes["w:val"];
      newAbstractId = abstractId;
      const abstract = editor.converter.numbering.abstracts[abstractId];
      newAbstractDef = { ...abstract };
      skipAddingNewAbstract = true;
    }
    const levelDefIndex = newAbstractDef.elements.findIndex(
      (el) => el.name === "w:lvl" && el.attributes["w:ilvl"] === level
    );
    const levelProps = newAbstractDef.elements[levelDefIndex];
    const elToFilter = ["w:numFmt", "w:lvlText", "w:start"];
    const oldElements = levelProps.elements.filter((el) => !elToFilter.includes(el.name));
    levelProps.elements = [
      ...oldElements,
      {
        type: "element",
        name: "w:start",
        attributes: {
          "w:val": start
        }
      },
      {
        type: "element",
        name: "w:numFmt",
        attributes: {
          "w:val": fmt
        }
      },
      {
        type: "element",
        name: "w:lvlText",
        attributes: {
          "w:val": text
        }
      }
    ];
    if (markerFontFamily) {
      const rPrIndex = levelProps.elements.findIndex((el) => el.name === "w:rPr");
      let rPr = levelProps.elements[rPrIndex];
      if (!rPr) {
        rPr = {
          type: "element",
          name: "w:rPr",
          elements: []
        };
        levelProps.elements.push(rPr);
      }
      rPr.elements = rPr.elements.filter((el) => el.name !== "w:rFonts");
      rPr.elements.push({
        type: "element",
        name: "w:rFonts",
        attributes: {
          "w:ascii": markerFontFamily,
          "w:hAnsi": markerFontFamily,
          "w:eastAsia": markerFontFamily,
          "w:cs": markerFontFamily
        }
      });
    }
  }
  if (!skipAddingNewAbstract) newNumbering.abstracts[newAbstractId] = newAbstractDef;
  const newNumDef = getBasicNumIdTag(numId, newAbstractId);
  newNumbering.definitions[numId] = newNumDef;
  const newTranslatedNumbering = { ...editor.converter.translatedNumbering };
  if (!newTranslatedNumbering.definitions) newTranslatedNumbering.definitions = {};
  if (!newTranslatedNumbering.abstracts) newTranslatedNumbering.abstracts = {};
  newTranslatedNumbering.definitions[numId] = translator$W.encode({
    nodes: [newNumDef]
  });
  newTranslatedNumbering.abstracts[newAbstractId] = translator$_.encode({
    nodes: [newAbstractDef]
  });
  editor.converter.translatedNumbering = newTranslatedNumbering;
  editor.converter.numbering = newNumbering;
  const change = { numDef: newNumDef, abstractDef: newAbstractDef, editor };
  editor.emit("list-definitions-change", { change, numbering: newNumbering, editor });
  return { abstract: newAbstractDef, definition: newNumDef };
};
const hasListDefinition = (editor, numId, ilvl) => {
  const { definitions, abstracts } = editor.converter.numbering;
  const numDef = definitions[numId];
  if (!numDef) return false;
  const abstractId = numDef.elements?.find((item) => item.name === "w:abstractNumId")?.attributes?.["w:val"];
  const abstract = abstracts[abstractId];
  if (!abstract) return false;
  const levelDef = abstract.elements?.find((item) => item.name === "w:lvl" && item.attributes?.["w:ilvl"] == ilvl);
  return !!levelDef;
};
const changeNumIdSameAbstract = (numId, level, listType, editor) => {
  const newId = getNewListId(editor, "definitions");
  const { abstract } = ListHelpers.getListDefinitionDetails({ numId, level, listType, editor });
  const numbering = editor.converter.numbering;
  const newNumbering = { ...numbering };
  if (!abstract) {
    ListHelpers.generateNewListDefinition({ numId: newId, listType, editor });
    return newId;
  }
  const newAbstractId = getNewListId(editor, "abstracts");
  const newAbstractDef = {
    ...abstract,
    attributes: {
      ...abstract.attributes || {},
      "w:abstractNumId": String(newAbstractId)
    }
  };
  newNumbering.abstracts[newAbstractId] = newAbstractDef;
  const newNumDef = getBasicNumIdTag(newId, newAbstractId);
  newNumbering.definitions[newId] = newNumDef;
  editor.converter.numbering = newNumbering;
  return newId;
};
const getBasicNumIdTag = (numId, abstractId) => {
  return {
    type: "element",
    name: "w:num",
    attributes: {
      "w:numId": String(numId)
    },
    elements: [{ name: "w:abstractNumId", attributes: { "w:val": String(abstractId) } }]
  };
};
const getNewListId = (editor, grouping = "definitions") => {
  const defs = editor.converter?.numbering?.[grouping] || {};
  const intKeys = Object.keys(defs).map((k2) => Number(k2)).filter((n) => Number.isInteger(n));
  const max2 = intKeys.length ? Math.max(...intKeys) : 0;
  return max2 + 1;
};
const getListDefinitionDetails = ({ numId, level, listType, editor, tries = 0 }) => {
  const { definitions, abstracts } = editor.converter.numbering;
  if (!numId) return {};
  const numDef = definitions[numId];
  if (!numDef && listType) {
    ListHelpers.generateNewListDefinition({ numId, listType, editor });
  }
  const abstractId = definitions[numId]?.elements?.find((item) => item.name === "w:abstractNumId")?.attributes?.["w:val"];
  const abstract = abstracts[abstractId];
  if (!abstract) {
    return {
      start: null,
      numFmt: null,
      lvlText: null,
      listNumberingType: null,
      suffix: null,
      justification: null,
      customFormat: null,
      abstract: null,
      abstractId
    };
  }
  const numStyleLink = abstract.elements?.find((item) => item.name === "w:numStyleLink");
  const styleId = numStyleLink?.attributes?.["w:val"];
  if (styleId && tries < 1) {
    const styleDefinition = getStyleTagFromStyleId(styleId, editor.converter.convertedXml);
    const linkedNumId = styleDefinition?.elements?.find((el) => el.name === "w:pPr")?.elements?.find((el) => el.name === "w:numPr")?.elements?.find((el) => el.name === "w:numId")?.attributes?.["w:val"];
    if (linkedNumId) {
      return getListDefinitionDetails({
        numId: Number(linkedNumId),
        level,
        listType,
        editor,
        tries: tries + 1
      });
    }
  }
  const listDefinition = abstract.elements?.find(
    (item) => item.name === "w:lvl" && item.attributes?.["w:ilvl"] == level
  );
  if (!listDefinition) {
    return {
      start: null,
      numFmt: null,
      lvlText: null,
      suffix: null,
      justification: null,
      listNumberingType: null,
      customFormat: null,
      abstract,
      abstractId
    };
  }
  const findElement = (name) => listDefinition.elements?.find((item) => item.name === name);
  const startElement = findElement("w:start");
  let numFmtElement = findElement("w:numFmt");
  if (!numFmtElement) {
    const mcAlternate = listDefinition.elements?.find((item) => item.name === "mc:AlternateContent");
    const choice = mcAlternate?.elements?.find((el) => el.name === "mc:Choice");
    numFmtElement = choice?.elements?.find((item) => item.name === "w:numFmt");
  }
  const lvlTextElement = findElement("w:lvlText");
  const suffixElement = findElement("w:suff");
  const lvlJcElement = findElement("w:lvlJc");
  const start = startElement?.attributes?.["w:val"];
  const numFmt = numFmtElement?.attributes?.["w:val"];
  const lvlText = lvlTextElement?.attributes?.["w:val"];
  const suffix = suffixElement?.attributes?.["w:val"];
  const justification = lvlJcElement?.attributes?.["w:val"];
  const listNumberingType = numFmt;
  const customFormat = numFmt === "custom" ? numFmtElement?.attributes?.["w:format"] : void 0;
  return {
    start,
    numFmt,
    lvlText,
    suffix,
    justification,
    listNumberingType,
    customFormat,
    abstract,
    abstractId
  };
};
const getAllListDefinitions = (editor) => {
  const numbering = editor?.converter?.numbering;
  if (!numbering) return {};
  const { definitions = {}, abstracts = {} } = numbering;
  return Object.entries(definitions).reduce((acc, [numId, definition]) => {
    if (!definition) return acc;
    const abstractId = definition.elements?.find((item) => item.name === "w:abstractNumId")?.attributes?.["w:val"];
    const abstract = abstractId != null ? abstracts?.[abstractId] : void 0;
    const levelDefinitions = abstract?.elements?.filter((item) => item.name === "w:lvl") || [];
    if (!acc[numId]) acc[numId] = {};
    levelDefinitions.forEach((levelDef) => {
      const ilvl = levelDef?.attributes?.["w:ilvl"];
      if (ilvl == null) return;
      const findElement = (name) => levelDef?.elements?.find((item) => item.name === name);
      const startElement = findElement("w:start");
      const lvlRestartElement = findElement("w:lvlRestart");
      const numFmtElement = findElement("w:numFmt");
      const lvlTextElement = findElement("w:lvlText");
      const suffixElement = findElement("w:suff");
      const numFmt = numFmtElement?.attributes?.["w:val"] ?? null;
      const customFormat = numFmt === "custom" ? numFmtElement?.attributes?.["w:format"] ?? null : null;
      acc[numId][ilvl] = {
        start: startElement?.attributes?.["w:val"] ?? null,
        restart: lvlRestartElement?.attributes?.["w:val"] ?? null,
        numFmt,
        lvlText: lvlTextElement?.attributes?.["w:val"] ?? null,
        suffix: suffixElement?.attributes?.["w:val"] ?? null,
        listNumberingType: numFmt,
        customFormat,
        abstract: abstract ?? null,
        abstractId
      };
    });
    return acc;
  }, {});
};
const removeListDefinitions = (listId, editor) => {
  const { numbering } = editor.converter;
  if (!numbering) return;
  const { definitions, abstracts } = numbering;
  const abstractId = definitions[listId].elements[0].attributes["w:val"];
  delete definitions[listId];
  delete abstracts[abstractId];
  editor.converter.numbering = {
    definitions,
    abstracts
  };
};
const createListItemNodeJSON = ({ level, numId, contentNode }) => {
  if (!Array.isArray(contentNode)) contentNode = [contentNode];
  const numberingProperties = {
    numId: Number(numId),
    ilvl: Number(level)
  };
  const attrs = {
    paragraphProperties: {
      numberingProperties
    },
    numberingProperties
  };
  const listItem = {
    type: "paragraph",
    attrs,
    content: [...contentNode || []]
  };
  return listItem;
};
const createSchemaOrderedListNode = ({ level, numId, editor, contentNode }) => {
  level = Number(level);
  numId = Number(numId);
  const listNodeJSON = createListItemNodeJSON({ level, numId, contentNode });
  return editor.schema.nodeFromJSON(listNodeJSON);
};
const createNewList = ({ listType, tr, editor }) => {
  const numId = ListHelpers.getNewListId(editor);
  ListHelpers.generateNewListDefinition({ numId, listType, editor });
  const paragraphInfo = findParentNode((node) => node?.type?.name === "paragraph")(tr.selection);
  if (!paragraphInfo) return false;
  const { node: paragraph, pos: paragraphPos = 0 } = paragraphInfo;
  updateNumberingProperties(
    {
      numId,
      ilvl: 0
    },
    paragraph,
    paragraphPos,
    editor,
    tr
  );
  return true;
};
const replaceListWithNode = ({ tr, from, to, newNode }) => {
  tr.replaceWith(from, to, newNode);
};
const ListHelpers = {
  replaceListWithNode,
  // DOCX helpers
  getListDefinitionDetails,
  getAllListDefinitions,
  generateNewListDefinition,
  getBasicNumIdTag,
  getNewListId,
  hasListDefinition,
  removeListDefinitions,
  // Schema helpers
  createNewList,
  createSchemaOrderedListNode,
  createListItemNodeJSON,
  changeNumIdSameAbstract,
  // Base list definitions
  baseOrderedListDef,
  baseBulletList
};
const extractListLevelStyles = (cssText, listId, level, numId) => {
  const pattern = new RegExp(`@list\\s+l${listId}:level${level}(?:\\s+lfo${numId})?\\s*\\{([^}]+)\\}`, "i");
  const match = cssText.match(pattern);
  if (!match) return null;
  const rawStyles = match[1].split(";").map((line) => line.trim()).filter(Boolean);
  const styleMap = {};
  for (const style of rawStyles) {
    const [key, value] = style.split(":").map((s) => s.trim());
    styleMap[key] = value;
  }
  return styleMap;
};
const extractParagraphStyles = (cssText, selector) => {
  const pattern = new RegExp(`(${selector})\\s*\\{([^}]+)\\}`, "i");
  const match = cssText.match(pattern);
  if (!match) return null;
  const rawStyles = match[2].split(";").map((line) => line.trim()).filter(Boolean);
  const styleMap = {};
  for (const style of rawStyles) {
    const [key, value] = style.split(":").map((s) => s.trim());
    styleMap[key] = value;
  }
  return styleMap;
};
function resolveStyles(extractedStyles, inlineStyles) {
  const inlineStyleMap = {};
  if (inlineStyles) {
    const styles = inlineStyles.split(";").map((s) => s.trim()).filter(Boolean);
    for (const style of styles) {
      const [key, value] = style.split(":").map((s) => s.trim());
      inlineStyleMap[key] = value;
    }
  }
  if (inlineStyleMap["mso-text-indent-alt"]) {
    delete inlineStyleMap["text-indent"];
    inlineStyleMap["text-indent"] = inlineStyleMap["mso-text-indent-alt"];
    delete inlineStyleMap["mso-text-indent-alt"];
  }
  if (inlineStyleMap["mso-bidi-font-family"]) {
    delete inlineStyleMap["font-family"];
    inlineStyleMap["font-family"] = inlineStyleMap["mso-bidi-font-family"];
    delete inlineStyleMap["mso-bidi-font-family"];
  }
  return { ...extractedStyles, ...inlineStyleMap };
}
const numDefMap = /* @__PURE__ */ new Map([
  ["decimal", "decimal"],
  ["alpha-lower", "lowerLetter"],
  ["alpha-upper", "upperLetter"],
  ["roman-lower", "lowerRoman"],
  ["roman-upper", "upperRoman"],
  ["bullet", "bullet"]
]);
const numDefByTypeMap = /* @__PURE__ */ new Map([
  ["1", "decimal"],
  ["a", "lowerLetter"],
  ["A", "upperLetter"],
  ["I", "upperRoman"],
  ["i", "lowerRoman"]
]);
function getStartNumber(lvlText) {
  const match = lvlText.match(/^(\d+)/);
  if (match) return parseInt(match[1], 10);
  return null;
}
function letterToNumber(letter) {
  return letter.toLowerCase().charCodeAt(0) - "a".charCodeAt(0) + 1;
}
function getStartNumberFromAlpha(lvlText) {
  const match = lvlText.match(/^([a-zA-Z])/);
  if (match) return letterToNumber(match[1]);
  return null;
}
function romanToNumber(roman) {
  const map = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1e3 };
  let num = 0, prev = 0;
  for (let i = roman.length - 1; i >= 0; i--) {
    const curr = map[roman[i].toUpperCase()] || 0;
    if (curr < prev) num -= curr;
    else num += curr;
    prev = curr;
  }
  return num;
}
function getStartNumberFromRoman(lvlText) {
  const match = lvlText.match(/^([ivxlcdmIVXLCDM]+)/);
  if (match) return romanToNumber(match[1]);
  return null;
}
const startHelperMap = /* @__PURE__ */ new Map([
  ["decimal", getStartNumber],
  ["lowerLetter", getStartNumberFromAlpha],
  ["upperLetter", getStartNumberFromAlpha],
  ["lowerRoman", getStartNumberFromRoman],
  ["upperRoman", getStartNumberFromRoman],
  ["bullet", () => 1]
]);
const googleNumDefMap = /* @__PURE__ */ new Map([
  ["decimal", "decimal"],
  ["decimal-leading-zero", "decimal"],
  ["lower-alpha", "lowerLetter"],
  ["upper-alpha", "upperLetter"],
  ["lower-roman", "lowerRoman"],
  ["upper-roman", "upperRoman"],
  ["bullet", "bullet"]
]);
const getLvlTextForGoogleList = (fmt, level, editor) => {
  const bulletListDef = editor.converter.numbering.abstracts[0];
  const bulletDefForLevel = bulletListDef.elements.find(
    (el) => el.name === "w:lvl" && el.attributes?.["w:ilvl"] === (level - 1).toString()
  );
  const bulletLvlText = bulletDefForLevel.elements.find((el) => el.name === "w:lvlText")?.attributes?.["w:val"];
  switch (fmt) {
    case "decimal-leading-zero":
      return `0%${level}.`;
    case "bullet":
      return bulletLvlText;
    default:
      return `%${level}.`;
  }
};
const handleDocxPaste = (html, editor, view) => {
  const { converter } = editor;
  if (!converter || !converter.convertedXml) return handleHtmlPaste(html, editor);
  let cleanedHtml = convertEmToPt(html);
  cleanedHtml = cleanHtmlUnnecessaryTags(cleanedHtml);
  const tempDiv = document.createElement("div");
  tempDiv.innerHTML = cleanedHtml;
  const data = tempDiv.querySelectorAll("p, li, " + [1, 2, 3, 4, 5, 6, 7, 8, 9].map((n) => `h${n}`).join(", "));
  const startMap = {};
  data.forEach((item) => {
    let type2;
    if (item.localName === "li") {
      type2 = "listItem";
    } else {
      type2 = "p";
    }
    const styleAttr = item.getAttribute("style") || "";
    const msoListMatch = styleAttr.match(/mso-list:\s*l(\d+)\s+level(\d+)\s+lfo(\d+)/);
    const css = tempDiv.querySelector("style").innerHTML;
    const normalStyles = extractParagraphStyles(css, ".MsoNormal");
    let styleId = item.getAttribute("class");
    let charStyles = {};
    if (item.localName.startsWith("h") && !styleId) {
      styleId = item.localName;
      const level = styleId.substring(1);
      charStyles = extractParagraphStyles(css, `.Heading${level}Char`);
    } else if (styleId) {
      styleId = `.${styleId}`;
    }
    const paragraphStyles = extractParagraphStyles(css, styleId);
    let styleChain = { ...normalStyles, ...paragraphStyles, ...charStyles };
    const numberingDefinedInline = !paragraphStyles || !paragraphStyles["mso-list"];
    if (msoListMatch) {
      const [, abstractId, level, numId] = msoListMatch;
      const numberingStyles = extractListLevelStyles(css, abstractId, level, numId) || {};
      const markerFontFamily = numberingStyles?.["font-family"] ?? normalStyles?.["font-family"];
      delete numberingStyles["font-family"];
      if (numberingDefinedInline) {
        styleChain = { ...normalStyles, ...paragraphStyles, ...numberingStyles };
      } else {
        styleChain = { ...normalStyles, ...numberingStyles, ...paragraphStyles };
      }
      let start, numFmt, lvlText;
      if (type2 === "listItem") {
        const listType = item.parentNode.getAttribute("type");
        const startAttr = item.parentNode.getAttribute("start");
        if (!startMap[numId]) startMap[numId] = startAttr;
        start = startMap[numId];
        numFmt = numDefByTypeMap.get(listType);
        lvlText = `%${level}.`;
      } else {
        const msoNumFormat = numberingStyles["mso-level-number-format"] || "decimal";
        numFmt = numDefMap.get(msoNumFormat);
        const punc = item.innerText?.match(/^\s*[a-zA-Z0-9]+([.()])/i)?.[1] || ".";
        lvlText = numFmt === "bullet" ? normalizeLvlTextChar(numberingStyles["mso-level-text"]) : `%${level}${punc}`;
        const startGetter = startHelperMap.get(numFmt);
        if (!startMap[numId]) startMap[numId] = startGetter(item.children[0]?.innerText || "1");
        start = startMap[numId];
      }
      item.setAttribute("data-marker-font-family", markerFontFamily);
      item.setAttribute("data-num-id", numId);
      item.setAttribute("data-list-level", parseInt(level) - 1);
      item.setAttribute("data-start", start);
      item.setAttribute("data-lvl-text", lvlText);
      item.setAttribute("data-num-fmt", numFmt);
    }
    const resolvedStyle = resolveStyles(styleChain, item.getAttribute("style"));
    const left = pointsToTwips(parseInt(resolvedStyle["margin-left"] ?? 0));
    const hangingFirstLine = pointsToTwips(parseInt(resolvedStyle["text-indent"] ?? 0));
    let hanging, firstLine;
    if (hangingFirstLine < 0) {
      hanging = Math.abs(hangingFirstLine);
    } else {
      firstLine = hangingFirstLine;
    }
    if (left || hanging || firstLine) {
      const indent = {};
      if (left != null) indent.left = left;
      if (hanging != null) indent.hanging = hanging;
      if (firstLine != null) indent.firstLine = firstLine;
      item.setAttribute("data-indent", JSON.stringify(indent));
    }
    const after = pointsToTwips(parseInt(resolvedStyle["margin-bottom"] ?? 0));
    const before = pointsToTwips(parseInt(resolvedStyle["margin-top"] ?? 0));
    if (after || before) {
      const spacing = {};
      if (after != null) spacing.after = after;
      if (before != null) spacing.before = before;
      item.setAttribute("data-spacing", JSON.stringify(spacing));
    }
    const textStyles = {};
    if (resolvedStyle["font-size"]) {
      textStyles["font-size"] = resolvedStyle["font-size"];
    }
    if (resolvedStyle["font-family"]) {
      textStyles["font-family"] = resolvedStyle["font-family"];
    }
    if (resolvedStyle["text-transform"]) {
      textStyles["text-transform"] = resolvedStyle["text-transform"];
    }
    if (Object.keys(textStyles).length) {
      Object.keys(textStyles).forEach((key) => {
        const styleValue = textStyles[key];
        if (styleValue) {
          item.style.setProperty(key, styleValue);
        }
      });
      item.setAttribute("data-text-styles", JSON.stringify(textStyles));
      for (const child of item.children) {
        if (child.style) {
          Object.keys(textStyles).forEach((key) => {
            const styleValue = textStyles[key];
            if (styleValue) {
              child.style.setProperty(key, styleValue);
            }
          });
        }
      }
    }
    if (resolvedStyle["font-weight"] === "bold") {
      item.style.setProperty("font-weight", "bold");
      for (const child of item.children) {
        if (child.style) {
          child.style.setProperty("font-weight", "bold");
        }
      }
    }
    extractAndRemoveConditionalPrefix(item);
  });
  transformWordLists(tempDiv, editor);
  let doc2 = DOMParser$1.fromSchema(editor.schema).parse(tempDiv);
  doc2 = wrapTextsInRuns(doc2);
  tempDiv.remove();
  const { dispatch } = editor.view;
  if (!dispatch) return false;
  dispatch(view.state.tr.replaceSelectionWith(doc2, true));
  return true;
};
const wrapTextsInRuns = (doc2) => {
  const runType = doc2.type?.schema?.nodes?.run;
  if (!runType) return doc2;
  const wrapNode = (node, parent) => {
    if (node.isText) {
      if (parent?.type?.name === "run") return node;
      const runProperties = decodeRPrFromMarks(node.marks);
      return runType.create({ runProperties }, [node]);
    }
    if (!node.childCount) return node;
    let changed = false;
    const wrappedChildren = [];
    node.forEach((child) => {
      const wrappedChild = wrapNode(child, node);
      if (wrappedChild !== child) changed = true;
      wrappedChildren.push(wrappedChild);
    });
    if (!changed) return node;
    return node.copy(Fragment.fromArray(wrappedChildren));
  };
  return wrapNode(doc2, null);
};
const transformWordLists = (container, editor) => {
  const listItems = Array.from(container.querySelectorAll("[data-num-id]"));
  const lists = {};
  const mappedLists = {};
  for (const item of listItems) {
    const level = parseInt(item.getAttribute("data-list-level"));
    const numFmt = item.getAttribute("data-num-fmt");
    const start = item.getAttribute("data-start");
    const lvlText = item.getAttribute("data-lvl-text");
    const markerFontFamily = item.getAttribute("data-marker-font-family");
    const importedId = item.getAttribute("data-num-id");
    if (!mappedLists[importedId]) mappedLists[importedId] = ListHelpers.getNewListId(editor);
    const id = mappedLists[importedId];
    const listType = numFmt === "bullet" ? "bulletList" : "orderedList";
    ListHelpers.generateNewListDefinition({
      numId: id,
      listType,
      level: level.toString(),
      start,
      fmt: numFmt,
      text: lvlText,
      editor,
      markerFontFamily
    });
    if (!lists[id]) lists[id] = { levels: {} };
    const currentListByNumId = lists[id];
    if (!currentListByNumId.levels[level]) currentListByNumId.levels[level] = Number(start) || 1;
    else currentListByNumId.levels[level]++;
    Object.keys(currentListByNumId.levels).forEach((key) => {
      const level1 = Number(key);
      if (level1 > level) {
        delete currentListByNumId.levels[level1];
      }
    });
    const path = generateListPath(level, currentListByNumId.levels, start);
    if (!path.length) path.push(currentListByNumId.levels[level]);
    const pElement = document.createElement("p");
    pElement.innerHTML = item.innerHTML;
    pElement.setAttribute("data-num-id", id);
    pElement.setAttribute("data-list-level", JSON.stringify(path));
    pElement.setAttribute("data-level", level);
    pElement.setAttribute("data-lvl-text", lvlText);
    pElement.setAttribute("data-num-fmt", numFmt);
    if (item.hasAttribute("data-indent")) {
      pElement.setAttribute("data-indent", item.getAttribute("data-indent"));
    }
    if (item.hasAttribute("data-spacing")) {
      pElement.setAttribute("data-spacing", item.getAttribute("data-spacing"));
    }
    if (item.hasAttribute("data-text-styles")) {
      const textStyles = JSON.parse(item.getAttribute("data-text-styles"));
      Object.keys(textStyles).forEach((key) => {
        const styleValue = textStyles[key];
        if (styleValue) {
          pElement.style.setProperty(key, styleValue);
          for (const child of pElement.children) {
            if (child.style) {
              child.style.setProperty(key, styleValue);
            }
          }
        }
      });
    }
    const parentNode = item.parentNode;
    parentNode.appendChild(pElement);
    let listForLevel;
    const newList = numFmt === "bullet" ? document.createElement("ul") : document.createElement("ol");
    newList.setAttribute("data-list-id", id);
    newList.level = level;
    parentNode.insertBefore(newList, item);
    listForLevel = newList;
    listForLevel.appendChild(pElement);
    item.remove();
  }
};
const generateListPath = (level, levels, start) => {
  const iLvl = Number(level);
  const path = [];
  if (iLvl > 0) {
    for (let i = iLvl; i >= 0; i--) {
      if (!levels[i]) levels[i] = Number(start);
      path.unshift(levels[i]);
    }
  }
  return path;
};
function extractAndRemoveConditionalPrefix(item) {
  const nodes = Array.from(item.childNodes);
  let fontFamily = null;
  let fontSize = null;
  let start = -1, end = -1;
  nodes.forEach((node, index2) => {
    if (node.nodeType === Node.COMMENT_NODE && node.nodeValue.includes("[if !supportLists]")) {
      start = index2;
    }
    if (start !== -1 && node.nodeType === Node.COMMENT_NODE && node.nodeValue.includes("[endif]")) {
      end = index2;
    }
  });
  if (start !== -1 && end !== -1) {
    for (let i = start + 1; i < end; i++) {
      const node = nodes[i];
      if (node.nodeType === Node.ELEMENT_NODE && node.style) {
        fontFamily = fontFamily || node.style.fontFamily;
        fontSize = fontSize || node.style.fontSize;
      }
    }
    for (let i = end; i >= start; i--) {
      item.removeChild(item.childNodes[i]);
    }
    if (fontFamily) item.setAttribute("data-font-family", fontFamily);
    if (fontSize) item.setAttribute("data-font-size", fontSize);
  }
}
const removeWhitespaces = (node) => {
  const children = node.childNodes;
  for (let i = children.length - 1; i >= 0; i -= 1) {
    const child = children[i];
    if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
      node.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces(child);
    }
  }
  return node;
};
function flattenListsInHtml$1(html, editor, domDocument) {
  const resolvedDocument = domDocument ?? editor?.options?.document ?? editor?.options?.mockDocument ?? (typeof document !== "undefined" ? document : null);
  const win = resolvedDocument?.defaultView ?? (typeof window !== "undefined" ? window : null);
  const DOMParserConstructor = win?.DOMParser ?? (typeof DOMParser !== "undefined" ? DOMParser : null);
  if (!DOMParserConstructor) {
    console.warn(
      "[super-editor] HTML list processing requires a DOM. Provide { document } (e.g. from JSDOM), set DOM globals, or run in a browser environment. Skipping list flattening."
    );
    return html;
  }
  const parser = new DOMParserConstructor();
  const doc2 = removeWhitespaces(parser.parseFromString(html, "text/html"));
  let foundList;
  while (foundList = findListToFlatten$1(doc2)) {
    flattenFoundList$1(foundList, editor);
  }
  return doc2.body.innerHTML;
}
function findListToFlatten$1(doc2) {
  let list = doc2.querySelector("ol:not([data-list-id]), ul:not([data-list-id])");
  if (list) return list;
  const allLists = doc2.querySelectorAll("ol[data-list-id], ul[data-list-id]");
  for (const list2 of allLists) {
    const liChildren = Array.from(list2.children).filter((c) => c.tagName.toLowerCase() === "li");
    if (liChildren.length > 1) {
      return list2;
    }
    const nestedLists = list2.querySelectorAll("ol, ul");
    if (nestedLists.length > 0) {
      return list2;
    }
    if (liChildren.length === 1) {
      return list2;
    }
  }
  return null;
}
function flattenFoundList$1(listElem, editor) {
  const localDoc = listElem.ownerDocument;
  const tag = listElem.tagName.toLowerCase();
  let rootNumId = listElem.getAttribute("data-list-id");
  if (!rootNumId) {
    rootNumId = ListHelpers.getNewListId(editor);
    ListHelpers.generateNewListDefinition({
      numId: rootNumId,
      listType: tag === "ol" ? "orderedList" : "bulletList",
      editor
    });
  }
  let level = Number(listElem.getAttribute("data-level"));
  if (Number.isNaN(level)) {
    level = 0;
  }
  let ancestor = listElem.parentElement;
  while (ancestor && ancestor !== localDoc.body) {
    if (ancestor.tagName && ancestor.tagName.toLowerCase() === "li") {
      level++;
    }
    ancestor = ancestor.parentElement;
  }
  const items = Array.from(listElem.children).filter((c) => c.tagName.toLowerCase() === "li");
  const newLists = [];
  items.forEach((li) => {
    const nestedLists = Array.from(li.querySelectorAll("ol, ul"));
    const nestedListsData = nestedLists.map((nl) => ({
      element: nl.cloneNode(true),
      parent: nl.parentNode
    }));
    nestedLists.forEach((nl) => nl.parentNode.removeChild(nl));
    let listNumberingType = tag === "ol" ? "decimal" : "bullet";
    try {
      const details = ListHelpers.getListDefinitionDetails?.({
        numId: rootNumId,
        level,
        editor
      });
      if (details?.listNumberingType) {
        listNumberingType = details.listNumberingType;
      }
    } catch {
    }
    const newList = createSingleItemList({ li, rootNumId, level, listNumberingType });
    newLists.push(newList);
    nestedListsData.forEach((data) => {
      data.element.setAttribute("data-level", level + 1);
      const nestedTag = data.element.tagName?.toLowerCase();
      if (nestedTag === tag) {
        data.element.setAttribute("data-list-id", rootNumId);
      }
      newLists.push(data.element);
    });
  });
  const parent = listElem.parentNode;
  const nextSibling = listElem.nextSibling;
  parent.removeChild(listElem);
  newLists.forEach((list) => {
    parent.insertBefore(list, nextSibling);
  });
}
function createSingleItemList({ li, rootNumId, level, listNumberingType }) {
  const localDoc = li.ownerDocument;
  const newItem = localDoc.createElement("p");
  Array.from(li.attributes).forEach((attr) => {
    if (!attr.name.startsWith("data-num-") && !attr.name.startsWith("data-level") && !attr.name.startsWith("data-list-")) {
      newItem.setAttribute(attr.name, attr.value);
    }
  });
  newItem.setAttribute("data-num-id", rootNumId);
  newItem.setAttribute("data-level", String(level));
  if (listNumberingType) {
    newItem.setAttribute("data-list-numbering-type", listNumberingType);
  }
  Array.from(li.childNodes).forEach((node) => {
    if (node.tagName === "P") {
      Array.from(node.childNodes).forEach((childNode) => {
        newItem.appendChild(childNode.cloneNode(true));
      });
      return;
    }
    newItem.appendChild(node.cloneNode(true));
  });
  return newItem;
}
function unflattenListsInHtml(html, domDocument) {
  const win = domDocument?.defaultView ?? (typeof window !== "undefined" ? window : null);
  const DOMParserConstructor = win?.DOMParser ?? (typeof DOMParser !== "undefined" ? DOMParser : null);
  if (!DOMParserConstructor) {
    console.warn(
      "[super-editor] HTML list processing requires a DOM. Provide { document } (e.g. from JSDOM), set DOM globals, or run in a browser environment. Skipping list unflattening."
    );
    return html;
  }
  const parser = new DOMParserConstructor();
  const doc2 = parser.parseFromString(html, "text/html");
  const allNodes = [...doc2.body.children];
  const listSequences = [];
  let currentSequence = null;
  allNodes.forEach((node) => {
    const isListParagraph = node.tagName === "P" && node.hasAttribute("data-num-id");
    if (isListParagraph) {
      const listId = node.getAttribute("data-num-id");
      if (currentSequence && currentSequence.id === listId) {
        currentSequence.items.push(node);
      } else {
        currentSequence = {
          id: listId,
          items: [node]
        };
        listSequences.push(currentSequence);
      }
    } else {
      currentSequence = null;
    }
  });
  listSequences.reverse().forEach((sequence) => {
    const sequenceItems = sequence.items;
    if (sequenceItems.length === 0) {
      return;
    }
    const items = sequenceItems.map((element) => {
      const level = parseInt(element.getAttribute("data-level") || "0", 10);
      const listNumberingType = element.getAttribute("data-list-numbering-type") || "";
      const listLevel = parseListLevelAttribute(element.getAttribute("data-list-level"));
      return {
        element,
        level,
        numId: element.getAttribute("data-num-id"),
        listNumberingType,
        listLevel
      };
    }).filter(Boolean);
    if (items.length === 0) {
      return;
    }
    const rootList = buildNestedList({ items });
    if (!rootList) {
      return;
    }
    const firstParagraph = sequenceItems[0];
    firstParagraph?.parentNode?.insertBefore(rootList, firstParagraph);
    sequenceItems.forEach((element) => {
      element.parentNode?.removeChild(element);
    });
  });
  return doc2.body.innerHTML;
}
function buildNestedList({ items }) {
  if (!items.length) {
    return null;
  }
  const [rootItem] = items;
  const doc2 = rootItem.element.ownerDocument;
  const rootListTag = getListTagForType(rootItem.listNumberingType);
  const rootList = doc2.createElement(rootListTag);
  if (rootItem.numId) {
    rootList.setAttribute("data-list-id", rootItem.numId);
  }
  rootList.setAttribute("data-level", String(rootItem.level ?? 0));
  applyStartAttribute(rootList, rootItem.listLevel, 0);
  const lastLevelItem = /* @__PURE__ */ new Map();
  items.forEach((item) => {
    const { element: paragraph, level } = item;
    const listItem = createListItemFromParagraph(paragraph);
    const cleanLi = cleanListItem(listItem);
    if (level === 0) {
      rootList.append(cleanLi);
      lastLevelItem.set(0, cleanLi);
    } else {
      const parentLi = lastLevelItem.get(level - 1);
      if (!parentLi) {
        rootList.append(cleanLi);
        lastLevelItem.set(level, cleanLi);
        return;
      }
      const listTag = getListTagForType(item.listNumberingType);
      let nestedList = findNestedList(parentLi, listTag);
      if (!nestedList) {
        nestedList = doc2.createElement(listTag);
        if (item.numId) {
          nestedList.setAttribute("data-list-id", item.numId);
        }
        parentLi.append(nestedList);
      }
      nestedList.setAttribute("data-level", String(level));
      applyStartAttribute(nestedList, item.listLevel, level);
      nestedList.append(cleanLi);
      lastLevelItem.set(level, cleanLi);
    }
    [...lastLevelItem.keys()].forEach((storedLevel) => {
      if (storedLevel > level) {
        lastLevelItem.delete(storedLevel);
      }
    });
  });
  return rootList;
}
function createListItemFromParagraph(paragraph) {
  const doc2 = paragraph.ownerDocument;
  const listItem = doc2.createElement("li");
  Array.from(paragraph.childNodes).forEach((node) => {
    listItem.appendChild(node.cloneNode(true));
  });
  Array.from(paragraph.attributes).forEach((attr) => {
    if (!LIST_METADATA_ATTRIBUTES.has(attr.name)) {
      listItem.setAttribute(attr.name, attr.value);
    }
  });
  return listItem;
}
function findNestedList(parentLi, listTag) {
  const lowerTag = listTag.toLowerCase();
  return Array.from(parentLi.children).find((child) => child.tagName && child.tagName.toLowerCase() === lowerTag);
}
function getListTagForType(listNumberingType) {
  const type2 = listNumberingType?.toLowerCase();
  if (!type2 || type2 === "bullet" || type2 === "image" || type2 === "none") {
    return "ul";
  }
  return "ol";
}
function applyStartAttribute(listNode, listLevel, level) {
  if (!listNode || listNode.tagName?.toLowerCase() !== "ol") {
    return;
  }
  const startValue = getStartValueForLevel(listLevel, level);
  if (startValue && startValue > 1 && !listNode.hasAttribute("start")) {
    listNode.setAttribute("start", String(startValue));
  }
}
function getStartValueForLevel(listLevel, level) {
  if (!Array.isArray(listLevel)) {
    return null;
  }
  const value = listLevel[level];
  const parsed = Number(value);
  return Number.isFinite(parsed) ? parsed : null;
}
function parseListLevelAttribute(raw) {
  if (!raw) {
    return null;
  }
  try {
    const parsed = JSON.parse(raw);
    return Array.isArray(parsed) ? parsed.map((value) => Number(value)) : null;
  } catch {
    return null;
  }
}
const LIST_METADATA_ATTRIBUTES = /* @__PURE__ */ new Set([
  "data-num-id",
  "data-level",
  "data-num-fmt",
  "data-lvl-text",
  "data-list-level",
  "data-marker-type",
  "data-list-numbering-type"
]);
function cleanListItem(listItem) {
  const attrs = [
    "data-num-id",
    "data-level",
    "data-num-fmt",
    "data-lvl-text",
    "data-list-level",
    "data-marker-type",
    "data-list-numbering-type",
    "aria-label"
  ];
  attrs.forEach((attr) => {
    listItem.removeAttribute(attr);
  });
  return listItem;
}
const handleGoogleDocsHtml = (html, editor, view) => {
  const htmlWithPtSizing = convertEmToPt(html);
  const cleanedHtml = sanitizeHtml(htmlWithPtSizing).innerHTML;
  const tempDiv = document.createElement("div");
  tempDiv.innerHTML = cleanedHtml;
  const htmlWithMergedLists = mergeSeparateLists(tempDiv);
  const flattenHtml = flattenListsInHtml(htmlWithMergedLists, editor);
  let doc2 = DOMParser$1.fromSchema(editor.schema).parse(flattenHtml);
  doc2 = wrapTextsInRuns(doc2);
  tempDiv.remove();
  const { dispatch } = editor.view;
  if (!dispatch) return false;
  dispatch(view.state.tr.replaceSelectionWith(doc2, true));
  return true;
};
function flattenListsInHtml(container, editor) {
  let foundList;
  while (foundList = findListToFlatten(container)) {
    flattenFoundList(foundList, editor);
  }
  return container;
}
function findListToFlatten(container) {
  let list = container.querySelector("ol:not([data-list-id]), ul:not([data-list-id])");
  if (list) return list;
  return null;
}
function flattenFoundList(listElem, editor) {
  const tag = listElem.tagName.toLowerCase();
  const baseLevel = getBaseLevel(listElem);
  const items = Array.from(listElem.children).filter((c) => c.tagName?.toLowerCase() === "li");
  if (!items.length) return;
  const counters = {};
  const levelStarts = {};
  const rootNumId = ListHelpers.getNewListId(editor);
  const newNodes = [];
  items.forEach((li) => {
    const level = getEffectiveLevel(li, baseLevel);
    const styleType = getListStyleType(li, tag);
    const numFmt = googleNumDefMap.get(styleType) || (tag === "ol" ? "decimal" : "bullet");
    const lvlText = getLvlTextForGoogleList(styleType, level + 1, editor);
    if (levelStarts[level] == null) {
      levelStarts[level] = getInitialStartValue({ li, listElem, level, baseLevel });
    }
    const currentValue = incrementLevelCounter(counters, level, levelStarts[level]);
    const path = buildListPath(level, counters);
    const paragraph = createSingleItemList({
      li: li.childNodes.length && li.childNodes[0].tagName === "P" ? li.childNodes[0] : li,
      rootNumId,
      level,
      listNumberingType: numFmt
    });
    paragraph.setAttribute("data-num-fmt", numFmt);
    paragraph.setAttribute("data-lvl-text", lvlText);
    paragraph.setAttribute("data-list-level", JSON.stringify(path.length ? path : [currentValue]));
    ListHelpers.generateNewListDefinition({
      numId: rootNumId,
      listType: numFmt === "bullet" ? "bulletList" : "orderedList",
      editor,
      fmt: numFmt,
      level: level.toString(),
      start: levelStarts[level],
      text: lvlText
    });
    newNodes.push(paragraph);
    const nestedLists = getNestedLists([li.nextSibling]);
    const nestedList = nestedLists[0];
    if (nestedList) {
      const cloned = nestedList.cloneNode(true);
      cloned.setAttribute("data-level", String(level + 1));
      newNodes.push(cloned);
      if (["OL", "UL"].includes(li.nextSibling?.tagName)) {
        li.nextSibling.remove();
      }
    }
  });
  const parent = listElem.parentNode;
  const nextSibling = listElem.nextSibling;
  parent.removeChild(listElem);
  newNodes.forEach((node) => {
    parent.insertBefore(node, nextSibling);
  });
}
function getNestedLists(nodes) {
  let result = [];
  const nodesArray = Array.from(nodes).filter((n) => n !== null);
  for (let item of nodesArray) {
    if (item.tagName === "OL" || item.tagName === "UL") {
      result.push(item);
    }
  }
  return result;
}
function mergeSeparateLists(container) {
  const tempCont = container.cloneNode(true);
  const allOls = Array.from(tempCont.querySelectorAll("ol") || []);
  const rootLevelLists = allOls.filter((ol) => !ol.parentElement?.closest("ol, ul"));
  const mainList = rootLevelLists.find((list) => !list.getAttribute("start")) || rootLevelLists[0];
  const hasStartAttr = rootLevelLists.some((list) => list.getAttribute("start") !== null);
  if (hasStartAttr && mainList) {
    const listsWithStartAttr = rootLevelLists.filter(
      (list) => list !== mainList && list.getAttribute("start") !== null
    );
    listsWithStartAttr.sort((a, b2) => Number(a.getAttribute("start")) - Number(b2.getAttribute("start"))).forEach((item) => {
      mainList.append(...item.childNodes);
      item.remove();
    });
  }
  return tempCont;
}
function getBaseLevel(listElem) {
  const explicitLevel = Number(listElem.getAttribute("data-level"));
  if (!Number.isNaN(explicitLevel)) return explicitLevel;
  let level = 0;
  let ancestor = listElem.parentElement;
  while (ancestor && ancestor.tagName) {
    if (ancestor.tagName.toLowerCase() === "li") level++;
    ancestor = ancestor.parentElement;
  }
  return level;
}
function getEffectiveLevel(li, baseLevel) {
  const ariaLevel = Number(li.getAttribute("aria-level"));
  if (Number.isNaN(ariaLevel)) {
    return baseLevel;
  }
  return Math.max(ariaLevel - 1, baseLevel);
}
function getListStyleType(li, fallbackTag) {
  return li.style?.["list-style-type"] || (fallbackTag === "ol" ? "decimal" : "bullet");
}
function getInitialStartValue({ li, listElem, level, baseLevel }) {
  const valueAttr = Number(li.getAttribute("value"));
  if (!Number.isNaN(valueAttr)) {
    return valueAttr;
  }
  if (level === baseLevel) {
    const listStart = Number(listElem.getAttribute("start"));
    if (!Number.isNaN(listStart)) {
      return listStart;
    }
  }
  return 1;
}
function incrementLevelCounter(map, level, start) {
  const numericLevel = Number(level);
  Object.keys(map).forEach((key) => {
    if (Number(key) > numericLevel) {
      delete map[key];
    }
  });
  if (map[numericLevel] == null) {
    map[numericLevel] = Number(start) || 1;
  } else {
    map[numericLevel] += 1;
  }
  return map[numericLevel];
}
function buildListPath(level, map) {
  const numericLevel = Number(level);
  if (Number.isNaN(numericLevel)) {
    return [];
  }
  const path = [];
  for (let i = 0; i <= numericLevel; i++) {
    if (map[i] != null) {
      path.push(map[i]);
    }
  }
  return path;
}
class InputRule {
  constructor(config2) {
    __publicField(this, "match");
    __publicField(this, "handler");
    this.match = config2.match;
    this.handler = config2.handler;
  }
}
const inputRuleMatcherHandler = (text, match) => {
  if (isRegExp(match)) {
    return match.exec(text);
  }
  const inputRuleMatch = match(text);
  if (!inputRuleMatch) {
    return null;
  }
  const result = [inputRuleMatch.text];
  result.index = inputRuleMatch.index;
  result.input = text;
  result.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[super-editor warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result.push(inputRuleMatch.replaceWith);
  }
  return result;
};
const run = (config2) => {
  const { editor, from, to, text, rules, plugin } = config2;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from);
  if ($from.parent.type.spec.code || !!($from.nodeBefore || $from.nodeAfter)?.marks.find((mark) => mark.type.spec.code)) {
    return false;
  }
  let matched = false;
  const textBefore = getTextContentFromNodes($from) + text;
  rules.forEach((rule) => {
    if (matched) {
      return;
    }
    const match = inputRuleMatcherHandler(textBefore, rule.match);
    if (!match) {
      return;
    }
    const tr = view.state.tr;
    const state2 = chainableEditorState(tr, view.state);
    const range2 = {
      from: from - (match[0].length - text.length),
      to
    };
    const { commands, chain, can } = new CommandService({
      editor,
      state: state2
    });
    const handler2 = rule.handler({
      state: state2,
      range: range2,
      match,
      commands,
      chain,
      can
    });
    if (handler2 === null || !tr.steps.length) {
      return;
    }
    tr.setMeta(plugin, {
      transform: tr,
      from,
      to,
      text
    });
    view.dispatch(tr);
    matched = true;
  });
  return matched;
};
const inputRulesPlugin = ({ editor, rules }) => {
  const plugin = new Plugin({
    key: new PluginKey("inputRulesPlugin"),
    state: {
      init() {
        return null;
      },
      apply(tr, prev, state2) {
        const stored = tr.getMeta(plugin);
        if (stored) {
          return stored;
        }
        const simulatedInputMeta = tr.getMeta("applyInputRules");
        const isSimulatedInput = !!simulatedInputMeta;
        if (isSimulatedInput) {
          setTimeout(() => {
            let { text } = simulatedInputMeta;
            if (typeof text !== "string") {
              const domDocument = editor?.options?.document ?? editor?.options?.mockDocument ?? (typeof document !== "undefined" ? document : null);
              if (!domDocument) {
                warnNoDOM("HTML conversion for input rules");
                return;
              }
              text = getHTMLFromFragment(Fragment.from(text), state2.schema, domDocument);
            }
            const { from } = simulatedInputMeta;
            const to = from + text.length;
            run({
              editor,
              from,
              to,
              text,
              rules,
              plugin
            });
          });
        }
        return tr.selectionSet || tr.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput(view, from, to, text) {
        return run({
          editor,
          from,
          to,
          text,
          rules,
          plugin
        });
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: "\n",
            rules,
            plugin
          });
        }
        return false;
      },
      // Paste handler
      handlePaste(view, event, slice) {
        const clipboard = event.clipboardData;
        const html = clipboard.getData("text/html");
        const fieldAnnotationContent = slice.content.content.filter((item) => item.type.name === "fieldAnnotation");
        if (fieldAnnotationContent.length) {
          return false;
        }
        const result = handleClipboardPaste({ editor, view }, html);
        return result;
      }
    },
    isInputRules: true
  });
  return plugin;
};
function isWordHtml(html) {
  return /class=["']?Mso|xmlns:o=["']?urn:schemas-microsoft-com|<!--\[if gte mso|<meta[^>]+name=["']?Generator["']?[^>]+Word/i.test(
    html
  );
}
function isGoogleDocsHtml(html) {
  return /docs-internal-guid-/.test(html);
}
function findParagraphAncestor($from) {
  for (let d2 = $from.depth; d2 >= 0; d2--) {
    const node = $from.node(d2);
    if (node.type.name === "paragraph") {
      return { node, depth: d2 };
    }
  }
  return { node: null, depth: -1 };
}
function handleHtmlPaste(html, editor, source) {
  let cleanedHtml;
  cleanedHtml = htmlHandler(html, editor);
  let doc2 = DOMParser$1.fromSchema(editor.schema).parse(cleanedHtml);
  doc2 = wrapTextsInRuns(doc2);
  const { dispatch, state: state2 } = editor.view;
  if (!dispatch) {
    return false;
  }
  const { $from } = state2.selection;
  const { node: paragraphNode } = findParagraphAncestor($from);
  const isInParagraph = paragraphNode !== null;
  const isSingleParagraph = doc2.childCount === 1 && doc2.firstChild.type.name === "paragraph";
  if (isInParagraph && isSingleParagraph) {
    const paragraphContent = doc2.firstChild.content;
    const tr = state2.tr.replaceSelectionWith(paragraphContent, false);
    dispatch(tr);
  } else if (isInParagraph) {
    const slice = new Slice(doc2.content, 0, 0);
    const tr = state2.tr.replaceSelection(slice);
    dispatch(tr);
  } else {
    dispatch(state2.tr.replaceSelectionWith(doc2, true));
  }
  return true;
}
function htmlHandler(html, editor, domDocument) {
  const resolvedDocument = domDocument ?? editor?.options?.document ?? editor?.options?.mockDocument ?? (typeof document !== "undefined" ? document : null);
  const flatHtml = flattenListsInHtml$1(html, editor, resolvedDocument);
  const htmlWithPtSizing = convertEmToPt(flatHtml);
  return sanitizeHtml(htmlWithPtSizing, void 0, resolvedDocument);
}
const convertEmToPt = (html) => {
  return html.replace(/font-size\s*:\s*([\d.]+)em/gi, (_2, emValue) => {
    const em = parseFloat(emValue);
    const pt = Math.round(em * 12 * 100) / 100;
    return `font-size: ${pt}pt`;
  });
};
function cleanHtmlUnnecessaryTags(html) {
  return html.replace(/<o:p>.*?<\/o:p>/gi, "").replace(/&nbsp;/gi, " ").replace(/<span[^>]*>\s*<\/span>/gi, "").replace(/<p[^>]*>\s*<\/p>/gi, "").trim();
}
function sanitizeHtml(html, forbiddenTags = ["meta", "svg", "script", "style", "button"], domDocument) {
  const resolvedDocument = domDocument ?? (typeof document !== "undefined" ? document : null);
  if (!resolvedDocument) {
    console.warn(
      "[super-editor] HTML sanitization requires a DOM. Provide { document } (e.g. from JSDOM), set DOM globals, or run in a browser environment. Skipping sanitization."
    );
    return null;
  }
  const container = resolvedDocument.createElement("div");
  container.innerHTML = html;
  const walkAndClean = (node) => {
    for (const child of [...node.children]) {
      if (forbiddenTags.includes(child.tagName.toLowerCase())) {
        child.remove();
        continue;
      }
      if (child.hasAttribute("linebreaktype")) {
        child.removeAttribute("linebreaktype");
      }
      walkAndClean(child);
    }
  };
  walkAndClean(container);
  return container;
}
function handleClipboardPaste({ editor, view }, html) {
  let source;
  if (!html) {
    source = "plain-text";
  } else if (isWordHtml(html)) {
    source = "word-html";
  } else if (isGoogleDocsHtml(html)) {
    source = "google-docs";
  } else {
    source = "browser-html";
  }
  switch (source) {
    case "plain-text":
      return false;
    case "word-html":
      if (editor.options.mode === "docx") {
        return handleDocxPaste(html, editor, view);
      }
      break;
    case "google-docs":
      return handleGoogleDocsHtml(html, editor, view);
    // falls through to browser-html handling when not in DOCX mode
    case "browser-html":
      return handleHtmlPaste(html, editor);
  }
  return false;
}
function createDocFromHTML(content, editor, options = {}) {
  const { isImport = false } = options;
  let parsedContent;
  if (typeof content === "string") {
    const domDocument = options.document ?? editor?.options?.document ?? editor?.options?.mockDocument ?? (typeof document !== "undefined" ? document : null);
    const tempDiv = htmlHandler(stripHtmlStyles(content, domDocument), editor, domDocument);
    if (isImport) {
      tempDiv.dataset.superdocImport = "true";
    }
    parsedContent = tempDiv;
  } else {
    parsedContent = content;
  }
  let doc2 = DOMParser$1.fromSchema(editor.schema).parse(parsedContent);
  doc2 = wrapTextsInRuns(doc2);
  return doc2;
}
function L() {
  return { async: false, breaks: false, extensions: null, gfm: true, hooks: null, pedantic: false, renderer: null, silent: false, tokenizer: null, walkTokens: null };
}
var T = L();
function G(l3) {
  T = l3;
}
var E = { exec: () => null };
function d(l3, e = "") {
  let t = typeof l3 == "string" ? l3 : l3.source, n = { replace: (r, i) => {
    let s = typeof i == "string" ? i : i.source;
    return s = s.replace(m.caret, "$1"), t = t.replace(r, s), n;
  }, getRegex: () => new RegExp(t, e) };
  return n;
}
var be = (() => {
  try {
    return !!new RegExp("(?<=1)(?<!1)");
  } catch {
    return false;
  }
})(), m = { codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm, outputLinkReplace: /\\([\[\]])/g, indentCodeCompensation: /^(\s+)(?:```)/, beginningSpace: /^\s+/, endingHash: /#$/, startingSpaceChar: /^ /, endingSpaceChar: / $/, nonSpaceChar: /[^ ]/, newLineCharGlobal: /\n/g, tabCharGlobal: /\t/g, multipleSpaceGlobal: /\s+/g, blankLine: /^[ \t]*$/, doubleBlankLine: /\n[ \t]*\n[ \t]*$/, blockquoteStart: /^ {0,3}>/, blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g, blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm, listReplaceTabs: /^\t+/, listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g, listIsTask: /^\[[ xX]\] /, listReplaceTask: /^\[[ xX]\] +/, anyLine: /\n.*\n/, hrefBrackets: /^<(.*)>$/, tableDelimiter: /[:|]/, tableAlignChars: /^\||\| *$/g, tableRowBlankLine: /\n[ \t]*$/, tableAlignRight: /^ *-+: *$/, tableAlignCenter: /^ *:-+: *$/, tableAlignLeft: /^ *:-+ *$/, startATag: /^<a /i, endATag: /^<\/a>/i, startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i, endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i, startAngleBracket: /^</, endAngleBracket: />$/, pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/, unicodeAlphaNumeric: /[\p{L}\p{N}]/u, escapeTest: /[&<>"']/, escapeReplace: /[&<>"']/g, escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g, unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret: /(^|[^\[])\^/g, percentDecode: /%25/g, findPipe: /\|/g, splitPipe: / \|/, slashPipe: /\\\|/g, carriageReturn: /\r\n|\r/g, spaceLine: /^ +$/gm, notSpaceStart: /^\S*/, endingNewline: /\n$/, listItemRegex: (l3) => new RegExp(`^( {0,3}${l3})((?:[	 ][^\\n]*)?(?:\\n|$))`), nextBulletRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), hrRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), fencesBeginRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}(?:\`\`\`|~~~)`), headingBeginRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}#`), htmlBeginRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}<(?:[a-z].*>|!--)`, "i") }, Re = /^(?:[ \t]*(?:\n|$))+/, Te = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, Oe = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, I = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, we = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, F = /(?:[*+-]|\d{1,9}[.)])/, ie = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, oe = d(ie).replace(/bull/g, F).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), ye = d(ie).replace(/bull/g, F).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), j = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, Pe = /^[^\n]+/, Q = /(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/, Se = d(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", Q).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), $e = d(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, F).getRegex(), v = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", U = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, _e = d("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", U).replace("tag", v).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), ae = d(j).replace("hr", I).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v).getRegex(), Le = d(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", ae).getRegex(), K = { blockquote: Le, code: Te, def: Se, fences: Oe, heading: we, hr: I, html: _e, lheading: oe, list: $e, newline: Re, paragraph: ae, table: E, text: Pe }, re = d("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", I).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v).getRegex(), Me = { ...K, lheading: ye, table: re, paragraph: d(j).replace("hr", I).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", re).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v).getRegex() }, ze = { ...K, html: d(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", U).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: E, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: d(j).replace("hr", I).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", oe).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex() }, Ae = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, Ee = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, le = /^( {2,}|\\)\n(?!\s*$)/, Ie = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, D = /[\p{P}\p{S}]/u, W = /[\s\p{P}\p{S}]/u, ue = /[^\s\p{P}\p{S}]/u, Ce = d(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, W).getRegex(), pe = /(?!~)[\p{P}\p{S}]/u, Be = /(?!~)[\s\p{P}\p{S}]/u, qe = /(?:[^\s\p{P}\p{S}]|~)/u, ve = d(/link|precode-code|html/, "g").replace("link", /\[(?:[^\[\]`]|(?<a>`+)[^`]+\k<a>(?!`))*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)/).replace("precode-", be ? "(?<!`)()" : "(^^|[^`])").replace("code", /(?<b>`+)[^`]+\k<b>(?!`)/).replace("html", /<(?! )[^<>]*?>/).getRegex(), ce = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, De = d(ce, "u").replace(/punct/g, D).getRegex(), He = d(ce, "u").replace(/punct/g, pe).getRegex(), he$3 = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", Ze = d(he$3, "gu").replace(/notPunctSpace/g, ue).replace(/punctSpace/g, W).replace(/punct/g, D).getRegex(), Ge = d(he$3, "gu").replace(/notPunctSpace/g, qe).replace(/punctSpace/g, Be).replace(/punct/g, pe).getRegex(), Ne = d("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, ue).replace(/punctSpace/g, W).replace(/punct/g, D).getRegex(), Fe = d(/\\(punct)/, "gu").replace(/punct/g, D).getRegex(), je = d(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), Qe = d(U).replace("(?:-->|$)", "-->").getRegex(), Ue = d("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", Qe).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), q = /(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`+[^`]*?`+(?!`)|[^\[\]\\`])*?/, Ke = d(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", q).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), de = d(/^!?\[(label)\]\[(ref)\]/).replace("label", q).replace("ref", Q).getRegex(), ke = d(/^!?\[(ref)\](?:\[\])?/).replace("ref", Q).getRegex(), We = d("reflink|nolink(?!\\()", "g").replace("reflink", de).replace("nolink", ke).getRegex(), se = /[hH][tT][tT][pP][sS]?|[fF][tT][pP]/, X = { _backpedal: E, anyPunctuation: Fe, autolink: je, blockSkip: ve, br: le, code: Ee, del: E, emStrongLDelim: De, emStrongRDelimAst: Ze, emStrongRDelimUnd: Ne, escape: Ae, link: Ke, nolink: ke, punctuation: Ce, reflink: de, reflinkSearch: We, tag: Ue, text: Ie, url: E }, Xe = { ...X, link: d(/^!?\[(label)\]\((.*?)\)/).replace("label", q).getRegex(), reflink: d(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", q).getRegex() }, N = { ...X, emStrongRDelimAst: Ge, emStrongLDelim: He, url: d(/^((?:protocol):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/).replace("protocol", se).replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/, text: d(/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|protocol:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/).replace("protocol", se).getRegex() }, Je = { ...N, br: d(le).replace("{2,}", "*").getRegex(), text: d(N.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() }, C = { normal: K, gfm: Me, pedantic: ze }, M = { normal: X, gfm: N, breaks: Je, pedantic: Xe };
var Ve = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, ge = (l3) => Ve[l3];
function w(l3, e) {
  if (e) {
    if (m.escapeTest.test(l3)) return l3.replace(m.escapeReplace, ge);
  } else if (m.escapeTestNoEncode.test(l3)) return l3.replace(m.escapeReplaceNoEncode, ge);
  return l3;
}
function J(l3) {
  try {
    l3 = encodeURI(l3).replace(m.percentDecode, "%");
  } catch {
    return null;
  }
  return l3;
}
function V(l3, e) {
  let t = l3.replace(m.findPipe, (i, s, a) => {
    let o = false, p = s;
    for (; --p >= 0 && a[p] === "\\"; ) o = !o;
    return o ? "|" : " |";
  }), n = t.split(m.splitPipe), r = 0;
  if (n[0].trim() || n.shift(), n.length > 0 && !n.at(-1)?.trim() && n.pop(), e) if (n.length > e) n.splice(e);
  else for (; n.length < e; ) n.push("");
  for (; r < n.length; r++) n[r] = n[r].trim().replace(m.slashPipe, "|");
  return n;
}
function z(l3, e, t) {
  let n = l3.length;
  if (n === 0) return "";
  let r = 0;
  for (; r < n; ) {
    let i = l3.charAt(n - r - 1);
    if (i === e && true) r++;
    else break;
  }
  return l3.slice(0, n - r);
}
function fe(l3, e) {
  if (l3.indexOf(e[1]) === -1) return -1;
  let t = 0;
  for (let n = 0; n < l3.length; n++) if (l3[n] === "\\") n++;
  else if (l3[n] === e[0]) t++;
  else if (l3[n] === e[1] && (t--, t < 0)) return n;
  return t > 0 ? -2 : -1;
}
function me(l3, e, t, n, r) {
  let i = e.href, s = e.title || null, a = l3[1].replace(r.other.outputLinkReplace, "$1");
  n.state.inLink = true;
  let o = { type: l3[0].charAt(0) === "!" ? "image" : "link", raw: t, href: i, title: s, text: a, tokens: n.inlineTokens(a) };
  return n.state.inLink = false, o;
}
function Ye(l3, e, t) {
  let n = l3.match(t.other.indentCodeCompensation);
  if (n === null) return e;
  let r = n[1];
  return e.split(`
`).map((i) => {
    let s = i.match(t.other.beginningSpace);
    if (s === null) return i;
    let [a] = s;
    return a.length >= r.length ? i.slice(r.length) : i;
  }).join(`
`);
}
var y = class {
  constructor(e) {
    __publicField(this, "options");
    __publicField(this, "rules");
    __publicField(this, "lexer");
    this.options = e || T;
  }
  space(e) {
    let t = this.rules.block.newline.exec(e);
    if (t && t[0].length > 0) return { type: "space", raw: t[0] };
  }
  code(e) {
    let t = this.rules.block.code.exec(e);
    if (t) {
      let n = t[0].replace(this.rules.other.codeRemoveIndent, "");
      return { type: "code", raw: t[0], codeBlockStyle: "indented", text: this.options.pedantic ? n : z(n, `
`) };
    }
  }
  fences(e) {
    let t = this.rules.block.fences.exec(e);
    if (t) {
      let n = t[0], r = Ye(n, t[3] || "", this.rules);
      return { type: "code", raw: n, lang: t[2] ? t[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : t[2], text: r };
    }
  }
  heading(e) {
    let t = this.rules.block.heading.exec(e);
    if (t) {
      let n = t[2].trim();
      if (this.rules.other.endingHash.test(n)) {
        let r = z(n, "#");
        (this.options.pedantic || !r || this.rules.other.endingSpaceChar.test(r)) && (n = r.trim());
      }
      return { type: "heading", raw: t[0], depth: t[1].length, text: n, tokens: this.lexer.inline(n) };
    }
  }
  hr(e) {
    let t = this.rules.block.hr.exec(e);
    if (t) return { type: "hr", raw: z(t[0], `
`) };
  }
  blockquote(e) {
    let t = this.rules.block.blockquote.exec(e);
    if (t) {
      let n = z(t[0], `
`).split(`
`), r = "", i = "", s = [];
      for (; n.length > 0; ) {
        let a = false, o = [], p;
        for (p = 0; p < n.length; p++) if (this.rules.other.blockquoteStart.test(n[p])) o.push(n[p]), a = true;
        else if (!a) o.push(n[p]);
        else break;
        n = n.slice(p);
        let u = o.join(`
`), c = u.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
        r = r ? `${r}
${u}` : u, i = i ? `${i}
${c}` : c;
        let g = this.lexer.state.top;
        if (this.lexer.state.top = true, this.lexer.blockTokens(c, s, true), this.lexer.state.top = g, n.length === 0) break;
        let h = s.at(-1);
        if (h?.type === "code") break;
        if (h?.type === "blockquote") {
          let R = h, f = R.raw + `
` + n.join(`
`), O = this.blockquote(f);
          s[s.length - 1] = O, r = r.substring(0, r.length - R.raw.length) + O.raw, i = i.substring(0, i.length - R.text.length) + O.text;
          break;
        } else if (h?.type === "list") {
          let R = h, f = R.raw + `
` + n.join(`
`), O = this.list(f);
          s[s.length - 1] = O, r = r.substring(0, r.length - h.raw.length) + O.raw, i = i.substring(0, i.length - R.raw.length) + O.raw, n = f.substring(s.at(-1).raw.length).split(`
`);
          continue;
        }
      }
      return { type: "blockquote", raw: r, tokens: s, text: i };
    }
  }
  list(e) {
    let t = this.rules.block.list.exec(e);
    if (t) {
      let n = t[1].trim(), r = n.length > 1, i = { type: "list", raw: "", ordered: r, start: r ? +n.slice(0, -1) : "", loose: false, items: [] };
      n = r ? `\\d{1,9}\\${n.slice(-1)}` : `\\${n}`, this.options.pedantic && (n = r ? n : "[*+-]");
      let s = this.rules.other.listItemRegex(n), a = false;
      for (; e; ) {
        let p = false, u = "", c = "";
        if (!(t = s.exec(e)) || this.rules.block.hr.test(e)) break;
        u = t[0], e = e.substring(u.length);
        let g = t[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (H) => " ".repeat(3 * H.length)), h = e.split(`
`, 1)[0], R = !g.trim(), f = 0;
        if (this.options.pedantic ? (f = 2, c = g.trimStart()) : R ? f = t[1].length + 1 : (f = t[2].search(this.rules.other.nonSpaceChar), f = f > 4 ? 1 : f, c = g.slice(f), f += t[1].length), R && this.rules.other.blankLine.test(h) && (u += h + `
`, e = e.substring(h.length + 1), p = true), !p) {
          let H = this.rules.other.nextBulletRegex(f), ee = this.rules.other.hrRegex(f), te = this.rules.other.fencesBeginRegex(f), ne = this.rules.other.headingBeginRegex(f), xe = this.rules.other.htmlBeginRegex(f);
          for (; e; ) {
            let Z = e.split(`
`, 1)[0], A;
            if (h = Z, this.options.pedantic ? (h = h.replace(this.rules.other.listReplaceNesting, "  "), A = h) : A = h.replace(this.rules.other.tabCharGlobal, "    "), te.test(h) || ne.test(h) || xe.test(h) || H.test(h) || ee.test(h)) break;
            if (A.search(this.rules.other.nonSpaceChar) >= f || !h.trim()) c += `
` + A.slice(f);
            else {
              if (R || g.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || te.test(g) || ne.test(g) || ee.test(g)) break;
              c += `
` + h;
            }
            !R && !h.trim() && (R = true), u += Z + `
`, e = e.substring(Z.length + 1), g = A.slice(f);
          }
        }
        i.loose || (a ? i.loose = true : this.rules.other.doubleBlankLine.test(u) && (a = true));
        let O = null, Y;
        this.options.gfm && (O = this.rules.other.listIsTask.exec(c), O && (Y = O[0] !== "[ ] ", c = c.replace(this.rules.other.listReplaceTask, ""))), i.items.push({ type: "list_item", raw: u, task: !!O, checked: Y, loose: false, text: c, tokens: [] }), i.raw += u;
      }
      let o = i.items.at(-1);
      if (o) o.raw = o.raw.trimEnd(), o.text = o.text.trimEnd();
      else return;
      i.raw = i.raw.trimEnd();
      for (let p = 0; p < i.items.length; p++) if (this.lexer.state.top = false, i.items[p].tokens = this.lexer.blockTokens(i.items[p].text, []), !i.loose) {
        let u = i.items[p].tokens.filter((g) => g.type === "space"), c = u.length > 0 && u.some((g) => this.rules.other.anyLine.test(g.raw));
        i.loose = c;
      }
      if (i.loose) for (let p = 0; p < i.items.length; p++) i.items[p].loose = true;
      return i;
    }
  }
  html(e) {
    let t = this.rules.block.html.exec(e);
    if (t) return { type: "html", block: true, raw: t[0], pre: t[1] === "pre" || t[1] === "script" || t[1] === "style", text: t[0] };
  }
  def(e) {
    let t = this.rules.block.def.exec(e);
    if (t) {
      let n = t[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), r = t[2] ? t[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", i = t[3] ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : t[3];
      return { type: "def", tag: n, raw: t[0], href: r, title: i };
    }
  }
  table(e) {
    let t = this.rules.block.table.exec(e);
    if (!t || !this.rules.other.tableDelimiter.test(t[2])) return;
    let n = V(t[1]), r = t[2].replace(this.rules.other.tableAlignChars, "").split("|"), i = t[3]?.trim() ? t[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], s = { type: "table", raw: t[0], header: [], align: [], rows: [] };
    if (n.length === r.length) {
      for (let a of r) this.rules.other.tableAlignRight.test(a) ? s.align.push("right") : this.rules.other.tableAlignCenter.test(a) ? s.align.push("center") : this.rules.other.tableAlignLeft.test(a) ? s.align.push("left") : s.align.push(null);
      for (let a = 0; a < n.length; a++) s.header.push({ text: n[a], tokens: this.lexer.inline(n[a]), header: true, align: s.align[a] });
      for (let a of i) s.rows.push(V(a, s.header.length).map((o, p) => ({ text: o, tokens: this.lexer.inline(o), header: false, align: s.align[p] })));
      return s;
    }
  }
  lheading(e) {
    let t = this.rules.block.lheading.exec(e);
    if (t) return { type: "heading", raw: t[0], depth: t[2].charAt(0) === "=" ? 1 : 2, text: t[1], tokens: this.lexer.inline(t[1]) };
  }
  paragraph(e) {
    let t = this.rules.block.paragraph.exec(e);
    if (t) {
      let n = t[1].charAt(t[1].length - 1) === `
` ? t[1].slice(0, -1) : t[1];
      return { type: "paragraph", raw: t[0], text: n, tokens: this.lexer.inline(n) };
    }
  }
  text(e) {
    let t = this.rules.block.text.exec(e);
    if (t) return { type: "text", raw: t[0], text: t[0], tokens: this.lexer.inline(t[0]) };
  }
  escape(e) {
    let t = this.rules.inline.escape.exec(e);
    if (t) return { type: "escape", raw: t[0], text: t[1] };
  }
  tag(e) {
    let t = this.rules.inline.tag.exec(e);
    if (t) return !this.lexer.state.inLink && this.rules.other.startATag.test(t[0]) ? this.lexer.state.inLink = true : this.lexer.state.inLink && this.rules.other.endATag.test(t[0]) && (this.lexer.state.inLink = false), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(t[0]) ? this.lexer.state.inRawBlock = true : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(t[0]) && (this.lexer.state.inRawBlock = false), { type: "html", raw: t[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: false, text: t[0] };
  }
  link(e) {
    let t = this.rules.inline.link.exec(e);
    if (t) {
      let n = t[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(n)) {
        if (!this.rules.other.endAngleBracket.test(n)) return;
        let s = z(n.slice(0, -1), "\\");
        if ((n.length - s.length) % 2 === 0) return;
      } else {
        let s = fe(t[2], "()");
        if (s === -2) return;
        if (s > -1) {
          let o = (t[0].indexOf("!") === 0 ? 5 : 4) + t[1].length + s;
          t[2] = t[2].substring(0, s), t[0] = t[0].substring(0, o).trim(), t[3] = "";
        }
      }
      let r = t[2], i = "";
      if (this.options.pedantic) {
        let s = this.rules.other.pedanticHrefTitle.exec(r);
        s && (r = s[1], i = s[3]);
      } else i = t[3] ? t[3].slice(1, -1) : "";
      return r = r.trim(), this.rules.other.startAngleBracket.test(r) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(n) ? r = r.slice(1) : r = r.slice(1, -1)), me(t, { href: r && r.replace(this.rules.inline.anyPunctuation, "$1"), title: i && i.replace(this.rules.inline.anyPunctuation, "$1") }, t[0], this.lexer, this.rules);
    }
  }
  reflink(e, t) {
    let n;
    if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
      let r = (n[2] || n[1]).replace(this.rules.other.multipleSpaceGlobal, " "), i = t[r.toLowerCase()];
      if (!i) {
        let s = n[0].charAt(0);
        return { type: "text", raw: s, text: s };
      }
      return me(n, i, n[0], this.lexer, this.rules);
    }
  }
  emStrong(e, t, n = "") {
    let r = this.rules.inline.emStrongLDelim.exec(e);
    if (!r || r[3] && n.match(this.rules.other.unicodeAlphaNumeric)) return;
    if (!(r[1] || r[2] || "") || !n || this.rules.inline.punctuation.exec(n)) {
      let s = [...r[0]].length - 1, a, o, p = s, u = 0, c = r[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (c.lastIndex = 0, t = t.slice(-1 * e.length + s); (r = c.exec(t)) != null; ) {
        if (a = r[1] || r[2] || r[3] || r[4] || r[5] || r[6], !a) continue;
        if (o = [...a].length, r[3] || r[4]) {
          p += o;
          continue;
        } else if ((r[5] || r[6]) && s % 3 && !((s + o) % 3)) {
          u += o;
          continue;
        }
        if (p -= o, p > 0) continue;
        o = Math.min(o, o + p + u);
        let g = [...r[0]][0].length, h = e.slice(0, s + r.index + g + o);
        if (Math.min(s, o) % 2) {
          let f = h.slice(1, -1);
          return { type: "em", raw: h, text: f, tokens: this.lexer.inlineTokens(f) };
        }
        let R = h.slice(2, -2);
        return { type: "strong", raw: h, text: R, tokens: this.lexer.inlineTokens(R) };
      }
    }
  }
  codespan(e) {
    let t = this.rules.inline.code.exec(e);
    if (t) {
      let n = t[2].replace(this.rules.other.newLineCharGlobal, " "), r = this.rules.other.nonSpaceChar.test(n), i = this.rules.other.startingSpaceChar.test(n) && this.rules.other.endingSpaceChar.test(n);
      return r && i && (n = n.substring(1, n.length - 1)), { type: "codespan", raw: t[0], text: n };
    }
  }
  br(e) {
    let t = this.rules.inline.br.exec(e);
    if (t) return { type: "br", raw: t[0] };
  }
  del(e) {
    let t = this.rules.inline.del.exec(e);
    if (t) return { type: "del", raw: t[0], text: t[2], tokens: this.lexer.inlineTokens(t[2]) };
  }
  autolink(e) {
    let t = this.rules.inline.autolink.exec(e);
    if (t) {
      let n, r;
      return t[2] === "@" ? (n = t[1], r = "mailto:" + n) : (n = t[1], r = n), { type: "link", raw: t[0], text: n, href: r, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  url(e) {
    let t;
    if (t = this.rules.inline.url.exec(e)) {
      let n, r;
      if (t[2] === "@") n = t[0], r = "mailto:" + n;
      else {
        let i;
        do
          i = t[0], t[0] = this.rules.inline._backpedal.exec(t[0])?.[0] ?? "";
        while (i !== t[0]);
        n = t[0], t[1] === "www." ? r = "http://" + t[0] : r = t[0];
      }
      return { type: "link", raw: t[0], text: n, href: r, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  inlineText(e) {
    let t = this.rules.inline.text.exec(e);
    if (t) {
      let n = this.lexer.state.inRawBlock;
      return { type: "text", raw: t[0], text: t[0], escaped: n };
    }
  }
};
var x = class l {
  constructor(e) {
    __publicField(this, "tokens");
    __publicField(this, "options");
    __publicField(this, "state");
    __publicField(this, "tokenizer");
    __publicField(this, "inlineQueue");
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || T, this.options.tokenizer = this.options.tokenizer || new y(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: false, inRawBlock: false, top: true };
    let t = { other: m, block: C.normal, inline: M.normal };
    this.options.pedantic ? (t.block = C.pedantic, t.inline = M.pedantic) : this.options.gfm && (t.block = C.gfm, this.options.breaks ? t.inline = M.breaks : t.inline = M.gfm), this.tokenizer.rules = t;
  }
  static get rules() {
    return { block: C, inline: M };
  }
  static lex(e, t) {
    return new l(t).lex(e);
  }
  static lexInline(e, t) {
    return new l(t).inlineTokens(e);
  }
  lex(e) {
    e = e.replace(m.carriageReturn, `
`), this.blockTokens(e, this.tokens);
    for (let t = 0; t < this.inlineQueue.length; t++) {
      let n = this.inlineQueue[t];
      this.inlineTokens(n.src, n.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(e, t = [], n = false) {
    for (this.options.pedantic && (e = e.replace(m.tabCharGlobal, "    ").replace(m.spaceLine, "")); e; ) {
      let r;
      if (this.options.extensions?.block?.some((s) => (r = s.call({ lexer: this }, e, t)) ? (e = e.substring(r.raw.length), t.push(r), true) : false)) continue;
      if (r = this.tokenizer.space(e)) {
        e = e.substring(r.raw.length);
        let s = t.at(-1);
        r.raw.length === 1 && s !== void 0 ? s.raw += `
` : t.push(r);
        continue;
      }
      if (r = this.tokenizer.code(e)) {
        e = e.substring(r.raw.length);
        let s = t.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.text, this.inlineQueue.at(-1).src = s.text) : t.push(r);
        continue;
      }
      if (r = this.tokenizer.fences(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.heading(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.hr(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.blockquote(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.list(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.html(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.def(e)) {
        e = e.substring(r.raw.length);
        let s = t.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.raw, this.inlineQueue.at(-1).src = s.text) : this.tokens.links[r.tag] || (this.tokens.links[r.tag] = { href: r.href, title: r.title }, t.push(r));
        continue;
      }
      if (r = this.tokenizer.table(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.lheading(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      let i = e;
      if (this.options.extensions?.startBlock) {
        let s = 1 / 0, a = e.slice(1), o;
        this.options.extensions.startBlock.forEach((p) => {
          o = p.call({ lexer: this }, a), typeof o == "number" && o >= 0 && (s = Math.min(s, o));
        }), s < 1 / 0 && s >= 0 && (i = e.substring(0, s + 1));
      }
      if (this.state.top && (r = this.tokenizer.paragraph(i))) {
        let s = t.at(-1);
        n && s?.type === "paragraph" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : t.push(r), n = i.length !== e.length, e = e.substring(r.raw.length);
        continue;
      }
      if (r = this.tokenizer.text(e)) {
        e = e.substring(r.raw.length);
        let s = t.at(-1);
        s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : t.push(r);
        continue;
      }
      if (e) {
        let s = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(s);
          break;
        } else throw new Error(s);
      }
    }
    return this.state.top = true, t;
  }
  inline(e, t = []) {
    return this.inlineQueue.push({ src: e, tokens: t }), t;
  }
  inlineTokens(e, t = []) {
    let n = e, r = null;
    if (this.tokens.links) {
      let o = Object.keys(this.tokens.links);
      if (o.length > 0) for (; (r = this.tokenizer.rules.inline.reflinkSearch.exec(n)) != null; ) o.includes(r[0].slice(r[0].lastIndexOf("[") + 1, -1)) && (n = n.slice(0, r.index) + "[" + "a".repeat(r[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (r = this.tokenizer.rules.inline.anyPunctuation.exec(n)) != null; ) n = n.slice(0, r.index) + "++" + n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    let i;
    for (; (r = this.tokenizer.rules.inline.blockSkip.exec(n)) != null; ) i = r[2] ? r[2].length : 0, n = n.slice(0, r.index + i) + "[" + "a".repeat(r[0].length - i - 2) + "]" + n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    n = this.options.hooks?.emStrongMask?.call({ lexer: this }, n) ?? n;
    let s = false, a = "";
    for (; e; ) {
      s || (a = ""), s = false;
      let o;
      if (this.options.extensions?.inline?.some((u) => (o = u.call({ lexer: this }, e, t)) ? (e = e.substring(o.raw.length), t.push(o), true) : false)) continue;
      if (o = this.tokenizer.escape(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.tag(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.link(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.reflink(e, this.tokens.links)) {
        e = e.substring(o.raw.length);
        let u = t.at(-1);
        o.type === "text" && u?.type === "text" ? (u.raw += o.raw, u.text += o.text) : t.push(o);
        continue;
      }
      if (o = this.tokenizer.emStrong(e, n, a)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.codespan(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.br(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.del(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.autolink(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (!this.state.inLink && (o = this.tokenizer.url(e))) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      let p = e;
      if (this.options.extensions?.startInline) {
        let u = 1 / 0, c = e.slice(1), g;
        this.options.extensions.startInline.forEach((h) => {
          g = h.call({ lexer: this }, c), typeof g == "number" && g >= 0 && (u = Math.min(u, g));
        }), u < 1 / 0 && u >= 0 && (p = e.substring(0, u + 1));
      }
      if (o = this.tokenizer.inlineText(p)) {
        e = e.substring(o.raw.length), o.raw.slice(-1) !== "_" && (a = o.raw.slice(-1)), s = true;
        let u = t.at(-1);
        u?.type === "text" ? (u.raw += o.raw, u.text += o.text) : t.push(o);
        continue;
      }
      if (e) {
        let u = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(u);
          break;
        } else throw new Error(u);
      }
    }
    return t;
  }
};
var P = class {
  constructor(e) {
    __publicField(this, "options");
    __publicField(this, "parser");
    this.options = e || T;
  }
  space(e) {
    return "";
  }
  code({ text: e, lang: t, escaped: n }) {
    let r = (t || "").match(m.notSpaceStart)?.[0], i = e.replace(m.endingNewline, "") + `
`;
    return r ? '<pre><code class="language-' + w(r) + '">' + (n ? i : w(i, true)) + `</code></pre>
` : "<pre><code>" + (n ? i : w(i, true)) + `</code></pre>
`;
  }
  blockquote({ tokens: e }) {
    return `<blockquote>
${this.parser.parse(e)}</blockquote>
`;
  }
  html({ text: e }) {
    return e;
  }
  def(e) {
    return "";
  }
  heading({ tokens: e, depth: t }) {
    return `<h${t}>${this.parser.parseInline(e)}</h${t}>
`;
  }
  hr(e) {
    return `<hr>
`;
  }
  list(e) {
    let t = e.ordered, n = e.start, r = "";
    for (let a = 0; a < e.items.length; a++) {
      let o = e.items[a];
      r += this.listitem(o);
    }
    let i = t ? "ol" : "ul", s = t && n !== 1 ? ' start="' + n + '"' : "";
    return "<" + i + s + `>
` + r + "</" + i + `>
`;
  }
  listitem(e) {
    let t = "";
    if (e.task) {
      let n = this.checkbox({ checked: !!e.checked });
      e.loose ? e.tokens[0]?.type === "paragraph" ? (e.tokens[0].text = n + " " + e.tokens[0].text, e.tokens[0].tokens && e.tokens[0].tokens.length > 0 && e.tokens[0].tokens[0].type === "text" && (e.tokens[0].tokens[0].text = n + " " + w(e.tokens[0].tokens[0].text), e.tokens[0].tokens[0].escaped = true)) : e.tokens.unshift({ type: "text", raw: n + " ", text: n + " ", escaped: true }) : t += n + " ";
    }
    return t += this.parser.parse(e.tokens, !!e.loose), `<li>${t}</li>
`;
  }
  checkbox({ checked: e }) {
    return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens: e }) {
    return `<p>${this.parser.parseInline(e)}</p>
`;
  }
  table(e) {
    let t = "", n = "";
    for (let i = 0; i < e.header.length; i++) n += this.tablecell(e.header[i]);
    t += this.tablerow({ text: n });
    let r = "";
    for (let i = 0; i < e.rows.length; i++) {
      let s = e.rows[i];
      n = "";
      for (let a = 0; a < s.length; a++) n += this.tablecell(s[a]);
      r += this.tablerow({ text: n });
    }
    return r && (r = `<tbody>${r}</tbody>`), `<table>
<thead>
` + t + `</thead>
` + r + `</table>
`;
  }
  tablerow({ text: e }) {
    return `<tr>
${e}</tr>
`;
  }
  tablecell(e) {
    let t = this.parser.parseInline(e.tokens), n = e.header ? "th" : "td";
    return (e.align ? `<${n} align="${e.align}">` : `<${n}>`) + t + `</${n}>
`;
  }
  strong({ tokens: e }) {
    return `<strong>${this.parser.parseInline(e)}</strong>`;
  }
  em({ tokens: e }) {
    return `<em>${this.parser.parseInline(e)}</em>`;
  }
  codespan({ text: e }) {
    return `<code>${w(e, true)}</code>`;
  }
  br(e) {
    return "<br>";
  }
  del({ tokens: e }) {
    return `<del>${this.parser.parseInline(e)}</del>`;
  }
  link({ href: e, title: t, tokens: n }) {
    let r = this.parser.parseInline(n), i = J(e);
    if (i === null) return r;
    e = i;
    let s = '<a href="' + e + '"';
    return t && (s += ' title="' + w(t) + '"'), s += ">" + r + "</a>", s;
  }
  image({ href: e, title: t, text: n, tokens: r }) {
    r && (n = this.parser.parseInline(r, this.parser.textRenderer));
    let i = J(e);
    if (i === null) return w(n);
    e = i;
    let s = `<img src="${e}" alt="${n}"`;
    return t && (s += ` title="${w(t)}"`), s += ">", s;
  }
  text(e) {
    return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : "escaped" in e && e.escaped ? e.text : w(e.text);
  }
};
var $ = class {
  strong({ text: e }) {
    return e;
  }
  em({ text: e }) {
    return e;
  }
  codespan({ text: e }) {
    return e;
  }
  del({ text: e }) {
    return e;
  }
  html({ text: e }) {
    return e;
  }
  text({ text: e }) {
    return e;
  }
  link({ text: e }) {
    return "" + e;
  }
  image({ text: e }) {
    return "" + e;
  }
  br() {
    return "";
  }
};
var b = class l2 {
  constructor(e) {
    __publicField(this, "options");
    __publicField(this, "renderer");
    __publicField(this, "textRenderer");
    this.options = e || T, this.options.renderer = this.options.renderer || new P(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new $();
  }
  static parse(e, t) {
    return new l2(t).parse(e);
  }
  static parseInline(e, t) {
    return new l2(t).parseInline(e);
  }
  parse(e, t = true) {
    let n = "";
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      if (this.options.extensions?.renderers?.[i.type]) {
        let a = i, o = this.options.extensions.renderers[a.type].call({ parser: this }, a);
        if (o !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "def", "paragraph", "text"].includes(a.type)) {
          n += o || "";
          continue;
        }
      }
      let s = i;
      switch (s.type) {
        case "space": {
          n += this.renderer.space(s);
          continue;
        }
        case "hr": {
          n += this.renderer.hr(s);
          continue;
        }
        case "heading": {
          n += this.renderer.heading(s);
          continue;
        }
        case "code": {
          n += this.renderer.code(s);
          continue;
        }
        case "table": {
          n += this.renderer.table(s);
          continue;
        }
        case "blockquote": {
          n += this.renderer.blockquote(s);
          continue;
        }
        case "list": {
          n += this.renderer.list(s);
          continue;
        }
        case "html": {
          n += this.renderer.html(s);
          continue;
        }
        case "def": {
          n += this.renderer.def(s);
          continue;
        }
        case "paragraph": {
          n += this.renderer.paragraph(s);
          continue;
        }
        case "text": {
          let a = s, o = this.renderer.text(a);
          for (; r + 1 < e.length && e[r + 1].type === "text"; ) a = e[++r], o += `
` + this.renderer.text(a);
          t ? n += this.renderer.paragraph({ type: "paragraph", raw: o, text: o, tokens: [{ type: "text", raw: o, text: o, escaped: true }] }) : n += o;
          continue;
        }
        default: {
          let a = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(a), "";
          throw new Error(a);
        }
      }
    }
    return n;
  }
  parseInline(e, t = this.renderer) {
    let n = "";
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      if (this.options.extensions?.renderers?.[i.type]) {
        let a = this.options.extensions.renderers[i.type].call({ parser: this }, i);
        if (a !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(i.type)) {
          n += a || "";
          continue;
        }
      }
      let s = i;
      switch (s.type) {
        case "escape": {
          n += t.text(s);
          break;
        }
        case "html": {
          n += t.html(s);
          break;
        }
        case "link": {
          n += t.link(s);
          break;
        }
        case "image": {
          n += t.image(s);
          break;
        }
        case "strong": {
          n += t.strong(s);
          break;
        }
        case "em": {
          n += t.em(s);
          break;
        }
        case "codespan": {
          n += t.codespan(s);
          break;
        }
        case "br": {
          n += t.br(s);
          break;
        }
        case "del": {
          n += t.del(s);
          break;
        }
        case "text": {
          n += t.text(s);
          break;
        }
        default: {
          let a = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(a), "";
          throw new Error(a);
        }
      }
    }
    return n;
  }
};
var S = (_b = class {
  constructor(e) {
    __publicField(this, "options");
    __publicField(this, "block");
    this.options = e || T;
  }
  preprocess(e) {
    return e;
  }
  postprocess(e) {
    return e;
  }
  processAllTokens(e) {
    return e;
  }
  emStrongMask(e) {
    return e;
  }
  provideLexer() {
    return this.block ? x.lex : x.lexInline;
  }
  provideParser() {
    return this.block ? b.parse : b.parseInline;
  }
}, __publicField(_b, "passThroughHooks", /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens", "emStrongMask"])), __publicField(_b, "passThroughHooksRespectAsync", /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens"])), _b);
var B = class {
  constructor(...e) {
    __publicField(this, "defaults", L());
    __publicField(this, "options", this.setOptions);
    __publicField(this, "parse", this.parseMarkdown(true));
    __publicField(this, "parseInline", this.parseMarkdown(false));
    __publicField(this, "Parser", b);
    __publicField(this, "Renderer", P);
    __publicField(this, "TextRenderer", $);
    __publicField(this, "Lexer", x);
    __publicField(this, "Tokenizer", y);
    __publicField(this, "Hooks", S);
    this.use(...e);
  }
  walkTokens(e, t) {
    let n = [];
    for (let r of e) switch (n = n.concat(t.call(this, r)), r.type) {
      case "table": {
        let i = r;
        for (let s of i.header) n = n.concat(this.walkTokens(s.tokens, t));
        for (let s of i.rows) for (let a of s) n = n.concat(this.walkTokens(a.tokens, t));
        break;
      }
      case "list": {
        let i = r;
        n = n.concat(this.walkTokens(i.items, t));
        break;
      }
      default: {
        let i = r;
        this.defaults.extensions?.childTokens?.[i.type] ? this.defaults.extensions.childTokens[i.type].forEach((s) => {
          let a = i[s].flat(1 / 0);
          n = n.concat(this.walkTokens(a, t));
        }) : i.tokens && (n = n.concat(this.walkTokens(i.tokens, t)));
      }
    }
    return n;
  }
  use(...e) {
    let t = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return e.forEach((n) => {
      let r = { ...n };
      if (r.async = this.defaults.async || r.async || false, n.extensions && (n.extensions.forEach((i) => {
        if (!i.name) throw new Error("extension name required");
        if ("renderer" in i) {
          let s = t.renderers[i.name];
          s ? t.renderers[i.name] = function(...a) {
            let o = i.renderer.apply(this, a);
            return o === false && (o = s.apply(this, a)), o;
          } : t.renderers[i.name] = i.renderer;
        }
        if ("tokenizer" in i) {
          if (!i.level || i.level !== "block" && i.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
          let s = t[i.level];
          s ? s.unshift(i.tokenizer) : t[i.level] = [i.tokenizer], i.start && (i.level === "block" ? t.startBlock ? t.startBlock.push(i.start) : t.startBlock = [i.start] : i.level === "inline" && (t.startInline ? t.startInline.push(i.start) : t.startInline = [i.start]));
        }
        "childTokens" in i && i.childTokens && (t.childTokens[i.name] = i.childTokens);
      }), r.extensions = t), n.renderer) {
        let i = this.defaults.renderer || new P(this.defaults);
        for (let s in n.renderer) {
          if (!(s in i)) throw new Error(`renderer '${s}' does not exist`);
          if (["options", "parser"].includes(s)) continue;
          let a = s, o = n.renderer[a], p = i[a];
          i[a] = (...u) => {
            let c = o.apply(i, u);
            return c === false && (c = p.apply(i, u)), c || "";
          };
        }
        r.renderer = i;
      }
      if (n.tokenizer) {
        let i = this.defaults.tokenizer || new y(this.defaults);
        for (let s in n.tokenizer) {
          if (!(s in i)) throw new Error(`tokenizer '${s}' does not exist`);
          if (["options", "rules", "lexer"].includes(s)) continue;
          let a = s, o = n.tokenizer[a], p = i[a];
          i[a] = (...u) => {
            let c = o.apply(i, u);
            return c === false && (c = p.apply(i, u)), c;
          };
        }
        r.tokenizer = i;
      }
      if (n.hooks) {
        let i = this.defaults.hooks || new S();
        for (let s in n.hooks) {
          if (!(s in i)) throw new Error(`hook '${s}' does not exist`);
          if (["options", "block"].includes(s)) continue;
          let a = s, o = n.hooks[a], p = i[a];
          S.passThroughHooks.has(s) ? i[a] = (u) => {
            if (this.defaults.async && S.passThroughHooksRespectAsync.has(s)) return (async () => {
              let g = await o.call(i, u);
              return p.call(i, g);
            })();
            let c = o.call(i, u);
            return p.call(i, c);
          } : i[a] = (...u) => {
            if (this.defaults.async) return (async () => {
              let g = await o.apply(i, u);
              return g === false && (g = await p.apply(i, u)), g;
            })();
            let c = o.apply(i, u);
            return c === false && (c = p.apply(i, u)), c;
          };
        }
        r.hooks = i;
      }
      if (n.walkTokens) {
        let i = this.defaults.walkTokens, s = n.walkTokens;
        r.walkTokens = function(a) {
          let o = [];
          return o.push(s.call(this, a)), i && (o = o.concat(i.call(this, a))), o;
        };
      }
      this.defaults = { ...this.defaults, ...r };
    }), this;
  }
  setOptions(e) {
    return this.defaults = { ...this.defaults, ...e }, this;
  }
  lexer(e, t) {
    return x.lex(e, t ?? this.defaults);
  }
  parser(e, t) {
    return b.parse(e, t ?? this.defaults);
  }
  parseMarkdown(e) {
    return (n, r) => {
      let i = { ...r }, s = { ...this.defaults, ...i }, a = this.onError(!!s.silent, !!s.async);
      if (this.defaults.async === true && i.async === false) return a(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      if (typeof n > "u" || n === null) return a(new Error("marked(): input parameter is undefined or null"));
      if (typeof n != "string") return a(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(n) + ", string expected"));
      if (s.hooks && (s.hooks.options = s, s.hooks.block = e), s.async) return (async () => {
        let o = s.hooks ? await s.hooks.preprocess(n) : n, u = await (s.hooks ? await s.hooks.provideLexer() : e ? x.lex : x.lexInline)(o, s), c = s.hooks ? await s.hooks.processAllTokens(u) : u;
        s.walkTokens && await Promise.all(this.walkTokens(c, s.walkTokens));
        let h = await (s.hooks ? await s.hooks.provideParser() : e ? b.parse : b.parseInline)(c, s);
        return s.hooks ? await s.hooks.postprocess(h) : h;
      })().catch(a);
      try {
        s.hooks && (n = s.hooks.preprocess(n));
        let p = (s.hooks ? s.hooks.provideLexer() : e ? x.lex : x.lexInline)(n, s);
        s.hooks && (p = s.hooks.processAllTokens(p)), s.walkTokens && this.walkTokens(p, s.walkTokens);
        let c = (s.hooks ? s.hooks.provideParser() : e ? b.parse : b.parseInline)(p, s);
        return s.hooks && (c = s.hooks.postprocess(c)), c;
      } catch (o) {
        return a(o);
      }
    };
  }
  onError(e, t) {
    return (n) => {
      if (n.message += `
Please report this to https://github.com/markedjs/marked.`, e) {
        let r = "<p>An error occurred:</p><pre>" + w(n.message + "", true) + "</pre>";
        return t ? Promise.resolve(r) : r;
      }
      if (t) return Promise.reject(n);
      throw n;
    };
  }
};
var _ = new B();
function k(l3, e) {
  return _.parse(l3, e);
}
k.options = k.setOptions = function(l3) {
  return _.setOptions(l3), k.defaults = _.defaults, G(k.defaults), k;
};
k.getDefaults = L;
k.defaults = T;
k.use = function(...l3) {
  return _.use(...l3), k.defaults = _.defaults, G(k.defaults), k;
};
k.walkTokens = function(l3, e) {
  return _.walkTokens(l3, e);
};
k.parseInline = _.parseInline;
k.Parser = b;
k.parser = b.parse;
k.Renderer = P;
k.TextRenderer = $;
k.Lexer = x;
k.lexer = x.lex;
k.Tokenizer = y;
k.Hooks = S;
k.parse = k;
k.options;
k.setOptions;
k.use;
k.walkTokens;
k.parseInline;
b.parse;
x.lex;
k.use({
  breaks: false,
  // Use proper paragraphs, not <br> tags
  gfm: true
  // GitHub Flavored Markdown support
});
function createDocFromMarkdown(markdown, editor, options = {}) {
  const html = convertMarkdownToHTML(markdown);
  return createDocFromHTML(html, editor, options);
}
function convertMarkdownToHTML(markdown) {
  let html = k.parse(markdown, { async: false });
  return html.replace(/<\/p>\n<ul>/g, "</p>\n<p>&nbsp;</p>\n<ul>").replace(/<\/p>\n<ol>/g, "</p>\n<p>&nbsp;</p>\n<ol>").replace(/<\/ul>\n<h/g, "</ul>\n<p>&nbsp;</p>\n<h").replace(/<\/ol>\n<h/g, "</ol>\n<p>&nbsp;</p>\n<h");
}
function processContent({ content, type: type2, editor }) {
  if (!editor) {
    throw new Error("[processContent] Editor instance is required");
  }
  if (!editor.schema) {
    throw new Error("[processContent] Editor schema is not initialized");
  }
  if (content === null || content === void 0) {
    throw new Error("[processContent] Content is required and cannot be null or undefined");
  }
  const domDocument = editor?.options?.document ?? editor?.options?.mockDocument ?? (typeof document !== "undefined" ? document : null);
  let doc2;
  switch (type2) {
    case "html":
      if (!domDocument) {
        throw new Error(
          "[processContent] HTML processing requires a DOM. Provide { document } (e.g. from JSDOM), set DOM globals, or run in a browser environment."
        );
      }
      doc2 = createDocFromHTML(content, editor, { isImport: true, document: domDocument });
      break;
    case "markdown":
      if (!domDocument) {
        throw new Error(
          "[processContent] Markdown processing requires a DOM. Provide { document } (e.g. from JSDOM), set DOM globals, or run in a browser environment."
        );
      }
      doc2 = createDocFromMarkdown(content, editor, { isImport: true, document: domDocument });
      break;
    case "text":
      if (!domDocument) {
        throw new Error(
          "[processContent] Text processing requires a DOM. Provide { document } (e.g. from JSDOM), set DOM globals, or run in a browser environment."
        );
      }
      const wrapper = domDocument.createElement("div");
      wrapper.dataset.superdocImport = "true";
      const para = domDocument.createElement("p");
      para.textContent = content;
      wrapper.appendChild(para);
      doc2 = DOMParser$1.fromSchema(editor.schema).parse(wrapper);
      doc2 = wrapTextsInRuns(doc2);
      break;
    case "schema":
      doc2 = editor.schema.nodeFromJSON(content);
      doc2 = wrapTextsInRuns(doc2);
      break;
    default:
      throw new Error(
        `[processContent] Unknown content type: ${type2}. Expected 'html', 'markdown', 'text', or 'schema'.`
      );
  }
  return doc2;
}
const defaultBooleans = ["required", "readonly", "disabled", "checked", "multiple", "autofocus"];
function updateDOMAttributes(dom, attrs = {}, options = {}) {
  const customBooleans = options.customBooleans || [];
  const booleans = [...defaultBooleans, ...customBooleans];
  Object.entries(attrs).forEach(([key, value]) => {
    if (booleans.includes(key)) {
      if (!value) dom.removeAttribute(key);
      else dom.setAttribute(key, "");
      return;
    }
    if (value != null) {
      dom.setAttribute(key, value);
    } else {
      dom.removeAttribute(key);
    }
  });
}
const MAX_INLINE_NAVIGATION_ITERATIONS = 8;
const computeChangeRange = (original, suggested) => {
  const origLen = original.length;
  const suggLen = suggested.length;
  let prefix = 0;
  while (prefix < origLen && prefix < suggLen && original[prefix] === suggested[prefix]) {
    prefix++;
  }
  if (prefix === origLen && prefix === suggLen) {
    return { prefix, suffix: 0, hasChange: false };
  }
  let suffix = 0;
  while (suffix < origLen - prefix && suffix < suggLen - prefix && original[origLen - 1 - suffix] === suggested[suggLen - 1 - suffix]) {
    suffix++;
  }
  return { prefix, suffix, hasChange: true };
};
const resolveInlineTextPosition = (doc2, position, direction) => {
  const docSize = doc2.content.size;
  if (position < 0 || position > docSize) {
    return position;
  }
  const step = direction === "forward" ? 1 : -1;
  let current = position;
  let iterations = 0;
  while (iterations < MAX_INLINE_NAVIGATION_ITERATIONS) {
    iterations++;
    const resolved = doc2.resolve(current);
    const boundaryNode = direction === "forward" ? resolved.nodeAfter : resolved.nodeBefore;
    if (!boundaryNode || boundaryNode.isText) {
      break;
    }
    if (!boundaryNode.isInline || boundaryNode.isAtom || boundaryNode.content.size === 0) {
      break;
    }
    const next = current + step;
    if (next < 0 || next > docSize) {
      break;
    }
    current = next;
    const adjacent = doc2.resolve(current);
    const checkNode = direction === "forward" ? adjacent.nodeAfter : adjacent.nodeBefore;
    if (checkNode && checkNode.isText) {
      break;
    }
  }
  return current;
};
const mapCharOffsetToPosition = (doc2, from, to, charOffset) => {
  const docSize = doc2.content.size;
  if (from < 0 || from >= docSize || from >= to) {
    return from;
  }
  const resolvedFrom = resolveInlineTextPosition(doc2, from, "forward");
  if (charOffset <= 0) {
    return resolvedFrom;
  }
  const totalTextLength = doc2.textBetween(resolvedFrom, to, "", "").length;
  if (totalTextLength <= 0) {
    return resolvedFrom;
  }
  const targetOffset = Math.min(charOffset, totalTextLength);
  let low = resolvedFrom;
  let high = to;
  while (low < high) {
    const mid = Math.floor((low + high) / 2);
    const textLength = doc2.textBetween(resolvedFrom, mid, "", "").length;
    if (textLength < targetOffset) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  const mappedPosition = Math.min(low, to);
  const direction = targetOffset === totalTextLength ? "backward" : "forward";
  return resolveInlineTextPosition(doc2, mappedPosition, direction);
};
const getFirstTextMarks = (doc2, from, to) => {
  const docSize = doc2.content.size;
  if (from < 0 || to > docSize || from > to) {
    return null;
  }
  let firstMarks = null;
  doc2.nodesBetween(from, to, (node) => {
    if (node.isText) {
      firstMarks = node.marks;
      return false;
    }
  });
  return firstMarks;
};
const getMarksAtPosition = (state2, position) => {
  if (state2.storedMarks?.length) {
    return [...state2.storedMarks];
  }
  const resolved = state2.doc.resolve(position);
  return [...resolved.marks()];
};
const buildTextNodes = (state2, from, to, suggestedText) => {
  if (!suggestedText) {
    return [];
  }
  const { schema } = state2;
  const firstMarks = getFirstTextMarks(state2.doc, from, to);
  const marks = firstMarks ? [...firstMarks] : getMarksAtPosition(state2, from);
  return [schema.text(suggestedText, marks)];
};
const _testInternals = {
  computeChangeRange,
  resolveInlineTextPosition,
  mapCharOffsetToPosition,
  getFirstTextMarks,
  getMarksAtPosition,
  buildTextNodes
};
const applyPatch = ({ state: state2, tr, from, to, suggestedText }) => {
  if (!state2?.doc) {
    return { tr, changed: false };
  }
  const docSize = state2.doc.content.size;
  if (from < 0 || to > docSize || from > to) {
    return { tr, changed: false };
  }
  const originalText = state2.doc.textBetween(from, to, "", "");
  const { prefix, suffix, hasChange } = computeChangeRange(originalText, suggestedText);
  if (!hasChange) {
    return { tr, changed: false };
  }
  const changeFrom = mapCharOffsetToPosition(state2.doc, from, to, prefix);
  const originalTextLength = originalText.length;
  const changeTo = mapCharOffsetToPosition(state2.doc, from, to, originalTextLength - suffix);
  const replacementEnd = suggestedText.length - suffix;
  const replacementText = suggestedText.slice(prefix, replacementEnd);
  if (!replacementText) {
    tr.delete(changeFrom, changeTo);
    return { tr, changed: true };
  }
  const nodes = buildTextNodes(state2, changeFrom, changeTo, replacementText);
  tr.replaceWith(changeFrom, changeTo, Fragment.fromArray(nodes));
  return { tr, changed: true };
};
const helpers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  _testInternals,
  applyPatch,
  chainableEditorState,
  cleanSchemaItem,
  convertMarkdownToHTML,
  createDocFromHTML,
  createDocFromMarkdown,
  createDocument,
  defaultBlockAt,
  findChildren,
  findMark,
  findParentNode,
  findParentNodeClosestToPos,
  generateDocxListAttributes,
  generateDocxRandomId,
  generateRandom32BitHex,
  generateRandomSigned32BitIntStrId,
  getActiveFormatting,
  getExtensionConfigField,
  getMarkRange,
  getMarkType,
  getMarksBetween,
  getMarksFromSelection,
  getNodeType,
  getSchemaTypeByName,
  getSchemaTypeNameByName,
  isActive,
  isInTable,
  isList: isList$1,
  isMarkActive,
  isNodeActive,
  isTextSelection,
  posToDOMRect,
  processContent,
  updateDOMAttributes
}, Symbol.toStringTag, { value: "Module" }));
const translateImageNode = (params) => {
  const {
    node: { attrs = {} },
    tableCell,
    imageSize
  } = params;
  let imageId = attrs.rId;
  const src = attrs.originalSrc || attrs.src || attrs.imageSrc;
  const { originalWidth, originalHeight } = getPngDimensions(src);
  let imageName;
  if (params.node.type === "image") {
    if (src?.startsWith("data:")) {
      imageName = getFallbackImageNameFromDataUri(src);
    } else {
      imageName = src?.split("/").pop();
    }
  } else {
    imageName = attrs.fieldId;
  }
  imageName = sanitizeDocxMediaName(imageName);
  let size = attrs.size ? {
    w: pixelsToEmu(attrs.size.width),
    h: pixelsToEmu(attrs.size.height)
  } : imageSize;
  if (originalWidth && originalHeight) {
    const boxWidthPx = emuToPixels(size.w);
    const boxHeightPx = emuToPixels(size.h);
    const { scaledWidth, scaledHeight } = getScaledSize(originalWidth, originalHeight, boxWidthPx, boxHeightPx);
    size = {
      w: pixelsToEmu(scaledWidth),
      h: pixelsToEmu(scaledHeight)
    };
  }
  if (tableCell) {
    const colwidthSum = tableCell.attrs.colwidth.reduce((acc, curr) => acc + curr, 0);
    const leftMargin = tableCell.attrs.cellMargins?.left || 8;
    const rightMargin = tableCell.attrs.cellMargins?.right || 8;
    const maxWidthEmu = pixelsToEmu(colwidthSum - (leftMargin + rightMargin));
    const { width: w2, height: h } = resizeKeepAspectRatio(size.w, size.h, maxWidthEmu);
    if (w2 && h) size = { w: w2, h };
  }
  if (imageId) {
    const docx = params.converter?.convertedXml || {};
    const rels = docx["word/_rels/document.xml.rels"];
    const relsTag = rels?.elements?.find((el) => el.name === "Relationships");
    const hasRelation = relsTag?.elements.find((el) => el.attributes.Id === imageId);
    const path = src?.split("word/")[1];
    if (!hasRelation) {
      addImageRelationshipForId(params, imageId, path);
    }
  } else if (params.node.type === "image" && !imageId) {
    const path = src?.split("word/")[1];
    imageId = addNewImageRelationship(params, path);
  } else if (params.node.type === "fieldAnnotation" && !imageId) {
    const type2 = src?.split(";")[0].split("/")[1];
    if (!type2) {
      return prepareTextAnnotation(params);
    }
    const sanitizedHash = sanitizeDocxMediaName(attrs.hash, generateDocxRandomId(4));
    const fileName = `${imageName}_${sanitizedHash}.${type2}`;
    const relationshipTarget = `media/${fileName}`;
    const packagePath = `word/${relationshipTarget}`;
    imageId = addNewImageRelationship(params, relationshipTarget);
    params.media[packagePath] = src;
  }
  const inlineAttrs = attrs.originalPadding || {
    distT: 0,
    distB: 0,
    distL: 0,
    distR: 0
  };
  const xfrmAttrs = {};
  const effectExtentAttrs = {
    l: 0,
    t: 0,
    r: 0,
    b: 0
  };
  const transformData = attrs.transformData;
  if (transformData) {
    if (transformData.rotation) {
      xfrmAttrs.rot = degreesToRot(transformData.rotation);
    }
    if (transformData.verticalFlip) {
      xfrmAttrs.flipV = "1";
    }
    if (transformData.horizontalFlip) {
      xfrmAttrs.flipH = "1";
    }
    if (transformData.sizeExtension) {
      effectExtentAttrs.l = pixelsToEmu(transformData.sizeExtension.left);
      effectExtentAttrs.t = pixelsToEmu(transformData.sizeExtension.top);
      effectExtentAttrs.r = pixelsToEmu(transformData.sizeExtension.right);
      effectExtentAttrs.b = pixelsToEmu(transformData.sizeExtension.bottom);
    }
  }
  const drawingXmlns = "http://schemas.openxmlformats.org/drawingml/2006/main";
  const pictureXmlns = "http://schemas.openxmlformats.org/drawingml/2006/picture";
  return {
    attributes: inlineAttrs,
    elements: [
      {
        name: "wp:extent",
        attributes: {
          cx: size.w,
          cy: size.h
        }
      },
      {
        name: "wp:effectExtent",
        attributes: effectExtentAttrs
      },
      {
        name: "wp:docPr",
        attributes: {
          id: attrs.id || 0,
          name: attrs.alt || `Picture ${imageName}`
        }
      },
      {
        name: "wp:cNvGraphicFramePr",
        elements: [
          {
            name: "a:graphicFrameLocks",
            attributes: {
              "xmlns:a": drawingXmlns,
              noChangeAspect: 1
            }
          }
        ]
      },
      {
        name: "a:graphic",
        attributes: { "xmlns:a": drawingXmlns },
        elements: [
          {
            name: "a:graphicData",
            attributes: { uri: pictureXmlns },
            elements: [
              {
                name: "pic:pic",
                attributes: { "xmlns:pic": pictureXmlns },
                elements: [
                  {
                    name: "pic:nvPicPr",
                    elements: [
                      {
                        name: "pic:cNvPr",
                        attributes: {
                          id: attrs.id || 0,
                          name: attrs.title || `Picture ${imageName}`
                        }
                      },
                      {
                        name: "pic:cNvPicPr",
                        elements: [
                          {
                            name: "a:picLocks",
                            attributes: {
                              noChangeAspect: 1,
                              noChangeArrowheads: 1
                            }
                          }
                        ]
                      }
                    ]
                  },
                  {
                    name: "pic:blipFill",
                    elements: [
                      {
                        name: "a:blip",
                        attributes: {
                          "r:embed": imageId
                        }
                      },
                      {
                        name: "a:stretch",
                        elements: [{ name: "a:fillRect" }]
                      }
                    ]
                  },
                  {
                    name: "pic:spPr",
                    attributes: {
                      bwMode: "auto"
                    },
                    elements: [
                      {
                        name: "a:xfrm",
                        attributes: xfrmAttrs,
                        elements: [
                          {
                            name: "a:ext",
                            attributes: {
                              cx: size.w,
                              cy: size.h
                            }
                          },
                          {
                            name: "a:off",
                            attributes: {
                              x: 0,
                              y: 0
                            }
                          }
                        ]
                      },
                      {
                        name: "a:prstGeom",
                        attributes: { prst: "rect" },
                        elements: [{ name: "a:avLst" }]
                      },
                      {
                        name: "a:noFill"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  };
};
function getPngDimensions(base64) {
  if (!base64) return {};
  const type2 = base64.split(";")[0].split("/")[1];
  if (!base64 || type2 !== "png") {
    return {
      originalWidth: void 0,
      originalHeight: void 0
    };
  }
  let header = base64.split(",")[1].slice(0, 50);
  let uint8 = Uint8Array.from(atob(header), (c) => c.charCodeAt(0));
  let dataView = new DataView(uint8.buffer, 0, 28);
  return {
    originalWidth: dataView.getInt32(16),
    originalHeight: dataView.getInt32(20)
  };
}
function getScaledSize(originalWidth, originalHeight, maxWidth, maxHeight) {
  let scaledWidth = originalWidth;
  let scaledHeight = originalHeight;
  let ratio = Math.min(maxWidth / originalWidth, maxHeight / originalHeight);
  scaledWidth = Math.round(scaledWidth * ratio);
  scaledHeight = Math.round(scaledHeight * ratio);
  return { scaledWidth, scaledHeight };
}
function resizeKeepAspectRatio(width, height, maxWidth) {
  if (width > maxWidth) {
    let scale = maxWidth / width;
    let newHeight = Math.round(height * scale);
    return { width: maxWidth, height: newHeight };
  }
  return { width, height };
}
function addNewImageRelationship(params, imagePath) {
  const newId = "rId" + generateDocxRandomId();
  const newRel = {
    type: "element",
    name: "Relationship",
    attributes: {
      Id: newId,
      Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
      Target: imagePath
    }
  };
  params.relationships.push(newRel);
  return newId;
}
function addImageRelationshipForId(params, id, imagePath) {
  const newRel = {
    type: "element",
    name: "Relationship",
    attributes: {
      Id: id,
      Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
      Target: imagePath
    }
  };
  params.relationships.push(newRel);
}
function translateVectorShape(params) {
  const { node } = params;
  const { drawingContent } = node.attrs;
  const drawing = {
    name: "w:drawing",
    elements: [...drawingContent ? [...drawingContent.elements || []] : []]
  };
  const choice = {
    name: "mc:Choice",
    attributes: { Requires: "wps" },
    elements: [drawing]
  };
  const alternateContent = {
    name: "mc:AlternateContent",
    elements: [choice]
  };
  return wrapTextInRun(alternateContent);
}
function translateShapeGroup(params) {
  const { node } = params;
  const { drawingContent } = node.attrs;
  if (drawingContent) {
    const drawing = {
      name: "w:drawing",
      elements: [...drawingContent.elements || []]
    };
    const choice = {
      name: "mc:Choice",
      attributes: { Requires: "wpg" },
      elements: [drawing]
    };
    const alternateContent = {
      name: "mc:AlternateContent",
      elements: [choice]
    };
    return wrapTextInRun(alternateContent);
  }
  return wrapTextInRun({
    name: "w:drawing",
    elements: []
  });
}
function mergeDrawingChildren({ order, generated, original }) {
  const genQueues = groupByName(generated);
  const originalsByIndex = groupByIndex(original);
  return mergeWithOrder(order, genQueues, originalsByIndex);
}
function groupByIndex(entries = []) {
  const map = /* @__PURE__ */ new Map();
  entries.forEach((entry) => {
    if (!entry) return;
    const { index: index2, xml } = entry;
    if (typeof index2 === "number" && xml && xml.name !== "wp:extent") {
      map.set(index2, carbonCopy(xml));
    }
  });
  return map;
}
function mergeWithOrder(order = [], genQueues, originalsByIndex) {
  const out = [];
  const namesInOrder = new Set(order);
  order.forEach((name, idx) => {
    if (name === "wp:extent") {
      const queue3 = genQueues.get("wp:extent") || [];
      if (queue3.length) {
        out.push(queue3.shift());
        if (!queue3.length) genQueues.delete("wp:extent");
      }
      return;
    }
    if (originalsByIndex.has(idx)) {
      out.push(originalsByIndex.get(idx));
      originalsByIndex.delete(idx);
      if (genQueues.has(name)) {
        genQueues.delete(name);
      }
      return;
    }
    const queue2 = genQueues.get(name) || [];
    if (queue2.length) {
      out.push(queue2.shift());
      if (!queue2.length) genQueues.delete(name);
    }
  });
  originalsByIndex.forEach((xml) => out.push(xml));
  genQueues.forEach((queue2, name) => {
    if (namesInOrder.has(name)) return;
    queue2.forEach((el) => out.push(el));
  });
  return out;
}
function groupByName(nodes = []) {
  const map = /* @__PURE__ */ new Map();
  nodes.forEach((el) => {
    if (!el?.name) return;
    const list = map.get(el.name) || [];
    list.push(carbonCopy(el));
    map.set(el.name, list);
  });
  return map;
}
function translateAnchorNode(params) {
  const { attrs } = params.node;
  const anchorElements = [];
  const useOriginalChildren = Array.isArray(attrs.originalDrawingChildren) && attrs.originalDrawingChildren.length > 0;
  const hasSimplePos = attrs.simplePos !== void 0 || attrs.originalAttributes?.simplePos !== void 0;
  if (!useOriginalChildren && hasSimplePos) {
    anchorElements.push({
      name: "wp:simplePos",
      attributes: {
        x: attrs.simplePos?.x ?? 0,
        y: attrs.simplePos?.y ?? 0
      }
    });
  }
  if (!useOriginalChildren && attrs.anchorData) {
    const hElements = [];
    if (attrs.marginOffset.horizontal !== void 0) {
      hElements.push({
        name: "wp:posOffset",
        elements: [{ type: "text", text: pixelsToEmu(attrs.marginOffset.horizontal).toString() }]
      });
    }
    if (attrs.anchorData.alignH) {
      hElements.push({
        name: "wp:align",
        elements: [{ type: "text", text: attrs.anchorData.alignH }]
      });
    }
    anchorElements.push({
      name: "wp:positionH",
      attributes: { relativeFrom: attrs.anchorData.hRelativeFrom },
      ...hElements.length && { elements: hElements }
    });
    const vElements = [];
    if (attrs.marginOffset.top !== void 0) {
      vElements.push({
        name: "wp:posOffset",
        elements: [{ type: "text", text: pixelsToEmu(attrs.marginOffset.top).toString() }]
      });
    }
    if (attrs.anchorData.alignV) {
      vElements.push({
        name: "wp:align",
        elements: [{ type: "text", text: attrs.anchorData.alignV }]
      });
    }
    anchorElements.push({
      name: "wp:positionV",
      attributes: { relativeFrom: attrs.anchorData.vRelativeFrom },
      ...vElements.length && { elements: vElements }
    });
  }
  const nodeElements = translateImageNode(params);
  const inlineAttrs = {
    ...attrs.originalAttributes || {},
    ...nodeElements.attributes || {}
  };
  if (inlineAttrs.relativeHeight == null) {
    inlineAttrs.relativeHeight = 1;
  }
  if (attrs.originalAttributes?.simplePos === void 0 && hasSimplePos) {
    inlineAttrs.simplePos = "1";
  }
  const wrapElement = {
    name: `wp:wrap${attrs.wrap?.type || "None"}`
    // Important: wp:anchor will break if no wrapping is specified. We need to use wrapNone.
  };
  switch (useOriginalChildren ? void 0 : attrs.wrap?.type) {
    case "Square":
      wrapElement.attributes = {
        wrapText: attrs.wrap.attrs.wrapText
      };
      if ("distBottom" in (attrs.wrap.attrs || {})) {
        wrapElement.attributes.distB = pixelsToEmu(attrs.wrap.attrs.distBottom);
      }
      if ("distLeft" in (attrs.wrap.attrs || {})) {
        wrapElement.attributes.distL = pixelsToEmu(attrs.wrap.attrs.distLeft);
      }
      if ("distRight" in (attrs.wrap.attrs || {})) {
        wrapElement.attributes.distR = pixelsToEmu(attrs.wrap.attrs.distRight);
      }
      if ("distTop" in (attrs.wrap.attrs || {})) {
        wrapElement.attributes.distT = pixelsToEmu(attrs.wrap.attrs.distTop);
      }
      break;
    case "TopAndBottom": {
      const attributes = {};
      let hasKeys = false;
      if ("distBottom" in (attrs.wrap.attrs || {})) {
        attributes.distB = pixelsToEmu(attrs.wrap.attrs.distBottom);
        hasKeys = true;
      }
      if ("distTop" in (attrs.wrap.attrs || {})) {
        attributes.distT = pixelsToEmu(attrs.wrap.attrs.distTop);
        hasKeys = true;
      }
      if (hasKeys) {
        wrapElement.attributes = attributes;
      }
      break;
    }
    case "Through":
    case "Tight": {
      const attributes = {};
      if ("distLeft" in (attrs.wrap.attrs || {})) {
        attributes.distL = pixelsToEmu(attrs.wrap.attrs.distLeft);
      }
      if ("distRight" in (attrs.wrap.attrs || {})) {
        attributes.distR = pixelsToEmu(attrs.wrap.attrs.distRight);
      }
      if ("distTop" in (attrs.wrap.attrs || {})) {
        attributes.distT = pixelsToEmu(attrs.wrap.attrs.distTop);
      }
      if ("distBottom" in (attrs.wrap.attrs || {})) {
        attributes.distB = pixelsToEmu(attrs.wrap.attrs.distBottom);
      }
      const wrapText = attrs.wrap.attrs?.wrapText || "bothSides";
      {
        attributes.wrapText = wrapText;
      }
      if (Object.keys(attributes).length) {
        wrapElement.attributes = attributes;
      }
      if (attrs.wrap.attrs?.polygon) {
        const polygonNode = objToPolygon(attrs.wrap.attrs.polygon);
        if (polygonNode) {
          if (attrs.wrap.attrs?.polygonEdited !== void 0) {
            polygonNode.attributes = {
              ...polygonNode.attributes || {},
              edited: String(attrs.wrap.attrs.polygonEdited)
            };
          }
          wrapElement.elements = [polygonNode];
        }
      }
      break;
    }
    case "None":
      inlineAttrs.behindDoc = attrs.wrap.attrs?.behindDoc ? "1" : "0";
      break;
  }
  const effectIndex = nodeElements.elements.findIndex((el) => el.name === "wp:effectExtent");
  const elementsWithWrap = [
    ...nodeElements.elements.slice(0, effectIndex + 1),
    wrapElement,
    ...nodeElements.elements.slice(effectIndex + 1)
  ];
  const mergedElements = mergeDrawingChildren({
    order: attrs.drawingChildOrder || [],
    original: attrs.originalDrawingChildren || [],
    generated: [...anchorElements, ...elementsWithWrap]
  });
  return {
    name: "wp:anchor",
    attributes: inlineAttrs,
    elements: mergedElements
  };
}
const XML_NODE_NAME$k = "wp:anchor";
const SD_NODE_NAME$i = ["image", "shapeGroup", "vectorShape", "contentBlock"];
const validXmlAttributes$8 = [
  "distT",
  "distB",
  "distL",
  "distR",
  "allowOverlap",
  "behindDoc",
  "layoutInCell",
  "locked",
  "relativeHeight",
  "simplePos",
  "wp14:anchorId",
  "wp14:editId"
].map((xmlName) => createAttributeHandler(xmlName));
function encode$z(params) {
  const { node } = params.extraParams;
  if (!node || !node.name) {
    return null;
  }
  return handleAnchorNode(params);
}
function decode$B(params) {
  const { node } = params;
  if (!node || !node.type) {
    return null;
  }
  return translateAnchorNode(params);
}
const config$j = {
  xmlName: XML_NODE_NAME$k,
  sdNodeOrKeyName: SD_NODE_NAME$i,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$z,
  decode: decode$B,
  attributes: validXmlAttributes$8
};
const translator$V = NodeTranslator.from(config$j);
function handleInlineNode(params) {
  const { node } = params.extraParams;
  if (node.name !== "wp:inline") {
    return null;
  }
  return handleImageNode(node, params, false);
}
function translateInlineNode(params) {
  const { attrs } = params.node;
  const nodeElements = translateImageNode(params);
  const inlineAttrs = {
    ...attrs.originalAttributes || {},
    ...nodeElements.attributes || {}
  };
  const generatedElements = nodeElements?.elements || [];
  const mergedElements = mergeDrawingChildren({
    order: params.node?.attrs?.drawingChildOrder || [],
    original: params.node?.attrs?.originalDrawingChildren || [],
    generated: generatedElements
  });
  return {
    name: "wp:inline",
    attributes: inlineAttrs,
    elements: mergedElements
  };
}
const XML_NODE_NAME$j = "wp:inline";
const SD_NODE_NAME$h = ["image", "shapeGroup", "vectorShape", "contentBlock"];
const validXmlAttributes$7 = ["distT", "distB", "distL", "distR", "wp14:anchorId", "wp14:editId"].map(
  (xmlName) => createAttributeHandler(xmlName)
);
function encode$y(params) {
  const { node } = params.extraParams;
  if (!node || !node.name) {
    return null;
  }
  return handleInlineNode(params);
}
function decode$A(params) {
  const { node } = params;
  if (!node || !node.type) {
    return null;
  }
  return translateInlineNode(params);
}
const config$i = {
  xmlName: XML_NODE_NAME$j,
  sdNodeOrKeyName: SD_NODE_NAME$h,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$y,
  decode: decode$A,
  attributes: validXmlAttributes$7
};
const translator$U = NodeTranslator.from(config$i);
const XML_NODE_NAME$i = "w:drawing";
const SD_NODE_NAME$g = [];
const validXmlAttributes$6 = [];
function encode$x(params) {
  const nodes = params.nodes;
  const node = nodes[0];
  const translatorByChildName = {
    "wp:anchor": translator$V,
    "wp:inline": translator$U
  };
  const result = (node.elements || []).reduce((acc, child) => {
    if (acc) return acc;
    const translator2 = translatorByChildName[child.name];
    if (!translator2) return acc;
    const childResult = translator2.encode({ ...params, extraParams: { node: child } });
    return childResult || acc;
  }, null);
  if (result) return result;
  return {
    type: "passthroughBlock",
    attrs: {
      originalName: "w:drawing",
      originalXml: carbonCopy(node)
    }
  };
}
function decode$z(params) {
  const { node } = params;
  if (!node || !node.type) {
    return null;
  }
  const childTranslator = node.attrs.isAnchor ? translator$V : translator$U;
  const resultNode = childTranslator.decode(params);
  return wrapTextInRun(
    {
      name: "w:drawing",
      elements: [resultNode]
    },
    []
  );
}
const config$h = {
  xmlName: XML_NODE_NAME$i,
  sdNodeOrKeyName: SD_NODE_NAME$g,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$x,
  decode: decode$z,
  attributes: validXmlAttributes$6
};
const translator$T = NodeTranslator.from(config$h);
function getTextNodeForExport(text, marks, params) {
  const hasLeadingOrTrailingSpace = /^\s|\s$/.test(text);
  const space = hasLeadingOrTrailingSpace ? "preserve" : null;
  const nodeAttrs = space ? { "xml:space": space } : null;
  const textNodes = [];
  const textRunProperties = decodeRPrFromMarks(marks || []);
  const parentRunProperties = params.extraParams?.runProperties || {};
  const combinedRunProperties = combineRunProperties([parentRunProperties, textRunProperties]);
  const rPrNode = translator$2w.decode({ node: { attrs: { runProperties: combinedRunProperties } } });
  textNodes.push({
    name: "w:t",
    elements: [{ text, type: "text" }],
    attributes: nodeAttrs
  });
  if (params) {
    const { editor } = params;
    const customMarks = editor.extensionService.extensions.filter((e) => e.isExternal === true);
    marks.forEach((mark) => {
      const isCustomMark = customMarks.some((customMark) => {
        const customMarkName = customMark.name;
        return mark.type === customMarkName;
      });
      if (!isCustomMark) return;
      let attrsString = "";
      Object.entries(mark.attrs).forEach(([key, value]) => {
        if (value) {
          attrsString += `${key}=${value};`;
        }
      });
      if (isCustomMark) {
        textNodes.unshift({
          type: "element",
          name: "w:bookmarkStart",
          attributes: {
            "w:id": "5000",
            "w:name": mark.type + ";" + attrsString
          }
        });
        textNodes.push({
          type: "element",
          name: "w:bookmarkEnd",
          attributes: {
            "w:id": "5000"
          }
        });
      }
    });
  }
  return {
    name: "w:r",
    elements: rPrNode ? [rPrNode, ...textNodes] : textNodes
  };
}
var he$2 = { exports: {} };
var he$1 = he$2.exports;
var hasRequiredHe;
function requireHe() {
  if (hasRequiredHe) return he$2.exports;
  hasRequiredHe = 1;
  (function(module, exports$1) {
    (function(root) {
      var freeExports = exports$1;
      var freeModule = module && module.exports == freeExports && module;
      var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
      }
      var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var regexAsciiWhitelist = /[\x01-\x7F]/g;
      var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
      var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
      var encodeMap = { "": "shy", "": "zwnj", "": "zwj", "": "lrm", "": "ic", "": "it", "": "af", "": "rlm", "": "ZeroWidthSpace", "": "NoBreak", "": "DownBreve", "": "tdot", "": "DotDot", "	": "Tab", "\n": "NewLine", "": "puncsp", "": "MediumSpace", "": "thinsp", "": "hairsp", "": "emsp13", "": "ensp", "": "emsp14", "": "emsp", "": "numsp", "": "nbsp", "": "ThickSpace", "": "oline", "_": "lowbar", "": "dash", "": "ndash", "": "mdash", "": "horbar", ",": "comma", ";": "semi", "": "bsemi", ":": "colon", "": "Colone", "!": "excl", "": "iexcl", "?": "quest", "": "iquest", ".": "period", "": "nldr", "": "mldr", "": "middot", "'": "apos", "": "lsquo", "": "rsquo", "": "sbquo", "": "lsaquo", "": "rsaquo", '"': "quot", "": "ldquo", "": "rdquo", "": "bdquo", "": "laquo", "": "raquo", "(": "lpar", ")": "rpar", "[": "lsqb", "]": "rsqb", "{": "lcub", "}": "rcub", "": "lceil", "": "rceil", "": "lfloor", "": "rfloor", "": "lopar", "": "ropar", "": "lbrke", "": "rbrke", "": "lbrkslu", "": "rbrksld", "": "lbrksld", "": "rbrkslu", "": "langd", "": "rangd", "": "lparlt", "": "rpargt", "": "gtlPar", "": "ltrPar", "": "lobrk", "": "robrk", "": "lang", "": "rang", "": "Lang", "": "Rang", "": "loang", "": "roang", "": "lbbrk", "": "rbbrk", "": "Vert", "": "sect", "": "para", "@": "commat", "*": "ast", "/": "sol", "undefined": null, "&": "amp", "#": "num", "%": "percnt", "": "permil", "": "pertenk", "": "dagger", "": "Dagger", "": "bull", "": "hybull", "": "prime", "": "Prime", "": "tprime", "": "qprime", "": "bprime", "": "caret", "`": "grave", "": "acute", "": "tilde", "^": "Hat", "": "macr", "": "breve", "": "dot", "": "die", "": "ring", "": "dblac", "": "cedil", "": "ogon", "": "circ", "": "caron", "": "deg", "": "copy", "": "reg", "": "copysr", "": "wp", "": "rx", "": "mho", "": "iiota", "": "larr", "": "nlarr", "": "rarr", "": "nrarr", "": "uarr", "": "darr", "": "harr", "": "nharr", "": "varr", "": "nwarr", "": "nearr", "": "searr", "": "swarr", "": "rarrw", "": "nrarrw", "": "Larr", "": "Uarr", "": "Rarr", "": "Darr", "": "larrtl", "": "rarrtl", "": "mapstoleft", "": "mapstoup", "": "map", "": "mapstodown", "": "larrhk", "": "rarrhk", "": "larrlp", "": "rarrlp", "": "harrw", "": "lsh", "": "rsh", "": "ldsh", "": "rdsh", "": "crarr", "": "cularr", "": "curarr", "": "olarr", "": "orarr", "": "lharu", "": "lhard", "": "uharr", "": "uharl", "": "rharu", "": "rhard", "": "dharr", "": "dharl", "": "rlarr", "": "udarr", "": "lrarr", "": "llarr", "": "uuarr", "": "rrarr", "": "ddarr", "": "lrhar", "": "rlhar", "": "lArr", "": "nlArr", "": "uArr", "": "rArr", "": "nrArr", "": "dArr", "": "iff", "": "nhArr", "": "vArr", "": "nwArr", "": "neArr", "": "seArr", "": "swArr", "": "lAarr", "": "rAarr", "": "zigrarr", "": "larrb", "": "rarrb", "": "duarr", "": "loarr", "": "roarr", "": "hoarr", "": "forall", "": "comp", "": "part", "": "npart", "": "exist", "": "nexist", "": "empty", "": "Del", "": "in", "": "notin", "": "ni", "": "notni", "": "bepsi", "": "prod", "": "coprod", "": "sum", "+": "plus", "": "pm", "": "div", "": "times", "<": "lt", "": "nlt", "<": "nvlt", "=": "equals", "": "ne", "=": "bne", "": "Equal", ">": "gt", "": "ngt", ">": "nvgt", "": "not", "|": "vert", "": "brvbar", "": "minus", "": "mp", "": "plusdo", "": "frasl", "": "setmn", "": "lowast", "": "compfn", "": "Sqrt", "": "prop", "": "infin", "": "angrt", "": "ang", "": "nang", "": "angmsd", "": "angsph", "": "mid", "": "nmid", "": "par", "": "npar", "": "and", "": "or", "": "cap", "": "caps", "": "cup", "": "cups", "": "int", "": "Int", "": "tint", "": "qint", "": "oint", "": "Conint", "": "Cconint", "": "cwint", "": "cwconint", "": "awconint", "": "there4", "": "becaus", "": "ratio", "": "Colon", "": "minusd", "": "mDDot", "": "homtht", "": "sim", "": "nsim", "": "nvsim", "": "bsim", "": "race", "": "ac", "": "acE", "": "acd", "": "wr", "": "esim", "": "nesim", "": "sime", "": "nsime", "": "cong", "": "ncong", "": "simne", "": "ap", "": "nap", "": "ape", "": "apid", "": "napid", "": "bcong", "": "CupCap", "": "NotCupCap", "": "nvap", "": "bump", "": "nbump", "": "bumpe", "": "nbumpe", "": "doteq", "": "nedot", "": "eDot", "": "efDot", "": "erDot", "": "colone", "": "ecolon", "": "ecir", "": "cire", "": "wedgeq", "": "veeeq", "": "trie", "": "equest", "": "equiv", "": "nequiv", "": "bnequiv", "": "le", "": "nle", "": "nvle", "": "ge", "": "nge", "": "nvge", "": "lE", "": "nlE", "": "gE", "": "ngE", "": "lvnE", "": "lnE", "": "gnE", "": "gvnE", "": "ll", "": "nLtv", "": "nLt", "": "gg", "": "nGtv", "": "nGt", "": "twixt", "": "lsim", "": "nlsim", "": "gsim", "": "ngsim", "": "lg", "": "ntlg", "": "gl", "": "ntgl", "": "pr", "": "npr", "": "sc", "": "nsc", "": "prcue", "": "nprcue", "": "sccue", "": "nsccue", "": "prsim", "": "scsim", "": "NotSucceedsTilde", "": "sub", "": "nsub", "": "vnsub", "": "sup", "": "nsup", "": "vnsup", "": "sube", "": "nsube", "": "supe", "": "nsupe", "": "vsubne", "": "subne", "": "vsupne", "": "supne", "": "cupdot", "": "uplus", "": "sqsub", "": "NotSquareSubset", "": "sqsup", "": "NotSquareSuperset", "": "sqsube", "": "nsqsube", "": "sqsupe", "": "nsqsupe", "": "sqcap", "": "sqcaps", "": "sqcup", "": "sqcups", "": "oplus", "": "ominus", "": "otimes", "": "osol", "": "odot", "": "ocir", "": "oast", "": "odash", "": "plusb", "": "minusb", "": "timesb", "": "sdotb", "": "vdash", "": "nvdash", "": "dashv", "": "top", "": "bot", "": "models", "": "vDash", "": "nvDash", "": "Vdash", "": "nVdash", "": "Vvdash", "": "VDash", "": "nVDash", "": "prurel", "": "vltri", "": "nltri", "": "vrtri", "": "nrtri", "": "ltrie", "": "nltrie", "": "nvltrie", "": "rtrie", "": "nrtrie", "": "nvrtrie", "": "origof", "": "imof", "": "mumap", "": "hercon", "": "intcal", "": "veebar", "": "barvee", "": "angrtvb", "": "lrtri", "": "Wedge", "": "Vee", "": "xcap", "": "xcup", "": "diam", "": "sdot", "": "Star", "": "divonx", "": "bowtie", "": "ltimes", "": "rtimes", "": "lthree", "": "rthree", "": "bsime", "": "cuvee", "": "cuwed", "": "Sub", "": "Sup", "": "Cap", "": "Cup", "": "fork", "": "epar", "": "ltdot", "": "gtdot", "": "Ll", "": "nLl", "": "Gg", "": "nGg", "": "lesg", "": "leg", "": "gel", "": "gesl", "": "cuepr", "": "cuesc", "": "lnsim", "": "gnsim", "": "prnsim", "": "scnsim", "": "vellip", "": "ctdot", "": "utdot", "": "dtdot", "": "disin", "": "isinsv", "": "isins", "": "isindot", "": "notindot", "": "notinvc", "": "notinvb", "": "isinE", "": "notinE", "": "nisd", "": "xnis", "": "nis", "": "notnivc", "": "notnivb", "": "barwed", "": "Barwed", "": "drcrop", "": "dlcrop", "": "urcrop", "": "ulcrop", "": "bnot", "": "profline", "": "profsurf", "": "telrec", "": "target", "": "ulcorn", "": "urcorn", "": "dlcorn", "": "drcorn", "": "frown", "": "smile", "": "cylcty", "": "profalar", "": "topbot", "": "ovbar", "": "solbar", "": "angzarr", "": "lmoust", "": "rmoust", "": "tbrk", "": "bbrk", "": "bbrktbrk", "": "OverParenthesis", "": "UnderParenthesis", "": "OverBrace", "": "UnderBrace", "": "trpezium", "": "elinters", "": "blank", "": "boxh", "": "boxv", "": "boxdr", "": "boxdl", "": "boxur", "": "boxul", "": "boxvr", "": "boxvl", "": "boxhd", "": "boxhu", "": "boxvh", "": "boxH", "": "boxV", "": "boxdR", "": "boxDr", "": "boxDR", "": "boxdL", "": "boxDl", "": "boxDL", "": "boxuR", "": "boxUr", "": "boxUR", "": "boxuL", "": "boxUl", "": "boxUL", "": "boxvR", "": "boxVr", "": "boxVR", "": "boxvL", "": "boxVl", "": "boxVL", "": "boxHd", "": "boxhD", "": "boxHD", "": "boxHu", "": "boxhU", "": "boxHU", "": "boxvH", "": "boxVh", "": "boxVH", "": "uhblk", "": "lhblk", "": "block", "": "blk14", "": "blk12", "": "blk34", "": "squ", "": "squf", "": "EmptyVerySmallSquare", "": "rect", "": "marker", "": "fltns", "": "xutri", "": "utrif", "": "utri", "": "rtrif", "": "rtri", "": "xdtri", "": "dtrif", "": "dtri", "": "ltrif", "": "ltri", "": "loz", "": "cir", "": "tridot", "": "xcirc", "": "ultri", "": "urtri", "": "lltri", "": "EmptySmallSquare", "": "FilledSmallSquare", "": "starf", "": "star", "": "phone", "": "female", "": "male", "": "spades", "": "clubs", "": "hearts", "": "diams", "": "sung", "": "check", "": "cross", "": "malt", "": "sext", "": "VerticalSeparator", "": "bsolhsub", "": "suphsol", "": "xlarr", "": "xrarr", "": "xharr", "": "xlArr", "": "xrArr", "": "xhArr", "": "xmap", "": "dzigrarr", "": "nvlArr", "": "nvrArr", "": "nvHarr", "": "Map", "": "lbarr", "": "rbarr", "": "lBarr", "": "rBarr", "": "RBarr", "": "DDotrahd", "": "UpArrowBar", "": "DownArrowBar", "": "Rarrtl", "": "latail", "": "ratail", "": "lAtail", "": "rAtail", "": "larrfs", "": "rarrfs", "": "larrbfs", "": "rarrbfs", "": "nwarhk", "": "nearhk", "": "searhk", "": "swarhk", "": "nwnear", "": "toea", "": "tosa", "": "swnwar", "": "rarrc", "": "nrarrc", "": "cudarrr", "": "ldca", "": "rdca", "": "cudarrl", "": "larrpl", "": "curarrm", "": "cularrp", "": "rarrpl", "": "harrcir", "": "Uarrocir", "": "lurdshar", "": "ldrushar", "": "LeftRightVector", "": "RightUpDownVector", "": "DownLeftRightVector", "": "LeftUpDownVector", "": "LeftVectorBar", "": "RightVectorBar", "": "RightUpVectorBar", "": "RightDownVectorBar", "": "DownLeftVectorBar", "": "DownRightVectorBar", "": "LeftUpVectorBar", "": "LeftDownVectorBar", "": "LeftTeeVector", "": "RightTeeVector", "": "RightUpTeeVector", "": "RightDownTeeVector", "": "DownLeftTeeVector", "": "DownRightTeeVector", "": "LeftUpTeeVector", "": "LeftDownTeeVector", "": "lHar", "": "uHar", "": "rHar", "": "dHar", "": "luruhar", "": "ldrdhar", "": "ruluhar", "": "rdldhar", "": "lharul", "": "llhard", "": "rharul", "": "lrhard", "": "udhar", "": "duhar", "": "RoundImplies", "": "erarr", "": "simrarr", "": "larrsim", "": "rarrsim", "": "rarrap", "": "ltlarr", "": "gtrarr", "": "subrarr", "": "suplarr", "": "lfisht", "": "rfisht", "": "ufisht", "": "dfisht", "": "vzigzag", "": "vangrt", "": "angrtvbd", "": "ange", "": "range", "": "dwangle", "": "uwangle", "": "angmsdaa", "": "angmsdab", "": "angmsdac", "": "angmsdad", "": "angmsdae", "": "angmsdaf", "": "angmsdag", "": "angmsdah", "": "bemptyv", "": "demptyv", "": "cemptyv", "": "raemptyv", "": "laemptyv", "": "ohbar", "": "omid", "": "opar", "": "operp", "": "olcross", "": "odsold", "": "olcir", "": "ofcir", "": "olt", "": "ogt", "": "cirscir", "": "cirE", "": "solb", "": "bsolb", "": "boxbox", "": "trisb", "": "rtriltri", "": "LeftTriangleBar", "": "NotLeftTriangleBar", "": "RightTriangleBar", "": "NotRightTriangleBar", "": "iinfin", "": "infintie", "": "nvinfin", "": "eparsl", "": "smeparsl", "": "eqvparsl", "": "lozf", "": "RuleDelayed", "": "dsol", "": "xodot", "": "xoplus", "": "xotime", "": "xuplus", "": "xsqcup", "": "fpartint", "": "cirfnint", "": "awint", "": "rppolint", "": "scpolint", "": "npolint", "": "pointint", "": "quatint", "": "intlarhk", "": "pluscir", "": "plusacir", "": "simplus", "": "plusdu", "": "plussim", "": "plustwo", "": "mcomma", "": "minusdu", "": "loplus", "": "roplus", "": "Cross", "": "timesd", "": "timesbar", "": "smashp", "": "lotimes", "": "rotimes", "": "otimesas", "": "Otimes", "": "odiv", "": "triplus", "": "triminus", "": "tritime", "": "iprod", "": "amalg", "": "capdot", "": "ncup", "": "ncap", "": "capand", "": "cupor", "": "cupcap", "": "capcup", "": "cupbrcap", "": "capbrcup", "": "cupcup", "": "capcap", "": "ccups", "": "ccaps", "": "ccupssm", "": "And", "": "Or", "": "andand", "": "oror", "": "orslope", "": "andslope", "": "andv", "": "orv", "": "andd", "": "ord", "": "wedbar", "": "sdote", "": "simdot", "": "congdot", "": "ncongdot", "": "easter", "": "apacir", "": "apE", "": "napE", "": "eplus", "": "pluse", "": "Esim", "": "eDDot", "": "equivDD", "": "ltcir", "": "gtcir", "": "ltquest", "": "gtquest", "": "les", "": "nles", "": "ges", "": "nges", "": "lesdot", "": "gesdot", "": "lesdoto", "": "gesdoto", "": "lesdotor", "": "gesdotol", "": "lap", "": "gap", "": "lne", "": "gne", "": "lnap", "": "gnap", "": "lEg", "": "gEl", "": "lsime", "": "gsime", "": "lsimg", "": "gsiml", "": "lgE", "": "glE", "": "lesges", "": "gesles", "": "els", "": "egs", "": "elsdot", "": "egsdot", "": "el", "": "eg", "": "siml", "": "simg", "": "simlE", "": "simgE", "": "LessLess", "": "NotNestedLessLess", "": "GreaterGreater", "": "NotNestedGreaterGreater", "": "glj", "": "gla", "": "ltcc", "": "gtcc", "": "lescc", "": "gescc", "": "smt", "": "lat", "": "smte", "": "smtes", "": "late", "": "lates", "": "bumpE", "": "pre", "": "npre", "": "sce", "": "nsce", "": "prE", "": "scE", "": "prnE", "": "scnE", "": "prap", "": "scap", "": "prnap", "": "scnap", "": "Pr", "": "Sc", "": "subdot", "": "supdot", "": "subplus", "": "supplus", "": "submult", "": "supmult", "": "subedot", "": "supedot", "": "subE", "": "nsubE", "": "supE", "": "nsupE", "": "subsim", "": "supsim", "": "vsubnE", "": "subnE", "": "vsupnE", "": "supnE", "": "csub", "": "csup", "": "csube", "": "csupe", "": "subsup", "": "supsub", "": "subsub", "": "supsup", "": "suphsub", "": "supdsub", "": "forkv", "": "topfork", "": "mlcp", "": "Dashv", "": "Vdashl", "": "Barv", "": "vBar", "": "vBarv", "": "Vbar", "": "Not", "": "bNot", "": "rnmid", "": "cirmid", "": "midcir", "": "topcir", "": "nhpar", "": "parsim", "": "parsl", "": "nparsl", "": "flat", "": "natur", "": "sharp", "": "curren", "": "cent", "$": "dollar", "": "pound", "": "yen", "": "euro", "": "sup1", "": "half", "": "frac13", "": "frac14", "": "frac15", "": "frac16", "": "frac18", "": "sup2", "": "frac23", "": "frac25", "": "sup3", "": "frac34", "": "frac35", "": "frac38", "": "frac45", "": "frac56", "": "frac58", "": "frac78", "": "ascr", "": "aopf", "": "afr", "": "Aopf", "": "Afr", "": "Ascr", "": "ordf", "": "aacute", "": "Aacute", "": "agrave", "": "Agrave", "": "abreve", "": "Abreve", "": "acirc", "": "Acirc", "": "aring", "": "angst", "": "auml", "": "Auml", "": "atilde", "": "Atilde", "": "aogon", "": "Aogon", "": "amacr", "": "Amacr", "": "aelig", "": "AElig", "": "bscr", "": "bopf", "": "bfr", "": "Bopf", "": "Bscr", "": "Bfr", "": "cfr", "": "cscr", "": "copf", "": "Cfr", "": "Cscr", "": "Copf", "": "cacute", "": "Cacute", "": "ccirc", "": "Ccirc", "": "ccaron", "": "Ccaron", "": "cdot", "": "Cdot", "": "ccedil", "": "Ccedil", "": "incare", "": "dfr", "": "dd", "": "dopf", "": "dscr", "": "Dscr", "": "Dfr", "": "DD", "": "Dopf", "": "dcaron", "": "Dcaron", "": "dstrok", "": "Dstrok", "": "eth", "": "ETH", "": "ee", "": "escr", "": "efr", "": "eopf", "": "Escr", "": "Efr", "": "Eopf", "": "eacute", "": "Eacute", "": "egrave", "": "Egrave", "": "ecirc", "": "Ecirc", "": "ecaron", "": "Ecaron", "": "euml", "": "Euml", "": "edot", "": "Edot", "": "eogon", "": "Eogon", "": "emacr", "": "Emacr", "": "ffr", "": "fopf", "": "fscr", "": "Ffr", "": "Fopf", "": "Fscr", "": "fflig", "": "ffilig", "": "ffllig", "": "filig", "fj": "fjlig", "": "fllig", "": "fnof", "": "gscr", "": "gopf", "": "gfr", "": "Gscr", "": "Gopf", "": "Gfr", "": "gacute", "": "gbreve", "": "Gbreve", "": "gcirc", "": "Gcirc", "": "gdot", "": "Gdot", "": "Gcedil", "": "hfr", "": "planckh", "": "hscr", "": "hopf", "": "Hscr", "": "Hfr", "": "Hopf", "": "hcirc", "": "Hcirc", "": "hbar", "": "hstrok", "": "Hstrok", "": "iopf", "": "ifr", "": "iscr", "": "ii", "": "Iopf", "": "Iscr", "": "Im", "": "iacute", "": "Iacute", "": "igrave", "": "Igrave", "": "icirc", "": "Icirc", "": "iuml", "": "Iuml", "": "itilde", "": "Itilde", "": "Idot", "": "iogon", "": "Iogon", "": "imacr", "": "Imacr", "": "ijlig", "": "IJlig", "": "imath", "": "jscr", "": "jopf", "": "jfr", "": "Jscr", "": "Jfr", "": "Jopf", "": "jcirc", "": "Jcirc", "": "jmath", "": "kopf", "": "kscr", "": "kfr", "": "Kscr", "": "Kopf", "": "Kfr", "": "kcedil", "": "Kcedil", "": "lfr", "": "lscr", "": "ell", "": "lopf", "": "Lscr", "": "Lfr", "": "Lopf", "": "lacute", "": "Lacute", "": "lcaron", "": "Lcaron", "": "lcedil", "": "Lcedil", "": "lstrok", "": "Lstrok", "": "lmidot", "": "Lmidot", "": "mfr", "": "mopf", "": "mscr", "": "Mfr", "": "Mopf", "": "Mscr", "": "nfr", "": "nopf", "": "nscr", "": "Nopf", "": "Nscr", "": "Nfr", "": "nacute", "": "Nacute", "": "ncaron", "": "Ncaron", "": "ntilde", "": "Ntilde", "": "ncedil", "": "Ncedil", "": "numero", "": "eng", "": "ENG", "": "oopf", "": "ofr", "": "oscr", "": "Oscr", "": "Ofr", "": "Oopf", "": "ordm", "": "oacute", "": "Oacute", "": "ograve", "": "Ograve", "": "ocirc", "": "Ocirc", "": "ouml", "": "Ouml", "": "odblac", "": "Odblac", "": "otilde", "": "Otilde", "": "oslash", "": "Oslash", "": "omacr", "": "Omacr", "": "oelig", "": "OElig", "": "pfr", "": "pscr", "": "popf", "": "Popf", "": "Pfr", "": "Pscr", "": "qopf", "": "qfr", "": "qscr", "": "Qscr", "": "Qfr", "": "Qopf", "": "kgreen", "": "rfr", "": "ropf", "": "rscr", "": "Rscr", "": "Re", "": "Ropf", "": "racute", "": "Racute", "": "rcaron", "": "Rcaron", "": "rcedil", "": "Rcedil", "": "sopf", "": "sscr", "": "sfr", "": "Sopf", "": "Sfr", "": "Sscr", "": "oS", "": "sacute", "": "Sacute", "": "scirc", "": "Scirc", "": "scaron", "": "Scaron", "": "scedil", "": "Scedil", "": "szlig", "": "tfr", "": "tscr", "": "topf", "": "Tscr", "": "Tfr", "": "Topf", "": "tcaron", "": "Tcaron", "": "tcedil", "": "Tcedil", "": "trade", "": "tstrok", "": "Tstrok", "": "uscr", "": "uopf", "": "ufr", "": "Uopf", "": "Ufr", "": "Uscr", "": "uacute", "": "Uacute", "": "ugrave", "": "Ugrave", "": "ubreve", "": "Ubreve", "": "ucirc", "": "Ucirc", "": "uring", "": "Uring", "": "uuml", "": "Uuml", "": "udblac", "": "Udblac", "": "utilde", "": "Utilde", "": "uogon", "": "Uogon", "": "umacr", "": "Umacr", "": "vfr", "": "vopf", "": "vscr", "": "Vfr", "": "Vopf", "": "Vscr", "": "wopf", "": "wscr", "": "wfr", "": "Wscr", "": "Wopf", "": "Wfr", "": "wcirc", "": "Wcirc", "": "xfr", "": "xscr", "": "xopf", "": "Xopf", "": "Xfr", "": "Xscr", "": "yfr", "": "yscr", "": "yopf", "": "Yscr", "": "Yfr", "": "Yopf", "": "yacute", "": "Yacute", "": "ycirc", "": "Ycirc", "": "yuml", "": "Yuml", "": "zscr", "": "zfr", "": "zopf", "": "Zfr", "": "Zopf", "": "Zscr", "": "zacute", "": "Zacute", "": "zcaron", "": "Zcaron", "": "zdot", "": "Zdot", "": "imped", "": "thorn", "": "THORN", "": "napos", "": "alpha", "": "Alpha", "": "beta", "": "Beta", "": "gamma", "": "Gamma", "": "delta", "": "Delta", "": "epsi", "": "epsiv", "": "Epsilon", "": "gammad", "": "Gammad", "": "zeta", "": "Zeta", "": "eta", "": "Eta", "": "theta", "": "thetav", "": "Theta", "": "iota", "": "Iota", "": "kappa", "": "kappav", "": "Kappa", "": "lambda", "": "Lambda", "": "mu", "": "micro", "": "Mu", "": "nu", "": "Nu", "": "xi", "": "Xi", "": "omicron", "": "Omicron", "": "pi", "": "piv", "": "Pi", "": "rho", "": "rhov", "": "Rho", "": "sigma", "": "Sigma", "": "sigmaf", "": "tau", "": "Tau", "": "upsi", "": "Upsilon", "": "Upsi", "": "phi", "": "phiv", "": "Phi", "": "chi", "": "Chi", "": "psi", "": "Psi", "": "omega", "": "ohm", "": "acy", "": "Acy", "": "bcy", "": "Bcy", "": "vcy", "": "Vcy", "": "gcy", "": "Gcy", "": "gjcy", "": "GJcy", "": "dcy", "": "Dcy", "": "djcy", "": "DJcy", "": "iecy", "": "IEcy", "": "iocy", "": "IOcy", "": "jukcy", "": "Jukcy", "": "zhcy", "": "ZHcy", "": "zcy", "": "Zcy", "": "dscy", "": "DScy", "": "icy", "": "Icy", "": "iukcy", "": "Iukcy", "": "yicy", "": "YIcy", "": "jcy", "": "Jcy", "": "jsercy", "": "Jsercy", "": "kcy", "": "Kcy", "": "kjcy", "": "KJcy", "": "lcy", "": "Lcy", "": "ljcy", "": "LJcy", "": "mcy", "": "Mcy", "": "ncy", "": "Ncy", "": "njcy", "": "NJcy", "": "ocy", "": "Ocy", "": "pcy", "": "Pcy", "": "rcy", "": "Rcy", "": "scy", "": "Scy", "": "tcy", "": "Tcy", "": "tshcy", "": "TSHcy", "": "ucy", "": "Ucy", "": "ubrcy", "": "Ubrcy", "": "fcy", "": "Fcy", "": "khcy", "": "KHcy", "": "tscy", "": "TScy", "": "chcy", "": "CHcy", "": "dzcy", "": "DZcy", "": "shcy", "": "SHcy", "": "shchcy", "": "SHCHcy", "": "hardcy", "": "HARDcy", "": "ycy", "": "Ycy", "": "softcy", "": "SOFTcy", "": "ecy", "": "Ecy", "": "yucy", "": "YUcy", "": "yacy", "": "YAcy", "": "aleph", "": "beth", "": "gimel", "": "daleth" };
      var regexEscape = /["&'<>`]/g;
      var escapeMap = {
        '"': "&quot;",
        "&": "&amp;",
        "'": "&#x27;",
        "<": "&lt;",
        // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
        // following is not strictly necessary unless its part of a tag or an
        // unquoted attribute value. Were only escaping it to support those
        // situations, and for XML support.
        ">": "&gt;",
        // In Internet Explorer  8, the backtick character can be used
        // to break out of (un)quoted attribute values or HTML comments.
        // See http://html5sec.org/#102, http://html5sec.org/#108, and
        // http://html5sec.org/#133.
        "`": "&#x60;"
      };
      var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
      var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
      var decodeMap = { "aacute": "", "Aacute": "", "abreve": "", "Abreve": "", "ac": "", "acd": "", "acE": "", "acirc": "", "Acirc": "", "acute": "", "acy": "", "Acy": "", "aelig": "", "AElig": "", "af": "", "afr": "", "Afr": "", "agrave": "", "Agrave": "", "alefsym": "", "aleph": "", "alpha": "", "Alpha": "", "amacr": "", "Amacr": "", "amalg": "", "amp": "&", "AMP": "&", "and": "", "And": "", "andand": "", "andd": "", "andslope": "", "andv": "", "ang": "", "ange": "", "angle": "", "angmsd": "", "angmsdaa": "", "angmsdab": "", "angmsdac": "", "angmsdad": "", "angmsdae": "", "angmsdaf": "", "angmsdag": "", "angmsdah": "", "angrt": "", "angrtvb": "", "angrtvbd": "", "angsph": "", "angst": "", "angzarr": "", "aogon": "", "Aogon": "", "aopf": "", "Aopf": "", "ap": "", "apacir": "", "ape": "", "apE": "", "apid": "", "apos": "'", "ApplyFunction": "", "approx": "", "approxeq": "", "aring": "", "Aring": "", "ascr": "", "Ascr": "", "Assign": "", "ast": "*", "asymp": "", "asympeq": "", "atilde": "", "Atilde": "", "auml": "", "Auml": "", "awconint": "", "awint": "", "backcong": "", "backepsilon": "", "backprime": "", "backsim": "", "backsimeq": "", "Backslash": "", "Barv": "", "barvee": "", "barwed": "", "Barwed": "", "barwedge": "", "bbrk": "", "bbrktbrk": "", "bcong": "", "bcy": "", "Bcy": "", "bdquo": "", "becaus": "", "because": "", "Because": "", "bemptyv": "", "bepsi": "", "bernou": "", "Bernoullis": "", "beta": "", "Beta": "", "beth": "", "between": "", "bfr": "", "Bfr": "", "bigcap": "", "bigcirc": "", "bigcup": "", "bigodot": "", "bigoplus": "", "bigotimes": "", "bigsqcup": "", "bigstar": "", "bigtriangledown": "", "bigtriangleup": "", "biguplus": "", "bigvee": "", "bigwedge": "", "bkarow": "", "blacklozenge": "", "blacksquare": "", "blacktriangle": "", "blacktriangledown": "", "blacktriangleleft": "", "blacktriangleright": "", "blank": "", "blk12": "", "blk14": "", "blk34": "", "block": "", "bne": "=", "bnequiv": "", "bnot": "", "bNot": "", "bopf": "", "Bopf": "", "bot": "", "bottom": "", "bowtie": "", "boxbox": "", "boxdl": "", "boxdL": "", "boxDl": "", "boxDL": "", "boxdr": "", "boxdR": "", "boxDr": "", "boxDR": "", "boxh": "", "boxH": "", "boxhd": "", "boxhD": "", "boxHd": "", "boxHD": "", "boxhu": "", "boxhU": "", "boxHu": "", "boxHU": "", "boxminus": "", "boxplus": "", "boxtimes": "", "boxul": "", "boxuL": "", "boxUl": "", "boxUL": "", "boxur": "", "boxuR": "", "boxUr": "", "boxUR": "", "boxv": "", "boxV": "", "boxvh": "", "boxvH": "", "boxVh": "", "boxVH": "", "boxvl": "", "boxvL": "", "boxVl": "", "boxVL": "", "boxvr": "", "boxvR": "", "boxVr": "", "boxVR": "", "bprime": "", "breve": "", "Breve": "", "brvbar": "", "bscr": "", "Bscr": "", "bsemi": "", "bsim": "", "bsime": "", "bsol": "\\", "bsolb": "", "bsolhsub": "", "bull": "", "bullet": "", "bump": "", "bumpe": "", "bumpE": "", "bumpeq": "", "Bumpeq": "", "cacute": "", "Cacute": "", "cap": "", "Cap": "", "capand": "", "capbrcup": "", "capcap": "", "capcup": "", "capdot": "", "CapitalDifferentialD": "", "caps": "", "caret": "", "caron": "", "Cayleys": "", "ccaps": "", "ccaron": "", "Ccaron": "", "ccedil": "", "Ccedil": "", "ccirc": "", "Ccirc": "", "Cconint": "", "ccups": "", "ccupssm": "", "cdot": "", "Cdot": "", "cedil": "", "Cedilla": "", "cemptyv": "", "cent": "", "centerdot": "", "CenterDot": "", "cfr": "", "Cfr": "", "chcy": "", "CHcy": "", "check": "", "checkmark": "", "chi": "", "Chi": "", "cir": "", "circ": "", "circeq": "", "circlearrowleft": "", "circlearrowright": "", "circledast": "", "circledcirc": "", "circleddash": "", "CircleDot": "", "circledR": "", "circledS": "", "CircleMinus": "", "CirclePlus": "", "CircleTimes": "", "cire": "", "cirE": "", "cirfnint": "", "cirmid": "", "cirscir": "", "ClockwiseContourIntegral": "", "CloseCurlyDoubleQuote": "", "CloseCurlyQuote": "", "clubs": "", "clubsuit": "", "colon": ":", "Colon": "", "colone": "", "Colone": "", "coloneq": "", "comma": ",", "commat": "@", "comp": "", "compfn": "", "complement": "", "complexes": "", "cong": "", "congdot": "", "Congruent": "", "conint": "", "Conint": "", "ContourIntegral": "", "copf": "", "Copf": "", "coprod": "", "Coproduct": "", "copy": "", "COPY": "", "copysr": "", "CounterClockwiseContourIntegral": "", "crarr": "", "cross": "", "Cross": "", "cscr": "", "Cscr": "", "csub": "", "csube": "", "csup": "", "csupe": "", "ctdot": "", "cudarrl": "", "cudarrr": "", "cuepr": "", "cuesc": "", "cularr": "", "cularrp": "", "cup": "", "Cup": "", "cupbrcap": "", "cupcap": "", "CupCap": "", "cupcup": "", "cupdot": "", "cupor": "", "cups": "", "curarr": "", "curarrm": "", "curlyeqprec": "", "curlyeqsucc": "", "curlyvee": "", "curlywedge": "", "curren": "", "curvearrowleft": "", "curvearrowright": "", "cuvee": "", "cuwed": "", "cwconint": "", "cwint": "", "cylcty": "", "dagger": "", "Dagger": "", "daleth": "", "darr": "", "dArr": "", "Darr": "", "dash": "", "dashv": "", "Dashv": "", "dbkarow": "", "dblac": "", "dcaron": "", "Dcaron": "", "dcy": "", "Dcy": "", "dd": "", "DD": "", "ddagger": "", "ddarr": "", "DDotrahd": "", "ddotseq": "", "deg": "", "Del": "", "delta": "", "Delta": "", "demptyv": "", "dfisht": "", "dfr": "", "Dfr": "", "dHar": "", "dharl": "", "dharr": "", "DiacriticalAcute": "", "DiacriticalDot": "", "DiacriticalDoubleAcute": "", "DiacriticalGrave": "`", "DiacriticalTilde": "", "diam": "", "diamond": "", "Diamond": "", "diamondsuit": "", "diams": "", "die": "", "DifferentialD": "", "digamma": "", "disin": "", "div": "", "divide": "", "divideontimes": "", "divonx": "", "djcy": "", "DJcy": "", "dlcorn": "", "dlcrop": "", "dollar": "$", "dopf": "", "Dopf": "", "dot": "", "Dot": "", "DotDot": "", "doteq": "", "doteqdot": "", "DotEqual": "", "dotminus": "", "dotplus": "", "dotsquare": "", "doublebarwedge": "", "DoubleContourIntegral": "", "DoubleDot": "", "DoubleDownArrow": "", "DoubleLeftArrow": "", "DoubleLeftRightArrow": "", "DoubleLeftTee": "", "DoubleLongLeftArrow": "", "DoubleLongLeftRightArrow": "", "DoubleLongRightArrow": "", "DoubleRightArrow": "", "DoubleRightTee": "", "DoubleUpArrow": "", "DoubleUpDownArrow": "", "DoubleVerticalBar": "", "downarrow": "", "Downarrow": "", "DownArrow": "", "DownArrowBar": "", "DownArrowUpArrow": "", "DownBreve": "", "downdownarrows": "", "downharpoonleft": "", "downharpoonright": "", "DownLeftRightVector": "", "DownLeftTeeVector": "", "DownLeftVector": "", "DownLeftVectorBar": "", "DownRightTeeVector": "", "DownRightVector": "", "DownRightVectorBar": "", "DownTee": "", "DownTeeArrow": "", "drbkarow": "", "drcorn": "", "drcrop": "", "dscr": "", "Dscr": "", "dscy": "", "DScy": "", "dsol": "", "dstrok": "", "Dstrok": "", "dtdot": "", "dtri": "", "dtrif": "", "duarr": "", "duhar": "", "dwangle": "", "dzcy": "", "DZcy": "", "dzigrarr": "", "eacute": "", "Eacute": "", "easter": "", "ecaron": "", "Ecaron": "", "ecir": "", "ecirc": "", "Ecirc": "", "ecolon": "", "ecy": "", "Ecy": "", "eDDot": "", "edot": "", "eDot": "", "Edot": "", "ee": "", "efDot": "", "efr": "", "Efr": "", "eg": "", "egrave": "", "Egrave": "", "egs": "", "egsdot": "", "el": "", "Element": "", "elinters": "", "ell": "", "els": "", "elsdot": "", "emacr": "", "Emacr": "", "empty": "", "emptyset": "", "EmptySmallSquare": "", "emptyv": "", "EmptyVerySmallSquare": "", "emsp": "", "emsp13": "", "emsp14": "", "eng": "", "ENG": "", "ensp": "", "eogon": "", "Eogon": "", "eopf": "", "Eopf": "", "epar": "", "eparsl": "", "eplus": "", "epsi": "", "epsilon": "", "Epsilon": "", "epsiv": "", "eqcirc": "", "eqcolon": "", "eqsim": "", "eqslantgtr": "", "eqslantless": "", "Equal": "", "equals": "=", "EqualTilde": "", "equest": "", "Equilibrium": "", "equiv": "", "equivDD": "", "eqvparsl": "", "erarr": "", "erDot": "", "escr": "", "Escr": "", "esdot": "", "esim": "", "Esim": "", "eta": "", "Eta": "", "eth": "", "ETH": "", "euml": "", "Euml": "", "euro": "", "excl": "!", "exist": "", "Exists": "", "expectation": "", "exponentiale": "", "ExponentialE": "", "fallingdotseq": "", "fcy": "", "Fcy": "", "female": "", "ffilig": "", "fflig": "", "ffllig": "", "ffr": "", "Ffr": "", "filig": "", "FilledSmallSquare": "", "FilledVerySmallSquare": "", "fjlig": "fj", "flat": "", "fllig": "", "fltns": "", "fnof": "", "fopf": "", "Fopf": "", "forall": "", "ForAll": "", "fork": "", "forkv": "", "Fouriertrf": "", "fpartint": "", "frac12": "", "frac13": "", "frac14": "", "frac15": "", "frac16": "", "frac18": "", "frac23": "", "frac25": "", "frac34": "", "frac35": "", "frac38": "", "frac45": "", "frac56": "", "frac58": "", "frac78": "", "frasl": "", "frown": "", "fscr": "", "Fscr": "", "gacute": "", "gamma": "", "Gamma": "", "gammad": "", "Gammad": "", "gap": "", "gbreve": "", "Gbreve": "", "Gcedil": "", "gcirc": "", "Gcirc": "", "gcy": "", "Gcy": "", "gdot": "", "Gdot": "", "ge": "", "gE": "", "gel": "", "gEl": "", "geq": "", "geqq": "", "geqslant": "", "ges": "", "gescc": "", "gesdot": "", "gesdoto": "", "gesdotol": "", "gesl": "", "gesles": "", "gfr": "", "Gfr": "", "gg": "", "Gg": "", "ggg": "", "gimel": "", "gjcy": "", "GJcy": "", "gl": "", "gla": "", "glE": "", "glj": "", "gnap": "", "gnapprox": "", "gne": "", "gnE": "", "gneq": "", "gneqq": "", "gnsim": "", "gopf": "", "Gopf": "", "grave": "`", "GreaterEqual": "", "GreaterEqualLess": "", "GreaterFullEqual": "", "GreaterGreater": "", "GreaterLess": "", "GreaterSlantEqual": "", "GreaterTilde": "", "gscr": "", "Gscr": "", "gsim": "", "gsime": "", "gsiml": "", "gt": ">", "Gt": "", "GT": ">", "gtcc": "", "gtcir": "", "gtdot": "", "gtlPar": "", "gtquest": "", "gtrapprox": "", "gtrarr": "", "gtrdot": "", "gtreqless": "", "gtreqqless": "", "gtrless": "", "gtrsim": "", "gvertneqq": "", "gvnE": "", "Hacek": "", "hairsp": "", "half": "", "hamilt": "", "hardcy": "", "HARDcy": "", "harr": "", "hArr": "", "harrcir": "", "harrw": "", "Hat": "^", "hbar": "", "hcirc": "", "Hcirc": "", "hearts": "", "heartsuit": "", "hellip": "", "hercon": "", "hfr": "", "Hfr": "", "HilbertSpace": "", "hksearow": "", "hkswarow": "", "hoarr": "", "homtht": "", "hookleftarrow": "", "hookrightarrow": "", "hopf": "", "Hopf": "", "horbar": "", "HorizontalLine": "", "hscr": "", "Hscr": "", "hslash": "", "hstrok": "", "Hstrok": "", "HumpDownHump": "", "HumpEqual": "", "hybull": "", "hyphen": "", "iacute": "", "Iacute": "", "ic": "", "icirc": "", "Icirc": "", "icy": "", "Icy": "", "Idot": "", "iecy": "", "IEcy": "", "iexcl": "", "iff": "", "ifr": "", "Ifr": "", "igrave": "", "Igrave": "", "ii": "", "iiiint": "", "iiint": "", "iinfin": "", "iiota": "", "ijlig": "", "IJlig": "", "Im": "", "imacr": "", "Imacr": "", "image": "", "ImaginaryI": "", "imagline": "", "imagpart": "", "imath": "", "imof": "", "imped": "", "Implies": "", "in": "", "incare": "", "infin": "", "infintie": "", "inodot": "", "int": "", "Int": "", "intcal": "", "integers": "", "Integral": "", "intercal": "", "Intersection": "", "intlarhk": "", "intprod": "", "InvisibleComma": "", "InvisibleTimes": "", "iocy": "", "IOcy": "", "iogon": "", "Iogon": "", "iopf": "", "Iopf": "", "iota": "", "Iota": "", "iprod": "", "iquest": "", "iscr": "", "Iscr": "", "isin": "", "isindot": "", "isinE": "", "isins": "", "isinsv": "", "isinv": "", "it": "", "itilde": "", "Itilde": "", "iukcy": "", "Iukcy": "", "iuml": "", "Iuml": "", "jcirc": "", "Jcirc": "", "jcy": "", "Jcy": "", "jfr": "", "Jfr": "", "jmath": "", "jopf": "", "Jopf": "", "jscr": "", "Jscr": "", "jsercy": "", "Jsercy": "", "jukcy": "", "Jukcy": "", "kappa": "", "Kappa": "", "kappav": "", "kcedil": "", "Kcedil": "", "kcy": "", "Kcy": "", "kfr": "", "Kfr": "", "kgreen": "", "khcy": "", "KHcy": "", "kjcy": "", "KJcy": "", "kopf": "", "Kopf": "", "kscr": "", "Kscr": "", "lAarr": "", "lacute": "", "Lacute": "", "laemptyv": "", "lagran": "", "lambda": "", "Lambda": "", "lang": "", "Lang": "", "langd": "", "langle": "", "lap": "", "Laplacetrf": "", "laquo": "", "larr": "", "lArr": "", "Larr": "", "larrb": "", "larrbfs": "", "larrfs": "", "larrhk": "", "larrlp": "", "larrpl": "", "larrsim": "", "larrtl": "", "lat": "", "latail": "", "lAtail": "", "late": "", "lates": "", "lbarr": "", "lBarr": "", "lbbrk": "", "lbrace": "{", "lbrack": "[", "lbrke": "", "lbrksld": "", "lbrkslu": "", "lcaron": "", "Lcaron": "", "lcedil": "", "Lcedil": "", "lceil": "", "lcub": "{", "lcy": "", "Lcy": "", "ldca": "", "ldquo": "", "ldquor": "", "ldrdhar": "", "ldrushar": "", "ldsh": "", "le": "", "lE": "", "LeftAngleBracket": "", "leftarrow": "", "Leftarrow": "", "LeftArrow": "", "LeftArrowBar": "", "LeftArrowRightArrow": "", "leftarrowtail": "", "LeftCeiling": "", "LeftDoubleBracket": "", "LeftDownTeeVector": "", "LeftDownVector": "", "LeftDownVectorBar": "", "LeftFloor": "", "leftharpoondown": "", "leftharpoonup": "", "leftleftarrows": "", "leftrightarrow": "", "Leftrightarrow": "", "LeftRightArrow": "", "leftrightarrows": "", "leftrightharpoons": "", "leftrightsquigarrow": "", "LeftRightVector": "", "LeftTee": "", "LeftTeeArrow": "", "LeftTeeVector": "", "leftthreetimes": "", "LeftTriangle": "", "LeftTriangleBar": "", "LeftTriangleEqual": "", "LeftUpDownVector": "", "LeftUpTeeVector": "", "LeftUpVector": "", "LeftUpVectorBar": "", "LeftVector": "", "LeftVectorBar": "", "leg": "", "lEg": "", "leq": "", "leqq": "", "leqslant": "", "les": "", "lescc": "", "lesdot": "", "lesdoto": "", "lesdotor": "", "lesg": "", "lesges": "", "lessapprox": "", "lessdot": "", "lesseqgtr": "", "lesseqqgtr": "", "LessEqualGreater": "", "LessFullEqual": "", "LessGreater": "", "lessgtr": "", "LessLess": "", "lesssim": "", "LessSlantEqual": "", "LessTilde": "", "lfisht": "", "lfloor": "", "lfr": "", "Lfr": "", "lg": "", "lgE": "", "lHar": "", "lhard": "", "lharu": "", "lharul": "", "lhblk": "", "ljcy": "", "LJcy": "", "ll": "", "Ll": "", "llarr": "", "llcorner": "", "Lleftarrow": "", "llhard": "", "lltri": "", "lmidot": "", "Lmidot": "", "lmoust": "", "lmoustache": "", "lnap": "", "lnapprox": "", "lne": "", "lnE": "", "lneq": "", "lneqq": "", "lnsim": "", "loang": "", "loarr": "", "lobrk": "", "longleftarrow": "", "Longleftarrow": "", "LongLeftArrow": "", "longleftrightarrow": "", "Longleftrightarrow": "", "LongLeftRightArrow": "", "longmapsto": "", "longrightarrow": "", "Longrightarrow": "", "LongRightArrow": "", "looparrowleft": "", "looparrowright": "", "lopar": "", "lopf": "", "Lopf": "", "loplus": "", "lotimes": "", "lowast": "", "lowbar": "_", "LowerLeftArrow": "", "LowerRightArrow": "", "loz": "", "lozenge": "", "lozf": "", "lpar": "(", "lparlt": "", "lrarr": "", "lrcorner": "", "lrhar": "", "lrhard": "", "lrm": "", "lrtri": "", "lsaquo": "", "lscr": "", "Lscr": "", "lsh": "", "Lsh": "", "lsim": "", "lsime": "", "lsimg": "", "lsqb": "[", "lsquo": "", "lsquor": "", "lstrok": "", "Lstrok": "", "lt": "<", "Lt": "", "LT": "<", "ltcc": "", "ltcir": "", "ltdot": "", "lthree": "", "ltimes": "", "ltlarr": "", "ltquest": "", "ltri": "", "ltrie": "", "ltrif": "", "ltrPar": "", "lurdshar": "", "luruhar": "", "lvertneqq": "", "lvnE": "", "macr": "", "male": "", "malt": "", "maltese": "", "map": "", "Map": "", "mapsto": "", "mapstodown": "", "mapstoleft": "", "mapstoup": "", "marker": "", "mcomma": "", "mcy": "", "Mcy": "", "mdash": "", "mDDot": "", "measuredangle": "", "MediumSpace": "", "Mellintrf": "", "mfr": "", "Mfr": "", "mho": "", "micro": "", "mid": "", "midast": "*", "midcir": "", "middot": "", "minus": "", "minusb": "", "minusd": "", "minusdu": "", "MinusPlus": "", "mlcp": "", "mldr": "", "mnplus": "", "models": "", "mopf": "", "Mopf": "", "mp": "", "mscr": "", "Mscr": "", "mstpos": "", "mu": "", "Mu": "", "multimap": "", "mumap": "", "nabla": "", "nacute": "", "Nacute": "", "nang": "", "nap": "", "napE": "", "napid": "", "napos": "", "napprox": "", "natur": "", "natural": "", "naturals": "", "nbsp": "", "nbump": "", "nbumpe": "", "ncap": "", "ncaron": "", "Ncaron": "", "ncedil": "", "Ncedil": "", "ncong": "", "ncongdot": "", "ncup": "", "ncy": "", "Ncy": "", "ndash": "", "ne": "", "nearhk": "", "nearr": "", "neArr": "", "nearrow": "", "nedot": "", "NegativeMediumSpace": "", "NegativeThickSpace": "", "NegativeThinSpace": "", "NegativeVeryThinSpace": "", "nequiv": "", "nesear": "", "nesim": "", "NestedGreaterGreater": "", "NestedLessLess": "", "NewLine": "\n", "nexist": "", "nexists": "", "nfr": "", "Nfr": "", "nge": "", "ngE": "", "ngeq": "", "ngeqq": "", "ngeqslant": "", "nges": "", "nGg": "", "ngsim": "", "ngt": "", "nGt": "", "ngtr": "", "nGtv": "", "nharr": "", "nhArr": "", "nhpar": "", "ni": "", "nis": "", "nisd": "", "niv": "", "njcy": "", "NJcy": "", "nlarr": "", "nlArr": "", "nldr": "", "nle": "", "nlE": "", "nleftarrow": "", "nLeftarrow": "", "nleftrightarrow": "", "nLeftrightarrow": "", "nleq": "", "nleqq": "", "nleqslant": "", "nles": "", "nless": "", "nLl": "", "nlsim": "", "nlt": "", "nLt": "", "nltri": "", "nltrie": "", "nLtv": "", "nmid": "", "NoBreak": "", "NonBreakingSpace": "", "nopf": "", "Nopf": "", "not": "", "Not": "", "NotCongruent": "", "NotCupCap": "", "NotDoubleVerticalBar": "", "NotElement": "", "NotEqual": "", "NotEqualTilde": "", "NotExists": "", "NotGreater": "", "NotGreaterEqual": "", "NotGreaterFullEqual": "", "NotGreaterGreater": "", "NotGreaterLess": "", "NotGreaterSlantEqual": "", "NotGreaterTilde": "", "NotHumpDownHump": "", "NotHumpEqual": "", "notin": "", "notindot": "", "notinE": "", "notinva": "", "notinvb": "", "notinvc": "", "NotLeftTriangle": "", "NotLeftTriangleBar": "", "NotLeftTriangleEqual": "", "NotLess": "", "NotLessEqual": "", "NotLessGreater": "", "NotLessLess": "", "NotLessSlantEqual": "", "NotLessTilde": "", "NotNestedGreaterGreater": "", "NotNestedLessLess": "", "notni": "", "notniva": "", "notnivb": "", "notnivc": "", "NotPrecedes": "", "NotPrecedesEqual": "", "NotPrecedesSlantEqual": "", "NotReverseElement": "", "NotRightTriangle": "", "NotRightTriangleBar": "", "NotRightTriangleEqual": "", "NotSquareSubset": "", "NotSquareSubsetEqual": "", "NotSquareSuperset": "", "NotSquareSupersetEqual": "", "NotSubset": "", "NotSubsetEqual": "", "NotSucceeds": "", "NotSucceedsEqual": "", "NotSucceedsSlantEqual": "", "NotSucceedsTilde": "", "NotSuperset": "", "NotSupersetEqual": "", "NotTilde": "", "NotTildeEqual": "", "NotTildeFullEqual": "", "NotTildeTilde": "", "NotVerticalBar": "", "npar": "", "nparallel": "", "nparsl": "", "npart": "", "npolint": "", "npr": "", "nprcue": "", "npre": "", "nprec": "", "npreceq": "", "nrarr": "", "nrArr": "", "nrarrc": "", "nrarrw": "", "nrightarrow": "", "nRightarrow": "", "nrtri": "", "nrtrie": "", "nsc": "", "nsccue": "", "nsce": "", "nscr": "", "Nscr": "", "nshortmid": "", "nshortparallel": "", "nsim": "", "nsime": "", "nsimeq": "", "nsmid": "", "nspar": "", "nsqsube": "", "nsqsupe": "", "nsub": "", "nsube": "", "nsubE": "", "nsubset": "", "nsubseteq": "", "nsubseteqq": "", "nsucc": "", "nsucceq": "", "nsup": "", "nsupe": "", "nsupE": "", "nsupset": "", "nsupseteq": "", "nsupseteqq": "", "ntgl": "", "ntilde": "", "Ntilde": "", "ntlg": "", "ntriangleleft": "", "ntrianglelefteq": "", "ntriangleright": "", "ntrianglerighteq": "", "nu": "", "Nu": "", "num": "#", "numero": "", "numsp": "", "nvap": "", "nvdash": "", "nvDash": "", "nVdash": "", "nVDash": "", "nvge": "", "nvgt": ">", "nvHarr": "", "nvinfin": "", "nvlArr": "", "nvle": "", "nvlt": "<", "nvltrie": "", "nvrArr": "", "nvrtrie": "", "nvsim": "", "nwarhk": "", "nwarr": "", "nwArr": "", "nwarrow": "", "nwnear": "", "oacute": "", "Oacute": "", "oast": "", "ocir": "", "ocirc": "", "Ocirc": "", "ocy": "", "Ocy": "", "odash": "", "odblac": "", "Odblac": "", "odiv": "", "odot": "", "odsold": "", "oelig": "", "OElig": "", "ofcir": "", "ofr": "", "Ofr": "", "ogon": "", "ograve": "", "Ograve": "", "ogt": "", "ohbar": "", "ohm": "", "oint": "", "olarr": "", "olcir": "", "olcross": "", "oline": "", "olt": "", "omacr": "", "Omacr": "", "omega": "", "Omega": "", "omicron": "", "Omicron": "", "omid": "", "ominus": "", "oopf": "", "Oopf": "", "opar": "", "OpenCurlyDoubleQuote": "", "OpenCurlyQuote": "", "operp": "", "oplus": "", "or": "", "Or": "", "orarr": "", "ord": "", "order": "", "orderof": "", "ordf": "", "ordm": "", "origof": "", "oror": "", "orslope": "", "orv": "", "oS": "", "oscr": "", "Oscr": "", "oslash": "", "Oslash": "", "osol": "", "otilde": "", "Otilde": "", "otimes": "", "Otimes": "", "otimesas": "", "ouml": "", "Ouml": "", "ovbar": "", "OverBar": "", "OverBrace": "", "OverBracket": "", "OverParenthesis": "", "par": "", "para": "", "parallel": "", "parsim": "", "parsl": "", "part": "", "PartialD": "", "pcy": "", "Pcy": "", "percnt": "%", "period": ".", "permil": "", "perp": "", "pertenk": "", "pfr": "", "Pfr": "", "phi": "", "Phi": "", "phiv": "", "phmmat": "", "phone": "", "pi": "", "Pi": "", "pitchfork": "", "piv": "", "planck": "", "planckh": "", "plankv": "", "plus": "+", "plusacir": "", "plusb": "", "pluscir": "", "plusdo": "", "plusdu": "", "pluse": "", "PlusMinus": "", "plusmn": "", "plussim": "", "plustwo": "", "pm": "", "Poincareplane": "", "pointint": "", "popf": "", "Popf": "", "pound": "", "pr": "", "Pr": "", "prap": "", "prcue": "", "pre": "", "prE": "", "prec": "", "precapprox": "", "preccurlyeq": "", "Precedes": "", "PrecedesEqual": "", "PrecedesSlantEqual": "", "PrecedesTilde": "", "preceq": "", "precnapprox": "", "precneqq": "", "precnsim": "", "precsim": "", "prime": "", "Prime": "", "primes": "", "prnap": "", "prnE": "", "prnsim": "", "prod": "", "Product": "", "profalar": "", "profline": "", "profsurf": "", "prop": "", "Proportion": "", "Proportional": "", "propto": "", "prsim": "", "prurel": "", "pscr": "", "Pscr": "", "psi": "", "Psi": "", "puncsp": "", "qfr": "", "Qfr": "", "qint": "", "qopf": "", "Qopf": "", "qprime": "", "qscr": "", "Qscr": "", "quaternions": "", "quatint": "", "quest": "?", "questeq": "", "quot": '"', "QUOT": '"', "rAarr": "", "race": "", "racute": "", "Racute": "", "radic": "", "raemptyv": "", "rang": "", "Rang": "", "rangd": "", "range": "", "rangle": "", "raquo": "", "rarr": "", "rArr": "", "Rarr": "", "rarrap": "", "rarrb": "", "rarrbfs": "", "rarrc": "", "rarrfs": "", "rarrhk": "", "rarrlp": "", "rarrpl": "", "rarrsim": "", "rarrtl": "", "Rarrtl": "", "rarrw": "", "ratail": "", "rAtail": "", "ratio": "", "rationals": "", "rbarr": "", "rBarr": "", "RBarr": "", "rbbrk": "", "rbrace": "}", "rbrack": "]", "rbrke": "", "rbrksld": "", "rbrkslu": "", "rcaron": "", "Rcaron": "", "rcedil": "", "Rcedil": "", "rceil": "", "rcub": "}", "rcy": "", "Rcy": "", "rdca": "", "rdldhar": "", "rdquo": "", "rdquor": "", "rdsh": "", "Re": "", "real": "", "realine": "", "realpart": "", "reals": "", "rect": "", "reg": "", "REG": "", "ReverseElement": "", "ReverseEquilibrium": "", "ReverseUpEquilibrium": "", "rfisht": "", "rfloor": "", "rfr": "", "Rfr": "", "rHar": "", "rhard": "", "rharu": "", "rharul": "", "rho": "", "Rho": "", "rhov": "", "RightAngleBracket": "", "rightarrow": "", "Rightarrow": "", "RightArrow": "", "RightArrowBar": "", "RightArrowLeftArrow": "", "rightarrowtail": "", "RightCeiling": "", "RightDoubleBracket": "", "RightDownTeeVector": "", "RightDownVector": "", "RightDownVectorBar": "", "RightFloor": "", "rightharpoondown": "", "rightharpoonup": "", "rightleftarrows": "", "rightleftharpoons": "", "rightrightarrows": "", "rightsquigarrow": "", "RightTee": "", "RightTeeArrow": "", "RightTeeVector": "", "rightthreetimes": "", "RightTriangle": "", "RightTriangleBar": "", "RightTriangleEqual": "", "RightUpDownVector": "", "RightUpTeeVector": "", "RightUpVector": "", "RightUpVectorBar": "", "RightVector": "", "RightVectorBar": "", "ring": "", "risingdotseq": "", "rlarr": "", "rlhar": "", "rlm": "", "rmoust": "", "rmoustache": "", "rnmid": "", "roang": "", "roarr": "", "robrk": "", "ropar": "", "ropf": "", "Ropf": "", "roplus": "", "rotimes": "", "RoundImplies": "", "rpar": ")", "rpargt": "", "rppolint": "", "rrarr": "", "Rrightarrow": "", "rsaquo": "", "rscr": "", "Rscr": "", "rsh": "", "Rsh": "", "rsqb": "]", "rsquo": "", "rsquor": "", "rthree": "", "rtimes": "", "rtri": "", "rtrie": "", "rtrif": "", "rtriltri": "", "RuleDelayed": "", "ruluhar": "", "rx": "", "sacute": "", "Sacute": "", "sbquo": "", "sc": "", "Sc": "", "scap": "", "scaron": "", "Scaron": "", "sccue": "", "sce": "", "scE": "", "scedil": "", "Scedil": "", "scirc": "", "Scirc": "", "scnap": "", "scnE": "", "scnsim": "", "scpolint": "", "scsim": "", "scy": "", "Scy": "", "sdot": "", "sdotb": "", "sdote": "", "searhk": "", "searr": "", "seArr": "", "searrow": "", "sect": "", "semi": ";", "seswar": "", "setminus": "", "setmn": "", "sext": "", "sfr": "", "Sfr": "", "sfrown": "", "sharp": "", "shchcy": "", "SHCHcy": "", "shcy": "", "SHcy": "", "ShortDownArrow": "", "ShortLeftArrow": "", "shortmid": "", "shortparallel": "", "ShortRightArrow": "", "ShortUpArrow": "", "shy": "", "sigma": "", "Sigma": "", "sigmaf": "", "sigmav": "", "sim": "", "simdot": "", "sime": "", "simeq": "", "simg": "", "simgE": "", "siml": "", "simlE": "", "simne": "", "simplus": "", "simrarr": "", "slarr": "", "SmallCircle": "", "smallsetminus": "", "smashp": "", "smeparsl": "", "smid": "", "smile": "", "smt": "", "smte": "", "smtes": "", "softcy": "", "SOFTcy": "", "sol": "/", "solb": "", "solbar": "", "sopf": "", "Sopf": "", "spades": "", "spadesuit": "", "spar": "", "sqcap": "", "sqcaps": "", "sqcup": "", "sqcups": "", "Sqrt": "", "sqsub": "", "sqsube": "", "sqsubset": "", "sqsubseteq": "", "sqsup": "", "sqsupe": "", "sqsupset": "", "sqsupseteq": "", "squ": "", "square": "", "Square": "", "SquareIntersection": "", "SquareSubset": "", "SquareSubsetEqual": "", "SquareSuperset": "", "SquareSupersetEqual": "", "SquareUnion": "", "squarf": "", "squf": "", "srarr": "", "sscr": "", "Sscr": "", "ssetmn": "", "ssmile": "", "sstarf": "", "star": "", "Star": "", "starf": "", "straightepsilon": "", "straightphi": "", "strns": "", "sub": "", "Sub": "", "subdot": "", "sube": "", "subE": "", "subedot": "", "submult": "", "subne": "", "subnE": "", "subplus": "", "subrarr": "", "subset": "", "Subset": "", "subseteq": "", "subseteqq": "", "SubsetEqual": "", "subsetneq": "", "subsetneqq": "", "subsim": "", "subsub": "", "subsup": "", "succ": "", "succapprox": "", "succcurlyeq": "", "Succeeds": "", "SucceedsEqual": "", "SucceedsSlantEqual": "", "SucceedsTilde": "", "succeq": "", "succnapprox": "", "succneqq": "", "succnsim": "", "succsim": "", "SuchThat": "", "sum": "", "Sum": "", "sung": "", "sup": "", "Sup": "", "sup1": "", "sup2": "", "sup3": "", "supdot": "", "supdsub": "", "supe": "", "supE": "", "supedot": "", "Superset": "", "SupersetEqual": "", "suphsol": "", "suphsub": "", "suplarr": "", "supmult": "", "supne": "", "supnE": "", "supplus": "", "supset": "", "Supset": "", "supseteq": "", "supseteqq": "", "supsetneq": "", "supsetneqq": "", "supsim": "", "supsub": "", "supsup": "", "swarhk": "", "swarr": "", "swArr": "", "swarrow": "", "swnwar": "", "szlig": "", "Tab": "	", "target": "", "tau": "", "Tau": "", "tbrk": "", "tcaron": "", "Tcaron": "", "tcedil": "", "Tcedil": "", "tcy": "", "Tcy": "", "tdot": "", "telrec": "", "tfr": "", "Tfr": "", "there4": "", "therefore": "", "Therefore": "", "theta": "", "Theta": "", "thetasym": "", "thetav": "", "thickapprox": "", "thicksim": "", "ThickSpace": "", "thinsp": "", "ThinSpace": "", "thkap": "", "thksim": "", "thorn": "", "THORN": "", "tilde": "", "Tilde": "", "TildeEqual": "", "TildeFullEqual": "", "TildeTilde": "", "times": "", "timesb": "", "timesbar": "", "timesd": "", "tint": "", "toea": "", "top": "", "topbot": "", "topcir": "", "topf": "", "Topf": "", "topfork": "", "tosa": "", "tprime": "", "trade": "", "TRADE": "", "triangle": "", "triangledown": "", "triangleleft": "", "trianglelefteq": "", "triangleq": "", "triangleright": "", "trianglerighteq": "", "tridot": "", "trie": "", "triminus": "", "TripleDot": "", "triplus": "", "trisb": "", "tritime": "", "trpezium": "", "tscr": "", "Tscr": "", "tscy": "", "TScy": "", "tshcy": "", "TSHcy": "", "tstrok": "", "Tstrok": "", "twixt": "", "twoheadleftarrow": "", "twoheadrightarrow": "", "uacute": "", "Uacute": "", "uarr": "", "uArr": "", "Uarr": "", "Uarrocir": "", "ubrcy": "", "Ubrcy": "", "ubreve": "", "Ubreve": "", "ucirc": "", "Ucirc": "", "ucy": "", "Ucy": "", "udarr": "", "udblac": "", "Udblac": "", "udhar": "", "ufisht": "", "ufr": "", "Ufr": "", "ugrave": "", "Ugrave": "", "uHar": "", "uharl": "", "uharr": "", "uhblk": "", "ulcorn": "", "ulcorner": "", "ulcrop": "", "ultri": "", "umacr": "", "Umacr": "", "uml": "", "UnderBar": "_", "UnderBrace": "", "UnderBracket": "", "UnderParenthesis": "", "Union": "", "UnionPlus": "", "uogon": "", "Uogon": "", "uopf": "", "Uopf": "", "uparrow": "", "Uparrow": "", "UpArrow": "", "UpArrowBar": "", "UpArrowDownArrow": "", "updownarrow": "", "Updownarrow": "", "UpDownArrow": "", "UpEquilibrium": "", "upharpoonleft": "", "upharpoonright": "", "uplus": "", "UpperLeftArrow": "", "UpperRightArrow": "", "upsi": "", "Upsi": "", "upsih": "", "upsilon": "", "Upsilon": "", "UpTee": "", "UpTeeArrow": "", "upuparrows": "", "urcorn": "", "urcorner": "", "urcrop": "", "uring": "", "Uring": "", "urtri": "", "uscr": "", "Uscr": "", "utdot": "", "utilde": "", "Utilde": "", "utri": "", "utrif": "", "uuarr": "", "uuml": "", "Uuml": "", "uwangle": "", "vangrt": "", "varepsilon": "", "varkappa": "", "varnothing": "", "varphi": "", "varpi": "", "varpropto": "", "varr": "", "vArr": "", "varrho": "", "varsigma": "", "varsubsetneq": "", "varsubsetneqq": "", "varsupsetneq": "", "varsupsetneqq": "", "vartheta": "", "vartriangleleft": "", "vartriangleright": "", "vBar": "", "Vbar": "", "vBarv": "", "vcy": "", "Vcy": "", "vdash": "", "vDash": "", "Vdash": "", "VDash": "", "Vdashl": "", "vee": "", "Vee": "", "veebar": "", "veeeq": "", "vellip": "", "verbar": "|", "Verbar": "", "vert": "|", "Vert": "", "VerticalBar": "", "VerticalLine": "|", "VerticalSeparator": "", "VerticalTilde": "", "VeryThinSpace": "", "vfr": "", "Vfr": "", "vltri": "", "vnsub": "", "vnsup": "", "vopf": "", "Vopf": "", "vprop": "", "vrtri": "", "vscr": "", "Vscr": "", "vsubne": "", "vsubnE": "", "vsupne": "", "vsupnE": "", "Vvdash": "", "vzigzag": "", "wcirc": "", "Wcirc": "", "wedbar": "", "wedge": "", "Wedge": "", "wedgeq": "", "weierp": "", "wfr": "", "Wfr": "", "wopf": "", "Wopf": "", "wp": "", "wr": "", "wreath": "", "wscr": "", "Wscr": "", "xcap": "", "xcirc": "", "xcup": "", "xdtri": "", "xfr": "", "Xfr": "", "xharr": "", "xhArr": "", "xi": "", "Xi": "", "xlarr": "", "xlArr": "", "xmap": "", "xnis": "", "xodot": "", "xopf": "", "Xopf": "", "xoplus": "", "xotime": "", "xrarr": "", "xrArr": "", "xscr": "", "Xscr": "", "xsqcup": "", "xuplus": "", "xutri": "", "xvee": "", "xwedge": "", "yacute": "", "Yacute": "", "yacy": "", "YAcy": "", "ycirc": "", "Ycirc": "", "ycy": "", "Ycy": "", "yen": "", "yfr": "", "Yfr": "", "yicy": "", "YIcy": "", "yopf": "", "Yopf": "", "yscr": "", "Yscr": "", "yucy": "", "YUcy": "", "yuml": "", "Yuml": "", "zacute": "", "Zacute": "", "zcaron": "", "Zcaron": "", "zcy": "", "Zcy": "", "zdot": "", "Zdot": "", "zeetrf": "", "ZeroWidthSpace": "", "zeta": "", "Zeta": "", "zfr": "", "Zfr": "", "zhcy": "", "ZHcy": "", "zigrarr": "", "zopf": "", "Zopf": "", "zscr": "", "Zscr": "", "zwj": "", "zwnj": "" };
      var decodeMapLegacy = { "aacute": "", "Aacute": "", "acirc": "", "Acirc": "", "acute": "", "aelig": "", "AElig": "", "agrave": "", "Agrave": "", "amp": "&", "AMP": "&", "aring": "", "Aring": "", "atilde": "", "Atilde": "", "auml": "", "Auml": "", "brvbar": "", "ccedil": "", "Ccedil": "", "cedil": "", "cent": "", "copy": "", "COPY": "", "curren": "", "deg": "", "divide": "", "eacute": "", "Eacute": "", "ecirc": "", "Ecirc": "", "egrave": "", "Egrave": "", "eth": "", "ETH": "", "euml": "", "Euml": "", "frac12": "", "frac14": "", "frac34": "", "gt": ">", "GT": ">", "iacute": "", "Iacute": "", "icirc": "", "Icirc": "", "iexcl": "", "igrave": "", "Igrave": "", "iquest": "", "iuml": "", "Iuml": "", "laquo": "", "lt": "<", "LT": "<", "macr": "", "micro": "", "middot": "", "nbsp": "", "not": "", "ntilde": "", "Ntilde": "", "oacute": "", "Oacute": "", "ocirc": "", "Ocirc": "", "ograve": "", "Ograve": "", "ordf": "", "ordm": "", "oslash": "", "Oslash": "", "otilde": "", "Otilde": "", "ouml": "", "Ouml": "", "para": "", "plusmn": "", "pound": "", "quot": '"', "QUOT": '"', "raquo": "", "reg": "", "REG": "", "sect": "", "shy": "", "sup1": "", "sup2": "", "sup3": "", "szlig": "", "thorn": "", "THORN": "", "times": "", "uacute": "", "Uacute": "", "ucirc": "", "Ucirc": "", "ugrave": "", "Ugrave": "", "uml": "", "uuml": "", "Uuml": "", "yacute": "", "Yacute": "", "yen": "", "yuml": "" };
      var decodeMapNumeric = { "0": "", "128": "", "130": "", "131": "", "132": "", "133": "", "134": "", "135": "", "136": "", "137": "", "138": "", "139": "", "140": "", "142": "", "145": "", "146": "", "147": "", "148": "", "149": "", "150": "", "151": "", "152": "", "153": "", "154": "", "155": "", "156": "", "158": "", "159": "" };
      var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65e3, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111];
      var stringFromCharCode = String.fromCharCode;
      var object = {};
      var hasOwnProperty = object.hasOwnProperty;
      var has = function(object2, propertyName) {
        return hasOwnProperty.call(object2, propertyName);
      };
      var contains = function(array, value) {
        var index2 = -1;
        var length = array.length;
        while (++index2 < length) {
          if (array[index2] == value) {
            return true;
          }
        }
        return false;
      };
      var merge = function(options, defaults) {
        if (!options) {
          return defaults;
        }
        var result = {};
        var key2;
        for (key2 in defaults) {
          result[key2] = has(options, key2) ? options[key2] : defaults[key2];
        }
        return result;
      };
      var codePointToSymbol = function(codePoint, strict) {
        var output = "";
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
          if (strict) {
            parseError("character reference outside the permissible Unicode range");
          }
          return "";
        }
        if (has(decodeMapNumeric, codePoint)) {
          if (strict) {
            parseError("disallowed character reference");
          }
          return decodeMapNumeric[codePoint];
        }
        if (strict && contains(invalidReferenceCodePoints, codePoint)) {
          parseError("disallowed character reference");
        }
        if (codePoint > 65535) {
          codePoint -= 65536;
          output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        output += stringFromCharCode(codePoint);
        return output;
      };
      var hexEscape = function(codePoint) {
        return "&#x" + codePoint.toString(16).toUpperCase() + ";";
      };
      var decEscape = function(codePoint) {
        return "&#" + codePoint + ";";
      };
      var parseError = function(message) {
        throw Error("Parse error: " + message);
      };
      var encode2 = function(string, options) {
        options = merge(options, encode2.options);
        var strict = options.strict;
        if (strict && regexInvalidRawCodePoint.test(string)) {
          parseError("forbidden code point");
        }
        var encodeEverything = options.encodeEverything;
        var useNamedReferences = options.useNamedReferences;
        var allowUnsafeSymbols = options.allowUnsafeSymbols;
        var escapeCodePoint = options.decimal ? decEscape : hexEscape;
        var escapeBmpSymbol = function(symbol) {
          return escapeCodePoint(symbol.charCodeAt(0));
        };
        if (encodeEverything) {
          string = string.replace(regexAsciiWhitelist, function(symbol) {
            if (useNamedReferences && has(encodeMap, symbol)) {
              return "&" + encodeMap[symbol] + ";";
            }
            return escapeBmpSymbol(symbol);
          });
          if (useNamedReferences) {
            string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;").replace(/&#x66;&#x6A;/g, "&fjlig;");
          }
          if (useNamedReferences) {
            string = string.replace(regexEncodeNonAscii, function(string2) {
              return "&" + encodeMap[string2] + ";";
            });
          }
        } else if (useNamedReferences) {
          if (!allowUnsafeSymbols) {
            string = string.replace(regexEscape, function(string2) {
              return "&" + encodeMap[string2] + ";";
            });
          }
          string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;");
          string = string.replace(regexEncodeNonAscii, function(string2) {
            return "&" + encodeMap[string2] + ";";
          });
        } else if (!allowUnsafeSymbols) {
          string = string.replace(regexEscape, escapeBmpSymbol);
        }
        return string.replace(regexAstralSymbols, function($0) {
          var high = $0.charCodeAt(0);
          var low = $0.charCodeAt(1);
          var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
          return escapeCodePoint(codePoint);
        }).replace(regexBmpWhitelist, escapeBmpSymbol);
      };
      encode2.options = {
        "allowUnsafeSymbols": false,
        "encodeEverything": false,
        "strict": false,
        "useNamedReferences": false,
        "decimal": false
      };
      var decode2 = function(html, options) {
        options = merge(options, decode2.options);
        var strict = options.strict;
        if (strict && regexInvalidEntity.test(html)) {
          parseError("malformed character reference");
        }
        return html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
          var codePoint;
          var semicolon;
          var decDigits;
          var hexDigits;
          var reference;
          var next;
          if ($1) {
            reference = $1;
            return decodeMap[reference];
          }
          if ($2) {
            reference = $2;
            next = $3;
            if (next && options.isAttributeValue) {
              if (strict && next == "=") {
                parseError("`&` did not start a character reference");
              }
              return $0;
            } else {
              if (strict) {
                parseError(
                  "named character reference was not terminated by a semicolon"
                );
              }
              return decodeMapLegacy[reference] + (next || "");
            }
          }
          if ($4) {
            decDigits = $4;
            semicolon = $5;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(decDigits, 10);
            return codePointToSymbol(codePoint, strict);
          }
          if ($6) {
            hexDigits = $6;
            semicolon = $7;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(hexDigits, 16);
            return codePointToSymbol(codePoint, strict);
          }
          if (strict) {
            parseError(
              "named character reference was not terminated by a semicolon"
            );
          }
          return $0;
        });
      };
      decode2.options = {
        "isAttributeValue": false,
        "strict": false
      };
      var escape = function(string) {
        return string.replace(regexEscape, function($0) {
          return escapeMap[$0];
        });
      };
      var he2 = {
        "version": "1.2.0",
        "encode": encode2,
        "decode": decode2,
        "escape": escape,
        "unescape": decode2
      };
      if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
          freeModule.exports = he2;
        } else {
          for (var key in he2) {
            has(he2, key) && (freeExports[key] = he2[key]);
          }
        }
      } else {
        root.he = he2;
      }
    })(he$1);
  })(he$2, he$2.exports);
  return he$2.exports;
}
var heExports = requireHe();
const he = /* @__PURE__ */ getDefaultExportFromCjs$2(heExports);
function translateFieldAnnotation(params) {
  const { node, isFinalDoc, fieldsHighlightColor } = params;
  const { attrs = {} } = node;
  const annotationHandler = getTranslationByAnnotationType(attrs.type, attrs.fieldType);
  if (!annotationHandler) return {};
  let processedNode;
  let sdtContentElements;
  let id = attrs.sdtId;
  if ((attrs.type === "image" || attrs.type === "signature") && !attrs.hash) {
    attrs.hash = generateDocxRandomId(4);
  }
  if (!attrs.sdtId) {
    id = generateRandomSigned32BitIntStrId();
  }
  if (isFinalDoc) {
    return annotationHandler(params);
  } else {
    processedNode = annotationHandler(params);
    sdtContentElements = [processedNode];
    if (attrs.type === "html") {
      const runElements = processedNode.elements[0].elements.filter((el) => el.name === "w:r");
      sdtContentElements = [...runElements];
    }
  }
  sdtContentElements = [...sdtContentElements];
  const fieldBackgroundTag = getFieldHighlightJson(fieldsHighlightColor);
  if (fieldBackgroundTag) {
    sdtContentElements.unshift(fieldBackgroundTag);
  }
  const annotationAttrs = {
    displayLabel: attrs.displayLabel,
    defaultDisplayLabel: attrs.defaultDisplayLabel,
    fieldId: attrs.fieldId,
    fieldType: attrs.fieldType,
    fieldTypeShort: attrs.type,
    fieldColor: attrs.fieldColor,
    fieldMultipleImage: attrs.multipleImage,
    fieldFontFamily: attrs.fontFamily,
    fieldFontSize: attrs.fontSize,
    fieldTextColor: attrs.textColor,
    fieldTextHighlight: attrs.textHighlight,
    hash: attrs.hash
  };
  const annotationAttrsJson = JSON.stringify(annotationAttrs);
  const sanitizedDisplayLabel = attrs.displayLabel === "undefined" || attrs.displayLabel === void 0 ? "" : attrs.displayLabel;
  const sdtPrElements = [
    { name: "w:alias", attributes: { "w:val": sanitizedDisplayLabel } },
    { name: "w:tag", attributes: { "w:val": annotationAttrsJson } },
    { name: "w:id", attributes: { "w:val": id } }
  ];
  if (attrs.sdtPr?.elements && Array.isArray(attrs.sdtPr.elements)) {
    const elementsToExclude = ["w:alias", "w:tag", "w:id"];
    const passthroughElements = attrs.sdtPr.elements.filter(
      (el) => el && el.name && !elementsToExclude.includes(el.name)
    );
    sdtPrElements.push(...passthroughElements);
  }
  const result = {
    name: "w:sdt",
    elements: [
      {
        name: "w:sdtPr",
        elements: sdtPrElements
      },
      {
        name: "w:sdtContent",
        elements: sdtContentElements
      }
    ]
  };
  return result;
}
function getTranslationByAnnotationType(annotationType, annotationFieldType) {
  if (annotationType === "text" && annotationFieldType === "FILEUPLOADER") {
    return null;
  }
  const imageEmuSize = {
    w: 4286250,
    h: 4286250
  };
  const signatureEmuSize = {
    w: 99e4,
    h: 495e3
  };
  const dictionary = {
    text: prepareTextAnnotation,
    image: (params) => prepareImageAnnotation(params, imageEmuSize),
    signature: (params) => prepareImageAnnotation(params, signatureEmuSize),
    checkbox: prepareCheckboxAnnotation,
    html: prepareHtmlAnnotation,
    link: prepareUrlAnnotation
  };
  return dictionary[annotationType];
}
function prepareTextAnnotation(params) {
  const {
    node: { attrs = {}, marks = [] }
  } = params;
  const marksFromAttrs = translateFieldAttrsToMarks(attrs);
  return getTextNodeForExport(attrs.displayLabel, [...marks, ...marksFromAttrs], params);
}
function prepareImageAnnotation(params, imageSize) {
  return translator$T.decode({
    ...params,
    imageSize
  });
}
function prepareCheckboxAnnotation(params) {
  const {
    node: { attrs = {}, marks = [] }
  } = params;
  const content = he.decode(attrs.displayLabel);
  return getTextNodeForExport(content, marks, params);
}
function prepareHtmlAnnotation(params) {
  const {
    node: { attrs = {}, marks = [] },
    editorSchema,
    editor
  } = params;
  let html = attrs.rawHtml || attrs.displayLabel;
  const paragraphHtmlContainer = sanitizeHtml(
    html,
    void 0,
    editor?.options?.document ?? editor?.options?.mockDocument
  );
  const marksFromAttrs = translateFieldAttrsToMarks(attrs);
  const allMarks = [...marks, ...marksFromAttrs];
  let state2 = EditorState.create({
    doc: DOMParser$1.fromSchema(editorSchema).parse(paragraphHtmlContainer)
  });
  if (allMarks.length) {
    state2 = applyMarksToHtmlAnnotation(state2, allMarks);
  }
  const htmlAnnotationNode = state2.doc.toJSON();
  const listTypes = ["bulletList", "orderedList"];
  const seenLists = /* @__PURE__ */ new Map();
  state2.doc.descendants((node) => {
    if (listTypes.includes(node.type.name)) {
      const listItem = node.firstChild;
      const { attrs: attrs2 } = listItem;
      const { level, numId } = attrs2;
      if (!seenLists.has(numId)) {
        const newNumId = ListHelpers.changeNumIdSameAbstract(numId, level, node.type.name, editor);
        listItem.attrs.numId = newNumId;
        seenLists.set(numId, newNumId);
      } else {
        const newNumId = seenLists.get(numId);
        listItem.attrs.numId = newNumId;
      }
    }
  });
  const elements = translateChildNodes({
    ...params,
    node: htmlAnnotationNode
  });
  return {
    name: "htmlAnnotation",
    elements
  };
}
function prepareUrlAnnotation(params) {
  const {
    node: { attrs = {}, marks = [] }
  } = params;
  if (!attrs.linkUrl) return prepareTextAnnotation(params);
  const linkTextNode = {
    type: "text",
    text: attrs.linkUrl,
    marks: [
      ...marks,
      {
        type: "link",
        attrs: {
          href: attrs.linkUrl,
          history: true,
          text: attrs.linkUrl
        }
      },
      {
        type: "textStyle",
        attrs: {
          color: "#467886"
        }
      }
    ]
  };
  return translator$1M.decode({
    ...params,
    node: linkTextNode
  });
}
function translateFieldAttrsToMarks(attrs = {}) {
  const { fontFamily, fontSize, bold, underline, italic, textColor, textHighlight } = attrs;
  const marks = [];
  if (fontFamily) marks.push({ type: "fontFamily", attrs: { fontFamily } });
  if (fontSize) marks.push({ type: "fontSize", attrs: { fontSize } });
  if (bold) marks.push({ type: "bold", attrs: {} });
  if (underline) marks.push({ type: "underline", attrs: {} });
  if (italic) marks.push({ type: "italic", attrs: {} });
  if (textColor) marks.push({ type: "color", attrs: { color: textColor } });
  if (textHighlight) marks.push({ type: "highlight", attrs: { color: textHighlight } });
  return marks;
}
function applyMarksToHtmlAnnotation(state2, marks) {
  const { tr, doc: doc2, schema } = state2;
  const allowedMarks = ["fontFamily", "fontSize", "highlight"];
  if (!marks.some((m2) => allowedMarks.includes(m2.type))) {
    return state2;
  }
  const fontFamily = marks.find((m2) => m2.type === "fontFamily");
  const fontSize = marks.find((m2) => m2.type === "fontSize");
  const highlight = marks.find((m2) => m2.type === "highlight");
  const textStyleType = schema.marks.textStyle;
  const highlightType = schema.marks.highlight;
  doc2.descendants((node, pos) => {
    if (!node.isText) return;
    const foundTextStyle = node.marks.find((m2) => m2.type.name === "textStyle");
    const foundHighlight = node.marks.find((m2) => m2.type.name === "highlight");
    if (!foundTextStyle) {
      tr.addMark(
        pos,
        pos + node.nodeSize,
        textStyleType.create({
          ...fontFamily?.attrs,
          ...fontSize?.attrs
        })
      );
    } else if (!foundTextStyle?.attrs.fontFamily && fontFamily) {
      tr.addMark(
        pos,
        pos + node.nodeSize,
        textStyleType.create({
          ...foundTextStyle?.attrs,
          ...fontFamily.attrs
        })
      );
    } else if (!foundTextStyle?.attrs.fontSize && fontSize) {
      tr.addMark(
        pos,
        pos + node.nodeSize,
        textStyleType.create({
          ...foundTextStyle?.attrs,
          ...fontSize.attrs
        })
      );
    }
    if (!foundHighlight) {
      tr.addMark(
        pos,
        pos + node.nodeSize,
        highlightType.create({
          ...highlight?.attrs
        })
      );
    }
  });
  return state2.apply(tr);
}
function getFieldHighlightJson(fieldsHighlightColor) {
  if (!fieldsHighlightColor) return null;
  let parsedColor = fieldsHighlightColor.trim();
  const hexRegex = /^#?([A-Fa-f0-9]{3}|[A-Fa-f0-9]{4}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{8})$/;
  if (!hexRegex.test(parsedColor)) {
    console.warn(`Invalid HEX color provided to fieldsHighlightColor export param: ${fieldsHighlightColor}`);
    return null;
  }
  if (parsedColor.startsWith("#")) {
    parsedColor = parsedColor.slice(1);
  }
  return {
    name: "w:rPr",
    elements: [
      {
        name: "w:shd",
        attributes: {
          "w:fill": `#${parsedColor}`,
          "w:color": "auto",
          "w:val": "clear"
        }
      }
    ]
  };
}
function translateDocumentSection(params) {
  const { node } = params;
  const { attrs = {} } = node;
  const childContent = translateChildNodes({ ...params, nodes: node.content });
  const nodeElements = [
    {
      name: "w:sdtContent",
      elements: childContent
    }
  ];
  const exportedTag = JSON.stringify({
    type: "documentSection",
    description: attrs.description
  });
  const sdtPr = generateSdtPrTagForDocumentSection(attrs.id, attrs.title, exportedTag, attrs.sdtPr);
  const { isLocked } = attrs;
  if (isLocked) {
    sdtPr.elements.push({
      name: "w:lock",
      attributes: {
        "w:val": "sdtContentLocked"
      }
    });
  }
  nodeElements.unshift(sdtPr);
  const result = {
    name: "w:sdt",
    elements: nodeElements
  };
  return result;
}
const generateSdtPrTagForDocumentSection = (id, title, tag, sdtPr) => {
  const coreElements = [
    {
      name: "w:id",
      attributes: {
        "w:val": id
      }
    },
    {
      name: "w:alias",
      attributes: {
        "w:val": title
      }
    },
    {
      name: "w:tag",
      attributes: {
        "w:val": tag
      }
    }
  ];
  if (sdtPr?.elements && Array.isArray(sdtPr.elements)) {
    const elementsToExclude = ["w:id", "w:alias", "w:tag", "w:lock"];
    const passthroughElements = sdtPr.elements.filter((el) => el && el.name && !elementsToExclude.includes(el.name));
    coreElements.push(...passthroughElements);
  }
  return {
    name: "w:sdtPr",
    elements: coreElements
  };
};
function translateDocumentPartObj(params) {
  const { node } = params;
  const { attrs = {} } = node;
  const childContent = translateChildNodes({ ...params, nodes: node.content });
  const sdtPr = generateSdtPrForDocPartObj(attrs);
  const nodeElements = [
    sdtPr,
    {
      name: "w:sdtContent",
      elements: childContent
    }
  ];
  const result = {
    name: "w:sdt",
    elements: nodeElements
  };
  return result;
}
function generateSdtPrForDocPartObj(attrs) {
  const existingDocPartObj = attrs.sdtPr?.elements?.find((el) => el.name === "w:docPartObj");
  const existingDocPartGallery = existingDocPartObj?.elements?.find((el) => el.name === "w:docPartGallery")?.attributes?.["w:val"];
  const docPartGallery = attrs.docPartGallery ?? existingDocPartGallery ?? null;
  const id = attrs.id ?? attrs.sdtPr?.elements?.find((el) => el.name === "w:id")?.attributes?.["w:val"] ?? "";
  const docPartUnique = attrs.docPartUnique ?? existingDocPartObj?.elements?.some((el) => el.name === "w:docPartUnique") ?? false;
  if (docPartGallery === null) {
    if (attrs.sdtPr) {
      return attrs.sdtPr;
    }
    return {
      name: "w:sdtPr",
      elements: [
        {
          name: "w:id",
          attributes: {
            "w:val": id
          }
        },
        {
          name: "w:docPartObj",
          elements: []
        }
      ]
    };
  }
  const docPartObjElements = [
    {
      name: "w:docPartGallery",
      attributes: {
        "w:val": docPartGallery
      }
    }
  ];
  if (docPartUnique) {
    docPartObjElements.push({ name: "w:docPartUnique" });
  }
  const sdtPrElements = [
    {
      name: "w:id",
      attributes: {
        "w:val": id
      }
    },
    {
      name: "w:docPartObj",
      elements: docPartObjElements
    }
  ];
  if (attrs.sdtPr?.elements && Array.isArray(attrs.sdtPr.elements)) {
    const elementsToExclude = ["w:id", "w:docPartObj"];
    const passthroughElements = attrs.sdtPr.elements.filter(
      (el) => el && el.name && !elementsToExclude.includes(el.name)
    );
    sdtPrElements.push(...passthroughElements);
  }
  return {
    name: "w:sdtPr",
    elements: sdtPrElements
  };
}
const RUN_LEVEL_WRAPPERS = /* @__PURE__ */ new Set(["w:hyperlink", "w:ins", "w:del"]);
function convertSdtContentToRuns(elements) {
  const normalized = Array.isArray(elements) ? elements : [elements];
  const runs = [];
  normalized.forEach((element) => {
    if (!element) return;
    if (element.name === "w:sdtPr") {
      return;
    }
    if (element.name === "w:r") {
      runs.push(element);
      return;
    }
    if (element.name === "w:sdt") {
      const sdtContent = (element.elements || []).find((child) => child?.name === "w:sdtContent");
      if (sdtContent?.elements) {
        runs.push(...convertSdtContentToRuns(sdtContent.elements));
      }
      return;
    }
    if (RUN_LEVEL_WRAPPERS.has(element.name)) {
      const wrapperElements = convertSdtContentToRuns(element.elements || []);
      if (wrapperElements.length) {
        runs.push({
          ...element,
          elements: wrapperElements
        });
      }
      return;
    }
    if (element.name) {
      runs.push({
        name: "w:r",
        type: "element",
        elements: element.elements || [element]
      });
    }
  });
  return runs.filter((run2) => Array.isArray(run2.elements) && run2.elements.length > 0);
}
function translateStructuredContent(params) {
  const { node, isFinalDoc } = params;
  const childContent = translateChildNodes({ ...params, node });
  const childElements = Array.isArray(childContent) ? childContent : [childContent];
  if (isFinalDoc) {
    if (node?.type === "structuredContent") {
      return convertSdtContentToRuns(childElements);
    }
    if (node?.type === "structuredContentBlock") {
      return childElements.length === 1 ? childElements[0] : childElements;
    }
  }
  const sdtContent = { name: "w:sdtContent", elements: childElements };
  const sdtPr = generateSdtPrTagForStructuredContent({ node });
  const nodeElements = [sdtPr, sdtContent];
  const result = {
    name: "w:sdt",
    elements: nodeElements
  };
  return result;
}
function generateSdtPrTagForStructuredContent({ node }) {
  const { attrs = {} } = node;
  const id = {
    name: "w:id",
    type: "element",
    attributes: { "w:val": attrs.id }
  };
  const alias = {
    name: "w:alias",
    type: "element",
    attributes: { "w:val": attrs.alias }
  };
  const tag = {
    name: "w:tag",
    type: "element",
    attributes: { "w:val": attrs.tag }
  };
  const resultElements = [];
  if (attrs.id) resultElements.push(id);
  if (attrs.alias) resultElements.push(alias);
  if (attrs.tag) resultElements.push(tag);
  if (attrs.sdtPr) {
    const elements = attrs.sdtPr.elements || [];
    const elementsToExclude = ["w:id", "w:alias", "w:tag"];
    const restElements = elements.filter((el) => !elementsToExclude.includes(el.name));
    const result2 = {
      name: "w:sdtPr",
      type: "element",
      elements: [...resultElements, ...restElements]
    };
    return result2;
  }
  const result = {
    name: "w:sdtPr",
    type: "element",
    elements: resultElements
  };
  return result;
}
const XML_NODE_NAME$h = "w:sdt";
const SD_NODE_NAME$f = ["fieldAnnotation", "structuredContent", "structuredContentBlock", "documentSection"];
const validXmlAttributes$5 = [];
function encode$w(params) {
  const nodes = params.nodes;
  const node = nodes[0];
  const { type: sdtType, handler: handler2 } = sdtNodeTypeStrategy(node);
  if (!handler2 || sdtType === "unknown") {
    return void 0;
  }
  const result = handler2(params);
  return result;
}
function decode$y(params) {
  const { node } = params;
  if (!node || !node.type) {
    return null;
  }
  const types2 = {
    fieldAnnotation: () => translateFieldAnnotation(params),
    structuredContent: () => translateStructuredContent(params),
    structuredContentBlock: () => translateStructuredContent(params),
    documentSection: () => translateDocumentSection(params),
    documentPartObject: () => translateDocumentPartObj(params),
    // Handled in doc-part-obj translator
    default: () => null
  };
  const decoder = types2[node.type] ?? types2.default;
  const result = decoder();
  return result;
}
const config$g = {
  xmlName: XML_NODE_NAME$h,
  sdNodeOrKeyName: SD_NODE_NAME$f,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$w,
  decode: decode$y,
  attributes: validXmlAttributes$5
};
const translator$S = NodeTranslator.from(config$g);
const getColspan = (cell) => {
  const rawColspan = cell?.attrs?.colspan;
  const numericColspan = typeof rawColspan === "string" ? parseInt(rawColspan, 10) : rawColspan;
  return Number.isFinite(numericColspan) && numericColspan > 0 ? numericColspan : 1;
};
const resolveGridBefore = (row) => {
  const rawGridBefore = row?.attrs?.tableRowProperties?.gridBefore ?? row?.attrs?.gridBefore;
  const numericGridBefore = typeof rawGridBefore === "string" ? parseInt(rawGridBefore, 10) : rawGridBefore;
  if (!Number.isFinite(numericGridBefore) || numericGridBefore <= 0) return 0;
  const cells = Array.isArray(row.content) ? row.content : [];
  let leadingGridBefore = 0;
  while (leadingGridBefore < cells.length && cells[leadingGridBefore]?.attrs?.__placeholder === "gridBefore") {
    leadingGridBefore += 1;
  }
  return leadingGridBefore > 0 ? 0 : numericGridBefore;
};
const advanceColumnsForCell = (columnIndex, cell) => columnIndex + getColspan(cell);
const getCellStartColumn = (row, targetCell) => {
  const cells = Array.isArray(row.content) ? row.content : [];
  let columnIndex = resolveGridBefore(row);
  for (const cell of cells) {
    if (cell === targetCell) return columnIndex;
    columnIndex = advanceColumnsForCell(columnIndex, cell);
  }
  return columnIndex;
};
const findCellCoveringColumn = (row, targetColumn) => {
  const cells = Array.isArray(row.content) ? row.content : [];
  let columnIndex = resolveGridBefore(row);
  for (const cell of cells) {
    const colspan = getColspan(cell);
    if (targetColumn >= columnIndex && targetColumn < columnIndex + colspan) {
      return cell;
    }
    columnIndex = advanceColumnsForCell(columnIndex, cell);
  }
  return null;
};
const findInsertionIndexForColumn = (row, targetColumn) => {
  const cells = Array.isArray(row.content) ? row.content : [];
  let columnIndex = resolveGridBefore(row);
  for (let index2 = 0; index2 < cells.length; index2++) {
    if (columnIndex >= targetColumn) return index2;
    columnIndex = advanceColumnsForCell(columnIndex, cells[index2]);
  }
  return cells.length;
};
function preProcessVerticalMergeCells(table, { editorSchema }) {
  if (!table || !Array.isArray(table.content)) {
    return table;
  }
  const rows = table.content;
  for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {
    const row = rows[rowIndex];
    if (!row) continue;
    if (!Array.isArray(row.content)) {
      row.content = [];
    }
    for (let cellIndex = 0; cellIndex < row.content.length; cellIndex++) {
      const cell = row.content[cellIndex];
      if (!cell) continue;
      const attrs = cell.attrs || {};
      const rawRowspan = typeof attrs.rowspan === "string" ? parseInt(attrs.rowspan, 10) : attrs.rowspan;
      if (!Number.isFinite(rawRowspan) || rawRowspan <= 1) continue;
      const maxRowspan = Math.min(rawRowspan, rows.length - rowIndex);
      const startColumn = getCellStartColumn(row, cell);
      for (let offset = 1; offset < maxRowspan; offset++) {
        const rowToChange = rows[rowIndex + offset];
        if (!rowToChange) continue;
        if (!Array.isArray(rowToChange.content)) {
          rowToChange.content = [];
        }
        const existingCell = findCellCoveringColumn(rowToChange, startColumn);
        if (existingCell?.attrs?.continueMerge) continue;
        const mergedCell = {
          type: cell.type,
          content: [editorSchema.nodes.paragraph.createAndFill().toJSON()],
          attrs: {
            ...cell.attrs,
            rowspan: null,
            continueMerge: true
          }
        };
        const insertionIndex = findInsertionIndexForColumn(rowToChange, startColumn);
        rowToChange.content.splice(insertionIndex, 0, mergedCell);
      }
    }
  }
  return table;
}
const translator$R = NodeTranslator.from({
  xmlName: "w:bidiVisual",
  sdNodeOrKeyName: "rightToLeft",
  encode: ({ nodes }) => parseBoolean(nodes[0].attributes?.["w:val"] ?? "1"),
  decode: ({ node }) => node.attrs.rightToLeft ? { attributes: {} } : void 0
});
const translator$Q = NodeTranslator.from(createSingleAttrPropertyHandler("w:tblCaption", "caption"));
const translator$P = NodeTranslator.from(createSingleAttrPropertyHandler("w:tblDescription", "description"));
const translator$O = NodeTranslator.from(createMeasurementPropertyHandler("w:tblInd", "tableIndent"));
const translator$N = NodeTranslator.from(createSingleAttrPropertyHandler("w:tblLayout", "tableLayout", "w:type"));
const tblLookBitmask = Object.freeze({
  firstRow: 32,
  lastRow: 64,
  firstColumn: 128,
  lastColumn: 256,
  noHBand: 512,
  noVBand: 1024
});
const decodeTblLookVal = (val) => {
  if (!val) return null;
  const raw = typeof val === "string" ? val.trim() : String(val);
  let numeric = Number.parseInt(raw, 16);
  if (!Number.isFinite(numeric)) {
    numeric = Number.parseInt(raw, 10);
  }
  if (!Number.isFinite(numeric)) return null;
  return Object.fromEntries(Object.entries(tblLookBitmask).map(([key, mask]) => [key, (numeric & mask) === mask]));
};
const translator$M = NodeTranslator.from({
  xmlName: "w:tblLook",
  sdNodeOrKeyName: "tblLook",
  attributes: ["w:firstColumn", "w:firstRow", "w:lastColumn", "w:lastRow", "w:noHBand", "w:noVBand"].map((attr) => createAttributeHandler(attr, null, parseBoolean, booleanToString)).concat([createAttributeHandler("w:val")]),
  encode: (params, encodedAttrs) => {
    const decoded = decodeTblLookVal(encodedAttrs.val);
    if (decoded) {
      Object.entries(decoded).forEach(([key, value]) => {
        if (!Object.prototype.hasOwnProperty.call(encodedAttrs, key)) {
          encodedAttrs[key] = value;
        }
      });
    }
    return Object.keys(encodedAttrs).length > 0 ? encodedAttrs : void 0;
  },
  decode: function({ node }, context) {
    const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs.tblLook || {} } });
    return Object.keys(decodedAttrs).length > 0 ? { attributes: decodedAttrs } : void 0;
  }
});
const translator$L = NodeTranslator.from(createSingleAttrPropertyHandler("w:tblOverlap", "overlap"));
const translator$K = NodeTranslator.from(createSingleAttrPropertyHandler("w:tblStyle", "tableStyleId"));
const translator$J = NodeTranslator.from(
  createSingleIntegerPropertyHandler("w:tblStyleColBandSize", "tableStyleColBandSize")
);
const translator$I = NodeTranslator.from(
  createSingleIntegerPropertyHandler("w:tblStyleRowBandSize", "tableStyleRowBandSize")
);
const translator$H = NodeTranslator.from(createMeasurementPropertyHandler("w:tblW", "tableWidth"));
const translator$G = NodeTranslator.from({
  xmlName: "w:tblpPr",
  sdNodeOrKeyName: "floatingTableProperties",
  attributes: ["w:leftFromText", "w:rightFromText", "w:topFromText", "w:bottomFromText", "w:tblpX", "w:tblpY"].map((attr) => createAttributeHandler(attr, null, parseInteger, integerToString)).concat(["w:horzAnchor", "w:vertAnchor", "w:tblpXSpec", "w:tblpYSpec"].map((attr) => createAttributeHandler(attr))),
  encode: (params, encodedAttrs) => {
    return Object.keys(encodedAttrs).length > 0 ? encodedAttrs : void 0;
  },
  decode: function({ node }, context) {
    const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs.floatingTableProperties || {} } });
    return Object.keys(decodedAttrs).length > 0 ? { attributes: decodedAttrs } : void 0;
  }
});
const propertyTranslators$4 = [
  translator$27,
  translator$1G,
  translator$25,
  translator$23,
  translator$1C,
  translator$21
];
const translator$F = NodeTranslator.from(
  createNestedPropertiesTranslator("w:tblCellMar", "cellMargins", propertyTranslators$4)
);
const propertyTranslators$3 = [
  translator$R,
  translator$2l,
  translator$2V,
  translator$Q,
  translator$1j,
  translator$P,
  translator$O,
  translator$N,
  translator$M,
  translator$L,
  translator$K,
  translator$J,
  translator$I,
  translator$H,
  translator$G,
  translator$1o,
  translator$F
];
const translator$E = NodeTranslator.from(
  createNestedPropertiesTranslator("w:tblPr", "tableProperties", propertyTranslators$3)
);
const translator$D = NodeTranslator.from(
  createSingleAttrPropertyHandler("w:gridCol", "col", "w:w", parseInteger, integerToString)
);
const DEFAULT_COLUMN_WIDTH_PX = 100;
const normalizeTwipWidth = (value) => {
  if (value == null) return null;
  const numericValue = typeof value === "string" ? parseInt(value, 10) : value;
  if (!Number.isFinite(numericValue) || Number.isNaN(numericValue) || numericValue <= 0) {
    return null;
  }
  return numericValue;
};
const getSchemaDefaultColumnWidthPx = (params) => {
  const defaultValue = params?.editor?.schema?.nodes?.tableCell?.spec?.attrs?.colwidth?.default;
  if (Array.isArray(defaultValue)) {
    const numericWidth = defaultValue.find((width) => typeof width === "number" && Number.isFinite(width) && width > 0);
    if (numericWidth != null) return numericWidth;
  } else if (typeof defaultValue === "number" && Number.isFinite(defaultValue) && defaultValue > 0) {
    return defaultValue;
  }
  return DEFAULT_COLUMN_WIDTH_PX;
};
const getTableWidthPx = (params) => {
  const explicitWidth = params?.node?.attrs?.tableWidth?.width;
  if (typeof explicitWidth === "number" && explicitWidth > 0) return explicitWidth;
  const tableWidth = params?.node?.attrs?.tableProperties?.tableWidth;
  if (tableWidth?.value != null && typeof tableWidth.value === "number" && tableWidth.value > 0) {
    const { value, type: type2 } = tableWidth;
    if (!type2 || type2 === "auto" || type2 === "dxa") {
      return twipsToPixels(value);
    }
  }
  return null;
};
const resolveFallbackColumnWidthTwips = (params, totalColumns, cellMinWidthTwips) => {
  const columnCount = Math.max(totalColumns, 1);
  const defaultColumnWidthPx = getSchemaDefaultColumnWidthPx(params);
  const tableWidthPx = getTableWidthPx(params);
  const safeDefaultPx = Number.isFinite(defaultColumnWidthPx) && defaultColumnWidthPx > 0 ? defaultColumnWidthPx : DEFAULT_COLUMN_WIDTH_PX;
  let fallbackWidthPx = safeDefaultPx;
  if (typeof tableWidthPx === "number" && tableWidthPx > 0) {
    fallbackWidthPx = tableWidthPx / columnCount;
  }
  const fallbackWidthTwips = pixelsToTwips(fallbackWidthPx);
  if (!Number.isFinite(fallbackWidthTwips) || Number.isNaN(fallbackWidthTwips) || fallbackWidthTwips <= 0) {
    const safeDefault = Math.max(pixelsToTwips(safeDefaultPx), cellMinWidthTwips);
    return safeDefault;
  }
  return Math.max(fallbackWidthTwips, cellMinWidthTwips);
};
const XML_NODE_NAME$g = "w:tblGrid";
const SD_ATTR_KEY$1 = "grid";
const cellMinWidth = pixelsToTwips(10);
const encode$v = (params) => {
  const { nodes } = params;
  const node = nodes[0];
  const attributes = encodeProperties(
    { ...params, nodes: [node] },
    { [translator$D.xmlName]: translator$D },
    true
  );
  return {
    xmlName: XML_NODE_NAME$g,
    sdNodeOrKeyName: SD_ATTR_KEY$1,
    attributes
  };
};
const decode$x = (params) => {
  const { grid: rawGrid } = params.node.attrs || {};
  const grid = Array.isArray(rawGrid) ? rawGrid : [];
  const { firstRow = {}, preferTableGrid = false, totalColumns: requestedColumns } = params.extraParams || {};
  const cellNodes = firstRow.content?.filter((n) => n.type === "tableCell") ?? [];
  let colWidthsFromCellNodes = cellNodes.flatMap((cell) => {
    const spanCount = Math.max(1, cell?.attrs?.colspan ?? 1);
    const colwidth = cell.attrs?.colwidth;
    return Array.from({ length: spanCount }).map((_2, span) => Array.isArray(colwidth) ? colwidth[span] : void 0);
  });
  const columnCountFromCells = colWidthsFromCellNodes.length;
  const gridColumnCount = grid.length;
  let totalColumns = Math.max(columnCountFromCells, gridColumnCount);
  if (typeof requestedColumns === "number" && Number.isFinite(requestedColumns) && requestedColumns > 0) {
    totalColumns = requestedColumns;
  } else if (preferTableGrid && gridColumnCount > 0) {
    totalColumns = gridColumnCount;
  }
  if (colWidthsFromCellNodes.length > totalColumns) {
    colWidthsFromCellNodes = colWidthsFromCellNodes.slice(0, totalColumns);
  }
  const fallbackColumnWidthTwips = resolveFallbackColumnWidthTwips(params, totalColumns, cellMinWidth);
  const elements = [];
  const pushColumn = (widthTwips, { enforceMinimum = false } = {}) => {
    let numericWidth = typeof widthTwips === "string" ? parseInt(widthTwips, 10) : widthTwips;
    let shouldEnforceMinimum = enforceMinimum;
    if (numericWidth == null || Number.isNaN(numericWidth) || numericWidth <= 0) {
      numericWidth = fallbackColumnWidthTwips;
      shouldEnforceMinimum = true;
    }
    const roundedWidth = Math.round(numericWidth);
    const minimumWidth = shouldEnforceMinimum ? cellMinWidth : 1;
    const safeWidth = Math.max(roundedWidth, minimumWidth);
    const decoded = translator$D.decode({
      node: { type: (
        /** @type {string} */
        translator$D.sdNodeOrKeyName
      ), attrs: { col: safeWidth } }
    });
    if (decoded) elements.push(decoded);
  };
  for (let columnIndex = 0; columnIndex < totalColumns; ++columnIndex) {
    const rawWidth = colWidthsFromCellNodes[columnIndex];
    const cellWidthPixels = typeof rawWidth === "number" && Number.isFinite(rawWidth) ? rawWidth : Number(rawWidth);
    const hasCellWidth = Number.isFinite(cellWidthPixels) && cellWidthPixels > 0;
    const colGridAttrs = grid?.[columnIndex] || {};
    const gridWidthTwips = normalizeTwipWidth(colGridAttrs.col);
    const gridWidthPixels = gridWidthTwips != null ? twipsToPixels(gridWidthTwips) : null;
    let cellWidthTwips;
    let enforceMinimum = false;
    if (gridWidthTwips != null) {
      cellWidthTwips = gridWidthTwips;
    } else if (hasCellWidth) {
      const tolerance = 0.5;
      if (gridWidthTwips != null && gridWidthPixels != null && Math.abs(gridWidthPixels - cellWidthPixels) <= tolerance) {
        cellWidthTwips = gridWidthTwips;
      } else {
        cellWidthTwips = pixelsToTwips(cellWidthPixels);
      }
    } else {
      cellWidthTwips = fallbackColumnWidthTwips;
      enforceMinimum = true;
    }
    pushColumn(cellWidthTwips, { enforceMinimum });
  }
  const newNode = {
    name: XML_NODE_NAME$g,
    attributes: {},
    elements
  };
  return newNode;
};
const config$f = {
  xmlName: XML_NODE_NAME$g,
  sdNodeOrKeyName: SD_ATTR_KEY$1,
  encode: encode$v,
  decode: decode$x
};
const translator$C = NodeTranslator.from(config$f);
const propertyTranslators$2 = [translator$1O, translator$2w, translator$E, translator$1e, translator$1q];
const attributeHandlers$1 = [createAttributeHandler("w:type")];
const translator$B = NodeTranslator.from(
  createNestedPropertiesTranslator("w:tblStylePr", "tableStyleProperties", propertyTranslators$2, {}, attributeHandlers$1)
);
const DEFAULT_PAGE_WIDTH_TWIPS = 12240;
const DEFAULT_PAGE_MARGIN_TWIPS = 1440;
const DEFAULT_CONTENT_WIDTH_TWIPS = DEFAULT_PAGE_WIDTH_TWIPS - 2 * DEFAULT_PAGE_MARGIN_TWIPS;
const MIN_COLUMN_WIDTH_TWIPS = pixelsToTwips(10);
const pctToPercent = (value) => {
  if (value == null) return null;
  return value / 50;
};
const resolveContentWidthTwips = () => DEFAULT_CONTENT_WIDTH_TWIPS;
const resolveMeasurementWidthPx = (measurement) => {
  if (!measurement || typeof measurement.value !== "number" || measurement.value <= 0) return null;
  const { value, type: type2 } = measurement;
  if (!type2 || type2 === "auto") return null;
  if (type2 === "dxa") return twipsToPixels(value);
  if (type2 === "pct") {
    const percent = pctToPercent(value);
    if (percent == null || percent <= 0) return null;
    const widthTwips = resolveContentWidthTwips() * percent / 100;
    return twipsToPixels(widthTwips);
  }
  return null;
};
const countColumnsInRow = (row) => {
  if (!row?.elements?.length) return 0;
  return row.elements.reduce((count, element) => {
    if (element.name !== "w:tc") return count;
    const tcPr = element.elements?.find((el) => el.name === "w:tcPr");
    const gridSpan = tcPr?.elements?.find((el) => el.name === "w:gridSpan");
    const spanValue = parseInt(gridSpan?.attributes?.["w:val"] || "1", 10);
    return count + (Number.isFinite(spanValue) && spanValue > 0 ? spanValue : 1);
  }, 0);
};
const clampColumnWidthTwips = (value) => Math.max(Math.round(value), MIN_COLUMN_WIDTH_TWIPS);
const createFallbackGrid = (columnCount, columnWidthTwips) => Array.from({ length: columnCount }, () => ({ col: clampColumnWidthTwips(columnWidthTwips) }));
const buildFallbackGridForTable = ({ params, rows, tableWidth, tableWidthMeasurement }) => {
  const firstRow = rows.find((row) => row.elements?.some((el) => el.name === "w:tc"));
  const columnCount = countColumnsInRow(firstRow);
  if (!columnCount) return null;
  const schemaDefaultPx = getSchemaDefaultColumnWidthPx(
    /** @type {any} */
    params
  );
  const minimumColumnWidthPx = Number.isFinite(schemaDefaultPx) && schemaDefaultPx > 0 ? schemaDefaultPx : DEFAULT_COLUMN_WIDTH_PX;
  let totalWidthPx;
  if (tableWidthMeasurement) {
    const resolved = resolveMeasurementWidthPx(tableWidthMeasurement);
    if (resolved != null) totalWidthPx = resolved;
  }
  if (totalWidthPx == null && tableWidth?.width && tableWidth.width > 0) {
    totalWidthPx = tableWidth.width;
  }
  if (totalWidthPx == null) {
    totalWidthPx = minimumColumnWidthPx * columnCount;
  }
  const rawColumnWidthPx = Math.max(totalWidthPx / columnCount, minimumColumnWidthPx);
  const columnWidthTwips = clampColumnWidthTwips(pixelsToTwips(rawColumnWidthPx));
  const fallbackColumnWidthPx = twipsToPixels(columnWidthTwips);
  return {
    grid: createFallbackGrid(columnCount, columnWidthTwips),
    columnWidths: Array(columnCount).fill(fallbackColumnWidthPx)
  };
};
const XML_NODE_NAME$f = "w:tbl";
const SD_NODE_NAME$e = "table";
const INDENT_TWIPS_TOLERANCE = 5;
const sumColumnTwips = (columns = []) => columns.reduce((sum, col) => {
  const raw = col?.col;
  const value = typeof raw === "number" ? raw : Number.parseInt(raw, 10);
  return Number.isFinite(value) ? sum + value : sum;
}, 0);
const getFirstRowCellWidthSumTwips = (rows = []) => {
  const firstRow = rows.find((row) => row?.elements?.some((el) => el.name === "w:tc"));
  if (!firstRow?.elements) return null;
  const cells = firstRow.elements.filter((el) => el.name === "w:tc");
  if (!cells.length) return null;
  let sum = 0;
  for (const cell of cells) {
    const tcPr = cell.elements?.find((el) => el.name === "w:tcPr");
    const tcW = tcPr?.elements?.find((el) => el.name === "w:tcW");
    const rawWidth = tcW?.attributes?.["w:w"];
    const width = typeof rawWidth === "number" ? rawWidth : Number.parseInt(rawWidth, 10);
    if (!Number.isFinite(width)) return null;
    sum += width;
  }
  return sum;
};
const encode$u = (params, encodedAttrs) => {
  const { nodes } = params;
  const node = nodes[0];
  const tblPr = node.elements.find((el) => el.name === "w:tblPr");
  if (tblPr) {
    const encodedProperties = translator$E.encode({ ...params, nodes: [tblPr] });
    encodedAttrs["tableProperties"] = encodedProperties || {};
  } else {
    encodedAttrs["tableProperties"] || (encodedAttrs["tableProperties"] = {});
  }
  const tblGrid = node.elements.find((el) => el.name === "w:tblGrid");
  if (tblGrid) {
    encodedAttrs["grid"] = translator$C.encode({ ...params, nodes: [tblGrid] }).attributes;
  }
  [
    "tableStyleId",
    "justification",
    "tableLayout",
    ["tableIndent", ({ value, type: type2 }) => ({ width: twipsToPixels(value), type: type2 })],
    ["tableCellSpacing", ({ value, type: type2 }) => ({ w: String(value), type: type2 })]
  ].forEach((prop) => {
    let key;
    let transform;
    if (Array.isArray(prop)) {
      [key, transform] = prop;
    } else {
      key = prop;
      transform = (v2) => v2;
    }
    if (encodedAttrs.tableProperties[key]) {
      encodedAttrs[key] = transform(encodedAttrs.tableProperties[key]);
    }
  });
  if (encodedAttrs.tableCellSpacing) {
    encodedAttrs["borderCollapse"] = "separate";
  }
  if (encodedAttrs.tableProperties.tableWidth) {
    const tableWidthMeasurement = encodedAttrs.tableProperties.tableWidth;
    const widthPx = twipsToPixels(tableWidthMeasurement.value);
    if (widthPx != null) {
      encodedAttrs.tableWidth = {
        width: widthPx,
        type: tableWidthMeasurement.type
      };
    } else if (tableWidthMeasurement.type === "auto") {
      encodedAttrs.tableWidth = {
        width: 0,
        type: tableWidthMeasurement.type
      };
    }
  }
  const tableLook = encodedAttrs.tableProperties.tblLook;
  const borderProps = _processTableBorders(encodedAttrs.tableProperties.borders || {});
  const referencedStyles = _getReferencedTableStyles(encodedAttrs.tableStyleId, params) || {};
  encodedAttrs.borders = { ...referencedStyles.borders, ...borderProps };
  encodedAttrs.tableProperties.cellMargins = referencedStyles.cellMargins = {
    ...referencedStyles.cellMargins,
    ...encodedAttrs.tableProperties.cellMargins
  };
  const rows = node.elements.filter((el) => el.name === "w:tr");
  let columnWidths = Array.isArray(encodedAttrs["grid"]) ? encodedAttrs["grid"].map((item) => twipsToPixels(item.col)) : [];
  const tableIndentTwips = encodedAttrs.tableProperties?.tableIndent?.value;
  const hasIndent = Number.isFinite(tableIndentTwips) && tableIndentTwips !== 0;
  const hasExplicitGrid = Boolean(tblGrid);
  const gridTwipsTotal = hasExplicitGrid ? sumColumnTwips(encodedAttrs["grid"]) : null;
  const rowTcWTwipsTotal = hasExplicitGrid && hasIndent ? getFirstRowCellWidthSumTwips(rows) : null;
  const indentDiff = rowTcWTwipsTotal != null && gridTwipsTotal != null ? rowTcWTwipsTotal - gridTwipsTotal : null;
  const preferTableGridWidths = hasExplicitGrid && hasIndent && gridTwipsTotal != null && rowTcWTwipsTotal != null && Math.sign(indentDiff) === Math.sign(tableIndentTwips) && Math.abs(indentDiff - tableIndentTwips) <= INDENT_TWIPS_TOLERANCE;
  if (!columnWidths.length) {
    const fallback = buildFallbackGridForTable({
      params,
      rows,
      tableWidth: encodedAttrs.tableWidth,
      tableWidthMeasurement: encodedAttrs.tableProperties.tableWidth
    });
    if (fallback) {
      encodedAttrs.grid = fallback.grid;
      columnWidths = fallback.columnWidths;
    }
  }
  const content = [];
  const totalColumns = columnWidths.length;
  const totalRows = rows.length;
  const activeRowSpans = totalColumns > 0 ? new Array(totalColumns).fill(0) : [];
  rows.forEach((row, rowIndex) => {
    const result = translator$1d.encode({
      ...params,
      path: [...params.path || [], node],
      nodes: [row],
      extraParams: {
        row,
        table: node,
        tableProperties: encodedAttrs.tableProperties,
        tableBorders: encodedAttrs.borders,
        tableLook,
        columnWidths,
        activeRowSpans: activeRowSpans.slice(),
        rowIndex,
        totalRows,
        totalColumns,
        preferTableGridWidths,
        _referencedStyles: referencedStyles
      }
    });
    if (result) {
      content.push(result);
      if (totalColumns > 0) {
        const activeRowSpansForCurrentRow = activeRowSpans.slice();
        for (let col = 0; col < totalColumns; col++) {
          if (activeRowSpans[col] > 0) {
            activeRowSpans[col] -= 1;
          }
        }
        let columnIndex = 0;
        const advanceColumnIndex = () => {
          while (columnIndex < totalColumns && activeRowSpansForCurrentRow[columnIndex] > 0) {
            columnIndex += 1;
          }
        };
        advanceColumnIndex();
        result.content?.forEach((cell) => {
          advanceColumnIndex();
          const colspan = Math.max(1, cell.attrs?.colspan || 1);
          const rowspan = Math.max(1, cell.attrs?.rowspan || 1);
          if (rowspan > 1) {
            for (let offset = 0; offset < colspan && columnIndex + offset < totalColumns; offset++) {
              const targetIndex = columnIndex + offset;
              const remainingRows = rowspan - 1;
              if (remainingRows > 0 && remainingRows > activeRowSpans[targetIndex]) {
                activeRowSpans[targetIndex] = remainingRows;
              }
            }
          }
          columnIndex += colspan;
          advanceColumnIndex();
        });
      }
    }
  });
  return {
    type: "table",
    content,
    attrs: encodedAttrs
  };
};
const decode$w = (params, decodedAttrs) => {
  params.node = preProcessVerticalMergeCells(params.node, params);
  const { node } = params;
  const rawGrid = node.attrs?.grid;
  const grid = Array.isArray(rawGrid) ? rawGrid : [];
  const preferTableGrid = node.attrs?.userEdited !== true && grid.length > 0;
  const totalColumns = preferTableGrid ? grid.length : void 0;
  const extraParams = {
    ...params.extraParams || {},
    preferTableGrid,
    totalColumns
  };
  const elements = translateChildNodes({ ...params, extraParams });
  const firstRow = node.content?.find((n) => n.type === "tableRow");
  const element = translator$C.decode({
    ...params,
    node: { ...node, attrs: { ...node.attrs, grid } },
    extraParams: {
      ...extraParams,
      firstRow
    }
  });
  if (element) elements.unshift(element);
  if (node.attrs?.tableProperties) {
    const properties = { ...node.attrs.tableProperties };
    const element2 = translator$E.decode({
      ...params,
      node: { ...node, attrs: { ...node.attrs, tableProperties: properties } }
    });
    if (element2) elements.unshift(element2);
  }
  return {
    name: "w:tbl",
    attributes: decodedAttrs || {},
    elements
  };
};
function _processTableBorders(rawBorders) {
  const borders = {};
  Object.entries(rawBorders).forEach(([name, attributes]) => {
    const attrs = {};
    const color = attributes.color;
    const size = attributes.size;
    const val = attributes.val;
    if (color && color !== "auto") attrs["color"] = color.startsWith("#") ? color : `#${color}`;
    if (size && size !== "auto") attrs["size"] = eighthPointsToPixels(size);
    if (val) attrs["val"] = val;
    borders[name] = attrs;
  });
  return borders;
}
function _getReferencedTableStyles(tableStyleReference, params) {
  if (!tableStyleReference) return null;
  const stylesToReturn = {};
  const { docx } = params;
  const styles = docx["word/styles.xml"];
  const { elements } = styles.elements[0];
  const styleElements = elements.filter((el) => el.name === "w:style");
  const styleTag = styleElements.find((el) => el.attributes["w:styleId"] === tableStyleReference);
  if (!styleTag) return null;
  stylesToReturn.name = styleTag.elements.find((el) => el.name === "w:name");
  const basedOn = styleTag.elements.find((el) => el.name === "w:basedOn");
  let baseTblPr;
  if (basedOn?.attributes) {
    const baseStyles = styleElements.find((el) => el.attributes["w:styleId"] === basedOn.attributes["w:val"]);
    baseTblPr = baseStyles ? baseStyles.elements.find((el) => el.name === "w:tblPr") : {};
  }
  const pPr = styleTag.elements.find((el) => el.name === "w:pPr");
  if (pPr) {
    const justification = pPr.elements.find((el) => el.name === "w:jc");
    if (justification?.attributes) stylesToReturn.justification = justification.attributes["w:val"];
  }
  const rPr = styleTag?.elements.find((el) => el.name === "w:rPr");
  if (rPr) {
    const fonts = rPr.elements.find((el) => el.name === "w:rFonts");
    if (fonts) {
      const { "w:ascii": ascii, "w:hAnsi": hAnsi, "w:cs": cs } = fonts.attributes;
      stylesToReturn.fonts = { ascii, hAnsi, cs };
    }
    const fontSize = rPr.elements.find((el) => el.name === "w:sz");
    if (fontSize?.attributes) stylesToReturn.fontSize = halfPointToPoints(fontSize.attributes["w:val"]) + "pt";
  }
  const tblPr = styleTag.elements.find((el) => el.name === "w:tblPr");
  if (tblPr && tblPr.elements) {
    if (baseTblPr && baseTblPr.elements) {
      tblPr.elements = [...baseTblPr.elements, ...tblPr.elements];
    }
    const tableProperties = translator$E.encode({ ...params, nodes: [tblPr] });
    if (tableProperties) {
      const borders = _processTableBorders(tableProperties.borders || {});
      if (borders || Object.keys(borders).length) stylesToReturn.borders = borders;
      const cellMargins = {};
      Object.entries(tableProperties.cellMargins || {}).forEach(([key, attrs]) => {
        if (attrs?.value != null) {
          cellMargins[key] = {
            value: attrs.value,
            type: attrs.type || "dxa"
          };
        }
      });
      if (Object.keys(cellMargins).length) stylesToReturn.cellMargins = cellMargins;
    }
  }
  const tblStylePr = styleTag.elements.filter((el) => el.name === "w:tblStylePr");
  let styleProps = {};
  if (tblStylePr) {
    styleProps = tblStylePr.reduce((acc, el) => {
      acc[el.attributes["w:type"]] = translator$B.encode({ ...params, nodes: [el] });
      return acc;
    }, {});
  }
  return {
    ...stylesToReturn,
    ...styleProps
  };
}
const config$e = {
  xmlName: XML_NODE_NAME$f,
  sdNodeOrKeyName: SD_NODE_NAME$e,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$u,
  decode: decode$w,
  attributes: []
};
const translator$A = NodeTranslator.from(config$e);
const encode$t = (attributes) => {
  return attributes["w:id"];
};
const decode$v = (attrs) => {
  return attrs.id;
};
const attrConfig$g = Object.freeze({
  xmlName: "w:id",
  sdName: "id",
  encode: encode$t,
  decode: decode$v
});
const encode$s = (attributes) => {
  return attributes["w:name"];
};
const decode$u = (attrs) => {
  return attrs.name;
};
const attrConfig$f = Object.freeze({
  xmlName: "w:name",
  sdName: "name",
  encode: encode$s,
  decode: decode$u
});
const encode$r = (attributes) => {
  return attributes["w:colFirst"];
};
const decode$t = (attrs) => {
  return attrs.colFirst;
};
const attrConfig$e = Object.freeze({
  xmlName: "w:colFirst",
  sdName: "colFirst",
  encode: encode$r,
  decode: decode$t
});
const encode$q = (attributes) => {
  return attributes["w:colLast"];
};
const decode$s = (attrs) => {
  return attrs.colLast;
};
const attrConfig$d = Object.freeze({
  xmlName: "w:colLast",
  sdName: "colLast",
  encode: encode$q,
  decode: decode$s
});
const encode$p = (attributes) => {
  return attributes["w:displacedByCustomXml"];
};
const decode$r = (attrs) => {
  return attrs.displacedByCustomXml;
};
const attrConfig$c = Object.freeze({
  xmlName: "w:displacedByCustomXml",
  sdName: "displacedByCustomXml",
  encode: encode$p,
  decode: decode$r
});
const bookmarkStartAttrConfigs = [attrConfig$g, attrConfig$f, attrConfig$e, attrConfig$d, attrConfig$c];
const XML_NODE_NAME$e = "w:bookmarkStart";
const SD_NODE_NAME$d = "bookmarkStart";
const encode$o = (params, encodedAttrs = {}) => {
  return {
    type: "bookmarkStart",
    attrs: encodedAttrs
  };
};
const decode$q = (params, decodedAttrs = {}) => {
  const result = {
    name: "w:bookmarkStart",
    elements: []
  };
  if (decodedAttrs && Object.keys(decodedAttrs).length) {
    result.attributes = decodedAttrs;
  }
  return result;
};
const config$d = {
  xmlName: XML_NODE_NAME$e,
  sdNodeOrKeyName: SD_NODE_NAME$d,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$o,
  decode: decode$q,
  attributes: bookmarkStartAttrConfigs
};
const translator$z = NodeTranslator.from(config$d);
const encode$n = (attributes) => {
  return attributes["w:id"];
};
const decode$p = (attrs) => {
  return attrs.id;
};
const attrConfig$b = Object.freeze({
  xmlName: "w:id",
  sdName: "id",
  encode: encode$n,
  decode: decode$p
});
const encode$m = (attributes) => {
  return attributes["w:displacedByCustomXml"];
};
const decode$o = (attrs) => {
  return attrs.displacedByCustomXml;
};
const attrConfig$a = Object.freeze({
  xmlName: "w:displacedByCustomXml",
  sdName: "displacedByCustomXml",
  encode: encode$m,
  decode: decode$o
});
const bookmarkEndAttrConfigs = [attrConfig$b, attrConfig$a];
const XML_NODE_NAME$d = "w:bookmarkEnd";
const SD_NODE_NAME$c = "bookmarkEnd";
const encode$l = (params, encodedAttrs = {}) => {
  return {
    type: "bookmarkEnd",
    attrs: encodedAttrs
  };
};
const decode$n = (params, decodedAttrs = {}) => {
  const result = {
    name: "w:bookmarkEnd",
    elements: []
  };
  if (decodedAttrs && Object.keys(decodedAttrs).length) {
    result.attributes = decodedAttrs;
  }
  return result;
};
const config$c = {
  xmlName: XML_NODE_NAME$d,
  sdNodeOrKeyName: SD_NODE_NAME$c,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$l,
  decode: decode$n,
  attributes: bookmarkEndAttrConfigs
};
const translator$y = NodeTranslator.from(config$c);
const decode$m = (attrs) => attrs?.["w:id"];
const attrConfig$9 = Object.freeze({
  xmlName: "w:id",
  sdName: "w:id",
  // We do not translate it from 'w:id' to 'id' when encoding, so the name is the same
  encode: () => {
  },
  decode: decode$m
});
const XML_NODE_NAME$c = "w:commentRange";
const SD_NODE_NAME$b = "commentRange";
const decode$l = (params) => {
  const { node, comments, commentsExportType, exportedCommentDefs } = params;
  if (!node) return;
  if (!comments) return;
  if (exportedCommentDefs?.length === 0) return;
  if (commentsExportType === "clean") return;
  const commentNodeId = node.attrs["w:id"];
  const nodeIdStr = String(commentNodeId);
  const originalComment = comments.find((comment) => {
    return String(comment.commentId) === nodeIdStr || String(comment.importedId) === nodeIdStr;
  });
  if (!originalComment) return;
  const parentCommentId = originalComment.parentCommentId;
  const parentComment = comments.find(
    ({ commentId, importedId }) => commentId === parentCommentId || importedId === parentCommentId
  );
  const isInternal = parentComment?.isInternal || originalComment.isInternal;
  if (commentsExportType === "external" && isInternal) return;
  if (node.type !== "commentRangeStart" && node.type !== "commentRangeEnd") {
    return;
  }
  const { type: type2 } = node;
  const commentIndex = comments.findIndex((comment) => comment.commentId === originalComment.commentId);
  let commentSchema = getCommentSchema(type2, commentIndex);
  if (type2 === "commentRangeEnd") {
    const commentReference = {
      name: "w:r",
      elements: [{ name: "w:commentReference", attributes: { "w:id": String(commentIndex) } }]
    };
    commentSchema = [commentSchema, commentReference];
  }
  const usesRangeThreading = originalComment.threadingStyleOverride === "range-based" || originalComment.threadingMethod === "range-based" || originalComment.originalXmlStructure?.hasCommentsExtended === false;
  if (!usesRangeThreading) {
    return commentSchema;
  }
  if (!parentComment?.trackedChange) {
    return commentSchema;
  }
  const trackedChangeType = parentComment.trackedChangeType;
  const isReplace = trackedChangeType === "both";
  const wrapperName = type2 === "commentRangeStart" ? "w:ins" : isReplace ? "w:del" : trackedChangeType === "trackDelete" ? "w:del" : "w:ins";
  const createdTime = parentComment.createdTime || Date.now();
  const date = new Date(createdTime).toISOString().replace(/\.\d{3}Z$/, "Z");
  const wrapperAttributes = {
    "w:id": String(parentComment.commentId),
    ...parentComment.creatorName ? { "w:author": parentComment.creatorName } : {},
    ...parentComment.creatorEmail ? { "w:authorEmail": parentComment.creatorEmail } : {},
    "w:date": date
  };
  return {
    name: wrapperName,
    attributes: wrapperAttributes,
    elements: Array.isArray(commentSchema) ? commentSchema : [commentSchema]
  };
};
const getCommentSchema = (type2, commentIndex) => {
  return {
    name: `w:${type2}`,
    attributes: {
      "w:id": String(commentIndex)
    }
  };
};
const getConfig = (type2) => {
  const sdName = `${SD_NODE_NAME$b}${type2}`;
  const isStart = type2 === "Start";
  return {
    xmlName: `${XML_NODE_NAME$c}${type2}`,
    sdNodeOrKeyName: sdName,
    type: NodeTranslator.translatorTypes.NODE,
    encode: ({ nodes }) => {
      const node = nodes?.[0];
      if (!node) return void 0;
      const attrs = node.attributes ? { ...node.attributes } : {};
      return {
        type: isStart ? "commentRangeStart" : "commentRangeEnd",
        attrs
      };
    },
    decode: decode$l,
    attributes: [attrConfig$9]
  };
};
const commentRangeStartTranslator = NodeTranslator.from(getConfig("Start"));
const commentRangeEndTranslator = NodeTranslator.from(getConfig("End"));
const encode$k = (attributes) => {
  return attributes["w:id"];
};
const decode$k = (attrs) => {
  return attrs.id;
};
const attrConfig$8 = Object.freeze({
  xmlName: "w:id",
  sdName: "id",
  encode: encode$k,
  decode: decode$k
});
const encode$j = (attributes) => {
  return attributes["w:edGrp"];
};
const decode$j = (attrs) => {
  return attrs.edGrp;
};
const attrConfig$7 = Object.freeze({
  xmlName: "w:edGrp",
  sdName: "edGrp",
  encode: encode$j,
  decode: decode$j
});
const encode$i = (attributes) => {
  return attributes["w:ed"];
};
const decode$i = (attrs) => {
  return attrs.ed;
};
const attrConfig$6 = Object.freeze({
  xmlName: "w:ed",
  sdName: "ed",
  encode: encode$i,
  decode: decode$i
});
const encode$h = (attributes) => {
  return parseInteger(attributes["w:colFirst"]);
};
const decode$h = (attrs) => {
  return integerToString(attrs.colFirst);
};
const attrConfig$5 = Object.freeze({
  xmlName: "w:colFirst",
  sdName: "colFirst",
  encode: encode$h,
  decode: decode$h
});
const encode$g = (attributes) => {
  return parseInteger(attributes["w:colLast"]);
};
const decode$g = (attrs) => {
  return integerToString(attrs.colLast);
};
const attrConfig$4 = Object.freeze({
  xmlName: "w:colLast",
  sdName: "colLast",
  encode: encode$g,
  decode: decode$g
});
const validXmlAttributes$4 = [attrConfig$8, attrConfig$7, attrConfig$6, attrConfig$5, attrConfig$4];
const XML_NODE_NAME$b = "w:permStart";
const SD_NODE_NAME$a = "permStart";
const encode$f = (params, encodedAttrs = {}) => {
  return {
    type: "permStart",
    attrs: encodedAttrs
  };
};
const decode$f = (params, decodedAttrs = {}) => {
  const result = {
    name: XML_NODE_NAME$b,
    elements: []
  };
  if (decodedAttrs && Object.keys(decodedAttrs).length) {
    result.attributes = decodedAttrs;
  }
  return result;
};
const config$b = {
  xmlName: XML_NODE_NAME$b,
  sdNodeOrKeyName: SD_NODE_NAME$a,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$f,
  decode: decode$f,
  attributes: validXmlAttributes$4
};
const translator$x = NodeTranslator.from(config$b);
const encode$e = (attributes) => {
  return attributes["w:id"];
};
const decode$e = (attrs) => {
  return attrs.id;
};
const attrConfig$3 = Object.freeze({
  xmlName: "w:id",
  sdName: "id",
  encode: encode$e,
  decode: decode$e
});
const encode$d = (attributes) => {
  return attributes["w:displacedByCustomXml"];
};
const decode$d = (attrs) => {
  return attrs.displacedByCustomXml;
};
const attrConfig$2 = Object.freeze({
  xmlName: "w:displacedByCustomXml",
  sdName: "displacedByCustomXml",
  encode: encode$d,
  decode: decode$d
});
const validXmlAttributes$3 = [attrConfig$3, attrConfig$2];
const XML_NODE_NAME$a = "w:permEnd";
const SD_NODE_NAME$9 = "permEnd";
const encode$c = (params, encodedAttrs = {}) => {
  return {
    type: "permEnd",
    attrs: encodedAttrs
  };
};
const decode$c = (params, decodedAttrs = {}) => {
  const result = {
    name: XML_NODE_NAME$a,
    elements: []
  };
  if (decodedAttrs && Object.keys(decodedAttrs).length) {
    result.attributes = decodedAttrs;
  }
  return result;
};
const config$a = {
  xmlName: XML_NODE_NAME$a,
  sdNodeOrKeyName: SD_NODE_NAME$9,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$c,
  decode: decode$c,
  attributes: validXmlAttributes$3
};
const translator$w = NodeTranslator.from(config$a);
const XML_NODE_NAME$9 = "sd:pageReference";
const SD_NODE_NAME$8 = "pageReference";
const encode$b = (params) => {
  const { nodes = [], nodeListHandler } = params || {};
  const node = nodes[0];
  const processedText = nodeListHandler.handler({
    ...params,
    nodes: node.elements
  });
  const processedNode = {
    type: "pageReference",
    attrs: {
      instruction: node.attributes?.instruction || "",
      marksAsAttrs: node.marks || []
    },
    content: processedText
  };
  return processedNode;
};
const decode$b = (params) => {
  const { node } = params;
  const outputMarks = processOutputMarks(node.attrs?.marksAsAttrs || []);
  const contentNodes = (node.content ?? []).flatMap((n) => exportSchemaToJson({ ...params, node: n }));
  const translated = [
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:fldChar",
          attributes: {
            "w:fldCharType": "begin"
          }
        }
      ]
    },
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:instrText",
          attributes: { "xml:space": "preserve" },
          elements: [
            {
              type: "text",
              text: `${node.attrs.instruction}`
            }
          ]
        }
      ]
    },
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:fldChar",
          attributes: {
            "w:fldCharType": "separate"
          }
        }
      ]
    },
    ...contentNodes,
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:fldChar",
          attributes: {
            "w:fldCharType": "end"
          }
        }
      ]
    }
  ];
  return translated;
};
const config$9 = {
  xmlName: XML_NODE_NAME$9,
  sdNodeOrKeyName: SD_NODE_NAME$8,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$b,
  decode: decode$b
};
const translator$v = NodeTranslator.from(config$9);
const XML_NODE_NAME$8 = "sd:tableOfContents";
const SD_NODE_NAME$7 = "tableOfContents";
const encode$a = (params) => {
  const { nodes = [], nodeListHandler } = params || {};
  const node = nodes[0];
  const processedContent = nodeListHandler.handler({
    ...params,
    nodes: node.elements || []
  });
  const processedNode = {
    type: "tableOfContents",
    attrs: {
      instruction: node.attributes?.instruction || ""
    },
    content: processedContent
  };
  return processedNode;
};
const decode$a = (params) => {
  const { node } = params;
  const contentNodes = node.content.map((n) => exportSchemaToJson({ ...params, node: n }));
  const tocBeginElements = [
    {
      name: "w:r",
      elements: [{ name: "w:fldChar", attributes: { "w:fldCharType": "begin" }, elements: [] }]
    },
    {
      name: "w:r",
      elements: [
        {
          name: "w:instrText",
          attributes: { "xml:space": "preserve" },
          elements: [{ text: node.attrs?.instruction || "", type: "text", name: "#text", elements: [] }]
        }
      ]
    },
    { name: "w:r", elements: [{ name: "w:fldChar", attributes: { "w:fldCharType": "separate" }, elements: [] }] }
  ];
  if (contentNodes.length > 0) {
    const firstParagraph = contentNodes[0];
    let insertIndex = 0;
    if (firstParagraph.elements) {
      const pPrIndex = firstParagraph.elements.findIndex((el) => el.name === "w:pPr");
      insertIndex = pPrIndex >= 0 ? pPrIndex + 1 : 0;
    } else {
      firstParagraph.elements = [];
    }
    firstParagraph.elements.splice(insertIndex, 0, ...tocBeginElements);
  } else {
    contentNodes.push({
      name: "w:p",
      elements: tocBeginElements
    });
  }
  const tocEndElements = [
    { name: "w:r", elements: [{ name: "w:fldChar", attributes: { "w:fldCharType": "end" }, elements: [] }] }
  ];
  const lastParagraph = contentNodes[contentNodes.length - 1];
  if (lastParagraph.elements) {
    lastParagraph.elements.push(...tocEndElements);
  } else {
    lastParagraph.elements = [...tocEndElements];
  }
  return contentNodes;
};
const config$8 = {
  xmlName: XML_NODE_NAME$8,
  sdNodeOrKeyName: SD_NODE_NAME$7,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$a,
  decode: decode$a
};
const translator$u = NodeTranslator.from(config$8);
const buildInstructionElements = (instruction, instructionTokens) => {
  const tokens = Array.isArray(instructionTokens) ? instructionTokens : [];
  if (tokens.length > 0) {
    return tokens.map((token) => {
      if (token?.type === "tab") {
        return { name: "w:tab", elements: [] };
      }
      const text = token?.text ?? "";
      return {
        name: "w:instrText",
        attributes: { "xml:space": "preserve" },
        elements: [{ type: "text", text }]
      };
    });
  }
  return [
    {
      name: "w:instrText",
      attributes: { "xml:space": "preserve" },
      elements: [{ type: "text", text: instruction ?? "" }]
    }
  ];
};
const XML_NODE_NAME$7 = "sd:index";
const SD_NODE_NAME$6 = "index";
const encode$9 = (params) => {
  const { nodes = [], nodeListHandler } = params || {};
  const node = nodes[0];
  const processedContent = nodeListHandler.handler({
    ...params,
    nodes: node.elements || []
  });
  return {
    type: "index",
    attrs: {
      instruction: node.attributes?.instruction || "",
      instructionTokens: node.attributes?.instructionTokens || null
    },
    content: processedContent
  };
};
const decode$9 = (params) => {
  const { node } = params;
  const contentNodes = (node.content ?? []).map((n) => exportSchemaToJson({ ...params, node: n }));
  const instructionElements = buildInstructionElements(node.attrs?.instruction, node.attrs?.instructionTokens);
  const indexBeginElements = [
    {
      name: "w:r",
      elements: [{ name: "w:fldChar", attributes: { "w:fldCharType": "begin" }, elements: [] }]
    },
    {
      name: "w:r",
      elements: instructionElements
    },
    { name: "w:r", elements: [{ name: "w:fldChar", attributes: { "w:fldCharType": "separate" }, elements: [] }] }
  ];
  if (contentNodes.length > 0) {
    const firstParagraph = contentNodes[0];
    let insertIndex = 0;
    if (firstParagraph.elements) {
      const pPrIndex = firstParagraph.elements.findIndex((el) => el.name === "w:pPr");
      insertIndex = pPrIndex >= 0 ? pPrIndex + 1 : 0;
    } else {
      firstParagraph.elements = [];
    }
    firstParagraph.elements.splice(insertIndex, 0, ...indexBeginElements);
  } else {
    contentNodes.push({
      name: "w:p",
      elements: indexBeginElements
    });
  }
  const indexEndElements = [
    { name: "w:r", elements: [{ name: "w:fldChar", attributes: { "w:fldCharType": "end" }, elements: [] }] }
  ];
  const lastParagraph = contentNodes[contentNodes.length - 1];
  if (lastParagraph.elements) {
    lastParagraph.elements.push(...indexEndElements);
  } else {
    lastParagraph.elements = [...indexEndElements];
  }
  return contentNodes;
};
const config$7 = {
  xmlName: XML_NODE_NAME$7,
  sdNodeOrKeyName: SD_NODE_NAME$6,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$9,
  decode: decode$9
};
const translator$t = NodeTranslator.from(config$7);
const XML_NODE_NAME$6 = "sd:indexEntry";
const SD_NODE_NAME$5 = "indexEntry";
const encode$8 = (params) => {
  const { nodes = [], nodeListHandler } = params || {};
  const node = nodes[0];
  const processedText = nodeListHandler.handler({
    ...params,
    nodes: node.elements
  });
  return {
    type: "indexEntry",
    attrs: {
      instruction: node.attributes?.instruction || "",
      instructionTokens: node.attributes?.instructionTokens || null,
      marksAsAttrs: node.marks || []
    },
    content: processedText
  };
};
const decode$8 = (params) => {
  const { node } = params;
  const outputMarks = processOutputMarks(node.attrs?.marksAsAttrs || []);
  const contentNodes = (node.content ?? []).flatMap((n) => exportSchemaToJson({ ...params, node: n }));
  const instructionElements = buildInstructionElements(node.attrs?.instruction, node.attrs?.instructionTokens);
  return [
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:fldChar",
          attributes: {
            "w:fldCharType": "begin"
          }
        }
      ]
    },
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        ...instructionElements
      ]
    },
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:fldChar",
          attributes: {
            "w:fldCharType": "separate"
          }
        }
      ]
    },
    ...contentNodes,
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:fldChar",
          attributes: {
            "w:fldCharType": "end"
          }
        }
      ]
    }
  ];
};
const config$6 = {
  xmlName: XML_NODE_NAME$6,
  sdNodeOrKeyName: SD_NODE_NAME$5,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$8,
  decode: decode$8
};
const translator$s = NodeTranslator.from(config$6);
const XML_NODE_NAME$5 = "sd:autoPageNumber";
const SD_NODE_NAME$4 = "page-number";
const encode$7 = (params) => {
  const { nodes = [] } = params || {};
  const node = nodes[0];
  const rPr = node.elements?.find((el) => el.name === "w:rPr");
  const marks = parseMarks(rPr || { elements: [] });
  const processedNode = {
    type: "page-number",
    attrs: {
      marksAsAttrs: marks
    }
  };
  return processedNode;
};
const decode$7 = (params) => {
  const { node } = params;
  const outputMarks = processOutputMarks(node.attrs?.marksAsAttrs || []);
  const translated = [
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:fldChar",
          attributes: {
            "w:fldCharType": "begin"
          }
        }
      ]
    },
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:instrText",
          attributes: { "xml:space": "preserve" },
          elements: [
            {
              type: "text",
              text: " PAGE"
            }
          ]
        }
      ]
    },
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:fldChar",
          attributes: {
            "w:fldCharType": "separate"
          }
        }
      ]
    },
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:fldChar",
          attributes: {
            "w:fldCharType": "end"
          }
        }
      ]
    }
  ];
  return translated;
};
const config$5 = {
  xmlName: XML_NODE_NAME$5,
  sdNodeOrKeyName: SD_NODE_NAME$4,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$7,
  decode: decode$7
};
const translator$r = NodeTranslator.from(config$5);
const XML_NODE_NAME$4 = "sd:totalPageNumber";
const SD_NODE_NAME$3 = "total-page-number";
const encode$6 = (params) => {
  const { nodes = [] } = params || {};
  const node = nodes[0];
  const rPr = node.elements?.find((el) => el.name === "w:rPr");
  const marks = parseMarks(rPr || { elements: [] });
  const processedNode = {
    type: "total-page-number",
    attrs: {
      marksAsAttrs: marks
    }
  };
  return processedNode;
};
const decode$6 = (params) => {
  const { node } = params;
  const outputMarks = processOutputMarks(node.attrs?.marksAsAttrs || []);
  const translated = [
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:fldChar",
          attributes: {
            "w:fldCharType": "begin"
          }
        }
      ]
    },
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:instrText",
          attributes: { "xml:space": "preserve" },
          elements: [
            {
              type: "text",
              text: " NUMPAGES"
            }
          ]
        }
      ]
    },
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:fldChar",
          attributes: {
            "w:fldCharType": "separate"
          }
        }
      ]
    },
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:fldChar",
          attributes: {
            "w:fldCharType": "end"
          }
        }
      ]
    }
  ];
  return translated;
};
const config$4 = {
  xmlName: XML_NODE_NAME$4,
  sdNodeOrKeyName: SD_NODE_NAME$3,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$6,
  decode: decode$6
};
const translator$q = NodeTranslator.from(config$4);
function parseInlineStyles(styleString) {
  if (!styleString) return {};
  return styleString.split(";").filter((style) => !!style.trim()).reduce((acc, style) => {
    const [prop, value] = style.split(":").map((str) => str.trim());
    if (prop && value) acc[prop] = value;
    return acc;
  }, {});
}
function handleVRectImport({ pNode, pict, params }) {
  const rect = pict.elements?.find((el) => el.name === "v:rect");
  const schemaAttrs = {};
  const rectAttrs = rect.attributes || {};
  schemaAttrs.attributes = rectAttrs;
  if (rectAttrs.style) {
    const parsedStyle = parseInlineStyles(rectAttrs.style);
    const rectStyle = buildVRectStyles(parsedStyle);
    if (rectStyle) {
      schemaAttrs.style = rectStyle;
    }
    const size = {};
    const isFullWidthHR = rectAttrs["o:hr"] === "t" || rectAttrs["o:hrstd"] === "t";
    if (parsedStyle.width !== void 0) {
      if (isFullWidthHR) {
        size.width = "100%";
      } else {
        const inlineWidth = parsePointsToPixels(parsedStyle.width);
        size.width = inlineWidth;
      }
    }
    if (parsedStyle.height !== void 0) {
      size.height = parsePointsToPixels(parsedStyle.height);
    }
    if (Object.keys(size).length > 0) {
      schemaAttrs.size = size;
    }
  }
  if (rectAttrs.fillcolor) {
    schemaAttrs.background = rectAttrs.fillcolor;
  }
  const vmlAttrs = {};
  if (rectAttrs["o:hralign"]) vmlAttrs.hralign = rectAttrs["o:hralign"];
  if (rectAttrs["o:hrstd"]) vmlAttrs.hrstd = rectAttrs["o:hrstd"];
  if (rectAttrs["o:hr"]) vmlAttrs.hr = rectAttrs["o:hr"];
  if (rectAttrs.stroked) vmlAttrs.stroked = rectAttrs.stroked;
  if (Object.keys(vmlAttrs).length > 0) {
    schemaAttrs.vmlAttributes = vmlAttrs;
  }
  const isHorizontalRule = rectAttrs["o:hr"] === "t" || rectAttrs["o:hrstd"] === "t";
  if (isHorizontalRule) {
    schemaAttrs.horizontalRule = true;
  }
  const pElement = translator$1N.encode({
    ...params,
    nodes: [{ ...pNode, elements: pNode.elements.filter((el) => el.name !== "w:r") }]
  });
  pElement.content = [
    {
      type: "contentBlock",
      attrs: schemaAttrs
    }
  ];
  return pElement;
}
function parsePointsToPixels(value) {
  if (typeof value !== "string") return value;
  if (value.endsWith("pt")) {
    const val = value.replace("pt", "");
    if (isNaN(Number(val))) {
      return 0;
    }
    const points = parseFloat(val);
    return Math.ceil(points * 1.33);
  }
  if (value.endsWith("px")) {
    const val = value.replace("px", "");
    if (isNaN(Number(val))) {
      return 0;
    }
    return parseInt(val);
  }
  const numValue = parseFloat(value);
  return isNaN(numValue) ? 0 : numValue;
}
function buildVRectStyles(styleObject) {
  let style = "";
  for (const [prop, value] of Object.entries(styleObject)) {
    style += `${prop}: ${value};`;
  }
  return style;
}
const defaultInitialXml = `<w:document xmlns:wpc="http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas" xmlns:cx="http://schemas.microsoft.com/office/drawing/2014/chartex" xmlns:cx1="http://schemas.microsoft.com/office/drawing/2015/9/8/chartex" xmlns:cx2="http://schemas.microsoft.com/office/drawing/2015/10/21/chartex" xmlns:cx3="http://schemas.microsoft.com/office/drawing/2016/5/9/chartex" xmlns:cx4="http://schemas.microsoft.com/office/drawing/2016/5/10/chartex" xmlns:cx5="http://schemas.microsoft.com/office/drawing/2016/5/11/chartex" xmlns:cx6="http://schemas.microsoft.com/office/drawing/2016/5/12/chartex" xmlns:cx7="http://schemas.microsoft.com/office/drawing/2016/5/13/chartex" xmlns:cx8="http://schemas.microsoft.com/office/drawing/2016/5/14/chartex" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:aink="http://schemas.microsoft.com/office/drawing/2016/ink" xmlns:am3d="http://schemas.microsoft.com/office/drawing/2017/model3d" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:oel="http://schemas.microsoft.com/office/2019/extlst" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:wp14="http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing" xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing" xmlns:w10="urn:schemas-microsoft-com:office:word" xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml" xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml" xmlns:w16cex="http://schemas.microsoft.com/office/word/2018/wordml/cex" xmlns:w16cid="http://schemas.microsoft.com/office/word/2016/wordml/cid" xmlns:w16="http://schemas.microsoft.com/office/word/2018/wordml" xmlns:w16sdtdh="http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash" xmlns:w16se="http://schemas.microsoft.com/office/word/2015/wordml/symex" xmlns:wpg="http://schemas.microsoft.com/office/word/2010/wordprocessingGroup" xmlns:wpi="http://schemas.microsoft.com/office/word/2010/wordprocessingInk" xmlns:wne="http://schemas.microsoft.com/office/word/2006/wordml" xmlns:wps="http://schemas.microsoft.com/office/word/2010/wordprocessingShape" mc:Ignorable="w14 w15 w16se w16cid w16 w16cex w16sdtdh wp14"><w:body></w:body></w:document>`;
const parseXmlToJson = (xml) => {
  return JSON.parse(libExports.xml2json(xml, null, 2));
};
const getInitialJSON = (parsedDocx, fallbackXml = defaultInitialXml) => {
  return parsedDocx["word/document.xml"] || parseXmlToJson(fallbackXml);
};
const handleDrawingNode = (params) => {
  const { nodes } = params;
  const validNodes = ["w:drawing", "w:p"];
  if (nodes.length === 0 || !validNodes.includes(nodes[0].name)) {
    return { nodes: [], consumed: 0 };
  }
  const mainNode = nodes[0];
  let node;
  if (mainNode.name === "w:drawing") node = mainNode;
  else node = mainNode.elements.find((el) => el.name === "w:drawing");
  if (!node) {
    return { nodes: [], consumed: 0 };
  }
  const translatorParams = { ...params, nodes: [node] };
  const schemaNode = translator$T.encode(translatorParams);
  const newNodes = schemaNode ? [schemaNode] : [];
  return { nodes: newNodes, consumed: 1 };
};
const drawingNodeHandlerEntity = {
  handlerName: "drawingNodeHandler",
  handler: handleDrawingNode
};
const XML_NODE_NAME$3 = "w:del";
const SD_ATTR_KEY = "trackDelete";
const validXmlAttributes$2 = [
  createAttributeHandler("w:id", "id"),
  createAttributeHandler("w:date", "date"),
  createAttributeHandler("w:author", "author"),
  createAttributeHandler("w:authorEmail", "authorEmail")
];
const encode$5 = (params, encodedAttrs = {}) => {
  const { nodeListHandler, extraParams = {}, converter } = params;
  const { node } = extraParams;
  if (encodedAttrs.id && converter?.trackedChangeIdMap?.has(encodedAttrs.id)) {
    encodedAttrs.id = converter.trackedChangeIdMap.get(encodedAttrs.id);
  }
  const subs = nodeListHandler.handler({
    ...params,
    insideTrackChange: true,
    nodes: node.elements,
    path: [...params.path || [], node]
  });
  encodedAttrs.importedAuthor = `${encodedAttrs.author} (imported)`;
  if (converter?.documentOrigin) {
    encodedAttrs.origin = converter.documentOrigin;
  }
  subs.forEach((subElement) => {
    subElement.marks = [];
    if (subElement?.content?.[0]) {
      if (subElement.content[0].marks === void 0) {
        subElement.content[0].marks = [];
      }
      if (subElement.content[0].type === "text") {
        subElement.content[0].marks.push({ type: "trackDelete", attrs: encodedAttrs });
      }
    }
  });
  return subs;
};
function decode$5(params) {
  const { node } = params;
  if (!node || !node.type) {
    return null;
  }
  const trackingMarks = ["trackInsert", "trackFormat", "trackDelete"];
  const marks = node.marks;
  const trackedMark = marks.find((m2) => m2.type === "trackDelete");
  const trackStyleMark = createTrackStyleMark(marks);
  node.marks = marks.filter((m2) => !trackingMarks.includes(m2.type));
  if (trackStyleMark) {
    node.marks.push(trackStyleMark);
  }
  const translatedTextNode = exportSchemaToJson({ ...params, node });
  const textNode = translatedTextNode.elements.find((n) => n.name === "w:t");
  textNode.name = "w:delText";
  return {
    name: "w:del",
    attributes: {
      "w:id": trackedMark.attrs.id,
      "w:author": trackedMark.attrs.author,
      "w:authorEmail": trackedMark.attrs.authorEmail,
      "w:date": trackedMark.attrs.date
    },
    elements: [translatedTextNode]
  };
}
const config$3 = {
  xmlName: XML_NODE_NAME$3,
  sdNodeOrKeyName: SD_ATTR_KEY,
  type: NodeTranslator.translatorTypes.ATTRIBUTE,
  encode: encode$5,
  decode: decode$5,
  attributes: validXmlAttributes$2
};
const translator$p = NodeTranslator.from(config$3);
const isTrackChangeElement = (node) => node?.name === "w:del" || node?.name === "w:ins";
const unwrapTrackChangeNode = (node) => {
  if (!node) {
    return null;
  }
  if (isTrackChangeElement(node)) {
    return node;
  }
  if (node.name === "w:sdt") {
    const content = node.elements?.find((element) => element.name === "w:sdtContent");
    if (!content?.elements?.length) {
      return null;
    }
    for (const child of content.elements) {
      const trackChange = unwrapTrackChangeNode(child);
      if (trackChange) {
        return trackChange;
      }
    }
  }
  return null;
};
const handleTrackChangeNode = (params) => {
  const { nodes } = params;
  if (nodes.length === 0) {
    return { nodes: [], consumed: 0 };
  }
  const mainNode = unwrapTrackChangeNode(nodes[0]);
  if (!mainNode) {
    return { nodes: [], consumed: 0 };
  }
  let result;
  const translatorParams = {
    ...params,
    nodes: [mainNode]
  };
  switch (mainNode.name) {
    case "w:del":
      result = translator$p.encode({
        ...translatorParams,
        extraParams: {
          ...translatorParams.extraParams,
          node: mainNode
        }
      });
      break;
    case "w:ins":
      result = translator$2f.encode({
        ...translatorParams,
        extraParams: {
          ...translatorParams.extraParams,
          node: mainNode
        }
      });
      break;
  }
  return { nodes: result, consumed: 1 };
};
const trackChangeNodeHandlerEntity = {
  handlerName: "trackChangeNodeHandler",
  handler: handleTrackChangeNode
};
const hyperlinkNodeHandlerEntity = generateV2HandlerEntity("hyperlinkNodeHandler", translator$1M);
const runNodeHandlerEntity = generateV2HandlerEntity("runNodeHandler", translator$1L);
const XML_NODE_NAME$2 = "w:t";
const SD_NODE_NAME$2 = "text";
const validXmlAttributes$1 = [createAttributeHandler("xml:space", "xmlSpace")];
const encode$4 = (params, encodedAttrs = {}) => {
  const { node } = params.extraParams;
  const { elements, type: type2, attributes } = node;
  let text;
  if (!elements) {
    return null;
  }
  if (elements.length === 1) {
    text = elements[0].text;
    const docXmlSpace = params.converter?.documentAttributes?.["xml:space"];
    const xmlSpace = encodedAttrs.xmlSpace ?? attributes?.["xml:space"] ?? elements[0]?.attributes?.["xml:space"] ?? docXmlSpace;
    if (xmlSpace !== "preserve" && typeof text === "string") {
      text = text.replace(/^[ \t\n\r]+/, "").replace(/[ \t\n\r]+$/, "");
    }
    text = text.replace(/\[\[sdspace\]\]/g, "");
    const isWhitespaceOnly = /^[ \t\n\r]*$/.test(text);
    if (xmlSpace !== "preserve" && isWhitespaceOnly) {
      return null;
    }
  } else if (!elements.length && encodedAttrs.xmlSpace === "preserve") {
    text = " ";
  } else return null;
  return {
    type: "text",
    text,
    attrs: { type: type2, attributes: attributes || {} },
    marks: []
  };
};
const decode$4 = (params) => {
  const { node, extraParams } = params;
  if (!node || !node.type) {
    return null;
  }
  const trackedMarks = ["trackDelete", "trackInsert"];
  const trackedMark = node.marks?.find((m2) => trackedMarks.includes(m2.type));
  if (trackedMark) {
    switch (trackedMark.type) {
      case "trackDelete":
        return translator$p.decode(params);
      case "trackInsert":
        return translator$2f.decode(params);
    }
  }
  const isLinkNode = node.marks?.some((m2) => m2.type === "link");
  if (isLinkNode && !extraParams?.linkProcessed) {
    return translator$1M.decode(params);
  }
  const { text, marks = [] } = node;
  return getTextNodeForExport(text, marks, params);
};
const config$2 = {
  xmlName: XML_NODE_NAME$2,
  sdNodeOrKeyName: SD_NODE_NAME$2,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$4,
  decode: decode$4,
  attributes: validXmlAttributes$1
};
const translator$o = NodeTranslator.from(config$2);
const handleTextNode = (params) => {
  const { nodes, insideTrackChange } = params;
  if (nodes.length === 0 || !(nodes[0].name === "w:t" || insideTrackChange && nodes[0].name === "w:delText")) {
    return { nodes: [], consumed: 0 };
  }
  const node = nodes[0];
  const resultNode = translator$o.encode({
    ...params,
    extraParams: {
      ...params.extraParams || {},
      node
    }
  });
  if (!resultNode) return { nodes: [], consumed: 0 };
  return {
    nodes: [resultNode],
    consumed: 1
  };
};
const textNodeHandlerEntity = {
  handlerName: "textNodeHandler",
  handler: handleTextNode
};
const handleParagraphNode = (params) => {
  const { nodes } = params;
  if (nodes.length === 0 || nodes[0].name !== "w:p") {
    return { nodes: [], consumed: 0 };
  }
  const schemaNode = translator$1N.encode(params);
  const newNodes = schemaNode ? [schemaNode] : [];
  return { nodes: newNodes, consumed: 1 };
};
const paragraphNodeHandlerEntity = {
  handlerName: "paragraphNodeHandler",
  handler: handleParagraphNode
};
const handleSdtNode = (params) => {
  const { nodes } = params;
  if (nodes.length === 0 || nodes[0].name !== "w:sdt") {
    return { nodes: [], consumed: 0 };
  }
  const result = translator$S.encode(params);
  if (!result) {
    return { nodes: [], consumed: 0 };
  }
  const resultNodes = Array.isArray(result) ? result : [result];
  return {
    nodes: resultNodes,
    consumed: 1
  };
};
const sdtNodeHandlerEntity = {
  handlerName: "sdtNodeHandler",
  handler: handleSdtNode
};
const translator$n = NodeTranslator.from(createSingleBooleanPropertyHandler("w:autoRedefine"));
const translator$m = NodeTranslator.from(createSingleAttrPropertyHandler("w:aliases"));
const translator$l = NodeTranslator.from(createSingleAttrPropertyHandler("w:basedOn"));
const encode$3 = (attributes) => {
  return attributes?.["w:id"];
};
const decode$3 = (attrs) => {
  return attrs?.id;
};
const attrConfig$1 = Object.freeze({
  xmlName: "w:id",
  sdName: "id",
  encode: encode$3,
  decode: decode$3
});
const encode$2 = (attributes) => {
  const val = attributes?.["w:customMarkFollows"];
  return val === "1" || val === "true" || val === true ? true : void 0;
};
const decode$2 = (attrs) => {
  return attrs?.customMarkFollows ? "1" : void 0;
};
const attrConfig = Object.freeze({
  xmlName: "w:customMarkFollows",
  sdName: "customMarkFollows",
  encode: encode$2,
  decode: decode$2
});
const XML_NODE_NAME$1 = "w:footnoteReference";
const SD_NODE_NAME$1 = "footnoteReference";
const encode$1 = (_2, encodedAttrs) => {
  const translated = { type: SD_NODE_NAME$1 };
  if (encodedAttrs && Object.keys(encodedAttrs).length > 0) {
    translated.attrs = { ...encodedAttrs };
  }
  return translated;
};
const decode$1 = (_params, decodedAttrs) => {
  const ref2 = { name: XML_NODE_NAME$1, elements: [] };
  if (decodedAttrs && Object.keys(decodedAttrs).length > 0) {
    ref2.attributes = { ...decodedAttrs };
  }
  return ref2;
};
const config$1 = {
  xmlName: XML_NODE_NAME$1,
  sdNodeOrKeyName: SD_NODE_NAME$1,
  type: NodeTranslator.translatorTypes.NODE,
  encode: encode$1,
  decode: decode$1,
  attributes: [attrConfig$1, attrConfig]
};
const translator$k = NodeTranslator.from(config$1);
const translator$j = NodeTranslator.from({
  xmlName: "w:docDefaults",
  sdNodeOrKeyName: "docDefaults",
  type: NodeTranslator.translatorTypes.NODE,
  attributes: [],
  encode: (params) => {
    const { nodes } = params;
    const node = nodes[0];
    const result = {};
    [
      {
        wrapperName: "w:rPrDefault",
        propertyName: "runProperties",
        translator: translator$2w
      },
      {
        wrapperName: "w:pPrDefault",
        propertyName: "paragraphProperties",
        translator: translator$1O
      }
    ].forEach(({ wrapperName, propertyName, translator: translator2 }) => {
      const defaultElement = node.elements?.find((el) => el.name === wrapperName);
      const propertyElement = defaultElement?.elements?.find((el) => el.name === wrapperName.replace("Default", ""));
      if (propertyElement) {
        const props = translator2.encode({ ...params, nodes: [propertyElement] });
        if (props) {
          result[propertyName] = props;
        }
      }
    });
    return Object.keys(result).length > 0 ? result : void 0;
  },
  decode: function(params) {
    const currentValue = params.node.attrs?.["docDefaults"];
    if (!currentValue) {
      return void 0;
    }
    const elements = [];
    [
      {
        wrapperName: "w:rPrDefault",
        propertyName: "runProperties",
        translator: translator$2w
      },
      {
        wrapperName: "w:pPrDefault",
        propertyName: "paragraphProperties",
        translator: translator$1O
      }
    ].forEach(({ wrapperName, propertyName, translator: translator2 }) => {
      const propertyValue = currentValue[propertyName];
      if (propertyValue) {
        const decodedProperty = translator2.decode({ ...params, node: { attrs: { [propertyName]: propertyValue } } });
        if (decodedProperty) {
          elements.push({
            name: wrapperName,
            type: "element",
            elements: [decodedProperty]
          });
        }
      }
    });
    if (elements.length === 0) {
      return void 0;
    }
    const newNode = {
      name: "w:docDefaults",
      type: "element",
      attributes: {},
      elements
    };
    return newNode;
  }
});
const translator$i = NodeTranslator.from({
  xmlName: "w:lsdException",
  sdNodeOrKeyName: "lsdException",
  type: NodeTranslator.translatorTypes.NODE,
  attributes: [
    createAttributeHandler("w:name"),
    createBooleanAttributeHandler("w:locked"),
    createBooleanAttributeHandler("w:qFormat"),
    createBooleanAttributeHandler("w:semiHidden"),
    createBooleanAttributeHandler("w:unhideWhenUsed"),
    createIntegerAttributeHandler("w:uiPriority")
  ],
  encode: (_2, encodedAttrs) => {
    return encodedAttrs;
  },
  decode: function({ node }) {
    const decodedAttrs = this.decodeAttributes({ node: { ...node, attrs: node.attrs["lsdException"] || {} } });
    return Object.keys(decodedAttrs).length > 0 ? { name: "w:lsdException", attributes: decodedAttrs } : void 0;
  }
});
const translator$h = NodeTranslator.from({
  xmlName: "w:latentStyles",
  sdNodeOrKeyName: "latentStyles",
  type: NodeTranslator.translatorTypes.NODE,
  attributes: [
    createBooleanAttributeHandler("w:defLockedState"),
    createBooleanAttributeHandler("w:defUIPriority"),
    createBooleanAttributeHandler("w:defSemiHidden"),
    createBooleanAttributeHandler("w:defUnhideWhenUsed"),
    createBooleanAttributeHandler("w:defQFormat")
  ],
  encode: (params, encodedAttrs) => {
    const { nodes } = params;
    const node = nodes[0];
    const lsdExceptions = encodePropertiesByKey(
      "w:lsdException",
      "lsdExceptions",
      translator$i,
      params,
      node,
      "name"
    );
    return { ...lsdExceptions, ...encodedAttrs };
  },
  decode: function(params) {
    const decodedAttrs = this.decodeAttributes({
      node: { ...params.node, attrs: params.node.attrs.latentStyles || {} }
    });
    const currentValue = params.node.attrs?.latentStyles;
    if (!currentValue) {
      return void 0;
    }
    const elements = decodePropertiesByKey(
      "w:lsdException",
      "lsdExceptions",
      translator$i,
      params,
      currentValue
    );
    const newNode = {
      name: "w:latentStyles",
      attributes: decodedAttrs,
      elements
    };
    return newNode;
  }
});
const translator$g = NodeTranslator.from(createSingleBooleanPropertyHandler("w:locked"));
const translator$f = NodeTranslator.from(createSingleAttrPropertyHandler("w:link"));
const translator$e = NodeTranslator.from(createSingleIntegerPropertyHandler("w:lvlRestart"));
const translator$d = NodeTranslator.from(createSingleAttrPropertyHandler("w:next"));
const translator$c = NodeTranslator.from(createSingleIntegerPropertyHandler("w:numIdMacAtCleanup"));
const propertyTranslators$1 = [
  translator$1c,
  translator$1b,
  translator$1a,
  translator$19,
  translator$18,
  translator$17,
  translator$c
];
const propertyTranslatorsByXmlName$1 = {};
const propertyTranslatorsBySdName$1 = {};
propertyTranslators$1.forEach((translator2) => {
  propertyTranslatorsByXmlName$1[translator2.xmlName] = translator2;
  propertyTranslatorsBySdName$1[translator2.sdNodeOrKeyName] = translator2;
});
const translator$b = NodeTranslator.from({
  xmlName: "w:numbering",
  sdNodeOrKeyName: "numbering",
  type: NodeTranslator.translatorTypes.NODE,
  attributes: [],
  encode: (params, encodedAttrs) => {
    const { nodes } = params;
    const node = nodes[0];
    const props = encodeProperties(params, propertyTranslatorsByXmlName$1);
    const result = {
      ...encodedAttrs,
      ...props,
      ...encodePropertiesByKey("w:abstractNum", "abstracts", translator$_, params, node, "abstractNumId"),
      ...encodePropertiesByKey("w:num", "definitions", translator$W, params, node, "numId")
    };
    return result;
  },
  decode: function(params) {
    const currentValue = params.node.attrs?.["abstractNum"];
    if (!currentValue) {
      return void 0;
    }
    const decodedAttrs = this.decodeAttributes({ node: { ...params.node, attrs: currentValue } });
    const props = decodeProperties(params, propertyTranslatorsBySdName$1, currentValue);
    const elements = [
      ...props,
      ...decodePropertiesByKey("w:abstractNum", "abstracts", translator$_, params, currentValue),
      ...decodePropertiesByKey("w:num", "definitions", translator$W, params, currentValue)
    ];
    const newNode = {
      name: "w:numbering",
      type: "element",
      attributes: decodedAttrs,
      elements
    };
    return newNode;
  }
});
const translator$a = NodeTranslator.from(createSingleBooleanPropertyHandler("w:personal"));
const translator$9 = NodeTranslator.from(createSingleBooleanPropertyHandler("w:personalCompose"));
const translator$8 = NodeTranslator.from(createSingleBooleanPropertyHandler("w:personalReply"));
const translator$7 = NodeTranslator.from(createSingleIntegerPropertyHandler("w:rsid"));
const translator$6 = NodeTranslator.from(createSingleBooleanPropertyHandler("w:semiHidden"));
const translator$5 = NodeTranslator.from(createSingleBooleanPropertyHandler("w:unhideWhenUsed"));
const translator$4 = NodeTranslator.from(createSingleBooleanPropertyHandler("w:qFormat"));
const translator$3 = NodeTranslator.from(createSingleIntegerPropertyHandler("w:uiPriority"));
const propertyTranslators = [
  translator$1a,
  translator$m,
  translator$l,
  translator$d,
  translator$f,
  translator$n,
  translator$1k,
  translator$6,
  translator$5,
  translator$4,
  translator$g,
  translator$a,
  translator$9,
  translator$8,
  translator$3,
  translator$7,
  translator$1O,
  translator$2w,
  translator$E,
  translator$1e,
  translator$1q,
  translator$B
];
const attributeHandlers = [
  createAttributeHandler("w:type"),
  createAttributeHandler("w:styleId"),
  createBooleanAttributeHandler("w:default"),
  createBooleanAttributeHandler("w:customStyle")
];
const propertyTranslatorsByXmlName = {};
const propertyTranslatorsBySdName = {};
propertyTranslators.forEach((translator2) => {
  if (!translator2) return;
  propertyTranslatorsByXmlName[translator2.xmlName] = translator2;
  propertyTranslatorsBySdName[translator2.sdNodeOrKeyName] = translator2;
});
const translator$2 = NodeTranslator.from({
  xmlName: "w:style",
  sdNodeOrKeyName: "style",
  type: NodeTranslator.translatorTypes.NODE,
  attributes: attributeHandlers,
  encode: (params, encodedAttrs) => {
    const { nodes } = params;
    const node = nodes[0];
    const result = {
      ...encodedAttrs,
      ...encodeProperties(params, propertyTranslatorsByXmlName),
      ...encodePropertiesByKey(
        translator$B.xmlName,
        "tableStyleProperties",
        translator$B,
        params,
        node,
        "type"
      )
    };
    return result;
  },
  decode: function(params) {
    const currentValue = params.node.attrs?.["style"];
    if (!currentValue) {
      return void 0;
    }
    const decodedAttrs = this.decodeAttributes({ node: { ...params.node, attrs: currentValue } });
    const elements = [
      ...decodeProperties(params, propertyTranslatorsBySdName, currentValue),
      ...decodePropertiesByKey(
        translator$B.xmlName,
        "tableStyleProperties",
        translator$B,
        params,
        currentValue
      )
    ];
    const newNode = {
      name: "w:style",
      type: "element",
      attributes: decodedAttrs,
      elements
    };
    return newNode;
  }
});
const translator$1 = NodeTranslator.from({
  xmlName: "w:styles",
  sdNodeOrKeyName: "styles",
  type: NodeTranslator.translatorTypes.NODE,
  attributes: [],
  encode: (params) => {
    const { nodes } = params;
    const node = nodes[0];
    const props = encodeProperties(params, {
      "w:docDefaults": translator$j,
      "w:latentStyles": translator$h
    });
    const result = {
      ...props,
      ...encodePropertiesByKey("w:style", "styles", translator$2, params, node, "styleId")
    };
    return result;
  },
  decode: function(params) {
    const currentValue = params.node.attrs?.["styles"];
    if (!currentValue) {
      return void 0;
    }
    const props = decodeProperties(
      params,
      {
        docDefaults: translator$j,
        latentStyles: translator$h
      },
      currentValue
    );
    const elements = [...props, ...decodePropertiesByKey("w:style", "styles", translator$2, params, currentValue)];
    const newNode = {
      name: "w:styles",
      type: "element",
      attributes: {},
      elements
    };
    return newNode;
  }
});
const translatorList = Array.from(
  /* @__PURE__ */ new Set([
    translator$2v,
    translator$v,
    translator$u,
    translator$t,
    translator$s,
    translator$r,
    translator$q,
    translator$_,
    translator$Z,
    translator$2u,
    translator$n,
    translator$2t,
    translator$2s,
    translator$m,
    translator$36,
    translator$2a,
    translator$35,
    translator$l,
    translator$34,
    translator$R,
    translator$y,
    translator$z,
    translator$28,
    translator$39,
    translator$1n,
    translator$2W,
    translator$2q,
    translator$2$,
    translator$2p,
    translator$2z,
    translator$p,
    translator$2o,
    translator$j,
    translator$T,
    translator$30,
    translator$2B,
    translator$2H,
    translator$2G,
    translator$2P,
    translator$1H,
    translator$k,
    translator$2C,
    translator$2n,
    translator$1m,
    translator$1l,
    translator$D,
    translator$1J,
    translator$1s,
    translator$1r,
    translator$1k,
    translator$1t,
    translator$38,
    translator$1M,
    translator$33,
    translator$2y,
    translator$2g,
    translator$2m,
    translator$2O,
    translator$2f,
    translator$1F,
    translator$1E,
    translator$15,
    translator$2l,
    translator$2k,
    translator$2j,
    translator$2E,
    translator$2i,
    translator$2U,
    translator$h,
    translator$26,
    translator$i,
    translator$f,
    translator$$,
    translator$X,
    translator$12,
    translator$16,
    translator$e,
    translator$1B,
    translator$13,
    translator$17,
    translator$g,
    translator$2h,
    translator$1a,
    translator$d,
    translator$2N,
    translator$1x,
    translator$W,
    translator$b,
    translator$11,
    translator$2e,
    translator$c,
    translator$2d,
    translator$18,
    translator$1c,
    translator$2L,
    translator$2c,
    translator$2b,
    translator$2M,
    translator$1N,
    translator$1_,
    translator$20,
    translator$a,
    translator$9,
    translator$8,
    translator$2D,
    translator$1O,
    translator$1$,
    translator$x,
    translator$w,
    translator$1L,
    translator$2_,
    translator$2w,
    translator$2Z,
    translator$7,
    translator$2A,
    translator$24,
    translator$S,
    translator$6,
    translator$2K,
    translator$2V,
    translator$2R,
    translator$2Q,
    translator$1Z,
    translator$1Y,
    translator$1X,
    translator$1W,
    translator$14,
    translator$2I,
    translator$1D,
    translator$Y,
    translator$31,
    translator$2,
    translator$19,
    translator$1,
    translator$2Y,
    translator$2X,
    translator$o,
    translator$37,
    translator$1V,
    translator$A,
    translator$1o,
    translator$Q,
    translator$F,
    translator$1j,
    translator$P,
    translator$C,
    translator$1i,
    translator$O,
    translator$N,
    translator$M,
    translator$L,
    translator$E,
    translator$K,
    translator$J,
    translator$I,
    translator$H,
    translator$G,
    translator$1p,
    translator$1y,
    translator$1v,
    translator$1w,
    translator$1q,
    translator$1K,
    translator$1T,
    translator$1A,
    translator$1b,
    translator$1d,
    translator$1z,
    translator$1h,
    translator$1e,
    translator$1U,
    translator$1S,
    translator$1R,
    translator$22,
    translator$32,
    translator$3,
    translator$5,
    translator$1u,
    translator$2J,
    translator$2S,
    translator$1I,
    translator$2F,
    translator$1g,
    translator$1f,
    translator$2x,
    translator$1Q,
    translator$1P,
    translator$4,
    translator$V,
    translator$U,
    commentRangeStartTranslator,
    commentRangeEndTranslator
  ])
);
const additionalHandlers = Object.freeze(
  translatorList.reduce((acc, translator2) => {
    if (typeof translator2 === "function") return acc;
    const key = translator2?.xmlName;
    if (!key) return acc;
    acc[key] = translator2;
    return acc;
  }, {})
);
const baseHandlers = {
  ...additionalHandlers
};
const registeredHandlers = Object.freeze(baseHandlers);
const INLINE_PARENT_NAMES = /* @__PURE__ */ new Set([
  "w:r",
  "w:hyperlink",
  "w:smartTag",
  "w:fldSimple",
  "w:proofErr",
  "w:del",
  "w:ins",
  "w:p"
  // Paragraph is an inline container; unknown children must be inline-safe
]);
const INLINE_NODE_NAMES = /* @__PURE__ */ new Set([
  "m:oMathPara",
  "m:oMath",
  "m:t",
  "m:r",
  "m:ctrlPr",
  "m:sSupPr",
  "m:e",
  "m:sup",
  "m:sSup"
]);
const BLOCK_BOUNDARY_NAMES = /* @__PURE__ */ new Set(["w:body", "w:tbl", "w:tc", "w:tr"]);
const isInlineContext = (path = [], currentNodeName) => {
  const immediateName = currentNodeName ?? path[path.length - 1]?.name;
  if (immediateName && INLINE_NODE_NAMES.has(immediateName)) {
    return true;
  }
  if (!Array.isArray(path) || path.length === 0) return false;
  for (let i = path.length - 1; i >= 0; i--) {
    const ancestorName = path[i]?.name;
    if (!ancestorName) continue;
    if (INLINE_NODE_NAMES.has(ancestorName) || INLINE_PARENT_NAMES.has(ancestorName)) {
      return true;
    }
    if (BLOCK_BOUNDARY_NAMES.has(ancestorName)) {
      return false;
    }
  }
  return false;
};
const handlePassthroughNode = (params) => {
  const { nodes = [] } = params;
  const node = nodes[0];
  if (!node) return { nodes: [], consumed: 0 };
  if (registeredHandlers[node.name] || node.name === "w:commentReference") {
    return { nodes: [], consumed: 0 };
  }
  const originalXml = carbonCopy(node) || {};
  const originalElementsSource = originalXml.elements;
  const originalElements = originalElementsSource ? carbonCopy(originalElementsSource) : [];
  const childElements = Array.isArray(node.elements) ? node.elements : [];
  let childContent = [];
  if (childElements.length && params.nodeListHandler?.handler) {
    const childParams = {
      ...params,
      nodes: childElements,
      path: [...params.path || [], node]
    };
    childContent = params.nodeListHandler.handler(childParams) || [];
  }
  if (originalElements?.length) {
    originalXml.elements = originalElements;
  }
  const passthroughNode = {
    type: isInlineContext(params.path, node.name) ? "passthroughInline" : "passthroughBlock",
    attrs: {
      originalName: node.name,
      originalXml
    },
    marks: [],
    content: childContent
  };
  return {
    nodes: [passthroughNode],
    consumed: 1
  };
};
const passthroughNodeHandlerEntity = {
  handlerName: "passthroughNodeHandler",
  handler: handlePassthroughNode
};
const handler = (params) => {
  const { nodes } = params;
  if (nodes.length === 0 || nodes[0].name !== "w:br") {
    return { nodes: [], consumed: 0 };
  }
  const result = translator$39.encode(params);
  if (!result) return { nodes: [], consumed: 0 };
  return {
    nodes: [result],
    consumed: 1
  };
};
const lineBreakNodeHandlerEntity = {
  handlerName: "lineBreakNodeHandler",
  handler
};
const handleBookmarkNode = (params) => {
  const { nodes, nodeListHandler, editor } = params;
  if (nodes.length === 0 || nodes[0].name !== "w:bookmarkStart") {
    return { nodes: [], consumed: 0 };
  }
  const node = nodes[0];
  const customMarks = editor?.extensionService?.extensions?.filter((e) => e.isExternal === true) || [];
  const bookmarkName = node.attributes["w:name"]?.split(";")[0];
  const customMark = customMarks.find((mark) => mark.name === bookmarkName);
  if (customMark) {
    const bookmarkEndIndex = nodes.findIndex(
      (n) => n.name === "w:bookmarkEnd" && n.attributes["w:id"] === node.attributes["w:id"]
    );
    const textNodes = nodes.slice(1, bookmarkEndIndex);
    const attrs = {};
    node.attributes["w:name"].split(";").forEach((name) => {
      const [key, value] = name.split("=");
      if (key && value) {
        attrs[key] = value;
      }
    });
    const translatedText = nodeListHandler.handler({
      ...params,
      nodes: textNodes,
      path: [...params.path || [], node]
    });
    translatedText.forEach((n) => {
      n.marks.push({
        type: customMark.name,
        attrs
      });
    });
    return {
      nodes: translatedText,
      consumed: translatedText.length + 2
    };
  }
  const encoded = translator$z.encode({ ...params, nodes: [node] });
  if (!encoded) {
    return { nodes: [], consumed: 0 };
  }
  return { nodes: [encoded], consumed: 1 };
};
const handleBookmarkStartNode = (params) => {
  const { nodes } = params;
  if (!nodes.length || nodes[0].name !== "w:bookmarkStart") {
    return { nodes: [], consumed: 0 };
  }
  if (isCustomMarkBookmark(nodes[0], params.editor)) {
    return handleBookmarkNode(params);
  }
  const node = translator$z.encode(params);
  if (!node) return { nodes: [], consumed: 0 };
  return { nodes: [node], consumed: 1 };
};
const isCustomMarkBookmark = (bookmarkStartNode, editor) => {
  if (!bookmarkStartNode?.attributes || !editor?.extensionService?.extensions) {
    return false;
  }
  const rawBookmarkName = bookmarkStartNode.attributes["w:name"];
  if (!rawBookmarkName || typeof rawBookmarkName !== "string") {
    return false;
  }
  const [bookmarkName, ...bookmarkPayloadParts] = rawBookmarkName.split(";");
  if (!bookmarkName) {
    return false;
  }
  const customMarks = editor.extensionService.extensions.filter((extension) => extension.isExternal === true);
  const matchesCustomMarkName = customMarks.some((mark) => mark.name === bookmarkName);
  if (!matchesCustomMarkName) {
    return false;
  }
  return bookmarkPayloadParts.some((part) => part && part.includes("="));
};
const bookmarkStartNodeHandlerEntity = {
  handlerName: "w:bookmarkStartTranslator",
  handler: handleBookmarkStartNode
};
const handleBookmarkEndNode = (params) => {
  const { nodes } = params;
  if (!nodes.length || nodes[0].name !== "w:bookmarkEnd") {
    return { nodes: [], consumed: 0 };
  }
  const node = translator$y.encode(params);
  if (!node) return { nodes: [], consumed: 0 };
  return { nodes: [node], consumed: 1 };
};
const bookmarkEndNodeHandlerEntity = {
  handlerName: "w:bookmarkEndTranslator",
  handler: handleBookmarkEndNode
};
const ALTERNATE_CONTENT_NODE = "mc:AlternateContent";
const skipHandlerResponse = { nodes: [], consumed: 0 };
const isAlternateContentNode = (node) => node?.name === ALTERNATE_CONTENT_NODE;
const resolveAlternateContentElements = (alternateContent) => {
  const { elements } = selectAlternateContentElements(alternateContent);
  if (!elements) return null;
  return elements;
};
const buildNodeWithoutAlternateContent = (node) => {
  const { elements } = node || {};
  if (!elements?.length) return null;
  let replaced = false;
  const updatedElements = [];
  elements.forEach((element) => {
    if (isAlternateContentNode(element)) {
      const resolved = resolveAlternateContentElements(element);
      if (resolved) {
        updatedElements.push(...resolved);
        replaced = true;
        return;
      }
      updatedElements.push(carbonCopy(element));
      return;
    }
    updatedElements.push(carbonCopy(element));
  });
  if (!replaced) return null;
  const clone = carbonCopy(node);
  clone.elements = updatedElements;
  return clone;
};
const handleAlternateChoice = (params) => {
  const { nodes, nodeListHandler } = params;
  if (!nodes?.length) {
    return skipHandlerResponse;
  }
  const [currentNode] = nodes;
  if (isAlternateContentNode(currentNode)) {
    const nodeForTranslator = currentNode?.type ? currentNode : {
      ...currentNode,
      type: "element"
    };
    const translated = translator$2v.encode({
      ...params,
      nodes: [nodeForTranslator],
      extraParams: { ...params.extraParams || {}, node: nodeForTranslator }
    });
    if (!translated) {
      return skipHandlerResponse;
    }
    const nodesArray = Array.isArray(translated) ? translated : [translated];
    return { nodes: nodesArray, consumed: 1 };
  }
  const sanitizedNode = buildNodeWithoutAlternateContent(currentNode);
  if (!sanitizedNode) {
    return skipHandlerResponse;
  }
  const result = nodeListHandler.handler({
    ...params,
    nodes: [sanitizedNode],
    path: [...params.path || [], sanitizedNode]
  });
  return { nodes: result, consumed: 1 };
};
const alternateChoiceHandler = {
  handlerName: "alternateChoiceHandler",
  handler: handleAlternateChoice
};
const autoPageHandlerEntity = generateV2HandlerEntity("autoPageNumberHandler", translator$r);
const autoTotalPageCountEntity = generateV2HandlerEntity("autoTotalPageCountEntity", translator$q);
const pageReferenceEntity = generateV2HandlerEntity("pageReferenceNodeHandler", translator$v);
const INLINE_PICT_RESULT_TYPES = /* @__PURE__ */ new Set(["image", "contentBlock"]);
const buildParagraphAttrsFromPNode = (pNode, params) => {
  const { attributes = {} } = parseProperties(pNode);
  const pPr = pNode?.elements?.find((el) => el.name === "w:pPr");
  const inlineParagraphProperties = pPr ? translator$1O.encode({ ...params, nodes: [pPr] }) || {} : {};
  return {
    ...attributes,
    paragraphProperties: inlineParagraphProperties,
    rsidRDefault: pNode?.attributes?.["w:rsidRDefault"],
    filename: params?.filename
  };
};
const handlePictNode = (params) => {
  const { nodes } = params;
  if (!nodes.length || nodes[0].name !== "w:p") {
    return { nodes: [], consumed: 0 };
  }
  const pNode = nodes[0];
  const runs = pNode.elements?.filter((el) => el.name === "w:r") || [];
  let pict = null;
  for (const run2 of runs) {
    const foundPict = run2.elements?.find((el) => el.name === "w:pict");
    if (foundPict) {
      pict = foundPict;
      break;
    }
  }
  if (!pict) {
    return { nodes: [], consumed: 0 };
  }
  const node = pict;
  const result = translator.encode({ ...params, extraParams: { node, pNode } });
  if (!result) {
    return { nodes: [], consumed: 0 };
  }
  const shouldWrapInParagraph = INLINE_PICT_RESULT_TYPES.has(result.type);
  const wrappedNode = shouldWrapInParagraph ? {
    type: "paragraph",
    content: [result],
    attrs: buildParagraphAttrsFromPNode(pNode, params),
    marks: []
  } : result;
  return {
    nodes: [wrappedNode],
    consumed: 1
  };
};
const pictNodeHandlerEntity = {
  handlerName: "handlePictNode",
  handler: handlePictNode
};
function importCommentData({ docx, editor, converter }) {
  const nodeListHandler = defaultNodeListHandler();
  const comments = docx["word/comments.xml"];
  if (!comments) return;
  const commentThreadingProfile = converter?.commentThreadingProfile || {
    defaultStyle: docx["word/commentsExtended.xml"] ? "commentsExtended" : "range-based",
    mixed: false,
    fileSet: {
      hasCommentsExtended: !!docx["word/commentsExtended.xml"],
      hasCommentsExtensible: !!docx["word/commentsExtensible.xml"],
      hasCommentsIds: !!docx["word/commentsIds.xml"]
    }
  };
  const { elements } = comments;
  if (!elements || !elements.length) return;
  const { elements: allComments = [] } = elements[0];
  const extractedComments = allComments.map((el) => {
    const { attributes } = el;
    const importedId = attributes["w:id"];
    const authorName = attributes["w:author"];
    const authorEmail = attributes["w:email"];
    const initials = attributes["w:initials"];
    const createdDate = attributes["w:date"];
    const internalId = attributes["custom:internalId"];
    const trackedChange = attributes["custom:trackedChange"] === "true";
    const trackedChangeType = attributes["custom:trackedChangeType"];
    const trackedChangeText = attributes["custom:trackedChangeText"] !== "null" ? attributes["custom:trackedChangeText"] : null;
    const trackedDeletedText = attributes["custom:trackedDeletedText"] !== "null" ? attributes["custom:trackedDeletedText"] : null;
    const date = new Date(createdDate);
    const unixTimestampMs = date.getTime();
    const parsedElements = nodeListHandler.handler({
      nodes: el.elements,
      nodeListHandler,
      docx,
      editor,
      converter,
      path: [el]
    });
    const lastElement = parsedElements[parsedElements.length - 1];
    const paraId = lastElement?.attrs?.["w14:paraId"];
    const threadingMethod = commentThreadingProfile.defaultStyle;
    return {
      commentId: internalId || v4(),
      importedId,
      creatorName: authorName,
      creatorEmail: authorEmail,
      createdTime: unixTimestampMs,
      textJson: parsedElements[0],
      elements: parsedElements,
      initials,
      paraId,
      trackedChange,
      trackedChangeText,
      trackedChangeType,
      trackedDeletedText,
      isDone: false,
      origin: converter?.documentOrigin || "word",
      threadingMethod,
      threadingStyleOverride: void 0,
      originalXmlStructure: {
        ...commentThreadingProfile.fileSet
      }
    };
  });
  const extendedComments = generateCommentsWithExtendedData({
    docx,
    comments: extractedComments,
    converter,
    threadingProfile: commentThreadingProfile
  });
  if (converter) {
    const hasOverride = extendedComments.some(
      (comment) => comment.threadingStyleOverride && comment.threadingStyleOverride !== commentThreadingProfile.defaultStyle
    );
    converter.commentThreadingProfile = {
      ...commentThreadingProfile,
      mixed: hasOverride || commentThreadingProfile.mixed
    };
  }
  return extendedComments;
}
const generateCommentsWithExtendedData = ({ docx, comments, converter, threadingProfile }) => {
  if (!comments?.length) return [];
  const rangeData = extractCommentRangesFromDocument(docx, converter);
  const { commentsInTrackedChanges } = rangeData;
  const trackedChangeParentMap = detectThreadingFromTrackedChanges(comments, commentsInTrackedChanges);
  const rangeThreadedComments = detectThreadingFromRanges(comments, {
    ...rangeData,
    commentsInTrackedChanges: /* @__PURE__ */ new Map()
  });
  const commentIdSet = new Set(comments.map((comment) => comment.commentId));
  const rangeParentMap = /* @__PURE__ */ new Map();
  rangeThreadedComments.forEach((comment) => {
    if (comment.parentCommentId && commentIdSet.has(comment.parentCommentId)) {
      rangeParentMap.set(comment.commentId, comment.parentCommentId);
    }
  });
  const commentsExtended = docx["word/commentsExtended.xml"];
  if (!commentsExtended) {
    const commentsWithThreading = detectThreadingFromRanges(comments, rangeData);
    return commentsWithThreading.map((comment) => ({
      ...comment,
      isDone: comment.isDone ?? false
    }));
  }
  const { elements: initialElements = [] } = commentsExtended;
  if (!initialElements?.length) return comments.map((comment) => ({ ...comment, isDone: comment.isDone ?? false }));
  const { elements = [] } = initialElements[0] ?? {};
  const commentEx = elements.filter((el) => el.name === "w15:commentEx");
  return comments.map((comment) => {
    const extendedDef = commentEx.find((ce2) => {
      return comment.elements?.some((el) => el.attrs?.["w14:paraId"] === ce2.attributes["w15:paraId"]);
    });
    let isDone = comment.isDone ?? false;
    let parentCommentId = void 0;
    let threadingParentCommentId = void 0;
    let threadingStyleOverride = void 0;
    const trackedChangeParent = trackedChangeParentMap.get(comment.importedId);
    const isInsideTrackedChange = trackedChangeParent?.isTrackedChangeParent;
    const hasExtendedEntry = !!extendedDef;
    if (extendedDef) {
      const details = getExtendedDetails(extendedDef);
      isDone = details.isDone ?? false;
      if (details.paraIdParent) {
        const parentComment = comments.find(
          (c) => c.paraId === details.paraIdParent || c.elements?.some((el) => el.attrs?.["w14:paraId"] === details.paraIdParent)
        );
        const rangeParent = rangeParentMap.get(comment.commentId);
        if (parentComment?.trackedChange) {
          if (rangeParent) {
            threadingParentCommentId = rangeParent;
            parentCommentId = threadingParentCommentId;
          }
        } else {
          threadingParentCommentId = parentComment?.commentId;
          parentCommentId = threadingParentCommentId;
        }
      }
    }
    const trackedChangeParentId = isInsideTrackedChange ? trackedChangeParent.trackedChangeId : void 0;
    if (!parentCommentId && !hasExtendedEntry && rangeParentMap.has(comment.commentId)) {
      parentCommentId = rangeParentMap.get(comment.commentId);
      if (threadingProfile?.defaultStyle === "commentsExtended") {
        threadingStyleOverride = "range-based";
      }
    }
    return {
      ...comment,
      isDone,
      parentCommentId,
      threadingStyleOverride,
      threadingParentCommentId,
      trackedChangeParentId
    };
  });
};
const getExtendedDetails = (commentEx) => {
  const { attributes } = commentEx;
  const paraId = attributes["w15:paraId"];
  const isDone = attributes["w15:done"] === "1" ? true : false;
  const paraIdParent = attributes["w15:paraIdParent"];
  return { paraId, isDone, paraIdParent };
};
const extractCommentRangesFromDocument = (docx, converter) => {
  const documentXml = docx["word/document.xml"];
  if (!documentXml) {
    return { rangeEvents: [], rangePositions: /* @__PURE__ */ new Map(), commentsInTrackedChanges: /* @__PURE__ */ new Map() };
  }
  const rangeEvents = [];
  const rangePositions = /* @__PURE__ */ new Map();
  const commentsInTrackedChanges = /* @__PURE__ */ new Map();
  let positionIndex = 0;
  let lastElementWasCommentMarker = false;
  const recentlyClosedComments = /* @__PURE__ */ new Set();
  let lastTrackedChange = null;
  const walkElements = (elements, currentTrackedChangeId = null) => {
    if (!elements || !Array.isArray(elements)) return;
    elements.forEach((element) => {
      const isCommentStart = element.name === "w:commentRangeStart";
      const isCommentEnd = element.name === "w:commentRangeEnd";
      const isTrackedChange = element.name === "w:ins" || element.name === "w:del";
      if (isCommentStart) {
        const commentId = element.attributes?.["w:id"];
        if (commentId !== void 0) {
          const id = String(commentId);
          rangeEvents.push({
            type: "start",
            commentId: id
          });
          if (!rangePositions.has(id)) {
            rangePositions.set(id, { startIndex: positionIndex, endIndex: -1 });
          } else {
            rangePositions.get(id).startIndex = positionIndex;
          }
          if (currentTrackedChangeId !== null) {
            commentsInTrackedChanges.set(id, currentTrackedChangeId);
          }
        }
        lastElementWasCommentMarker = true;
        recentlyClosedComments.clear();
      } else if (isCommentEnd) {
        const commentId = element.attributes?.["w:id"];
        if (commentId !== void 0) {
          const id = String(commentId);
          rangeEvents.push({
            type: "end",
            commentId: id
          });
          if (!rangePositions.has(id)) {
            rangePositions.set(id, { startIndex: -1, endIndex: positionIndex });
          } else {
            rangePositions.get(id).endIndex = positionIndex;
          }
          recentlyClosedComments.add(id);
        }
        lastElementWasCommentMarker = true;
      } else if (isTrackedChange) {
        const trackedChangeId = element.attributes?.["w:id"];
        const author = element.attributes?.["w:author"];
        const date = element.attributes?.["w:date"];
        const elementType = element.name;
        let mappedId = trackedChangeId;
        let isReplacement = false;
        if (trackedChangeId !== void 0 && converter) {
          if (!converter.trackedChangeIdMap) {
            converter.trackedChangeIdMap = /* @__PURE__ */ new Map();
          }
          if (lastTrackedChange && lastTrackedChange.type !== elementType && lastTrackedChange.author === author && lastTrackedChange.date === date) {
            mappedId = lastTrackedChange.mappedId;
            converter.trackedChangeIdMap.set(String(trackedChangeId), mappedId);
            isReplacement = true;
          } else {
            if (!converter.trackedChangeIdMap.has(String(trackedChangeId))) {
              converter.trackedChangeIdMap.set(String(trackedChangeId), v4());
            }
            mappedId = converter.trackedChangeIdMap.get(String(trackedChangeId));
          }
        }
        if (currentTrackedChangeId === null) {
          if (isReplacement) {
            lastTrackedChange = null;
          } else {
            lastTrackedChange = {
              type: elementType,
              author,
              date,
              mappedId,
              wordId: String(trackedChangeId)
            };
          }
        }
        if (mappedId && recentlyClosedComments.size > 0) {
          recentlyClosedComments.forEach((commentId) => {
            if (!commentsInTrackedChanges.has(commentId)) {
              commentsInTrackedChanges.set(commentId, String(mappedId));
            }
          });
        }
        recentlyClosedComments.clear();
        if (element.elements && Array.isArray(element.elements)) {
          walkElements(element.elements, mappedId !== void 0 ? String(mappedId) : currentTrackedChangeId);
        }
      } else {
        if (lastElementWasCommentMarker) {
          positionIndex++;
          lastElementWasCommentMarker = false;
        }
        if (element.name === "w:p") {
          recentlyClosedComments.clear();
          lastTrackedChange = null;
        }
        if (element.elements && Array.isArray(element.elements)) {
          walkElements(element.elements, currentTrackedChangeId);
        }
      }
    });
  };
  if (documentXml.elements && documentXml.elements.length > 0) {
    const body = documentXml.elements[0];
    if (body.elements) {
      walkElements(body.elements);
    }
  }
  return { rangeEvents, rangePositions, commentsInTrackedChanges };
};
const detectThreadingFromNestedRanges = (comments, rangeEvents, skipComments = /* @__PURE__ */ new Set()) => {
  const openRanges = [];
  const parentMap = /* @__PURE__ */ new Map();
  rangeEvents.forEach((event) => {
    if (event.type === "start") {
      if (!skipComments.has(event.commentId) && openRanges.length > 0) {
        for (let i = openRanges.length - 1; i >= 0; i--) {
          if (!skipComments.has(openRanges[i])) {
            parentMap.set(event.commentId, openRanges[i]);
            break;
          }
        }
      }
      openRanges.push(event.commentId);
    } else if (event.type === "end") {
      const index2 = openRanges.lastIndexOf(event.commentId);
      if (index2 !== -1) {
        openRanges.splice(index2, 1);
      }
    }
  });
  return parentMap;
};
const detectThreadingFromSharedPosition = (comments, rangePositions) => {
  const parentMap = /* @__PURE__ */ new Map();
  const commentsByStartPosition = /* @__PURE__ */ new Map();
  comments.forEach((comment) => {
    const position = rangePositions.get(comment.importedId);
    if (position && position.startIndex >= 0) {
      const startKey = position.startIndex;
      if (!commentsByStartPosition.has(startKey)) {
        commentsByStartPosition.set(startKey, []);
      }
      commentsByStartPosition.get(startKey).push(comment);
    }
  });
  commentsByStartPosition.forEach((commentsAtPosition) => {
    if (commentsAtPosition.length <= 1) return;
    const sorted = [...commentsAtPosition].sort((a, b2) => a.createdTime - b2.createdTime);
    const parentComment = sorted[0];
    for (let i = 1; i < sorted.length; i++) {
      parentMap.set(sorted[i].importedId, parentComment.importedId);
    }
  });
  return parentMap;
};
const detectThreadingFromMissingRanges = (comments, rangePositions) => {
  const parentMap = /* @__PURE__ */ new Map();
  const commentsWithRanges = [];
  const commentsWithoutRanges = [];
  comments.forEach((comment) => {
    const position = rangePositions.get(comment.importedId);
    if (position && position.startIndex >= 0) {
      commentsWithRanges.push(comment);
    } else {
      commentsWithoutRanges.push(comment);
    }
  });
  commentsWithoutRanges.forEach((comment) => {
    const potentialParents = commentsWithRanges.filter((c) => c.createdTime < comment.createdTime).sort((a, b2) => b2.createdTime - a.createdTime);
    if (potentialParents.length > 0) {
      parentMap.set(comment.importedId, potentialParents[0].importedId);
    }
  });
  return parentMap;
};
const detectThreadingFromTrackedChanges = (comments, commentsInTrackedChanges) => {
  const parentMap = /* @__PURE__ */ new Map();
  if (!commentsInTrackedChanges || commentsInTrackedChanges.size === 0) {
    return parentMap;
  }
  comments.forEach((comment) => {
    const trackedChangeId = commentsInTrackedChanges.get(comment.importedId);
    if (trackedChangeId !== void 0) {
      parentMap.set(comment.importedId, { trackedChangeId, isTrackedChangeParent: true });
    }
  });
  return parentMap;
};
const detectThreadingFromRanges = (comments, rangeData) => {
  const { rangeEvents, rangePositions, commentsInTrackedChanges } = Array.isArray(rangeData) ? { rangeEvents: rangeData, rangePositions: /* @__PURE__ */ new Map(), commentsInTrackedChanges: /* @__PURE__ */ new Map() } : rangeData;
  if (!rangeEvents || rangeEvents.length === 0) {
    if (comments.length > 1) {
      const parentMap = detectThreadingFromMissingRanges(comments, rangePositions);
      return applyParentRelationships(comments, parentMap);
    }
    return comments;
  }
  const commentsWithSharedPosition = findCommentsWithSharedStartPosition(comments, rangePositions);
  const nestedParentMap = detectThreadingFromNestedRanges(comments, rangeEvents, commentsWithSharedPosition);
  const sharedPositionParentMap = detectThreadingFromSharedPosition(comments, rangePositions);
  const missingRangeParentMap = detectThreadingFromMissingRanges(comments, rangePositions);
  const trackedChangeParentMap = detectThreadingFromTrackedChanges(comments, commentsInTrackedChanges);
  const mergedParentMap = new Map([...missingRangeParentMap, ...nestedParentMap, ...sharedPositionParentMap]);
  return applyParentRelationships(comments, mergedParentMap, trackedChangeParentMap);
};
const findCommentsWithSharedStartPosition = (comments, rangePositions) => {
  const sharedPositionComments = /* @__PURE__ */ new Set();
  const commentsByStartPosition = /* @__PURE__ */ new Map();
  comments.forEach((comment) => {
    const position = rangePositions.get(comment.importedId);
    if (position && position.startIndex >= 0) {
      const startKey = position.startIndex;
      if (!commentsByStartPosition.has(startKey)) {
        commentsByStartPosition.set(startKey, []);
      }
      commentsByStartPosition.get(startKey).push(comment.importedId);
    }
  });
  commentsByStartPosition.forEach((commentIds) => {
    if (commentIds.length > 1) {
      commentIds.forEach((id) => sharedPositionComments.add(id));
    }
  });
  return sharedPositionComments;
};
const applyParentRelationships = (comments, parentMap, trackedChangeParentMap = /* @__PURE__ */ new Map()) => {
  return comments.map((comment) => {
    const trackedChangeParent = trackedChangeParentMap.get(comment.importedId);
    const updatedComment = trackedChangeParent && trackedChangeParent.isTrackedChangeParent ? {
      ...comment,
      trackedChangeParentId: trackedChangeParent.trackedChangeId
    } : comment;
    const parentImportedId = parentMap.get(comment.importedId);
    if (parentImportedId) {
      const parentComment = comments.find((c) => c.importedId === parentImportedId);
      if (parentComment) {
        return {
          ...updatedComment,
          parentCommentId: parentComment.commentId
        };
      }
    }
    return updatedComment;
  });
};
const stripFootnoteMarkerNodes = (nodes) => {
  if (!Array.isArray(nodes) || nodes.length === 0) return nodes;
  const walk = (list) => {
    if (!Array.isArray(list) || list.length === 0) return;
    for (let i = list.length - 1; i >= 0; i--) {
      const node = list[i];
      if (!node) continue;
      if (node.type === "passthroughInline" && node.attrs?.originalName === "w:footnoteRef") {
        list.splice(i, 1);
        continue;
      }
      if (Array.isArray(node.content)) {
        walk(node.content);
      }
    }
  };
  const copy2 = JSON.parse(JSON.stringify(nodes));
  walk(copy2);
  return copy2;
};
function importFootnoteData({ docx, editor, converter, nodeListHandler, numbering } = {}) {
  const handler2 = nodeListHandler || defaultNodeListHandler();
  const footnotes = docx?.["word/footnotes.xml"];
  if (!footnotes?.elements?.length) return [];
  const root = footnotes.elements[0];
  const elements = Array.isArray(root?.elements) ? root.elements : [];
  const footnoteElements = elements.filter((el) => el?.name === "w:footnote");
  if (footnoteElements.length === 0) return [];
  const results = [];
  const lists = {};
  const inlineDocumentFonts = [];
  footnoteElements.forEach((el) => {
    const idRaw = el?.attributes?.["w:id"];
    if (idRaw === void 0 || idRaw === null) return;
    const id = String(idRaw);
    const idNumber = Number(id);
    const originalXml = carbonCopy(el);
    const type2 = el?.attributes?.["w:type"] || null;
    if (type2 === "separator" || type2 === "continuationSeparator") {
      results.push({
        id,
        type: type2,
        originalXml,
        content: []
      });
      return;
    }
    if (!Number.isFinite(idNumber) || idNumber < 0) return;
    const childElements = Array.isArray(el.elements) ? el.elements : [];
    const converted = handler2.handler({
      nodes: childElements,
      nodeListHandler: handler2,
      docx,
      editor,
      converter,
      numbering,
      lists,
      inlineDocumentFonts,
      filename: "footnotes.xml",
      path: [el]
    });
    const stripped = stripFootnoteMarkerNodes(converted);
    results.push({
      id,
      type: type2,
      originalXml,
      content: stripped
    });
  });
  return results;
}
const RELATIONSHIP_TYPES = (
  /** @type {const} */
  {
    image: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
    hyperlink: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink"
  }
);
const getDocumentRelationshipElements = (editor) => {
  const docx = editor.converter?.convertedXml;
  if (!docx) return [];
  const documentRels = docx["word/_rels/document.xml.rels"];
  const elements = documentRels?.elements;
  if (!Array.isArray(elements)) return [];
  const relationshipTag = elements.find((el) => el.name === "Relationships");
  return relationshipTag?.elements || [];
};
const getMaxRelationshipIdInt = (relationships) => {
  const ids = [];
  relationships.forEach((rel) => {
    const splitId = rel.attributes.Id.split("rId");
    const parsedInt = parseInt(splitId[1], 10);
    if (Number.isInteger(parsedInt)) {
      ids.push(parsedInt);
    }
  });
  if (ids.length === 0) return 0;
  return Math.max(...ids);
};
const findRelationshipIdFromTarget = (target, editor) => {
  if (!target) return null;
  if (target.startsWith("word/")) target = target.replace("word/", "");
  const relationships = getDocumentRelationshipElements(editor);
  const existingLinkRel = relationships?.find((rel) => rel.attributes.Target === target);
  if (existingLinkRel) {
    return existingLinkRel.attributes.Id;
  }
};
const insertNewRelationship = (target, type2, editor) => {
  if (!target || typeof target !== "string") {
    throw new Error("Target must be a non-empty string");
  }
  if (!type2 || typeof type2 !== "string") {
    throw new Error("Type must be a non-empty string");
  }
  if (!editor) {
    throw new Error("Editor instance is required");
  }
  const mappedType = RELATIONSHIP_TYPES[type2];
  if (!mappedType) {
    console.warn(
      `Unsupported relationship type: ${type2}. Available types: ${Object.keys(RELATIONSHIP_TYPES).join(", ")}`
    );
    return null;
  }
  const existingRelId = findRelationshipIdFromTarget(target, editor);
  if (existingRelId) {
    console.info(`Reusing existing relationship for target: ${target} (ID: ${existingRelId})`);
    return existingRelId;
  }
  const docx = editor.converter?.convertedXml;
  if (!docx) {
    console.error("No converted XML found in editor");
    return null;
  }
  const documentRels = docx["word/_rels/document.xml.rels"];
  if (!documentRels) {
    console.error("No document relationships found in the docx");
    return null;
  }
  const relationshipsTag = documentRels.elements?.find((el) => el.name === "Relationships");
  if (!relationshipsTag) {
    console.error("No Relationships tag found in document relationships");
    return null;
  }
  if (!relationshipsTag.elements) {
    relationshipsTag.elements = [];
  }
  const newId = getNewRelationshipId(editor);
  if (!newId) {
    console.error("Failed to generate new relationship ID");
    return null;
  }
  const newRel = {
    type: "element",
    name: "Relationship",
    attributes: {
      Id: newId,
      Type: mappedType,
      Target: target
    }
  };
  if (type2 === "hyperlink") {
    newRel.attributes.TargetMode = "External";
  }
  relationshipsTag.elements.push(newRel);
  return newId;
};
const getNewRelationshipId = (editor) => {
  const relationships = getDocumentRelationshipElements(editor);
  const maxIdInt = getMaxRelationshipIdInt(relationships);
  return `rId${maxIdInt + 1}`;
};
const DocxHelpers = {
  findRelationshipIdFromTarget,
  insertNewRelationship,
  getNewRelationshipId
};
const kebabCase = (str) => str.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);
const comments_module_events = {
  ADD: "add",
  UPDATE: "update",
  SELECTED: "selected"
};
function hasV8CaptureStackTrace(error) {
  return typeof error.captureStackTrace === "function";
}
class FileObjectError extends Error {
  constructor(message, cause) {
    super(message);
    this.cause = cause;
    this.name = "FileObjectError";
    if (hasV8CaptureStackTrace(Error)) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
}
class InvalidDataUriError extends FileObjectError {
  constructor(uri2) {
    super(`Invalid data URI format: URI must contain exactly one comma separator`);
    this.uri = uri2;
    this.name = "InvalidDataUriError";
  }
}
class FetchFailedError extends FileObjectError {
  constructor(url, cause) {
    super(`Failed to fetch file from URL: ${url}`, cause);
    this.url = url;
    this.name = "FetchFailedError";
  }
}
const getFileObject = async (fileUrl, name, type2) => {
  try {
    if (fileUrl.startsWith("data:") && fileUrl.includes(";base64,")) {
      const parts = fileUrl.split(",");
      if (parts.length !== 2) {
        throw new InvalidDataUriError(fileUrl);
      }
      const binary = atob(parts[1]);
      const bytes = Uint8Array.from(binary, (c) => c.charCodeAt(0));
      return new File([bytes], name, { type: type2 });
    }
    const response = await fetch(fileUrl);
    if (!response.ok) {
      throw new FetchFailedError(fileUrl, new Error(`HTTP ${response.status}: ${response.statusText}`));
    }
    const blob = await response.blob();
    return new File([blob], name, { type: type2 });
  } catch (error) {
    if (error instanceof FileObjectError) {
      throw error;
    }
    throw new FileObjectError("Failed to create file object", error);
  }
};
const vClickOutside = {
  mounted(el, binding) {
    const clickOutsideHandler = (event) => {
      if (!el.contains(event.target)) {
        binding.value?.(event);
      }
    };
    document.addEventListener("click", clickOutsideHandler);
    el.__clickOutsideHandler = clickOutsideHandler;
  },
  unmounted(el) {
    if (el.__clickOutsideHandler) {
      document.removeEventListener("click", el.__clickOutsideHandler);
      delete el.__clickOutsideHandler;
    }
  }
};
const getDefaultStyleDefinition = (defaultStyleId, docx) => {
  const result = { lineSpaceBefore: null, lineSpaceAfter: null };
  if (!defaultStyleId) return result;
  const styles = docx["word/styles.xml"];
  if (!styles) return result;
  const { elements } = styles.elements[0];
  const elementsWithId = elements.filter((el) => {
    const { attributes } = el;
    return attributes && attributes["w:styleId"] === defaultStyleId;
  });
  const firstMatch = elementsWithId[0];
  if (!firstMatch) return result;
  const qFormat = elementsWithId.find((el) => {
    const qFormat2 = el.elements.find((innerEl) => innerEl.name === "w:qFormat");
    return qFormat2;
  });
  const name = elementsWithId.find((el) => el.elements.some((inner) => inner.name === "w:name"))?.elements.find((inner) => inner.name === "w:name")?.attributes["w:val"];
  const pPr = firstMatch.elements.find((el) => el.name === "w:pPr");
  const spacing = pPr?.elements?.find((el) => el.name === "w:spacing");
  const justify = pPr?.elements?.find((el) => el.name === "w:jc");
  const indent = pPr?.elements?.find((el) => el.name === "w:ind");
  const tabs = pPr?.elements?.find((el) => el.name === "w:tabs");
  let lineSpaceBefore, lineSpaceAfter, line;
  if (spacing?.attributes) {
    lineSpaceBefore = twipsToPixels(spacing.attributes["w:before"]);
    lineSpaceAfter = twipsToPixels(spacing.attributes["w:after"]);
    line = twipsToLines(spacing.attributes["w:line"]);
  }
  let textAlign, leftIndent, rightIndent, firstLine;
  if (indent?.attributes) {
    textAlign = justify?.attributes?.["w:val"];
    leftIndent = twipsToPixels(indent.attributes["w:left"]);
    rightIndent = twipsToPixels(indent.attributes["w:right"]);
    firstLine = twipsToPixels(indent.attributes["w:firstLine"]);
  }
  let tabStops = [];
  if (tabs) {
    tabStops = (tabs.elements || []).filter((el) => el.name === "w:tab").map((tab) => {
      let val = tab.attributes["w:val"];
      if (val == "left") {
        val = "start";
      } else if (val == "right") {
        val = "end";
      }
      return {
        val,
        pos: twipsToPixels(tab.attributes["w:pos"]),
        leader: tab.attributes["w:leader"]
      };
    });
  }
  const keepNext = pPr?.elements?.find((el) => el.name === "w:keepNext");
  const keepLines = pPr?.elements?.find((el) => el.name === "w:keepLines");
  const outlineLevel = pPr?.elements?.find((el) => el.name === "w:outlineLvl");
  const outlineLvlValue = outlineLevel?.attributes["w:val"];
  const pageBreakBefore = pPr?.elements?.find((el) => el.name === "w:pageBreakBefore");
  let pageBreakBeforeVal = 0;
  if (pageBreakBefore) {
    if (!pageBreakBefore.attributes?.["w:val"]) pageBreakBeforeVal = 1;
    else pageBreakBeforeVal = Number(pageBreakBefore?.attributes?.["w:val"]);
  }
  const pageBreakAfter = pPr?.elements?.find((el) => el.name === "w:pageBreakAfter");
  let pageBreakAfterVal;
  if (pageBreakAfter) {
    if (!pageBreakAfter.attributes?.["w:val"]) pageBreakAfterVal = 1;
    else pageBreakAfterVal = Number(pageBreakAfter?.attributes?.["w:val"]);
  }
  const basedOn = elementsWithId.find((el) => el.elements.some((inner) => inner.name === "w:basedOn"))?.elements.find((inner) => inner.name === "w:basedOn")?.attributes["w:val"];
  const parsedAttrs = {
    name,
    qFormat: qFormat ? true : false,
    keepNext: keepNext ? true : false,
    keepLines: keepLines ? true : false,
    outlineLevel: outlineLevel ? parseInt(outlineLvlValue) : null,
    pageBreakBefore: pageBreakBeforeVal ? true : false,
    pageBreakAfter: pageBreakAfterVal ? true : false,
    basedOn: basedOn ?? null
  };
  const rPr = firstMatch.elements.find((el) => el.name === "w:rPr");
  const parsedMarks = parseMarks(rPr, [], docx) || [];
  const parsedStyles = {
    spacing: { lineSpaceAfter, lineSpaceBefore, line },
    textAlign,
    indent: { leftIndent, rightIndent, firstLine },
    tabStops: tabStops.length > 0 ? tabStops : null
  };
  parsedMarks.forEach((mark) => {
    const { type: type2, attrs } = mark;
    if (type2 === "textStyle") {
      Object.entries(attrs).forEach(([key, value]) => {
        parsedStyles[kebabCase(key)] = value;
      });
      return;
    }
    parsedStyles[type2] = attrs;
  });
  return {
    attrs: parsedAttrs,
    styles: parsedStyles
  };
};
const IGNORED_NODE_NAMES = ["w:proofErr", "w:lastRenderedPageBreak"];
const pruneIgnoredNodes = (nodes = []) => nodes.filter((node) => !IGNORED_NODE_NAMES.includes(node.name)).map((node) => node.elements ? { ...node, elements: pruneIgnoredNodes(node.elements) } : node);
const handleTabNode = (params) => {
  const { nodes } = params;
  if (!nodes.length || nodes[0].name !== "w:tab") {
    return { nodes: [], consumed: 0 };
  }
  const node = translator$37.encode(params);
  return { nodes: [node], consumed: 1 };
};
const tabNodeEntityHandler = {
  handlerName: "w:tabTranslator",
  handler: handleTabNode
};
const footnoteReferenceHandlerEntity = generateV2HandlerEntity("footnoteReferenceHandler", translator$k);
const tableNodeHandlerEntity = generateV2HandlerEntity("tableNodeHandler", translator$A);
const tableOfContentsHandlerEntity = generateV2HandlerEntity("tableOfContentsHandler", translator$u);
const indexHandlerEntity = generateV2HandlerEntity("indexHandler", translator$t);
const indexEntryHandlerEntity = generateV2HandlerEntity("indexEntryHandler", translator$s);
const commentRangeStartHandlerEntity = generateV2HandlerEntity(
  "commentRangeStartHandler",
  commentRangeStartTranslator
);
const commentRangeEndHandlerEntity = generateV2HandlerEntity(
  "commentRangeEndHandler",
  commentRangeEndTranslator
);
const permStartHandlerEntity = generateV2HandlerEntity("permStartHandler", translator$x);
const permEndHandlerEntity = generateV2HandlerEntity("permEndHandler", translator$w);
const detectDocumentOrigin = (docx) => {
  const commentsExtended = docx["word/commentsExtended.xml"];
  if (commentsExtended) {
    const { elements: initialElements = [] } = commentsExtended;
    if (initialElements?.length > 0) {
      const { elements = [] } = initialElements[0] ?? {};
      const commentEx = elements.filter((el) => el.name === "w15:commentEx");
      if (commentEx.length > 0) {
        return "word";
      }
    }
  }
  const comments = docx["word/comments.xml"];
  if (comments && !commentsExtended) {
    return "google-docs";
  }
  return "unknown";
};
const detectCommentThreadingProfile = (docx) => {
  const hasCommentsExtended = !!docx["word/commentsExtended.xml"];
  const hasCommentsExtensible = !!docx["word/commentsExtensible.xml"];
  const hasCommentsIds = !!docx["word/commentsIds.xml"];
  return {
    defaultStyle: hasCommentsExtended ? "commentsExtended" : "range-based",
    mixed: false,
    fileSet: {
      hasCommentsExtended,
      hasCommentsExtensible,
      hasCommentsIds
    }
  };
};
const createDocumentJson = (docx, converter, editor) => {
  const json = carbonCopy(getInitialJSON(docx));
  if (!json) return null;
  if (converter) {
    importFootnotePropertiesFromSettings(docx, converter);
    converter.documentOrigin = detectDocumentOrigin(docx);
    converter.commentThreadingProfile = detectCommentThreadingProfile(docx);
  }
  const nodeListHandler = defaultNodeListHandler();
  const bodyNode = json.elements[0].elements.find((el) => el.name === "w:body");
  if (bodyNode) {
    ensureSectionProperties(bodyNode);
    const node = bodyNode;
    const { processedNodes } = preProcessNodesForFldChar(node.elements ?? [], docx);
    node.elements = processedNodes;
    const bodySectPr = node.elements?.find((n) => n.name === "w:sectPr");
    const bodySectPrElements = bodySectPr?.elements ?? [];
    if (converter) {
      converter.importedBodyHasHeaderRef = bodySectPrElements.some((el) => el?.name === "w:headerReference");
      converter.importedBodyHasFooterRef = bodySectPrElements.some((el) => el?.name === "w:footerReference");
    }
    const contentElements = node.elements?.filter((n) => n.name !== "w:sectPr") ?? [];
    const content = pruneIgnoredNodes(contentElements);
    const lists = {};
    const inlineDocumentFonts = [];
    const numbering = getNumberingDefinitions(docx);
    const comments = importCommentData({ docx, converter, editor });
    const footnotes = importFootnoteData({ docx, nodeListHandler, converter, editor, numbering });
    const translatedLinkedStyles = translateStyleDefinitions(docx);
    const translatedNumbering = translateNumberingDefinitions(docx);
    let parsedContent = nodeListHandler.handler({
      nodes: content,
      nodeListHandler,
      docx,
      converter,
      numbering,
      translatedNumbering,
      translatedLinkedStyles,
      editor,
      inlineDocumentFonts,
      lists,
      path: []
    });
    parsedContent = filterOutRootInlineNodes(parsedContent);
    collapseWhitespaceNextToInlinePassthrough(parsedContent);
    const result = {
      type: "doc",
      content: parsedContent,
      attrs: {
        attributes: json.elements[0].attributes,
        // Attach body-level sectPr if it exists
        ...bodySectPr ? { bodySectPr } : {}
      }
    };
    return {
      pmDoc: result,
      savedTagsToRestore: node,
      pageStyles: getDocumentStyles(
        node,
        docx,
        converter,
        editor,
        numbering,
        translatedNumbering,
        translatedLinkedStyles
      ),
      comments,
      footnotes,
      inlineDocumentFonts,
      linkedStyles: getStyleDefinitions(docx),
      translatedLinkedStyles,
      numbering: getNumberingDefinitions(docx, converter),
      translatedNumbering,
      themeColors: getThemeColorPalette(docx)
    };
  }
  return null;
};
const defaultNodeListHandler = () => {
  const entities = [
    alternateChoiceHandler,
    runNodeHandlerEntity,
    pictNodeHandlerEntity,
    paragraphNodeHandlerEntity,
    textNodeHandlerEntity,
    lineBreakNodeHandlerEntity,
    sdtNodeHandlerEntity,
    bookmarkStartNodeHandlerEntity,
    bookmarkEndNodeHandlerEntity,
    hyperlinkNodeHandlerEntity,
    commentRangeStartHandlerEntity,
    commentRangeEndHandlerEntity,
    drawingNodeHandlerEntity,
    trackChangeNodeHandlerEntity,
    tableNodeHandlerEntity,
    footnoteReferenceHandlerEntity,
    tabNodeEntityHandler,
    tableOfContentsHandlerEntity,
    indexHandlerEntity,
    indexEntryHandlerEntity,
    autoPageHandlerEntity,
    autoTotalPageCountEntity,
    pageReferenceEntity,
    permStartHandlerEntity,
    permEndHandlerEntity,
    passthroughNodeHandlerEntity
  ];
  const handler2 = createNodeListHandler(entities);
  return {
    handler: handler2,
    handlerEntities: entities
  };
};
const createNodeListHandler = (nodeHandlers) => {
  const getSafeElementContext = (elements, index2, processedNode, path) => {
    if (!elements || index2 < 0 || index2 >= elements.length) {
      return {
        elementIndex: index2,
        error: "index_out_of_bounds",
        arrayLength: elements?.length
      };
    }
    const element = elements[index2];
    return {
      elementName: element?.name,
      attributes: processedNode?.attrs,
      marks: processedNode?.marks,
      elementPath: path,
      type: processedNode?.type,
      content: processedNode?.content
    };
  };
  const nodeListHandlerFn = ({
    nodes: elements,
    docx,
    insideTrackChange,
    converter,
    numbering,
    translatedNumbering,
    translatedLinkedStyles,
    editor,
    filename,
    parentStyleId,
    lists,
    inlineDocumentFonts,
    path = [],
    extraParams = {}
  }) => {
    if (!elements || !elements.length) return [];
    const filteredElements = pruneIgnoredNodes(elements);
    if (!filteredElements.length) return [];
    const processedElements = [];
    try {
      for (let index2 = 0; index2 < filteredElements.length; index2++) {
        try {
          const nodesToHandle = filteredElements.slice(index2);
          if (!nodesToHandle || nodesToHandle.length === 0) {
            continue;
          }
          const { nodes, consumed, unhandled } = nodeHandlers.reduce(
            (res, handler2) => {
              if (res.consumed > 0) return res;
              return handler2.handler({
                nodes: nodesToHandle,
                docx,
                nodeListHandler: { handler: nodeListHandlerFn, handlerEntities: nodeHandlers },
                insideTrackChange,
                converter,
                numbering,
                translatedNumbering,
                translatedLinkedStyles,
                editor,
                filename,
                parentStyleId,
                lists,
                inlineDocumentFonts,
                path,
                extraParams
              });
            },
            { nodes: [], consumed: 0 }
          );
          const context = getSafeElementContext(
            filteredElements,
            index2,
            nodes[0],
            `/word/${filename || "document.xml"}`
          );
          if (unhandled) {
            if (!context.elementName) continue;
            continue;
          } else {
            const hasHighlightMark = nodes[0]?.marks?.find((mark) => mark.type === "highlight");
            if (hasHighlightMark) {
              converter?.docHiglightColors.add(hasHighlightMark.attrs.color.toUpperCase());
            }
          }
          if (consumed > 0) {
            index2 += consumed - 1;
          }
          if (nodes) {
            nodes.forEach((node) => {
              if (node?.type && !["runProperties"].includes(node.type)) {
                if (node.type === "text" && Array.isArray(node.content) && !node.content.length) {
                  return;
                }
                processedElements.push(node);
              }
            });
          }
        } catch (error) {
          console.debug("Import error", error);
          editor?.emit("exception", { error, editor });
        }
      }
      return processedElements;
    } catch (error) {
      console.debug("Error during import", error);
      editor?.emit("exception", { error, editor });
      throw error;
    }
  };
  return nodeListHandlerFn;
};
function parseFootnoteProperties(footnotePrElement, source) {
  if (!footnotePrElement) return null;
  const props = { source };
  const elements = Array.isArray(footnotePrElement.elements) ? footnotePrElement.elements : [];
  elements.forEach((el) => {
    const val = el?.attributes?.["w:val"];
    switch (el.name) {
      case "w:numFmt":
        if (val) props.numFmt = val;
        break;
      case "w:numStart":
        if (val) props.numStart = val;
        break;
      case "w:numRestart":
        if (val) props.numRestart = val;
        break;
      case "w:pos":
        if (val) props.pos = val;
        break;
    }
  });
  props.originalXml = carbonCopy(footnotePrElement);
  return props;
}
function importFootnotePropertiesFromSettings(docx, converter) {
  if (!docx || !converter || converter.footnoteProperties) return;
  const settings = docx["word/settings.xml"];
  const settingsRoot = settings?.elements?.[0];
  const elements = Array.isArray(settingsRoot?.elements) ? settingsRoot.elements : [];
  const footnotePr = elements.find((el) => el?.name === "w:footnotePr");
  if (!footnotePr) return;
  converter.footnoteProperties = parseFootnoteProperties(footnotePr, "settings");
}
function getDocumentStyles(node, docx, converter, editor, numbering, translatedNumbering, translatedLinkedStyles) {
  const sectPr = node.elements?.find((n) => n.name === "w:sectPr");
  const styles = {};
  sectPr?.elements?.forEach((el) => {
    const { name, attributes } = el;
    switch (name) {
      case "w:pgSz":
        styles["pageSize"] = {
          width: twipsToInches(attributes["w:w"]),
          height: twipsToInches(attributes["w:h"])
        };
        break;
      case "w:pgMar":
        styles["pageMargins"] = {
          top: twipsToInches(attributes["w:top"]),
          right: twipsToInches(attributes["w:right"]),
          bottom: twipsToInches(attributes["w:bottom"]),
          left: twipsToInches(attributes["w:left"]),
          header: twipsToInches(attributes["w:header"]),
          footer: twipsToInches(attributes["w:footer"]),
          gutter: twipsToInches(attributes["w:gutter"])
        };
        break;
      case "w:cols":
        styles["columns"] = {
          space: twipsToInches(attributes["w:space"]),
          num: attributes["w:num"],
          equalWidth: attributes["w:equalWidth"]
        };
        break;
      case "w:docGrid":
        styles["docGrid"] = {
          linePitch: twipsToInches(attributes["w:linePitch"]),
          type: attributes["w:type"]
        };
        break;
      case "w:titlePg":
        converter.headerIds.titlePg = true;
        break;
      case "w:footnotePr":
        if (!converter.footnoteProperties) {
          converter.footnoteProperties = parseFootnoteProperties(el, "sectPr");
        }
        break;
    }
  });
  importHeadersFooters(docx, converter, editor, numbering, translatedNumbering, translatedLinkedStyles);
  styles.alternateHeaders = isAlternatingHeadersOddEven(docx);
  return styles;
}
const DEFAULT_SECTION_PROPS = Object.freeze({
  pageSize: Object.freeze({ width: "12240", height: "15840" }),
  pageMargins: Object.freeze({
    top: "1440",
    right: "1440",
    bottom: "1440",
    left: "1440",
    header: "720",
    footer: "720",
    gutter: "0"
  })
});
function ensureSectionProperties(bodyNode) {
  if (!bodyNode.elements) bodyNode.elements = [];
  let sectPr = bodyNode.elements.find((el) => el.name === "w:sectPr");
  if (!sectPr) {
    sectPr = {
      type: "element",
      name: "w:sectPr",
      elements: []
    };
    bodyNode.elements.push(sectPr);
  } else if (!sectPr.elements) {
    sectPr.elements = [];
  }
  const ensureChild = (name, factory) => {
    let child = sectPr.elements.find((el) => el.name === name);
    if (!child) {
      child = factory();
      sectPr.elements.push(child);
    } else if (!child.attributes) {
      child.attributes = {};
    }
    return child;
  };
  const pgSz = ensureChild("w:pgSz", () => ({
    type: "element",
    name: "w:pgSz",
    attributes: {}
  }));
  pgSz.attributes["w:w"] = pgSz.attributes["w:w"] ?? DEFAULT_SECTION_PROPS.pageSize.width;
  pgSz.attributes["w:h"] = pgSz.attributes["w:h"] ?? DEFAULT_SECTION_PROPS.pageSize.height;
  const pgMar = ensureChild("w:pgMar", () => ({
    type: "element",
    name: "w:pgMar",
    attributes: {}
  }));
  Object.entries(DEFAULT_SECTION_PROPS.pageMargins).forEach(([key, value]) => {
    const attrKey = `w:${key}`;
    if (pgMar.attributes[attrKey] == null) pgMar.attributes[attrKey] = value;
  });
  return sectPr;
}
function getStyleDefinitions(docx) {
  const styles = docx["word/styles.xml"];
  if (!styles) return [];
  const elements = styles.elements?.[0]?.elements ?? [];
  const styleDefinitions = elements.filter((el) => el.name === "w:style");
  const latentStyles = elements.find((el) => el.name === "w:latentStyles");
  (latentStyles?.elements ?? []).forEach((el) => {
    const { attributes } = el;
    styleDefinitions.find((style) => style.attributes["w:styleId"] === attributes["w:name"]);
  });
  const allParsedStyles = [];
  styleDefinitions.forEach((style) => {
    const id = style.attributes["w:styleId"];
    const parsedStyle = getDefaultStyleDefinition(id, docx);
    const importedStyle = {
      id: style.attributes["w:styleId"],
      type: style.attributes["w:type"],
      definition: parsedStyle,
      attributes: {}
    };
    allParsedStyles.push(importedStyle);
  });
  return allParsedStyles;
}
function translateStyleDefinitions(docx) {
  const styles = docx["word/styles.xml"];
  if (!styles) return [];
  const stylesElement = styles.elements[0];
  const parsedStyles = translator$1.encode({ nodes: [stylesElement] });
  return parsedStyles;
}
function translateNumberingDefinitions(docx) {
  const numbering = docx["word/numbering.xml"] ?? baseNumbering;
  const numberingElement = numbering.elements[0];
  const parsedNumbering = translator$b.encode({ nodes: [numberingElement] });
  return parsedNumbering;
}
function addDefaultStylesIfMissing(styles) {
  if (!styles) return null;
  const updatedStyles = carbonCopy(styles);
  const { elements } = updatedStyles.elements[0];
  Object.keys(DEFAULT_LINKED_STYLES).forEach((styleId) => {
    const existsOnDoc = elements.some((el) => el.attributes?.["w:styleId"] === styleId);
    if (!existsOnDoc) {
      const missingStyle = DEFAULT_LINKED_STYLES[styleId];
      updatedStyles.elements[0].elements.push(missingStyle);
    }
  });
  return updatedStyles;
}
const importHeadersFooters = (docx, converter, mainEditor, numbering, translatedNumbering, translatedLinkedStyles) => {
  const rels = docx["word/_rels/document.xml.rels"];
  const relationships = rels?.elements.find((el) => el.name === "Relationships");
  const { elements } = relationships || { elements: [] };
  const headerType = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header";
  const footerType = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer";
  const headers = elements.filter((el) => el.attributes["Type"] === headerType);
  const footers = elements.filter((el) => el.attributes["Type"] === footerType);
  const sectPr = findSectPr(docx["word/document.xml"]) || [];
  const allSectPrElements = sectPr.flatMap((el) => el.elements);
  if (!mainEditor) return;
  const editor = { ...mainEditor };
  editor.options.annotations = true;
  headers.forEach((header) => {
    const { rId, referenceFile, currentFileName } = getHeaderFooterSectionData(header, docx);
    const headerNodes = carbonCopy(referenceFile.elements[0].elements ?? []);
    const { processedNodes: headerProcessedNodes } = preProcessPageFieldsOnly(headerNodes);
    const sectPrHeader = allSectPrElements.find(
      (el) => el.name === "w:headerReference" && el.attributes["r:id"] === rId
    );
    let sectionType = sectPrHeader?.attributes["w:type"];
    if (converter.headerIds[sectionType]) sectionType = null;
    const nodeListHandler = defaultNodeListHandler();
    let schema = nodeListHandler.handler({
      nodes: headerProcessedNodes,
      nodeListHandler,
      docx,
      converter,
      numbering,
      translatedNumbering,
      translatedLinkedStyles,
      editor,
      filename: currentFileName,
      path: []
    });
    schema = filterOutRootInlineNodes(schema);
    if (!converter.headerIds.ids) converter.headerIds.ids = [];
    converter.headerIds.ids.push(rId);
    converter.headers[rId] = { type: "doc", content: [...schema] };
    if (sectionType) {
      converter.headerIds[sectionType] = rId;
    }
  });
  const titlePg = allSectPrElements?.find((el) => el.name === "w:titlePg");
  if (titlePg) converter.headerIds.titlePg = true;
  footers.forEach((footer) => {
    const { rId, referenceFile, currentFileName } = getHeaderFooterSectionData(footer, docx);
    const footerNodes = carbonCopy(referenceFile.elements[0].elements ?? []);
    const { processedNodes: footerProcessedNodes } = preProcessPageFieldsOnly(footerNodes);
    const sectPrFooter = allSectPrElements.find(
      (el) => el.name === "w:footerReference" && el.attributes["r:id"] === rId
    );
    const sectionType = sectPrFooter?.attributes["w:type"];
    const nodeListHandler = defaultNodeListHandler();
    let schema = nodeListHandler.handler({
      nodes: footerProcessedNodes,
      nodeListHandler,
      docx,
      converter,
      numbering,
      editor,
      filename: currentFileName,
      path: []
    });
    schema = filterOutRootInlineNodes(schema);
    if (!converter.footerIds.ids) converter.footerIds.ids = [];
    converter.footerIds.ids.push(rId);
    converter.footers[rId] = { type: "doc", content: [...schema] };
    if (sectionType) {
      converter.footerIds[sectionType] = rId;
    }
  });
};
const findSectPr = (obj, result = []) => {
  for (const key in obj) {
    if (obj[key] === "w:sectPr") {
      result.push(obj);
    } else if (typeof obj[key] === "object") {
      findSectPr(obj[key], result);
    }
  }
  return result;
};
const getHeaderFooterSectionData = (sectionData, docx) => {
  const rId = sectionData.attributes.Id;
  const target = sectionData.attributes.Target;
  const filePath = resolveOpcTargetPath(target, "word");
  const referenceFile = filePath ? docx[filePath] : void 0;
  const currentFileName = target;
  return {
    rId,
    referenceFile,
    currentFileName
  };
};
function filterOutRootInlineNodes(content = []) {
  if (!Array.isArray(content) || content.length === 0) return content;
  const INLINE_TYPES = /* @__PURE__ */ new Set([
    "text",
    "bookmarkStart",
    "bookmarkEnd",
    "lineBreak",
    "hardBreak",
    "pageNumber",
    "totalPageCount",
    "runItem",
    "image",
    "tab",
    "fieldAnnotation",
    "mention",
    "contentBlock",
    "aiLoaderNode",
    "commentRangeStart",
    "commentRangeEnd",
    "commentReference",
    "footnoteReference",
    "structuredContent"
  ]);
  const PRESERVABLE_INLINE_XML_NAMES = {
    bookmarkStart: "w:bookmarkStart",
    bookmarkEnd: "w:bookmarkEnd"
  };
  const result = [];
  content.forEach((node) => {
    if (!node || typeof node.type !== "string") return;
    const type2 = node.type;
    const preservableNodeName = PRESERVABLE_INLINE_XML_NAMES[type2];
    if (type2 === "image" && node.attrs?.isAnchor) {
      result.push({
        type: "paragraph",
        content: [node],
        attrs: {},
        marks: []
      });
      return;
    }
    if (!INLINE_TYPES.has(type2)) {
      result.push(node);
    } else if (preservableNodeName) {
      const originalXml = buildOriginalXml(type2, node.attrs, PRESERVABLE_INLINE_XML_NAMES);
      result.push({
        type: "passthroughBlock",
        attrs: {
          originalName: preservableNodeName,
          ...originalXml ? { originalXml } : {}
        }
      });
    }
  });
  return result;
}
const buildOriginalXml = (type2, attrs, preservableTags) => {
  const attrConfigsByType = {
    bookmarkStart: bookmarkStartAttrConfigs,
    bookmarkEnd: bookmarkEndAttrConfigs
  };
  const configs = attrConfigsByType[type2];
  if (!configs) return null;
  const xmlAttrs = {};
  configs.forEach((cfg) => {
    const val = cfg.decode(attrs || {});
    if (val !== void 0) {
      xmlAttrs[cfg.xmlName] = val;
    }
  });
  const attributes = Object.keys(xmlAttrs).length ? xmlAttrs : void 0;
  const name = preservableTags[type2];
  return { name, ...attributes ? { attributes } : {}, elements: [] };
};
function collapseWhitespaceNextToInlinePassthrough(content = []) {
  if (!Array.isArray(content) || content.length === 0) return;
  const sequence = collectInlineSequence(content);
  sequence.forEach((entry, index2) => {
    if (entry.kind !== "passthrough") return;
    const prev = findNeighborText(sequence, index2, -1);
    const next = findNeighborText(sequence, index2, 1);
    if (!prev || !next) return;
    if (!prev.node.text.endsWith(" ") || !next.node.text.startsWith(" ")) return;
    prev.node.text = prev.node.text.replace(/ +$/, " ");
    next.node.text = next.node.text.replace(/^ +/, "");
    if (next.node.text.length === 0) {
      next.parent.splice(next.index, 1);
    }
  });
}
function collectInlineSequence(nodes, result = [], insidePassthrough = false) {
  if (!Array.isArray(nodes) || nodes.length === 0) return result;
  nodes.forEach((node, index2) => {
    if (!node) return;
    const isPassthrough = node.type === "passthroughInline";
    if (isPassthrough && !insidePassthrough) {
      result.push({ kind: "passthrough", parent: nodes, index: index2 });
    }
    if (node.type === "text" && typeof node.text === "string" && !insidePassthrough) {
      result.push({ kind: "text", node, parent: nodes, index: index2 });
    }
    if (Array.isArray(node.content) && node.content.length) {
      const nextInside = insidePassthrough || isPassthrough;
      collectInlineSequence(node.content, result, nextInside);
    }
  });
  return result;
}
function findNeighborText(sequence, startIndex, direction) {
  let cursor = startIndex + direction;
  while (cursor >= 0 && cursor < sequence.length) {
    const entry = sequence[cursor];
    if (entry.kind === "text") {
      return entry;
    }
    cursor += direction;
  }
  return null;
}
function getThemeColorPalette(docx) {
  const themePart = docx?.["word/theme/theme1.xml"];
  if (!themePart || !Array.isArray(themePart.elements)) return void 0;
  const themeNode = themePart.elements.find((el) => el.name === "a:theme");
  const themeElements = themeNode?.elements?.find((el) => el.name === "a:themeElements");
  const clrScheme = themeElements?.elements?.find((el) => el.name === "a:clrScheme");
  if (!clrScheme || !Array.isArray(clrScheme.elements)) return void 0;
  const palette = {};
  clrScheme.elements.forEach((colorNode) => {
    const rawName = colorNode?.name;
    if (!rawName) return;
    const colorName = rawName.replace(/^a:/, "");
    if (!colorName) return;
    const valueNode = Array.isArray(colorNode.elements) ? colorNode.elements.find((el) => el.attributes && (el.attributes.val || el.attributes.lastClr)) : void 0;
    const colorValue = valueNode?.attributes?.val || valueNode?.attributes?.lastClr;
    if (!colorValue) return;
    const normalized = String(colorValue).trim();
    if (!normalized) return;
    palette[colorName] = `#${normalized.toUpperCase()}`;
  });
  return Object.keys(palette).length ? palette : void 0;
}
function getNumberingDefinitions(docx, converter) {
  const cache = ensureNumberingCache(docx, converter);
  const abstractDefinitions = {};
  cache.abstractById.forEach((value, key) => {
    const numericKey = Number(key);
    if (!Number.isNaN(numericKey)) {
      abstractDefinitions[numericKey] = value;
    }
  });
  let importListDefs = {};
  cache.numNodesById.forEach((value, key) => {
    const numericKey = Number(key);
    if (Number.isInteger(numericKey)) {
      importListDefs[numericKey] = value;
    }
  });
  return {
    abstracts: abstractDefinitions,
    definitions: importListDefs
  };
}
const isAlternatingHeadersOddEven = (docx) => {
  const settings = docx["word/settings.xml"];
  if (!settings || !settings.elements?.length) return false;
  const { elements = [] } = settings.elements[0];
  const evenOdd = elements.find((el) => el.name === "w:evenAndOddHeaders");
  return !!evenOdd;
};
function handleShapeTextboxImport({ params, pict }) {
  const shape = pict.elements?.find((el) => el.name === "v:shape");
  const schemaAttrs = {};
  const schemaTextboxAttrs = {};
  const shapeAttrs = shape.attributes || {};
  schemaAttrs.attributes = shapeAttrs;
  if (shapeAttrs.fillcolor) {
    schemaAttrs.fillcolor = shapeAttrs.fillcolor;
  }
  const parsedStyle = parseInlineStyles(shapeAttrs.style);
  const shapeStyle = buildStyles(parsedStyle);
  if (shapeStyle) {
    schemaAttrs.style = shapeStyle;
  }
  const textbox = shape.elements?.find((el) => el.name === "v:textbox");
  const wrap2 = shape.elements?.find((el) => el.name === "w10:wrap");
  if (wrap2?.attributes) {
    schemaAttrs.wrapAttributes = wrap2.attributes;
  }
  if (textbox?.attributes) {
    schemaTextboxAttrs.attributes = textbox.attributes;
  }
  const textboxContent = textbox?.elements?.find((el) => el.name === "w:txbxContent");
  const processedContent = preProcessTextBoxContent(textboxContent, params);
  const textboxParagraphs = collectTextBoxParagraphs(processedContent?.elements || []);
  const content = textboxParagraphs.map(
    (elem) => handleParagraphNode({
      nodes: [elem],
      docx: params.docx,
      nodeListHandler: defaultNodeListHandler()
    })
  );
  const contentNodes = content.reduce((acc, current) => [...acc, ...current.nodes], []);
  const shapeTextbox = {
    type: "shapeTextbox",
    attrs: schemaTextboxAttrs,
    content: contentNodes
  };
  const shapeContainer = {
    type: "shapeContainer",
    attrs: schemaAttrs,
    content: [shapeTextbox]
  };
  return shapeContainer;
}
function buildStyles(styleObject) {
  const allowed = [
    "width",
    "height"
    // these styles should probably work relative to the page,
    // since in the doc it is positioned absolutely.
    // 'margin-left',
    // 'margin-right',
    // causes pagination issues.
    // 'margin-top',
    // 'margin-bottom',
    // styleObject - also contains other word styles (mso-).
  ];
  let style = "";
  for (const [prop, value] of Object.entries(styleObject)) {
    if (allowed.includes(prop)) {
      style += `${prop}: ${value};`;
    }
  }
  return style;
}
function handleShapeImageWatermarkImport({ params, pict }) {
  const shape = pict.elements?.find((el) => el.name === "v:shape");
  if (!shape) return null;
  const imagedata = shape.elements?.find((el) => el.name === "v:imagedata");
  if (!imagedata) return null;
  const { docx, filename } = params;
  const shapeAttrs = shape.attributes || {};
  const imagedataAttrs = imagedata.attributes || {};
  const rId = imagedataAttrs["r:id"];
  if (!rId) {
    console.warn("v:imagedata missing r:id attribute");
    return null;
  }
  const currentFile = filename || "document.xml";
  let rels = docx[`word/_rels/${currentFile}.rels`];
  if (!rels) rels = docx[`word/_rels/document.xml.rels`];
  const relationships = rels?.elements?.find((el) => el.name === "Relationships");
  const { elements } = relationships || [];
  const rel = elements?.find((el) => el.attributes["Id"] === rId);
  if (!rel) {
    console.warn(`Relationship not found for r:id="${rId}"`);
    return null;
  }
  const targetPath = rel.attributes["Target"];
  const normalizedPath = normalizeTargetPath(targetPath);
  const style = shapeAttrs.style || "";
  const styleObj = parseVmlStyle$1(style);
  const width = styleObj.width || "100px";
  const height = styleObj.height || "100px";
  const position = {
    type: styleObj.position || "absolute",
    marginLeft: styleObj["margin-left"] || "0",
    marginTop: styleObj["margin-top"] || "0"
  };
  const zIndex = styleObj["z-index"] ? parseInt(styleObj["z-index"], 10) : void 0;
  const hPosition = styleObj["mso-position-horizontal"] || "center";
  const vPosition = styleObj["mso-position-vertical"] || "center";
  const hRelativeTo = styleObj["mso-position-horizontal-relative"] || "margin";
  const vRelativeTo = styleObj["mso-position-vertical-relative"] || "margin";
  const gain = imagedataAttrs["gain"];
  const blacklevel = imagedataAttrs["blacklevel"];
  const title = imagedataAttrs["o:title"] || "Watermark";
  const imageNode = {
    type: "image",
    attrs: {
      src: normalizedPath,
      alt: title,
      extension: normalizedPath.substring(normalizedPath.lastIndexOf(".") + 1),
      title,
      rId,
      // Store VML-specific attributes for round-trip
      vmlWatermark: true,
      vmlStyle: style,
      vmlAttributes: shapeAttrs,
      vmlImagedata: imagedataAttrs,
      // Positioning
      isAnchor: true,
      inline: false,
      wrap: {
        type: "None",
        attrs: {
          behindDoc: Number.isFinite(zIndex) ? zIndex < 0 : true
        }
      },
      anchorData: {
        hRelativeFrom: hRelativeTo,
        vRelativeFrom: vRelativeTo,
        alignH: hPosition,
        alignV: vPosition
      },
      // Size
      size: {
        width: convertToPixels$1(width),
        height: convertToPixels$1(height)
      },
      marginOffset: {
        horizontal: convertToPixels$1(position.marginLeft),
        top: convertToPixels$1(position.marginTop)
      },
      // Image adjustments
      ...gain && { gain },
      ...blacklevel && { blacklevel }
    }
  };
  return imageNode;
}
function normalizeTargetPath(targetPath = "") {
  if (!targetPath) return targetPath;
  const trimmed = targetPath.replace(/^\/+/, "");
  if (trimmed.startsWith("word/")) return trimmed;
  if (trimmed.startsWith("media/")) return `word/${trimmed}`;
  return `word/${trimmed}`;
}
function parseVmlStyle$1(style) {
  const result = {};
  if (!style) return result;
  const declarations = style.split(";").filter((s) => s.trim());
  for (const decl of declarations) {
    const [prop, value] = decl.split(":").map((s) => s.trim());
    if (prop && value) {
      result[prop] = value;
    }
  }
  return result;
}
function convertToPixels$1(value) {
  if (typeof value === "number") return value;
  if (!value || typeof value !== "string") return 0;
  const match = value.match(/^([\d.]+)([a-z%]+)?$/i);
  if (!match) return 0;
  const num = parseFloat(match[1]);
  const unit = match[2] || "px";
  switch (unit.toLowerCase()) {
    case "px":
      return num;
    case "pt":
      return num * (96 / 72);
    // 1pt = 1/72 inch, 96 DPI
    case "in":
      return num * 96;
    case "cm":
      return num * (96 / 2.54);
    case "mm":
      return num * (96 / 25.4);
    case "pc":
      return num * 16;
    // 1pc = 12pt
    default:
      return num;
  }
}
function handleShapeTextWatermarkImport({ pict }) {
  const shape = pict.elements?.find((el) => el.name === "v:shape");
  if (!shape) return null;
  const textpath = shape.elements?.find((el) => el.name === "v:textpath");
  if (!textpath) return null;
  const shapeAttrs = shape.attributes || {};
  const textpathAttrs = textpath.attributes || {};
  const watermarkText = textpathAttrs["string"] || "";
  if (!watermarkText) {
    console.warn("v:textpath missing string attribute");
    return null;
  }
  const style = shapeAttrs.style || "";
  const styleObj = parseVmlStyle(style);
  const width = styleObj.width || "481.8pt";
  const height = styleObj.height || "82.8pt";
  const position = {
    type: styleObj.position || "absolute",
    marginLeft: styleObj["margin-left"] || "0",
    marginTop: styleObj["margin-top"] || "0"
  };
  const rotation = parseFloat(styleObj.rotation) || 0;
  const hPosition = styleObj["mso-position-horizontal"] || "center";
  const vPosition = styleObj["mso-position-vertical"] || "center";
  const hRelativeTo = styleObj["mso-position-horizontal-relative"] || "margin";
  const vRelativeTo = styleObj["mso-position-vertical-relative"] || "margin";
  const textAnchor = styleObj["v-text-anchor"] || "middle";
  const fill = shape.elements?.find((el) => el.name === "v:fill");
  const fillAttrs = fill?.attributes || {};
  const rawFillColor = shapeAttrs.fillcolor || fillAttrs.color || "silver";
  const rawFillColor2 = fillAttrs.color2 || "#3f3f3f";
  const fillColor = sanitizeColor(rawFillColor, "silver");
  const fillColor2 = sanitizeColor(rawFillColor2, "#3f3f3f");
  const opacity = fillAttrs.opacity || "0.5";
  const fillType = fillAttrs.type || "solid";
  const stroke = shape.elements?.find((el) => el.name === "v:stroke");
  const strokeAttrs = stroke?.attributes || {};
  const stroked = shapeAttrs.stroked || "f";
  const strokeColor = strokeAttrs.color || "#3465a4";
  const strokeJoinstyle = strokeAttrs.joinstyle || "round";
  const strokeEndcap = strokeAttrs.endcap || "flat";
  const textpathStyle = textpathAttrs.style || "";
  const textStyleObj = parseVmlStyle(textpathStyle);
  const rawFontFamily = textStyleObj["font-family"]?.replace(/['"]/g, "");
  const fontFamily = sanitizeFontFamily(rawFontFamily);
  const fontSize = textStyleObj["font-size"] || "1pt";
  const fitshape = textpathAttrs.fitshape || "t";
  const trim = textpathAttrs.trim || "t";
  const textpathOn = textpathAttrs.on || "t";
  const path = shape.elements?.find((el) => el.name === "v:path");
  const pathAttrs = path?.attributes || {};
  const textpathok = pathAttrs.textpathok || "t";
  const wrap2 = shape.elements?.find((el) => el.name === "w10:wrap");
  const wrapAttrs = wrap2?.attributes || {};
  const wrapType = wrapAttrs.type || "none";
  const widthPx = convertToPixels(width);
  const heightPx = convertToPixels(height);
  const sanitizedOpacity = sanitizeNumeric(parseFloat(opacity), 0.5, 0, 1);
  const sanitizedRotation = sanitizeNumeric(rotation, 0, -360, 360);
  const svgResult = generateTextWatermarkSVG({
    text: watermarkText,
    width: widthPx,
    height: heightPx,
    rotation: sanitizedRotation,
    fill: {
      color: fillColor,
      opacity: sanitizedOpacity
    },
    textStyle: {
      fontFamily,
      fontSize
    }
  });
  const svgDataUri = svgResult.dataUri;
  const imageWatermarkNode = {
    type: "image",
    attrs: {
      src: svgDataUri,
      alt: watermarkText,
      title: watermarkText,
      extension: "svg",
      // Mark this as a text watermark for export
      vmlWatermark: true,
      vmlTextWatermark: true,
      // Store VML-specific attributes for round-trip
      vmlStyle: style,
      vmlAttributes: shapeAttrs,
      vmlTextpathAttributes: textpathAttrs,
      vmlPathAttributes: pathAttrs,
      vmlFillAttributes: fillAttrs,
      vmlStrokeAttributes: strokeAttrs,
      vmlWrapAttributes: wrapAttrs,
      // Positioning (same as image watermarks)
      isAnchor: true,
      inline: false,
      wrap: {
        type: wrapType === "none" ? "None" : wrapType,
        attrs: {
          behindDoc: true
        }
      },
      anchorData: {
        hRelativeFrom: hRelativeTo,
        vRelativeFrom: vRelativeTo,
        alignH: hPosition,
        alignV: vPosition
      },
      // Size - use rotated bounding box dimensions to prevent clipping
      size: {
        width: svgResult.svgWidth,
        height: svgResult.svgHeight
      },
      marginOffset: {
        // For center-aligned watermarks relative to margin, Word's margin values
        // are not suitable for browser rendering. Set to 0 to let center alignment work.
        horizontal: hPosition === "center" && hRelativeTo === "margin" ? 0 : convertToPixels(position.marginLeft),
        top: vPosition === "center" && vRelativeTo === "margin" ? 0 : convertToPixels(position.marginTop)
      },
      // Store text watermark specific data for export
      textWatermarkData: {
        text: watermarkText,
        rotation: sanitizedRotation,
        textStyle: {
          fontFamily,
          fontSize,
          textAnchor
        },
        fill: {
          color: fillColor,
          color2: fillColor2,
          opacity: sanitizedOpacity,
          type: fillType
        },
        stroke: {
          enabled: stroked !== "f",
          color: strokeColor,
          joinstyle: strokeJoinstyle,
          endcap: strokeEndcap
        },
        textpath: {
          on: textpathOn === "t",
          fitshape: fitshape === "t",
          trim: trim === "t",
          textpathok: textpathok === "t"
        }
      }
    }
  };
  return imageWatermarkNode;
}
function sanitizeFontFamily(fontFamily) {
  if (!fontFamily || typeof fontFamily !== "string") {
    return "Arial";
  }
  const sanitized = fontFamily.replace(/[^a-zA-Z0-9\s,\-]/g, "").trim();
  return sanitized || "Arial";
}
function sanitizeColor(color, defaultColor = "silver") {
  if (!color || typeof color !== "string") {
    return defaultColor;
  }
  const sanitized = color.replace(/[^a-zA-Z0-9#%(),.]/g, "").trim();
  return sanitized || defaultColor;
}
function sanitizeNumeric(value, defaultValue, min2 = -Infinity, max2 = Infinity) {
  const num = typeof value === "number" ? value : parseFloat(value);
  if (isNaN(num) || !isFinite(num)) {
    return defaultValue;
  }
  return Math.max(min2, Math.min(max2, num));
}
function generateTextWatermarkSVG({ text, width, height, rotation, fill, textStyle }) {
  let fontSize = height * 0.9;
  if (textStyle?.fontSize && textStyle.fontSize.trim() !== "1pt") {
    const match = textStyle.fontSize.match(/^([\d.]+)(pt|px)?$/);
    if (match) {
      const value = parseFloat(match[1]);
      const unit = match[2] || "pt";
      fontSize = (unit === "pt" ? value * (96 / 72) : value) * 50;
    }
  }
  fontSize = Math.max(fontSize, 48);
  const color = sanitizeColor(fill?.color, "silver");
  const opacity = sanitizeNumeric(fill?.opacity, 0.5, 0, 1);
  const fontFamily = sanitizeFontFamily(textStyle?.fontFamily);
  const sanitizedRotation = sanitizeNumeric(rotation, 0, -360, 360);
  const sanitizedWidth = sanitizeNumeric(width, 100, 1, 1e4);
  const sanitizedHeight = sanitizeNumeric(height, 100, 1, 1e4);
  const sanitizedFontSize = sanitizeNumeric(fontSize, 48, 1, 1e3);
  const radians = sanitizedRotation * Math.PI / 180;
  const cos = Math.abs(Math.cos(radians));
  const sin = Math.abs(Math.sin(radians));
  const rotatedWidth = sanitizedWidth * cos + sanitizedHeight * sin;
  const rotatedHeight = sanitizedWidth * sin + sanitizedHeight * cos;
  const svgWidth = Math.max(sanitizedWidth, rotatedWidth) * 1.1;
  const svgHeight = Math.max(sanitizedHeight, rotatedHeight) * 1.1;
  const centerX = svgWidth / 2;
  const centerY = svgHeight / 2;
  const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${svgWidth}" height="${svgHeight}" viewBox="0 0 ${svgWidth} ${svgHeight}" style="overflow: visible;">
  <text
    x="${centerX}"
    y="${centerY}"
    text-anchor="middle"
    dominant-baseline="middle"
    font-family="${fontFamily}"
    font-size="${sanitizedFontSize}px"
    fill="${color}"
    opacity="${opacity}"
    transform="rotate(${sanitizedRotation} ${centerX} ${centerY})">${escapeXml(text)}</text>
</svg>`;
  return {
    dataUri: `data:image/svg+xml,${encodeURIComponent(svg)}`,
    svgWidth,
    svgHeight
  };
}
function escapeXml(text) {
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
function parseVmlStyle(style) {
  const result = {};
  if (!style) return result;
  const declarations = style.split(";").filter((s) => s.trim());
  for (const decl of declarations) {
    const colonIndex = decl.indexOf(":");
    if (colonIndex === -1) continue;
    const prop = decl.substring(0, colonIndex).trim();
    const value = decl.substring(colonIndex + 1).trim();
    if (prop && value) {
      result[prop] = value;
    }
  }
  return result;
}
function convertToPixels(value) {
  if (typeof value === "number") return value;
  if (!value || typeof value !== "string") return 0;
  const match = value.match(/^([\d.]+)([a-z%]+)?$/i);
  if (!match) return 0;
  const num = parseFloat(match[1]);
  const unit = match[2] || "px";
  switch (unit.toLowerCase()) {
    case "px":
      return num;
    case "pt":
      return num * (96 / 72);
    // 1pt = 1/72 inch, 96 DPI
    case "in":
      return num * 96;
    case "cm":
      return num * (96 / 2.54);
    case "mm":
      return num * (96 / 25.4);
    case "pc":
      return num * 16;
    // 1pc = 12pt
    default:
      return num;
  }
}
function pictNodeTypeStrategy(node) {
  const shape = node.elements?.find((el) => el.name === "v:shape");
  const group = node.elements?.find((el) => el.name === "v:group");
  const rect = node.elements?.find((el) => el.name === "v:rect");
  if (rect) {
    return { type: "contentBlock", handler: handleVRectImport };
  }
  if (!shape && !group) {
    return { type: "unknown", handler: null };
  }
  const isGroup = group && !shape;
  if (isGroup) {
    return { type: "unknown", handler: null };
  } else {
    const textbox = shape.elements?.find((el) => el.name === "v:textbox");
    if (textbox) {
      return { type: "shapeContainer", handler: handleShapeTextboxImport };
    }
    const textpath = shape.elements?.find((el) => el.name === "v:textpath");
    if (textpath) {
      return { type: "image", handler: handleShapeTextWatermarkImport };
    }
    const imagedata = shape.elements?.find((el) => el.name === "v:imagedata");
    if (imagedata) {
      return { type: "image", handler: handleShapeImageWatermarkImport };
    }
  }
  return { type: "unknown", handler: null };
}
function translateShapeContainer(params) {
  const { node } = params;
  const elements = translateChildNodes(params);
  const shape = {
    name: "v:shape",
    attributes: {
      ...node.attrs.attributes,
      fillcolor: node.attrs.fillcolor
    },
    elements: [
      ...elements,
      ...node.attrs.wrapAttributes ? [
        {
          name: "w10:wrap",
          attributes: { ...node.attrs.wrapAttributes }
        }
      ] : []
    ]
  };
  const pict = {
    name: "w:pict",
    attributes: {
      "w14:anchorId": generateRandomSigned32BitIntStrId()
    },
    elements: [shape]
  };
  const par = {
    name: "w:p",
    elements: [wrapTextInRun(pict)]
  };
  return par;
}
function translateShapeTextbox(params) {
  const { node } = params;
  const elements = translateChildNodes(params);
  const textboxContent = {
    name: "w:txbxContent",
    elements
  };
  const textbox = {
    name: "v:textbox",
    attributes: {
      ...node.attrs.attributes
    },
    elements: [textboxContent]
  };
  return textbox;
}
function translateContentBlock(params) {
  const { node } = params;
  const { vmlAttributes, horizontalRule } = node.attrs;
  if (vmlAttributes || horizontalRule) {
    return translateVRectContentBlock(params);
  }
  const alternateContent = translator$2v.decode(params);
  return wrapTextInRun(alternateContent);
}
function translateVRectContentBlock(params) {
  const { node } = params;
  const { vmlAttributes, background, attributes, style } = node.attrs;
  const rectAttrs = {
    id: attributes?.id || `_x0000_i${Math.floor(Math.random() * 1e4)}`
  };
  if (style) {
    rectAttrs.style = style;
  }
  if (background) {
    rectAttrs.fillcolor = background;
  }
  if (vmlAttributes) {
    if (vmlAttributes.hralign) rectAttrs["o:hralign"] = vmlAttributes.hralign;
    if (vmlAttributes.hrstd) rectAttrs["o:hrstd"] = vmlAttributes.hrstd;
    if (vmlAttributes.hr) rectAttrs["o:hr"] = vmlAttributes.hr;
    if (vmlAttributes.stroked) rectAttrs.stroked = vmlAttributes.stroked;
  }
  if (attributes) {
    Object.entries(attributes).forEach(([key, value]) => {
      if (!rectAttrs[key] && value !== void 0) {
        rectAttrs[key] = value;
      }
    });
  }
  const rect = {
    name: "v:rect",
    attributes: rectAttrs
  };
  const pict = {
    name: "w:pict",
    attributes: {
      "w14:anchorId": generateRandomSigned32BitIntStrId()
    },
    elements: [rect]
  };
  return wrapTextInRun(pict);
}
function translateImageWatermark(params) {
  const { node } = params;
  const { attrs } = node;
  if (attrs.vmlAttributes && attrs.vmlImagedata) {
    const shape2 = {
      name: "v:shape",
      attributes: attrs.vmlAttributes,
      elements: [
        {
          name: "v:imagedata",
          attributes: {
            ...attrs.vmlImagedata,
            "r:id": attrs.rId
          }
        }
      ]
    };
    const pict2 = {
      name: "w:pict",
      attributes: {
        "w14:anchorId": generateRandomSigned32BitIntStrId()
      },
      elements: [shape2]
    };
    const par2 = {
      name: "w:p",
      elements: [wrapTextInRun(pict2)]
    };
    return par2;
  }
  const style = buildVmlStyle$1(attrs);
  const shape = {
    name: "v:shape",
    attributes: {
      id: `WordPictureWatermark${generateRandomSigned32BitIntStrId().replace("-", "")}`,
      "o:spid": `_x0000_s${Math.floor(Math.random() * 1e4)}`,
      type: "#_x0000_t75",
      style,
      "o:allowincell": "f"
    },
    elements: [
      {
        name: "v:imagedata",
        attributes: {
          "r:id": attrs.rId,
          "o:title": attrs.title || attrs.alt || "Watermark",
          ...attrs.gain && { gain: attrs.gain },
          ...attrs.blacklevel && { blacklevel: attrs.blacklevel }
        }
      }
    ]
  };
  const pict = {
    name: "w:pict",
    attributes: {
      "w14:anchorId": generateRandomSigned32BitIntStrId()
    },
    elements: [shape]
  };
  const par = {
    name: "w:p",
    elements: [wrapTextInRun(pict)]
  };
  return par;
}
function buildVmlStyle$1(attrs) {
  const styles = [];
  styles.push("position:absolute");
  if (attrs.size) {
    if (attrs.size.width) {
      styles.push(`width:${convertToPt$1(attrs.size.width)}pt`);
    }
    if (attrs.size.height) {
      styles.push(`height:${convertToPt$1(attrs.size.height)}pt`);
    }
  }
  if (attrs.marginOffset) {
    if (attrs.marginOffset.horizontal !== void 0) {
      styles.push(`margin-left:${convertToPt$1(attrs.marginOffset.horizontal)}pt`);
    }
    if (attrs.marginOffset.top !== void 0) {
      styles.push(`margin-top:${convertToPt$1(attrs.marginOffset.top)}pt`);
    }
  }
  if (attrs.wrap?.attrs?.behindDoc) {
    styles.push("z-index:-251653120");
  }
  if (attrs.anchorData) {
    if (attrs.anchorData.alignH) {
      styles.push(`mso-position-horizontal:${attrs.anchorData.alignH}`);
    }
    if (attrs.anchorData.alignV) {
      styles.push(`mso-position-vertical:${attrs.anchorData.alignV}`);
    }
    if (attrs.anchorData.hRelativeFrom) {
      styles.push(`mso-position-horizontal-relative:${attrs.anchorData.hRelativeFrom}`);
    }
    if (attrs.anchorData.vRelativeFrom) {
      styles.push(`mso-position-vertical-relative:${attrs.anchorData.vRelativeFrom}`);
    }
  }
  styles.push("mso-width-percent:0");
  styles.push("mso-height-percent:0");
  return styles.join(";");
}
function convertToPt$1(pixels) {
  return pixels * 72 / 96;
}
function translateTextWatermark(params) {
  const { node } = params;
  const { attrs } = node;
  const text = attrs.textWatermarkData?.text || attrs.vmlTextpathAttributes?.string || "";
  if (attrs.vmlAttributes && attrs.vmlTextpathAttributes) {
    const shapeElements2 = [];
    if (attrs.vmlPathAttributes) {
      shapeElements2.push({
        name: "v:path",
        attributes: attrs.vmlPathAttributes
      });
    }
    shapeElements2.push({
      name: "v:textpath",
      attributes: {
        ...attrs.vmlTextpathAttributes,
        string: text
      }
    });
    if (attrs.vmlFillAttributes && Object.keys(attrs.vmlFillAttributes).length > 0) {
      shapeElements2.push({
        name: "v:fill",
        attributes: attrs.vmlFillAttributes
      });
    }
    if (attrs.vmlStrokeAttributes && Object.keys(attrs.vmlStrokeAttributes).length > 0) {
      shapeElements2.push({
        name: "v:stroke",
        attributes: attrs.vmlStrokeAttributes
      });
    }
    if (attrs.vmlWrapAttributes) {
      shapeElements2.push({
        name: "w10:wrap",
        attributes: attrs.vmlWrapAttributes
      });
    }
    const shape2 = {
      name: "v:shape",
      attributes: attrs.vmlAttributes,
      elements: shapeElements2
    };
    const pict2 = {
      name: "w:pict",
      elements: [shape2]
    };
    const par2 = {
      name: "w:p",
      elements: [wrapTextInRun(pict2)]
    };
    return par2;
  }
  const wmData = attrs.textWatermarkData || {};
  const style = buildVmlStyle(attrs, wmData);
  const textpathStyle = buildTextpathStyle(wmData);
  const shapeElements = [];
  shapeElements.push({
    name: "v:path",
    attributes: {
      textpathok: "t"
    }
  });
  shapeElements.push({
    name: "v:textpath",
    attributes: {
      on: "t",
      fitshape: "t",
      string: text,
      style: textpathStyle,
      ...wmData.textpath?.trim !== void 0 && { trim: wmData.textpath.trim ? "t" : "f" }
    }
  });
  const fillAttrs = {};
  const fill = wmData.fill || attrs.fill;
  if (fill) {
    if (fill.type) fillAttrs.type = fill.type;
    if (fill.color2) fillAttrs.color2 = fill.color2;
    if (fill.opacity !== void 0) fillAttrs.opacity = fill.opacity.toString();
    if (fill.detectmouseclick !== void 0) {
      fillAttrs["o:detectmouseclick"] = fill.detectmouseclick ? "t" : "f";
    }
  }
  if (Object.keys(fillAttrs).length > 0) {
    shapeElements.push({
      name: "v:fill",
      attributes: fillAttrs
    });
  }
  const stroke = wmData.stroke || attrs.stroke;
  if (stroke && stroke.enabled !== false) {
    const strokeAttrs = {};
    if (stroke.color) strokeAttrs.color = stroke.color;
    if (stroke.joinstyle) strokeAttrs.joinstyle = stroke.joinstyle;
    if (stroke.endcap) strokeAttrs.endcap = stroke.endcap;
    if (Object.keys(strokeAttrs).length > 0) {
      shapeElements.push({
        name: "v:stroke",
        attributes: strokeAttrs
      });
    }
  }
  shapeElements.push({
    name: "w10:wrap",
    attributes: {
      type: attrs.wrap?.type?.toLowerCase() || "none"
    }
  });
  const shape = {
    name: "v:shape",
    attributes: {
      id: `PowerPlusWaterMarkObject${generateRandomSigned32BitIntStrId().replace("-", "")}`,
      "o:spid": `shape_${Math.floor(Math.random() * 1e4)}`,
      type: "#_x0000_t136",
      style,
      fillcolor: fill?.color || "silver",
      stroked: stroke?.enabled !== false ? "t" : "f",
      "o:allowincell": "f",
      ...attrs.vmlAttributes?.adj && { adj: attrs.vmlAttributes.adj }
    },
    elements: shapeElements
  };
  const pict = {
    name: "w:pict",
    elements: [shape]
  };
  const par = {
    name: "w:p",
    elements: [wrapTextInRun(pict)]
  };
  return par;
}
function buildVmlStyle(attrs, wmData) {
  const styles = [];
  styles.push("position:absolute");
  if (attrs.marginOffset) {
    if (attrs.marginOffset.horizontal !== void 0) {
      styles.push(`margin-left:${convertToPt(attrs.marginOffset.horizontal)}pt`);
    }
    if (attrs.marginOffset.top !== void 0) {
      styles.push(`margin-top:${convertToPt(attrs.marginOffset.top)}pt`);
    }
  } else {
    styles.push("margin-left:0.05pt");
    styles.push("margin-top:315.7pt");
  }
  if (attrs.size) {
    if (attrs.size.width) {
      styles.push(`width:${convertToPt(attrs.size.width)}pt`);
    }
    if (attrs.size.height) {
      styles.push(`height:${convertToPt(attrs.size.height)}pt`);
    }
  }
  const wrapType = attrs.wrap?.type;
  let msoWrapStyle = "none";
  if (wrapType) {
    const wrapTypeLower = wrapType.toLowerCase();
    if (wrapTypeLower === "topandbottom") {
      msoWrapStyle = "top-and-bottom";
    } else if (["square", "tight", "through"].includes(wrapTypeLower)) {
      msoWrapStyle = wrapTypeLower;
    }
  }
  styles.push(`mso-wrap-style:${msoWrapStyle}`);
  const textAnchor = wmData.textStyle?.textAnchor || attrs.textStyle?.textAnchor;
  if (textAnchor) {
    styles.push(`v-text-anchor:${textAnchor}`);
  }
  const rotation = wmData.rotation || attrs.rotation;
  if (rotation !== void 0 && rotation !== 0) {
    styles.push(`rotation:${rotation}`);
  }
  if (attrs.anchorData) {
    if (attrs.anchorData.alignH) {
      styles.push(`mso-position-horizontal:${attrs.anchorData.alignH}`);
    }
    if (attrs.anchorData.alignV) {
      styles.push(`mso-position-vertical:${attrs.anchorData.alignV}`);
    }
    if (attrs.anchorData.hRelativeFrom) {
      styles.push(`mso-position-horizontal-relative:${attrs.anchorData.hRelativeFrom}`);
    }
    if (attrs.anchorData.vRelativeFrom) {
      styles.push(`mso-position-vertical-relative:${attrs.anchorData.vRelativeFrom}`);
    }
  }
  return styles.join(";");
}
function buildTextpathStyle(wmData) {
  const styles = [];
  if (wmData.textStyle) {
    if (wmData.textStyle.fontFamily) {
      styles.push(`font-family:"${wmData.textStyle.fontFamily}"`);
    }
    if (wmData.textStyle.fontSize) {
      styles.push(`font-size:${wmData.textStyle.fontSize}`);
    }
  }
  return styles.join(";");
}
function convertToPt(pixels) {
  if (typeof pixels === "number") {
    return pixels * 72 / 96;
  }
  return parseFloat(pixels) || 0;
}
const XML_NODE_NAME = "w:pict";
const SD_NODE_NAME = ["shapeContainer", "contentBlock", "image"];
const validXmlAttributes = [];
function encode(params) {
  const { node, pNode } = params.extraParams;
  const { type: pictType, handler: handler2 } = pictNodeTypeStrategy(node);
  if (!handler2 || pictType === "unknown") {
    return void 0;
  }
  const result = handler2({
    params,
    pNode,
    pict: node
  });
  return result;
}
function decode(params) {
  const { node } = params;
  if (!node || !node.type) {
    return null;
  }
  const types2 = {
    shapeContainer: () => translateShapeContainer(params),
    shapeTextbox: () => translateShapeTextbox(params),
    contentBlock: () => translateContentBlock(params),
    image: () => {
      if (node.attrs?.vmlWatermark) {
        if (node.attrs?.vmlTextWatermark) {
          return translateTextWatermark(params);
        }
        return translateImageWatermark(params);
      }
      return null;
    },
    default: () => null
  };
  const decoder = types2[node.type] ?? types2.default;
  const result = decoder();
  return result;
}
const config = {
  xmlName: XML_NODE_NAME,
  sdNodeOrKeyName: SD_NODE_NAME,
  type: NodeTranslator.translatorTypes.NODE,
  encode,
  decode,
  attributes: validXmlAttributes
};
const translator = NodeTranslator.from(config);
const DEFAULT_SECTION_PROPS_TWIPS = Object.freeze({
  pageSize: Object.freeze({ width: "12240", height: "15840" }),
  pageMargins: Object.freeze({
    top: "1440",
    right: "1440",
    bottom: "1440",
    left: "1440",
    header: "720",
    footer: "720",
    gutter: "0"
  })
});
const ensureSectionLayoutDefaults = (sectPr, converter) => {
  if (!sectPr) {
    return {
      type: "element",
      name: "w:sectPr",
      elements: []
    };
  }
  if (!sectPr.elements) sectPr.elements = [];
  const ensureChild = (name) => {
    let child = sectPr.elements.find((n) => n.name === name);
    if (!child) {
      child = {
        type: "element",
        name,
        elements: [],
        attributes: {}
      };
      sectPr.elements.push(child);
    } else {
      if (!child.elements) child.elements = [];
      if (!child.attributes) child.attributes = {};
    }
    return child;
  };
  const pageSize = converter?.pageStyles?.pageSize;
  const pgSz = ensureChild("w:pgSz");
  if (pageSize?.width != null) pgSz.attributes["w:w"] = String(inchesToTwips(pageSize.width));
  if (pageSize?.height != null) pgSz.attributes["w:h"] = String(inchesToTwips(pageSize.height));
  if (pgSz.attributes["w:w"] == null) pgSz.attributes["w:w"] = DEFAULT_SECTION_PROPS_TWIPS.pageSize.width;
  if (pgSz.attributes["w:h"] == null) pgSz.attributes["w:h"] = DEFAULT_SECTION_PROPS_TWIPS.pageSize.height;
  const pageMargins = converter?.pageStyles?.pageMargins;
  const pgMar = ensureChild("w:pgMar");
  if (pageMargins) {
    Object.entries(pageMargins).forEach(([key, value]) => {
      const converted = inchesToTwips(value);
      if (converted != null) pgMar.attributes[`w:${key}`] = String(converted);
    });
  }
  Object.entries(DEFAULT_SECTION_PROPS_TWIPS.pageMargins).forEach(([key, value]) => {
    const attrKey = `w:${key}`;
    if (pgMar.attributes[attrKey] == null) pgMar.attributes[attrKey] = value;
  });
  return sectPr;
};
function exportSchemaToJson(params) {
  const { type: type2 } = params.node || {};
  const router = {
    doc: translateDocumentNode,
    body: translateBodyNode,
    heading: translateHeadingNode,
    paragraph: translator$1N,
    run: translator$1L,
    text: translator$o,
    lineBreak: translator$39,
    table: translator$A,
    tableRow: translator$1d,
    tableCell: translator$1p,
    bookmarkStart: translator$z,
    bookmarkEnd: translator$y,
    fieldAnnotation: translator$S,
    tab: translator$37,
    image: translator$T,
    hardBreak: translator$39,
    commentRangeStart: commentRangeStartTranslator,
    commentRangeEnd: commentRangeEndTranslator,
    permStart: translator$x,
    permEnd: translator$w,
    commentReference: () => null,
    footnoteReference: translator$k,
    shapeContainer: translator,
    shapeTextbox: translator,
    contentBlock: translator,
    vectorShape: translateVectorShape,
    shapeGroup: translateShapeGroup,
    structuredContent: translator$S,
    structuredContentBlock: translator$S,
    documentPartObject: translator$S,
    documentSection: translator$S,
    "page-number": translator$r,
    "total-page-number": translator$q,
    pageReference: translator$v,
    tableOfContents: translator$u,
    index: translator$t,
    indexEntry: translator$s,
    passthroughBlock: translatePassthroughNode,
    passthroughInline: translatePassthroughNode
  };
  let handler2 = router[type2];
  if (handler2 && "decode" in handler2 && typeof handler2.decode === "function") {
    return handler2.decode(params);
  }
  if (!handler2) {
    console.error("No translation function found for node type:", type2);
    return null;
  }
  return handler2(params);
}
function translatePassthroughNode(params) {
  const original = params?.node?.attrs?.originalXml;
  if (!original) return null;
  return carbonCopy(original);
}
function translateBodyNode(params) {
  let sectPr = params.bodyNode?.elements?.find((n) => n.name === "w:sectPr");
  if (!sectPr) {
    sectPr = {
      type: "element",
      name: "w:sectPr",
      elements: []
    };
  } else if (!sectPr.elements) {
    sectPr = { ...sectPr, elements: [] };
  }
  sectPr = ensureSectionLayoutDefaults(sectPr, params.converter);
  if (params.converter) {
    const canExportHeaderRef = params.converter.importedBodyHasHeaderRef || params.converter.headerFooterModified;
    const canExportFooterRef = params.converter.importedBodyHasFooterRef || params.converter.headerFooterModified;
    const hasHeader = sectPr.elements?.some((n) => n.name === "w:headerReference");
    const hasDefaultHeader = params.converter.headerIds?.default;
    if (!hasHeader && hasDefaultHeader && !params.editor.options.isHeaderOrFooter && canExportHeaderRef) {
      const defaultHeader = generateDefaultHeaderFooter("header", params.converter.headerIds?.default);
      sectPr.elements.push(defaultHeader);
    }
    const hasFooter = sectPr.elements?.some((n) => n.name === "w:footerReference");
    const hasDefaultFooter = params.converter.footerIds?.default;
    if (!hasFooter && hasDefaultFooter && !params.editor.options.isHeaderOrFooter && canExportFooterRef) {
      const defaultFooter = generateDefaultHeaderFooter("footer", params.converter.footerIds?.default);
      sectPr.elements.push(defaultFooter);
    }
    const hasFootnotePr = sectPr.elements?.some((n) => n.name === "w:footnotePr");
    const footnoteProperties = params.converter.footnoteProperties;
    if (!hasFootnotePr && footnoteProperties?.source === "sectPr" && footnoteProperties.originalXml) {
      sectPr.elements.push(carbonCopy(footnoteProperties.originalXml));
    }
  }
  const elements = translateChildNodes(params);
  if (params.isHeaderFooter) {
    return {
      name: "w:body",
      elements: [...elements]
    };
  }
  return {
    name: "w:body",
    elements: [...elements, sectPr]
  };
}
const generateDefaultHeaderFooter = (type2, id) => {
  return {
    type: "element",
    name: `w:${type2}Reference`,
    attributes: {
      "w:type": "default",
      "r:id": id
    }
  };
};
function translateHeadingNode(params) {
  const { node } = params;
  const { level = 1, ...otherAttrs } = node.attrs;
  const paragraphNode = {
    type: "paragraph",
    content: node.content,
    attrs: {
      ...otherAttrs,
      styleId: `Heading${level}`
      // Maps to Heading1, Heading2, etc. in Word
    }
  };
  return translator$1N.decode({ ...params, node: paragraphNode });
}
function mergeMcIgnorable(defaultIgnorable = "", originalIgnorable = "") {
  const merged = [
    .../* @__PURE__ */ new Set([...defaultIgnorable.split(/\s+/).filter(Boolean), ...originalIgnorable.split(/\s+/).filter(Boolean)])
  ];
  return merged.join(" ");
}
function translateDocumentNode(params) {
  const bodyNode = {
    type: "body",
    content: params.node.content
  };
  const translatedBodyNode = exportSchemaToJson({ ...params, node: bodyNode });
  const originalAttrs = params.converter?.documentAttributes || {};
  const attributes = {
    ...DEFAULT_DOCX_DEFS,
    ...originalAttrs
  };
  const mergedIgnorable = mergeMcIgnorable(DEFAULT_DOCX_DEFS["mc:Ignorable"], originalAttrs["mc:Ignorable"]);
  if (mergedIgnorable) {
    attributes["mc:Ignorable"] = mergedIgnorable;
  }
  const node = {
    name: "w:document",
    elements: [translatedBodyNode],
    attributes
  };
  return [node, params];
}
function wrapTextInRun(nodeOrNodes, marks) {
  let elements = [];
  if (Array.isArray(nodeOrNodes)) elements = nodeOrNodes;
  else elements = [nodeOrNodes];
  if (marks && marks.length) elements.unshift(generateRunProps(marks));
  return {
    name: "w:r",
    elements
  };
}
function generateRunProps(marks = []) {
  return {
    name: "w:rPr",
    elements: marks.filter((mark) => !!Object.keys(mark).length)
  };
}
function processOutputMarks(marks = []) {
  return marks.flatMap((mark) => {
    if (mark.type === "textStyle") {
      return Object.entries(mark.attrs).filter(([, value]) => value).map(([key]) => {
        const unwrappedMark = { type: key, attrs: mark.attrs };
        return translateMark(unwrappedMark);
      });
    } else {
      return translateMark(mark);
    }
  });
}
function translateMark(mark) {
  const xmlMark = SuperConverter.markTypes.find((m2) => m2.type === mark.type);
  if (!xmlMark) {
    return {};
  }
  const markElement = { name: xmlMark.name, attributes: {} };
  const { attrs } = mark;
  let value;
  switch (mark.type) {
    case "bold":
      if (attrs?.value) {
        markElement.attributes["w:val"] = attrs.value;
      } else {
        delete markElement.attributes;
      }
      markElement.type = "element";
      break;
    case "italic":
      if (attrs?.value && attrs.value !== "1" && attrs.value !== true) {
        markElement.attributes["w:val"] = attrs.value;
      } else {
        delete markElement.attributes;
      }
      markElement.type = "element";
      break;
    case "underline": {
      const translated = translator$32.decode({
        node: {
          attrs: {
            underlineType: attrs.underlineType ?? attrs.underline ?? null,
            underlineColor: attrs.underlineColor ?? attrs.color ?? null,
            underlineThemeColor: attrs.underlineThemeColor ?? attrs.themeColor ?? null,
            underlineThemeTint: attrs.underlineThemeTint ?? attrs.themeTint ?? null,
            underlineThemeShade: attrs.underlineThemeShade ?? attrs.themeShade ?? null
          }
        }
      });
      return translated || {};
    }
    // Text style cases
    case "fontSize":
      value = attrs.fontSize;
      markElement.attributes["w:val"] = value.slice(0, -2) * 2;
      break;
    case "fontFamily":
      value = attrs.fontFamily;
      ["w:ascii", "w:eastAsia", "w:hAnsi", "w:cs"].forEach((attr) => {
        const parsedValue = value.split(", ");
        markElement.attributes[attr] = parsedValue[0] ? parsedValue[0] : value;
      });
      break;
    // Add ability to get run styleIds from textStyle marks and inject to run properties in word
    case "styleId":
      markElement.name = "w:rStyle";
      markElement.attributes["w:val"] = attrs.styleId;
      break;
    case "color": {
      const rawColor = attrs.color;
      if (!rawColor) break;
      const normalized = String(rawColor).trim().toLowerCase();
      if (normalized === "inherit") {
        markElement.attributes["w:val"] = "auto";
        break;
      }
      let processedColor = String(rawColor).replace(/^#/, "").replace(/;$/, "");
      if (processedColor.startsWith("rgb")) {
        processedColor = rgbToHex(processedColor);
      }
      markElement.attributes["w:val"] = processedColor;
      break;
    }
    case "textAlign":
      markElement.attributes["w:val"] = attrs.textAlign;
      break;
    case "textIndent":
      markElement.attributes["w:firstline"] = inchesToTwips(attrs.textIndent);
      break;
    case "textTransform":
      if (attrs?.textTransform === "none") {
        markElement.attributes["w:val"] = "0";
      } else {
        delete markElement.attributes;
      }
      markElement.type = "element";
      break;
    case "lineHeight":
      markElement.attributes["w:line"] = linesToTwips(attrs.lineHeight);
      break;
    case "highlight": {
      const highlightValue = attrs.color ?? attrs.highlight ?? null;
      const translated = translator$38.decode({ node: { attrs: { highlight: highlightValue } } });
      return translated || {};
    }
    case "strike":
      if (attrs?.value === "0") markElement.attributes["w:val"] = attrs.value;
      break;
    case "link":
      return {};
  }
  return markElement;
}
class DocxExporter {
  constructor(converter) {
    __privateAdd(this, _DocxExporter_instances);
    this.converter = converter;
  }
  schemaToXml(data, debug = false) {
    const result = __privateMethod(this, _DocxExporter_instances, generate_xml_as_list_fn).call(this, data, debug);
    return result.join("");
  }
}
_DocxExporter_instances = new WeakSet();
generate_xml_as_list_fn = function(data, debug = false) {
  const json = JSON.parse(JSON.stringify(data));
  const declaration = this.converter.declaration?.attributes || {
    version: "1.0",
    encoding: "UTF-8",
    standalone: "yes"
  };
  const xmlTag = `<?xml${Object.entries(declaration).map(([key, value]) => ` ${key}="${value}"`).join("")}?>`;
  const result = __privateMethod(this, _DocxExporter_instances, generateXml_fn).call(this, json, debug);
  const final = [xmlTag, ...result];
  return final;
};
replaceSpecialCharacters_fn = function(text) {
  if (text === void 0 || text === null) return text;
  return String(text).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
};
/**
 * Recursively generates XML string representation from a JSON node structure.
 * Handles special processing for different element types to maintain Word document integrity.
 *
 * Processing behavior by element type:
 * - Text nodes (type='text'): Escapes special XML characters (&, <, >, ", ')
 * - w:instrText: Joins child text nodes and escapes special characters; preserves field instruction syntax
 * - w:t, w:delText, wp:posOffset: Removes [[sdspace]] placeholders that were added during import to preserve
 *   whitespace, then escapes special characters. These placeholders are temporary markers used internally.
 * - Other elements: Recursively processes child elements
 *
 * @param {Object} node - The JSON node to convert to XML
 * @param {string} node.name - The XML element name (e.g., 'w:t', 'w:p')
 * @param {Object} [node.attributes] - Key-value pairs of XML attributes
 * @param {Array} [node.elements] - Array of child nodes to process recursively
 * @param {string} [node.type] - Node type ('text' for text nodes, 'element' for XML elements)
 * @param {string} [node.text] - The text content (only present when type='text')
 * @returns {string[]|string|null} Array of XML string fragments for elements, string for text nodes, or null for invalid nodes
 * @throws {Error} Logs error to console if text element processing fails, then continues processing
 *
 * @example
 * // Simple text element
 * const node = {
 *   name: 'w:t',
 *   elements: [{ type: 'text', text: 'Hello World' }]
 * };
 * // Returns: ['<w:t>', 'Hello World', '</w:t>']
 *
 * @example
 * // Element with placeholder removal
 * const node = {
 *   name: 'w:t',
 *   elements: [{ type: 'text', text: 'Text[[sdspace]]content' }]
 * };
 * // Returns: ['<w:t>', 'Textcontent', '</w:t>']
 */
generateXml_fn = function(node) {
  if (!node) return null;
  let { name } = node;
  const { elements, attributes } = node;
  let tag = `<${name}`;
  for (let attr in attributes) {
    const parsedAttrName = typeof attributes[attr] === "string" ? __privateMethod(this, _DocxExporter_instances, replaceSpecialCharacters_fn).call(this, attributes[attr]) : attributes[attr];
    tag += ` ${attr}="${parsedAttrName}"`;
  }
  const selfClosing = name && (!elements || !elements.length);
  if (selfClosing) tag += " />";
  else tag += ">";
  let tags = [tag];
  if (!name && node.type === "text") {
    return __privateMethod(this, _DocxExporter_instances, replaceSpecialCharacters_fn).call(this, node.text ?? "");
  }
  if (elements) {
    if (name === "w:instrText") {
      const textContent = (elements || []).map((child) => typeof child?.text === "string" ? child.text : "").join("");
      tags.push(__privateMethod(this, _DocxExporter_instances, replaceSpecialCharacters_fn).call(this, textContent));
    } else if (name === "w:t" || name === "w:delText" || name === "wp:posOffset") {
      if (elements.length === 0) {
        console.error(`${name} element has no child elements. Expected text node. Element will be self-closing.`);
      } else if (elements[0] == null || typeof elements[0].text !== "string") {
        console.error(
          `${name} element's first child is missing or does not have a valid text property. Received: ${JSON.stringify(elements[0])}. Pushing empty string to maintain XML structure.`
        );
        tags.push("");
      } else {
        let text = elements[0].text.replace(/\[\[sdspace\]\]/g, "");
        text = __privateMethod(this, _DocxExporter_instances, replaceSpecialCharacters_fn).call(this, text);
        tags.push(text);
      }
    } else {
      if (elements) {
        for (let child of elements) {
          const newElements = __privateMethod(this, _DocxExporter_instances, generateXml_fn).call(this, child);
          if (!newElements) {
            continue;
          }
          if (typeof newElements === "string") {
            tags.push(newElements);
            continue;
          }
          const removeUndefined = newElements.filter((el) => {
            const isUndefined = el === "<undefined>" || el === "</undefined>";
            return !isUndefined;
          });
          for (const element of removeUndefined) {
            tags.push(element);
          }
        }
      }
    }
  }
  if (!selfClosing) tags.push(`</${name}>`);
  return tags;
};
const prepareCommentParaIds = (comment) => {
  const newComment = {
    ...comment,
    commentParaId: generateRandom32BitHex()
  };
  return newComment;
};
const getCommentDefinition = (comment, commentId, allComments, editor) => {
  const translatedText = translator$1N.decode({ editor, node: comment.commentJSON });
  const attributes = {
    "w:id": String(commentId),
    "w:author": comment.creatorName || comment.importedAuthor?.name,
    "w:email": comment.creatorEmail || comment.importedAuthor?.email,
    "w:date": toIsoNoFractional(comment.createdTime),
    "w:initials": getInitials(comment.creatorName),
    "w:done": comment.resolvedTime ? "1" : "0",
    "w15:paraId": comment.commentParaId,
    "custom:internalId": comment.commentId || comment.internalId,
    "custom:trackedChange": comment.trackedChange,
    "custom:trackedChangeText": comment.trackedChangeText || null,
    "custom:trackedChangeType": comment.trackedChangeType,
    "custom:trackedDeletedText": comment.deletedText || null
  };
  if (comment?.parentCommentId) {
    const parentComment = allComments.find((c) => c.commentId === comment.parentCommentId);
    if (parentComment && !parentComment.trackedChange) {
      attributes["w15:paraIdParent"] = parentComment.commentParaId;
    }
  }
  return {
    type: "element",
    name: "w:comment",
    attributes,
    elements: [translatedText]
  };
};
const getInitials = (name) => {
  if (!name) return null;
  const preparedText = name.replace("(imported)", "").trim();
  const initials = preparedText.split(" ").map((word) => word[0]).join("");
  return initials;
};
const toIsoNoFractional = (unixMillis) => {
  const date = new Date(unixMillis || Date.now());
  return date.toISOString().replace(/\.\d{3}Z$/, "Z");
};
const updateCommentsXml = (commentDefs = [], commentsXml) => {
  const newCommentsXml = carbonCopy(commentsXml);
  commentDefs.forEach((commentDef) => {
    const paraNode = commentDef.elements[0];
    if (!paraNode.attributes) paraNode.attributes = {};
    const elements = paraNode.elements;
    elements.unshift(COMMENT_REF);
    const paraId = commentDef.attributes["w15:paraId"];
    paraNode.attributes["w14:paraId"] = paraId;
    commentDef.attributes = {
      "w:id": commentDef.attributes["w:id"],
      "w:author": commentDef.attributes["w:author"],
      "w:email": commentDef.attributes["w:email"],
      "w:date": commentDef.attributes["w:date"],
      "w:initials": commentDef.attributes["w:initials"],
      "custom:internalId": commentDef.attributes["custom:internalId"],
      "custom:trackedChange": commentDef.attributes["custom:trackedChange"],
      "custom:trackedChangeText": commentDef.attributes["custom:trackedChangeText"],
      "custom:trackedChangeType": commentDef.attributes["custom:trackedChangeType"],
      "custom:trackedDeletedText": commentDef.attributes["custom:trackedDeletedText"],
      "xmlns:custom": "http://schemas.openxmlformats.org/wordprocessingml/2006/main"
    };
  });
  newCommentsXml.elements[0].elements = commentDefs;
  return newCommentsXml;
};
const determineExportStrategy = (comments) => {
  if (!comments || comments.length === 0) {
    return "word";
  }
  const origins = new Set(comments.map((c) => c.origin || "word"));
  if (origins.size === 1) {
    const origin = origins.values().next().value;
    return origin === "google-docs" ? "google-docs" : "word";
  }
  return "word";
};
const resolveThreadingStyle = (comment, threadingProfile) => {
  if (comment?.threadingStyleOverride) return comment.threadingStyleOverride;
  if (threadingProfile?.defaultStyle) return threadingProfile.defaultStyle;
  return comment?.originalXmlStructure?.hasCommentsExtended ? "commentsExtended" : "range-based";
};
const updateCommentsExtendedXml = (comments = [], commentsExtendedXml, threadingProfile = null) => {
  if (!commentsExtendedXml) {
    return null;
  }
  const exportStrategy = typeof threadingProfile === "string" ? threadingProfile : "word";
  const profile = typeof threadingProfile === "string" ? null : threadingProfile;
  const hasThreadedComments = comments.some((comment) => comment.threadingParentCommentId || comment.parentCommentId);
  const shouldGenerateCommentsExtended = profile ? profile.defaultStyle === "commentsExtended" || profile.mixed || comments.some((comment) => resolveThreadingStyle(comment, profile) === "commentsExtended") : exportStrategy !== "google-docs";
  const shouldIncludeForThreads = hasThreadedComments;
  if (!shouldGenerateCommentsExtended && !shouldIncludeForThreads) {
    return null;
  }
  const xmlCopy = carbonCopy(commentsExtendedXml);
  const commentsEx = comments.map((comment) => {
    const isResolved = comment.resolvedTime || comment.isDone;
    const attributes = {
      "w15:paraId": comment.commentParaId,
      "w15:done": isResolved ? "1" : "0"
    };
    const parentId = comment.threadingParentCommentId || comment.parentCommentId;
    const threadingStyle = resolveThreadingStyle(comment, profile);
    if (parentId && (threadingStyle === "commentsExtended" || shouldIncludeForThreads)) {
      const parentComment = comments.find((c) => c.commentId === parentId);
      const allowTrackedParent = profile?.defaultStyle === "commentsExtended";
      if (parentComment && (allowTrackedParent || !parentComment.trackedChange)) {
        attributes["w15:paraIdParent"] = parentComment.commentParaId;
      }
    }
    return {
      type: "element",
      name: "w15:commentEx",
      attributes
    };
  });
  xmlCopy.elements[0].elements = commentsEx;
  return xmlCopy;
};
const updateCommentsIdsAndExtensible = (comments = [], commentsIds, extensible) => {
  const documentIdsUpdated = carbonCopy(commentsIds);
  const extensibleUpdated = carbonCopy(extensible);
  documentIdsUpdated.elements[0].elements = [];
  extensibleUpdated.elements[0].elements = [];
  comments.forEach((comment) => {
    const newDurableId = generateRandom32BitHex();
    const newCommentIdDef = {
      type: "element",
      name: "w16cid:commentId",
      attributes: {
        "w16cid:paraId": comment.commentParaId,
        "w16cid:durableId": newDurableId
      }
    };
    documentIdsUpdated.elements[0].elements.push(newCommentIdDef);
    const newExtensible = {
      type: "element",
      name: "w16cex:commentExtensible",
      attributes: {
        "w16cex:durableId": newDurableId,
        "w16cex:dateUtc": toIsoNoFractional(comment.createdTime)
      }
    };
    extensibleUpdated.elements[0].elements.push(newExtensible);
  });
  return {
    documentIdsUpdated,
    extensibleUpdated
  };
};
const generateConvertedXmlWithCommentFiles = (convertedXml, fileSet = null) => {
  const newXml = carbonCopy(convertedXml);
  newXml["word/comments.xml"] = COMMENTS_XML_DEFINITIONS.COMMENTS_XML_DEF;
  const includeExtensible = fileSet ? fileSet.hasCommentsExtensible : true;
  const includeIds = fileSet ? fileSet.hasCommentsIds : true;
  newXml["word/commentsExtended.xml"] = COMMENTS_XML_DEFINITIONS.COMMENTS_EXTENDED_XML_DEF;
  if (includeExtensible) newXml["word/commentsExtensible.xml"] = COMMENTS_XML_DEFINITIONS.COMMENTS_EXTENSIBLE_XML_DEF;
  if (includeIds) newXml["word/commentsIds.xml"] = COMMENTS_XML_DEFINITIONS.COMMENTS_IDS_XML_DEF;
  newXml["[Content_Types].xml"] = COMMENTS_XML_DEFINITIONS.CONTENT_TYPES;
  return newXml;
};
const removeCommentsFilesFromConvertedXml = (convertedXml) => {
  const updatedXml = carbonCopy(convertedXml);
  delete updatedXml["word/comments.xml"];
  delete updatedXml["word/commentsExtended.xml"];
  delete updatedXml["word/commentsExtensible.xml"];
  delete updatedXml["word/commentsIds.xml"];
  return updatedXml;
};
const generateRelationship = (target) => {
  const relsDefault = COMMENTS_XML_DEFINITIONS.DOCUMENT_RELS_XML_DEF.elements[0].elements;
  const rel = relsDefault.find((rel2) => rel2.attributes.Target === target);
  return { ...rel };
};
const prepareCommentsXmlFilesForExport = ({
  convertedXml,
  defs,
  commentsWithParaIds,
  exportType,
  threadingProfile
}) => {
  const relationships = [];
  if (exportType === "clean") {
    const documentXml = removeCommentsFilesFromConvertedXml(convertedXml);
    return { documentXml, relationships };
  }
  const exportStrategy = determineExportStrategy(commentsWithParaIds);
  const updatedXml = generateConvertedXmlWithCommentFiles(convertedXml, threadingProfile?.fileSet);
  updatedXml["word/comments.xml"] = updateCommentsXml(defs, updatedXml["word/comments.xml"]);
  relationships.push(generateRelationship("comments.xml"));
  const commentsExtendedXml = updateCommentsExtendedXml(
    commentsWithParaIds,
    updatedXml["word/commentsExtended.xml"],
    threadingProfile || exportStrategy
  );
  if (commentsExtendedXml !== null) {
    updatedXml["word/commentsExtended.xml"] = commentsExtendedXml;
    relationships.push(generateRelationship("commentsExtended.xml"));
  } else {
    delete updatedXml["word/commentsExtended.xml"];
  }
  if (updatedXml["word/commentsIds.xml"] && updatedXml["word/commentsExtensible.xml"]) {
    const { documentIdsUpdated, extensibleUpdated } = updateCommentsIdsAndExtensible(
      commentsWithParaIds,
      updatedXml["word/commentsIds.xml"],
      updatedXml["word/commentsExtensible.xml"]
    );
    updatedXml["word/commentsIds.xml"] = documentIdsUpdated;
    updatedXml["word/commentsExtensible.xml"] = extensibleUpdated;
    relationships.push(generateRelationship("commentsIds.xml"));
    relationships.push(generateRelationship("commentsExtensible.xml"));
  }
  return {
    relationships,
    documentXml: updatedXml
  };
};
const HYPERLINK_RELATIONSHIP_TYPE = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink";
const HEADER_RELATIONSHIP_TYPE = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header";
const FOOTER_RELATIONSHIP_TYPE = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer";
const REL_ID_NUMERIC_PATTERN = /rId|mi/g;
const getLargestRelationshipId = (relationships = []) => {
  const numericIds = relationships.map((rel) => Number(String(rel?.attributes?.Id ?? "").replace(REL_ID_NUMERIC_PATTERN, ""))).filter((value) => Number.isFinite(value));
  return numericIds.length ? Math.max(...numericIds) : 0;
};
const mergeRelationshipElements = (existingRelationships = [], newRelationships = []) => {
  if (!newRelationships?.length) {
    return existingRelationships;
  }
  let largestId = getLargestRelationshipId(existingRelationships);
  const seenIds = new Set(existingRelationships.map((rel) => rel?.attributes?.Id).filter(Boolean));
  for (const rel of newRelationships) {
    const id = rel?.attributes?.Id;
    if (!id || seenIds.has(id)) continue;
    const numeric = Number(String(id).replace(REL_ID_NUMERIC_PATTERN, ""));
    if (Number.isFinite(numeric) && numeric > largestId) largestId = numeric;
  }
  const additions = [];
  newRelationships.forEach((rel) => {
    if (!rel?.attributes) return;
    const attributes = rel.attributes;
    const currentId = attributes.Id || "";
    attributes.Target = attributes?.Target?.replace(/&/g, "&amp;");
    const existingTarget = existingRelationships.find((el) => el.attributes.Target === attributes.Target);
    const isNewHyperlink = attributes.Type === HYPERLINK_RELATIONSHIP_TYPE && currentId.length > 6;
    const isNewHeadFoot = (attributes.Type === HEADER_RELATIONSHIP_TYPE || attributes.Type === FOOTER_RELATIONSHIP_TYPE) && currentId.length > 6;
    const hasSeenId = currentId && seenIds.has(currentId);
    if (!isNewHyperlink && !isNewHeadFoot && existingTarget) return;
    if (!currentId || hasSeenId) {
      let candidate = Math.max(largestId, 1);
      while (seenIds.has(`rId${candidate}`)) {
        candidate += 1;
      }
      attributes.Id = `rId${candidate}`;
      largestId = candidate;
    } else {
      const numeric = Number(String(currentId).replace(REL_ID_NUMERIC_PATTERN, ""));
      if (Number.isFinite(numeric) && numeric > largestId) largestId = numeric;
    }
    seenIds.add(attributes.Id);
    additions.push(rel);
  });
  const result = additions.length ? [...existingRelationships, ...additions] : existingRelationships;
  return result;
};
const RELS_XMLNS = "http://schemas.openxmlformats.org/package/2006/relationships";
const FOOTNOTES_RELS_PATH = "word/_rels/footnotes.xml.rels";
const paragraphHasFootnoteRef = (node) => {
  if (!node) return false;
  if (node.name === "w:footnoteRef") return true;
  const children = Array.isArray(node.elements) ? node.elements : [];
  return children.some((child) => paragraphHasFootnoteRef(child));
};
const insertFootnoteRefIntoParagraph = (paragraph) => {
  if (!paragraph || paragraph.name !== "w:p") return;
  if (!Array.isArray(paragraph.elements)) paragraph.elements = [];
  if (paragraphHasFootnoteRef(paragraph)) return;
  const footnoteRef = { type: "element", name: "w:footnoteRef", elements: [] };
  const footnoteRefRun = {
    type: "element",
    name: "w:r",
    elements: [
      {
        type: "element",
        name: "w:rPr",
        elements: [{ type: "element", name: "w:rStyle", attributes: { "w:val": "FootnoteReference" } }]
      },
      footnoteRef
    ]
  };
  const pPrIndex = paragraph.elements.findIndex((el) => el?.name === "w:pPr");
  const insertAt = pPrIndex >= 0 ? pPrIndex + 1 : 0;
  paragraph.elements.splice(insertAt, 0, footnoteRefRun);
};
const ensureFootnoteRefMarker = (elements) => {
  if (!Array.isArray(elements)) return;
  const firstParagraphIndex = elements.findIndex((el) => el?.name === "w:p");
  if (firstParagraphIndex >= 0) {
    insertFootnoteRefIntoParagraph(elements[firstParagraphIndex]);
    return;
  }
  const paragraph = {
    type: "element",
    name: "w:p",
    elements: []
  };
  insertFootnoteRefIntoParagraph(paragraph);
  elements.unshift(paragraph);
};
const translateFootnoteContent = (content, exportContext) => {
  if (!Array.isArray(content) || content.length === 0) return [];
  const translated = [];
  content.forEach((node) => {
    if (!node) return;
    const result = exportSchemaToJson({ ...exportContext, node });
    if (Array.isArray(result)) {
      result.filter(Boolean).forEach((entry) => translated.push(entry));
      return;
    }
    if (result) translated.push(result);
  });
  return translated;
};
const createFootnoteElement = (footnote, exportContext) => {
  if (!footnote) return null;
  const { id, content, type: type2, originalXml } = footnote;
  if ((type2 === "separator" || type2 === "continuationSeparator") && originalXml) {
    return carbonCopy(originalXml);
  }
  const attributes = { "w:id": String(id) };
  if (type2) attributes["w:type"] = type2;
  const translatedContent = translateFootnoteContent(content, exportContext);
  const originalHadFootnoteRef = originalXml ? paragraphHasFootnoteRef(originalXml) : true;
  if (originalHadFootnoteRef) {
    ensureFootnoteRefMarker(translatedContent);
  }
  const base = originalXml ? carbonCopy(originalXml) : {
    type: "element",
    name: "w:footnote",
    attributes: {},
    elements: []
  };
  base.attributes = { ...base.attributes || {}, ...attributes };
  base.elements = translatedContent;
  return base;
};
const applyFootnotePropertiesToSettings = (converter, convertedXml) => {
  const props = converter?.footnoteProperties;
  if (!props || props.source !== "settings" || !props.originalXml) {
    return convertedXml;
  }
  const settingsXml = convertedXml["word/settings.xml"];
  const settingsRoot = settingsXml?.elements?.[0];
  if (!settingsRoot) return convertedXml;
  const updatedSettings = carbonCopy(settingsXml);
  const updatedRoot = updatedSettings.elements?.[0];
  if (!updatedRoot) return convertedXml;
  const elements = Array.isArray(updatedRoot.elements) ? updatedRoot.elements : [];
  const nextElements = elements.filter((el) => el?.name !== "w:footnotePr");
  nextElements.push(carbonCopy(props.originalXml));
  updatedRoot.elements = nextElements;
  return { ...convertedXml, "word/settings.xml": updatedSettings };
};
const buildFootnotesRelsXml = (converter, convertedXml, relationships) => {
  if (!relationships.length) return null;
  const existingRels = convertedXml[FOOTNOTES_RELS_PATH];
  const existingRoot = existingRels?.elements?.find((el) => el.name === "Relationships");
  const existingElements = Array.isArray(existingRoot?.elements) ? existingRoot.elements : [];
  const merged = mergeRelationshipElements(existingElements, relationships);
  const declaration = existingRels?.declaration ?? converter?.initialJSON?.declaration;
  const relsXml = {
    ...declaration ? { declaration } : {},
    elements: [
      {
        name: "Relationships",
        attributes: { xmlns: RELS_XMLNS },
        elements: merged
      }
    ]
  };
  return relsXml;
};
const prepareFootnotesXmlForExport = ({ footnotes, editor, converter, convertedXml }) => {
  let updatedXml = applyFootnotePropertiesToSettings(converter, convertedXml);
  if (!footnotes || !Array.isArray(footnotes) || footnotes.length === 0) {
    return { updatedXml, relationships: [], media: {} };
  }
  const footnoteRelationships = [];
  const footnoteMedia = {};
  const exportContext = {
    editor,
    editorSchema: editor?.schema,
    converter,
    relationships: footnoteRelationships,
    media: footnoteMedia
  };
  const footnoteElements = footnotes.map((fn) => createFootnoteElement(fn, exportContext)).filter(Boolean);
  if (footnoteElements.length === 0) {
    return { updatedXml, relationships: [], media: footnoteMedia };
  }
  let footnotesXml = updatedXml["word/footnotes.xml"];
  if (!footnotesXml) {
    footnotesXml = carbonCopy(FOOTNOTES_XML_DEF);
  } else {
    footnotesXml = carbonCopy(footnotesXml);
  }
  if (footnotesXml.elements && footnotesXml.elements[0]) {
    footnotesXml.elements[0].elements = footnoteElements;
  }
  updatedXml = { ...updatedXml, "word/footnotes.xml": footnotesXml };
  if (footnoteRelationships.length > 0) {
    const footnotesRelsXml = buildFootnotesRelsXml(converter, updatedXml, footnoteRelationships);
    if (footnotesRelsXml) {
      updatedXml = { ...updatedXml, [FOOTNOTES_RELS_PATH]: footnotesRelsXml };
    }
  }
  const relationships = [
    {
      type: "element",
      name: "Relationship",
      attributes: {
        Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footnotes",
        Target: "footnotes.xml"
      }
    }
  ];
  return { updatedXml, relationships, media: footnoteMedia };
};
const FONT_FAMILY_FALLBACKS = Object.freeze({
  swiss: "Arial, sans-serif",
  roman: "Times New Roman, serif",
  modern: "Courier New, monospace",
  script: "cursive",
  decorative: "fantasy",
  system: "system-ui",
  auto: "sans-serif"
});
const DEFAULT_GENERIC_FALLBACK = "sans-serif";
const DEFAULT_FONT_SIZE_PT = 10;
const collectRunDefaultProperties = (runProps, { allowOverrideTypeface = true, allowOverrideSize = true, themeResolver, state: state2 }) => {
  if (!runProps?.elements?.length || !state2) return;
  const fontsNode = runProps.elements.find((el) => el.name === "w:rFonts");
  if (fontsNode?.attributes) {
    const themeName = fontsNode.attributes["w:asciiTheme"];
    if (themeName) {
      const themeInfo = themeResolver?.(themeName) || {};
      if ((allowOverrideTypeface || !state2.typeface) && themeInfo.typeface) state2.typeface = themeInfo.typeface;
      if ((allowOverrideTypeface || !state2.panose) && themeInfo.panose) state2.panose = themeInfo.panose;
    }
    const ascii = fontsNode.attributes["w:ascii"];
    if ((allowOverrideTypeface || !state2.typeface) && ascii) {
      state2.typeface = ascii;
    }
  }
  const sizeNode = runProps.elements.find((el) => el.name === "w:sz");
  if (sizeNode?.attributes?.["w:val"]) {
    const sizeTwips = Number(sizeNode.attributes["w:val"]);
    if (Number.isFinite(sizeTwips)) {
      if (state2.fallbackSzTwips === void 0) state2.fallbackSzTwips = sizeTwips;
      const sizePt = sizeTwips / 2;
      if (allowOverrideSize || state2.fontSizePt === void 0) state2.fontSizePt = sizePt;
    }
  }
  const kernNode = runProps.elements.find((el) => el.name === "w:kern");
  if (kernNode?.attributes?.["w:val"]) {
    if (allowOverrideSize || state2.kern === void 0) state2.kern = kernNode.attributes["w:val"];
  }
};
const _SuperConverter = class _SuperConverter {
  constructor(params = null) {
    __privateAdd(this, _SuperConverter_instances);
    this.debug = params?.debug || false;
    this.domEnvironment = {
      mockWindow: params?.mockWindow || null,
      mockDocument: params?.mockDocument || null
    };
    this.declaration = null;
    this.documentAttributes = null;
    this.convertedXml = {};
    this.docx = params?.docx || [];
    this.media = params?.media || {};
    this.fonts = params?.fonts || {};
    this.addedMedia = {};
    this.comments = [];
    this.footnotes = [];
    this.footnoteProperties = null;
    this.inlineDocumentFonts = [];
    this.commentThreadingProfile = null;
    this.docHiglightColors = /* @__PURE__ */ new Set([]);
    this.xml = params?.xml;
    this.declaration = null;
    this.numbering = {};
    this.translatedNumbering = {};
    this.numbering = null;
    this.pageStyles = null;
    this.themeColors = null;
    this.initialJSON = null;
    this.headers = {};
    this.headerIds = { default: null, even: null, odd: null, first: null };
    this.headerEditors = [];
    this.footers = {};
    this.footerIds = { default: null, even: null, odd: null, first: null };
    this.footerEditors = [];
    this.importedBodyHasHeaderRef = false;
    this.importedBodyHasFooterRef = false;
    this.headerFooterModified = false;
    this.linkedStyles = [];
    this.translatedLinkedStyles = {};
    this.json = params?.json;
    this.tagsNotInSchema = ["w:body"];
    this.savedTagsToRestore = [];
    this.documentInternalId = null;
    this.fileSource = params?.fileSource || null;
    this.documentId = params?.documentId || null;
    this.documentGuid = null;
    this.documentHash = null;
    this.documentModified = false;
    if (this.docx.length || this.xml) this.parseFromXml();
  }
  static getFontTableEntry(docx, fontName) {
    if (!docx || !fontName) return null;
    const fontTable = docx["word/fontTable.xml"];
    if (!fontTable?.elements?.length) return null;
    const fontsNode = fontTable.elements.find((el) => el.name === "w:fonts");
    if (!fontsNode?.elements?.length) return null;
    return fontsNode.elements.find((el) => el?.attributes?.["w:name"] === fontName) || null;
  }
  static getFallbackFromFontTable(docx, fontName) {
    const fontEntry = _SuperConverter.getFontTableEntry(docx, fontName);
    const family = fontEntry?.elements?.find((child) => child.name === "w:family")?.attributes?.["w:val"];
    if (!family) return null;
    const mapped = FONT_FAMILY_FALLBACKS[family.toLowerCase()];
    return mapped || DEFAULT_GENERIC_FALLBACK;
  }
  static toCssFontFamily(fontName, docx) {
    if (!fontName) return fontName;
    if (fontName.includes(",")) return fontName;
    const fallback = _SuperConverter.getFallbackFromFontTable(docx, fontName) || DEFAULT_GENERIC_FALLBACK;
    const normalizedFallbackParts = fallback.split(",").map((part) => part.trim().toLowerCase()).filter(Boolean);
    if (normalizedFallbackParts.includes(fontName.trim().toLowerCase())) {
      return fallback;
    }
    return `${fontName}, ${fallback}`;
  }
  /**
   * Get the DocxHelpers object that contains utility functions for working with docx files.
   * @returns {import('./docx-helpers/docx-helpers.js').DocxHelpers} The DocxHelpers object.
   */
  get docxHelpers() {
    return DocxHelpers;
  }
  parseFromXml() {
    this.docx?.forEach((file) => {
      this.convertedXml[file.name] = this.parseXmlToJson(file.content);
      if (file.name === "word/document.xml") {
        this.documentAttributes = this.convertedXml[file.name].elements[0]?.attributes;
      }
      if (file.name === "word/styles.xml") {
        this.convertedXml[file.name] = addDefaultStylesIfMissing(this.convertedXml[file.name]);
      }
    });
    this.initialJSON = this.convertedXml["word/document.xml"];
    if (!this.initialJSON) this.initialJSON = this.parseXmlToJson(this.xml);
    this.declaration = this.initialJSON?.declaration;
    this.resolveDocumentGuid();
  }
  /**
   * Parses XML content into JSON format while preserving whitespace-only text runs.
   *
   * This method wraps xml-js's xml2json parser with additional preprocessing to prevent
   * the parser from dropping whitespace-only content in <w:t> and <w:delText> elements.
   * This is critical for correctly handling documents that rely on document-level
   * xml:space="preserve" rather than per-element attributes, which is common in
   * PDF-to-DOCX converted documents.
   *
   * The whitespace preservation strategy:
   * 1. Before parsing, wraps whitespace-only content with [[sdspace]] placeholders
   * 2. xml-js parser preserves the placeholder-wrapped text
   * 3. During text node processing (t-translator.js), placeholders are removed
   *
   * @param {string} xml - The XML string to parse
   * @returns {Object} The parsed JSON representation of the XML document
   *
   * @example
   * // Handles whitespace-only text runs
   * const xml = '<w:t> </w:t>';
   * const result = parseXmlToJson(xml);
   * // Result preserves the space: { elements: [{ text: '[[sdspace]] [[sdspace]]' }] }
   *
   * @example
   * // Handles elements with attributes
   * const xml = '<w:t xml:space="preserve">  text  </w:t>';
   * const result = parseXmlToJson(xml);
   * // Preserves content and attributes
   *
   * @example
   * // Handles both w:t and w:delText elements
   * const xml = '<w:delText> </w:delText>';
   * const result = parseXmlToJson(xml);
   * // Preserves whitespace in deleted text
   */
  parseXmlToJson(xml) {
    const newXml = xml.replace(
      /(<w:(?:t|delText)(?:\s[^>]*)?>)(\s+)(<\/w:(?:t|delText)>)/g,
      "$1[[sdspace]]$2[[sdspace]]$3"
    );
    return JSON.parse(libExports.xml2json(newXml, null, 2));
  }
  /**
   * Checks if an element name matches the expected local name, with or without namespace prefix.
   * This helper supports custom namespace prefixes in DOCX files (e.g., 'op:Properties', 'custom:property').
   *
   * @private
   * @static
   * @param {string|undefined|null} elementName - The element name to check (may include namespace prefix)
   * @param {string} expectedLocalName - The expected local name without prefix
   * @returns {boolean} True if the element name matches (with or without prefix)
   *
   * @example
   * // Exact match without prefix
   * _matchesElementName('Properties', 'Properties') // => true
   *
   * @example
   * // Match with namespace prefix
   * _matchesElementName('op:Properties', 'Properties') // => true
   * _matchesElementName('custom:property', 'property') // => true
   *
   * @example
   * // No match
   * _matchesElementName('SomeOtherElement', 'Properties') // => false
   * _matchesElementName(':Properties', 'Properties') // => false (empty prefix)
   */
  static _matchesElementName(elementName, expectedLocalName) {
    if (!elementName || typeof elementName !== "string") return false;
    if (!expectedLocalName) return false;
    if (elementName === expectedLocalName) return true;
    if (elementName.endsWith(`:${expectedLocalName}`)) {
      const prefix = elementName.slice(0, -(expectedLocalName.length + 1));
      return prefix.length > 0;
    }
    return false;
  }
  /**
   * Extracts the namespace prefix from an element name.
   *
   * @private
   * @static
   * @param {string} elementName - The element name (may include namespace prefix, e.g., 'op:Properties')
   * @returns {string} The namespace prefix (e.g., 'op') or empty string if no prefix
   *
   * @example
   * _extractNamespacePrefix('op:Properties') // => 'op'
   * _extractNamespacePrefix('Properties') // => ''
   * _extractNamespacePrefix('custom:property') // => 'custom'
   */
  static _extractNamespacePrefix(elementName) {
    if (!elementName || typeof elementName !== "string") return "";
    const colonIndex = elementName.indexOf(":");
    return colonIndex > 0 ? elementName.slice(0, colonIndex) : "";
  }
  /**
   * Generic method to get a stored custom property from docx.
   * Supports both standard and custom namespace prefixes (e.g., 'op:Properties', 'custom:property').
   *
   * @static
   * @param {Array} docx - Array of docx file objects
   * @param {string} propertyName - Name of the property to retrieve
   * @returns {string|null} The property value or null if not found
   *
   * Returns null in the following cases:
   * - docx array is empty or doesn't contain 'docProps/custom.xml'
   * - custom.xml cannot be parsed
   * - Properties element is not found (with or without namespace prefix)
   * - Property with the specified name is not found
   * - Property has malformed structure (missing nested elements or text)
   * - Any error occurs during parsing or retrieval
   *
   * @example
   * // Standard property without namespace prefix
   * const version = SuperConverter.getStoredCustomProperty(docx, 'SuperdocVersion');
   * // => '1.2.3'
   *
   * @example
   * // Property with namespace prefix (e.g., from Office 365)
   * const guid = SuperConverter.getStoredCustomProperty(docx, 'DocumentGuid');
   * // Works with both 'Properties' and 'op:Properties' elements
   * // => 'abc-123-def-456'
   *
   * @example
   * // Non-existent property
   * const missing = SuperConverter.getStoredCustomProperty(docx, 'NonExistent');
   * // => null
   */
  static getStoredCustomProperty(docx, propertyName) {
    try {
      const customXml = docx.find((doc2) => doc2.name === "docProps/custom.xml");
      if (!customXml) return null;
      const converter = new _SuperConverter();
      const content = customXml.content;
      const contentJson = converter.parseXmlToJson(content);
      const properties = contentJson?.elements?.find((el) => _SuperConverter._matchesElementName(el.name, "Properties"));
      if (!properties?.elements) return null;
      const property = properties.elements.find(
        (el) => _SuperConverter._matchesElementName(el.name, "property") && el.attributes?.name === propertyName
      );
      if (!property) return null;
      if (!property.elements?.[0]?.elements?.[0]?.text) {
        console.warn(`Malformed property structure for "${propertyName}"`);
        return null;
      }
      return property.elements[0].elements[0].text;
    } catch (e) {
      console.warn(`Error getting custom property ${propertyName}:`, e);
      return null;
    }
  }
  /**
   * Generic method to set a stored custom property in docx.
   * Supports both standard and custom namespace prefixes (e.g., 'op:Properties', 'custom:property').
   *
   * @static
   * @param {Object} docx - The docx object to store the property in (converted XML structure)
   * @param {string} propertyName - Name of the property
   * @param {string|Function} value - Value or function that returns the value
   * @param {boolean} preserveExisting - If true, won't overwrite existing values
   * @returns {string|null} The stored value, or null if Properties element is not found
   *
   * @throws {Error} If an error occurs during property setting (logged as warning)
   *
   * @example
   * // Set a new property
   * const value = SuperConverter.setStoredCustomProperty(docx, 'MyProperty', 'MyValue');
   * // => 'MyValue'
   *
   * @example
   * // Set a property with a function
   * const guid = SuperConverter.setStoredCustomProperty(docx, 'DocumentGuid', () => uuidv4());
   * // => 'abc-123-def-456'
   *
   * @example
   * // Preserve existing value
   * SuperConverter.setStoredCustomProperty(docx, 'MyProperty', 'NewValue', true);
   * // => 'MyValue' (original value preserved)
   *
   * @example
   * // Works with namespace prefixes
   * // If docx has 'op:Properties' and 'op:property' elements, this will handle them correctly
   * const version = SuperConverter.setStoredCustomProperty(docx, 'Version', '2.0.0');
   * // => '2.0.0'
   */
  static setStoredCustomProperty(docx, propertyName, value, preserveExisting = false) {
    try {
      const customLocation = "docProps/custom.xml";
      if (!docx[customLocation]) docx[customLocation] = generateCustomXml();
      const customXml = docx[customLocation];
      const properties = customXml.elements?.find((el) => _SuperConverter._matchesElementName(el.name, "Properties"));
      if (!properties) return null;
      if (!properties.elements) properties.elements = [];
      const namespacePrefix = _SuperConverter._extractNamespacePrefix(properties.name);
      const propertyElementName = namespacePrefix ? `${namespacePrefix}:property` : "property";
      let property = properties.elements.find(
        (el) => _SuperConverter._matchesElementName(el.name, "property") && el.attributes?.name === propertyName
      );
      if (property && preserveExisting) {
        if (!property.elements?.[0]?.elements?.[0]?.text) {
          console.warn(`Malformed existing property structure for "${propertyName}"`);
          return null;
        }
        return property.elements[0].elements[0].text;
      }
      const finalValue = typeof value === "function" ? value() : value;
      if (!property) {
        const existingPids = properties.elements.filter((el) => el.attributes?.pid).map((el) => parseInt(el.attributes.pid, 10)).filter(Number.isInteger);
        const pid = existingPids.length > 0 ? Math.max(...existingPids) + 1 : 2;
        property = {
          type: "element",
          name: propertyElementName,
          attributes: {
            name: propertyName,
            fmtid: "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
            pid
          },
          elements: [
            {
              type: "element",
              name: "vt:lpwstr",
              elements: [
                {
                  type: "text",
                  text: finalValue
                }
              ]
            }
          ]
        };
        properties.elements.push(property);
      } else {
        const existingPropertyPrefix = _SuperConverter._extractNamespacePrefix(property.name);
        if (existingPropertyPrefix !== namespacePrefix) {
          property.name = propertyElementName;
        }
        if (!property.elements?.[0]?.elements?.[0]) {
          console.warn(`Malformed property structure for "${propertyName}", recreating structure`);
          property.elements = [
            {
              type: "element",
              name: "vt:lpwstr",
              elements: [
                {
                  type: "text",
                  text: finalValue
                }
              ]
            }
          ];
        } else {
          property.elements[0].elements[0].text = finalValue;
        }
      }
      return finalValue;
    } catch (e) {
      console.warn(`Error setting custom property ${propertyName}:`, e);
      return null;
    }
  }
  static getStoredSuperdocVersion(docx) {
    return _SuperConverter.getStoredCustomProperty(docx, "SuperdocVersion");
  }
  static setStoredSuperdocVersion(docx = this.convertedXml, version = "1.9.0-next.5") {
    return _SuperConverter.setStoredCustomProperty(docx, "SuperdocVersion", version, false);
  }
  /**
   * Get document GUID from docx files (static method)
   * @static
   * @param {Array} docx - Array of docx file objects
   * @returns {string|null} The document GUID
   */
  static extractDocumentGuid(docx) {
    try {
      const settingsXml = docx.find((doc2) => doc2.name === "word/settings.xml");
      if (!settingsXml) return null;
      const converter = new _SuperConverter();
      const settingsJson = converter.parseXmlToJson(settingsXml.content);
      const settings = settingsJson.elements?.[0];
      if (!settings) return null;
      const docIdElement = settings.elements?.find((el) => el.name === "w15:docId");
      if (docIdElement?.attributes?.["w15:val"]) {
        return docIdElement.attributes["w15:val"].replace(/[{}]/g, "");
      }
    } catch {
    }
    return _SuperConverter.getStoredCustomProperty(docx, "DocumentGuid");
  }
  /**
   * Get the permanent document GUID
   * @returns {string|null} The document GUID (only for modified documents)
   */
  getDocumentGuid() {
    return this.documentGuid;
  }
  /**
   * Get the SuperDoc version for this converter instance
   * @returns {string|null} The SuperDoc version or null if not available
   */
  getSuperdocVersion() {
    if (this.docx) {
      return _SuperConverter.getStoredSuperdocVersion(this.docx);
    }
    return null;
  }
  /**
   * Resolve existing document GUID (synchronous)
   */
  resolveDocumentGuid() {
    const microsoftGuid = this.getMicrosoftDocId();
    if (microsoftGuid) {
      this.documentGuid = microsoftGuid;
      return;
    }
    const customGuid = _SuperConverter.getStoredCustomProperty(this.docx, "DocumentGuid");
    if (customGuid) {
      this.documentGuid = customGuid;
    }
  }
  /**
   * Get Microsoft's docId from settings.xml (READ ONLY)
   */
  getMicrosoftDocId() {
    this.getDocumentInternalId();
    if (this.documentInternalId) {
      return this.documentInternalId.replace(/[{}]/g, "");
    }
    return null;
  }
  /**
   * Get document identifier (GUID or hash) - async for lazy hash generation
   */
  async getDocumentIdentifier() {
    if (this.documentGuid) {
      return this.documentGuid;
    }
    if (!this.documentHash && this.fileSource) {
      this.documentHash = await __privateMethod(this, _SuperConverter_instances, generateDocumentHash_fn).call(this);
    }
    return this.documentHash;
  }
  /**
   * Promote from hash to GUID on first edit
   */
  promoteToGuid() {
    if (this.documentGuid) return this.documentGuid;
    this.documentGuid = this.getMicrosoftDocId() || v4();
    this.documentModified = true;
    this.documentHash = null;
    return this.documentGuid;
  }
  getDocumentDefaultStyles() {
    const styles = this.convertedXml["word/styles.xml"];
    const styleRoot = styles?.elements?.[0];
    const styleElements = styleRoot?.elements || [];
    if (!styleElements.length) return {};
    const defaults = styleElements.find((el) => el.name === "w:docDefaults");
    const normalStyle = styleElements.find((el) => el.name === "w:style" && el.attributes?.["w:styleId"] === "Normal");
    const defaultsState = {
      typeface: void 0,
      panose: void 0,
      fontSizePt: void 0,
      kern: void 0,
      fallbackSzTwips: void 0
    };
    const docDefaultRun = defaults?.elements?.find((el) => el.name === "w:rPrDefault");
    const docDefaultProps = docDefaultRun?.elements?.find((el) => el.name === "w:rPr") ?? docDefaultRun;
    collectRunDefaultProperties(docDefaultProps, {
      allowOverrideTypeface: true,
      allowOverrideSize: true,
      themeResolver: (theme) => this.getThemeInfo(theme),
      state: defaultsState
    });
    const normalRunProps = normalStyle?.elements?.find((el) => el.name === "w:rPr") ?? null;
    collectRunDefaultProperties(normalRunProps, {
      allowOverrideTypeface: true,
      allowOverrideSize: true,
      themeResolver: (theme) => this.getThemeInfo(theme),
      state: defaultsState
    });
    if (defaultsState.fontSizePt === void 0) {
      if (Number.isFinite(defaultsState.fallbackSzTwips)) defaultsState.fontSizePt = defaultsState.fallbackSzTwips / 2;
      else defaultsState.fontSizePt = DEFAULT_FONT_SIZE_PT;
    }
    const fontFamilyCss = defaultsState.typeface ? _SuperConverter.toCssFontFamily(defaultsState.typeface, this.convertedXml) : void 0;
    const result = {};
    if (defaultsState.fontSizePt !== void 0) result.fontSizePt = defaultsState.fontSizePt;
    if (defaultsState.kern !== void 0) result.kern = defaultsState.kern;
    if (defaultsState.typeface) result.typeface = defaultsState.typeface;
    if (defaultsState.panose) result.panose = defaultsState.panose;
    if (fontFamilyCss) result.fontFamilyCss = fontFamilyCss;
    return result;
  }
  getDocumentFonts() {
    const inlineDocumentFonts = [...new Set(this.inlineDocumentFonts || [])];
    const defaults = this.getDocumentDefaultStyles?.() || {};
    const defaultTypeface = typeof defaults.typeface === "string" ? defaults.typeface : null;
    const defaultFontFamilyCss = typeof defaults.fontFamilyCss === "string" ? defaults.fontFamilyCss : null;
    const fallbackFont = defaultTypeface || (defaultFontFamilyCss ? defaultFontFamilyCss.split(",")[0]?.replace(/["']/g, "").trim() : null);
    const withDefaultFont = (fonts) => {
      const result = [...fonts];
      if (fallbackFont && !result.includes(fallbackFont)) result.push(fallbackFont);
      return result;
    };
    const fontTable = this.convertedXml["word/fontTable.xml"];
    if (!fontTable) {
      return withDefaultFont(inlineDocumentFonts);
    }
    const wFonts = fontTable.elements?.find((element) => element.name === "w:fonts");
    if (!wFonts) {
      return withDefaultFont(inlineDocumentFonts);
    }
    if (!wFonts.elements) {
      return withDefaultFont(inlineDocumentFonts);
    }
    const fontsInFontTable = wFonts.elements.filter((element) => element.name === "w:font").map((element) => element.attributes["w:name"]);
    const allFonts = [...inlineDocumentFonts, ...fontsInFontTable];
    return withDefaultFont([...new Set(allFonts)]);
  }
  getFontFaceImportString() {
    const fontTable = this.convertedXml["word/fontTable.xml"];
    if (!fontTable || !Object.keys(this.fonts).length) return;
    const fonts = fontTable.elements.find((el) => el.name === "w:fonts");
    const embededFonts = fonts?.elements.filter(
      (el) => el.elements?.some((nested) => nested?.attributes && nested.attributes["r:id"] && nested.attributes["w:fontKey"])
    );
    const fontsToInclude = embededFonts?.reduce((acc, cur) => {
      const embedElements = cur.elements.filter((el) => el.name.startsWith("w:embed"))?.map((el) => ({ ...el, fontFamily: cur.attributes["w:name"] }));
      return [...acc, ...embedElements];
    }, []);
    const rels = this.convertedXml["word/_rels/fontTable.xml.rels"];
    const relationships = rels?.elements.find((el) => el.name === "Relationships") || {};
    const { elements } = relationships;
    const fontsImported = [];
    let styleString = "";
    for (const font of fontsToInclude) {
      const filePath = elements.find((el) => el.attributes.Id === font.attributes["r:id"])?.attributes?.Target;
      if (!filePath) return;
      const fontUint8Array = this.fonts[`word/${filePath}`];
      const fontBuffer = fontUint8Array?.buffer;
      if (!fontBuffer) return;
      const ttfBuffer = deobfuscateFont(fontBuffer, font.attributes["w:fontKey"]);
      if (!ttfBuffer) return;
      const blob = new Blob([ttfBuffer], { type: "font/ttf" });
      const fontUrl = URL.createObjectURL(blob);
      const isNormal = font.name.includes("Regular");
      const isBold = font.name.includes("Bold");
      const isItalic = font.name.includes("Italic");
      const isLight = font.name.includes("Light");
      const fontWeight = isNormal ? "normal" : isBold ? "bold" : isLight ? "200" : "normal";
      if (!fontsImported.includes(font.fontFamily)) {
        fontsImported.push(font.fontFamily);
      }
      styleString += `
        @font-face {
          font-style: ${isItalic ? "italic" : "normal"};
          font-weight: ${fontWeight};
          font-display: swap;
          font-family: ${font.fontFamily};
          src: url(${fontUrl}) format('truetype');
        }
      `;
    }
    return {
      styleString,
      fontsImported
    };
  }
  getDocumentInternalId() {
    const settingsLocation = "word/settings.xml";
    if (!this.convertedXml[settingsLocation]) {
      return;
    }
    const settings = this.convertedXml[settingsLocation];
    if (!settings.elements?.[0]?.elements?.length) {
      return;
    }
    const w15DocId = settings.elements[0].elements.find((el) => el.name === "w15:docId");
    this.documentInternalId = w15DocId?.attributes?.["w15:val"];
  }
  createDocumentIdElement() {
    const docId = v4().toUpperCase();
    this.documentInternalId = docId;
    return {
      type: "element",
      name: "w15:docId",
      attributes: {
        "w15:val": `{${docId}}`
      }
    };
  }
  getThemeInfo(themeName) {
    themeName = themeName.toLowerCase();
    const theme1 = this.convertedXml["word/theme/theme1.xml"];
    if (!theme1) return {};
    const themeData = theme1.elements.find((el) => el.name === "a:theme");
    const themeElements = themeData.elements.find((el) => el.name === "a:themeElements");
    const fontScheme = themeElements.elements.find((el) => el.name === "a:fontScheme");
    let fonts;
    if (themeName.startsWith("major")) {
      fonts = fontScheme.elements.find((el) => el.name === "a:majorFont").elements[0];
    } else if (themeName.startsWith("minor")) {
      fonts = fontScheme.elements.find((el) => el.name === "a:minorFont").elements[0];
    }
    const { typeface, panose } = fonts.attributes;
    return { typeface, panose };
  }
  getSchema(editor) {
    let result;
    try {
      this.getDocumentInternalId();
      if (!this.convertedXml.media) {
        this.convertedXml.media = this.media;
      }
      result = createDocumentJson(this.convertedXml, this, editor);
    } catch (error) {
      editor?.emit("exception", { error, editor });
    }
    if (result) {
      this.savedTagsToRestore.push({ ...result.savedTagsToRestore });
      this.pageStyles = result.pageStyles;
      this.numbering = result.numbering;
      this.comments = result.comments;
      this.footnotes = result.footnotes;
      this.linkedStyles = result.linkedStyles;
      this.translatedLinkedStyles = result.translatedLinkedStyles;
      this.translatedNumbering = result.translatedNumbering;
      this.inlineDocumentFonts = result.inlineDocumentFonts;
      this.themeColors = result.themeColors ?? null;
      return result.pmDoc;
    } else {
      return null;
    }
  }
  schemaToXml(data, debug = false) {
    const exporter = new DocxExporter(this);
    return exporter.schemaToXml(data, debug);
  }
  async exportToDocx(jsonData, editorSchema, documentMedia, isFinalDoc = false, commentsExportType, comments = [], editor, exportJsonOnly = false, fieldsHighlightColor) {
    const exportableComments = comments.filter((c) => !c.trackedChange);
    const commentsWithParaIds = exportableComments.map((c) => prepareCommentParaIds(c));
    const commentDefinitions = commentsWithParaIds.map(
      (c, index2) => getCommentDefinition(c, index2, commentsWithParaIds, editor)
    );
    const { result, params } = this.exportToXmlJson({
      data: jsonData,
      editorSchema,
      comments: exportableComments,
      commentDefinitions,
      commentsExportType,
      isFinalDoc,
      editor,
      fieldsHighlightColor
    });
    if (exportJsonOnly) return result;
    const exporter = new DocxExporter(this);
    const xml = exporter.schemaToXml(result);
    const {
      updatedXml: footnotesUpdatedXml,
      relationships: footnotesRels,
      media: footnotesMedia
    } = prepareFootnotesXmlForExport({
      footnotes: this.footnotes,
      editor,
      converter: this,
      convertedXml: this.convertedXml
    });
    this.convertedXml = { ...this.convertedXml, ...footnotesUpdatedXml };
    await __privateMethod(this, _SuperConverter_instances, exportProcessMediaFiles_fn).call(this, {
      ...documentMedia,
      ...params.media,
      ...footnotesMedia,
      ...this.media
    }, editor);
    let updatedXml = { ...this.convertedXml };
    let commentsRels = [];
    if (comments.length) {
      const { documentXml, relationships } = __privateMethod(this, _SuperConverter_instances, prepareCommentsXmlFilesForExport_fn).call(this, {
        defs: params.exportedCommentDefs,
        exportType: commentsExportType,
        commentsWithParaIds
      });
      updatedXml = { ...documentXml };
      commentsRels = relationships;
    }
    this.convertedXml = { ...this.convertedXml, ...updatedXml };
    const headFootRels = __privateMethod(this, _SuperConverter_instances, exportProcessHeadersFooters_fn).call(this, { isFinalDoc });
    __privateMethod(this, _SuperConverter_instances, exportProcessNewRelationships_fn).call(this, [...params.relationships, ...commentsRels, ...footnotesRels, ...headFootRels]);
    _SuperConverter.setStoredSuperdocVersion(this.convertedXml);
    if (this.documentModified || this.documentGuid) {
      if (!this.documentGuid) {
        this.documentGuid = this.getMicrosoftDocId() || v4();
      }
      _SuperConverter.setStoredCustomProperty(this.convertedXml, "DocumentGuid", this.documentGuid, true);
    }
    __privateMethod(this, _SuperConverter_instances, exportNumberingFile_fn).call(this, params);
    return xml;
  }
  exportToXmlJson({
    data,
    editorSchema,
    comments,
    commentDefinitions,
    commentsExportType = "clean",
    isFinalDoc = false,
    editor,
    isHeaderFooter = false,
    fieldsHighlightColor = null
  }) {
    const bodyNode = this.savedTagsToRestore.find((el) => el.name === "w:body");
    const [result, params] = exportSchemaToJson({
      node: data,
      bodyNode,
      relationships: [],
      documentMedia: {},
      media: {},
      isFinalDoc,
      editorSchema,
      converter: this,
      pageStyles: this.pageStyles,
      comments,
      commentsExportType,
      exportedCommentDefs: commentDefinitions,
      editor,
      isHeaderFooter,
      fieldsHighlightColor
    });
    return { result, params };
  }
  /**
   * Creates a default empty header for the specified variant.
   *
   * This method programmatically creates a new header section with an empty ProseMirror
   * document. The header is added to the converter's data structures and will be included
   * in subsequent DOCX exports.
   *
   * @param {('default' | 'first' | 'even' | 'odd')} variant - The header variant to create
   * @returns {string} The relationship ID of the created header
   *
   * @throws {Error} If variant is invalid or header already exists for this variant
   *
   * @example
   * ```javascript
   * const headerId = converter.createDefaultHeader('default');
   * // headerId: 'rId-header-default'
   * // converter.headers['rId-header-default'] contains empty PM doc
   * // converter.headerIds.default === 'rId-header-default'
   * ```
   */
  createDefaultHeader(variant = "default") {
    if (typeof variant !== "string") {
      throw new TypeError(`variant must be a string, received ${typeof variant}`);
    }
    const validVariants = ["default", "first", "even", "odd"];
    if (!validVariants.includes(variant)) {
      throw new Error(`Invalid header variant: ${variant}. Must be one of: ${validVariants.join(", ")}`);
    }
    if (this.headerIds[variant]) {
      console.warn(`[SuperConverter] Header already exists for variant '${variant}': ${this.headerIds[variant]}`);
      return this.headerIds[variant];
    }
    const rId = `rId-header-${variant}`;
    const emptyDoc = {
      type: "doc",
      content: [
        {
          type: "paragraph",
          content: []
        }
      ]
    };
    this.headers[rId] = emptyDoc;
    this.headerIds[variant] = rId;
    if (!this.headerIds.ids) {
      this.headerIds.ids = [];
    }
    if (!this.headerIds.ids.includes(rId)) {
      this.headerIds.ids.push(rId);
    }
    this.headerFooterModified = true;
    this.documentModified = true;
    return rId;
  }
  /**
   * Creates a default empty footer for the specified variant.
   *
   * This method programmatically creates a new footer section with an empty ProseMirror
   * document. The footer is added to the converter's data structures and will be included
   * in subsequent DOCX exports.
   *
   * @param {('default' | 'first' | 'even' | 'odd')} variant - The footer variant to create
   * @returns {string} The relationship ID of the created footer
   *
   * @throws {Error} If variant is invalid or footer already exists for this variant
   *
   * @example
   * ```javascript
   * const footerId = converter.createDefaultFooter('default');
   * // footerId: 'rId-footer-default'
   * // converter.footers['rId-footer-default'] contains empty PM doc
   * // converter.footerIds.default === 'rId-footer-default'
   * ```
   */
  createDefaultFooter(variant = "default") {
    if (typeof variant !== "string") {
      throw new TypeError(`variant must be a string, received ${typeof variant}`);
    }
    const validVariants = ["default", "first", "even", "odd"];
    if (!validVariants.includes(variant)) {
      throw new Error(`Invalid footer variant: ${variant}. Must be one of: ${validVariants.join(", ")}`);
    }
    if (this.footerIds[variant]) {
      console.warn(`[SuperConverter] Footer already exists for variant '${variant}': ${this.footerIds[variant]}`);
      return this.footerIds[variant];
    }
    const rId = `rId-footer-${variant}`;
    const emptyDoc = {
      type: "doc",
      content: [
        {
          type: "paragraph",
          content: []
        }
      ]
    };
    this.footers[rId] = emptyDoc;
    this.footerIds[variant] = rId;
    if (!this.footerIds.ids) {
      this.footerIds.ids = [];
    }
    if (!this.footerIds.ids.includes(rId)) {
      this.footerIds.ids.push(rId);
    }
    this.headerFooterModified = true;
    this.documentModified = true;
    return rId;
  }
  // Deprecated methods for backward compatibility
  static getStoredSuperdocId(docx) {
    console.warn("getStoredSuperdocId is deprecated, use getDocumentGuid instead");
    return _SuperConverter.extractDocumentGuid(docx);
  }
  static updateDocumentVersion(docx, version) {
    console.warn("updateDocumentVersion is deprecated, use setStoredSuperdocVersion instead");
    return _SuperConverter.setStoredSuperdocVersion(docx, version);
  }
};
_SuperConverter_instances = new WeakSet();
generateDocumentHash_fn = async function() {
  if (!this.fileSource) return `HASH-${Date.now()}`;
  try {
    let buffer2;
    if (Buffer2.isBuffer(this.fileSource)) {
      buffer2 = this.fileSource;
    } else if (this.fileSource instanceof ArrayBuffer) {
      buffer2 = Buffer2.from(this.fileSource);
    } else if (this.fileSource instanceof Blob || this.fileSource instanceof File) {
      const arrayBuffer = await this.fileSource.arrayBuffer();
      buffer2 = Buffer2.from(arrayBuffer);
    } else {
      return `HASH-${Date.now()}`;
    }
    const hash = index(buffer2);
    return `HASH-${hash.toString("hex").toUpperCase()}`;
  } catch (e) {
    console.warn("Could not generate document hash:", e);
    return `HASH-${Date.now()}`;
  }
};
exportNumberingFile_fn = function() {
  const numberingPath = "word/numbering.xml";
  let numberingXml = this.convertedXml[numberingPath];
  const newNumbering = this.numbering;
  if (!numberingXml) numberingXml = baseNumbering;
  const currentNumberingXml = numberingXml.elements[0];
  const newAbstracts = Object.values(newNumbering.abstracts).map((entry) => entry);
  const newNumDefs = Object.values(newNumbering.definitions).map((entry) => entry);
  currentNumberingXml.elements = [...newAbstracts, ...newNumDefs];
  this.convertedXml[numberingPath] = numberingXml;
};
/**
 * Update comments files and relationships depending on export type
 */
prepareCommentsXmlFilesForExport_fn = function({ defs, exportType, commentsWithParaIds }) {
  const { documentXml, relationships } = prepareCommentsXmlFilesForExport({
    exportType,
    convertedXml: this.convertedXml,
    defs,
    commentsWithParaIds,
    threadingProfile: this.commentThreadingProfile
  });
  return { documentXml, relationships };
};
exportProcessHeadersFooters_fn = function({ isFinalDoc = false }) {
  const relsData = this.convertedXml["word/_rels/document.xml.rels"];
  const relationships = relsData.elements.find((x2) => x2.name === "Relationships");
  const newDocRels = [];
  Object.entries(this.headers).forEach(([id, header], index2) => {
    const fileName = relationships.elements.find((el) => el.attributes.Id === id)?.attributes.Target || `header${index2 + 1}.xml`;
    const headerEditor = this.headerEditors.find((item) => item.id === id);
    if (!headerEditor) return;
    const { result, params } = this.exportToXmlJson({
      data: header,
      editor: headerEditor.editor,
      editorSchema: headerEditor.editor.schema,
      comments: [],
      commentDefinitions: [],
      isHeaderFooter: true,
      isFinalDoc
    });
    const bodyContent = result.elements[0].elements;
    const file = this.convertedXml[`word/${fileName}`];
    if (!file) {
      this.convertedXml[`word/${fileName}`] = {
        declaration: this.initialJSON?.declaration,
        elements: [
          {
            attributes: DEFAULT_DOCX_DEFS,
            name: "w:hdr",
            type: "element",
            elements: []
          }
        ]
      };
      newDocRels.push({
        type: "element",
        name: "Relationship",
        attributes: {
          Id: id,
          Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header",
          Target: fileName
        }
      });
    }
    this.convertedXml[`word/${fileName}`].elements[0].elements = bodyContent;
    if (params.relationships.length) {
      const relationships2 = this.convertedXml[`word/_rels/${fileName}.rels`]?.elements?.find((x2) => x2.name === "Relationships")?.elements || [];
      this.convertedXml[`word/_rels/${fileName}.rels`] = {
        declaration: this.initialJSON?.declaration,
        elements: [
          {
            name: "Relationships",
            attributes: {
              xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
            },
            elements: [...relationships2, ...params.relationships]
          }
        ]
      };
    }
  });
  Object.entries(this.footers).forEach(([id, footer], index2) => {
    const fileName = relationships.elements.find((el) => el.attributes.Id === id)?.attributes.Target || `footer${index2 + 1}.xml`;
    const footerEditor = this.footerEditors.find((item) => item.id === id);
    if (!footerEditor) return;
    const { result, params } = this.exportToXmlJson({
      data: footer,
      editor: footerEditor.editor,
      editorSchema: footerEditor.editor.schema,
      comments: [],
      commentDefinitions: [],
      isHeaderFooter: true,
      isFinalDoc
    });
    const bodyContent = result.elements[0].elements;
    const file = this.convertedXml[`word/${fileName}`];
    if (!file) {
      this.convertedXml[`word/${fileName}`] = {
        declaration: this.initialJSON?.declaration,
        elements: [
          {
            attributes: DEFAULT_DOCX_DEFS,
            name: "w:ftr",
            type: "element",
            elements: []
          }
        ]
      };
      newDocRels.push({
        type: "element",
        name: "Relationship",
        attributes: {
          Id: id,
          Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer",
          Target: fileName
        }
      });
    }
    this.convertedXml[`word/${fileName}`].elements[0].elements = bodyContent;
    if (params.relationships.length) {
      const relationships2 = this.convertedXml[`word/_rels/${fileName}.rels`]?.elements?.find((x2) => x2.name === "Relationships")?.elements || [];
      this.convertedXml[`word/_rels/${fileName}.rels`] = {
        declaration: this.initialJSON?.declaration,
        elements: [
          {
            name: "Relationships",
            attributes: {
              xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
            },
            elements: [...relationships2, ...params.relationships]
          }
        ]
      };
    }
  });
  return newDocRels;
};
exportProcessNewRelationships_fn = function(rels = []) {
  const relsData = this.convertedXml["word/_rels/document.xml.rels"];
  const relationships = relsData.elements.find((x2) => x2.name === "Relationships");
  relationships.elements = mergeRelationshipElements(relationships.elements, rels);
};
exportProcessMediaFiles_fn = async function(media = {}) {
  const processedData = {
    ...this.convertedXml.media || {}
  };
  for (const [filePath, value] of Object.entries(media)) {
    if (value == null) continue;
    processedData[filePath] = await getArrayBufferFromUrl(value);
  }
  this.convertedXml.media = processedData;
  this.media = this.convertedXml.media;
  this.addedMedia = {
    ...processedData
  };
};
__publicField(_SuperConverter, "allowedElements", Object.freeze({
  "w:document": "doc",
  "w:body": "body",
  "w:p": "paragraph",
  "w:r": "run",
  "w:t": "text",
  "w:delText": "text",
  "w:br": "lineBreak",
  "w:tbl": "table",
  "w:tr": "tableRow",
  "w:tc": "tableCell",
  "w:drawing": "drawing",
  "w:bookmarkStart": "bookmarkStart",
  // 'w:tab': 'tab',
  // Formatting only
  "w:sectPr": "sectionProperties",
  "w:rPr": "runProperties",
  // Comments
  "w:commentRangeStart": "commentRangeStart",
  "w:commentRangeEnd": "commentRangeEnd",
  "w:commentReference": "commentReference"
}));
__publicField(_SuperConverter, "markTypes", [
  { name: "w:b", type: "bold", property: "value" },
  // { name: 'w:bCs', type: 'bold' },
  { name: "w:i", type: "italic" },
  // { name: 'w:iCs', type: 'italic' },
  { name: "w:u", type: "underline", mark: "underline", property: "underlineType" },
  { name: "w:strike", type: "strike", mark: "strike", property: "value" },
  { name: "w:color", type: "color", mark: "textStyle", property: "color" },
  { name: "w:sz", type: "fontSize", mark: "textStyle", property: "fontSize" },
  // { name: 'w:szCs', type: 'fontSize', mark: 'textStyle', property: 'fontSize' },
  { name: "w:rFonts", type: "fontFamily", mark: "textStyle", property: "fontFamily" },
  { name: "w:rStyle", type: "styleId", mark: "textStyle", property: "styleId" },
  { name: "w:jc", type: "textAlign", mark: "textStyle", property: "textAlign" },
  { name: "w:ind", type: "textIndent", mark: "textStyle", property: "textIndent" },
  { name: "w:spacing", type: "lineHeight", mark: "textStyle", property: "lineHeight" },
  { name: "w:spacing", type: "letterSpacing", mark: "textStyle", property: "letterSpacing" },
  { name: "link", type: "link", mark: "link", property: "href" },
  { name: "w:highlight", type: "highlight", mark: "highlight", property: "color" },
  { name: "w:shd", type: "highlight", mark: "highlight", property: "color" },
  { name: "w:caps", type: "textTransform", mark: "textStyle", property: "textTransform" }
]);
__publicField(_SuperConverter, "propertyTypes", Object.freeze({
  "w:pPr": "paragraphProperties",
  "w:rPr": "runProperties",
  "w:sectPr": "sectionProperties",
  "w:numPr": "numberingProperties",
  "w:tcPr": "tableCellProperties"
}));
__publicField(_SuperConverter, "elements", /* @__PURE__ */ new Set(["w:document", "w:body", "w:p", "w:r", "w:t", "w:delText"]));
let SuperConverter = _SuperConverter;
function generateCustomXml() {
  return DEFAULT_CUSTOM_XML;
}
export {
  getSchemaTypeByName as $,
  AllSelection as A,
  Buffer2 as B,
  isNodeActive as C,
  DOMSerializer as D,
  deleteProps as E,
  Fragment as F,
  processContent as G,
  htmlHandler as H,
  ReplaceStep as I,
  twipsToInches as J,
  inchesToTwips as K,
  ptToTwips as L,
  Mapping as M,
  NodeSelection as N,
  getResolvedParagraphProperties as O,
  PluginKey as P,
  linesToTwips as Q,
  ReplaceAroundStep as R,
  Selection as S,
  TextSelection as T,
  changeListLevel as U,
  findParentNode as V,
  isList as W,
  updateNumberingProperties as X,
  ListHelpers as Y,
  isMacOS as Z,
  isIOS as _,
  Plugin as a,
  inputRulesPlugin as a0,
  TrackDeleteMarkName as a1,
  TrackInsertMarkName as a2,
  TrackFormatMarkName as a3,
  comments_module_events as a4,
  objectIncludes as a5,
  AddMarkStep as a6,
  RemoveMarkStep as a7,
  findMark as a8,
  twipsToLines as a9,
  encodeCSSFromPPr as aA,
  twipsToPixels as aB,
  encodeCSSFromRPr as aC,
  generateOrderedListIndex as aD,
  docxNumberingHelpers as aE,
  InputRule as aF,
  convertSizeToCSS as aG,
  findParentNodeClosestToPos as aH,
  isInTable as aI,
  generateDocxRandomId as aJ,
  insertNewRelationship as aK,
  inchesToPixels as aL,
  kebabCase as aM,
  getUnderlineCssString as aN,
  commonjsGlobal as aO,
  getDefaultExportFromCjs$2 as aP,
  getContentTypesFromXml as aQ,
  libExports as aR,
  vClickOutside as aS,
  getActiveFormatting as aT,
  getFileObject as aU,
  registeredHandlers as aV,
  pixelsToTwips as aa,
  helpers as ab,
  posToDOMRect as ac,
  resolveOpcTargetPath as ad,
  getArrayBufferFromUrl as ae,
  CommandService as af,
  SuperConverter as ag,
  createDocument as ah,
  createDocFromMarkdown as ai,
  createDocFromHTML as aj,
  EditorState as ak,
  isActive as al,
  unflattenListsInHtml as am,
  SelectionRange as an,
  Transform as ao,
  resolveParagraphProperties as ap,
  resolveDocxFontFamily as aq,
  _getReferencedTableStyles as ar,
  decodeRPrFromMarks as as,
  halfPointToPoints as at,
  parseSizeUnit as au,
  minMax as av,
  updateDOMAttributes as aw,
  findChildren as ax,
  generateRandomSigned32BitIntStrId as ay,
  calculateResolvedParagraphProperties as az,
  Slice as b,
  callOrGet as c,
  DOMParser$1 as d,
  Mark as e,
  dropPoint as f,
  getExtensionConfigField as g,
  getMarkType as h,
  getMarksFromSelection as i,
  getNodeType as j,
  getSchemaTypeNameByName as k,
  Schema$1 as l,
  cleanSchemaItem as m,
  canSplit as n,
  defaultBlockAt as o,
  process$1 as p,
  encodeMarksFromRPr as q,
  resolveRunProperties as r,
  liftTarget as s,
  canJoin as t,
  joinPoint as u,
  v4 as v,
  replaceStep as w,
  isTextSelection as x,
  getMarkRange as y,
  isMarkActive as z
};
